# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
contact@jan-baumgaertner.tech.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.
# Contributing to TriP
We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's:

- Reporting a bug
- Discussing the current state of the code
- Submitting a fix
- Proposing new features
- Becoming a maintainer

or just spotting spelling mistakes in the documentation.

## We Develop with Github
We use github to host code, to track issues and feature requests, as well as accept pull requests.

## We Use [Github Flow](https://guides.github.com/introduction/flow/index.html), So All Code Changes Happen Through Pull Requests
Pull requests are the best way to propose changes to the codebase (we use [Github Flow](https://guides.github.com/introduction/flow/index.html)). We actively welcome your pull requests:

1. Fork the repo and create your branch from `master`.
2. If you've added code that should be tested, add tests.
3. If you've changed APIs, update the documentation.
4. Ensure the test suite passes.
5. Make sure your code lints.
6. Issue that pull request!

## Any contributions you make will be under the MIT Software License
In short, when you submit code changes, your submissions are understood to be under the same [MIT License](http://choosealicense.com/licenses/mit/) that covers the project. Feel free to contact the maintainers if that's a concern.

## Report bugs using Github's [issues](https://github.com/briandk/transcriptase-atom/issues)
We use GitHub issues to track public bugs. Report a bug by [opening a new issue](); it's that easy!

## Write bug reports with detail, background, and sample code
[This is an example](http://stackoverflow.com/q/12488905/180626) of a bug report I wrote, and I think it's not a bad model. Here's [another example from Craig Hockenberry](http://www.openradar.me/11905408), an app developer whom I greatly respect.

**Great Bug Reports** tend to have:

- A quick summary and/or background
- Steps to reproduce
  - Be specific!
  - Give sample code if you can. [My stackoverflow question](http://stackoverflow.com/q/12488905/180626) includes sample code that *anyone* with a base R setup can run to reproduce what I was seeing
- What you expected would happen
- What actually happens
- Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)

People *love* thorough bug reports. I'm not even kidding.

## Use a Consistent Coding Style
We strive to follow the [PEP 8](https://www.python.org/dev/peps/pep-0008/) code style.
Creating a new pull request will also automatically trigger a [code-inspector](https://www.code-inspector.com/) review.
It will also check for mayor style inconsistencies.

## License
By contributing, you agree that your contributions will be licensed under its MIT License.

## References
This document was adapted from the open-source contribution guidelines of  [briandk](https://gist.github.com/briandk/3d2e8b3ec8daf5a27a62#file-contributing-md)
![trip_logo](docs/source/trip_logo.svg)

[![Code Grade](https://api.codiga.io/project/29339/score/svg)](https://frontend.code-inspector.com/project/29339/dashboard) 
[![codecov](https://codecov.io/gh/TriPed-Robot/TriP/branch/main/graph/badge.svg?token=T6TMY8CD8M)](https://codecov.io/gh/TriPed-Robot/TriP)
[![Documentation Status](https://readthedocs.org/projects/trip-kinematics/badge/?version=main)](https://trip-kinematics.readthedocs.io/en/main/?badge=main)
![example workflow](https://github.com/TriPed-Robot/TriP/actions/workflows/python-package.yml//badge.svg)
[![DOI](https://joss.theoj.org/papers/10.21105/joss.03967/status.svg)](https://doi.org/10.21105/joss.03967)
# TriP
TriP is a python library designed to calculate the forward- and inverse-kinematics of rigid mechanisms.

This includes open chains, closed chains, and even combinations of both.



## Features

- Model any robot (including closed and hybrid chains)
- Generate symbolic representations of forward kinematics
- Compute Jacobian matrices for differential kinematics
- Compute the inverse kinematics of arbitrary rigid mechanisms
- Compute the Inverse Kinematics in position and/or orientation 
- Support arbitrary joint types and quaternions
- Includes several ready to use examples (TriPed robot, Excavator Arm)
- TriPs validates the inverse kinematics algorithms with extensive testing using analytic solutions.

## Installation

Installing the latest release (recommended):
```
pip install trip-kinematics
```

Installing the newest version from source:
```
git clone https://github.com/TriPed-Robot/trip_kinematics
cd trip_kinematics
pip install src/
```

## Documentation
The documentation can be found [here](https://trip-kinematics.readthedocs.io/en/main/)

## How to cite this library
If you find this work useful please give credits to the authors by citing:

* Baumgärtner et al., (2022). TriP: A Python package for the kinematic modeling of serial-parallel hybrid robots. Journal of Open Source Software, 7(71), 3967, https://doi.org/10.21105/joss.03967

```
@article{Baumgärtner2022,
  doi = {10.21105/joss.03967},
  url = {https://doi.org/10.21105/joss.03967},
  year = {2022},
  publisher = {The Open Journal},
  volume = {7},
  number = {71},
  pages = {3967},
  author = {Jan Baumgärtner and Torben Miller},
  title = {TriP: A Python package for the kinematic modeling of serial-parallel hybrid robots},
  journal = {Journal of Open Source Software}
}
```


 
These reference values where calulated using the Matlab Simulation of the TriPed which can be found [here](https://triped-robot.github.io/docs/matlab_about/)
Results of Inverse Kinematics tests performed using the CCDSolver on the Robot will show up in this folder.
The results can be visualized with the functions in the plot_kinematics.py  script.Results of Inverse Kinematics tests performed using the SimpleInvSolver on the Robot will show up in this folder.
The results can be visualized with the functions in the plot_kinematics.py  script.# Errors

    Class: TransformationParameters

        Description: TransformationParameters have mixed keys from euler and quaternion
        Msg: "State can't have euler angles and quaternions!"


        Description: State-keys given to constructor are not present in the given values
        Msg: "Key(s) from stateVariables not present inside values"


    Class: KinematicGroup

        Description: At initializing you have to give either actuated_state,actuated_to_virtual and virtual_to_actuated or neither.
        Msg: "For actuated states a forward and an inverse mapping are required."

        Description: The actuated_to_virtual has to return a state that fits the virtual_state
        Msg: "actuated_to_virtual does not fit virtual state"

        Description: The virtual_to_actuated hast to return a state that fits the actuated_state
        Msg:"virtual_to_actuated does not fit actuated state"

    at set_state

        Description the given state has to match either the virtual_state or the actuated_state
        Msg: "State does not match!"

        Class: TransformationMatrix

        Description: For the convention parameter there is something other specified than quat or any permutation of xyz
        Msg: "ConventionError: Expect x,y,z got: "

Warnings:

    Class: KinematicGroup

        Description: If the initalvalues of the virtual_state do not match the values calculated when first running the actuated_to_virtual
        Msg: "Calculated state values do not match given values! Using set_state() before forward_kinematics() or inverse_kinematics() is recommended"
######################
How TriP models Robots
######################

TriP models robots using the :class:`Robot` class.
A robot object is made up of :class:`Transformation` and :class:`KinematicGroup` objects.
The :class:`KinematicGroup` objects are used to model closed chains.

The following sections will explain the :class:`Transformation`, :class:`KinematicGroup` and :class:`Robot` objects in more detail.
It is advised to read these sections before using them to model robots.

The last section also explains how Kinematic Solvers work.

****************
Transformations
****************

A Kinematic model is made up of Coordinate systems.
These coordinate systems are connected by transformations.

TriP implements its own :class:`.Transformation` class.

One can distinguish between static transformations and dynamic transformations.
Dynamic transformations change depending on an internal state thereby modeling the joints of a mechanism.

.. TODO zuerst mehr auf Struktur der Transformation class eingehen!

The :class:`.Transformation` class has an attribute that manages the internal state.

Transformation Descriptions
===========================

In general, states can influence the transformation in arbitrary ways.
Yet robotics uses several standard conventions.

The :class:`.Transormation` class currently supports the following conventions:

* translation with Euler angle rotation
* translation with quaternion rotation
.. * Denavit Hartenberg 



Translation with Euler Angles rotation
--------------------------------------
This convention is perhaps the most natural and intuitive.
In this convention, the transformation is specified using 6 parameters `[tx ty tz rx ry rz]`.
These parameters have the following interpretation:

========== ===============================================
parameter  interpretation
========== ===============================================
tx         moves the coordinate system along the x-axis
ty         moves the coordinate system along the y-axis
tz         moves the coordinate system along the z-axis
rx         rotates the coordinate system around the x-axis
ry         rotates the coordinate system around the y-axis
rz         rotates the coordinate system around the z-axis
========== ===============================================

.. important::
    In this convention, rotation is always applied before translation.

    The Euler angles follow the `XYZ` convention.
    This means that the transformation first rotates around x, then around y, and lastly around z.
    This convention is also called Roll, Pitch, and Yaw. Here rx=Roll, ry=Pitch, and rz=Yaw.


This transformation is captured by the following transformation matrix:

.. math::
    \begin{pmatrix} \cos{rz}\cos{ry} & \cos{rz}\sin{ry}\sin{rx} - \sin{rz}\cos{rx} & \cos{rz}\sin{ry}\cos{rx} + \sin{rz}\sin{rx} & t_x \\
                    \sin{rz}\cos{ry} & \sin{rz}\sin{ry}\sin{rx} + \cos{rz}\cos{rx} & \sin{rz}\sin{ry}\cos{rx} - \cos{rz}\sin{rx} & t_y \\
                    -\sin{ry}        & \cos{ry}\sin{rx}                            & \cos{ry}\cos{rx}                            & t_z \\
                    0                & 0                                           & 0                                           & 1 \end{pmatrix}

The definition of joints in this convention is very straightforward, below is a sample list of different joints:

.. image:: images/sample_transformations.png
 :alt: sample_joints

Note that while all non specified parameters are assumed to be zero, the value of each `state_variable` still has to be supplied.

Translation with Quaternion rotation
------------------------------------
Quaternions are an alternative four-dimensional description of rotation.
They have many advantages compared to Euler angles, which are explained `here <https://en.wikipedia.org/wiki/Quaternion>`_ .
However, they trade these advantages for an intuitive interpretation.

========== ===============================================
parameter  interpretation
========== ===============================================
tx         moves the coordinate system along the x-axis
ty         moves the coordinate system along the y-axis
tz         moves the coordinate system along the z-axis
qw         first quaternion, also called a.
qx         second quaternion, also called b.
qy         third quaternion, also called c.
qz         fourth quaternion, also called d.
========== ===============================================


The corresponding matrix is:

.. math::
    \begin{pmatrix} 1-2(q_y^2+q_z^2) & 2(q_xq_y-q_zq_w) &  2(q_xq_z + q_yq_w) & t_x \\
                    2(q_xq_y + q_zq_w) & 1-2(q_x^2+q_z^2) &  2(q_yq_z - q_xq_w) & t_y \\
                    2(q_xq_z-q_yq_w)   & 2(q_yq_z+q_xq_w) &  1-2(q_x^2+q_y^2)  & t_z \\
                    0                & 0                  & 0                   & 1 \end{pmatrix}



.. important:: 
    The matrix only describes a rotation if all quaternions are normalized, meaning :math:`qw^2+qx^2+qy^2+qz^2=1`.
    Since the current inverse kinematics solver does not support constraints this means that quaternions are not supported when calculating inverse kinematics.

..
    Denavit Hartenberg
    ------------------
    The Denavit Hartenberg is a popular although limited description format.
    It requires only 4 parameters to describe a transformation.
    This makes the transformation numerically efficient for inverse kinematic solvers.

    ========== ===============================================
    parameter  interpretation
    ========== ===============================================
    theta      rotates the coordinate system around the z-axis
    d          moves the coordinate system along the z-axis
    a          moves the coordinate system along the x-axis
    alpha      rotates the coordinate system around the x-axis
    ========== ===============================================

    .. important::
        While these parameters perform the same functions as in the first convention the transformations are applied in a different order.
        Namely, the system first rotates around the z-axis, then it moves along it, then it moves along the x-axis, and then it rotates around it.

        The Denavit Hartenberg formulation only works for robots with only one branch from start to finish.
        This includes most robotic arms but excludes for example humanoid robots as each limb is a separate branch. For more information see the next subsection.


    The Denavit Hartenberg transformation is captured by the following matrix:

    .. math::
        \left(\begin{array}{cccc}
        {\cos \theta} & {-\sin \theta \cos \alpha} & {\sin \theta \sin \alpha} & {a \cos \theta} \\
        {\sin \theta} & {\cos \theta \cos \alpha} & {-\cos \theta \sin \alpha} & {a \sin \theta} \\
        {0} & {\sin \alpha} & {\cos \alpha} & {d} \\
        {0} & {0} & {0} & {1}
        \end{array}\right)


Transformation trees
====================

To fully specify the kinematic model of a robot not only the transformations are needed but also
how they are connected.
This is described by the so-called transformation tree.
Conventionally nodes of this tree describe coordinate frames while its edges describe transformations.
An example can be seen down below:

.. image:: images/trafo_tree_coords.png
 :alt: transformation tree with coordinate frames

Here the cursive graph nodes are coordinate frames while the edges are the transformations between them.
Since TriP only models transformations and not coordinate frames in TriP the name of a coordinate frame is synonymous with the name of the transformation leading to it.
This leads to the following simplified transformation tree:

.. image:: images/trafo_tree.png
 :alt: transformation tree

In this tree the edge and the node it leads to refer to the transformation.
TriP builds this simplified transformation tree by specifying the parent of each transformation.
The parent is in this case the transformation that preceded the current transformation.
For the example transformation tree this would look like this:
::
    to_joint_1 = Transformation(name="To Join1")
    joint_1    = Transformation(name="Joint1",values={'ry': 0},state_variables=['ry'],parent=to_joint_1)

    to_joint_2 = Transformation(name="To Joint2",values={'tx':1},parent=joint_1)
    joint_2    = Transformation(name="Joint2",values={'ry': 0},state_variables=['ry'],parent=to_joint_2)
    to_joint_3 = Transformation(name="To Joint3",values={'tx':1},parent=joint_2)
    joint_3    = Transformation(name="Joint3",values={'ry': 0},state_variables=['ry'],parent=to_joint_3)

    to_joint_4 = Transformation(name="To Joint4",values={'tx':1},parent=joint_1)
    joint_4    = Transformation(name="Joint4",values={'ry': 0},state_variables=['ry'],parent=to_joint_4)
    to_joint_5 = Transformation(name="To Joint5",values={'tx':1},parent=joint_4)
    joint_5    = Transformation(name="Joint5",values={'ry': 0},state_variables=['ry'],parent=to_joint_5)

.. important::
    Transformations with no parent are considered connected to the base Frame. Since for most robots, this is where they are connected to the floor this frame is also called Ground.
    This can be seen in transformation ```to_joint_1```. Note that strictly speaking this transformation is necessary since its transformation is an identity matrix.
    It is only included for clarity.

The transformation tree building concept does not work if more than one transformation leads to the same frame.
Here one would have to distinguish between the transformations leading to the frame and the frame itself.
Such a situation is referred to as a closed kinematic chain, the next section will explain how they are modeled in TriP.

****************
Kinematic Groups
****************

Most kinematic libraries rely only on transformation objects because they only model open chains.
An example for this is `IKPY <https://github.com/Phylliade/ikpy>`_ . 
In an open chain, the position and orientation of a coordinate system depend only on one transformation from its parent.


But, consider the excavator arm below:

.. image:: images/excavator_arm.png
 :alt: excavator_arm

.. TODO describe joint drawing conventions

In this example, multiple coordinate systems have more than one parent since the transformations form a loop.

Such a loop is called a closed kinematic chain.

Classically closed chains are modeled using an algebraic closure equation :math:`g(q) = 0`.
The closure equation couples all joint states :math:`q` so that multi transformations leading to the same frame all agree on the state of the frame.

In practice, this is computationally expensive and often entirely unnecessary.

.. important::
    To simplify the system one could treat the system as if the hinges of the excavator's arm were directly actuated.

    This simplified virtual chain contains no closed loops and thus standard kinematics algorithms can be used to compute forward or inverse kinematics.

    To get the solution of the real excavator, one simply has to convert between the state of the hinges and the state of the hydraulic cylinders.
    
    This can be done using some kind of mapping function based on trigonometry.


TriP embraces this mapping approach and implements it using the :class:`.KinematicGroup` class.
A :class:`.KinematicGroup` is made up of a `virtual_chain`, an `actuated_state`, and two mappings.
The mappings convert between the state of the `virtual_chain`, called `virtual_state`, and the state of the actuated joints called `actuated_state`.

.. image:: images/group_structure.png
 :alt: group_structure

.. important::
    The virtual_chain has to be a single open chain without branches.
    The reasons for this will be discussed in the next section

divide a robot into groups
==========================
In the example above the excavator is modeled as a single group.
However, it is also possible to divide the excavator into multiple groups.
These groups can then be combined just like transformations.
Multiple smaller groups have two advantages over a single large group:

For one it improves modularity, making it easier to reuse assembly parts.

But more importantly, it reduced computational cost.
To keep virtual and actuated state consistent mapping has to be called every time part of one state changes.
A single group mechanism would mean updating every state.
This problem is especially bad for branching mechanisms.
Consider a four-legged robot, setting the actuator of one leg would then mean updating all four legs.
To prevent this problem outright the virtual chain can not contain branches.


In summary, groups should be defined as small as possible.
Small in this case refers to the number of actuators that have to be grouped.
The minimum size is defined by the closed chains.
Consider the following mechanism

.. image:: images/closed_chain_group_configs.png
    :alt: group_partitoning

Grouping a) and c) are valid groups, with a) being more performant. 
However the Grouping in b) is not valid. 
The reason is that the state of the top platform depends on the state of all three green prismatic joints.

.. TODO noch auf offene ketten eingehen, warum sind die keine Gruppen?



These considerations lead to the following guidelines for building hybrid robots:

.. important::
    Every closed chain should be modeled by a Group. 
    Every open chain should be modeled by Transformations.  
    Se the following robots as an example:

    .. image:: images/hybrid_chain_taxonomy_groups.png
        :alt: group_partitoning


The excavator has two actuated states and two virtual states.
These are the lengths of hydraulic cylinders :math:`a_1`, :math:`a_2` and the arm angles :math:`q_1`, :math:`q_2`.
Since each cylinder length :math:`a_i` controls one arm angle :math:`q_i`, the excavator can be divided into two groups.
These are visualized by the green and blue parts respectively.

The mappings for each group can be calculated using trigonometry:

.. image:: images/geometric_mapping.png
    :alt: geometric_mapping

The full code for the excavator looks like this:

.. literalinclude:: ../../src/trip_robots/excavator_rr.py
   :language: python
   :linenos:
   :lines: 1-75


actuated state vs virtual state
===============================
If one looks at the code above one can see that the dictionary values of the actuated state in lines 26 and 36 are float values, 
while the values of the virtual states in lines 32 and 39 are dictionaries.

This difference is because virtual states always specify convention parameters of a :class:`Transformation`.
Actuated values on the other hand are not associated with a Transformation and thus don't adhere to transformation conventions.

This is an important difference to keep in mind when dealing with both states.
Below are a few examples of joints and how their actuated and virtual states would differ.


.. image:: images/state_differences_normal.png
    :alt: state_differences_normal

.. image:: images/state_differences.png
    :alt: state_differences



Using closure equations
=======================
While direct mappings are always preferable it is not always possible to find a direct function.
In this case, one can always resort to the closure equation.
Since TriP is based on mappings the closure equation is used to set up mapping functions that solve the closure equation.
For the mapping from actuated state to virtual state, the actuated states are fixed and the virtual states calculated.
Likewise, for the reverse mapping, the virtual state is fixed while the actuated states are calculated.

The setup of the closure equation will require extra transformations.
This can be done by building a full open chain or for simple chains by directly setting up the transformation matrices using the Utility submodule.
In this case of the excavator, the following joints can be defined:

.. image:: images/closure_mapping.png
    :alt: closure_mapping

The solving of the closure equation can be performed by casadi, which TriP also uses for inverse kinematics calculations:

.. literalinclude:: ../../src/trip_robots/excavator_rr.py
   :language: python
   :linenos:
   :lines: 1-36,78-143

.. _virtual_chain_reference_label:

Defining virtual chains
=======================
In the vast majority of cases, the specification of the virtual chain is straightforward.
One simply uses a single chain of transformations that goes from one end of the group to the other.
However, in some cases, this can lead to unintended or suboptimal results.

As a simple example of this problem, think of the excavator arm from above.
Assuming that it had a spherical joint at the elbow, the system would still not be able to move any differently.
However, the virtual open chain which neglects the hydraulic cylinders would suddenly behave much differently.

An inverse kinematics solver might now try to find open chain configurations that are not possible with the full mechanism.


.. warning::
    Since TriP currently does not support Joint limits, it can not detect which open chain configurations are not possible.
    This can lead to solvers failing outright.

This problem can be avoided by designing a custom virtual open chain.
In the case of the excavator this is very simple, just substitute the spherical joint with a revolute joint.
For more complicated robots this might be more complex, a general rule of thumb is:

.. important::
    The virtual open chain should offer the same degrees of freedom as the full mechanism.
    Ideally, the correspondence between virtual joints and actuated joints should be as simple as possible.




******
Robots
******

The Robot class is the centerpiece of TriP, they encapsulate  :class:`.Transormation`  and :class:`.KinematicGroup` objects of a Robot.
This causes some problems.
Groups distinguish between actuated_states and virtual_states while for a transformation these are the same.´

.. important::
    To solve this problem Transformations are internally converted into groups.
    The actuated state of a transformation follows the naming convention `NAME_KEY` 
    where `NAME` is the name of the :class:`.Transformation` and `KEY` is a key for the state of the transformation.
    The full actuated state of a robot can be returned using the `get_actuated_state` method.

For robots without closed chains, both the virtual_state and the actuated_state can be used interchangeably.
We advise nevertheless to use the actuated_state whenever possible as a general convention.

End Effectors
=============

The :class:`.Robot` class offers the same functionality as the Group object at a more abstract level.
Additionally, it supports end effectors.
In robotics, an end effector is conventionally a device at the end of a robotics arm which interacts with the environment.
Kinematically and more, generally speaking, it is a coordinate frame whose position and orientation is of special interest.
This might be because it holds a tool, or because it specifies a foot position or maybe it just holds a sensor.

In any case, end effectors are coordinate frames for which we might want to compute forward or inverse kinematics.
Since for open chains frames and the transformations leading to them are synonymous an effectors can be any frame resulting from a transformation of a robots virtual_chain.
Remember since the robot is comprised of groups it's virtual open chain is a concatenation of the virtual_chains of each group.

The :class:`.Robot` class offers the `get_endeffectors` method for ease of use which returns the names of all possible end effector frames.

Symbolic Representations
========================

The robot class is capable of generating symbolic representations of end effector kinematics.
This means it can describe the state of and end effector frame as a mathematical function :math:`\tilde{p}(\tilde{q})` whose input is the virtual state :math:`\tilde{q}`.

This is handy for several reasons:

- It allows for quick calculations of the end effector position without needing matrix multiplication at every step
- It allows automatic mathematical derivation to calculate the Jacobi matrix and generally analyze the virtual chain
- It allows the setup of mathematical solvers which can compute the inverse kinematics for a given end effector.

Generally, the first point is not needed as the forward kinematics is quite fast on its own and can be called using the `forward_kinematic` function given an end effector and a robot object.
However, if speed is the issue, the casadi library which is used for the symbolic representation is capable of generating C code from such a function object.
This can be used to further speed up code executions or calculate the kinematics on an embedded device.

The main advantages, however, are the second and the third points which are related seeing that most numerical optimization requires the computation of gradients.
Casadi features fast algorithmic differentiation (a powerful hybrid between numerical differentiation and analytic differentiation used in many machine learning solutions).
This allows the fast calculations of gradients and Jacobi matrices.

As such TriP can also be used to do kinematic analysis for open chains.
Note that it does not support closed chains because the mapping functions don't have to be casadi objects.
However if one does use casadi like functions TriP can also be used to analyze hybrid chains.

In general, the symbolic representation returns a casadi object on which the full`casadi feature pallet can be used.
This includes the setup of numerical solvers which are used to calculate the inverse kinematics.


Forward kinematics
==================

The calculation of forward kinematics is done using the `forward_kinematic` function.
The general procedure can be seen in the image below:

.. image:: images/forward_kinematics_procedure.png
 :alt: inverse_kinematics_procedure

The forward kinematics of the virtual_chain are in this case calculated by multiypling the transformation matrices of the virtual_chain together.
This results in a 4x4 transformation matrix describing the state of the end effector.

*******
Solvers
*******

Solvers are objects which calculate the inverse kinematics for a given :class:`.Robot` and end effector.
The reason they are not functions like the forward_kinematic functions is that the generation and setup of a casadi solver object is the biggest performance bottleneck.
To circumvent this, solver classes generate and store casadi solver objects for a given robot and end effector.
Using casadis framework it is then easily possible to implement different types of solving algorithms.

TriP currently only has one type of solver object called :class:`.SimpleInvKinSolver` which will be further explained shortly.
However it is also possible to write your own solver classes, all one has to do is implement the `solve_virtual` and `solve_actuated` 
functions which return the virtual and actuated state respectively given a desired end effector state and an optional initial solver tip.

SimpleInvKinSolver
==================

The :class:`.SimpleInvKinSolver` is as the name implies a rudimentary solver whose general procedure can be seen in the image below:

.. image:: images/inverse_kinematics_procedure.png
 :alt: inverse_kinematics_procedure

First, the system tries to find a virtual state which results in the end effector being as close as possible to the target.
This is done using a casadis NLP solver using auto-generated jacobian and hessian matrices.

In the next step, the system calls the internal mapping functions of the robot to convert the virtual_state into an actuated_state.

.. warning::
    This sequential approach is not capable of handling virtual_states for which no actuate_state can be found. 
    In this case, the solver simply fails.
    To prevent this, suitable starting values for the solver can be supplied and the virtual_chain can be set up to minimize the chance of this happening.
    See section :ref:`virtual_chain_reference_label` for reference.



.. TriP documentation master file, created by
   sphinx-quickstart on Tue Mar 23 13:52:13 2021.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to TriP's documentation!
================================

Have you ever worked with a robot with hydraulic actuators?
Or ever have to compensate bad motors by having them moving the joint via a complicated linkage?

Then you have worked with a hybrid kinematic chain.

TriP is a python library designed to calculate the forward- and inverse-kinematics of such chains.
Since hybrid chains are the most general type of rigid mechanism this includes almost all robots.

Features
--------

- Model any robot (including closed and hybrid chains)
- Generate symbolic representations of forward kinematics
- Compute Jacobian matrices for differential kinematics
- Compute the inverse kinematics of arbitrary rigid mechanisms
- Compute the Inverse Kinematics in position and/or orientation 
- Support arbitrary joint types and quaternions
- Includes several ready to use examples (TriPed robot, Excavator Arm)
- TriPs validates the inverse kinematics algorithms with extensive testing using analytic solutions.


.. toctree::

    how_it_works
    getting_started
    usage
    tutorials
    code_docu

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
###############
Getting Started
###############

The current release of the project can always be found on the python package index `PyPi <https://en.wikipedia.org/wiki/Quaternion>`_ .
However, since another python package is already called trip, the package is called trip_kinematics.
The current stable release can be installed using:

::

    pip install trip_kinematics


Alternatively, the current development version can be downloaded using Github:

::

    git clone https://github.com/TriPed-Robot/TriP
    cd TriP
    pip install src/


For more information on how to use the library once installed visit the Tutorials or read 'How TriP models Robots'.
Code Documentation
******************

.. toctree::
   :hidden:
   

.. automodule:: trip_kinematics.Utility
   :members:

.. automodule:: trip_kinematics.Transformation
   :members:

.. automodule:: trip_kinematics.KinematicGroup
   :members:

.. automodule:: trip_kinematics.Robot
   :members:

.. automodule:: trip_kinematics.Solver
   :members:



Tutorials
************

.. toctree::
   :hidden:



Building a Robot Model
======================

Before TriPs functionality can be used on a robot, it first has to be build within TriP.
This Tutorial will show how to build the `TriPed robot  <https://triped-robot.github.io/docs/robot/>`_  shown below:


.. image:: https://user-images.githubusercontent.com/22688144/124489566-6d70f000-ddb1-11eb-9f57-6a2d9e374fcc.png?raw=true
    :alt: triped


Here each leg was highlighted in a different color.
Since all legs are identicall, this tutorial will start with a single leg.
More information about the triped legs can be found `here <https://triped-robot.github.io/docs/legs/>`_ .


The first step in setting up a robot is identifying the groups and transformations.
TriP uses Groups to model closed kinematic chains.
These are structures where multiple moving parts converge in a single location forming one or more loops.
Some examples can be seen down below:


These closed chains will either be connected directly to each other or using a series of other moving parts.
Such a series is called a open kinematic chain.
Open Kinematic chains are handled using a series of transformations.


In the case of the TriPed the following chains can be identified:

.. image:: images/triped_hybrid_chain.png
    :alt: triped-hybrid_chain

This in turn means that the leg of the TriPed contains one kinematic group and a number of transformations representing the open chain.

Once each group has been identified the group construction worklow goes like this:

.. image:: images/trip_sameple_workflow.png
    :alt: trip_sample_workflow

Building open chains
----------------------------

Groups handle closed chains by abstracting them into a virtual open chains that models how group moves combined with two mapping functions from these virtual joints to the actual actuated joints and back.
This means that for both the open and the closed chain, a chain has to be build.
The precise transformations depend on the type of robot and its conventions.
The kinematic transformations of the TriPed are described here: `here <https://triped-robot.github.io/docs/kinematics/>`_  .
This leads to the following virtual open chain:

.. literalinclude:: ../../src/trip_robots/triped_leg.py
   :language: python
   :linenos:
   :lines: 1-12,157-162

And the corresponding transformations for the open chain:

.. literalinclude:: ../../src/trip_robots/triped_leg.py
   :language: python
   :linenos:
   :lines: 171-183

.. warning::
    Note that the second code block references the closed chain as its parent. Since this group is not yet build the code above will encounter errors.
    In Practice the close chain group first has to be built. The correct order of this code can be seen [here](https://github.com/TriPed-Robot/trip_kinematics/blob/main/src/trip_robots/triped_leg.py).


Note that both chains are made up of transformations without `state_variables`.
Such transformations are 'static' and dont represent a joint.
It is possible to construct open chains without such transformations (see the `denavit hartenberg <https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters/>`_ convention for example).
In practice however they are handy to specify the position of a joint at a specified angle.
This allows the joint angles to be interpretable.
This can be seen with the `a_ll_zero` transformation. It ensures that a `extend_joint` angle corresponds to the foot of the leg being completely retracted.


Create Mappings
---------------

For the kinematic group a mapping from the actuated swing_joints to the virtual gimbal joint have to be provided. These joints can be seen down below:

.. image:: images/triped_mapping.png
    :alt: triped_mapping


The mapping between these joints can be computet by solving a geometric closing equation. As pictured above, the tip :math:`x_i` the output lever connected to the actuated joints  :math:`i`
alwas intersects the sphere at position :math:`c_i` where :math:`i` is either 1 or 2.

Mathematically this can be described using:

.. math::
       \sum_{i=1}^2||(c_i(rx,ry,rz^v)-p_{_i}(rz_i^a))^T(c_i(rx,ry,rz^v)-p_{i}(rz_i^a))-r^2||^2 = 0

Where :math:`rx,ry,rz` are the rotation around the x, y and z axis and the suberscript :math:`v,~a`denotes the virtual and actuated state respectively.

The virtual_to_actuated and actuated_to_virtual mappings can now be defined as the virtual or actuated state that solves the closure equation assuming the other state as a fixed value.
This can be done using casadis nonelinear programming solver.
The final code can be seen down below:

.. literalinclude:: ../../src/trip_robots/triped_leg.py
   :language: python
   :linenos:
   :lines: 15-155


Building the group
-------------------

Using both the mappings and the virtual open chain, the group can be build:

.. literalinclude:: ../../src/trip_robots/triped_leg.py
   :language: python
   :linenos:
   :lines: 164-169

Note that the closed chain specifies no parent since it is located directly at the robots base and the open chain specifies no mappings since these are autogenerated.

Combining groups to a robot
---------------------------

The last step is to combine the group and transformations into a robot object:
::

    triped_leg     = Robot([closed_chain,a_p_ll,a_ll_zero,a_ll_zero_ll_joint,a_ll_joint_fcs])

Building the complete robot
---------------------------

Since the TriPed has three legs, the above process has to be repeated three times.
Each time the joints and actuated state need their own unique names.

Since this would be tedious to do by hand, a function can be written that returns the full transformation of a single leg.
This functions then follows the above steps, only appending the initial kinematic group with a transformation to the start position of each leg.

This function can be seen here:

.. literalinclude:: ../../src/trip_robots/triped.py
   :language: python
   :linenos:
   :lines: 10-91

The final TriPed robot can then be build using:

.. literalinclude:: ../../src/trip_robots/triped.py
   :language: python
   :linenos:
   :lines: 94



Importing URDF Files
====================
The Universal Robot Description Format (URDF) is used to describe a variety of serial robot mechanisms.
Trip includes a URDF parser that allows the importation of alist of transfomrations from a URDF file

It can be used directly after importing the TriP library by calling the function trip_kinematics.from_urdf with the path to the URDF file as the argument. Note that the function returns a list of Transformations, which you probably want to create a Robot from in most cases:

.. code-block:: python

    transformations_list = trip_kinematics.urdf_parser.from_urdf(urdf_path)
    robot = Robot(transformations_list)


This means you can also add other Transformations manually on top of those specified in the URDF file, if required.

Also note that the parser includes defaults for certain values if the corresponding URDF tag is missing, specifically:

* <origin> defaults to <origin xyz="0 0 0" rpy="0 0 0" />.

  * (The same also applies if only one of xyz and rpy is specified, with the omitted value defaulting to "0 0 0")

* <axis> defaults to <axis  xyz="0 0 1" />