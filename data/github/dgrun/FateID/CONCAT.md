# FateID algorithm

FateID is a random forests-based algorithm for the quantification of the fate biases of multipotent progenitors, i. e. the probabilities of differentiating towards particular cell lineages. It utilizes single cell expression data, and was designed to work well with quantitative single-cell RNA-seq data incorporating unique molecular identifiers. FateID requires a gene-by-cell expression matrix as input and groups of cells represeting committed stages (or advanced differentiation stages) of all lineages accessible from the multipotent progenitor population. These so-called target clusters can be defined by a clustering partition, which can also directly be generated by FateID if a list of specific marker genes for all lineages is given.

## Installing

After downloading and unzipping
```
unzip FateID-master.zip 
```

it can be installed from the command line by
```
R CMD INSTALL FateID-master
```

or directly in R from source by
```
install.packages("FateID-master",repos = NULL, type="source")
```
(if R is started from the directory where FateID.zip has been downloaded to; otherwise specify the full path)


Alternatively, install in R directly from github using devtools:
```
install.packages("devtools")
library(devtools)
install_github("dgrun/FateID")
```

## Running a FateID analysis

Load package:
```
library(FateID)
```

See vignette for details and examples:
```
vignette("FateID")
```

## Reference:

Herman JS, Sagar, GrÃ¼n D. (2018) FateID infers cell fate bias in
multipotent progenitors from single-cell RNA-seq data. Nat Methods. 2018 May;15(5):379-386. doi: 10.1038/nmeth.4662.---
title: "FateID reference manual"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{An introduction to FateID.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8) 
```
## Prerequisites

This manual explains how to run the FateID algorithm on sample data. FateID is a method for the quantification of cell fate bias in single cell transcriptome datasets comprising different cell types that emerge from a common progenitor [@FateID]. The progenitor populations are expected to be part of the dataset and the FateID algorithm was designed to learn a pre-existing bias of each progenitor cell to one or multiple alternative terminal fates. The strategy of the algorithm is to apply an iterative random forest classification [@RandomForests] in order to quantify fate bias in increasingly naive progenitors using cells that have been classified in previous iterations as training set.

FateID can be directly installed from CRAN:
```{r eval = FALSE}
install.packages("FateID")
```

After installation the FateID package has to be loaded:
```{r}
library(FateID)
```


In the following sections we describe the application of FateID on sample data. 
We do not explain all input and return arguments of the FateID functions in detail, since extensive description is available in the man pages for all of the functions.

## Input data

The algorithm requires an expression data frame as input with cells as columns and genes as features. Column names are expected to correspond to cell IDs and row names are expected to correspond to gene IDs.

Example data are available from the FateID package. The dataset has to be imported in order to reproduce the analysis in this reference manual:

```{r}
data(intestine)
```

This dataset contains transcript counts of mouse intestinal epithelial cells positive for an Lgr5-lineage reporter after 5 days of lineage tracing [@StemID], i. e. these cells are 5 days old progeny of Lgr5-positive intestinal stem cells:

```{r}
x <- intestine$x
head(x[,1:5])
```

Moreover, FateID requires a partitioning of cells, which can be generated by any clustering method. For example the RaceID3 algorithm can be used to identify cell clusters, and a partitioning generated by this method is provided as part of the package. The partitioning has to be provided as a vector with integer values and component names corresponding to column names of the expression data frame:

```{r}
y <- intestine$y
head(y)
```

Cluster analysis can inform on the presence of mature cell types in the dataset, where cell types of distinct lineages correspond to different clusters (i. e. different numbers of the partition). In the example data, cluster number 6 comprises enterocytes, marked by high expression of the Alpi gene, while cluster 9 represents mature Paneth cells (high expression of Defa24) and cluster 13 mature goblet cells (high expression of Clca3). Other rare cell types are only present in very low numbers and therefore were excluded from the analysis.

As further input for FateID, the endpoints of the differentiation trajectories, i. e. the most mature stages of all distinct cell lineages in the data set have to be defined by a vector of integer numbers representing the corresponding clusters in the partition `y`.

```{r}
tar <- c(6,9,13)
```

If a partitioning into cell types and states from a prior clustering analysis is not available, FateID can derive a partitioning based on marker gene information. For this strategy, a list of marker gene IDs is needed. Each component of this list contains one or more marker genes of a distinct lineage:

```{r}
FMarker <- list(c("Defa20__chr8","Defa24__chr8"), "Clca3__chr3", "Alpi__chr1")
xf <- getPart(x,FMarker,fthr=NULL,n=5)
head(xf$part)
head(xf$tar)
tar <- xf$tar
y <- xf$part
```

The getPart function extracts the top `n` cells expressing the markers of one of the lineages most highly and defines an expression threshold by the average expression across these cells. For this inference the expression level is aggregated across all markers of this lineage. The target cluster of a lineage is given by the ensemble of cells with aggregated marker gene expression higher than this threshold. Alternatively, a vector with threshold expression values for all lineages can also be provided as input argument `fthr`. The target cluster numbers will reflect the order of the component of the `FMarker` list starting at 2. Cluster number 1 comprises all remaining cells that do not exhibit marker gene expression beyond the mean expresion of the top `n` cells expressing a marker or the levels in `fthr`, respectively.

Once target clusters have been defined, FateID has the option to reclassify all remaining cells using the cells within the target clusters as input. 

```{r}
rc <- reclassify(x, y, tar, clthr=.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL, q=0.9)
y  <- rc$part
```
The function returns a partition with the novel assignments after reclassification and can replace the previous partition based on the original target clusters. The purpose of this step is to identify all cells with a pronounced bias towards one of the fates.
This step is optional but recommended to obtain larger training sets for random forests. This and other functions can be executed on expression data prior to or after feature selection. In the sample data, the data frame `x` contains only genes with variability exceeding a background level of combined technical and biological noise as inferred by RaceID3. Alternatively, the full data frame containing all genes can be used as input.

```{r}
v <- intestine$v
rc <- reclassify(v, y, tar, clthr=.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL, q=0.9)
y  <- rc$part
```

The reclassify function also performs a feature selection based on importance sampling, i. e. all features with an importance larger than the q-quantile of the importance distribution for a given class are retained. The reduced expression table is returned by the function and can replace the original input expression data frame:

```{r}
x  <- rc$xf
```
Utilizing this function is recommended if the input data have not been subject to any other feature selection method.

Feature selection can also be performed utilizing a differential gene expression analysis.

```{r}
x <- getFeat(v,y,tar,fpv=0.01)
```

This function compares gene expression within cells of a target cluster to the ensemble of all remaining cells and identifies genes that are significantly up-regulated in a target cluster with a p-value lower than `fpv`. The function returns a reduced expression data frame, which can be used for the subsequent analysis. In general, the reclassify function is more recommended for feature selection, since it reflects the information used for the random forest classification.


##	Computing the fate bias

The core function of FateID computes the fate bias for each cell in the dataset excluding cells within the target cluster. These cells are assigned to the lineage representing the respective target cluster with a probability of one and this probability does not change during inference of the fate bias of all other cells:

```{r}
tar <- c(6,9,13)
x <- intestine$x
y <- intestine$y
fb  <- fateBias(x, y, tar, z=NULL, minnr=5, minnrh=10, adapt=TRUE, confidence=0.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL)
```

Apart from the (feature selected) expression data frame `x`, the partition `y`, and the vector of target clusters `tar`, the `fateBias` function takes further arguments as input. The optional argument `z` is a cell-to-cell distance matrix utilized to identify non-classified cells in the immediate neighborhood of all cells that have been classified as one of the target clusters in the previous iteration. By default this distance matrix will be computed as `z=1-cor(x)`, but if other distance measures are preferred, a distance matrix can be provided by this argument. 

The FateID algorithm computed by the `fateBias` function performs an iterative calculation. It starts with a set of cells representing each target cluster. For each target cluster, the `minnr` neighboring cells with the shortest median distance to all cells in the target cluster are extracted. The ensemble of the neighboring cells of all target clusters represents the test set of the next iteration. The `minnr` parameter thus controls the step size of the algorithm. In each iteration, `minnr` cells times the number of target clusters are classified and can contribute to the training set in the next iteration.

The training set of this iteration comprises all cells assigned to one of the target clusters and the response vector is given by the partition of these cells. The classification of the test set is done based on the random forest votes: If a cell receives significantly more random forest votes for one target cluster versus all other clusters (based on sampling statistics with a p-value threshold of 0.05 it is assigned to this target cluster and contributes to the training set for the next iteration. All cells without a significant fate bias towards any one of the target clusters are not incorporated into the training set for the next iteration. However, the fraction of votes, which can be interpreted as a fate probability, is recorded and stored for all cells. 
Another important parameter controls which cells contribute to the training set for a given iteration. At most `minnrh` cells from each target cluster contribute to the training set. These cells are selected as the `minnrh` cells with the shortest distance to any cell within the current training set. This parameter controls the gene expression horizon on the differentiation trajectory taken into account for the classification of the test set. If minnrh is set to Inf then all previously classified cells with a significant fate bias for one of the target clusters contribute to the training set. However, if gene expression changes follow complex dynamics along a differentiation trajectory, it can become detrimental to include very distant cells expressing maturation markers that are not expressed during the earliest stages of differentiation. It is generally advised to confine the expression horizon to smaller values in order to increase the specificity of the algorithm. However, the training set should still be large enough to warrant a confident classification. As a rule of thumb, the `minnrh` parameter should be set to 20 or larger values, depending on the size and coverage of the dataset. If the input data set is large and a large number of cells are available in the dataset for all lineages covering the entire differentiation trajectory, this parameter can be increased. We recommend testing the robustness of the results to changes in `minnrh`. The step size `minnr` should be selected based on similar consideration. However, it is generally recommended to keep this number lower in order to avoid misclassification due to insufficient resolution. For the majority of datasets with several hundreds of cells we use `minnr=5` and `minnrh=20`.

FateID also permits a dynamic test set size, where the `minnr` parameter is adapted separately for each target cluster based on the classification success in the previous iteration. If `adapt=TRUE`, the number of successfully classified cells is determined in each iteration, i.e. the number of cells with a minimum fraction of votes given by the `confidence` parameter for the target cluster, which gave rise to the inclusion of the cell in the test set. Weights are then derived by dividing this number by the maximum across all target clusters after adding a pseudocount of 1. The test set size `minnr` is rescaled for each cluster by the respective weight in the next iteration. 

This leads to decreasing test set sizes, and hence, slower classification, if the previous classification success of the local neighbourhood has been low. Such an adaptive scheme is important if the number cells on different branches exhibits large differences. If classification on a short branch reaches the naÃ¯ve compartment, where classification succes can be expected to decrease, the progression on this branch in future iterations slows down, while classification of more mature stages on a highly populated branch still progresses at full speed.

As an alternative approach the FateID algorithm offers classification based on distances to all other cells. When `use.dist` is set to `TRUE`, then the distance matrix `z` (or `1-cor(x)`) is interpreted as feature matrix.
The remaining arguments are control parameters of the random forests algorithm and usually do not have to be adjusted.
As outlined in the man packages of the `fateBias` function it returns a list of five components. The votes component is a data frame of random forest votes of all cells for each of the target clusters.  The column names are given by a concatenation of a `t` with the number of the target cluster. The row names are given by cell IDs. The probs component has the same structure, but the votes for each cell are normalized to one in order to represent fate probabilities.
The `tr` component is a list of vectors. Each vector contains all cell IDs of cells with a significant fate bias towards the corresponding target cluster. Significant fate bias means significantly more votes for a given cluster than for any other cluster based on sampling statistics with a p-value below 0.05.
The fourth component is vector with all cell IDs ordered by random forest iteration in which they have been classified. The last component is a list of random forest objects produced by the function randomForest from the randomForest package object for all iterations.

##	Visualization of fate bias

Various dimensional reduction methods are commonly used for single cell transcriptome analysis in order to visually inspect the cell population structure. The FateID package computes a number of dimensional reduction representations to enable visualization of the fate bias and pseudo-temporal ordering by principal curve computation.

```{r}
dr  <- compdr(x, z=NULL, m=c("tsne","cmd","umap"), k=2, lle.n=30, tsne.perplexity=30, seed=12345)
```

The first two input parameters are the same as the ones to the `fateBias` function. The parameter `k` indicates the dimensions for which the dimensional reduction representations are computed. Typically, one wants to inspect data visually in two or three dimensions. However, it is possible to also compute dimensional reductions to more than three dimensions and inspecting the data after projecting onto a subset of dimensions. The remaining parameters are main control parameter for the various algorithms used for dimensional reduction. The function performs computation of a t-SNE map [@TSNE] using the `Rtsne` package, classical multi-dimensional scaling using `cmdscale` from the `stats` package, and locally linear embedding using the `lle` function from the `lle` package. Umaps are computed with the `umap` package. To speed up the computation, only a subset of dimensionality reduction representations can be selected as input parameter `m`.
  
All results can be plotted by the `plotFateMap` function.

The dimensional reduction representation with a highlighting of the partition can be plotted for any of the dimensional reduction algorithms in any of the dimensions computed by `compdr`. For example, a umap can be plotted in two dimensions:

```{r}
plotFateMap(y,dr,k=2,m="umap")
```

Plotting in three dimensions opens an interactive `RGL` device to allow rotation of the plot and zooming in and out:

```{r eval=FALSE}
plotFateMap(y,dr,k=3,m="umap")
```

The fate bias can now be highlighted in the dimensional reduction representation by providing the name of the target cluster additional argument (concatenation of a `t` and the cluster number, e.g. `t6`) and the `fateBias` output:

```{r}
plotFateMap(y,dr,k=2,m="umap",fb=fb,g="t6")
```
  
To approximate the differentiation trajectories, principal curves can be computed in the dimensionally reduced space. For the computation of a principal curve of a given target cluster, only those cells contribute that have a fraction of random forest votes for this target cluster larger than `trthr`. If this argument is not given only cells contribute with a significant bias for this target cluster in comparison to all others with a p-value < 0.05 derived from sampling statistics. The principal curves are plotted into the maps and returned by the function if the argument `prc` is `TRUE`.

```{r}
pr <- plotFateMap(y,dr,k=2,m="umap",trthr=.33,fb=fb,prc=TRUE)
```


If the most naive cluster representing a common upstream progenitor of all cell types is known, the number of this cluster can also be given as input argument start in order to initialize the principal curve computation with principal curves starting in the start cluster and ending in one of the target clusters. To enforce that principal curves traverse through the cell population representing the respective target cluster, the weight of cells within the initial target clusters is increased 10-fold for the principal curve computation.

If principal curves are computed, the return object of plotFateMap is a list of two objects. The first argument `pr` is itself a list of principal curve objects for each target cluster as computed by the `principal.curve` function from the `princurve` package. The second argument `trc` is a list of vectors with cell IDs for the principal curve of each target cluster containing the IDs of all cells with a significant fate bias or a fate bias greater than `trthr`, respectively. The cell IDs are ordered by their position along the principal curve as obtained from the point of their shortest distance to the curve.

The expression of a gene, or the aggregated expression across a group of genes, can also be highlighted in the dimensional reduction representation by providing a vector with the respective gene IDs as additional parameter `g`, an optional title `n` for the plot, and an expression data data frame `x` (we are using the full one instead of the reduced one):

```{r}
v <- intestine$v
pr <-plotFateMap(y, dr, k=2, m="umap", g=c("Defa20__chr8", "Defa24__chr8"), n="Defa", x=v)
```

Finally, if `g="E"` and a list `fb` returned by the `fateBias` function is provided as input, the function will plot the entropy of the fate bias based on the probabilities for the different target clusters. An entropy level of the fate bias will indicate the level of multipotency with larger fate bias entropies corresponding to more multipotent cell states. If executed with `g="E"`, the function will return a vector with the fate bias entropy of each cell:

```{r}
E <- plotFateMap(y,dr,k=2,m="umap",g="E",fb=fb)
head(E)
```
  
The principal curve can also be computed directly without calling the `plotFateMap` function:

```{r}
pr  <- prcurve(y,fb,dr,k=2,m="umap",trthr=0.33,start=3)
```

This function has the same input arguments as `plotFateMap` and is invoked by the `plotFateMap` function.

##	Inspecting pseudo-temporal gene expression changes

FateID also provides functions for the visualization and analysis of pseudo-temporal gene expression changes.
For this purpose, cells with a fate bias towards a target cluster can be extracted. The principal curve analysis returns all cells along a differentiation trajectory in pseudo-temporal order. For example, cells with a fate bias towards cluster 6 in pseudo-temporal order can be extracted by the following command:

```{r}
n <- pr$trc[["t6"]]
```

Alternatively, other published methods for pseudo-temporal ordering, e.g., Monocle2 [@Census] or diffusion pseudo-time [@DPT], can be used after selecting cells by cell fate probability.

In the second step, the input expression data are defined:

```{r}
v <- intestine$v
fs  <- filterset(v,n=n,minexpr=2,minnumber=1)
```
Here, we are using the full expression data frame `v` without feature selection.
The second argument is the vector of cell ids corresponding to valid row names of the expression table in pseudo-temporal order.

The `filterset` function can be used to eliminate lowly expressed genes on the trajectory from the subsequent analysis and has two additional arguments to discard genes, which are not expressed at a level of `minexpr` or higher in at least `minnumber` of cells. The function returns a filtered expression data frame with genes as rows and cells as columns in the same order as in the input vector `n`.
In the third step, a self-organizing map (SOM) of the pseudo-temporal expression profiles is computed:

```{r}
s1d <- getsom(fs,nb=50,alpha=.5)
```

This map provides a grouping of similar expression profiles into modules. The first input argument is again an expression data frame. In this case, we use the filtered expression table generated by the filterset function to retain only genes that are expressed on the trajectory under consideration.
Pseudo-temporal expression profiles along the differentiation trajectory of interest are computed after smoothening  by local regression with smoothing parameter `alpha`.

This function returns a list of the following three components: a `som` object returned by the function `som` of the package `som`, a data frame `x` with smoothened and normalized expression profiles, and a data frame `zs` of z-score transformed pseudo-temporal expression profiles.

The SOM is then processed by another function to group the nodes of the SOM into larger modules and to produce additional z-score transformed and binned expression data frames for display:

```{r}
ps  <- procsom(s1d,corthr=.85,minsom=3)
```

The first input argument is given by the SOM computed by the function `getsom`. The function has two additional input parameters to control the grouping of the SOM nodes into larger modules. The parameter corthr defines a correlation threshold. If the correlation of the z-scores of the average normalized pseudo-temporal expression profiles of neighboring nodes in the SOM exceeds this threshold genes of the neighboring nodes are merged into a larger module. Only modules with at least `minsom` genes are kept. The function returns a list of various data frames with normalized, z-score-transformed, or binned expression along with the assignment of genes to modules of the SOM (see help page for details).

The output of the processed SOM can be plotted using the `plotheatmap` function.
First, in order to highlight the clustering partition `y`, the same color scheme as used in `plotFateMap` can be generated (alternatively, both functions can be executed with an arbitrary user-defined scheme):

```{r}
fcol <- sample(rainbow(max(y)))
```

Now, the different output data frames of the `procsom` function can be plotted. 

Average z-score for all modules derived from the SOM:

```{r}
plotheatmap(ps$nodes.z, xpart=y[n], xcol=fcol, ypart=unique(ps$nodes), xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

The z-score profile of each gene ordered in SOM modules:

```{r}
plotheatmap(ps$all.z, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

Normalized expression profile of each gene ordered by SOM modules:

```{r}
plotheatmap(ps$all.e, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

Binarized expression profile of each gene (z-score < -1, -1 < z-score < 1, z-score > 1):

```{r}
plotheatmap(ps$all.b, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```


In order to inspect genes within individual modules of the SOM, these genes can be extracted given the number of the module. The module numbers are contained in the return argument nodes of the `procsom` function and can be extracted, e. g. for module number 1:

```{r}
g <- names(ps$nodes)[ps$nodes == 1]
```

The average pseudo-temporal expression profile of this group can be plotted by the function `plotexpression`:

```{r}
plotexpression(fs, y, g, n, col=fcol, name="Node 1", cluster=FALSE, alpha=.5, types=NULL)
```

In the same way it is possible to plot expression profiles of individual genes, e.g.:

```{r}
plotexpression(fs, y, "Clca4__chr3", n, col=fcol, cluster=FALSE, alpha=.5, types=NULL)
```

It is also possible to highlight the data points as specific symbols, for example reflecting batches, by using the types argument:

```{r}
plotexpression(fs, y, g, n, col=fcol, name="Node 1", cluster=FALSE, types=sub("\\_\\d+","",n))
```

See help pages for detailed explanation of the input parameters.

Finally, individual loess-smoothed profiles for a set of genes can be plotted in the same graph (after normalizing the sum of expression across all cells to one in order to display genes on the same scale):

```{r}
group <- head(g,6)
plotexpressionProfile(fs, y, group, n, name="Node 1", cluster=FALSE)
```

See help pages for detailed explanation of the input parameters.


##	Differential gene expression analysis

Together with FateID a function for differential gene expression analysis is provided. This function implements an approach similar to DESeq [@DESeq] by which negative binomial distributions are fitted to transcript counts in two populations, representing, for instance, two different cell types. By default, the function should be executed on normalized data and estimates the dispersion parameter from the polynomial fit of the log-transformed transcript count variance as a function of the log-transformed mean expression. This is done on the input data, either after pooling cells from the two populations or on each of the populations separately. Alternatively, one can also provide a function for the variance-mean dependence as an input parameter, e. g. the dependence computed in the RaceID2 [@StemID] outlier identification. As another option, the function can also execute a standard DESeq2 [@DESeq2] differential expression analysis.

To run the analysis, an expression data frame is needed as input together with two vectors of cell IDs corresponding to subsets of column names of this data frame. 

For example, this function could be used to identify genes differentially expressed between cells in the original clusters 3,4,5 (the progenitor compartment) that are either biased towards enterocytes (cluster 6) or goblet cells (cluster 13) with a fate-probability of >0.5:

```{r}
thr <- .5
a   <- "t13"
b   <- "t6"
cl  <- c(3,4,5)
A <- rownames(fb$probs)[fb$probs[,a] > thr]
A <- A[y[A] %in% cl]
B <- rownames(fb$probs)[fb$probs[,b] > thr]
B <- B[y[B] %in% cl]
de <- diffexpnb(v,A=A,B=B,DESeq=FALSE,norm=FALSE,vfit=NULL,locreg=FALSE)
```

Here, we use the full expression data frame without feature selection as input. Normalization is not performed, since `v` is already normalized by size. With the chosen input parameters, diffexpnb will infer the dispersion parameter of the negative binomial transcript level distributions for the two populations based on a variance-mean dependence derived as in RaceID2 [@StemID]. Alternatively, a local regression can be utilized, if `locreg` equals `TRUE`. Another option is to run a DESeq2 [@DESeq2] analysis, if `DESeq` is `TRUE`.
The function returns a list of three components. The results of the differential gene expression analysis are stored in the res component, which is a data frame displaying mean expression of the two sets, fold change and log2 fold-change between the two sets, the p-value for differential expression (`pval`) and the Benjamini-Hochberg corrected false discovery rate (`padj`).

The results can be plotted by the following function:

```{r}
plotdiffgenesnb(de,mthr=-4,lthr=0,Aname=a,Bname=b,padj=FALSE)
```

##	Inspecting fate bias of gene expression

To enable further inspection of fate-specific marker gene expression, `FateID` provides a function to plot the expression levels of two genes against each other in a scatter plot. These genes could, for instance, represent markers of two different lineages, and the function reveals whether the expression domains of these genes fall into distinct clusters or whether they correlate with the fate bias towards a particular lineage.
To visualize a correlation of gene expression domain and cluster origin of the cells, the `gene2gene` function can be called with a gene expression data frame and a clustering partition as input:

```{r}
gene2gene(intestine$v,intestine$y,"Muc2__chr7","Apoa1__chr9")
```

If the fate bias towards a particular target cluster, e. g. cluster 6, should be highlighted, the output `fb` of the `fateBias` function and the column name of `fb$probs` corresponding to the target cluster, i. e. `t6`, are required as additional input parameters:

```{r} 
gene2gene(intestine$v, intestine$y, "Muc2__chr7", "Apoa1__chr9", fb=fb, tn="t6", plotnum=FALSE)
```

See help pages for additional input arguments.

  
To identify genes involved in early priming and fate decision at all stages of differentiation, it is informative to extract all the genes with a high importance value (see details of the randomForest function in the randomForest package) for the classification into a given target cluster in at least one random forest iteration:

```{r}
k <- impGenes(fb,"t6")
```

This function requires the output object of the `fateBias` function and the number of a target clusters, concatenated with a `t` as input. Additional optional arguments specify cutoffs for the importance values (see help pages). It returns a list of two objects, one data frame with mean importance values for all genes that passed the thresholds in at least of the iterations as rows and the iterations as columns, and a corresponding data frame with the standard deviation of the importance values.

The function also plots a heatmap of the importance values with hierarchical clustering of the genes.


For bug reports and any questions related to FateID please email directly to [link](mailto:dominic.gruen@gmail.com). 

## References

---
references:

- id: FateID
  type: article-journal
  author:
  - family: Herman
    given: J. S.
  - family: Sagar
    given:
  - family: GrÃ¼n
    given: D.
  issued:
  - year: '2018'
    month: '5'
  title: '[FateID infers cell fate bias in multipotent progenitors from single-cell RNA-seq data]{.nocase}'
  container-title: Nat. Methods
  page: '379-386'
  volume: '15'
  issue: '5'
  
- id: Census
  type: article-journal
  author:
  - family: Qiu
    given: X.
  - family: Hill
    given: A.
  - family: Packer
    given: J.
  - family: Lin
    given: D.
  - family: Ma
    given: Y. A.
  - family: Trapnell
    given: C.
  issued:
  - year: '2017'
    month: '3'
  title: '[Single-cell mRNA quantification and differential analysis with Census]{.nocase}'
  container-title: Nat. Methods
  page: '309-315'
  volume: '14'
  issue: '3'

- id: StemID
  type: article-journal
  author:
  - family: Grun
    given: D.
  - family: Muraro
    given: M. J.
  - family: Boisset
    given: J. C.
  - family: Wiebrands
    given: K.
  - family: Lyubimova
    given: A.
  - family: Dharmadhikari
    given: G.
  - family: Born
    given: M.
    dropping-particle: van den
  - family: Es
    given: J.
    dropping-particle: van
  - family: Jansen
    given: 'E.'
  - family: Clevers
    given: H.
  - family: Koning
    given: E. J. P.
    dropping-particle: de
  - family: Oudenaarden
    given: A.
    dropping-particle: van
  issued:
  - year: '2016'
    month: '8'
  title: '[De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome
    Data]{.nocase}'
  container-title: Cell Stem Cell
  page: '266-277'
  volume: '19'
  issue: '2'

- id: DESeq
  type: article-journal
  author:
  - family: Anders
    given: S.
  - family: Huber
    given: W.
  issued:
  - year: '2010'
  title: '[Differential expression analysis for sequence count data]{.nocase}'
  container-title: Genome Biol.
  page: R106
  volume: '11'
  issue: '10'

- id: DESeq2
  type: article-journal
  author:
  - family: Love
    given: M. I.
  - family: Huber
    given: W.
  - family: Anders
    given: S.
  issued:
  - year: '2014'
  title: '[Moderated estimation of fold change and dispersion for RNA-seq data with
    DESeq2]{.nocase}'
  container-title: Genome Biol.
  page: '550'
  volume: '15'
  issue: '12'

- id: RandomForests
  type: article-journal
  author:
  - family: Breiman
    given: L.
  issued:
  - year: '2001'
  title: '[Random Forests]{.nocase}'
  container-title: Mach. Learn.
  page: '5-32'
  volume: '45'
  issue: '1'

- id: TSNE
  type: article-journal
  author:
  - family: Maaten
    given: L.
    dropping-particle: van der
  - family: Hinton
    given: G.
  issued:
  - year: '2008'
  title: '[Visualizing Data using t-SNE]{.nocase}'
  container-title: J. Mach. Learn.
  page: '2570-2605'
  volume: '9'

- id: DPT
  type: article-journal
  author:
  - family: Haghverdi
    given: L.
  - family: Buttner
    given: M.
  - family: Wolf
    given: F. A.
  - family: Buettner
    given: F.
  - family: Theis
    given: F. J.
  issued:
  - year: '2016'
    month: '10'
  title: '[Diffusion pseudotime robustly reconstructs lineage branching]{.nocase}'
  container-title: Nat. Methods
  page: '845-848'
  volume: '13'
  issue: '10'

- id: Destiny
  type: article-journal
  author:
  - family: Angerer
    given: P.
  - family: Haghverdi
    given: L.
  - family: Buttner
    given: M.
  - family: Theis
    given: F. J.
  - family: Marr
    given: C.
  - family: Buettner
    given: F.
  issued:
  - year: '2016'
    month: '4'
  title: '[destiny: diffusion maps for large-scale single-cell data in R]{.nocase}'
  container-title: Bioinformatics
  page: '1241-1243'
  volume: '32'
  issue: '8'
...

---
title: "FateID reference manual"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{An introduction to FateID.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8) 
```
## Prerequisites

This manual explains how to run the FateID algorithm on sample data. FateID is a method for the quantification of cell fate bias in single cell transcriptome datasets comprising different cell types that emerge from a common progenitor [@FateID]. The progenitor populations are expected to be part of the dataset and the FateID algorithm was designed to learn a pre-existing bias of each progenitor cell to one or multiple alternative terminal fates. The strategy of the algorithm is to apply an iterative random forest classification [@RandomForests] in order to quantify fate bias in increasingly naive progenitors using cells that have been classified in previous iterations as training set.

FateID can be directly installed from CRAN:
```{r eval = FALSE}
install.packages("FateID")
```

After installation the FateID package has to be loaded:
```{r}
library(FateID)
```


In the following sections we describe the application of FateID on sample data. 
We do not explain all input and return arguments of the FateID functions in detail, since extensive description is available in the man pages for all of the functions.

## Input data

The algorithm requires an expression data frame as input with cells as columns and genes as features. Column names are expected to correspond to cell IDs and row names are expected to correspond to gene IDs.

Example data are available from the FateID package. The dataset has to be imported in order to reproduce the analysis in this reference manual:

```{r}
data(intestine)
```

This dataset contains transcript counts of mouse intestinal epithelial cells positive for an Lgr5-lineage reporter after 5 days of lineage tracing [@StemID], i. e. these cells are 5 days old progeny of Lgr5-positive intestinal stem cells:

```{r}
x <- intestine$x
head(x[,1:5])
```

Moreover, FateID requires a partitioning of cells, which can be generated by any clustering method. For example the RaceID3 algorithm can be used to identify cell clusters, and a partitioning generated by this method is provided as part of the package. The partitioning has to be provided as a vector with integer values and component names corresponding to column names of the expression data frame:

```{r}
y <- intestine$y
head(y)
```

Cluster analysis can inform on the presence of mature cell types in the dataset, where cell types of distinct lineages correspond to different clusters (i. e. different numbers of the partition). In the example data, cluster number 6 comprises enterocytes, marked by high expression of the Alpi gene, while cluster 9 represents mature Paneth cells (high expression of Defa24) and cluster 13 mature goblet cells (high expression of Clca3). Other rare cell types are only present in very low numbers and therefore were excluded from the analysis.

As further input for FateID, the endpoints of the differentiation trajectories, i. e. the most mature stages of all distinct cell lineages in the data set have to be defined by a vector of integer numbers representing the corresponding clusters in the partition `y`.

```{r}
tar <- c(6,9,13)
```

If a partitioning into cell types and states from a prior clustering analysis is not available, FateID can derive a partitioning based on marker gene information. For this strategy, a list of marker gene IDs is needed. Each component of this list contains one or more marker genes of a distinct lineage:

```{r}
FMarker <- list(c("Defa20__chr8","Defa24__chr8"), "Clca3__chr3", "Alpi__chr1")
xf <- getPart(x,FMarker,fthr=NULL,n=5)
head(xf$part)
head(xf$tar)
tar <- xf$tar
y <- xf$part
```

The getPart function extracts the top `n` cells expressing the markers of one of the lineages most highly and defines an expression threshold by the average expression across these cells. For this inference the expression level is aggregated across all markers of this lineage. The target cluster of a lineage is given by the ensemble of cells with aggregated marker gene expression higher than this threshold. Alternatively, a vector with threshold expression values for all lineages can also be provided as input argument `fthr`. The target cluster numbers will reflect the order of the component of the `FMarker` list starting at 2. Cluster number 1 comprises all remaining cells that do not exhibit marker gene expression beyond the mean expresion of the top `n` cells expressing a marker or the levels in `fthr`, respectively.

Once target clusters have been defined, FateID has the option to reclassify all remaining cells using the cells within the target clusters as input. 

```{r}
rc <- reclassify(x, y, tar, clthr=.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL, q=0.9)
y  <- rc$part
```
The function returns a partition with the novel assignments after reclassification and can replace the previous partition based on the original target clusters. The purpose of this step is to identify all cells with a pronounced bias towards one of the fates.
This step is optional but recommended to obtain larger training sets for random forests. This and other functions can be executed on expression data prior to or after feature selection. In the sample data, the data frame `x` contains only genes with variability exceeding a background level of combined technical and biological noise as inferred by RaceID3. Alternatively, the full data frame containing all genes can be used as input.

```{r}
v <- intestine$v
rc <- reclassify(v, y, tar, clthr=.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL, q=0.9)
y  <- rc$part
```

The reclassify function also performs a feature selection based on importance sampling, i. e. all features with an importance larger than the q-quantile of the importance distribution for a given class are retained. The reduced expression table is returned by the function and can replace the original input expression data frame:

```{r}
x  <- rc$xf
```
Utilizing this function is recommended if the input data have not been subject to any other feature selection method.

Feature selection can also be performed utilizing a differential gene expression analysis.

```{r}
x <- getFeat(v,y,tar,fpv=0.01)
```

This function compares gene expression within cells of a target cluster to the ensemble of all remaining cells and identifies genes that are significantly up-regulated in a target cluster with a p-value lower than `fpv`. The function returns a reduced expression data frame, which can be used for the subsequent analysis. In general, the reclassify function is more recommended for feature selection, since it reflects the information used for the random forest classification.


##	Computing the fate bias

The core function of FateID computes the fate bias for each cell in the dataset excluding cells within the target cluster. These cells are assigned to the lineage representing the respective target cluster with a probability of one and this probability does not change during inference of the fate bias of all other cells:

```{r}
tar <- c(6,9,13)
x <- intestine$x
y <- intestine$y
fb  <- fateBias(x, y, tar, z=NULL, minnr=5, minnrh=10, adapt=TRUE, confidence=0.75, nbfactor=5, use.dist=FALSE, seed=12345, nbtree=NULL)
```

Apart from the (feature selected) expression data frame `x`, the partition `y`, and the vector of target clusters `tar`, the `fateBias` function takes further arguments as input. The optional argument `z` is a cell-to-cell distance matrix utilized to identify non-classified cells in the immediate neighborhood of all cells that have been classified as one of the target clusters in the previous iteration. By default this distance matrix will be computed as `z=1-cor(x)`, but if other distance measures are preferred, a distance matrix can be provided by this argument. 

The FateID algorithm computed by the `fateBias` function performs an iterative calculation. It starts with a set of cells representing each target cluster. For each target cluster, the `minnr` neighboring cells with the shortest median distance to all cells in the target cluster are extracted. The ensemble of the neighboring cells of all target clusters represents the test set of the next iteration. The `minnr` parameter thus controls the step size of the algorithm. In each iteration, `minnr` cells times the number of target clusters are classified and can contribute to the training set in the next iteration.

The training set of this iteration comprises all cells assigned to one of the target clusters and the response vector is given by the partition of these cells. The classification of the test set is done based on the random forest votes: If a cell receives significantly more random forest votes for one target cluster versus all other clusters (based on sampling statistics with a p-value threshold of 0.05 it is assigned to this target cluster and contributes to the training set for the next iteration. All cells without a significant fate bias towards any one of the target clusters are not incorporated into the training set for the next iteration. However, the fraction of votes, which can be interpreted as a fate probability, is recorded and stored for all cells. 
Another important parameter controls which cells contribute to the training set for a given iteration. At most `minnrh` cells from each target cluster contribute to the training set. These cells are selected as the `minnrh` cells with the shortest distance to any cell within the current training set. This parameter controls the gene expression horizon on the differentiation trajectory taken into account for the classification of the test set. If minnrh is set to Inf then all previously classified cells with a significant fate bias for one of the target clusters contribute to the training set. However, if gene expression changes follow complex dynamics along a differentiation trajectory, it can become detrimental to include very distant cells expressing maturation markers that are not expressed during the earliest stages of differentiation. It is generally advised to confine the expression horizon to smaller values in order to increase the specificity of the algorithm. However, the training set should still be large enough to warrant a confident classification. As a rule of thumb, the `minnrh` parameter should be set to 20 or larger values, depending on the size and coverage of the dataset. If the input data set is large and a large number of cells are available in the dataset for all lineages covering the entire differentiation trajectory, this parameter can be increased. We recommend testing the robustness of the results to changes in `minnrh`. The step size `minnr` should be selected based on similar consideration. However, it is generally recommended to keep this number lower in order to avoid misclassification due to insufficient resolution. For the majority of datasets with several hundreds of cells we use `minnr=5` and `minnrh=20`.

FateID also permits a dynamic test set size, where the `minnr` parameter is adapted separately for each target cluster based on the classification success in the previous iteration. If `adapt=TRUE`, the number of successfully classified cells is determined in each iteration, i.e. the number of cells with a minimum fraction of votes given by the `confidence` parameter for the target cluster, which gave rise to the inclusion of the cell in the test set. Weights are then derived by dividing this number by the maximum across all target clusters after adding a pseudocount of 1. The test set size `minnr` is rescaled for each cluster by the respective weight in the next iteration. 

This leads to decreasing test set sizes, and hence, slower classification, if the previous classification success of the local neighbourhood has been low. Such an adaptive scheme is important if the number cells on different branches exhibits large differences. If classification on a short branch reaches the naÃ¯ve compartment, where classification succes can be expected to decrease, the progression on this branch in future iterations slows down, while classification of more mature stages on a highly populated branch still progresses at full speed.

As an alternative approach the FateID algorithm offers classification based on distances to all other cells. When `use.dist` is set to `TRUE`, then the distance matrix `z` (or `1-cor(x)`) is interpreted as feature matrix.
The remaining arguments are control parameters of the random forests algorithm and usually do not have to be adjusted.
As outlined in the man packages of the `fateBias` function it returns a list of five components. The votes component is a data frame of random forest votes of all cells for each of the target clusters.  The column names are given by a concatenation of a `t` with the number of the target cluster. The row names are given by cell IDs. The probs component has the same structure, but the votes for each cell are normalized to one in order to represent fate probabilities.
The `tr` component is a list of vectors. Each vector contains all cell IDs of cells with a significant fate bias towards the corresponding target cluster. Significant fate bias means significantly more votes for a given cluster than for any other cluster based on sampling statistics with a p-value below 0.05.
The fourth component is vector with all cell IDs ordered by random forest iteration in which they have been classified. The last component is a list of random forest objects produced by the function randomForest from the randomForest package object for all iterations.

##	Visualization of fate bias

Various dimensional reduction methods are commonly used for single cell transcriptome analysis in order to visually inspect the cell population structure. The FateID package computes a number of dimensional reduction representations to enable visualization of the fate bias and pseudo-temporal ordering by principal curve computation.

```{r}
dr  <- compdr(x, z=NULL, m=c("tsne","cmd","umap"), k=2, lle.n=30, tsne.perplexity=30, seed=12345)
```

The first two input parameters are the same as the ones to the `fateBias` function. The parameter `k` indicates the dimensions for which the dimensional reduction representations are computed. Typically, one wants to inspect data visually in two or three dimensions. However, it is possible to also compute dimensional reductions to more than three dimensions and inspecting the data after projecting onto a subset of dimensions. The remaining parameters are main control parameter for the various algorithms used for dimensional reduction. The function performs computation of a t-SNE map [@TSNE] using the `Rtsne` package, classical multi-dimensional scaling using `cmdscale` from the `stats` package, and locally linear embedding using the `lle` function from the `lle` package. Umaps are computed with the `umap` package. To speed up the computation, only a subset of dimensionality reduction representations can be selected as input parameter `m`.
  
All results can be plotted by the `plotFateMap` function.

The dimensional reduction representation with a highlighting of the partition can be plotted for any of the dimensional reduction algorithms in any of the dimensions computed by `compdr`. For example, a umap can be plotted in two dimensions:

```{r}
plotFateMap(y,dr,k=2,m="umap")
```

Plotting in three dimensions opens an interactive `RGL` device to allow rotation of the plot and zooming in and out:

```{r eval=FALSE}
plotFateMap(y,dr,k=3,m="umap")
```

The fate bias can now be highlighted in the dimensional reduction representation by providing the name of the target cluster additional argument (concatenation of a `t` and the cluster number, e.g. `t6`) and the `fateBias` output:

```{r}
plotFateMap(y,dr,k=2,m="umap",fb=fb,g="t6")
```
  
To approximate the differentiation trajectories, principal curves can be computed in the dimensionally reduced space. For the computation of a principal curve of a given target cluster, only those cells contribute that have a fraction of random forest votes for this target cluster larger than `trthr`. If this argument is not given only cells contribute with a significant bias for this target cluster in comparison to all others with a p-value < 0.05 derived from sampling statistics. The principal curves are plotted into the maps and returned by the function if the argument `prc` is `TRUE`.

```{r}
pr <- plotFateMap(y,dr,k=2,m="umap",trthr=.33,fb=fb,prc=TRUE)
```


If the most naive cluster representing a common upstream progenitor of all cell types is known, the number of this cluster can also be given as input argument start in order to initialize the principal curve computation with principal curves starting in the start cluster and ending in one of the target clusters. To enforce that principal curves traverse through the cell population representing the respective target cluster, the weight of cells within the initial target clusters is increased 10-fold for the principal curve computation.

If principal curves are computed, the return object of plotFateMap is a list of two objects. The first argument `pr` is itself a list of principal curve objects for each target cluster as computed by the `principal.curve` function from the `princurve` package. The second argument `trc` is a list of vectors with cell IDs for the principal curve of each target cluster containing the IDs of all cells with a significant fate bias or a fate bias greater than `trthr`, respectively. The cell IDs are ordered by their position along the principal curve as obtained from the point of their shortest distance to the curve.

The expression of a gene, or the aggregated expression across a group of genes, can also be highlighted in the dimensional reduction representation by providing a vector with the respective gene IDs as additional parameter `g`, an optional title `n` for the plot, and an expression data data frame `x` (we are using the full one instead of the reduced one):

```{r}
v <- intestine$v
pr <-plotFateMap(y, dr, k=2, m="umap", g=c("Defa20__chr8", "Defa24__chr8"), n="Defa", x=v)
```

Finally, if `g="E"` and a list `fb` returned by the `fateBias` function is provided as input, the function will plot the entropy of the fate bias based on the probabilities for the different target clusters. An entropy level of the fate bias will indicate the level of multipotency with larger fate bias entropies corresponding to more multipotent cell states. If executed with `g="E"`, the function will return a vector with the fate bias entropy of each cell:

```{r}
E <- plotFateMap(y,dr,k=2,m="umap",g="E",fb=fb)
head(E)
```
  
The principal curve can also be computed directly without calling the `plotFateMap` function:

```{r}
pr  <- prcurve(y,fb,dr,k=2,m="umap",trthr=0.33,start=3)
```

This function has the same input arguments as `plotFateMap` and is invoked by the `plotFateMap` function.

##	Inspecting pseudo-temporal gene expression changes

FateID also provides functions for the visualization and analysis of pseudo-temporal gene expression changes.
For this purpose, cells with a fate bias towards a target cluster can be extracted. The principal curve analysis returns all cells along a differentiation trajectory in pseudo-temporal order. For example, cells with a fate bias towards cluster 6 in pseudo-temporal order can be extracted by the following command:

```{r}
n <- pr$trc[["t6"]]
```

Alternatively, other published methods for pseudo-temporal ordering, e.g., Monocle2 [@Census] or diffusion pseudo-time [@DPT], can be used after selecting cells by cell fate probability.

In the second step, the input expression data are defined:

```{r}
v <- intestine$v
fs  <- filterset(v,n=n,minexpr=2,minnumber=1)
```
Here, we are using the full expression data frame `v` without feature selection.
The second argument is the vector of cell ids corresponding to valid row names of the expression table in pseudo-temporal order.

The `filterset` function can be used to eliminate lowly expressed genes on the trajectory from the subsequent analysis and has two additional arguments to discard genes, which are not expressed at a level of `minexpr` or higher in at least `minnumber` of cells. The function returns a filtered expression data frame with genes as rows and cells as columns in the same order as in the input vector `n`.
In the third step, a self-organizing map (SOM) of the pseudo-temporal expression profiles is computed:

```{r}
s1d <- getsom(fs,nb=50,alpha=.5)
```

This map provides a grouping of similar expression profiles into modules. The first input argument is again an expression data frame. In this case, we use the filtered expression table generated by the filterset function to retain only genes that are expressed on the trajectory under consideration.
Pseudo-temporal expression profiles along the differentiation trajectory of interest are computed after smoothening  by local regression with smoothing parameter `alpha`.

This function returns a list of the following three components: a `som` object returned by the function `som` of the package `som`, a data frame `x` with smoothened and normalized expression profiles, and a data frame `zs` of z-score transformed pseudo-temporal expression profiles.

The SOM is then processed by another function to group the nodes of the SOM into larger modules and to produce additional z-score transformed and binned expression data frames for display:

```{r}
ps  <- procsom(s1d,corthr=.85,minsom=3)
```

The first input argument is given by the SOM computed by the function `getsom`. The function has two additional input parameters to control the grouping of the SOM nodes into larger modules. The parameter corthr defines a correlation threshold. If the correlation of the z-scores of the average normalized pseudo-temporal expression profiles of neighboring nodes in the SOM exceeds this threshold genes of the neighboring nodes are merged into a larger module. Only modules with at least `minsom` genes are kept. The function returns a list of various data frames with normalized, z-score-transformed, or binned expression along with the assignment of genes to modules of the SOM (see help page for details).

The output of the processed SOM can be plotted using the `plotheatmap` function.
First, in order to highlight the clustering partition `y`, the same color scheme as used in `plotFateMap` can be generated (alternatively, both functions can be executed with an arbitrary user-defined scheme):

```{r}
fcol <- sample(rainbow(max(y)))
```

Now, the different output data frames of the `procsom` function can be plotted. 

Average z-score for all modules derived from the SOM:

```{r}
plotheatmap(ps$nodes.z, xpart=y[n], xcol=fcol, ypart=unique(ps$nodes), xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

The z-score profile of each gene ordered in SOM modules:

```{r}
plotheatmap(ps$all.z, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

Normalized expression profile of each gene ordered by SOM modules:

```{r}
plotheatmap(ps$all.e, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```

Binarized expression profile of each gene (z-score < -1, -1 < z-score < 1, z-score > 1):

```{r}
plotheatmap(ps$all.b, xpart=y[n], xcol=fcol, ypart=ps$nodes, xgrid=FALSE, ygrid=TRUE, xlab=FALSE)
```


In order to inspect genes within individual modules of the SOM, these genes can be extracted given the number of the module. The module numbers are contained in the return argument nodes of the `procsom` function and can be extracted, e. g. for module number 1:

```{r}
g <- names(ps$nodes)[ps$nodes == 1]
```

The average pseudo-temporal expression profile of this group can be plotted by the function `plotexpression`:

```{r}
plotexpression(fs, y, g, n, col=fcol, name="Node 1", cluster=FALSE, alpha=.5, types=NULL)
```

In the same way it is possible to plot expression profiles of individual genes, e.g.:

```{r}
plotexpression(fs, y, "Clca4__chr3", n, col=fcol, cluster=FALSE, alpha=.5, types=NULL)
```

It is also possible to highlight the data points as specific symbols, for example reflecting batches, by using the types argument:

```{r}
plotexpression(fs, y, g, n, col=fcol, name="Node 1", cluster=FALSE, types=sub("\\_\\d+","",n))
```

See help pages for detailed explanation of the input parameters.

Finally, individual loess-smoothed profiles for a set of genes can be plotted in the same graph (after normalizing the sum of expression across all cells to one in order to display genes on the same scale):

```{r}
group <- head(g,6)
plotexpressionProfile(fs, y, group, n, name="Node 1", cluster=FALSE)
```

See help pages for detailed explanation of the input parameters.


##	Differential gene expression analysis

Together with FateID a function for differential gene expression analysis is provided. This function implements an approach similar to DESeq [@DESeq] by which negative binomial distributions are fitted to transcript counts in two populations, representing, for instance, two different cell types. By default, the function should be executed on normalized data and estimates the dispersion parameter from the polynomial fit of the log-transformed transcript count variance as a function of the log-transformed mean expression. This is done on the input data, either after pooling cells from the two populations or on each of the populations separately. Alternatively, one can also provide a function for the variance-mean dependence as an input parameter, e. g. the dependence computed in the RaceID2 [@StemID] outlier identification. As another option, the function can also execute a standard DESeq2 [@DESeq2] differential expression analysis.

To run the analysis, an expression data frame is needed as input together with two vectors of cell IDs corresponding to subsets of column names of this data frame. 

For example, this function could be used to identify genes differentially expressed between cells in the original clusters 3,4,5 (the progenitor compartment) that are either biased towards enterocytes (cluster 6) or goblet cells (cluster 13) with a fate-probability of >0.5:

```{r}
thr <- .5
a   <- "t13"
b   <- "t6"
cl  <- c(3,4,5)
A <- rownames(fb$probs)[fb$probs[,a] > thr]
A <- A[y[A] %in% cl]
B <- rownames(fb$probs)[fb$probs[,b] > thr]
B <- B[y[B] %in% cl]
de <- diffexpnb(v,A=A,B=B,DESeq=FALSE,norm=FALSE,vfit=NULL,locreg=FALSE)
```

Here, we use the full expression data frame without feature selection as input. Normalization is not performed, since `v` is already normalized by size. With the chosen input parameters, diffexpnb will infer the dispersion parameter of the negative binomial transcript level distributions for the two populations based on a variance-mean dependence derived as in RaceID2 [@StemID]. Alternatively, a local regression can be utilized, if `locreg` equals `TRUE`. Another option is to run a DESeq2 [@DESeq2] analysis, if `DESeq` is `TRUE`.
The function returns a list of three components. The results of the differential gene expression analysis are stored in the res component, which is a data frame displaying mean expression of the two sets, fold change and log2 fold-change between the two sets, the p-value for differential expression (`pval`) and the Benjamini-Hochberg corrected false discovery rate (`padj`).

The results can be plotted by the following function:

```{r}
plotdiffgenesnb(de,mthr=-4,lthr=0,Aname=a,Bname=b,padj=FALSE)
```

##	Inspecting fate bias of gene expression

To enable further inspection of fate-specific marker gene expression, `FateID` provides a function to plot the expression levels of two genes against each other in a scatter plot. These genes could, for instance, represent markers of two different lineages, and the function reveals whether the expression domains of these genes fall into distinct clusters or whether they correlate with the fate bias towards a particular lineage.
To visualize a correlation of gene expression domain and cluster origin of the cells, the `gene2gene` function can be called with a gene expression data frame and a clustering partition as input:

```{r}
gene2gene(intestine$v,intestine$y,"Muc2__chr7","Apoa1__chr9")
```

If the fate bias towards a particular target cluster, e. g. cluster 6, should be highlighted, the output `fb` of the `fateBias` function and the column name of `fb$probs` corresponding to the target cluster, i. e. `t6`, are required as additional input parameters:

```{r} 
gene2gene(intestine$v, intestine$y, "Muc2__chr7", "Apoa1__chr9", fb=fb, tn="t6", plotnum=FALSE)
```

See help pages for additional input arguments.

  
To identify genes involved in early priming and fate decision at all stages of differentiation, it is informative to extract all the genes with a high importance value (see details of the randomForest function in the randomForest package) for the classification into a given target cluster in at least one random forest iteration:

```{r}
k <- impGenes(fb,"t6")
```

This function requires the output object of the `fateBias` function and the number of a target clusters, concatenated with a `t` as input. Additional optional arguments specify cutoffs for the importance values (see help pages). It returns a list of two objects, one data frame with mean importance values for all genes that passed the thresholds in at least of the iterations as rows and the iterations as columns, and a corresponding data frame with the standard deviation of the importance values.

The function also plots a heatmap of the importance values with hierarchical clustering of the genes.


For bug reports and any questions related to FateID please email directly to [link](mailto:dominic.gruen@gmail.com). 

## References

---
references:

- id: FateID
  type: article-journal
  author:
  - family: Herman
    given: J. S.
  - family: Sagar
    given:
  - family: GrÃ¼n
    given: D.
  issued:
  - year: '2018'
    month: '5'
  title: '[FateID infers cell fate bias in multipotent progenitors from single-cell RNA-seq data]{.nocase}'
  container-title: Nat. Methods
  page: '379-386'
  volume: '15'
  issue: '5'
  
- id: Census
  type: article-journal
  author:
  - family: Qiu
    given: X.
  - family: Hill
    given: A.
  - family: Packer
    given: J.
  - family: Lin
    given: D.
  - family: Ma
    given: Y. A.
  - family: Trapnell
    given: C.
  issued:
  - year: '2017'
    month: '3'
  title: '[Single-cell mRNA quantification and differential analysis with Census]{.nocase}'
  container-title: Nat. Methods
  page: '309-315'
  volume: '14'
  issue: '3'

- id: StemID
  type: article-journal
  author:
  - family: Grun
    given: D.
  - family: Muraro
    given: M. J.
  - family: Boisset
    given: J. C.
  - family: Wiebrands
    given: K.
  - family: Lyubimova
    given: A.
  - family: Dharmadhikari
    given: G.
  - family: Born
    given: M.
    dropping-particle: van den
  - family: Es
    given: J.
    dropping-particle: van
  - family: Jansen
    given: 'E.'
  - family: Clevers
    given: H.
  - family: Koning
    given: E. J. P.
    dropping-particle: de
  - family: Oudenaarden
    given: A.
    dropping-particle: van
  issued:
  - year: '2016'
    month: '8'
  title: '[De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome
    Data]{.nocase}'
  container-title: Cell Stem Cell
  page: '266-277'
  volume: '19'
  issue: '2'

- id: DESeq
  type: article-journal
  author:
  - family: Anders
    given: S.
  - family: Huber
    given: W.
  issued:
  - year: '2010'
  title: '[Differential expression analysis for sequence count data]{.nocase}'
  container-title: Genome Biol.
  page: R106
  volume: '11'
  issue: '10'

- id: DESeq2
  type: article-journal
  author:
  - family: Love
    given: M. I.
  - family: Huber
    given: W.
  - family: Anders
    given: S.
  issued:
  - year: '2014'
  title: '[Moderated estimation of fold change and dispersion for RNA-seq data with
    DESeq2]{.nocase}'
  container-title: Genome Biol.
  page: '550'
  volume: '15'
  issue: '12'

- id: RandomForests
  type: article-journal
  author:
  - family: Breiman
    given: L.
  issued:
  - year: '2001'
  title: '[Random Forests]{.nocase}'
  container-title: Mach. Learn.
  page: '5-32'
  volume: '45'
  issue: '1'

- id: TSNE
  type: article-journal
  author:
  - family: Maaten
    given: L.
    dropping-particle: van der
  - family: Hinton
    given: G.
  issued:
  - year: '2008'
  title: '[Visualizing Data using t-SNE]{.nocase}'
  container-title: J. Mach. Learn.
  page: '2570-2605'
  volume: '9'

- id: DPT
  type: article-journal
  author:
  - family: Haghverdi
    given: L.
  - family: Buttner
    given: M.
  - family: Wolf
    given: F. A.
  - family: Buettner
    given: F.
  - family: Theis
    given: F. J.
  issued:
  - year: '2016'
    month: '10'
  title: '[Diffusion pseudotime robustly reconstructs lineage branching]{.nocase}'
  container-title: Nat. Methods
  page: '845-848'
  volume: '13'
  issue: '10'

- id: Destiny
  type: article-journal
  author:
  - family: Angerer
    given: P.
  - family: Haghverdi
    given: L.
  - family: Buttner
    given: M.
  - family: Theis
    given: F. J.
  - family: Marr
    given: C.
  - family: Buettner
    given: F.
  issued:
  - year: '2016'
    month: '4'
  title: '[destiny: diffusion maps for large-scale single-cell data in R]{.nocase}'
  container-title: Bioinformatics
  page: '1241-1243'
  volume: '32'
  issue: '8'
...

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{compdr}
\alias{compdr}
\title{Computation of dimensional reduction representations}
\usage{
compdr(
  x,
  z = NULL,
  m = c("tsne", "cmd", "lle", "umap"),
  k = 2,
  lle.n = 30,
  tsne.perplexity = 30,
  umap.pars = NULL,
  seed = 12345
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{z}{Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is \code{NULL}. In this case, a correlation-based distance is computed from \code{x} by \code{1 - cor(x)}}

\item{m}{a vector of dimensional reduction representations to be computed. The following representations can be computed: \code{lle} (locally-linear embedding), \code{cmd} (classical multidimensional scaling), \code{dm} (diffusion map), \code{tsne} (t-SNE map), \code{umap} (umap). The default value of m is \code{c("cmd","tsne","umap")}. Any subset of methods can be selected.}

\item{k}{vector of integers representing the dimensions for which the dimensional reduction representations will be computed. Default value is \code{2}.}

\item{lle.n}{integer number for the number of neighbours used in the \code{lle} algorithm. Default value is 30.}

\item{tsne.perplexity}{positive number. Perplexity used in the t-SNE computation. Default value is 30.}

\item{umap.pars}{umap parameters. See \pkg{umap} package, \code{umap.defaults}. Default is \code{NULL} and \code{umap.defaults} are used. \code{umap.pars$input} is automatically set to \code{"dist"}, since the umap is computed for the distance object.}

\item{seed}{integer seed for initialization. If equal to \code{NULL} then each run will yield slightly different results due to the randomness of the random forest algorithm. Default is \code{NULL}}
}
\value{
A two-dimensional list with the dimensional reduction representation stored as data frames as components. Component names for the first dimension are given by one of the following algorithms:
  \item{lle}{locally linear embedding calculated by the lle function from the \pkg{lle} package.}
  \item{cmd}{classical multidimensional scaling computed by the \code{cmdscale} function of the \pkg{stats} package.}
  \item{tsne}{t-SNE map computed by the \code{Rtsne} function of the \pkg{Rtsne} package.}
  \item{umap}{umap computed by the \code{umap} function of the \pkg{umap} package.}

Component names of the second dimension are a concatenation of a capital D and an integer number of the dimension. There is one component for each dimension in \code{k}.
}
\description{
This function computes dimensional reduction representations to a specified number of dimensions using a number of different algorithms: t-SNE, cmd, lle, diffusion maps, umap
}
\examples{

x <- intestine$x
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
plot(dr[["cmd"]][["D2"]],pch=20,col="grey")

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{filterset}
\alias{filterset}
\title{Function for filtering expression data}
\usage{
filterset(x, n = NULL, minexpr = 2, minnumber = 1)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.}

\item{n}{ordered vector of cell IDs to be included. Cell IDs need to be column names of \code{x}. If not provided, then all cell IDs are included in arbitray order. Default value is \code{NULL}.}

\item{minexpr}{positive real number. This is the minimum expression required for at least \code{minnumber} cells. All genes that do not fulfill this criterion are removed. The default value is 2.}

\item{minnumber}{positive integer number. This is the minimum number of cells in which a gene needs to be expressed at least at a level of \code{minexpr}. All genes that do not fulfill this criterion are removed. The default value is 1.}
}
\value{
Reduced expression data frame with genes as rows and cells as columns in the same order as in \code{n}.
}
\description{
This function discards lowly expressed genes from the expression data frame.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/intestine.R
\docType{data}
\name{intestine}
\alias{intestine}
\title{Single-cell transcriptome data of intestinal epithelial cells}
\format{
A list of the following 5 components:
\describe{
  \item{x}{data frame with genes as rows and cells as columns. This reduced data frame only contains expression of the most variable genes.}
  \item{y}{vector containing a clustering partition of the 278 cells into different cell types}
  \item{v}{data frame with genes as rows and cells as columns. This data frame contains expression of all genes.}
  \item{fcol}{vector containing colour values for all clusters in \code{y}}
}
}
\usage{
intestine
}
\value{
None
}
\description{
This dataset contains gene expression values, i. e. transcript counts, of 278 intestinal epithelial cells, and additional information on different cell types in this sample.
}
\references{
GrÃ¼n et al. (2016) Cell Stem Cell 19(2): 266-77
(\href{https://pubmed.ncbi.nlm.nih.gov/27345837/}{PubMed})
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{plotdiffgenesnb}
\alias{plotdiffgenesnb}
\title{Function for plotting differentially expressed genes}
\usage{
plotdiffgenesnb(
  x,
  pthr = 0.05,
  padj = TRUE,
  lthr = 0,
  mthr = -Inf,
  Aname = NULL,
  Bname = NULL,
  show_names = TRUE,
  ...
)
}
\arguments{
\item{x}{output of the function \code{diffexpnb}.}

\item{pthr}{real number between 0 and 1. This number represents the p-value cutoff applied for displaying differentially expressed genes. Default value is 0.05. The parameter \code{padj} (see below) determines if this cutoff is applied to the uncorrected p-value or to the Benjamini-Hochberg corrected false discovery rate.}

\item{padj}{logical value. If \code{TRUE}, then genes with a Benjamini-Hochberg corrected false discovery rate lower than \code{pthr} are displayed. If \code{FALSE}, then genes with a p-value lower than \code{pthr} are displayed.}

\item{lthr}{real number between 0 and Inf. Differentially expressed genes are displayed only for log2 fold-changes greater than \code{lthr}. Default value is 0.}

\item{mthr}{real number between -Inf and Inf. Differentially expressed genes are displayed only for log2 mean expression greater than \code{mthr}. Default value is -Inf.}

\item{Aname}{name of expression set \code{A}, which was used as input to \code{diffexpnb}. If provided, this name is used in the axis labels. Default value is \code{NULL}.}

\item{Bname}{name of expression set \code{B}, which was used as input to \code{diffexpnb}. If provided, this name is used in the axis labels. Default value is \code{NULL}.}

\item{show_names}{logical value. If \code{TRUE} then gene names displayed for differentially expressed genes. Default value is \code{FALSE}.}

\item{...}{Additional arguments for function \code{plot}.}
}
\value{
None
}
\description{
This is a plotting function for visualizing the output of the \code{diffexpnb} function as MA plot.
}
\examples{

x <- intestine$x
y <- intestine$y
v <- intestine$v

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)

thr <- .3

A <- rownames(fb$probs)[fb$probs[,"t6"]  > .3]
B <- rownames(fb$probs)[fb$probs[,"t13"] > .3]
de <- diffexpnb(v,A=A,B=B)
plotdiffgenesnb(de,pthr=.05)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{plotheatmap}
\alias{plotheatmap}
\title{Heatmap of expression profiles}
\usage{
plotheatmap(
  x,
  xpart = NULL,
  xcol = NULL,
  xlab = TRUE,
  xgrid = FALSE,
  ypart = NULL,
  ycol = NULL,
  ylab = TRUE,
  ygrid = FALSE,
  cex = 1
)
}
\arguments{
\item{x}{data frame with input data to show. Columns will be displayed on the x-axis and rows on the y-axis in the order given in \code{x}. For example, columns can correspond to cells in pseudo-temporal order and rows contain gene expression, i. e. rows can represent pseudo-temporal gene expression profiles.}

\item{xpart}{optional vector with integer values indicating partitioning of the data points along the x-axis. For instance, \code{xpart} can be a cluster assignment of cell IDs. The order of the components has to be the same as for the columns in \code{x}. Default value is \code{NULL}.}

\item{xcol}{optional vector with valid color names. The number of components has to be equal to the number of different values on \code{xpart}. If provided, these colors are used to highlight partitioning along the x-axis based on \code{xpart}. Default value is \code{NULL}.}

\item{xlab}{logical value. If \code{TRUE} then the average position is indicated for each partition value along the x-axis. Default value is \code{TRUE}.}

\item{xgrid}{logical value. If \code{TRUE} then the partitioning along the x-axis is indicated by vertical lines representing the boundaries of all positions with a given value in \code{xpart}.}

\item{ypart}{optional vector with integer values indicating partitioning of the data points along the y-axis. For instance, \code{ypart} can be the assignment of gene IDs to nodes of a sel-organizing map. The order of the components has to be the same as for the rows in \code{x}. Default value is \code{NULL}.}

\item{ycol}{optional vector with valid color names. The number of components has to be equal to the number of different values on \code{ypart}. If provided, these colors are used to highlight partitioning along the y-axis based on \code{ypart}. Default value is \code{NULL}.}

\item{ylab}{logical value. If \code{TRUE} then the average position is indicated for each partition value along the y-axis. Default value is \code{TRUE}.}

\item{ygrid}{logical value. If \code{TRUE} then the partitioning along the y-axis is indicated by horizontal lines representing the boundaries of all positions with a given value in \code{ypart}.}

\item{cex}{positive real number. Size of axis labels. Default is 1.}
}
\value{
None
}
\description{
This function allows plotting of normalized or z-score transformed pseudo-temporal expression profiles and permits highlighting of partitioning along the x-axis and the y-axis
}
\examples{

\donttest{
x <- intestine$x
y <- intestine$y
v <- intestine$v
fcol <- intestine$col

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n <- pr$trc[["t6"]]
fs  <- filterset(v,n,minexpr=2,minnumber=1)
s1d <- getsom(fs,nb=1000,alpha=.5)
ps <- procsom(s1d,corthr=.85,minsom=3)
plotheatmap(ps$all.e,xpart=y[n],xcol=fcol,ypart=ps$nodes,xgrid=FALSE,ygrid=TRUE,xlab=FALSE)
}

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{getPart}
\alias{getPart}
\title{Inference of a cell type partition}
\usage{
getPart(x, FMarker, fthr = NULL, n = 25)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{FMarker}{list of vectors of gene IDs corresponding to valid rownames of \code{x}. The gene IDs within each component of \code{FMarker} are considered as marker genes of one of the cell types in the dataset. The aggregated expression of the genes for each component is compared to a threshold defined by the input argument \code{fthr} or \code{n}. All cells exceeding this threshold are assigned to a cluster representing cells with expression of the respective marker genes.}

\item{fthr}{vector of real positive numbers. This vector has to have the same length as the list \code{FMarker} and contains a threshold for the aggregated expression of all genes in the corresponding component of \code{FMarker}. If NULL then a threshold is inferred from the \code{n} top-expressing cells for the genes in the respective component of \code{FMarker}.}

\item{n}{positive integer number. For each component of \code{FMarker} the expression of all genes is aggregated in every cell and the \code{n} top-expressing cells are extracted. The average expression across these cell defines the expression threshold applied to infer the partitioning. Default value is 25.}
}
\value{
A list with the following three components:
  \item{part}{A vector with a partitioning, i. e. cluster assignment for each cell.}
  \item{tar}{A vector with the numbers of target clusters. Cluster 1 comprises all cells with no enrichment of marker genes. The remaining clusters correspond to cell types up-regulating the markers in the list \code{FMarker} in the same order as in this list.}
  \item{thr}{A vector with expression threshold values applied for each component in the list \code{FMarker} in the same order as in this list.}
}
\description{
This function performs an inference of a cell type partition based on the expression of marker genes.
}
\examples{
x <- intestine$x
y <- intestine$y

FMarker <- list(c("Defa20__chr8","Defa24__chr8"), "Clca3__chr3", "Alpi__chr1")
xf <- getPart(x,FMarker,fthr=NULL,n=5)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{diffexpnb}
\alias{diffexpnb}
\title{Function for differential expression analysis}
\usage{
diffexpnb(
  x,
  A,
  B,
  DESeq = FALSE,
  method = "pooled",
  norm = FALSE,
  vfit = NULL,
  locreg = FALSE,
  ...
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis. This input has to be provided if \code{g} (see below) is given and corresponds to a valid gene ID, i. e. one of the rownames of \code{x}. The default value is \code{NULL}. In this case, cluster identities are highlighted in the plot.}

\item{A}{vector of cell IDs corresponding column names of \code{x}. Differential expression in set \code{A} versus set \code{B} will be evaluated.}

\item{B}{vector of cell IDs corresponding column names of \code{x}. Differential expression in set \code{A} versus set \code{B} will be evaluated.}

\item{DESeq}{logical value. If \code{TRUE}, then \pkg{DESeq2} is used for the inference of differentially expressed genes. In this case, it is recommended to provide non-normalized input data \code{x}. Default value is \code{FALSE}}

\item{method}{either "per-condition" or "pooled". If DESeq is not used, this parameter determines, if the noise model is fitted for each set separately ("per-condition") or for the pooled set comprising all cells in \code{A} and \code{B}. Default value is "pooled".}

\item{norm}{logical value. If \code{TRUE} then the total transcript count in each cell is normalized to the minimum number of transcripts across all cells in set \code{A} and \code{B}. Default value is \code{FALSE}.}

\item{vfit}{function describing the background noise model. Inference of differentially expressed genes can be performed with a user-specified noise model describing the expression variance as a function of the mean expression. Default value is \code{NULL}.}

\item{locreg}{logical value. If \code{FALSE} then regression of a second order polynomial is perfomed to determine the relation of variance and mean. If \code{TRUE} a local regression is performed instead. Default value is \code{FALSE}.}

\item{...}{additional arguments to be passed to the low level function \code{DESeqDataSetFromMatrix}.}
}
\value{
If \code{DESeq} equals \code{TRUE}, the function returns the output of \pkg{DESeq2}. In this case list of the following two components is returned:
\item{cds}{object returned by the \pkg{DESeq2} function \code{DESeqDataSetFromMatrix}.}
\item{res}{data frame containing the results of the \pkg{DESeq2} analysis.}
Otherwise, a list of three components is returned:
\item{vf1}{a data frame of three columns, indicating the mean \code{m}, the variance \code{v} and the fitted variance \code{vm} for set \code{A}.}
\item{vf2}{a data frame of three columns, indicating the mean \code{m}, the variance \code{v} and the fitted variance \code{vm} for set \code{B}.}
\item{res}{a data frame with the results of the differential gene expression analysis with the structure of the \code{DESeq} output, displaying mean expression of the two sets, fold change and log2 fold change between the two sets, the p-value for differential expression (\code{pval}) and the Benjamini-Hochberg corrected false discovery rate (\code{padj}).}
}
\description{
This function performs differential expression analysis between two sets of single cell transcriptomes. The inference is based on a noise model or relies on the \code{DESeq2} approach.
}
\examples{

x <- intestine$x
y <- intestine$y
v <- intestine$v

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)

thr <- .3

A <- rownames(fb$probs)[fb$probs[,"t6"]  > .3]
B <- rownames(fb$probs)[fb$probs[,"t13"] > .3]
de <- diffexpnb(v,A=A,B=B)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{gene2gene}
\alias{gene2gene}
\title{Comparative plot of the expression levels of two genes}
\usage{
gene2gene(
  x,
  y,
  g1,
  g2,
  clusters = NULL,
  fb = NULL,
  tn = NULL,
  col = NULL,
  tp = 1,
  plotnum = TRUE,
  seed = 12345
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{g1}{gene id corresponding to a valid row names of x. Expression of gene \code{g1} versus gene \code{g2} will be plotted.}

\item{g2}{gene id corresponding to a valid row names of x. Expression of gene \code{g1} versus gene \code{g2} will be plotted.}

\item{clusters}{vector of valid cluster ids. Expression is displayed for cells in any of the clusters contained in \code{clusters}. If the argument is not given, cells of all clusters are displayed. Default value is \code{NULL}.}

\item{fb}{fateBias object returned by the function \code{fateBias}. Default value is \code{NULL}. Only if both \code{tn} and \code{fb} are provided as input, the fate bias will be colour coded.}

\item{tn}{name of a target cluster, i. e. concatenation of a \code{t} and the number of a target cluster. Has to correspond to a column name of \code{fb$probs}. The default value is \code{NULL}. Only if both \code{tn} and \code{fb} are provided as input, the fate bias will be colour coded.}

\item{col}{optional vector of valid color names for all clusters in \code{y} ordered by increasing cluster number. Default value is \code{NULL}.}

\item{tp}{Transparency of points in the plot. Default value is 1, i. e. non-transparent.}

\item{plotnum}{logical value. If \code{TRUE}, then cluster numbers are displayed on top of the data points. Default value is \code{TRUE}.}

\item{seed}{integer number. Random seed for determining colour scheme. Default is 12345.}
}
\value{
None
}
\description{
This function produces a scatter plot of the expression levels of two genes. It allows plotting cells of selected clusters and permits highlighting of the fate bias.
}
\examples{
x <- intestine$x
y <- intestine$y
v <- intestine$v

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
gene2gene(v,y,"Muc2__chr7","Apoa1__chr9")
gene2gene(v,y,"Muc2__chr7","Apoa1__chr9",fb=fb,tn="t6",plotnum=FALSE)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{reclassify}
\alias{reclassify}
\title{Reclassification of cells}
\usage{
reclassify(
  x,
  y,
  tar,
  z = NULL,
  clthr = 0.75,
  nbfactor = 5,
  use.dist = FALSE,
  seed = NULL,
  nbtree = NULL,
  q = 0.9,
  ...
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{tar}{vector of integers representing target cluster numbers. Each element of \code{tar} corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.}

\item{z}{Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is \code{NULL}. In this case, a correlation-based distance is computed from \code{x} by \code{1 - cor(x)}}

\item{clthr}{real number between zero and one. This is the threshold for the fraction of random forest votes required to assign a cell not contained within the target clusters to one of these clusters. The value of this parameter should be sufficiently high to only reclassify cells with a high-confidence assignment. Default value is 0.9.}

\item{nbfactor}{positive integer number. Determines the number of trees grown for each random forest. The number of trees is given by the number of columns of th training set multiplied by \code{nbfactor}. Default value is 5.}

\item{use.dist}{logical value. If \code{TRUE} then the distance matrix is used as feature matrix (i. e. \code{z} if not equal to \code{NULL} and \code{1-cor(x)} otherwise). If \code{FALSE}, gene expression values in \code{x} are used. Default is \code{FALSE}.}

\item{seed}{integer seed for initialization. If equal to \code{NULL} then each run will yield slightly different results due to the radomness of the random forest algorithm. Default is \code{NULL}}

\item{nbtree}{integer value. If given, it specifies the number of trees for each random forest explicitely. Default is \code{NULL}.}

\item{q}{real value between zero and one. This number specifies a threshold used for feature selection based on importance sampling. A reduced expression table is generated containing only features with an importance larger than the q-quantile for at least one of the classes (i. e. target clusters). Default value is 0.75.}

\item{...}{additional arguments to be passed to the low level function \code{randomForest}.}
}
\value{
A list with the following three components:
  \item{part}{A vector with the revised cluster assignment for each cell in the same order as in the input argument \code{y}.}
  \item{rf}{The random forest object generated for the reclassification, with enabled importance sampling (see \pkg{randomForest}).}
  \item{xf}{A filtered expression table with features extracted based on the important samples, only features with an importance larger than the q-quantile are for at least one of the classes are retained.}
}
\description{
This function attempts to reassign additional cells in the dataset to one of the target clusters.
}
\details{
The function uses random forest based supervised learning to assign cells not contained in the target clusters to one of these clusters. All cells not within any of the target clusters which receive a fraction of votes larger than \code{clthr} for one of the target clusters will be reassigned to this cluster. Since this function is developed to reclassify cells only if they can be assigned with high confidence, a high value of \code{clthr} (e. g. > 0.75) should be applied.
}
\examples{
x <- intestine$x
y <- intestine$y
tar <- c(6,9,13)
rc <- reclassify(x,y,tar,z=NULL,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL,q=.9)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{plotexpression}
\alias{plotexpression}
\title{Plotting of pseudo-temporal expression profiles}
\usage{
plotexpression(
  x,
  y,
  g,
  n,
  logsc = FALSE,
  col = NULL,
  name = NULL,
  cluster = FALSE,
  alpha = 0.5,
  types = NULL,
  cex = 3,
  ylim = NULL,
  map = TRUE,
  leg = TRUE,
  seed = 12345,
  ylab = NULL
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of \code{x}.}

\item{g}{a gene ID corresponding to one of the rownames of \code{x}. It can also be a vector of gene IDs. In this case, the aggregated expression across all gene IDs is plotted.}

\item{n}{ordered vector of cell IDs to be included. Cell IDs need to be column names of \code{x}.}

\item{logsc}{logical value. If \code{TRUE}, then log2-transformed values are plotted. Default is \code{FALSE} and untransformed values are plotted.}

\item{col}{optional vector of valid color names for all clusters in \code{y} ordered by increasing cluster number. Default value is \code{NULL}.}

\item{name}{optional character string. This argument corresponds to a title for the plot. Default value is \code{NULL}. If not provided, and \code{g} is given, then \code{name} will equal \code{g} or \code{g[1]}, respectively, if \code{g} is a vector of gene IDs.}

\item{cluster}{logical value. If \code{TRUE} then the partitioning along the x-axis is indicated be vertical lines representing the boundaries of all positions with a given value in \code{y}. The average position across all cells in a cluster will be indicated on the x-axis.}

\item{alpha}{positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function \code{loess} from the package \pkg{stats}. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.}

\item{types}{optional vector with IDs for different subsets of cells in \code{y}, e. g. different batches. All cells with the same ID will be displayed by the same symbol and color. Default value is \code{NULL}}

\item{cex}{size of data points. Default value is 3.}

\item{ylim}{vector of two numerical values: lower and upper limit of values shown on the y-axis. Default value is \code{NULL} and the whole range is shown.}

\item{map}{logical. If \code{TRUE} then data points are shown. Default value is \code{TRUE}.}

\item{leg}{logical. If \code{TRUE} then axes and labels are shown. Default value is \code{TRUE}.}

\item{seed}{integer number. Random seed for determining colour scheme. Default is 12345.}

\item{ylab}{Optional label for the y-axis. Default is \code{NULL} and axis is labeled "norm. expression".}
}
\value{
None
}
\description{
This function allows plotting pseudo-temporal expression profiles for single genes or groups of genes.
}
\examples{

\donttest{
x <- intestine$x
y <- intestine$y
v <- intestine$v
fcol <- intestine$col
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n <- pr$trc[["t6"]]
fs  <- filterset(v,n,minexpr=2,minnumber=1)
s1d <- getsom(fs,nb=1000,alpha=.5)
ps <- procsom(s1d,corthr=.85,minsom=3)
# plot average profile of all genes of node 1 in the self-organizing map
g <- names(ps$nodes)[ps$nodes == 1]
plotexpression(v,y,g,n,col=fcol,name="Node 1",cluster=FALSE,alpha=.5,types=NULL)
}

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{getFeat}
\alias{getFeat}
\title{Feature selection based on differentially expressed genes}
\usage{
getFeat(x, y, tar, fpv = 0.05, ...)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{tar}{vector of integers representing target cluster numbers. Each element of \code{tar} corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.}

\item{fpv}{p-value cutoff for calling differentially expressed genes. This is a cutoff for the Benjamini-Hochberg corrected false discovery rate. Default value is 0.05.}

\item{...}{additional arguments to be passed to the low level function \code{diffexpnb}.}
}
\value{
A filtered expression table with features extracted based on differentially expressed genes.
}
\description{
This function performs a feature selection based on the inference of differentially expressed genes between each target cluster and all remaining cells.
}
\details{
The function determines differentially expressed between the cells in each of the target clusters in comparison to the remaining cells by using \code{diffexpnb} function.
}
\examples{
x <- intestine$x
y <- intestine$y
tar <- c(6,9,13)
xf <- getFeat(x,y,tar,fpv=.05)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{prcurve}
\alias{prcurve}
\title{Computation of a principal curve for a given dimensional reduction representation}
\usage{
prcurve(y, fb, dr, k = 2, m = "cmd", trthr = NULL, start = NULL, ...)
}
\arguments{
\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{fb}{fateBias object returned by the function \code{fateBias}.}

\item{dr}{list of dimensional reduction representations returned by the function \code{compdr}.}

\item{k}{integer number for the dimension to be used. This dimension has to be present in \code{dr}. Default value is 2.}

\item{m}{name of the dimensional reduction algorithms to be used for the principal curve computation. One of \code{lle}, \code{cmd}, \code{dm}, \code{tsne}, \code{umap}. Default value is \code{cmd}. Has to be a component of \code{dr}, i.e. previously computed by \code{compdr}.}

\item{trthr}{real value representing the threshold of the fraction of random forest votes required for the inclusion of a given cell for the computation of the principal curve. If \code{NULL} then only cells with a significant bias >1 are included for each trajectory. The bias is computed as the ratio of the number of votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias >1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value < 0.05. Default value is \code{NULL}.}

\item{start}{integer number representing a specified starting cluster number for all trajectories, i. e. a common progenitor cluster. The argument is optional. Default value is \code{NULL}.}

\item{...}{additional arguments to be passed to the low level function \code{principal_curve}.}
}
\value{
A list of the following two components:
  \item{pr}{A list of principal curve objects produced by the \code{principal_curve} function from the \pkg{princurve} package. Each component corresponds to one differentiation trajectory giving rise to one of the target clusters from the \code{fb} object.}
  \item{trc}{A list of ordered cell IDs for each trajectory in \code{pr}.}
}
\description{
This function computes a principal curve for a given dimensional reduction representation which is specified by component names of an object returned by \code{compdr} using the \pkg{princurve} package.
}
\details{
The function computes a principal curve for each differentiation trajectory by considering only cells that are assigned to the trajectory with a significant fate bias >1 or at least \code{trthr} of the random forest votes, respectively.

For simulateneous computation and plotting of the principal curve, see function \code{plotFateMap}.
}
\examples{

x <- intestine$x
y <- intestine$y
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.25,start=NULL)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{procsom}
\alias{procsom}
\title{Processing of self-organizing maps for pseudo-temporal expression profiles}
\usage{
procsom(s1d, corthr = 0.85, minsom = 3)
}
\arguments{
\item{s1d}{output of function \code{getsom}}

\item{corthr}{correlation threshold, i. e. a real number between 0 and 1. The z-score of the average normalized pseudo-temporal expression profiles within each node of the self-organizing map is computed, and the correlation of these z-scores between neighbouring nodes is computed. If the correlation is greater than \code{corthr}, neighbouring nodes are merged. Default value is 0.85.}

\item{minsom}{positive integer number. Nodes of the self-organizing map with less than \code{minsom} transcripts are discarded. Default value is 3.}
}
\value{
A list of the following seven components:
\item{k}{vector of Pearson's correlation coefficient between node \code{i} and node \code{i+1} of the populated nodes of the self-organizing map.}
\item{nodes}{vector with assignment of genes to nodes of the final self-organizing map (after merging). Components are node numbers and component names are gene IDs.}
\item{nodes.e}{data frame with average normalized pseudo-temporal expression profile for each node, ordered by node number.}
\item{nodes.z}{data frame with z-score transformed average normalized pseudo-temporal expression profile for each node, ordered by node number.}
\item{all.e}{data frame with normalized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number.}
\item{all.z}{data frame with z-score transformed normalized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number.}
\item{all.b}{data frame with binarized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number. Expression is 1 in cells with z-score > 1 and -1 in cells with z-score < -1, and 0 otherwise.}
}
\description{
This function processes the self-organizing maps produced by the function \code{getsom}.
}
\examples{

\donttest{
x <- intestine$x
y <- intestine$y
v <- intestine$v

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n <- pr$trc[["t6"]]
fs  <- filterset(v,n,minexpr=2,minnumber=1)
s1d <- getsom(fs,nb=1000,alpha=.5)
ps <- procsom(s1d,corthr=.85,minsom=3)
}

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{plotexpressionProfile}
\alias{plotexpressionProfile}
\title{Plotting smoothed pseudo-temporal expression profiles for groups of genes}
\usage{
plotexpressionProfile(
  x,
  y,
  g,
  n,
  logsc = FALSE,
  col = NULL,
  name = NULL,
  cluster = FALSE,
  alpha = 0.5,
  lwd = 1,
  ylim = NULL,
  seed = 12345,
  ylab = NULL
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of \code{x}.}

\item{g}{a gene ID corresponding to one of the rownames of \code{x}. It can also be vector of gene IDs. In this case, a separate profile is plotted for each gene in \code{g}.}

\item{n}{ordered vector of cell IDs to be included. Cell IDs need to be column names of \code{x}.}

\item{logsc}{logical value. If \code{TRUE}, then log2-transformed values are plotted. Default is \code{FALSE} and untransformed values are plotted.}

\item{col}{optional vector of valid color names used for the profiles of all genes in \code{g}. Default value is \code{NULL}.}

\item{name}{optional character string. This argument corresponds to a title for the plot. Default value is \code{NULL}. If not provided, and \code{g} is given, then \code{name} will equal \code{g} or \code{g[1]}, respectively, if \code{g} is a vector of gene IDs.}

\item{cluster}{logical value. If \code{TRUE} then the partitioning along the x-axis is indicated be vertical lines representing the boundaries of all positions with a given value in \code{y}. The average position across all cells in a cluster will be indicated on the x-axis.}

\item{alpha}{positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function \code{loess} from the package \pkg{stats}. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.}

\item{lwd}{line width of profiles. Default value is 1.}

\item{ylim}{vector of two numerical values: lower and upper limit of values shown on the y-axis. Default value is \code{NULL} and the whole range is shown.}

\item{seed}{integer number. Random seed for determining colour scheme. Default is 12345.}

\item{ylab}{Optional label for the y-axis. Default is \code{NULL} and axis is labeled "norm. expression".}
}
\value{
None
}
\description{
This function allows plotting loess-smoothed pseudo-temporal expression profiles for groups of genes. To display gene expression profiles on the same scale, row sums are normalized to one.
}
\examples{

\donttest{
x <- intestine$x
y <- intestine$y
v <- intestine$v
fcol <- intestine$col
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n <- pr$trc[["t6"]]
fs  <- filterset(v,n,minexpr=2,minnumber=1)
s1d <- getsom(fs,nb=1000,alpha=.5)
ps <- procsom(s1d,corthr=.85,minsom=3)
# plot average profile of all genes of node 1 in the self-organizing map
g <- sample(names(ps$nodes)[ps$nodes == 1],5)
plotexpressionProfile(v,y,g,n,col=fcol,name="Node 1",alpha=.2)
}

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{fateBias}
\alias{fateBias}
\title{Computation of fate bias}
\usage{
fateBias(
  x,
  y,
  tar,
  z = NULL,
  minnr = NULL,
  minnrh = NULL,
  adapt = TRUE,
  confidence = 0.75,
  nbfactor = 5,
  use.dist = FALSE,
  seed = NULL,
  nbtree = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.}

\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{tar}{vector of integers representing target cluster numbers. Each element of \code{tar} corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.}

\item{z}{Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is \code{NULL}. In this case, a correlation-based distance is computed from \code{x} by \code{1 - cor(x)}.}

\item{minnr}{integer number of cells per target cluster to be selected for classification (test set) in each iteration. For each target cluster, the \code{minnr} cells with the highest similarity to a cell in the training set are selected for classification. If \code{z} is not \code{NULL} it is used as the similarity matrix for this step. Otherwise, \code{1-cor(x)} is used. Default value is \code{NULL} and \code{minnr} is estimated as the minimum of and 20 and half the median of target cluster sizes.}

\item{minnrh}{integer number of cells from the training set used for classification. From each training set, the \code{minnrh} cells with the highest similarity to the training set are selected. If \code{z} is not \code{NULL} it is used as the similarity matrix for this step. Default value is \code{NULL} and \code{minnrh} is estimated as the maximum of and 20 and half the median of target cluster sizes.}

\item{adapt}{logical. If \code{TRUE} then the size of the test set for each target cluster is adapted based on the classification success in the previous iteration. For each target cluster, the number of successfully classified cells is determined, i.e. the number of cells with a minimum fraction of votes given by the \code{confidence} parameter for the target cluster, which gave rise to the inclusion of the cell in the test set (see \code{minnr}). Weights are then derived by dividing this number by the maximum across all clusters after adding a pseudocount of 1. The test set size \code{minnr} is rescaled for each cluster by the respective weight in the next iteration. Default is \code{TRUE}.}

\item{confidence}{real number between 0 and 1. See \code{adapt} parameter. Default is 0.75.}

\item{nbfactor}{positive integer number. Determines the number of trees grown for each random forest. The number of trees is given by the number of columns of th training set multiplied by \code{nbfactor}. Default value is 5.}

\item{use.dist}{logical value. If \code{TRUE} then the distance matrix is used as feature matrix (i. e. \code{z} if not equal to \code{NULL} and \code{1-cor(x)} otherwise). If \code{FALSE}, gene expression values in \code{x} are used. Default is \code{FALSE}.}

\item{seed}{integer seed for initialization. If equal to \code{NULL} then each run will yield slightly different results due to the radomness of the random forest algorithm. Default is \code{NULL}}

\item{nbtree}{integer value. If given, it specifies the number of trees for each random forest explicitely. Default is \code{NULL}.}

\item{verbose}{logical. If \code{TRUE}, then print information to console.}

\item{...}{additional arguments to be passed to the low level function \code{randomForest}.}
}
\value{
A list with the following three components:
  \item{probs}{a data frame with the fraction of random forest votes for each cell. Columns represent the target clusters. Column names are given by a concatenation of \code{t} and target cluster number.}
  \item{votes}{a data frame with the number of random forest votes for each cell. Columns represent the target clusters. Column names are given by a concatenation of \code{t} and target cluster number.}
  \item{tr}{list of vectors. Each component contains the IDs of all cells on the trajectory to a given target cluster. Component names are given by a concatenation of \code{t} and target cluster number.}
  \item{rfl}{list of randomForest objects for each iteration of the classification.}
  \item{trall}{vector of cell ids ordered by the random forest iteration in which they have been classified into one of the target clusters.}
}
\description{
This function computes fate biases for single cells based on expression data from a single cell sequencing experiment. It requires a clustering partition and a target cluster representing a commited state for each trajectory.
}
\details{
The bias is computed as the ratio of the number of random forest votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias >1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value < 0.05. Cells are assigned to a trajectory if they exhibit a significant bias >1 for this trajectory.
}
\examples{
x <- intestine$x
y <- intestine$y
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,minnr=5,minnrh=20,adapt=TRUE,confidence=0.75,nbfactor=5)
head(fb$probs)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{impGenes}
\alias{impGenes}
\title{Extract genes with high importance values for random forest classification}
\usage{
impGenes(fb, tn, ithr = 0.02, zthr = 2)
}
\arguments{
\item{fb}{fateBias object returned by the function \code{fateBias}. If \code{fb} is provided, then a principal curve is computed and shown in the plot. Default value is \code{NULL}. The curve is only displayed if \code{g} equal \code{NULL}.}

\item{tn}{name of a target cluster, i. e. concatenation of a \code{t} and the number of a target cluster. Has to correspond to a column name of \code{fb$probs}.}

\item{ithr}{positive real number. Threshold for the required importance measure (mean decrease in accuracy of classification upon removal, see \pkg{randomForest}) to include a gene into the output as important feature for classying cells in \code{tn}. Default value is 0.02.}

\item{zthr}{positive real number. Threshold for the required z-score of the importance measure (importance divided by the standard deviation of importance) to include a gene into the output as important feature for classying cells in \code{tn}. Default value is 2.}
}
\value{
The function returns a list of two elements.
\item{d}{a data frame with mean importance values for all genes surviving the filtering by \code{ithr} and \code{zthr}. Columns correspond to random forest iterations, starting from the initial target cluster.}
\item{d}{a data frame with the standard deviation of importance values for all genes surviving the filtering by \code{ithr} and \code{zthr}. Columns correspond to random forest iterations, starting from the initial target cluster.}
The function produces a heatmap of \code{d} with hierarchical clustering of the rows using the function \code{pheatmap} from the \pkg{pheatmap} package.
}
\description{
This function extracts all genes with an importance value for classifying cells into a given target cluster exceeding a given threshold for at least one of the random forest iterationns.
}
\examples{
x <- intestine$x
y <- intestine$y
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
k <- impGenes(fb,"t6",ithr=.02,zthr=2)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{plotFateMap}
\alias{plotFateMap}
\title{Plot dimensional reduction representation of the expression data}
\usage{
plotFateMap(
  y,
  dr,
  x = NULL,
  g = NULL,
  n = NULL,
  prc = FALSE,
  logsc = FALSE,
  k = 2,
  m = "cmd",
  kr = NULL,
  col = NULL,
  fb = NULL,
  trthr = NULL,
  start = NULL,
  tp = 1,
  seed = 12345,
  ...
)
}
\arguments{
\item{y}{clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.}

\item{dr}{list of dimensional reduction representations returned by the function \code{compdr}.}

\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis. This input has to be provided if \code{g} (see below) is given and corresponds to a valid gene ID, i. e. one of the rownames of \code{x}. The default value is \code{NULL}. In this case, cluster identities are highlighted in the plot.}

\item{g}{either the name of one of the trajectories from \code{fb} or a gene ID corresponding to one of the rownames of \code{x}. In the latter case, the input argument \code{x} needs to be provided. A vector of gene IDs can also be provided. In this case, the aggregated expression across all gene IDs is plotted. If \code{g} equals E, then the entropy of fate bias is displayed. The default value is \code{NULL}. In this case, cluster identities are highlighted in the plot.}

\item{n}{optional character string. This argument corresponds to a title for 2-dimensional plots. Default value is \code{NULL}. If not provided, and \code{g} is given, then \code{n} will equal \code{g} or g[1], respectively, if g is a vector of gene IDs.}

\item{prc}{logical. If \code{TRUE}, then a principal curve is computed and returned. Default is \code{FALSE}.}

\item{logsc}{logical. If \code{TRUE}, then gene expression of fate bias probabilities are plotted on a log2 scale. Default value is \code{FALSE}.}

\item{k}{integer number for the dimension to be used. This dimension has to be present in \code{dr}. Only \code{k=2} is allowed starting from version 0.1.9.}

\item{m}{name of the dimensional reduction algorithms to be used for the principal curve computation. One of \code{lle}, \code{cmd}, \code{dm}, \code{tsne}, \code{umap}. Default value is \code{cmd}. Has to be a component of \code{dr}, i.e. previously computed by \code{compdr}.}

\item{kr}{integer vector. If \code{k}>3 then \code{kr} indicates the dimensions to be plotted (either two or three of all possible dimensions). Default value is \code{NULL}. In this case, \code{kr} is given by \code{1:min(k,3)}.}

\item{col}{optional vector of valid color names for all clusters in \code{y} ordered by increasing cluster number. Default value is \code{NULL}.}

\item{fb}{fateBias object returned by the function \code{fateBias}. If \code{fb} is provided, then a principal curve is computed and shown in the plot. Default value is \code{NULL}. The curve is only displayed if \code{g} equal \code{NULL}.}

\item{trthr}{real value representing the threshold of the fraction of random forest votes required for the inclusion of a given cell for the computation of the principal curve. If \code{NULL} then only cells with a significant bias >1 are included for each trajectory. The bias is computed as the ratio of the number of votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias >1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value < 0.05. Default value is \code{NULL}.}

\item{start}{integer number representing a specified starting cluster number for all trajectories, i. e. a common progenitor cluster. The argument is optional. Default value is \code{NULL}.}

\item{tp}{Transparency of points in the plot to allow better visibility of the principal curves. Default value is 1, i. e. non-transparent.}

\item{seed}{integer number. Random seed for determining colour scheme. Default is 12345.}

\item{...}{additional arguments to be passed to the low level function \code{principal_curve}.}
}
\value{
If \code{fb} is provided as input argument and \code{prc} equals \code{TRUE} then the output corresponds to the output of \code{prcurve}. Otherwise, only ouput is generated is \code{g} equals E. In this case a vector of fate bias entropies for all cells is given.
}
\description{
This function plots a dimensional reduction representation using the output of the \code{compdr} function as input. It allows display of the input clusters as well as color coding of fate bias probabilities and gene expression.
}
\examples{

x <- intestine$x
y <- intestine$y
# v contains all genes (no feature selection like in x)
v <- intestine$v
fcol <- intestine$fcol
tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)

# plot principal curves
pr <- plotFateMap(y,dr,k=2,prc=TRUE,m="cmd",col=fcol,fb=fb,trthr=0.25,start=NULL,tp=.5)

# plot expression of gene Apoa1__chr9
plotFateMap(y,dr,x=v,g="Apoa1__chr9",prc=FALSE,k=2,m="cmd",col=intestine$fcol)

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FateID_functions.R
\name{getsom}
\alias{getsom}
\title{Topological ordering of pseudo-temporal expression profiles}
\usage{
getsom(x, nb = 1000, alpha = 0.5)
}
\arguments{
\item{x}{expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. The pseudo-temporal expression profile of each gene is defined by the order of cell IDs, i. e. columns, in \code{x}.}

\item{nb}{positive integer number. Number of nodes of the self-organizing map. Default value is 1000.}

\item{alpha}{positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function \code{loess} from the package \pkg{stats}. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.}
}
\value{
A list of the following three components:
\item{som}{a \code{som} object returned by the function \code{som} of the package \pkg{som}}
\item{x}{pseudo-temporal expression profiles, i. e. the input expression data frame \code{x} after smoothing by running mean or local regression, respectivey, and normalization. The sum of smoothened gene expression values across all cells is normalized to 1.}
\item{zs}{data frame of z-score transformed pseudo-temporal expression profiles.}
}
\description{
This function computes a topological ordering of pseudo-temporal expression profiles of all genes by using 1-dimensional self-organizing maps.
}
\examples{

\donttest{
x <- intestine$x
y <- intestine$y
v <- intestine$v

tar <- c(6,9,13)
fb <- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr <- compdr(x,z=NULL,m="cmd",k=2,lle.n=30,tsne.perplexity=30)
pr <- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n <- pr$trc[["t6"]]
fs  <- filterset(v,n,minexpr=2,minnumber=1)
s1d <- getsom(fs,nb=1000,alpha=.5)
}

}
