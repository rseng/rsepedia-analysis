<!-- Copyright (c) 2014 John Biddiscombe                                          -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

Not Finished yet.


The network storage benchmark comes with several files

##################################################
# What the files are for
##################################################

------------------------------
network_storage.cpp
------------------------------
This is the code for the test.

------------------------------
network_storage.bat.in
------------------------------
This is a windows batch file template which will be filled in using cmake substitution
and then copied to your build/scripts directory.
The generated script can be invoked to run the benchmark in serial or parallel.
It spawns each task on the same node so although you may run 4 copies,
they are competing for resources.
The windows version is good for testing and debugging on a single node.
adding or removing /B for the launch command in the script
controls whether each task is launched in a new console window or not
example usage (2 tasks)
scripts/network_storage.bat 2

------------------------------
slurm-test-HPX-storage.sh.in
------------------------------
This is a bash script template which will be filled in using cmake substitution
and then copied to your build/scripts directory.
When executed, the script will loop over a number of parameter combinations
and for each create a directory with a name generated from the parameters, such as
  hpx-N0002-T02048-t04-ibverbs
and inside the dir there will be a "submit-job.bash" script which contains a single
slurm job submission. You can manually submit just one job using "sbatch submit-job.bash",
or in the root of the scripts folder there will be generated another script
which is called "run_jobs.bash". When this script is run, it will loop over
the jobs that were created by the first script and submit them all, you
can then sit back and wait until they complete.
Each job will write its results into "slurm.out" (and errors to slurm.err)
in the same subdirectory in which each individual job submission script was created.

The network_storage executable will produce several lines of output, but one line
contains the condensed information needed by the plotting script.
This line begins with the text "CSVData" to indicate comma separated data values.
Whilst jobs are running or when they have completed, you can execute a command
from the test root dir, such as
  find . -name slurm.out -exec grep CSV {} \;
and a list of results generated from the jobs will be produced.
For plotting of results, the output should be directed into a file using
  find . -name slurm.out -exec grep CSV {} \; >results-bgq-1a-2014-04-01.csv
Where you use a file name applicable to your current experiment.
The generated file will be suitable for use by the plotting script.

Important Note:
By default, the slurm jobs generated by the script have the 'exclusive' flag set.
This is because the jobs are intended to test BW of the network and it is
often desirable  to have only a single job running at a time.
The 'exclusive' flag only works (under slurm) if all jobs have the same name
so in your queue you will see many identical jobs and it will take a long time to drain.
If you can afford to run many job simultaneously, the job name may be set more
appropriately (details in script) and the exclusive flag removed.

------------------------------
plot-results.py
------------------------------
This is a python script which takes results generated by the test program
as described above and plots a number of graphs for different parameter studies.
The results.csv file generated contains BW measurements, timing ,thread, parcelport,
block size, etc information for the plots.
The python script parses the results and generates arrays (maps) of the data which
can be plotted in various ways. The scripts can be invoked as
  plot-results.py results.csv
optional arguments such as the figure size can be found by looking at the script.
The output from the script will be a series of svg and png files for each of the plots
created.

## Launch notes
greina14
bin/network_storage --localMB=1024 --transferKB=16384 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 --hpx:agas=148.187.83.44:7910 --hpx:hpx=148.187.83.44:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=1 -Ihpx.parcel.bootstrap=tcp

greina15
bin/network_storage --localMB=1024 --transferKB=16384 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1  --hpx:agas=148.187.83.44:7910 --hpx:worker --hpx:hpx=148.187.83.45:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=1 -Ihpx.parcel.bootstrap=tcp

greina1
gdb --args /home/biddisco/build/hvtkm/bin/network_storage --localMB=64 --transferKB=1024 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 --hpx:agas=192.168.3.31:7910 --hpx:hpx=192.168.3.31:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=1 -Ihpx.parcel.bootstrap=tcp --hpx:threads=1

greina2
gdb --args /home/biddisco/build/hvtkm/bin/network_storage --localMB=64 --transferKB=1024 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 --hpx:agas=192.168.3.31:7910 --hpx:hpx=192.168.3.32:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=1 -Ihpx.parcel.bootstrap=tcp --hpx:worker --hpx:threads=1

mpi launch
mpiexec -n 2 -host greina14,greina15 bin/network_storage --localMB=1024 --transferKB=16384 --iterations=10 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.tcp.enable=0 -Ihpx.parcel.mpi.enable=1 -Ihpx.parcel.verbs.enable=0 -Ihpx.parcel.bootstrap=mpi --hpx:threads=12

test TCP greina14
bin/network_storage --localMB=1024 --transferKB=16384 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 --hpx:agas=148.187.83.44:7910 --hpx:hpx=148.187.83.44:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=0 -Ihpx.parcel.bootstrap=tcp --iterations=10  --hpx:threads=12

test TCP greina15
bin/network_storage --localMB=1024 --transferKB=16384 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1  --hpx:agas=148.187.83.44:7910 --hpx:worker --hpx:hpx=148.187.83.45:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=0 -Ihpx.parcel.bootstrap=tcp --iterations=10  --hpx:threads=12
<!-- Copyright (c) 2017 Hartmut Kaiser                                            -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->
## Support for deploying and using HPX

Welcome to [HPX](http://stellar-group.org/libraries/hpx/)! We use GitHub for
[tracking bugs and feature requests](https://github.com/STEllAR-GROUP/hpx/issues).
Please see for the resources below if you are looking for the right place to
get support for using HPX.

### Documentation

* [User Documentation](https://hpx-docs.stellar-group.org/latest/html/index.html)


### Real-time Chat

* #ste||ar on [Libera.Chat](https://libera.chat/): this is the best option
  to get in contact with us as most of the developers are available on this
  channel. Check out the [channel archives](http://irclog.cct.lsu.edu/ste~b~~b~ar)
  for past conversations. The channel can also be accessed through
  [Matrix](https://matrix.to/#/#ste||ar:libera.chat).
* Slack ([registration](https://cpplang.now.sh/)): The
  [`#hpx`](https://cpplang.slack.com/messages/C68QLPZB3) channel is another
  place where people usually offer support.


### Mailing Lists/Groups

* [hpx-users group](mailto:hpx-users@stellar-group.org), see
  [here](https://www.mail-archive.com/hpx-users@stellar-group.org) for past
  conversations. This is the main mailing list for user questions and HPX
  announcements.
* [hpx-devel group](mailto:hpx-devel@stellar-group.org), see
  [here](https://www.mail-archive.com/hpx-devel@stellar-group.org) for past
  conversations. This is the main mailing list for development discussion
  and voting.
* [hpx-pmc group](mailto:hpx-pmc@stellar-group.org). The project management
  committee (PMC) can be reached at this address.

### Latest News

* For latest news and announcements please see our
  [blog](http://hpx.stellar-group.org/blog/).

### Stack Overflow

The HPX Community is active on Stack Overflow, you can post your questions there:

* [HPX on Stack Overflow](http://stackoverflow.com/questions/tagged/hpx)

  * Here are some tips for
    [about how to ask good questions](http://stackoverflow.com/help/how-to-ask).
  * Don't forget to check to see
    [what's on topic](http://stackoverflow.com/help/on-topic).
## Expected Behavior

... Please describe the behavior you would have expected.

## Actual Behavior

... Please describe the behavior you actually observed.


## Steps to Reproduce the Problem

... Please be as specific as possible while describing how to reproduce your problem.

  1.
  1.
  1.

## Specifications

... Please describe your environment

  - HPX Version:
  - Platform (compiler, OS):

<!-- Copyright (c) 2017 Hartmut Kaiser                                            -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

# HPX Code of Conduct

Like the technical community as a whole, the HPX team and community is made up
of a mixture of professionals and volunteers from all over the world, working
on every aspect of the mission - including mentorship, teaching, and connecting
people.

Diversity is one of our huge strengths, but it can also lead to communication
issues and unhappiness. To that end, we have a few ground rules that we ask
people to adhere to. This code applies equally to founders, mentors and those
seeking help and guidance.

This isn't an exhaustive list of things that you can't do. Rather, take it in
the spirit in which it's intended - a guide to make it easier to enrich all of
us and the technical communities in which we participate.

This code of conduct applies to all spaces managed by the
[HPX](https://github.com/STEllAR-GROUP/hpx) project or
[STE||AR Group](http://stellar-group.org). This includes IRC, the mailing
lists, the issue tracker, and any other forums created by the project team
which the community uses for communication. In addition, violations of this
code outside these spaces may affect a person's ability to participate within
them.

If you believe someone is violating the code of conduct, we ask that you report
it by emailing conduct@stellar-group.org.

* **Be friendly and patient**.
* **Be welcoming.** We strive to be a community that welcomes and supports
  people of all backgrounds and identities. This includes, but is not limited
  to members of any race, ethnicity, culture, national origin, colour,
  immigration status, social and economic class, educational level, sex, sexual
  orientation, gender identity and expression, age, size, family status,
  political belief, religion, and mental and physical ability.
* **Be considerate.** Your work will be used by other people, and you in turn
  will depend on the work of others. Any decision you take will affect users
  and colleagues, and you should take those consequences into account when
  making decisions. Remember that we're a world-wide community, so you might
  not be communicating in someone else's primary language.
* **Be respectful.** Not all of us will agree all the time, but disagreement
  is no excuse for poor behavior and poor manners. We might all experience some
  frustration now and then, but we cannot allow that frustration to turn into a
  personal attack. It's important to remember that a community where people
  feel uncomfortable or threatened is not a productive one. Members of the HPX
  community should be respectful when dealing with other members as well as
  with people outside the HPX community.
* **Be careful in the words that you choose.** We are a community of
  professionals, and we conduct ourselves professionally. Be kind to others.
  Do not insult or put down other participants. Harassment and other
  exclusionary behavior aren't acceptable. This includes, but is not limited
  to:
  * Violent threats or language directed against another person.
  * Discriminatory jokes and language.
  * Posting sexually explicit or violent material.
  * Posting (or threatening to post) other people's personally identifying
    information ("doxing").
  * Personal insults, especially those using racist or sexist terms.
  * Unwelcome sexual attention.
  * Advocating for, or encouraging, any of the above behavior.
  * Repeated harassment of others. In general, if someone asks you to stop,
    then stop.

* **When we disagree, try to understand why.** Disagreements, both social and
  technical, happen all the time and HPX is no exception. It is important
  that we resolve disagreements and differing views constructively. Remember
  that we're different. The strength of HPX comes from its varied community,
  people from a wide range of backgrounds. Different people have different
  perspectives on issues. Being unable to understand why someone holds a
  viewpoint doesn't mean that they're wrong. Don't forget that it is human to
  err and blaming each other doesn't get us anywhere. Instead, focus on
  helping to resolve issues and learning from mistakes.

Original text courtesy of the [Django](https://www.djangoproject.com/conduct/) project.
<!-- Copyright (c) 2014-2020 Hartmut Kaiser                                       -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

This describes how you can contribute to [HPX](https://github.com/STEllAR-GROUP/hpx).
Great to have you here. There are a few ways you can help make HPX better!

# How to Get Involved in Developing HPX

This page describes how you can get yourself involved with the development of
HPX. Here are some easy things to do.

All of the HPX development and the related discussions happen through the
[Github ticket system](https://github.com/STEllAR-GROUP/hpx/issues). We are
looking forward to contributions submitted through the usual Github process,
i.e. pull requests.

The easiest ways to get in contact with us are listed here:

* Mailing list: [hpx-users@stellar.cct.lsu.edu](email:hpx-users@stellar.cct.lsu.edu), [hpx-devel@stellar.cct.lsu.edu](email:hpx-devel@stellar.cct.lsu.edu)
* IRC channel:  #ste||ar on irc.freenode.net
* Blog:         [stellar.cct.lsu.edu](stellar.cct.lsu.edu)

The basic approach is to find something fun you want to fix, hack it up, and
send a `git diff` as a mail attachment to [hpx-devel@stellar.cct.lsu.edu](email:hpx-devel@stellar.cct.lsu.edu)
with a Subject prefixed with 'PATCH', as well as: "made available under the Boost
Software License V1" license statement. We also need a real name for the git
commit logs if you usually use an alias. Alternatively, you can create a pull
request from your HPX repository you cloned on Github (see below).

It should be easy!

If you create new files, please use our License Header:

    //  Copyright (c) <year> <your name>
    //
    //  Distributed under the Boost Software License, Version 1.0. (See accompanying
    //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Please avoid larger reformatting of the code for the time being (except for the
tasks listed below).

If the task is really quick and easy, 'just do it'. However, if you think it
will take you some time, and/or need partitioning (eg. some big, scalable
cleanup that many people can help out with), then please:

* add a comment to the ticket that you're starting work on it
* please provide updates each week or so, otherwise someone else may take the issue
* please take only one part of the task at a time.

If a task has an owner without an update in a week, feel free to notify them
that you're taking that on yourself, and of course if you realize you can't
complete a task - please update it in the
[ticket system](https://github.com/STEllAR-GROUP/hpx/issues).

Even if you are deeply skilled, please consider doing one little easy hack, to
get used to the process. After that, you are invited to move on up to the more
difficult tasks, leaving some of the easy tasks to others so they can get
involved and achieve change themselves. The quicker you move up the pile, the
more quickly you can be making large scale, user-visible changes and
improvements to HPX - of which these easy hacks are just the tip of a very
interesting iceberg.

Before we get to the list of possible tasks, here is some additional
information to get you started.

## Getting Started

### Get a login on Github [here](https://github.com/) and fork the HPX repository to your Github account.

All new and old bugs in HPX can be found in our
[ticket system](https://github.com/STEllAR-GROUP/hpx/issues). Especially with
new incoming bugs, it is helpful to test the bug on your own computer/operating
system and comment in the bug entry whether you can or cannot confirm the bug
and under what circumstances it affects you.

### Getting a build - if necessary

Some but not all tasks require you to have built HPX. Even if that is not
required, your feedback can be helpful to us - so - please try. The master
build instructions are [here](https://stellar-group.github.io/hpx/docs/sphinx/branches/master/html/quickstart.html)
with more stuff under development.

### Hacking help

If you need to search constructs in the code, there is a code search engine at
at the top of this page.

## General info

We use the [Boost coding standards](http://www.boost.org/development/requirements.html#Guidelines)
for our work on HPX

The short version of the guidelines:

* 80-character lines.
* Absolutely no tabs (use spaces instead of tabs).
* Because we use git, UNIX line endings.
* Identifiers are C++ STL style: no CamelCase. E.g. `my_class` instead of `MyClass`.
* Use expressive identifiers.
* Exceptions for error handling instead of C-style error codes.

A more elaborate description of our coding guidelines can be found
[here](https://github.com/STEllAR-GROUP/hpx/wiki/HPX-Source-Code-Structure-and-Coding-Standards).

There is a `.editorconfig` file in the HPX root directory which can be used
for almost any widely available editor. Please see
[their webpage](http://editorconfig.org) to download plugins for your favorite
editor.

There is a `.clang-format` file in the HPX root directory which you can use to
manually format the code you contribute. This configuration file can be used
with [clang-format](https://clang.llvm.org/docs/ClangFormat.html), a tool created
by the [Clang](https://clang.llvm.org/) project.

Please follow the following guidelines for using it:

* You should use this file for creating an initial formatting for new files.
* Please separate edits which are pure formatting into isolated commits
  keeping those distinct from edits changing any of the code.
* Please do _not_ configure your editor to automatically format the source
  file while saving edits to disk.
* Please do _not_ reformat a full source file without dire need.

A few additional ones:

* Use doxygen style comments to document API functions.
* Before writing a piece of utility code, see if there is something in
  `hpx::util`, Boost or the C++ standard library that can be used to save time.

# Community

Community is an important part of all we do.

* The HPX project is a meritocratic, consensus-based community project. Anyone
  with an interest in the project can join the community, contribute to the
  project design and participate in the decision making process.
  `This document <http://hpx.stellar-group.org/documents/governance/>`_ describes
  how that participation takes place and how to set about earning merit within
  the project community.
* You can help us answer questions our users have by being around on IRC
  (#ste||ar on irc.freenode.net) or by chiming in on the
  [users mailing list](email:hpx-users@stellar.cct.lsu.edu)
* You can help write blog posts (for [stellar.cct.lsu.edu](stellar.cct.lsu.edu))
  about things you're doing with HPX. We can give you access or help with
  posting things.
* Create an example of how to use HPX in the real world by building something
  or showing what others have built.
* Write about other people's work based on HPX. Show how it is used in daily
  life. Take screenshots and make videos!


# Your first bugfix

For our project, you can talk to the following people to receive help in
working through your first bugfix and thinking through the problem:

* @hkaiser, @heller, @wash, @jbjnr

Fixes #

## Proposed Changes

  -
  -
  -

## Any background context you want to provide?

## Checklist

Not all points below apply to all pull requests.

- [ ] I have added a new feature and have added tests to go along with it.
- [ ] I have fixed a bug and have added a regression test.
- [ ] I have added a test using random numbers; I have made sure it uses a seed, and that random numbers generated are valid inputs for the tests.
<!-- Copyright (c) 2018 Thomas Heller                                             -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

This example demonstrates a pipeline split up in 3 processes:
 - emitter.cpp:
    * Process producing input for worker. This serves as the master process
 - worker.cpp:
    * Process working on inputs. There can be multiple instances of this process
 - collector.cpp:
    * Process collecting the result of the workers

When using the MPI parcelport, the example can be run like this:

```
mpirun -np 1 ./bin/emitter : -np 1 ./bin/collector : -np N-1 ./bin/worker
```

For elasticity, the applicate can be started as following:

```
host0$ ./bin/emitter --hpx:hpx=<host0> --hpx:console
host1$ ./bin/collector --hpx:hpx=<host1> --hpx:agas=<host0> --hpx:connect --hpx:run-hpx-main
host2$ ./bin/worker --hpx:hpx=<host2> --hpx:agas=<host0> --hpx:connect --hpx:run-hpx-main
host3$ ./bin/worker --hpx:hpx=<host3> --hpx:agas=<host0> --hpx:connect --hpx:run-hpx-main
...
hostN$ ./bin/worker --hpx:hpx=<hostN> --hpx:agas=<host0> --hpx:connect --hpx:run-hpx-main
```
<!-- Copyright (c) 2013 Thomas Heller                                             -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

This is a version of a Jacobi supposed to run on shared memory machines.
It based on the dataflow ideas as presented in this paper:
http://dl.acm.org/citation.cfm?id=2467126

The example consists of 2 parts, each of the part provides a jacobi smoother
implemented in HPX and OpenMP, while the OpenMP variant includes one with
static and one with dynamic scheduling policies.

The first variant smoothes a regular two-dimensional grid with a simple
5 point stencil. The parameters are the number of grid points in one dimension
and for the HPX version, a block-size parameter which determines the
granularity of the work done. The relevant executables are:
  * jacobi_hpx
  * jacobi_omp_static
  * jacobi_omp_dynamic

The second variant performs a dynamic stencil based on the neighborhood
given by a sparse matrix. The matrix input format is "Matrix Market".
An example matrix can be obtained here:
http://www.cise.ufl.edu/research/sparse/matrices/Janna/Serena.html
Other matrices from that portal work as well.
The relevant executables are:
  * jacobi_nonuniform_hpx
  * jacobi_nonuniform_omp_static
  * jacobi_nonuniform_omp_dynamic

<!-- Copyright (c) 2014 Thomas Heller                                             -->
<!--                                                                              -->
<!-- SPDX-License-Identifier: BSL-1.0                                             -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)        -->

This directory contains python script to help debugging HPX applications with
gdb. In order to use it, please add the following lines to your ~/.gdbinit:

    source $HPX_SRC_DIR/tools/gdb/hpx.py

    define hook-continue
    hpx thread restore
    end

For a list of commands see `help hpx` inside of gdb.

Notes:

 - The scripts currently only work when HPX is compiled against Boost 1.56
 - The scripts currently only work with the local priority scheduler
 - The scripts currently only work on 64 bit executables
 - The scripts currently only work with the `x86_linux_context` context
   implementation (which is the default on Linux X86_64)
 - The hook-continue is needed because we currently just overwrite the current
   frame with the selected HPX user level context.

By not doing a `hpx thread restore` before gdb continues execution, your
program will abort.
﻿---
title: 'HPX - The C++ Standard Library for Parallelism and Concurrency'
tags:
 - concurrency
 - task-based run time system
 - parallelism
 - distributed
authors:
 - name: Hartmut Kaiser
   orcid: 0000-0002-8712-2806
   affiliation: "1"
 - name: Patrick Diehl
   orcid: 0000-0003-3922-8419
   affiliation: "1"
 - name: Adrian S. Lemoine
   affiliation: "6"
 - name: Bryce Adelstein Lelbach
   orcid: 0000-0002-7995-5226
   affiliation: "5"
 - name: Parsa Amini
   orcid: 0000-0002-6439-8404
   affiliation: "1"
 - name: Agustín Berge
   affiliation: "6"
 - name: John Biddiscombe
   orcid: 0000-0002-6552-2833
   affiliation: "4"
 - name: Steven R. Brandt
   orcid: 0000-0002-7979-2906
   affiliation: "1"
 - name: Nikunj Gupta
   orcid: 0000-0003-0525-3667
   affiliation: "3"
 - name: Thomas Heller
   orcid: 0000-0003-2620-9438
   affiliation: "2"
 - name: Kevin Huck
   orcid: 0000-0001-7064-8417
   affiliation: "8"
 - name: Zahra Khatami
   orcid: 0000-0001-6654-6856
   affiliation: "7"
 - name: Alireza Kheirkhahan
   orcid: 0000-0002-4624-4647
   affiliation: "1"
 - name: Auriane Reverdell
   orcid: 0000-0002-5531-0458
   affiliation: "4"
 - name: Shahrzad Shirzad
   orcid: 0000-0001-9496-8044
   affiliation: "1"
 - name: Mikael Simberg
   orcid: 0000-0002-7238-8935
   affiliation: "4"
 - name: Bibek Wagle
   orcid: 0000-0001-6619-7115
   affiliation: "1"
 - name: Weile Wei
   orcid: 0000-0002-3065-4959
   affiliation: "1"
 - name: Tianyi Zhang
   orcid: 0000-0002-1000-4887
   affiliation: "6"
affiliations:
 - name: Center for Computation \& Technology, Louisiana State University, LA, Baton Rouge, United States of America
   index: 1
 - name: Exasol, Erlangen, Germany
   index: 2
 - name: Indian Institute of Technology, Roorkee, India
   index: 3
 - name: Swiss National Supercomputing Centre, Lugano, Switzerland
   index: 4
 - name: NVIDIA, CA, Santa Clara, United States of America
   index: 5
 - name: STE$||$AR Group
   index: 6
 - name: Oracle, CA, Redwood City, United States of America
   index: 7
 - name: Oregon Advanced Computing Institute for Science and Society (OACISS), University of Oregon, OR, Eugene, United States of America
   index: 8
date: 26.08.2020
bibliography: paper.bib
---

# Summary

The new challenges presented by exascale system architectures have resulted in
difficulty achieving the desired scalability using traditional distributed-memory
runtimes. Asynchronous many-task systems (AMT) are based on a new paradigm
showing promise in addressing these challenges, providing application
developers with a productive and performant approach to programming on next
generation systems.

HPX is a C++ Library for concurrency and parallelism that is
developed by The STE||AR Group, an international group of collaborators working
in the field of distributed and parallel programming
[@heller2017hpx;@hpx_github;@tabbal2011preliminary]. It is a runtime system
written using modern C++ techniques that are linked as part of an application.
HPX exposes extended services and functionalities supporting the implementation
of parallel, concurrent, and distributed capabilities for applications in any
domain; it has been used in scientific computing, gaming, finances, data
mining, and other fields.

The HPX AMT runtime system attempts to solve some problems the community
is facing when it comes to creating scalable parallel applications that expose
excellent parallel efficiency and a high resource utilization. First, it exposes
a C++ standards conforming API that unifies syntax and semantics for local and
remote operations. This significantly simplifies writing codes that strive to
effectively utilize different types of available parallelism in today's machines
in a coordinated way (i.e., on-node, off-node, and accelerator-based parallelism).
Second, HPX implements an asynchronous C++ standard programming model that has the
emergent property of semi-automatic parallelization of the user's code. The
provided API (especially when used in conjunction with the new C++20 `co_await`
keyword [@standard2020programming]) enables intrinsic overlap of computation and
communication, prefers moving work to data over moving data to work, and exposes
minimal overheads from its lightweight threading subsystem, ensuring efficient
fine-grained parallelization and minimal-overhead synchronization and context
switching. This programming model natively ensures high-system utilization and
perfect scalability.

A detailed comparison of HPX with various other AMTs is given in [@thoman2018taxonomy].
Some notable AMT solutions are: Uintah [@germain2000uintah], Chapel [@chamberlain2007parallel],
Charm++ [@kale1993charm], Kokkos [@edwards2014kokkos], Legion [@bauer2012legion],
and PaRSEC [@bosilca2013parsec]. Note that we only refer to distributed memory solutions,
since this is an important feature for scientific applications to run large scale simulations.
The major showpiece of HPX compared to the mentioned distributed AMTs is its future-proof C++
standards conforming API and the exposed asynchronous programming model.

HPX's main goal is to
improve efficiency and scalability of parallel applications by increasing
resource utilization and reducing synchronization overheads through providing an
asynchronous API and employing adaptive scheduling. The consequent use of
_Futures_ intrinsically enables overlap of computation and communication and
constraint-based synchronization. HPX is able to maintain a balanced load among
all the available resources resulting in significantly reducing processor
starvation and effective latencies while controlling overheads. HPX fully
conforms to the C++ ISO standards and implements the standardized concurrency
mechanisms and parallelism facilities. Further, HPX extends those facilities to
distributed use cases, thus enabling syntactic and semantic equivalence of local
and remote operations on the API level. HPX uses the concept of C++ _Futures_ to
transform sequential algorithms into wait-free asynchronous executions.
The use of _Futurization_ enables the automatic creation of dynamic data flow
execution trees of potentially millions of lightweight HPX tasks executed in the
proper order. HPX also provides a work-stealing task scheduler that takes care
of fine-grained parallelizations and automatic load balancing. Furthermore,
HPX implements functionalities proposed as part of the ongoing C++
standardization process.

![Sketch of HPX's architecture with all the components and their interactions.\label{fig:architecture}](hpx_architecture.pdf)


\autoref{fig:architecture} sketches HPX's architecture. The components of HPX
and their references are listed below:

**Threading Subsystem** [@kaiser2009parallex] The thread manager manages the
 light-weight user level threads created by HPX. These light-weight threads
 have extremely short context switching times, resulting in reduced latencies
 even for very short operations. This also ensures reduced synchronization
 overheads for coordinating execution between different threads. HPX provides
 a set of scheduling policies that enable the user to flexibly customize the
 execution of HPX threads. Work-stealing and work-sharing policies ensure
 automatic local load balancing of tasks, which is important for achieving high
 system utilization and good scalability of the user's code.

**Active Global Address Space (AGAS)** [@kaiser2014hpx;@amini2019agas]
 To support distributed objects, HPX supports a component for resolving
 global addresses that extends the Partitioned Global Address Space
 (PGAS) model, enabling dynamic runtime-based resource allocation and
 data placement.
 This layer enables HPX to expose a uniform API for local and remote
 execution. Unlike PGAS, AGAS provides the user with the ability to
 transparently move global objects in between nodes of a distributed computer
 system without changing the object's global address. This capability is
 fundamental for supporting load balancing via object migration.

**Parcel Transport Layer** [@kaiser2009parallex;@biddiscombe2017zero]
 This component is an active-message networking layer.
 The parcelport leverages AGAS in order to deliver messages to and to launch
 functions on global objects regardless of their current placement in a
 distributed system.
 Additionally, its asynchronous protocol enables the
 parcelport to implicitly overlap communication and computation.
 The parcelport is modular to support multiple communication library
 backends. By default, HPX supports TCP/IP, Message Passing Interface (MPI),
 and libfabric [@daiss2019piz].

**Performance counters** [@grubel2016dynamic]
 HPX provides its users with a uniform suite of globally accessible
 performance counters to monitor system metrics *in-situ*. These counters have
 their names registered with AGAS, which enables the users to
 easily query for different metrics at runtime.
 Additionally, HPX provides an API for users to create their
 own application-specific counters to gather information customized to their
 own application. These user-defined counters are exposed through the same
 interface as their predefined counterparts.
 By default, HPX provides performance counters for its own components, such as
 networking, AGAS operations, thread scheduling, and various statistics.

**Policy Engine/Policies** [@huck2015autonomic;@khatami2017hpx;@laberge2019scheduling]
 Often, modern applications must adapt to runtime environments
 to ensure acceptable performance. Autonomic Performance Environment for
 Exascale (APEX) enables this flexibility by measuring HPX tasks, monitoring
 system utilization, and accepting user provided policies
 that are triggered by defined events.
 In this way, features such as parcel coalescing [@wagle2018methodology] can
 adapt to the current phase of an application or even state of a system.

**Accelerator Support**
 HPX has support for several methods of integration with GPUs:
 HPXCL [@diehl2018integration; @martin_stumpf_2018_1409043] and HPX.Compute
 [@copik2017using].
 HPXCL provides users the ability to manage GPU kernels through a
 global object. This enables HPX to coordinate the launching and
 synchronization of CPU and GPU code.
 HPX.Compute [@copik2017using] aims to provide a single-source
 solution to heterogeneity by automatically generating GPU kernels
 from C++ code. This enables HPX to launch both CPU and GPU kernels
 as dictated by the current state of the system. Support for integrating
 HPX with Kokkos [@edwards2014kokkos] is currently being developed. This
 integration already has added HPX as an asynchronous backend to Kokkos and
 will expose Kokkos' accelerator functionalities through HPX's asynchronous APIs
 in a C++ standards-conforming way.

**Local Control Objects (synchronization support facilities)**
 HPX has support for many of the C++20 primitives, such as `hpx::latch`,
 `hpx::barrier`, and `hpx::counting_semaphore` to synchronize the execution of
 different threads allowing overlapping computation and communication. These
 facilities fully conform to the C++20 standard [@standard2020programming].
 For asynchronous computing HPX provides `hpx::async` and `hpx::future`; see
 the second example in the next section.

**Software Resilience**
 HPX supports software-level resilience [@gupta2020implementing] through its
 resiliency API, such as `hpx::async_replay` and `hpx::async_replicate` and
 its dataflow counterparts `hpx::dataflow_replay` and
 `hpx::dataflow_replicate`. These APIs are resilient against memory bit
 flips and other hardware errors.
 HPX provides an easy method to port codes to the resilient API by replacing
 `hpx::async` or `hpx::dataflow` with its resilient API counterparts everywhere
 in the code without making any other changes.

**C++ Standards conforming API**
 HPX implements all the C++17 parallel algorithms [@standard2017programming]
 and extends those with asynchronous versions. Here, HPX provides the
 `hpx::execution::seq` and `hpx::execution::par` execution policies, and (as an
 extension) their asynchronous equivalents
 `hpx::execution::seq(hpx::execution::task)` and
 `hpx::execution::par(hpx::execution::task)` (see the first code example
 below). HPX also implements the C++20
 concurrency facilities and APIs [@standard2020programming], such as
 `hpx::jthread`, `hpx::latch`, `hpx::barrier`, etc.

# Applications

HPX is utilized in a diverse set of applications: 

- Scientific computing
   * [Octo-Tiger](https://github.com/STEllAR-GROUP/octotiger)
   [@daiss2019piz;@heller2019harnessing;@pfander2018accelerating], an
   astrophysics code for stellar mergers.
   * [libGeoDecomp](https://github.com/gentryx/libgeodecomp)
   [@Schafer:2008:LGL:1431669.1431721], an auto-parallelizing library to speed
   up stencil-code-based computer simulations.
   * [NLMech](https://github.com/nonlocalmodels) [@diehl2018implementation], a
   simulation tool for non-local models, e.g. Peridynamics.
   * [Dynamical Cluster Approximation](https://github.com/CompFUSE/DCA) (DCA++)
   [@hahner2020dca], a high-performance research software framework to solve 
   quantum many-body problems with cutting edge quantum cluster algorithms. 

- Libraries
   * [hpxMP](https://github.com/STEllAR-GROUP/hpxMP)
   [@zhang2019introduction; @zhang2020supporting] a modern OpenMP implementation
   leveraging HPX that supports shared memory multithread programming. 
   * [Kokkos](https://github.com/kokkos/kokkos) [@10.1016/j.jpdc.2014.07.003],
   the C++ Performance Portability Programming EcoSystem. 
   * [Phylanx](https://github.com/STEllAR-GROUP/phylanx)
   [@tohid2018asynchronous;@wagle2019runtime] An Asynchronous Distributed C++
   Array Processing Toolkit.

For a updated list of applications, we refer to the
corresponding [HPX website](https://hpx.stellar-group.org/hpx-users/).

# Example code

The following is an example of HPX's parallel algorithms API using execution
policies as defined in
the C++17 standard [@standard2017programming]. HPX implements all the
parallel algorithms defined therein. The parallel algorithms extend the classic
STL algorithms by adding a first argument (called execution policy).
The `hpx::execution::seq` implies sequential execution while `hpx::execution::par`
will execute the algorithm in parallel.
HPX's parallel algorithm library API is completely standards conforming.

```cpp
#include <hpx/hpx.hpp>
#include <iostream>
#include <vector>

int main()
{
 std::vector<int> values = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

 // Compute the sum in a sequential fashion
 int sum1 = hpx::reduce(
 hpx::execution::seq, values.begin(), values.end(), 0);
 std::cout << sum1 << '\n'; // will print 55

 // Compute the sum in a parallel fashion based on a range of values
 int sum2 = hpx::ranges::reduce(hpx::execution::par, values, 0);
 std::cout << sum2 << '\n'; // will print 55 as well

 return 0;
}
```

Example for the HPX's concurrency API where the Taylor series for the $\sin(x)$
function is computed. The Taylor series is given by,

$$ \sin(x) \approx = \sum\limits_{n=0}^N (-1)^{n-1} \frac{x^{2n}}{(2n)!}.$$

For the concurrent computation, the interval $[0, N]$ is split in two
partitions from $[0, N/2]$ and $[(N/2)+1, N]$, and these are computed
asynchronously using `hpx::async`. Note that each asynchronous function call
returns an `hpx::future` which is needed to synchronize the collection
of the partial results. The future has a `get()` method that returns the result
once the computation of the Taylor function finished. If the result is not ready
yet, the current thread is suspended until the result is ready. Only if
`f1` and `f2` are ready, the overall result will be printed to the standard
output stream.

```cpp
#include <hpx/hpx.hpp>
#include <cmath>
#include <iostream>

// Define the partial taylor function
double taylor(size_t begin, size_t end, size_t n, double x)
{
 double denom = factorial(2 * n);
 double res = 0;
 for (size_t i = begin; i != end; ++i)
 {
 res += std::pow(-1, i - 1) * std::pow(x, 2 * n) / denom;
 }
 return res;
}

int main()
{
 // Compute the Talor series sin(2.0) for 100 iterations
 size_t n = 100;

 // Launch two concurrent computations of each partial result
 hpx::future<double> f1 = hpx::async(taylor, 0, n / 2, n, 2.);
 hpx::future<double> f2 = hpx::async(taylor, (n / 2) + 1, n, n, 2.);

 // Introduce a barrier to gather the results
 double res = f1.get() + f2.get();

 // Print the result
 std::cout << "Sin(2.) = " << res << std::endl;
}
```

Please report any bugs or feature requests on the
[HPX GitHub page](https://github.com/STEllAR-GROUP/hpx).

# Acknowledgments

We would like to acknowledge the National Science Foundation (NSF), the U.S.
Department of Energy (DoE), the Defense Technical Information Center (DTIC), the
Defense Advanced Research Projects Agency (DARPA), the Center for Computation
and Technology (CCT) at Louisiana State University (LSU), the Swiss National
Supercomputing Centre (CSCS), the Department of Computer Science 3 - Computer
Architecture at the University of Erlangen Nuremberg who fund and support our
work, and the Heterogeneous System Architecture (HSA) Foundation.

We would also like to thank the following organizations for granting us
allocations of their compute resources: LSU HPC, Louisiana Optical Network
Iniative (LONI), the Extreme Science and Engineering Discovery Environment
(XSEDE), the National Energy Research Scientific Computing Center (NERSC), the
Oak Ridge Leadership Computing Facility (OLCF), Swiss National Supercomputing
Centre (CSCS/ETHZ), the Juelich Supercomputing Centre (JSC), and the Gauss
Center for Supercomputing.

At the time the paper was written, HPX was directly funded by the following
grants:

- The National Science Foundation through awards 1339782 (STORM) and 1737785
 (Phylanx).

- The Department of Energy (DoE) through the awards DE-AC52-06NA25396 (FLeCSI)
 DE-NA0003525 (Resilience), and DE-AC05-00OR22725 (DCA++).

- The Defense Technical Information Center (DTIC) under contract
 FA8075-14-D-0002/0007.

- The Bavarian Research Foundation (Bayerische Forschungsstiftung) through the
 grant AZ-987-11.

- The European Commission's Horizon 2020 programme through the grant
 H2020-EU.1.2.2. 671603 (AllScale).


For a updated list of previous and current funding, we refer to the
corresponding [HPX website](http://hpx.stellar-group.org/funding-acknowledgements/).

# References
..
    Copyright (c) 2007-2020 Louisiana State University

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

|circleci_status| |codacy| |coveralls| |CFF| |JOSS| |zenodo_doi|

Documentation: `latest
<https://hpx-docs.stellar-group.org/latest/html/index.html>`_,
`development (master)
<https://hpx-docs.stellar-group.org/branches/master/html/index.html>`_

===
HPX
===

HPX is a C++ Standard Library for Concurrency and Parallelism. It implements all
of the corresponding facilities as defined by the C++ Standard. Additionally, in
HPX we implement functionalities proposed as part of the ongoing C++
standardization process. We also extend the C++ Standard APIs to the distributed
case.

The goal of HPX is to create a high quality, freely available, open source
implementation of a new programming model for conventional systems, such as
classic Linux based Beowulf clusters or multi-socket highly parallel SMP nodes.
At the same time, we want to have a very modular and well designed runtime
system architecture which would allow us to port our implementation onto new
computer system architectures. We want to use real-world applications to drive
the development of the runtime system, coining out required functionalities and
converging onto a stable API which will provide a smooth migration path for
developers.

The API exposed by HPX is not only modeled after the interfaces defined by the
C++11/14/17/20 ISO standard, it also adheres to the programming guidelines used
by the Boost collection of C++ libraries. We aim to improve the scalability of
today's applications and to expose new levels of parallelism which are necessary
to take advantage of the exascale systems of the future.

What's so special about HPX?
============================

* HPX exposes a uniform, standards-oriented API for ease of programming parallel
  and distributed applications.
* It enables programmers to write fully asynchronous code using hundreds of
  millions of threads.
* HPX provides unified syntax and semantics for local and remote operations.
* HPX makes concurrency manageable with dataflow and future based
  synchronization.
* It implements a rich set of runtime services supporting a broad range of use
  cases.
* HPX exposes a uniform, flexible, and extendable performance counter framework
  which can enable runtime adaptivity
* It is designed to solve problems conventionally considered to be
  scaling-impaired.
* HPX has been designed and developed for systems of any scale, from hand-held
  devices to very large scale systems.
* It is the first fully functional implementation of the ParalleX execution
  model.
* HPX is published under a liberal open-source license and has an open, active,
  and thriving developer community.

Governance
==========

The HPX project is a meritocratic, consensus-based community project. Anyone
with an interest in the project can join the community, contribute to the
project design and participate in the decision making process.
`This document <http://hpx.stellar-group.org/documents/governance/>`_ describes
how that participation takes place and how to set about earning merit within
the project community.

Documentation
=============

If you plan to use HPX we suggest to start with the latest released version
which can be downloaded `here <https://stellar.cct.lsu.edu/downloads/>`_.

To quickly get started with HPX on most Linux distributions you can read the
quick start guide `here
<https://hpx-docs.stellar-group.org/latest/html/quickstart.html>`_.
Detailed instructions on building and installing HPX on various platforms can be
found `here
<https://hpx-docs.stellar-group.org/latest/html/manual/building_hpx.html>`_.
The full documentation for the latest release of HPX can always be found `here
<https://hpx-docs.stellar-group.org/latest/html/index.html>`_.

If you would like to work with the cutting edge version of this repository
(``master`` branch) the documentation can be found `here
<https://hpx-docs.stellar-group.org/branches/master/html/index.html>`_.
We strongly recommend that you follow the current health status of the master
branch by looking at our `continuous integration results website
<https://cdash.cscs.ch//index.php?project=HPX>`_. While we try to keep the
master branch stable and usable, sometimes new bugs trick their way into the
code base. The `CircleCI <https://circleci.com/gh/STEllAR-GROUP/hpx>`_
continuous integration service additionally tracks the current build status for
the master branch: |circleci_status|.

We use `Codacy <https://www.codacy.com/>`_ to assess the code quality of this
project: |codacy|. For our coverage analysis we rely on
`Coveralls <https://coveralls.io/>`_ to present the results: |coveralls|.

If you can't find what you are looking for in the documentation or you suspect
you've found a bug in HPX we very much encourage and appreciate any issue
reports through the `issue tracker for this Github project
<https://github.com/STEllAR-GROUP/hpx/issues>`_.

If you have any questions feel free to ask it over at `StackOverflow
<https://stackoverflow.com>`_ and tag the question with `hpx
<https://stackoverflow.com/questions/tagged/hpx>`_.

For a full list of support options please see our `Support page
<https://github.com/STEllAR-GROUP/hpx/blob/master/.github/SUPPORT.md>`_.

Code of conduct
===============

We have adopted a `code of conduct
<https://github.com/STEllAR-GROUP/hpx/blob/master/.github/CODE_OF_CONDUCT.md>`_
for this project. Please refer to this document if you would like to know more
about the expectations for members of our community, with regard to how they
will behave toward each other.

Please find the project's gpg key, which is used to sign HPX releases
`here
<https://pgp.mit.edu/pks/lookup?op=get&search=0xE18AE35E86BB194F>`_.

Citing
======

In publications, please use our paper in The Journal of Open Source
Software as the main citation for HPX: |JOSS|. For referring
to the latest release of HPX please use: |zenodo_doi|.

Acknowledgements
================

Past and current funding and support for HPX is listed `here
<https://hpx.stellar-group.org/funding-acknowledgements>`_

.. |circleci_status| image:: https://circleci.com/gh/STEllAR-GROUP/hpx/tree/master.svg?style=svg
     :target: https://circleci.com/gh/STEllAR-GROUP/hpx/tree/master
     :alt: HPX master branch build status

.. |zenodo_doi| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.598202.svg
     :target: https://doi.org/10.5281/zenodo.598202
     :alt: Latest software release of HPX

.. |codacy| image:: https://api.codacy.com/project/badge/Grade/0b8cd5a874914edaba67ce3bb711e688
     :target: https://www.codacy.com/gh/STEllAR-GROUP/hpx
     :alt: HPX Code Quality Assessment

.. |coveralls| image:: https://coveralls.io/repos/github/STEllAR-GROUP/hpx/badge.svg
     :target: https://coveralls.io/github/STEllAR-GROUP/hpx
     :alt: HPX coverage report

.. |JOSS| image:: https://joss.theoj.org/papers/022e5917b95517dff20cd3742ab95eca/status.svg
    :target: https://joss.theoj.org/papers/022e5917b95517dff20cd3742ab95eca
    :alt: JOSS Paper about HPX

.. |CFF| image:: https://github.com/STEllAR-GROUP/hpx/actions/workflows/cff-validator.yml/badge.svg
    :target: https://github.com/STEllAR-GROUP/hpx/actions/workflows/cff-validator.yml
    :alt: Citations file for HPX
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_overview:

========
Overview
========

|hpx| is organized into different sub-libraries and those in turn into modules.
The libraries and modules are independent, with clear dependencies and no
cycles. As an end-user, the use of these libraries is completely transparent. If
you use e.g. ``add_hpx_executable`` to create a target in your project you will
automatically get all modules as dependencies. See below for a list of the
available libraries and modules. Currently these are nothing more than an
internal grouping and do not affect usage. They cannot be consumed individually
at the moment.

.. toctree::
   :maxdepth: 2

   /libs/core/modules.rst
   /libs/parallelism/modules.rst
   /libs/full/modules.rst
..
    Copyright (c) 2018-2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. toctree::
   :caption: Modules
   :maxdepth: 2

   /libs/overview.rst
..
    Copyright (c) 2018 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

This directory holds modularized libraries HPX is build upon. Those libraries
can be seen as independent modules, with clear dependencies and no cycles.

The tool ```create_module_skeleton.py`` can be used to generate a basic
skeleton. The structure of this skeleton should be as follows:

* ``<lib_name>/``

  * ``README.rst``
  * ``CMakeLists.txt``
  * ``cmake``
  * ``docs/``

    * ``index.rst``

  * ``examples/``

    * ``CMakeLists.txt``

  * ``include/``

    * ``hpx/``

      * ``<lib_name>``

  * ``src/``

    * ``CMakeLists.txt``

  * ``tests/``

    * ``CMakeLists.txt``
    * ``unit/``

      * ``CMakeLists.txt``

    * ``regressions/``

      * ``CMakeLists.txt``

    * ``performance/``

      * ``CMakeLists.txt``

A ``README.rst`` should be always included which explains the basic purpose of
the library and a link to the generated documentation.

The ``include`` directory should contain only headers that other libraries need.
Private headers should be placed under the ``src`` directory. This allows for
clear separation. The ``cmake`` subdirectory may include additional |cmake|_
scripts needed to generate the respective build configurations.

Documentation is placed in the ``docs`` folder. A empty skeleton for the index
is created, which is picked up by the main build system and will be part of the
generated documentation.
..
    Copyright (c) 2018-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _full_modules:

==================
Main |hpx| modules
==================

.. toctree::
   :maxdepth: 2

   /libs/full/actions/docs/index.rst
   /libs/full/actions_base/docs/index.rst
   /libs/full/agas/docs/index.rst
   /libs/full/agas_base/docs/index.rst
   /libs/full/async_colocated/docs/index.rst
   /libs/full/async_distributed/docs/index.rst
   /libs/full/checkpoint/docs/index.rst
   /libs/full/checkpoint_base/docs/index.rst
   /libs/full/collectives/docs/index.rst
   /libs/full/command_line_handling/docs/index.rst
   /libs/full/components/docs/index.rst
   /libs/full/components_base/docs/index.rst
   /libs/full/compute/docs/index.rst
   /libs/full/distribution_policies/docs/index.rst
   /libs/full/executors_distributed/docs/index.rst
   /libs/full/include/docs/index.rst
   /libs/full/init_runtime/docs/index.rst
   /libs/full/lcos_distributed/docs/index.rst
   /libs/full/naming/docs/index.rst
   /libs/full/naming_base/docs/index.rst
   /libs/full/parcelport_libfabric/docs/index.rst
   /libs/full/parcelport_mpi/docs/index.rst
   /libs/full/parcelport_tcp/docs/index.rst
   /libs/full/parcelset/docs/index.rst
   /libs/full/parcelset_base/docs/index.rst
   /libs/full/performance_counters/docs/index.rst
   /libs/full/plugin_factories/docs/index.rst
   /libs/full/resiliency_distributed/docs/index.rst
   /libs/full/runtime_components/docs/index.rst
   /libs/full/runtime_distributed/docs/index.rst
   /libs/full/segmented_algorithms/docs/index.rst
   /libs/full/statistics/docs/index.rst
   /libs/full/version/docs/index.rst

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
components_base
===============

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx-docs/latest/html/libs/components_base/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_components_base:

===============
components_base
===============

TODO: High-level description of the library.

See the :ref:`API reference <modules_components_base_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===================
runtime_distributed
===================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/runtime_distributed/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_runtime_distributed:

===================
runtime_distributed
===================

TODO: High-level description of the module.

See the :ref:`API reference <modules_runtime_distributed_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====================
segmented_algorithms
====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/segmented_algorithms/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_segmented_algorithms:

====================
segmented_algorithms
====================

Segmented algorithms extend the usual parallel :ref:`modules_algorithms` by
providing overloads that work with distributed containers, such as partitioned vectors.

See the :ref:`API reference <modules_segmented_algorithms_api>` of the module for
more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====================
executors_distributed
=====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/executors_distributed/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_executors_distributed:

=====================
executors_distributed
=====================

This module provides the executor
:cpp:class:`hpx::parallel::execution::disribution_policy_executor`. It allows
one to create work that is implicitly distributed over multiple localities.

See the :ref:`API reference <modules_executors_distributed_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
checkpoint
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/checkpoint/docs/index.html>`__.
..
    Copyright (c) 2019-2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_checkpoint:

==========
checkpoint
==========

A common need of users is to periodically backup an application. This practice
provides resiliency and potential restart points in code. |hpx| utilizes the
concept of a ``checkpoint`` to support this use case.

Found in ``hpx/util/checkpoint.hpp``, ``checkpoint``\ s are defined as objects
that hold a serialized version of an object or set of objects at a particular
moment in time. This representation can be stored in memory for later use or it
can be written to disk for storage and/or recovery at a later point. In order to
create and fill this object with data, users must use a function called
``save_checkpoint``. In code the function looks like this::

    hpx::future<hpx::util::checkpoint> hpx::util::save_checkpoint(a, b, c, ...);

``save_checkpoint`` takes arbitrary data containers, such as ``int``,
``double``, ``float``, ``vector``, and ``future``, and serializes them into a
newly created ``checkpoint`` object. This function returns a ``future`` to a
``checkpoint`` containing the data. Here's an example of a simple use case::

    using hpx::util::checkpoint;
    using hpx::util::save_checkpoint;

    std::vector<int> vec{1,2,3,4,5};
    hpx::future<checkpoint> save_checkpoint(vec);

Once the future is ready, the checkpoint object will contain the ``vector``
``vec`` and its five elements.

``prepare_checkpoint`` takes arbitrary data containers (same as for
``save_checkpoint``), , such as ``int``,
``double``, ``float``, ``vector``, and ``future``, and calculates the necessary
buffer space for the checkpoint that would be created if ``save_checkpoint``
was called with the same arguments. This function returns a ``future`` to a
``checkpoint`` that is appropriately initialized. Here's an example of a
simple use case::

    using hpx::util::checkpoint;
    using hpx::util::prepare_checkpoint;

    std::vector<int> vec{1,2,3,4,5};
    hpx::future<checkpoint> prepare_checkpoint(vec);

Once the future is ready, the checkpoint object will be initialized with an
appropriately sized internal buffer.

It is also possible to modify the launch policy used by ``save_checkpoint``.
This is accomplished by passing a launch policy as the first argument. It is
important to note that passing ``hpx::launch::sync`` will cause
``save_checkpoint`` to return a ``checkpoint`` instead of a ``future`` to a
``checkpoint``. All other policies passed to ``save_checkpoint`` will return a
``future`` to a ``checkpoint``.

Sometimes ``checkpoint`` s must be declared before they are used.
``save_checkpoint`` allows users to move pre-created ``checkpoint`` s into the
function as long as they are the first container passing into the function (In
the case where a launch policy is used, the ``checkpoint`` will immediately
follow the launch policy). An example of these features can be found below:

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint.cpp
   :language: c++
   :start-after: //[check_test_1
   :end-before: //]

Once users can create ``checkpoint``\ s they must now be able to restore the
objects they contain into memory. This is accomplished by the function
``restore_checkpoint``. This function takes a ``checkpoint`` and fills its data
into the containers it is provided. It is important to remember that the
containers must be ordered in the same way they were placed into the
``checkpoint``. For clarity see the example below:

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint.cpp
   :language: c++
   :start-after: //[check_test_2
   :end-before: //]

The core utility of ``checkpoint`` is in its ability to make certain data
persistent. Often, this means that the data needs to be stored in an object,
such as a file, for later use. |hpx| has two solutions for these issues: stream
operator overloads and access iterators.

|hpx| contains two stream overloads, ``operator<<`` and ``operator>>``, to stream
data out of and into ``checkpoint``. Here is an example of the overloads in
use below:

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint.cpp
   :language: c++
   :start-after: //[check_test_3
   :end-before: //]

This is the primary way to move data into and out of a ``checkpoint``. It is
important to note, however, that users should be cautious when using a stream
operator to load data and another function to remove it (or vice versa). Both
``operator<<`` and ``operator>>`` rely on a ``.write()`` and a ``.read()``
function respectively. In order to know how much data to read from the
``std::istream``, the ``operator<<`` will write the size of the ``checkpoint``
before writing the ``checkpoint`` data. Correspondingly, the ``operator>>`` will
read the size of the stored data before reading the data into a new instance of
``checkpoint``. As long as the user employs the ``operator<<`` and
``operator>>`` to stream the data, this detail can be ignored.

.. important::

   Be careful when mixing ``operator<<`` and ``operator>>`` with other
   facilities to read and write to a ``checkpoint``. ``operator<<`` writes an
   extra variable, and ``operator>>`` reads this variable back separately. Used
   together the user will not encounter any issues and can safely ignore this
   detail.

Users may also move the data into and out of a ``checkpoint`` using the exposed
``.begin()`` and ``.end()`` iterators. An example of this use case is
illustrated below.

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint.cpp
   :language: c++
   :start-after: //[check_test_4
   :end-before: //]

Checkpointing components
------------------------

``save_checkpoint`` and ``restore_checkpoint`` are also able to store components
inside ``checkpoint``\ s. This can be done in one of two ways. First a client of
the component can be passed to ``save_checkpoint``. When the user wishes to
resurrect the component she can pass a client instance to
``restore_checkpoint``.

This technique is demonstrated below:

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint_component.cpp
   :language: c++
   :start-after: //[client_example
   :end-before: //]

The second way a user can save a component is by passing a ``shared_ptr`` to the
component to ``save_checkpoint``. This component can be resurrected by creating
a new instance of the component type and passing a ``shared_ptr`` to the new
instance to ``restore_checkpoint``.

This technique is demonstrated below:

.. literalinclude:: ../../../../../libs/full/checkpoint/tests/unit/checkpoint_component.cpp
   :language: c++
   :start-after: //[shared_ptr_example
   :end-before: //]

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
include
=======

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/include/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_include:

=======
include
=======

This module provides no functionality in itself. Instead it provides headers
that group together other headers that often appear together.

See the :ref:`API reference <modules_include_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

================
lcos_distributed
================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/lcos_distributed/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_lcos_distributed:

================
lcos_distributed
================

This module contains distributed :term:`LCO`\ s. Currently the only LCO provided
is :cpp:class::`hpx::lcos::channel`, a construct for sending values from one
:term:`locality` to another. See :ref:`libs_lcos_local` for local LCOs.

See the :ref:`API reference <modules_lcos_distributed_api>` of this module for more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========
Collectives
===========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/collectives/docs/index.html>`__.
..
    Copyright (c) 2019-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_collectives:

===========
collectives
===========

The collectives module exposes a set of distributed collective operations. Those
can be used to exchange data between participating sites in a coordinated way.
At this point the module exposes the following collective primitives:

* :cpp:func:`hpx::collectives::all_gather`: receives a set of values from all
  participating sites.
* :cpp:func:`hpx::collectives::all_reduce`: performs a reduction on data from
  each participating site to each participating site.
* :cpp:func:`hpx::collectives::all_to_all`: each participating site provides its
  element of the data to collect while all participating sites receive the data
  from every other site.
* :cpp:func:`hpx::collectives::broadcast_to` and
  :cpp:func:`hpx::collectives::broadcast_from`: performs a broadcast operation
  from a root site to all participating sites.
* :cpp:func:hpx::collectives::exclusive_scan: performs an exclusive scan operation
  on a set of values received from all call sites operating on the given base name.
* :cpp:func:`hpx::collectives::gather_here` and
  :cpp:func:`hpx::collectives::gather_there`: gathers values from all
  participating sites.
* :cpp:func:hpx::collectives::inclusive_scan: performs an inclusive scan operation
  on a set of values received from all call sites operating on the given base name.
* :cpp:func:`hpx::collectives::reduce_here` and
  :cpp:func:`hpx::collectives::reduce_there`: performs a reduction on data from each
  participating site to a root site.
* :cpp:func:`hpx::collectives::scatter_to` and
  :cpp:func:`hpx::collectives::scatter_from`: receives an element of a set of values
  operating on the given base name.

* :cpp:func:`hpx::lcos::broadcast`: performs a given action on all given global
  identifiers.
* :cpp:class:`hpx::lcos::barrier`: distributed barrier.
* :cpp:func:`hpx::lcos::fold`: performs a fold with a given action on all given
  global identifiers.
* :cpp:class:`hpx::lcos::latch`: distributed latch.
* :cpp:func:`hpx::lcos::reduce`: performs a reduction on data from each
  given global identifiers.
* :cpp:class:`hpx::lcos::spmd_block`: performs the same operation on a local
  image while providing handles to the other images.

See the :ref:`API reference <modules_collectives_api>` of the module for more
details.

..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
parcelset
=========

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/parcelset/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_parcelset:

=========
parcelset
=========

TODO: High-level description of the module.

See the :ref:`API reference <modules_parcelset_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
init_runtime
============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/init_runtime/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_init_runtime:

============
init_runtime
============

TODO: High-level description of the library.

See the :ref:`API reference <modules_init_runtime_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
actions_base
============

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx-docs/latest/html/libs/actions_base/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_actions_base:

============
actions_base
============

TODO: High-level description of the library.

See the :ref:`API reference <modules_actions_base_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
components
==========

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/components/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_components:

==========
components
==========

TODO: High-level description of the module.

See the :ref:`API reference <modules_components_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====================
command_line_handling
=====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/command_line_handling/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_command_line_handling:

=====================
command_line_handling
=====================

The command_line_handling module defines and handles the command-line options
required by the |hpx| runtime, combining them with configuration options
defined by the :ref:`modules_runtime_configuration` module. The actual parsing of
command line options is handled by the :ref:`modules_program_options` module.

See the :ref:`API reference <modules_command_line_handling_api>` of the module for
more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====================
performance_counters
====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/performance_counters/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_performance_counters:

====================
performance_counters
====================

This module provides the basic functionality required for defining performance
counters. See :ref:`performance_counters` for more information about
performance counters.

See the :ref:`API reference <modules_performance_counters_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==================
runtime_components
==================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/runtime_components/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_runtime_components:

==================
runtime_components
==================

TODO: High-level description of the module.

See the :ref:`API reference <modules_runtime_components_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
compute
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/compute/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_compute:

=======
compute
=======

The compute module provides utilities for handling task and memory affinity on
host systems.

See the :ref:`API reference <modules_compute_api>` of the module for more details.

..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====
agas
====

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/agas/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_agas:

====
agas
====

TODO: High-level description of the module.

See the :ref:`API reference <modules_agas_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====================
distribution_policies
=====================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/distribution_policies/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_distribution_policies:

=====================
distribution_policies
=====================

TODO: High-level description of the module.

See the :ref:`API reference <modules_distribution_policies_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
statistics
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/statistics/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_statistics:

==========
statistics
==========

This module provide some statistics utilities like rolling min/max and
histogram.

See the :ref:`API reference <modules_statistics_api>` of the module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
agas_base
=========

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/agas_base/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_agas_base:

=========
agas_base
=========

This module holds the implementation of the four AGAS services: primary
namespace, locality namespace, component namespace, and symbol namespace.

See the :ref:`API reference <modules_agas_base_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======================
resiliency_distributed
======================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/resiliency_distributed/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_resiliency_distributed:

======================
resiliency_distributed
======================

Software resiliency features of |HPX| were introduced in the
:ref:`resiliency module <modules_resiliency_api>`. This module extends the APIs
to run on distributed-memory systems allowing the user to invoke the failing
task on other localities at runtime. This is useful in cases where a node is
identified to fail more often (e.g., for certain ALU computes) as the task can
now be replayed or replicated among different localities. The API exposed
allows for an easy integration with the local only resiliency APIs as well.

Distributed software resilience APIs have a similar function signature
and lives under the same namespace of :cpp:func:`hpx::resiliency::experimental`.
The difference arises in the formal parameters where distributed APIs takes
the localities as the first argument, and an action as opposed to a function or
a function object. The localities signify the order in which the API will either
schedule (in case of Task Replay) tasks in a round robin fashion or replicate
the tasks onto the list of localities.

The list of APIs exposed by distributed resiliency modules is the same as those
defined in :ref:`local resiliency module <modules_resiliency_api>`.

See the :ref:`API reference <modules_resiliency_distributed_api>` of this module
for more details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========
naming_base
===========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/naming_base/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_naming_base:

===========
naming_base
===========

This module provides a forward declaration of `address_type`, `component_type`
and `invalid_locality_id`.

See the :ref:`API reference <modules_naming_base_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====================
parcelport_libfabric
====================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/parcelport_libfabric/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_parcelport_libfabric:

====================
parcelport_libfabric
====================

TODO: High-level description of the module.

See the :ref:`API reference <modules_parcelport_libfabric_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
parcelport_tcp
==============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/parcelport_tcp/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_parcelport_tcp:

==============
parcelport_tcp
==============

TODO: High-level description of the module.

See the :ref:`API reference <modules_parcelport_tcp_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
naming
======

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/naming/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_naming:

======
naming
======

TODO: High-level description of the module.

See the :ref:`API reference <modules_naming_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

================
plugin_factories
================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/plugin_factories/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_plugin_factories:

================
plugin_factories
================

TODO: High-level description of the module.

See the :ref:`API reference <modules_plugin_factories_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
actions
=======

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx-docs/latest/html/libs/actions/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_actions:

=======
actions
=======

TODO: High-level description of the library.

See the :ref:`API reference <modules_actions_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
parcelset_base
==============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/parcelset_base/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_parcelset_base:

==============
parcelset_base
==============

TODO: High-level description of the module.

See the :ref:`API reference <modules_parcelset_base_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
parcelport_mpi
==============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/parcelport_mpi/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_parcelport_mpi:

==============
parcelport_mpi
==============

TODO: High-level description of the module.

See the :ref:`API reference <modules_parcelport_mpi_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
async_colocated
===============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/async_colocated/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async_colocated:

===============
async_colocated
===============

TODO: High-level description of the module.

See the :ref:`API reference <modules_async_colocated_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
checkpoint_base
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/checkpoint_base/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_checkpoint_base:

===============
checkpoint_base
===============

The checkpoint_base module contains lower level facilities that wrap simple
check-pointing capabilities. This module does not implement special handling
for futures or components, but simply serializes all arguments to or from
a given container.

This module exposes the ``hpx::util::save_checkpoint_data``,
``hpx::util::restore_checkpoint_data``, and ``hpx::util::prepare_checkpoint_data``
APIs. These functions encapsulate the basic serialization functionalities
necessary to save/restore a variadic list of arguments to/from a given data
container.

See the :ref:`API reference <modules_checkpoint_base_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====
async
=====

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/async_distributed/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async:

=====
async
=====

This module contains functionality for asynchronously launching work on remote
localities: :cpp:func:`hpx::async`, :cpp:func:`hpx::apply`. This module extends
the local-only functions in :ref:`libs_async_local`.

See the :ref:`API reference <modules_async_api>` of this module for more
details.

..
    Copyright (c) 2018-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _core_modules:

============
Core modules
============

.. toctree::
   :maxdepth: 2

   /libs/core/affinity/docs/index.rst
   /libs/core/algorithms/docs/index.rst
   /libs/core/allocator_support/docs/index.rst
   /libs/core/asio/docs/index.rst
   /libs/core/assertion/docs/index.rst
   /libs/core/async_base/docs/index.rst
   /libs/core/async_combinators/docs/index.rst
   /libs/core/async_cuda/docs/index.rst
   /libs/core/async_local/docs/index.rst
   /libs/core/async_mpi/docs/index.rst
   /libs/core/batch_environments/docs/index.rst
   /libs/core/cache/docs/index.rst
   /libs/core/command_line_handling_local/docs/index.rst
   /libs/core/concepts/docs/index.rst
   /libs/core/concurrency/docs/index.rst
   /libs/core/config/docs/index.rst
   /libs/core/config_registry/docs/index.rst
   /libs/core/coroutines/docs/index.rst
   /libs/core/datastructures/docs/index.rst
   /libs/core/debugging/docs/index.rst
   /libs/core/errors/docs/index.rst
   /libs/core/execution/docs/index.rst
   /libs/core/execution_base/docs/index.rst
   /libs/core/executors/docs/index.rst
   /libs/core/filesystem/docs/index.rst
   /libs/core/format/docs/index.rst
   /libs/core/functional/docs/index.rst
   /libs/core/futures/docs/index.rst
   /libs/core/hardware/docs/index.rst
   /libs/core/hashing/docs/index.rst
   /libs/core/include_local/docs/index.rst
   /libs/core/ini/docs/index.rst
   /libs/core/init_runtime_local/docs/index.rst
   /libs/core/io_service/docs/index.rst
   /libs/core/iterator_support/docs/index.rst
   /libs/core/itt_notify/docs/index.rst
   /libs/core/lcos_local/docs/index.rst
   /libs/core/lock_registration/docs/index.rst
   /libs/core/logging/docs/index.rst
   /libs/core/memory/docs/index.rst
   /libs/core/mpi_base/docs/index.rst
   /libs/core/pack_traversal/docs/index.rst
   /libs/core/plugin/docs/index.rst
   /libs/core/prefix/docs/index.rst
   /libs/core/preprocessor/docs/index.rst
   /libs/core/program_options/docs/index.rst
   /libs/core/properties/docs/index.rst
   /libs/core/resiliency/docs/index.rst
   /libs/core/resource_partitioner/docs/index.rst
   /libs/core/runtime_configuration/docs/index.rst
   /libs/core/runtime_local/docs/index.rst
   /libs/core/schedulers/docs/index.rst
   /libs/core/serialization/docs/index.rst
   /libs/core/static_reinit/docs/index.rst
   /libs/core/string_util/docs/index.rst
   /libs/core/synchronization/docs/index.rst
   /libs/core/tag_invoke/docs/index.rst
   /libs/core/testing/docs/index.rst
   /libs/core/thread_pool_util/docs/index.rst
   /libs/core/thread_pools/docs/index.rst
   /libs/core/thread_support/docs/index.rst
   /libs/core/threading/docs/index.rst
   /libs/core/threading_base/docs/index.rst
   /libs/core/threadmanager/docs/index.rst
   /libs/core/timed_execution/docs/index.rst
   /libs/core/timing/docs/index.rst
   /libs/core/topology/docs/index.rst
   /libs/core/type_support/docs/index.rst
   /libs/core/util/docs/index.rst
   /libs/core/version/docs/index.rst

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
config_registry
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/config_registry/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_config_registry:

===============
config_registry
===============

The config_registry module is a low level module providing helper functionality
for registering configuration entries to a global registry from other modules.
The :cpp:func:`hpx::config_registry::add_module_config` function is used to add
configuration options, and :cpp:func:`hpx::config_registry::get_module_configs`
can be used to retrieve configuration entries registered so far.
:cpp:class:`add_module_config_helper` can be used to register configuration
entries through static global options.

See the :ref:`API reference <modules_config_registry_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
io_service
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/io_service/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_io_service:

==========
io_service
==========

This module provides an abstraction over Boost.ASIO, combining multiple
``asio::io_context``\ s into a single pool.
:cpp:class:`hpx::util::io_service_pool` provides a simple pool of
``asio::io_context``\ s with an API similar to ``asio::io_context``.
:cpp:class:`hpx::threads::detail::io_service_thread_pool` wraps
:cpp:class:`hpx::util::io_service_pool` into an interface derived from
:cpp:class:`hpx::threads::detail::thread_pool_base`.

See the :ref:`API reference <modules_io_service_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
config
======

This library is part of HPX. It contains macros that identify features of a compiler
as well as platform independent macros to control inlinining, export sets and more.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/config/docs/index.html>`_.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_config:

======
config
======

The config module contains various configuration options, typically hidden
behind macros that choose the correct implementation based on the compiler and
other available options.

See the :ref:`API reference <modules_config_api>` of the module for more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
runtime_local
=============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/runtime_local/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_runtime_local:

=============
runtime_local
=============

TODO: High-level description of the library.

See the :ref:`API reference <modules_runtime_local_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

================
iterator_support
================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/iterator_support/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_iterator_support:

================
iterator_support
================

This module provides helpers for iterators. It provides
:cpp:class:`hpx::util::iterator_facade` and
:cpp:class:`hpx::util::iterator_adaptor` for creating new iterators, and the
trait :cpp:class:`hpx::util::is_iterator` along with more specific iterator
traits.

See the :ref:`API reference <modules_iterator_support_api>` of the module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
executors
=========

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/executors/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_executors:

=========
executors
=========

The executors module exposes executors and execution policies. Most importantly,
it exposes the following classes and constants:

* :cpp:class:`hpx::execution::sequenced_executor`
* :cpp:class:`hpx::execution::parallel_executor`
* :cpp:class:`hpx::execution::sequenced_policy`
* :cpp:class:`hpx::execution::parallel_policy`
* :cpp:class:`hpx::execution::parallel_unsequenced_policy`
* :cpp:class:`hpx::execution::sequenced_task_policy`
* :cpp:class:`hpx::execution::parallel_task_policy`
* :cpp:var:`hpx::execution::seq`
* :cpp:var:`hpx::execution::par`
* :cpp:var:`hpx::execution::par_unseq`
* :cpp:var:`hpx::execution::task`

See the :ref:`API reference <modules_executors_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
testing
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/testing/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_testing:

=======
testing
=======

The testing module contains useful macros for testing. The results of tests can
be printed with :cpp:func:`hpx::util::report_errors`. The following macros are
provided:

* :c:macro:`HPX_TEST`
* :c:macro:`HPX_TEST_MSG`
* :c:macro:`HPX_TEST_EQ`
* :c:macro:`HPX_TEST_NEQ`
* :c:macro:`HPX_TEST_LT`
* :c:macro:`HPX_TEST_LTE`
* :c:macro:`HPX_TEST_RANGE`
* :c:macro:`HPX_TEST_EQ_MSG`
* :c:macro:`HPX_TEST_NEQ_MSG`
* :c:macro:`HPX_SANITY`
* :c:macro:`HPX_SANITY_MSG`
* :c:macro:`HPX_SANITY_EQ`
* :c:macro:`HPX_SANITY_NEQ`
* :c:macro:`HPX_SANITY_LT`
* :c:macro:`HPX_SANITY_LTE`
* :c:macro:`HPX_SANITY_RANGE`
* :c:macro:`HPX_SANITY_EQ_MSG`

See the :ref:`API reference <modules_testing_api>` of the module for more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==================
init_runtime_local
==================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/init_runtime_local/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_init_runtime_local:

==================
init_runtime_local
==================

TODO: High-level description of the module.

See the :ref:`API reference <modules_init_runtime_local_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====================
resource_partitioner
====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/resource_partitioner/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_resource_partitioner:

====================
resource_partitioner
====================

The resource_partitioner module defines :cpp:class:`hpx::resource::partitioner`,
the class used by the runtime and users to partition available hardware
resources into thread pools. See :ref:`using_resource_partitioner` for more
details on using the resource partitioner in applications.

See the :ref:`API reference <modules_resource_partitioner_api>` of this module for
more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====================
runtime_configuration
=====================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/runtime_configuration/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_runtime_configuration:

=====================
runtime_configuration
=====================

This module handles the configuration options required by the runtime.

See the :ref:`API reference <modules_runtime_configuration_api>` of this module
for more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========================
command_line_handling_local
===========================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/command_line_handling_local/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_command_line_handling_local:

===========================
command_line_handling_local
===========================

TODO: High-level description of the module.

See the :ref:`API reference <modules_command_line_handling_local_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
concurrency
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/concurrency/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_concurrency:

===========
concurrency
===========

This module provides concurrency primitives useful for multi-threaded
programming such as:

* :cpp:class:`hpx::util::barrier`
* :cpp:class:`hpx::util::cache_line_data` and
  :cpp:class:`hpx::util::cache_aligned_data`: wrappers for aligning and padding
  data to cache lines.
* various lockfree queue data structures

See the :ref:`API reference <modules_concurrency_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========
async_local
===========

This module contains functionality for asynchronously launching local work:
:cpp:func:`hpx::async`, :cpp:func:`hpx::apply`, and :cpp:func:`hpx::dataflow`.
The :ref:`modules_async` module extends the functionality in this module to work
with :term:`action`\ s.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/async_local/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async_local:

===========
async_local
===========

This module extends :ref:`modules_async_base` to provide local implementations of
:cpp:func:`hpx::async`, :cpp:func:`hpx::apply`, :cpp:func:`hpx::sync`, and
:cpp:func:`hpx::dataflow`.

See the :ref:`API reference <modules_async_local_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
Resiliency
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/resiliency/docs/index.html>`__.

Copyright (c) 2019 National Technology & Engineering Solutions of Sandia,
LLC (NTESS). Under the terms of the Contract DE-NA0003525 with NTESS, the
U.S. Government retains rights in this software.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_resiliency:

==========
resiliency
==========

In |hpx|, a program failure is a manifestation of a failing task. This module
exposes several APIs that allow users to manage failing tasks in a convenient way by
either replaying a failed task or by replicating a specific task.

Task replay is analogous to the Checkpoint/Restart mechanism found in conventional
execution models. The key difference being localized fault detection. When the
runtime detects an error, it replays the failing task as opposed to completely
rolling back the entire program to the previous checkpoint.

Task replication is designed to provide reliability enhancements by replicating
a set of tasks and evaluating their results to determine a consensus among them.
This technique is most effective in situations where there are few tasks in the
critical path of the DAG which leaves the system underutilized or where hardware
or software failures may result in an incorrect result instead of an error.
However, the drawback of this method is the additional computational cost incurred
by repeating a task multiple times.


The following API functions are exposed:

- :cpp:func:`hpx::resiliency::experimental::async_replay`: This version of task replay will
  catch user-defined exceptions and automatically reschedule the task N times
  before throwing an :cpp:func:`hpx::resiliency::experimental::abort_replay_exception` if no
  task is able to complete execution without an exception.

- :cpp:func:`hpx::resiliency::experimental::async_replay_validate`: This version of replay
  adds an argument to async replay which receives a user-provided validation
  function to test the result of the task against. If the task's output is
  validated, the result is returned. If the output fails the check or an
  exception is thrown, the task is replayed until no errors are encountered or
  the number of specified retries has been exceeded.

- :cpp:func:`hpx::resiliency::experimental::async_replicate`: This is the most basic
  implementation of the task replication. The API returns the first result that
  runs without detecting any errors.

- :cpp:func:`hpx::resiliency::experimental::async_replicate_validate`: This API additionally
  takes a validation function which evaluates the return values produced by the
  threads. The first task to compute a valid result is returned.

- :cpp:func:`hpx::resiliency::experimental::async_replicate_vote`: This API adds a vote
  function to the basic replicate function. Many hardware or software failures
  are silent errors which do not interrupt program flow. In order to detect
  errors of this kind, it is necessary to run the task several times and compare
  the values returned by every version of the task. In order to determine which
  return value is "correct", the API allows the user to provide a custom
  consensus function to properly form a consensus. This voting function then
  returns the "correct"" answer.

- :cpp:func:`hpx::resiliency::experimental::async_replicate_vote_validate`: This combines the
  features of the previously discussed replicate set. Replicate vote validate
  allows a user to provide a validation function to filter results.
  Additionally, as described in replicate vote, the user can provide a "voting
  function" which returns the consensus formed by the voting logic.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replay`: This version of dataflow replay
  will catch user-defined exceptions and automatically reschedules the task N
  times before throwing an :cpp:func:`hpx::resiliency::experimental::abort_replay_exception`
  if no task is able to complete execution without an exception. Any arguments
  for the executed task that are futures will cause the task invocation to be
  delayed until all of those futures have become ready.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replay_validate` : This version of replay
  adds an argument to dataflow replay which receives a user-provided validation
  function to test the result of the task against. If the task's output is
  validated, the result is returned. If the output fails the check or an
  exception is thrown, the task is replayed until no errors are encountered or
  the number of specified retries have been exceeded. Any arguments for the
  executed task that are futures will cause the task invocation to be delayed
  until all of those futures have become ready.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replicate`: This is the most basic
  implementation of the task replication. The API returns the first result that
  runs without detecting any errors. Any arguments for the executed task that
  are futures will cause the task invocation to be delayed until all of those
  futures have become ready.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replicate_validate`: This API
  additionally takes a validation function which evaluates the return values
  produced by the threads. The first task to compute a valid result is returned.
  Any arguments for the executed task that are futures will cause the task
  invocation to be delayed until all of those futures have become ready.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replicate_vote`: This API adds a vote
  function to the basic replicate function. Many hardware or software failures
  are silent errors which do not interrupt program flow. In order to detect
  errors of this kind, it is necessary to run the task several times and compare
  the values returned by every version of the task. In order to determine which
  return value is "correct", the API allows the user to provide a custom
  consensus function to properly form a consensus. This voting function then
  returns the "correct" answer. Any arguments for the executed task that are
  futures will cause the task invocation to be delayed until all of those
  futures have become ready.

- :cpp:func:`hpx::resiliency::experimental::dataflow_replicate_vote_validate`: This combines
  the features of the previously discussed replicate set. Replicate vote
  validate allows a user to provide a validation function to filter results.
  Additionally, as described in replicate vote, the user can provide a "voting
  function" which returns the consensus formed by the voting logic. Any
  arguments for the executed task that are futures will cause the task
  invocation to be delayed until all of those futures have become ready.

See the :ref:`API reference <modules_resiliency_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
thread
======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/thread/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_threading:

=========
threading
=========

This module provides the equivalents of ``std::thread`` and ``std::jthread``
for lightweight |hpx| threads:

* :cpp:class:`hpx::thread`
* :cpp:class:`hpx::jthread`

See the :ref:`API reference <modules_threading_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
preprocessor
===

This library contains useful preprocessor macros:

* ``HPX_PP_CAT``: Concatenate two tokens
* ``HPX_PP_EXPANDS``: Expands a preprocessor token
* ``HPX_PP_NARGS``: Determines the number of arguments passed to a variadic macro
* ``HPX_PP_STRINGIZE``: Turns a token into a string
* ``HPX_PP_STRIP_PARENS``: Strips parenthesis from a token

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/pp/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_preprocessor:

============
preprocessor
============

This library contains useful preprocessor macros:

* :c:macro:`HPX_PP_CAT`
* :c:macro:`HPX_PP_EXPAND`
* :c:macro:`HPX_PP_NARGS`
* :c:macro:`HPX_PP_STRINGIZE`
* :c:macro:`HPX_PP_STRIP_PARENS`

See the :ref:`API reference <modules_preprocessor_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==================
batch_environments
==================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/batch_environments/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_batch_environments:

==================
batch_environments
==================

This module allows for the detection of execution as batch jobs, a series of
programs executed without user intervention. All data is preselected and will
be executed according to preset parameters, such as date or completion of
another task. Batch environments are especially useful for executing repetitive
tasks.

|hpx| supports the creation of batch jobs through the Portable Batch System
(PBS) and SLURM.

For more information on batch environments, see :ref:`running_on_batch_systems`
and the :ref:`API reference <modules_batch_environments_api>` for the module.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
serialization
=============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/serialization/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_serialization:

=============
serialization
=============

This module provides serialization primitives and support for all built-in
types as well as all C++ Standard Library collection and utility types. This
list is extended by |hpx| vocabulary types with proper support for global
reference counting. |hpx|'s mode of serialization is derived from `Boost's
serialization model
<https://www.boost.org/doc/libs/1_72_0/libs/serialization/doc/index.html>`_
and, as such, is mostly interface compatible with
its Boost counterpart.

The purest form of serializing data is to copy the content of the payload bit
by bit; however, this method is impractical for generic C++ types, which might
be composed of more than just regular built-in types. Instead, |hpx|'s approach
to serialization is derived from the Boost Serialization library, and is geared
towards allowing the programmer of a given class explicit control and syntax of
what to serialize. It is based on operator overloading of two special archive
types that hold a buffer or stream to store the serialized data and is
responsible for dispatching the serialization mechanism to the intrusive or
non-intrusive version. The serialization process is recursive. Each member that
needs to be serialized must be specified explicitly. The advantage of this
approach is that the serialization code is written in C++ and leverages all
necessary programming techniques. The generic, user-facing interface allows
for effective application of the serialization process without obstructing the
algorithms that need special code for packing and unpacking. It also allows for
optimizations in the implementation of the archives.

See the :ref:`API reference <modules_serialization_api>` of the module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

================
thread_pool_util
================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/thread_pool_util/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_thread_pool_util:

================
thread_pool_util
================

This module contains helper functions for asynchronously suspending and resuming
thread pools and their worker threads.

See the :ref:`API reference <modules_thread_pool_util_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
timing
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/timing/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_timing:

======
timing
======

This module provides the timing utilities (clocks and timers).

See the :ref:`API reference <modules_timing_api>` of the module for more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
logging
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/logging/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_logging:

=======
logging
=======

This module provides useful macros for logging information.

See the :ref:`API reference <modules_logging_api>` of the module for more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========
string_util
===========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/string_util/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_string_util:

===========
string_util
===========

This module contains string utilities inspired by the Boost string algorithms
library.

See the :ref:`API reference <modules_string_util_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
async_mpi
===

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/mpi/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_mpi:

=========
async_mpi
=========

The MPI library is intended to simplify the process of integrating MPI based
codes with the |hpx| runtime. Any MPI function that is asynchronous and uses an
MPI_Request may be converted into an hpx::future.
The syntax is designed to allow a simple replacement of the MPI call with a futurized
async version that accepts an executor instead of a communicator,
and returns a future instead of assigning a request.
Typically, an MPI call of the form

.. code-block:: c++

    int MPI_Isend(buf, count, datatype, rank, tag, comm, request);

becomes

.. code-block:: c++

    hpx::future<int> f = hpx::async(executor, MPI_Isend, buf, count, datatype, rank, tag);

When the MPI operation is complete, the future will become ready.
This allows communication to integrated cleanly with the rest of HPX, in particular
the continuation style of programming may be used to build up more
complex code. Consider the following example, that chains user processing,
sends and receives using continuations...

.. code-block:: c++

    // create an executor for MPI dispatch
    hpx::mpi::experimental::executor exec(MPI_COMM_WORLD);

    // post an asynchronous receive using MPI_Irecv
    hpx::future<int> f_recv = hpx::async(
        exec, MPI_Irecv, &data, rank, MPI_INT, rank_from, i);

    // attach a continuation to run when the recv completes,
    f_recv.then([=, &tokens, &counter](auto&&)
    {
        // call an application specific function
        msg_recv(rank, size, rank_to, rank_from, tokens[i], i);

        // send a new message
        hpx::future<int> f_send = hpx::async(
            exec, MPI_Isend, &tokens[i], 1, MPI_INT, rank_to, i);

        // when that send completes
        f_send.then([=, &tokens, &counter](auto&&)
        {
            // call an application specific function
            msg_send(rank, size, rank_to, rank_from, tokens[i], i);
        });
    }

The example above makes use of ``MPI_Isend`` and ``MPI_Irecv``, but *any* MPI function
that uses requests may be futurized in this manner.
The following is a (non exhaustive) list of MPI functions that *should* be supported,
though not all have been tested at the time of writing
(please report any problems to the issue tracker).

.. code-block:: c++

    int MPI_Isend(...);
    int MPI_Ibsend(...);
    int MPI_Issend(...);
    int MPI_Irsend(...);
    int MPI_Irecv(...);
    int MPI_Imrecv(...);
    int MPI_Ibarrier(...);
    int MPI_Ibcast(...);
    int MPI_Igather(...);
    int MPI_Igatherv(...);
    int MPI_Iscatter(...);
    int MPI_Iscatterv(...);
    int MPI_Iallgather(...);
    int MPI_Iallgatherv(...);
    int MPI_Ialltoall(...);
    int MPI_Ialltoallv(...);
    int MPI_Ialltoallw(...);
    int MPI_Ireduce(...);
    int MPI_Iallreduce(...);
    int MPI_Ireduce_scatter(...);
    int MPI_Ireduce_scatter_block(...);
    int MPI_Iscan(...);
    int MPI_Iexscan(...);
    int MPI_Ineighbor_allgather(...);
    int MPI_Ineighbor_allgatherv(...);
    int MPI_Ineighbor_alltoall(...);
    int MPI_Ineighbor_alltoallv(...);
    int MPI_Ineighbor_alltoallw(...);

Note that the |hpx| mpi futurization wrapper should work with *any* asynchronous
`MPI` call, as long as the function signature has the last two arguments
`MPI_xxx(..., MPI_Comm comm, MPI_Request *request)`
- internally these two parameters will be substituted by the executor and future data
parameters that are supplied by template instantiations inside the `hpx::mpi` code.

See the :ref:`API reference <modules_mpi_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
errors
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/errors/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_errors:

======
errors
======

This module provides support for exceptions and error codes:

* :cpp:class:`hpx::exception`
* :cpp:class:`hpx::error_code`
* :cpp:enum:`hpx::error`

See the :ref:`API reference <modules_errors_api>` of the module for more details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
format
======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/format/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_format:

======
format
======

The format module exposes the :cpp:func:`format` and :cpp:func:`format_to`
functions for formatting strings.

See the :ref:`API reference <modules_format_api>` of the module for more details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
plugin
======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/plugin/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_plugin:

======
plugin
======

This module provides base utilities for creating plugins.

See the :ref:`API reference <modules_plugin_api>` of the module for more details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
algorithms
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/algorithms/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_algorithms:

==========
algorithms
==========

The algorithms module exposes the full set of algorithms defined by the C++
standard. There is also partial support for C++ ranges.

See the :ref:`API reference <modules_algorithms_api>` of the module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
properties
==========

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/properties/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_properties:

==========
properties
==========

This module implements the ``prefer`` customization point for properties in
terms of |p2220|_. This differs from |p1393|_ in that it relies fully on
``tag_invoke`` overloads and fewer base customization points. Actual properties
are defined in modules. All functionality is experimental and can be accessed
through the ``hpx::experimental`` namespace.

See the :ref:`API reference <modules_properties_api>` of this module for more
details.

..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
include_local
=============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/include_local/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_include_local:

=============
include_local
=============

This module provides no functionality in itself. Instead it provides headers
that group together other headers that often appear together. This module
provides local-only headers.

See the :ref:`API reference <modules_include_local_api>` of this module for
more details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

========
topology
========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/topology/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_topology:

========
topology
========

This module provides the class :cpp:class:`hpx::threads::topology` which
represents the hardware resources available on a node. The class is a light
wrapper around the |hwloc|_ library. The :cpp:class:`hpx::threads::cpu_mask` is
a small companion class that represents a set of resources on a node.

See the :ref:`API reference <modules_topology_api>` of the module for more details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
cache
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/cache/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_cache:

=====
cache
=====

This module provides two cache data structures:

* :cpp:class:`hpx::util::cache::local_cache`
* :cpp:class:`hpx::util::cache::lru_cache`

See the :ref:`API reference <modules_cache_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
Basic Execution
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/execution_base/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_execution_base:

===============
execution_base
===============

The basic execution module is the main entry point to implement parallel and
concurrent operations. It is modeled after `P0443 <http://wg21.link/p0443>`_
with some additions and implementations for the described concepts. Most
notably, it provides an abstraction for execution resources, execution contexts
and execution agents in such a way, that it provides customization points that
those aforementioned concepts can be replaced and combined with ease.

For that purpose, three virtual base classes are provided to be able to provide
implementations with different properties:

 - ``resource_base``: This is the abstraction for execution resources, that is
    for example CPU cores or an accelerator.
 - ``context_base``: An execution context uses execution resources and is able
    to spawn new execution agents, as new threads of executions on the available
    resources.
 - ``agent_base``: The execution agent represents the thread of execution, and
    can be used to yield, suspend, resume or abort a thread of execution.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
pack_traversal
==============

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/pack_traversal/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_pack_traversal:

==============
pack_traversal
==============

This module exposes the basic functionality for traversing various packs, both
synchronously and asynchronously: :cpp:func:`hpx::util::traverse_pack` and
:cpp:func:`hpx::util::traverse_pack_async`. It also exposes the higher level
functionality of unwrapping nested futures: :cpp:func:`hpx::util::unwrap` and
its function object form :cpp:class:`hpx::util::functional::unwrap`.

See the :ref:`API reference <modules_pack_traversal_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
coroutines
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/coroutines/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_coroutines:

==========
coroutines
==========

The coroutines module provides coroutine (user-space thread) implementations
for different platforms.

See the :ref:`API reference <modules_coroutines_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
thread_manager
==============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/thread_manager/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_thread_manager:

==============
thread_manager
==============

This module defines the :cpp:class:`hpx::threads::threadmanager` class. This is
used by the runtime to manage the creation and destruction of thread pools. The
:ref:`modules_resource_partitioner` module handles the partitioning of resources
into thread pools, but not the creation of thread pools.

See the :ref:`API reference <modules_thread_manager_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
version
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/version/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_version:

=======
version
=======

This module macros and functions for accessing version information about |hpx|
and its dependencies.

See the :ref:`API reference <modules_futures_api>` of this module for more
details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
thread_support
==============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/thread_support/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_thread_support:

==============
thread_support
==============

This module provides miscellaneous utilities for threading and concurrency.

See the :ref:`API reference <modules_thread_support_api>` of the module for more
details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
util
=========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/util/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_util:

====
util
====

The util module provides miscellaneous standalone utilities.

See the :ref:`API reference <modules_util_api>` of the module for more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
timed_execution
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/timed_execution/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_timed_execution:

===============
timed_execution
===============

This module provides extensions to the executor interfaces defined in the
:ref:`modules_execution` module that allow timed submission of tasks on thread
pools (at or after a specified time).

See the :ref:`API reference <modules_timed_execution_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
ini
===

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/ini/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_ini:

===
ini
===

TODO: High-level description of the module.

See the :ref:`API reference <modules_ini_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

====
asio
====

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/asio/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_asio:

====
asio
====

The asio module is a thin wrapper around the Boost.ASIO library, providing a
few additional helper functions.

See the :ref:`API reference <modules_algorithms_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
prefix
======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/prefix/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_prefix:

======
prefix
======

This module provides utilities for handling the prefix of an |hpx| application,
i.e. the paths used for searching components and plugins.

See the :ref:`API reference <modules_prefix_api>` of this module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
futures
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/futures/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_futures:

=======
futures
=======

This module defines the :cpp:class:`hpx::future` and
:cpp:class:`hpx::shared_future` classes corresponding to the C++ standard
library classes ``std::future`` and ``std::shared_future``. Note that the
specializations of :cpp:func:`hpx::future::then` for executors and
execution policies are defined in the :ref:`modules_execution` module.

See the :ref:`API reference <modules_futures_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======
hashing
=======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/hashing/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_hashing:

=======
hashing
=======

The hashing module provides two hashing implementations:

* :cpp:func:`hpx::util::fibhash`
* :cpp:class:`hpx::util::jenkins_hash`

See the :ref:`API reference <modules_hashing_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
schedulers
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/schedulers/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_schedulers:

==========
schedulers
==========

This module provides schedulers used by thread pools in the
:ref:`modules_thread_pools` module. There are currently three main schedulers:

* :cpp:class:`hpx::threads::policies::local_priority_queue_scheduler`
* :cpp:class:`hpx::threads::policies::static_priority_queue_scheduler`
* :cpp:class:`hpx::threads::policies::shared_priority_queue_scheduler`

Other schedulers are specializations or variations of the above schedulers. See
the examples of the :ref:`modules_resource_partitioner` module for examples of
specifying a custom scheduler for a thread pool.

See the :ref:`API reference <modules_schedulers_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

========
concepts
========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/concepts/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_concepts:

========
concepts
========

This module provides helpers for emulating concepts. It provides the following
macros:

* :c:macro:`HPX_CONCEPT_REQUIRES`
* :c:macro:`HPX_HAS_MEMBER_XXX_TRAIT_DEF`
* :c:macro:`HPX_HAS_XXX_TRAIT_DEF`

See the :ref:`API reference <modules_concepts_api>` of the module for more details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
itt_notify
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/itt_notify/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_itt_notify:

==========
itt_notify
==========

This module provides support for profiling with |vtune|_.

See the :ref:`API reference <modules_itt_notify_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
async_cuda
============

This library is part of HPX.

Documentation can be found `here
<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/async_cuda/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async_cuda:

============
async_cuda
============

This library adds a simple API that enables the user to retrieve a future  from
a cuda stream. Typically, a user may launch one or more kernels and then get a
future from the stream that will become ready when those kernels have completed.
It is important to note that multiple kernels may be launched without fetching a
future, and multiple futures may be obtained from the helper. Please refer to
the unit tests and examples for further examples.

See the :ref:`API reference <modules_async_cuda_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
thread_pools
============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/thread_pools/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_thread_pools:

============
thread_pools
============

This module defines the thread pools and utilities used by the |hpx| runtime.
The only thread pool implementation provided by this module is
:cpp:class:`hpx::threads::detail::scheduled_thread_pool`, which is derived from
:cpp:class:`hpx::threads::detail::thread_pool_base` defined in the
:ref:`modules_threading_base` module.

See the :ref:`API reference <modules_thread_pools_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
filesystem
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/filesystem/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_filesystem:

==========
filesystem
==========

This module provides a compatibility layer for the C++17 filesystem library. If
the filesystem library is available this module will simply forward its contents
into the ``hpx::filesystem`` namespace. If the library is not available it will
fall back to Boost.Filesystem instead.

See the :ref:`API reference <modules_filesystem_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
synchronization
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/synchronization/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_synchronization:

===============
synchronization
===============

This module provides synchronization primitives which should be used rather than
the C++ standard ones in |hpx| threads:

* :cpp:class:`hpx::lcos::local::barrier`
* :cpp:class:`hpx::lcos::local::condition_variable`
* :cpp:class:`hpx::lcos::local::counting_semaphore`
* :cpp:class:`hpx::lcos::local::event`
* :cpp:class:`hpx::lcos::local::latch`
* :cpp:class:`hpx::lcos::local::mutex`
* :cpp:class:`hpx::lcos::local::no_mutex`
* :cpp:class:`hpx::lcos::local::once_flag`
* :cpp:class:`hpx::lcos::local::recursive_mutex`
* :cpp:class:`hpx::lcos::local::shared_mutex`
* :cpp:class:`hpx::lcos::local::sliding_semaphore`
* :cpp:class:`hpx::lcos::local::spinlock` (`std::mutex` compatible spinlock)
* :cpp:class:`hpx::lcos::local::spinlock_no_backoff` (`boost::mutex` compatible spinlock)
* :cpp:class:`hpx::lcos::local::spinlock_pool`

See :ref:`modules_lcos_local`, :ref:`modules_async_combinators`, and :ref:`modules_async`
for higher level synchronization facilities.

See the :ref:`API reference <modules_synchronization_api>` of this module for more
details.


..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

========
mpi_base
========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/mpi_base/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_mpi_base:

========
mpi_base
========

This module provides helper functionality for detecting MPI environments.

See the :ref:`API reference <modules_mpi_base_api>` of this module for more
details.


..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
tag_invoke
============

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/tag_invoke/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_tag_invoke:

==========
tag_invoke
==========

TODO: High-level description of the module.

See the :ref:`API reference <modules_tag_invoke_api>` of this module for more
details.

..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
async_base
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/async_base/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async_base:

==========
async_base
==========

The async_base module defines the basic functionality for spawning tasks on
thread pools. This module does not implement any functionality on its own, but
is extended by :ref:`modules_async_local` and :ref:`modules_async_distributed` with
implementations for the local and distributed cases.

See the :ref:`API reference <modules_async_base_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

========
hardware
========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/hardware/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_hardware:

========
hardware
========

The hardware module abstracts away hardware specific details of timestamps and
CPU features.

See the :ref:`API reference <modules_hardware_api>` of the module for more details.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===============
program_options
===============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/program_options/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_program_options:

===============
program_options
===============

The module program_options is a direct fork of the Boost.ProgramOptions library
(Boost V1.70.0). For more information about this library please see `here
<https://www.boost.org/doc/libs/1_70_0/doc/html/program_options.html>`__.
In order to be included as an |hpx| module, the Boost.ProgramOptions library has
been moved to the ``namespace hpx::program_options``. We have also replaced all
Boost facilities the library depends on with either the equivalent facilities
from the standard library or from |hpx|. As a result, the |hpx| program_options module
is fully interface compatible with Boost.ProgramOptions (sans the ``hpx``
namespace and the ``#include <hpx/modules/program_options.hpp>`` changes that need to be
applied to all code relying on this library).

All credit goes to Vladimir Prus, the author of the excellent Boost.ProgramOptions
library. All bugs have been introduced by us.

See the :ref:`API reference <modules_program_options_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
debugging
=========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/debugging/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_debugging:

=========
debugging
=========

This module provides helpers for demangling symbol names.

See the :ref:`API reference <modules_debugging_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============
type_support
============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/type_support/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_type_support:

============
type_support
============

This module provides helper facilities related to types.

See the :ref:`API reference <modules_type_support_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=================
async_combinators
=================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/async_combinators/docs/index.html>`__.
..
    Copyright (c) 2020 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_async_combinators:

=================
async_combinators
=================

This module contains combinators for futures. The ``when_*`` functions allow you
to turn multiple futures into a single future which is ready when all, any,
some, or each of the given futures are ready. The ``wait_*`` combinators are
equivalent to the ``when_*`` functions except that they do not return a future.

The ``split_future`` combinator takes a single future of a container (e.g.
``tuple``) and turns it into a container of futures.

See :ref:`modules_lcos_local`, :ref:`modules_synchronization`, and :ref:`modules_async`
for other synchronization facilities.

See the :ref:`API reference <modules_async_combinators_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
threading_base
==============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/thread_data/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_threading_base:

==============
threading_base
==============

This module contains the base class definition required for threads. The base
class :cpp:class:`hpx::threads::thread_data` is inherited by two specializations
for stackful and stackless threads:
:cpp:class:`hpx::threads::thread_data_stackful` and
:cpp:class:`hpx::threads::thread_data_stackless`. In addition, the module
defines the base classes for schedulers and thread pools:
:cpp:class:`hpx::threads::policies::scheduler_base` and
:cpp:class:`hpx::threads::thread_pool_base`.

See the :ref:`API reference <modules_thread_data_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
execution
=========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/execution/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_execution:

=========
execution
=========

This library implements executors and execution policies for use with parallel
algorithms and other facilities related to managing the execution of tasks.

See the :ref:`API reference <modules_execution_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

========
affinity
========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/affinity/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_affinity:

========
affinity
========

The affinity module contains helper functionality for mapping worker threads to
hardware resources.

See the :ref:`API reference <modules_affinity_api>` of the module for more
details.

..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=================
lock_registration
=================

This module is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/modules/lock_registration/docs/index.html>`__.
..
    Copyright (c) 2020-2021 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_lock_registration:

=================
lock_registration
=================

This module contains fucntionality for registering locks to detect when they are
locked and unlocked on different threads.

See the :ref:`API reference <modules_lock_registration_api>` of this module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=================
allocator_support
=================

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/allocator_support/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_allocator_support:

=================
allocator_support
=================

This module provides utilities for allocators. It contains
:cpp:class:`hpx::util::internal_allocator` which directly forwards allocation
calls to ``jemalloc``. This utility is is mainly useful on Windows.

See the :ref:`API reference <modules_allocator_support_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==============
datastructures
==============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/datastructures/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_datastructures:

==============
datastructures
==============

The datastructures module provides basic data structures (typically provided for
compatibility with older C++ standards):

* :cpp:class:`hpx::util::basic_any`
* :cpp:class:`hpx::util::optional`
* :cpp:class:`hpx::util::tuple`

See the :ref:`API reference <modules_datastructures_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
static_reinit
=============

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/static_reinit/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_static_reinit:

=============
static_reinit
=============

This module provides a simple wrapper around static variables that can be
reinitialized.

See the :ref:`API reference <modules_futures_api>` of this module for more
details.
..
    Copyright (c) 2018 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=========
assertion
=========

This library is part of HPX. It implements ``HPX_ASSERT`` and ``HPX_ASSERT_MSG``
which are useful to implement error handling for debug builds.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/assert/docs/index.html>`_.
..
    Copyright (c) 2018 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_assertion:

=========
assertion
=========

The assertion library implements the macros :c:macro:`HPX_ASSERT` and
:c:macro:`HPX_ASSERT_MSG`. Those two macros can be used to implement assertions
which are turned of during a release build.

By default, the location and function where the assert has been called from are
displayed when the assertion fires. This behavior can be modified by using
:cpp:func:`hpx::assertion::set_assertion_handler`. When HPX initializes, it uses
this function to specify a more elaborate assertion handler. If your application
needs to customize this, it needs to do so before calling
:cpp:func:`hpx::hpx_init`, :cpp:func:`hpx::hpx_main` or using the C-main
wrappers.


See the :ref:`API reference <modules_assertion_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===
functional
===

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/functional/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_functional:

==========
functional
==========

This module provides function wrappers and helpers for managing functions and
their arguments.

* :cpp:class:`hpx::util::function`
* :cpp:class:`hpx::util::function_ref`
* :cpp:class:`hpx::util::unique_function`
* :cpp:func:`hpx::util::bind`
* :cpp:func:`hpx::util::bind_back`
* :cpp:func:`hpx::util::bind_front`
* :cpp:func:`hpx::util::deferred_call`
* :cpp:func:`hpx::util::invoke`
* :cpp:func:`hpx::util::invoke_fused`
* :cpp:func:`hpx::util::mem_fn`
* :cpp:func:`hpx::util::one_shot`
* :cpp:func:`hpx::util::protect`
* :cpp:class:`hpx::util::result_of`

See the :ref:`API reference <modules_functional_api>` of the module for more
details.

..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

==========
lcos_local
==========

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/lcos_local/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_lcos_local:

==========
lcos_local
==========

This module provides the following local :term:`LCO`\ s:

* :cpp:class:`hpx::lcos::local::and_gate`
* :cpp:class:`hpx::lcos::local::channel`
* :cpp:class:`hpx::lcos::local::one_element_channel`
* :cpp:class:`hpx::lcos::local::receive_channel`
* :cpp:class:`hpx::lcos::local::send_channel`
* :cpp:class:`hpx::lcos::local::guard`
* :cpp:class:`hpx::lcos::local::guard_set`
* :cpp:func:`hpx::lcos::local::run_guarded`
* :cpp:class:`hpx::lcos::local::conditional_trigger`
* :cpp:class:`hpx::lcos::local::packaged_task`
* :cpp:class:`hpx::lcos::local::promise`
* :cpp:class:`hpx::lcos::local::receive_buffer`
* :cpp:class:`hpx::lcos::local::trigger`

See :ref:`modules_lcos_distributed` for distributed LCOs. Basic synchronization
primitives for use in |hpx| threads can be found in :ref:`modules_synchronization`.
:ref:`async_combinators` contains useful utility functions for combining
futures.

See the :ref:`API reference <modules_lcos_local_api>` of this module for more
details.


..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

======
memory
======

This library is part of HPX.

Documentation can be found `here
<https://hpx-docs.stellar-group.org/latest/html/libs/memory/docs/index.html>`__.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _modules_memory:

======
memory
======

Part of this module is a forked version of boost::intrusive_ptr from
Boost.SmartPtr.

See the :ref:`API reference <modules_memory_api>` of the module for more details.
..
    Copyright (c) 2019 The STE||AR Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

This directory contains HPX components, i.e. implementations of distributed
objects. In addition, each component is implemented in a separate library that
depends on the main HPX library.
..
    Copyright (c) 2011 Bryce Lelbach

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

This directory intentionally avoids providing a CMakeLists.txt file
because it is intended to illustrate building by command line.

The exact commands needed to build and run are in hello.sh
..
    Copyright (c) 2012-2014 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

This examples shows how to couple Qt Application with HPX.

It starts a simple Qt Dialog which starts a number of HPX threads (specified in
the GUI) and prints the execution time of each thread in the GUI.
..
    Copyright (c) 2012 Matt Anderson

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

*************
 HPX ShenEOS
*************

The Shen equation of state (EOS) tables of nuclear matter at finite temperature
and density with various electron fractions within the relativistic mean field
(RMF) theory are a set of three dimensional data arrays enabling high precision
interpolation of 19 relevant parameters required for neutron star simulations.
While these tables are currently relatively small in size (about 300 MB), it is
expected that over the next year a new set of tables ensuring higher resolution
will be published. The size of the new tables is expected to be in the range of
several GB. This will prevent loading the whole data set into main memory on
each locality. In conventional, MPI based applications the full tables would
have to be either loaded into each MPI process or a distributed partitioning
scheme would have to be implemented. Both options are either not viable or
difficult to implement.

We created an HPX component encapsulating the non-overlapping partitioning and
distribution of the Shen EOS tables to all available localities, thus reducing
the required memory footprint per locality. A special client side object
ensures the transparent dispatching of interpolation requests to the
appropriate partition corresponding to the locality holding the required part
of the tables. The client side object exposes a simple API for easy
programmability.

This code is based on the work of Christian Ott and O'Connor, authors of the
original |sheneos_tables|_. You can get the original code here:::

    svn checkout --username anon --password anon svn://stellarcollapse.org/projects/EOSdriver

Options
-------

--file : std::string : sheneos_220r_180t_50y_extT_analmu_20100322_SVNr28.h5
    The |hdf5|_ data file containing the |sheneos_tables|_.

--num-ye-points -Y : std::size_t : 20
    The number of points to interpolate on the ye axis.

--num-temp-points -T : std::size_t: 20
    The number of points to interpolate on the temp axis.

--num-rho-points -R : std::size_t : 20
    The number of points to interpolate on the rho axis.

--num-partitions : std::size_t : 32
    The number of partitions to create.

--num-workers : std::size_t : 1
    The number of worker/measurement threads to create per locality.

--seed : std::size_t : 0
    The seed for the pseudo random number generator (if 0, a seed is chosen
    based on the current system time).

Input File Format
-----------------

The input file must be a set of |sheneos_tables|_ in the |hdf5|_ (.h5) format.

Example Run
-----------

::

    sheneos_test --file my_shen_table.h5 --num-partitions 2

.. |sheneos_tables| replace:: ShenEOS tables
.. _sheneos_tables: http://stellarcollapse.org/equationofstate

.. |hdf5| replace:: HDF5
.. _hdf5: http://www.hdfgroup.org/HDF5


..
    Copyright (C) 2007-2013 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _terminology:

===========
Terminology
===========

This section gives definitions for some of the terms used throughout the
|hpx| documentation and source code.

.. glossary::

   Locality

      A locality in |hpx| describes a synchronous domain of execution, or the
      domain of bounded upper response time. This normally is just a single node
      in a cluster or a NUMA domain in a SMP machine.

   Active Global Address Space
   AGAS

      |hpx| incorporates a global address space. Any executing thread can access
      any object within the domain of the parallel application with the caveat
      that it must have appropriate access privileges. The model does not assume
      that global addresses are cache coherent; all loads and stores will deal
      directly with the site of the target object. All global addresses within a
      Synchronous Domain are assumed to be cache coherent for those processor
      cores that incorporate transparent caches. The Active Global Address Space
      used by |hpx| differs from research |pgas|_ models. Partitioned Global
      Address Space is passive in their means of address translation. Copy
      semantics, distributed compound operations, and affinity relationships are
      some of the global functionality supported by AGAS.

   Process

      The concept of the "process" in |hpx| is extended beyond that of either
      sequential execution or communicating sequential processes. While the
      notion of process suggests action (as do "function" or "subroutine") it
      has a further responsibility of context, that is, the logical container of
      program state. It is this aspect of operation that process is employed in
      |hpx|. Furthermore, referring to "parallel processes" in |hpx| designates
      the presence of parallelism within the context of a given process, as well
      as the coarse grained parallelism achieved through concurrency of multiple
      processes of an executing user job. |hpx| processes provide a hierarchical
      name space within the framework of the active global address space and
      support multiple means of internal state access from external sources.

   Parcel

      The Parcel is a component in |hpx| that communicates data, invokes an
      action at a distance, and distributes flow-control through the migration
      of continuations. Parcels bridge the gap of asynchrony between synchronous
      domains while maintaining symmetry of semantics between local and global
      execution. Parcels enable message-driven computation and may be seen as a
      form of "active messages". Other important forms of message-driven
      computation predating active messages include `dataflow tokens
      <http://en.wikipedia.org/wiki/Dataflow_architecture>`_, the `J-machine's
      <http://en.wikipedia.org/wiki/J%E2%80%93Machine>`_ support for remote
      method instantiation, and at the coarse grained variations of Unix remote
      procedure calls, among others. This enables work to be moved to the data
      as well as performing the more common action of bringing data to the work.
      A parcel can cause actions to occur remotely and asynchronously, among
      which are the creation of threads at different system nodes or synchronous
      domains.

   Local Control Object
   Lightweight Control Object
   LCO

      A local control object (sometimes called a lightweight control object) is
      a general term for the synchronization mechanisms used in |hpx|. Any
      object implementing a certain concept can be seen as an LCO. This concepts
      encapsulates the ability to be triggered by one or more events which when
      taking the object into a predefined state will cause a thread to be
      executed. This could either create a new thread or resume an existing
      thread.

      The LCO is a family of synchronization functions potentially representing
      many classes of synchronization constructs, each with many possible
      variations and multiple instances. The LCO is sufficiently general that it
      can subsume the functionality of conventional synchronization primitives
      such as spinlocks, mutexes, semaphores, and global barriers. However due
      to the rich concept an LCO can represent powerful synchronization and
      control functionality not widely employed, such as dataflow and futures
      (among others), which open up enormous opportunities for rich diversity of
      distributed control and operation.

      See :ref:`lcos` for more details on how to use LCOs in |hpx|.

   Action

      An action is a function that can be invoked remotely. In |hpx| a plain
      function can be made into an action using a macro. See
      :ref:`applying_actions` for details on how to use actions in |hpx|.

   Component

      A component is a C++ object which can be accessed remotely. A component
      can also contain member functions which can be invoked remotely. These are
      referred to as component actions. See :ref:`components` for details on how
      to use components in |hpx|.
..
    Copyright (C)      2013 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=====================
Contributing to |hpx|
=====================

|hpx| development happens on |hpx_github|. The following sections are a
collection of useful information related to |hpx| development.

.. toctree::

   contributing/contributing
   contributing/governance
   contributing/release_procedure
   contributing/testing_hpx
   contributing/docker_image
   contributing/documentation
   contributing/modules
..
    Copyright (C) 2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _citing_hpx:

============
Citing |hpx|
============

Please cite |hpx| whenever you use it for publications. Use our paper in The
Journal of Open Source Software as the main citation for |HPX|: |hpx_joss|. Use
the Zenodo entry for referring to the latest version of |hpx|: |hpx_zenodo|.
Entries for citing specific versions of |hpx| can also be found at |hpx_zenodo|.
..
    Copyright (C) 2007-2014 Hartmut Kaiser
    Copyright (C) 2011 Bryce Lelbach
    Copyright (C) 2013 Pyry Jahkola
    Copyright (C) 2013 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples:

=========
Examples
=========

The following sections analyze some examples to help you get familiar with the
|hpx| style of programming. We start off with simple examples that utilize basic
|hpx| elements and then begin to expose the reader to the more complex and
powerful |hpx| concepts.

.. toctree::
   :maxdepth: 1

   examples/fibonacci_local
   examples/matrix_multiplication
   examples/fibonacci
   examples/hello_world
   examples/accumulator
   examples/interest_calculator
   examples/1d_stencil
..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _additional_material:

===================
Additional material
===================

* 2-day workshop held at CSCS in 2016

  * `Recorded lectures <https://www.youtube.com/playlist?list=PL1tk5lGm7zvSXfS-sqOOmIJ0lFNjKze18>`_
  * `Slides <https://github.com/STEllAR-GROUP/tutorials/tree/master/cscs2016>`_
* `Tutorials repository <https://github.com/STEllAR-GROUP/tutorials>`_
* `STE||AR Group blog posts <http://stellar-group.org/blog/>`_
* Basic |hpx| recipes

  * `Exporting a free function from a shared library which lives in a namespace, to use as Action <https://gitlab.com/-/snippets/1821389>`_
  * `Turning a struct or class into a component and use it's methods <https://gitlab.com/-/snippets/1822983>`_
  * `Creating and referencing components in hpx  <https://gitlab.com/-/snippets/1828131>`_
..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _quickstart:

===========
Quick start
===========

The following steps will help you get started with |hpx|. 


Installing |hpx|
================

The easiest way to install |hpx| on your system is by choosing one of the steps below:

#. **vcpkg**

   You can download and install |hpx| using the `vcpkg <https://github.com/Microsoft/vcpkg>`_ dependency manager:

   .. code-block:: shell-session

      $ vcpkg install hpx

#. **Spack**

   Another way to install |hpx| is using `Spack <https://spack.readthedocs.io/en/latest/>`_:

   .. code-block:: shell-session

      $ spack install hpx

#. **Fedora**

   Installation can be done with `Fedora <https://fedoraproject.org/wiki/DNF>`_ as well:

   .. code-block:: shell-session

      $ dnf install hpx*

#. **Arch Linux**

   |hpx| is available in the `Arch User Repository (AUR) <https://wiki.archlinux.org/title/Arch_User_Repository>`_ as ``hpx`` too.

More information or alternatives regarding the installation can be found in the :ref:`hpx_build_system`, a detailed guide with thorough explanation of ways to build and use |hpx|.

Hello, World!
=============

To get started with this minimal example you need to create a new project directory and a file ``CMakeLists.txt`` with the contents below in order to build an executable using |cmake| and |hpx|:

.. code-block:: cmake

   cmake_minimum_required(VERSION 3.18)
   project(my_hpx_project CXX)
   find_package(HPX REQUIRED)
   add_executable(my_hpx_program main.cpp)
   target_link_libraries(my_hpx_program HPX::hpx HPX::wrap_main HPX::iostreams_component)

The next step is to create a ``main.cpp`` with the contents below:

.. literalinclude:: ../examples/quickstart/hello_world_1.cpp
   :language: c++
   :start-after: //[hello_world_1_getting_started
   :end-before: //]

Then, in your project directory run the following:

.. code-block:: shell-session

   $ mkdir build && cd build
   $ cmake -DCMAKE_PREFIX_PATH=/path/to/hpx/installation ..
   $ make all
   $ ./my_hpx_program

.. code-block:: shell-session

    $ ./my_hpx_program
    Hello World!

The program looks almost like a regular C++ hello world with the exception of
the two includes and ``hpx::cout``. 

* When you include ``hpx_main.hpp`` |hpx| makes sure that ``main`` actually gets
  launched on the |hpx| runtime. So while it looks almost the same you can now use
  futures, ``async``, parallel algorithms and more which make use of the |hpx|
  runtime with lightweight threads. 

* ``hpx::cout`` is a replacement for ``std::cout`` to make sure printing never blocks 
  a lightweight thread. You can read more about ``hpx::cout`` in :ref:`iostreams`. 

.. note::

   * You will most likely have more than one ``main.cpp`` file in your project.
     See the section on :ref:`using_hpx_cmake` for more details on how to use
     ``add_hpx_executable``.

   * ``HPX::wrap_main`` is required if you are implicitly using ``main()`` as the
     runtime entry point. See :ref:`minimal` for more information.

   * ``HPX::iostreams_component`` is optional for a minimal project but lets us
     use the |hpx| equivalent of ``std::cout``, i.e., the |hpx| :ref:`iostreams`
     functionality in our application.

   * You do not have to let |hpx| take over your main function like in the
     example. See :ref:`starting_hpx` for more details on how to initialize and run 
     the |hpx| runtime.

.. caution::

   When including ``hpx_main.hpp`` the user-defined ``main`` gets renamed and
   the real ``main`` function is defined by |hpx|. This means that the
   user-defined ``main`` must include a return statement, unlike the real
   ``main``. If you do not include the return statement, you may end up with
   confusing compile time errors mentioning ``user_main`` or even runtime
   errors.

Writing task-based applications
===============================

So far we haven't done anything that can't be done using the C++ standard
library. In this section we will give a short overview of what you can do with
|hpx| on a single node. The essence is to avoid global synchronization and break
up your application into small, composable tasks whose dependencies control the
flow of your application. Remember, however, that |hpx| allows you to write
distributed applications similarly to how you would write applications for a
single node (see :ref:`why_hpx` and
:ref:`writing_distributed_hpx_applications`).

If you are already familiar with ``async`` and ``future``\ s from the C++ standard
library, the same functionality is available in |hpx|.

The following terminology is essential when talking about task-based C++
programs:

* lightweight thread: Essential for good performance with task-based programs.
  Lightweight refers to smaller stacks and faster context switching compared to
  OS threads. Smaller overheads allow the program to be broken up into smaller
  tasks, which in turns helps the runtime fully utilize all processing units.

* ``async``: The most basic way of launching tasks asynchronously. Returns a
  ``future<T>``.

* ``future<T>``: Represents a value of type ``T`` that will be ready in the future.
  The value can be retrieved with ``get`` (blocking) and one can check if the
  value is ready with ``is_ready`` (non-blocking).

* ``shared_future<T>``: Same as ``future<T>`` but can be copied (similar to
  ``std::unique_ptr`` vs ``std::shared_ptr``).

* continuation: A function that is to be run after a previous task has run
  (represented by a future). ``then`` is a method of ``future<T>`` that takes a
  function to run next. Used to build up dataflow DAGs (directed acyclic
  graphs). ``shared_future``\ s help you split up nodes in the DAG and functions
  like ``when_all`` help you join nodes in the DAG.

The following example is a collection of the most commonly used functionality in
|hpx|:

.. literalinclude:: ../examples/quickstart/potpourri.cpp
   :language: c++
   :lines: 6-

Try copying the contents to your ``main.cpp`` file and look at the output. It can
be a good idea to go through the program step by step with a debugger. You can
also try changing the types or adding new arguments to functions to make sure
you can get the types to match. The type of the ``then`` method can be especially
tricky to get right (the continuation needs to take the future as an argument).

.. note::

   |hpx| programs accept command line arguments. The most important one is
   :option:`--hpx:threads`\ ``=N`` to set the number of OS threads used by
   |hpx|. |hpx| uses one thread per core by default. Play around with the
   example above and see what difference the number of threads makes on the
   ``sort`` function. See :ref:`launching_and_configuring` for more details on
   how and what options you can pass to |hpx|.

.. tip::

   The example above used the construction ``hpx::when_all(...).then(...)``. For
   convenience and performance it is a good idea to replace uses of
   ``hpx::when_all(...).then(...)`` with ``dataflow``. See
   :ref:`examples_interest_calculator` for more details on ``dataflow``.

.. tip::

   If possible, try to use the provided parallel algorithms instead of
   writing your own implementation. This can save you time and the resulting
   program is often faster.

Next steps
==========

If you haven't done so already, reading the :ref:`terminology` section will help
you get familiar with the terms used in |hpx|.

The :ref:`examples` section contains small, self-contained walkthroughs of
example |hpx| programs. The :ref:`examples_1d_stencil` example is a thorough,
realistic example starting from a single node implementation and going stepwise
to a distributed implementation.

The :ref:`manual` contains detailed information on writing, building and running
|hpx| applications.
..
    Copyright (C) 2007-2013 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _why_hpx:

==========
Why |hpx|?
==========

Current advances in high performance computing (HPC) continue to suffer from the
issues plaguing parallel computation. These issues include, but are not limited
to, ease of programming, inability to handle dynamically changing workloads,
scalability, and efficient utilization of system resources. Emerging
technological trends such as multi-core processors further highlight limitations
of existing parallel computation models. To mitigate the aforementioned
problems, it is necessary to rethink the approach to parallelization models.
ParalleX contains mechanisms such as multi-threading, :term:`parcels <parcel>`,
:term:`global name space <AGAS>` support, percolation and :term:`local control
object`\ s (:term:`LCO`). By design, ParalleX overcomes limitations of current
models of parallelism by alleviating contention, latency, overhead and
starvation. With ParalleX, it is further possible to increase performance by at
least an order of magnitude on challenging parallel algorithms, e.g., dynamic
directed graph algorithms and adaptive mesh refinement methods for astrophysics.
An additional benefit of ParalleX is fine-grained control of power usage,
enabling reductions in power consumption.

ParalleX---a new execution model for future architectures
---------------------------------------------------------

ParalleX is a new parallel execution model that offers an alternative to
the conventional computation models, such as message passing. ParalleX
distinguishes itself by:

* Split-phase transaction model
* Message-driven
* Distributed shared memory (not cache coherent)
* Multi-threaded
* Futures synchronization
* :term:`Local Control Object`\ s (:term:`LCO`\ s)
* Synchronization for anonymous producer-consumer scenarios
* Percolation (pre-staging of task data)

The ParalleX model is intrinsically latency hiding, delivering an abundance of
variable-grained parallelism within a hierarchical namespace environment. The
goal of this innovative strategy is to enable future systems delivering very
high efficiency, increased scalability and ease of programming. ParalleX can
contribute to significant improvements in the design of all levels of computing
systems and their usage from application algorithms and their programming
languages to system architecture and hardware design together with their
supporting compilers and operating system software.

What is |hpx|?
--------------

High Performance ParalleX (|hpx|) is the first runtime system implementation of
the ParalleX execution model. The |hpx| runtime software package is a modular,
feature-complete, and performance-oriented representation of the ParalleX
execution model targeted at conventional parallel computing architectures, such
as SMP nodes and commodity clusters. It is academically developed and freely
available under an open source license. We provide |hpx| to the community for
experimentation and application to achieve high efficiency and scalability for
dynamic adaptive and irregular computational problems. |hpx| is a C++ library
that supports a set of critical mechanisms for dynamic adaptive resource
management and lightweight task scheduling within the context of a global
address space. It is solidly based on many years of experience in writing highly
parallel applications for HPC systems.

The two-decade success of the communicating sequential processes (CSP) execution
model and its message passing interface (MPI) programming model have been
seriously eroded by challenges of power, processor core complexity, multi-core
sockets, and heterogeneous structures of GPUs. Both efficiency and scalability
for some current (strong scaled) applications and future Exascale applications
demand new techniques to expose new sources of algorithm parallelism and exploit
unused resources through adaptive use of runtime information.

The ParalleX execution model replaces CSP to provide a new computing paradigm
embodying the governing principles for organizing and conducting highly
efficient scalable computations greatly exceeding the capabilities of today's
problems. |hpx| is the first practical, reliable, and performance-oriented
runtime system incorporating the principal concepts of the ParalleX model
publicly provided in open source release form.

|hpx| is designed by the |stellar|_ Group (**S**\ ystems **T**\ echnology,
**E**\ mergent Para\ **ll**\ elism, and **A**\ lgorithm **R**\ esearch) at
|lsu|_'s |cct|_ to enable developers to exploit the full processing power of
many-core systems with an unprecedented degree of parallelism. |stellar|_ is a
research group focusing on system software solutions and scientific application
development for hybrid and many-core hardware architectures.

For more information about the |stellar|_ Group, see :ref:`people`.

What makes our systems slow?
----------------------------

Estimates say that we currently run our computers at well below 100% efficiency.
The theoretical peak performance (usually measured in
`FLOPS <http://en.wikipedia.org/wiki/FLOPS>`_---floating point operations per
second) is much higher than any practical peak performance reached by any
application. This is particularly true for highly parallel hardware. The more
hardware parallelism we provide to an application, the better the application
must scale in order to efficiently use all the resources of the machine. Roughly
speaking, we distinguish two forms of scalability: strong scaling (see
`Amdahl's Law <http://en.wikipedia.org/wiki/Amdahl%27s_law>`_) and weak scaling
(see `Gustafson's Law <http://en.wikipedia.org/wiki/Gustafson%27s_law>`_). Strong
scaling is defined as how the solution time varies with the number of processors
for a fixed **total** problem size. It gives an estimate of how much faster we
can solve a particular problem by throwing more resources at it. Weak scaling is
defined as how the solution time varies with the number of processors for a
fixed problem size **per processor**. In other words, it defines how much more
data can we process by using more hardware resources.

In order to utilize as much hardware parallelism as possible an application must
exhibit excellent strong and weak scaling characteristics, which requires a high
percentage of work executed in parallel, i.e., using multiple threads of
execution. Optimally, if you execute an application on a hardware resource with
N processors it either runs N times faster or it can handle N times more data.
Both cases imply 100% of the work is executed on all available processors in
parallel. However, this is just a theoretical limit. Unfortunately, there are
more things that limit scalability, mostly inherent to the hardware
architectures and the programming models we use. We break these limitations into
four fundamental factors that make our systems *SLOW*:

* **S**\ tarvation occurs when there is insufficient concurrent work available to
  maintain high utilization of all resources.
* **L**\ atencies are imposed by the time-distance delay intrinsic to accessing
  remote resources and services.
* **O**\ verhead is work required for the management of parallel actions and
  resources on the critical execution path, which is not necessary in a
  sequential variant.
* **W**\ aiting for contention resolution is the delay due to the lack of
  availability of oversubscribed shared resources.

Each of those four factors manifests itself in multiple and different ways; each
of the hardware architectures and programming models expose specific forms.
However, the interesting part is that all of them are limiting the scalability of
applications no matter what part of the hardware jungle we look at. Hand-helds,
PCs, supercomputers, or the cloud, all suffer from the reign of the 4 horsemen:
**S**\ tarvation, **L**\ atency, **O**\ verhead, and **C**\ ontention. This
realization is very important as it allows us to derive the criteria for
solutions to the scalability problem from first principles, and it allows us to
focus our analysis on very concrete patterns and measurable metrics. Moreover,
any derived results will be applicable to a wide variety of targets.

Technology demands new response
-------------------------------

Today's computer systems are designed based on the initial ideas of
`John von Neumann <http://qss.stanford.edu/~godfrey/vonNeumann/vnedvac.pdf>`_, as
published back in 1945, and later extended by the
`Harvard architecture <http://en.wikipedia.org/wiki/Harvard_architecture>`_. These
ideas form the foundation, the execution model, of computer systems we use
currently. However, a new response is required in the light of the demands
created by today's technology.

So, what are the overarching objectives for designing systems allowing for
applications to scale as they should? In our opinion, the main objectives are:

* Performance: as previously mentioned, scalability and efficiency are the main criteria
  people are interested in.
* Fault tolerance: the low expected mean time between failures (`MTBF
  <http://en.wikipedia.org/wiki/Mean_time_between_failures>`_) of future systems
  requires embracing faults, not trying to avoid them.
* Power: minimizing energy consumption is a must as it is one of the major cost
  factors today, and will continue to rise in the future.
* Generality: any system should be usable for a broad set of use cases.
* Programmability: for programmer this is a very important objective,
  ensuring long term platform stability and portability.

What needs to be done to meet those objectives, to make applications scale
better on tomorrow's architectures? Well, the answer is almost obvious: we need
to devise a new execution model---a set of governing principles for the holistic
design of future systems---targeted at minimizing the effect of the outlined
**SLOW** factors. Everything we create for future systems, every design decision
we make, every criteria we apply, have to be validated against this single,
uniform metric. This includes changes in the hardware architecture we
prevalently use today, and it certainly involves new ways of writing software,
starting from the operating system, runtime system, compilers, and at the
application level. However, the key point is that all those layers have to be
co-designed; they are interdependent and cannot be seen as separate facets. The
systems we have today have been evolving for over 50 years now. All layers
function in a certain way, relying on the other layers to do so. But we do not
have the time to wait another 50 years for a new coherent system to evolve.
The new paradigms are needed now---therefore, co-design is the key.

Governing principles applied while developing |hpx|
---------------------------------------------------

As it turn out, we do not have to start from scratch. Not everything has to be
invented and designed anew. Many of the ideas needed to combat the 4 horsemen
already exist, many for more than 30 years. All it takes is to gather
them into a coherent approach. We'll highlight some of the derived principles we
think to be crucial for defeating **SLOW**. Some of those are focused on
high-performance computing, others are more general.

Focus on latency hiding instead of latency avoidance
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is impossible to design a system exposing zero latencies. In an effort to
come as close as possible to this goal many optimizations are mainly targeted
towards minimizing latencies. Examples for this can be seen everywhere, such as
low latency network technologies like `InfiniBand
<http://en.wikipedia.org/wiki/InfiniBand>`_, caching memory hierarchies in all
modern processors, the constant optimization of existing |mpi|_ implementations
to reduce related latencies, or the data transfer latencies intrinsic to the way
we use `GPGPUs <http://en.wikipedia.org/wiki/GPGPU>`_ today. It is important to
note that existing latencies are often tightly related to some resource having
to wait for the operation to be completed. At the same time it would be
perfectly fine to do some other, unrelated work in the meantime, allowing the
system to hide the latencies by filling the idle-time with useful work. Modern
systems already employ similar techniques (pipelined instruction execution in
the processor cores, asynchronous input/output operations, and many more). What
we propose is to go beyond anything we know today and to make latency hiding an
intrinsic concept of the operation of the whole system stack.

Embrace fine-grained parallelism instead of heavyweight threads
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If we plan to hide latencies even for very short operations, such as fetching
the contents of a memory cell from main memory (if it is not already cached), we
need to have very lightweight threads with extremely short context switching
times, optimally executable within one cycle. Granted, for mainstream
architectures, this is not possible today (even if we already have special
machines supporting this mode of operation, such as the `Cray XMT
<http://en.wikipedia.org/wiki/Cray_XMT>`_). For conventional systems, however,
the smaller the overhead of a context switch and the finer the granularity of
the threading system, the better will be the overall system utilization and its
efficiency. For today's architectures we already see a flurry of libraries
providing exactly this type of functionality: non-pre-emptive, task-queue based
parallelization solutions, such as |tbb|_, |ppl|_, |cilk_pp|_, and many others.
The possibility to suspend a current task if some preconditions for its
execution are not met (such as waiting for I/O or the result of a different
task), seamlessly switching to any other task which can continue, and to
reschedule the initial task after the required result has been calculated, which
makes the implementation of latency hiding almost trivial.

Rediscover constraint-based synchronization to replace global barriers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The code we write today is riddled with implicit (and explicit) global barriers.
By "global barriers," we mean the synchronization of the control flow between
several (very often all) threads (when using |openmp|_) or processes (|mpi|_).
For instance, an implicit global barrier is inserted after each loop
parallelized using |openmp|_ as the system synchronizes the threads used to
execute the different iterations in parallel. In |mpi|_ each of the
communication steps imposes an explicit barrier onto the execution flow as
(often all) nodes have to be synchronized. Each of those barriers is like the eye
of a needle the overall execution is forced to be squeezed through. Even
minimal fluctuations in the execution times of the parallel threads (jobs)
causes them to wait. Additionally, it is often only one of the executing threads 
that performs the actual reduce operation, which further impedes parallelism. A closer
analysis of a couple of key algorithms used in science applications reveals that
these global barriers are not always necessary. In many cases it is sufficient
to synchronize a small subset of the threads. Any operation should proceed
whenever the preconditions for its execution are met, and only those. Usually
there is no need to wait for iterations of a loop to finish before you can
continue calculating other things; all you need is to complete the iterations
that produce the required results for the next operation. Good
bye global barriers, hello constraint based synchronization! People have been
trying to build this type of computing (and even computers) since the 1970s.
The theory behind what they did is based on ideas around static and
dynamic dataflow. There are certain attempts today to get back to those ideas
and to incorporate them with modern architectures. For instance, a lot of work
is being done in the area of constructing dataflow-oriented execution trees. Our
results show that employing dataflow techniques in combination with the other
ideas, as outlined herein, considerably improves scalability for many problems.

Adaptive locality control instead of static data distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While this principle seems to be a given for single desktop or laptop computers
(the operating system is your friend), it is everything but ubiquitous on modern
supercomputers, which are usually built from a large number of separate nodes
(i.e., Beowulf clusters), tightly interconnected by a high-bandwidth, low-latency
network. Today's prevalent programming model for those is MPI, which does not
directly help with proper data distribution, leaving it to the programmer to
decompose the data to all of the nodes the application is running on. There are
a couple of specialized languages and programming environments based on |pgas|_
(Partitioned Global Address Space) designed to overcome this limitation, such as
|chapel|_, |x10|_, |upc|_, or |fortress|_. However, all systems based on PGAS
rely on static data distribution. This works fine as long as this static data
distribution does not result in heterogeneous workload distributions or other
resource utilization imbalances. In a distributed system these imbalances can be
mitigated by migrating part of the application data to different localities
(nodes). The only framework supporting (limited) migration today is |charm_pp|_.
The first attempts towards solving related problem go back decades as well, a
good example is the `Linda coordination language
<http://en.wikipedia.org/wiki/Linda_(coordination_language)>`_. Nevertheless,
none of the other mentioned systems support data migration today, which forces
the users to either rely on static data distribution and live with the related
performance hits or to implement everything themselves, which is very tedious
and difficult. We believe that the only viable way to flexibly support dynamic
and adaptive :term:`locality` control is to provide a global, uniform address
space to the applications, even on distributed systems.

Prefer moving work to the data over moving data to the work
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the best performance it seems obvious to minimize the amount of bytes
transferred from one part of the system to another. This is true on all levels.
At the lowest level we try to take advantage of processor memory caches, thus,
minimizing memory latencies. Similarly, we try to amortize the data transfer
time to and from `GPGPUs <http://en.wikipedia.org/wiki/GPGPU>`_ as much as
possible. At high levels we try to minimize data transfer between different
nodes of a cluster or between different virtual machines on the cloud. Our
experience (well, it's almost common wisdom) shows that the amount of bytes
necessary to encode a certain operation is very often much smaller than the
amount of bytes encoding the data the operation is performed upon. Nevertheless,
we still often transfer the data to a particular place where we execute the
operation just to bring the data back to where it came from afterwards. As an
example let's look at the way we usually write our applications for clusters
using MPI. This programming model is all about data transfer between nodes.
MPI is the prevalent programming model for clusters, and it is fairly
straightforward to understand and to use. Therefore, we often write 
applications in a way that accommodates this model, centered around data transfer.
These applications usually work well for smaller problem sizes and for regular
data structures. The larger the amount of data we have to churn and the more
irregular the problem domain becomes, the worse the overall machine
utilization and the (strong) scaling characteristics become. While it is not impossible
to implement more dynamic, data driven, and asynchronous applications using
MPI, it is somewhat difficult to do so. At the same time, if we look at
applications that prefer to execute the code close to the :term:`locality` where the
data was placed, i.e., utilizing active messages (for instance based on
|charm_pp|_), we see better asynchrony, simpler application codes, and improved
scaling.

Favor message driven computation over message passing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Today's prevalently used programming model on parallel (multi-node) systems is
MPI. It is based on message passing, as the name implies, which means that
the receiver has to be aware of a message about to come in. Both codes, the
sender and the receiver, have to synchronize in order to perform the
communication step. Even the newer, asynchronous interfaces require explicitly
coding the algorithms around the required communication scheme. As a result, everything
but the most trivial MPI applications spends a considerable amount of time
waiting for incoming messages, thus, causing starvation and latencies to impede
full resource utilization. The more complex and more dynamic the data structures
and algorithms become, the larger the adverse effects. The community discovered
message-driven and data-driven methods of implementing algorithms a long
time ago, and systems such as |charm_pp|_ have already integrated active
messages demonstrating the validity of the concept. Message-driven computation
allows for sending messages without requiring the receiver to actively wait for
them. Any incoming message is handled asynchronously and triggers the encoded
action by passing along arguments and---possibly---continuations. |hpx| combines
this scheme with work-queue based scheduling as described above, which allows
the system to almost completely overlap any communication with useful work,
thereby minimizing latencies.
..
    Copyright (C) 2018-2021 STE||AR Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _releases:

========
Releases
========

.. toctree::
   :maxdepth: 1

   releases/whats_new_1_7_1
   releases/whats_new_1_7_0
   releases/whats_new_1_6_0
   releases/whats_new_1_5_1
   releases/whats_new_1_5_0
   releases/whats_new_1_4_1
   releases/whats_new_1_4_0
   releases/whats_new_1_3_0
   releases/whats_new_1_2_1
   releases/whats_new_1_2_0
   releases/whats_new_1_1_0
   releases/whats_new_1_0_0
   releases/whats_new_0_9_99
   releases/whats_new_0_9_11
   releases/whats_new_0_9_10
   releases/whats_new_0_9_9
   releases/whats_new_0_9_8
   releases/whats_new_0_9_7
   releases/whats_new_0_9_6
   releases/whats_new_0_9_5
   releases/whats_new_0_9_0
   releases/whats_new_0_8_1
   releases/whats_new_0_8_0
   releases/whats_new_0_7_0
..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _about_hpx:

===========
About |hpx|
===========

.. toctree::
   :maxdepth: 2

   about_hpx/history
   about_hpx/people
..
    Copyright (C) 2007-2015 Hartmut Kaiser
    Copyright (C) 2016-2018 Adrian Serio

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===================================
Welcome to the |hpx| documentation!
===================================

If you're new to |hpx| you can get started with the :ref:`quickstart` guide.
Don't forget to read the :ref:`terminology` section to learn about the most
important concepts in |hpx|. The :ref:`examples` give you a feel for how it is
to write real |hpx| applications and the :ref:`manual` contains detailed
information about everything from building |hpx| to debugging it. There are
links to blog posts and videos about |hpx| in :ref:`additional_material`.

If you can't find what you're looking for in the documentation, please:

* open an issue on `GitHub <hpx_github_issues_>`_;
* contact us on `IRC <stellar_irc_>`_, the HPX channel on the `C++ Slack
  <cpplang_slack_>`_, or on our `mailing list <stellar_list_>`_; or
* read or ask questions tagged with |hpx| on `StackOverflow
  <hpx_stackoverflow_>`_.

See :ref:`citing_hpx` for details on how to cite |hpx| in publications. See
:ref:`hpx_users` for a list of institutions and projects using |hpx|.

What is |hpx|?
==============

|hpx| is a C++ Standard Library for Concurrency and Parallelism. It implements
all of the corresponding facilities as defined by the C++ Standard.
Additionally, in |hpx| we implement functionalities proposed as part of the
ongoing C++ standardization process. We also extend the C++ Standard APIs to the
distributed case. |hpx| is developed by the |stellar| group (see :ref:`people`).

The goal of |hpx| is to create a high quality, freely available, open source
implementation of a new programming model for conventional systems, such as
classic Linux based Beowulf clusters or multi-socket highly parallel SMP nodes.
At the same time, we want to have a very modular and well designed runtime
system architecture which would allow us to port our implementation onto new
computer system architectures. We want to use real-world applications to drive
the development of the runtime system, coining out required functionalities and
converging onto a stable API which will provide a smooth migration path for
developers.

The API exposed by |hpx| is not only modeled after the interfaces defined by the
C++11/14/17/20 ISO standard. It also adheres to the programming guidelines used
by the Boost collection of C++ libraries. We aim to improve the scalability of
today's applications and to expose new levels of parallelism which are necessary
to take advantage of the exascale systems of the future.

What's so special about |hpx|?
==============================

* HPX exposes a uniform, standards-oriented API for ease of programming parallel
  and distributed applications.
* It enables programmers to write fully asynchronous code using hundreds of
  millions of threads.
* HPX provides unified syntax and semantics for local and remote operations.
* HPX makes concurrency manageable with dataflow and future based
  synchronization.
* It implements a rich set of runtime services supporting a broad range of use
  cases.
* HPX exposes a uniform, flexible, and extendable performance counter framework
  which can enable runtime adaptivity
* It is designed to solve problems conventionally considered to be
  scaling-impaired.
* HPX has been designed and developed for systems of any scale, from
  hand-held devices to very large scale systems.
* It is the first fully functional implementation of the ParalleX execution
  model.
* HPX is published under a liberal open-source license and has an open, active,
  and thriving developer community.

.. toctree::
   :caption: User documentation
   :maxdepth: 2

   quickstart
   examples
   manual
   terminology
   why_hpx
   additional_material

.. include:: libs/index.rst

.. toctree::
   :caption: Reference
   :maxdepth: 2

   api

.. toctree::
   :caption: Developer documentation
   :maxdepth: 2

   contributing

.. toctree::
   :caption: Other
   :maxdepth: 2

   releases
   citing
   users
   about_hpx


Index
=====

* :ref:`genindex`

..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _manual:

======
Manual
======

The manual is your comprehensive guide to |hpx|. It contains detailed
information on how to build and use |hpx| in different scenarios.

.. toctree::
   :maxdepth: 2

   manual/building_hpx
   manual/creating_hpx_projects
   manual/starting_the_hpx_runtime
   manual/launching_and_configuring_hpx_applications
   manual/writing_single_node_hpx_applications
   manual/writing_distributed_hpx_applications
   manual/running_on_batch_systems
   manual/debugging_hpx_applications
   manual/optimizing_hpx_applications
   manual/hpx_runtime_and_resources
   manual/miscellaneous
   manual/troubleshooting
..
    Copyright (C) 2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_users:

===========
|hpx| users
===========

A list of institutions and projects using |hpx| can be found on the
|stellar_hpx_users|_ page.
..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
API reference
=============

|hpx| follows a versioning scheme with three numbers: ``major.minor.patch``. We
guarantee no breaking changes in the API for patch releases. Minor releases may
remove or break existing APIs, but only after a deprecation period of at least
two minor releases. In rare cases do we outright remove old and unused
functionality without a deprecation period.

We do not provide any ABI compatibility guarantees between any versions, debug
and release builds, and builds with different C++ standards.

..
   We follow |semver|_ for our API (starting from |hpx| 2.0.0). This means that
   patch releases never change the public API, neither with additions nor
   removals. Minor releases may add new functionality to the public API. Major
   releases may both remove and add functionality to the public API.

   We define the public API as any functionality in the ``hpx`` namespace,
   excluding any ``detail`` or ``experimental`` namespace within the ``hpx``
   namespace. We reserve the right to change any functionality in the ``detail``
   and ``experimental`` namespaces even in patch releases. However, any
   functionality in ``experimental`` is intended for eventual inclusion in the
   public API, and we avoid excessively breaking APIs in the ``experimental``
   namespace. In addition to the above, any macros starting with ``HPX_`` are
   part of the public API.

   We do not provide any ABI compatibility guarantees between any versions,
   debug and release builds, and builds with different C++ standards.

   Our build system provides compatibility guarantees only for |cmake| support.
   Any other build system support may change even in patch releases. The public
   API in terms of our build system are the ``HPX::`` targets provided by
   ``find_package(HPX)``.

The public API of |hpx| is presented below. Clicking on a name brings you to the
full documentation for the class or function. Including the header specified in
a heading brings in the features listed under that heading.

.. note::

   Names listed here are guaranteed stable with respect to semantic versioning.
   However, at the moment the list is incomplete and certain unlisted features
   are intended to be in the public API. While we work on completing the list,
   if you're unsure about whether a particular unlisted name is part of the
   public API you can get into contact with us or open an issue and we'll
   clarify the situation.

.. toctree::
   :maxdepth: 1

   api/public_api.rst

Full API
========

The full API of |hpx| is presented below. The listings for the public API above
refer to the full documentation below.

.. note::

   Most names listed in the full API reference are implementation details or
   considered unstable. They are listed mostly for completeness. If there is a
   particular feature you think deserves being in the public API we may consider
   promoting it. In general we prioritize making sure features corresponding to
   C++ standard library features are stable and complete.

.. toctree::
   :maxdepth: 1

   api/full_api.rst
{}
..
    Copyright (C) 2007-2013 Hartmut Kaiser
    Copyright (c) 2016 Adrian Serio

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _history:

=======
History
=======

The development of High Performance ParalleX (|hpx|) began in 2007. At that
time, Hartmut Kaiser became interested in the work done by the ParalleX group at
the |cct|_, a multi-disciplinary research institute at |lsu|_. The ParalleX
group was working to develop a new and experimental execution model for future
high performance computing architectures. This model was christened ParalleX.
The first implementations of ParalleX were crude, and many of those designs had
to be discarded entirely. However, over time the team learned quite a bit about
how to design a parallel, distributed runtime system which implements the
concepts of ParalleX.

From the very beginning, this endeavour has been a group effort. In addition to
a handful of interested researchers, there have always been graduate and
undergraduate students participating in the discussions, design, and
implementation of |hpx|. In 2011 we decided to formalize our collective research
efforts by creating the |stellar|_ group (**S**\ ystems **T**\ echnology, **E**\
mergent Para\ **ll**\ elism, and **A**\ lgorithm **R**\ esearch). Over time, the
team grew to include researchers around the country and the world. In 2014, the
|stellar|_ Group was reorganized to become the international community it is
today. This consortium of researchers aims to develop stable, sustainable, and
scalable tools which will enable application developers to exploit the
parallelism latent in the machines of today and tomorrow. Our goal of the |hpx|
project is to create a high quality, freely available, open source
implementation of ParalleX concepts for conventional and future systems by
building a modular and standards conforming runtime system for SMP and
distributed application environments. The API exposed by |hpx| is conformant to
the interfaces defined by the C++ ISO Standard and adheres to the programming
guidelines used by the |boost|_ collection of C++ libraries. We steer the
development of |hpx| with real world applications and aim to provide a smooth
migration path for domain scientists.

To learn more about |stellar|_ and ParalleX, see :ref:`people` and :ref:`why_hpx`.
..
    Copyright (C) 2007-2015 Hartmut Kaiser
    Copyright (C) 2016-2018 Adrian Serio

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _people:

======
People
======

The |stellar|_ Group (pronounced as stellar) stands for "\ **S**\ ystems \
**T**\ echnology, \ **E**\ mergent Para\ **ll**\ elism, and \ **A**\ lgorithm \
**R**\ esearch". We are an international group of faculty, researchers, and
students working at various institutions around the world. The goal of the
|stellar|_ Group is to promote the development of scalable parallel applications
by providing a community for ideas, a framework for collaboration, and a
platform for communicating these concepts to the broader community.

Our work is focused on building technologies for scalable parallel applications.
|hpx|, our general purpose C++ runtime system for parallel and distributed
applications, is no exception. We use |hpx| for a broad range of scientific
applications, helping scientists and developers to write code which scales
better and shows better performance compared to more conventional programming
models such as MPI.

|hpx| is based on *ParalleX* which is a new (and still experimental) parallel
execution model aiming to overcome the limitations imposed by the current
hardware and the techniques we use to write applications today. Our group
focuses on two types of applications - those requiring excellent strong scaling,
allowing for a dramatic reduction of execution time for fixed workloads and
those needing highest level of sustained performance through massive
parallelism. These applications are presently unable (through conventional
practices) to effectively exploit a relatively small number of cores in a
multi-core system. By extension, these application will not be able to exploit
high-end exascale computing systems which are likely to employ hundreds of
millions of such cores by the end of this decade.

Critical bottlenecks to the effective use of new generation high performance
computing (HPC) systems include:

* *Starvation*: due to lack of usable application parallelism and means of
  managing it,
* *Overhead*: reduction to permit strong scalability, improve efficiency, and
  enable dynamic resource management,
* *Latency*: from remote access across system or to local memories,
* *Contention*: due to multicore chip I/O pins, memory banks, and system
  interconnects.

The ParalleX model has been devised to address these challenges by enabling a
new computing dynamic through the application of message-driven computation in a
global address space context with lightweight synchronization. The work on |hpx|
is centered around implementing the concepts as defined by the ParalleX model.
|hpx| is currently targeted at conventional machines, such as classical Linux
based Beowulf clusters and SMP nodes.

We fully understand that the success of |hpx| (and ParalleX) is very much the
result of the work of many people. To see a list of who is contributing see our
tables below.

|hpx| contributors
==================

.. table:: Contributors

   ======================= ================ =====
   Name                    Institution      Email
   ======================= ================ =====
   Hartmut Kaiser          |cct|_, |lsu|_   |email_hkaiser|
   Thomas Heller           |inf3|_, |fau|_  |email_theller|
   Agustin Berge           |cct|_, |lsu|_   |email_aberge|
   Mikael Simberg          |cscs|_          |email_msimberg|
   John Biddiscombe        |cscs|_          |email_jbiddiscombe|
   Anton Bikineev          |cct|_, |lsu|_   |email_abikineev|
   Martin Stumpf           |inf3|_, |fau|_  |email_mstumpf|
   Bryce Adelstein Lelbach |nvidia|_        |email_blelbach|
   Shuangyang Yang         |cct|_, |lsu|_   |email_syang|
   Jeroen Habraken         |tue|_           |email_jhabraken|
   Steven Brandt           |cct|_, |lsu|_   |email_sbrandt|
   Antoine Tran Tan        |cct|_, |lsu|_   |email_atrantan|
   Adrian Serio            |cct|_, |lsu|_   |email_aserio|
   Maciej Brodowicz        |crest|_, |iu|_  |email_mbrodowicz|
   ======================= ================ =====

Contributors to this document
=============================

.. table:: Documentation authors

  ======================= ================ =====
  Name                    Institution      Email
  ======================= ================ =====
  Hartmut Kaiser          |cct|_, |lsu|_   |email_hkaiser|
  Thomas Heller           |inf3|_, |fau|_  |email_theller|
  Bryce Adelstein Lelbach |nvidia|_        |email_blelbach|
  Vinay C Amatya          |cct|_, |lsu|_   |email_vamatya|
  Steven Brandt           |cct|_, |lsu|_   |email_sbrandt|
  Maciej Brodowicz        |crest|_, |iu|_  |email_mbrodowicz|
  Adrian Serio            |cct|_, |lsu|_   |email_aserio|
  ======================= ================ =====

Acknowledgements
================

Thanks also to the following people who contributed directly or indirectly to
the project through discussions, pull requests, documentation patches, etc.

* Srinivas Yadav, for his work on SIMD support in algorithms before and during
  Google Summer of Code 2021.
* Akhil Nair, for his work on adapting algorithms to C++20 before and during
  Google Summer of Code 2021.
* Alexander Toktarev, for updating the parallel algorithm customization points
  to use ``tag_fallback_invoke`` for the default implementations.
* Brice Goglin, for reporting and helping fix issues related to the integration
  of hwloc in |hpx|.
* Giannis Gonidelis, for his work on the ranges adaptation during the
  Google Summer of Code 2020.
* Auriane Reverdell (|cscs|_), for her tireless work on refactoring our CMake
  setup and modularizing |hpx|.
* Christopher Hinz, for his work on refactoring our CMake setup.
* Weile Wei, for fixing |hpx| builds with CUDA on Summit.
* Severin Strobl, for fixing our CMake setup related to linking and adding new
  entry points to the |hpx| runtime.
* Rebecca Stobaugh, for her major documentation review and contributions
  during and after the 2019 Google Season of Documentation.
* Jan Melech, for adding automatic serialization of simple structs.
* Austin McCartney, for adding concept emulation of the Ranges TS bidirectional
  and random access iterator concepts.
* Marco Diers, reporting and fixing issues related PMIx.
* Maximilian Bremer, for reporting multiple issues and extending the component
  migration tests.
* Piotr Mikolajczyk, for his improvements and fixes to the set and count
  algorithms.
* Grant Rostig, for reporting several deficiencies on our web pages.
* Jakub Golinowski, for implementing an |hpx| backend for OpenCV and in the
  process improving documentation and reporting issues.
* Mikael Simberg (|cscs|_), for his tireless help cleaning up and maintaining
  |hpx|.
* Tianyi Zhang, for his work on HPXMP.
* Shahrzad Shirzad, for her contributions related to Phylanx.
* Christopher Ogle, for his contributions to the parallel algorithms.
* Surya Priy, for his work with statistic performance counters.
* Anushi Maheshwari, for her work on random number generation.
* Bruno Pitrus, for his work with parallel algorithms.
* Nikunj Gupta, for rewriting the implementation of ``hpx_main.hpp`` and for his
  fixes for tests.
* Christopher Taylor, for his interest in |hpx| and the fixes he provided.
* Shoshana Jakobovits, for her work on the resource partitioner.
* Denis Blank, who re-wrote our unwrapped function to accept plain values
  arbitrary containers, and properly deal with nested futures.
* Ajai V. George, who implemented several of the parallel algorithms.
* Taeguk Kwon, who worked on implementing parallel algorithms as well as
  adapting the parallel algorithms to the Ranges TS.
* Zach Byerly (|lsu|_), who in his work developing applications on top of |hpx|
  opened tickets and contributed to the |hpx| examples.
* Daniel Estermann, for his work porting |hpx| to the Raspberry Pi.
* Alireza Kheirkhahan (|lsu|_), who built and administered our local cluster as
  well as his work in distributed IO.
* Abhimanyu Rawat, who worked on stack overflow detection.
* David Pfander, who improved signal handling in |hpx|, provided his
  optimization expertise, and worked on incorporating the Vc vectorization into
  |hpx|.
* Denis Demidov, who contributed his insights with VexCL.
* Khalid Hasanov, who contributed changes which allowed to run |hpx| on 64Bit
  power-pc architectures.
* Zahra Khatami (|lsu|_), who contributed the prefetching iterators and the
  persistent auto chunking executor parameters implementation.
* Marcin Copik, who worked on implementing GPU support for C++AMP and HCC. He
  also worked on implementing a HCC backend for |hpx_compute|.
* Minh-Khanh Do, who contributed the implementation of several segmented
  algorithms.
* Bibek Wagle (|lsu|_), who worked on fixing and analyzing the performance of
  the :term:`parcel` coalescing plugin in |hpx|.
* Lukas Troska, who reported several problems and contributed various test cases
  allowing to reproduce the corresponding issues.
* Andreas Schaefer, who worked on integrating his library (|lgd|_) with |hpx|.
  He reported various problems and submitted several patches to fix issues
  allowing for a better integration with |lgd|_.
* Satyaki Upadhyay, who contributed several examples to |hpx|.
* Brandon Cordes, who contributed several improvements to the inspect tool.
* Harris Brakmic, who contributed an extensive build system description for
  building |hpx| with Visual Studio.
* Parsa Amini (|lsu|_), who refactored and simplified the implementation of
  :term:`AGAS` in |hpx| and who works on its implementation and optimization.
* Luis Martinez de Bartolome who implemented a build system extension for |hpx|
  integrating it with the |conan|_ C/C++ package manager.
* Vinay C Amatya (|lsu|_), who contributed to the documentation and provided
  some of the |hpx| examples.
* Kevin Huck and Nick Chaimov (|ou|_), who contributed the integration of APEX
  (Autonomic Performance Environment for eXascale) with |hpx|.
* Francisco Jose Tapia, who helped with implementing the parallel sort algorithm
  for |hpx|.
* Patrick Diehl, who worked on implementing CUDA support for our companion
  library targeting GPGPUs (|hpxcl|_).
* Eric Lemanissier contributed fixes to allow compilation using the MingW
  toolchain.
* Nidhi Makhijani who helped cleaning up some enum consistencies in |hpx| and
  contributed to the resource manager used in the thread scheduling subsystem.
  She also worked on |hpx| in the context of the Google Summer of Code 2015.
* Larry Xiao, Devang Bacharwar, Marcin Copik, and Konstantin Kronfeldner who
  worked on |hpx| in the context of the Google Summer of Code program 2015.
* Daniel Bourgeois (|cct|_) who contributed to |hpx| the implementation of
  several parallel algorithms (as proposed by |cpp11_n4107|_).
* Anuj Sharma and Christopher Bross (|inf3|_), who worked on |hpx| in the
  context of the |gsoc|_ program 2014.
* Martin Stumpf (|inf3|_), who rebuilt our contiguous testing infrastructure
  (see the |hpx_buildbot|_). Martin is also working on |hpxcl|_ (mainly all work
  related to |opencl|_) and implementing an |hpx| backend for |pocl|_, a
  portable computing language solution based on |opencl|_.
* Grant Mercer (|unlv|_), who helped creating many of the parallel algorithms
  (as proposed by |cpp11_n4107|_).
* Damond Howard (|lsu|_), who works on |hpxcl|_ (mainly all work related to
  |cuda|_).
* Christoph Junghans (Los Alamos National Lab), who helped making our
  buildsystem more portable.
* Antoine Tran Tan (Laboratoire de Recherche en Informatique, Paris), who worked
  on integrating |hpx| as a backend for |nt2|_. He also contributed an
  implementation of an API similar to Fortran co-arrays on top of |hpx|.
* John Biddiscombe (|cscs|_), who helped with the BlueGene/Q port of |hpx|,
  implemented the parallel sort algorithm, and made several other contributions.
* Erik Schnetter (Perimeter Institute for Theoretical Physics), who greatly
  helped to make |hpx| more robust by submitting a large amount of problem
  reports, feature requests, and made several direct contributions.
* Mathias Gaunard (Metascale), who contributed several patches to reduce compile
  time warnings generated while compiling |hpx|.
* Andreas Buhr, who helped with improving our documentation, especially by
  suggesting some fixes for inconsistencies.
* Patricia Grubel (|nmsu|_), who contributed the description of the different
  |hpx| thread scheduler policies and is working on the performance analysis of
  our thread scheduling subsystem.
* Lars Viklund, whose wit, passion for testing, and love of odd architectures
  has been an amazing contribution to our team. He has also contributed platform
  specific patches for FreeBSD and MSVC12.
* Agustin Berge, who contributed patches fixing some very nasty hidden template
  meta-programming issues. He rewrote large parts of the API elements ensuring
  strict conformance with the C++ ISO Standard.
* Anton Bikineev for contributing changes to make using ``boost::lexical_cast``
  safer, he also contributed a thread safety fix to the iostreams module. He
  also contributed a complete rewrite of the serialization infrastructure
  replacing Boost.Serialization inside |hpx|.
* Pyry Jahkola, who contributed the Mac OS build system and build documentation
  on how to build |hpx| using Clang and libc++.
* Mario Mulansky, who created an |hpx| backend for his Boost.Odeint library, and
  who submitted several test cases allowing us to reproduce and fix problems in
  |hpx|.
* Rekha Raj, who contributed changes to the description of the Windows build
  instructions.
* Jeremy Kemp how worked on an |hpx| OpenMP backend and added regression tests.
* Alex Nagelberg for his work on implementing a C wrapper API for |hpx|.
* Chen Guo, helvihartmann, Nicholas Pezolano, and John West who added and
  improved examples in |hpx|.
* Joseph Kleinhenz, Markus Elfring, Kirill Kropivyansky, Alexander Neundorf,
  Bryant Lam, and Alex Hirsch who improved our CMake.
* Tapasweni Pathak, Praveen Velliengiri, Jean-Loup Tastet, Michael Levine, Aalekh Nigam,
  HadrienG2, Prayag Verma, lslada, Alex Myczko, and Avyav Kumar
  who improved the documentation.
* Jayesh Badwaik, J. F. Bastien, Christoph Garth, Christopher Hinz, Brandon
  Kohn, Mario Lang, Maikel Nadolski, pierrele, hendrx, Dekken, woodmeister123,
  xaguilar, Andrew Kemp, Dylan Stark, Matthew Anderson, Jeremy Wilke, Jiazheng
  Yuan, CyberDrudge, david8dixon, Maxwell Reeser, Raffaele Solca, Marco
  Ippolito, Jules Penuchot, Weile Wei, Severin Strobl, Kor de Jong, albestro,
  Jeff Trull, Yuri Victorovich, and Gregor Daiß who contributed to the general
  improvement of |hpx|.

|stellar_hpx_funding|_ lists current and past funding sources for |hpx|.
..
    Copyright (C) 2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _contributing:

=====================
Contributing to |hpx|
=====================

The main source of information to understand the process of how to contribute
to HPX can be found in
`this document <https://github.com/STEllAR-GROUP/hpx/blob/master/.github/CONTRIBUTING.md>`_.
This is a living document that is constantly updated with relevant information.


..
    Copyright (C) 2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _governance:

======================
|hpx| governance model
======================

The |hpx| project is a meritocratic, consensus-based community project. Anyone
with an interest in the project can join the community, contribute to the
project design and participate in the decision making process.
`This document <http://hpx.stellar-group.org/documents/governance/>`_ describes
how that participation takes place and how to set about earning merit within
the project community.

..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _using_docker:

============================
Using docker for development
============================

Although it can often be useful to set up a local development environment with
system-provided or self-built dependencies, |docker|_ provides a convenient
alternative to quickly get all the dependencies needed to start development of
|hpx|. Our testing setup on |circleci|_ uses a docker image to run all tests.

To get started you need to install |docker|_ using whatever means is most
convenient on your system. Once you have |docker|_ installed, you can pull or
directly run the docker image. The image is based on Debian and Clang, and can
be found on |docker_build_env|_. To start a container using the |hpx| build
environment, run:

.. code-block:: shell-session

   $ docker run --interactive --tty stellargroup/build_env:latest bash

You are now in an environment where all the |hpx| build and runtime dependencies
are present. You can install additional packages according to your own needs.
Please see the |docker_docs|_ for more information on using |docker|_.

.. warning::

   All changes made within the container are lost when the container is closed.
   If you want files to persist (e.g., the |hpx| source tree) after closing the
   container, you can bind directories from the host system into the container
   (see |docker_docs_bind_mounts|_).

..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _documentation:

=============
Documentation
=============

This documentation is built using |sphinx|_, and an automatically generated API
reference using |doxygen|_ and |breathe|_.

We always welcome suggestions on how to improve our documentation, as well as
pull requests with corrections and additions.

Prerequisites
=============

To build the |hpx| documentation, you need recent versions of the following
packages:

- ``python3``
- ``sphinx 3.5.4`` (Python package)
- ``sphinx_rtd_theme`` (Python package)
- ``breathe 4.16.0`` (Python package)
- ``doxygen``

If the |python|_ dependencies are not available through your system package
manager, you can install them using the Python package manager ``pip``:

.. code-block:: bash

   pip install --user sphinx sphinx_rtd_theme breathe

You may need to set the following CMake variables to make sure CMake can
find the required dependencies.

.. option:: DOXYGEN_ROOT:PATH

   Specifies where to look for the installation of the |doxygen|_ tool.

.. option:: SPHINX_ROOT:PATH

   Specifies where to look for the installation of the |sphinx|_ tool.

.. option:: BREATHE_APIDOC_ROOT:PATH

   Specifies where to look for the installation of the |breathe|_ tool.


Building documentation
======================

Enable building of the documentation by setting ``HPX_WITH_DOCUMENTATION=ON``
during |cmake|_ configuration. To build the documentation, build the ``docs``
target using your build tool. The default output format is HTML documentation.
You can choose alternative output formats (single-page HTML, PDF, and man) with
the ``HPX_WITH_DOCUMENTATION_OUTPUT_FORMATS`` CMake option.

.. note::

   If you add new source files to the Sphinx documentation, you have to run
   CMake again to have the files included in the build.


Style guide
===========

The documentation is written using reStructuredText. These are the conventions
used for formatting the documentation:

* Use, at most, 80 characters per line.
* Top-level headings use over- and underlines with ``=``.
* Sub-headings use only underlines with characters in decreasing level of
  importance: ``=``, ``-`` and ``.``.
* Use sentence case in headings.
* Refer to common terminology using ``:term:`Component```.
* Indent content of directives (``.. directive::``) by three spaces.
* For C++ code samples at the end of paragraphs, use ``::`` and indent the code
  sample by 4 spaces.

  * For other languages (or if you don't want a colon at the end of the
    paragraph), use ``.. code-block:: language`` and indent by three spaces as
    with other directives.
* Use ``.. list-table::`` to wrap tables with a lot of text in cells.

API documentation
=================

The source code is documented using Doxygen. If you add new API documentation
either to existing or new source files, make sure that you add the documented
source files to the ``doxygen_dependencies`` variable in
``docs/CMakeLists.txt``.
..
    Copyright (C)      2013 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
Testing |hpx|
=============

To ensure correctness of |hpx|, we ship a large variety of unit and regression
tests. The tests are driven by the |ctest|_ tool and are executed automatically 
on each commit to the |hpx| |hpx_github|_ repository. In addition, it is encouraged 
to run the test suite manually to ensure proper operation on your target system. 
If a test fails for your platform, we highly recommend submitting an issue on our 
|hpx_github_issues|_ tracker with detailed information about the target system.

Running tests manually
======================

Running the tests manually is as easy as typing ``make tests && make test``.
This will build all tests and run them once the tests are built successfully.
After the tests have been built, you can invoke separate tests with the help of
the ``ctest`` command. You can list all available test targets using ``make help
| grep tests``. Please see the |ctest_doc|_ for further details.

Running performance tests
=========================

We run performance tests on Piz Daint for each pull request using Jenkins. To
run those performance tests locally or on Piz Daint, a script is provided under
``tools/perftests_ci/local_run.sh`` (to be run in the build directory specifying
the |hpx| source directory as the argument to the script, default is
``$HOME/projects/hpx_perftests_ci``.

Adding new performance tests
============================

To add a new performance test, you need to wrap the portion of code to benchmark
with ``hpx::util::perftests_report``, passing the test name, the executor name
and the function to time (can be a lambda). This facility is used to output the
time results in a json format (format needed to compare the results and plot
them).  To effectively print them at the end of your test, call
``hpx::util::perftests_print_times``. To see an example of use, see
``future_overhead_report.cpp``.  Finally, you can add the test to the CI report
editing the ``hpx_targets`` variable for the executable name and the
``hpx_test_options`` variable for the corresponding options to use for the run
in the performance test script ``.jenkins/cscs-perftests/launch_perftests.sh``.
And then run the ``tools/perftests_ci/local_run.sh`` script to get a reference
json run (use the name of the test) to be added in the
``tools/perftests_ci/perftest/references/daint_default`` directory.

Issue tracker
=============

If you stumble over a bug or missing feature in |hpx|, please
submit an issue to our |hpx_github_issues|_ page. For more information on how to
submit support requests or other means of getting in contact with the developers,
please see the |support|_ page.

Continuous testing
==================

In addition to manual testing, we run automated tests on various platforms. We also 
run tests on all pull requests using both |circleci|_ and a combination of |cdash|_ 
and |pycicle|_. You can see the dashboards here: |hpx_circleci|_ and |hpx_cdash|_ .
..
    Copyright (c)      2021 ETH Zurich
    Copyright (c) 2007-2017 Louisiana State University

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========================
Release procedure for |hpx|
===========================

Below is a step by step procedure for making an |hpx| release. We aim to produce two
releases per year: one in March-April, and one in September-October.

This is a living document and may not be totally current or accurate. It is an
attempt to capture current practices in making an |hpx| release. Please update it
as appropriate.

One way to use this procedure is to print a copy and check off the lines as they
are completed to avoid confusion.

#. Notify developers that a release is imminent.

#. For minor and major releases: create and check out a new branch at an
   appropriate point on ``master`` with the name ``release-major.minor.X``.
   ``major`` and ``minor`` should be the major and minor versions of the
   release. For patch releases: check out the corresponding
   ``release-major.minor.X`` branch.

#. Write release notes in ``docs/sphinx/releases/whats_new_$VERSION.rst``. Keep
   adding merged PRs and closed issues to this until just before the release is
   made. Use ``tools/generate_pr_issue_list.sh`` to generate the lists. Add the
   new release notes to the table of contents in ``docs/sphinx/releases.rst``.

#. Build the docs, and proof-read them. Update any documentation that may have
   changed, and correct any typos. Pay special attention to:

   * ``$HPX_SOURCE/README.rst``

     * Update grant information

   * ``docs/sphinx/releases/whats_new_$VERSION.rst``
   * ``docs/sphinx/about_hpx/people.rst``

     *   Update collaborators
     *   Update grant information

#. This step does not apply to patch releases. For both APEX and libCDS:

   * Change the release branch to be the most current release tag available in
     the APEX/libCDS ``git_external`` section in the main ``CMakeLists.txt``.
     Please contact the maintainers of the respective packages to generate a new
     release to synchronize with the |hpx| release (`APEX
     <http://github.com/UO-OACISS/xpress-apex>`_, `libCDS
     <https://github.com/STEllAR-GROUP/libcds>`_).

#. Make sure ``HPX_VERSION_MAJOR/MINOR/SUBMINOR`` in ``CMakeLists.txt`` contain
   the correct values. Change them if needed.

#. This step does not apply to patch releases. Remove features which have been
   deprecated for at least 2 releases. This involves removing build options
   which enable those features from the main CMakeLists.txt and also deleting
   all related code and tests from the main source tree.

   The general deprecation policy involves a three-step process we have to go
   through in order to introduce a breaking change:

   a. First release cycle: add a build option that allows for explicitly disabling
      any old (now deprecated) code.
   b. Second release cycle: turn this build option OFF by default.
   c. Third release cycle: completely remove the old code.

   The main CMakeLists.txt contains a comment indicating for which version
   the breaking change was introduced first.
   In the case of deprecated features which don't have a replacement yet, we
   keep them around in case (like Vc for example).

#. Update the minimum required versions if necessary (compilers, dependencies,
   etc.) in ``building_hpx.rst``.

#. Verify that the Jenkins setups for the release branch on Rostam and Piz Daint
   are running and do not display any errors.

#. Repeat the following steps until satisfied with the release.

   #. Change ``HPX_VERSION_TAG`` in ``CMakeLists.txt`` to ``-rcN``, where ``N``
      is the current iteration of this step. Start with ``-rc1``.

   #. Create a pre-release on GitHub using the script ``tools/roll_release.sh``.
      This script automatically tag with the corresponding release number.
      The script requires that you have the |stellar| Group signing key.

   #. This step is not necessary for patch releases. Notify
      ``hpx-users@stellar-group.org`` and ``stellar@cct.lsu.edu`` of the
      availability of the release candidate. Ask users to test the candidate by
      checking out the release candidate tag.

   #. Allow at least a week for testing of the release candidate.

      * Use ``git merge`` when possible, and fall back to ``git cherry-pick``
        when needed. For patch releases ``git cherry-pick`` is most likely your
        only choice if there have been significant unrelated changes on master
        since the previous release.
      * Go back to the first step when enough patches have been added.
      * If there are no more patches, continue to make the final release.

#. Update any occurrences of the latest stable release to refer to the version
   about to be released. For example, ``quickstart.rst`` contains instructions
   to check out the latest stable tag. Make sure that refers to the new version.

#. Add a new entry to the RPM changelog (``cmake/packaging/rpm/Changelog.txt``)
   with the new version number and a link to the corresponding changelog.

#. Change ``HPX_VERSION_TAG`` in ``CMakeLists.txt`` to an empty string.

#. Add the release date to the caption of the current "What's New" section in
   the docs, and change the value of ``HPX_VERSION_DATE`` in
   ``CMakeLists.txt``.

#. Create a release on GitHub using the script ``tools/roll_release.sh``. This
   script automatically tag the with the corresponding release number. The
   script requires that you have the |stellar| Group signing key.

#. Update the websites (`hpx.stellar-group.org <https://hpx.stellar-group.org>`_,
   `stellar-group.org <https://stellar-group.org>`_ and
   `stellar.cct.lsu.edu <https://stellar.cct.lsu.edu>`_). You can login on
   wordpress through `this page <https://hpx.stellar-group.org/wp-login.php>`.
   You can update the pages with the following:

   * Update links on the downloads page. Link to the release on GitHub.
   * Documentation links on the docs page (link to generated documentation on
     GitHub Pages). Follow the style of previous releases.
   * A new blog post announcing the release, which links to downloads and the
     "What's New" section in the documentation (see previous releases for
     examples).

#. Merge release branch into master.

#. Post-release cleanup. Create a new pull request against master with the
   following changes:

   #. Modify the release procedure if necessary.

   #. Change ``HPX_VERSION_TAG`` in ``CMakeLists.txt`` back to ``-trunk``.

   #. Increment ``HPX_VERSION_MINOR`` in ``CMakeLists.txt``.

#. Update Vcpkg (``https://github.com/Microsoft/vcpkg``) to pull from latest
   release.

   * Update version number in CONTROL
   * Update tag and SHA512 to that of the new release

#. Update spack (``https://github.com/spack/spack``) with the latest HPX package.

   * Update version number in ``hpx/package.py`` and SHA256 to that of the new
     release

#. Announce the release on hpx-users@stellar-group.org, stellar@cct.lsu.edu,
   allcct@cct.lsu.edu, faculty@csc.lsu.edu, faculty@ece.lsu.edu,
   xpress@crest.iu.edu, the |hpx| Slack channel, the IRC channel, Sonia Sachs,
   our list of external collaborators, isocpp.org, reddit.com, HPC Wire, Inside
   HPC, Heise Online, and a CCT press release.

#. Beer and pizza.
..
    Copyright (c) 2019 The STE||AR-Group

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _module_structure:

================
Module structure
================

This section explains the structure of an |hpx| module.

The tool `create_library_skeleton.py
<https://github.com/STEllAR-GROUP/hpx/blob/master/libs/create_library_skeleton.py>`_
can be used to generate a basic skeleton. To create a library skeleton, run the
tool in the ``libs`` subdirectory with the module name as an argument:

.. code-block:: shell-session

    $ ./create_library_skeleton <lib_name>

This creates a skeleton with the necessary files for an |hpx| module. It will not create any actual source files. The structure of this skeleton is as follows:

* ``<lib_name>/``

  * ``README.rst``
  * ``CMakeLists.txt``
  * ``cmake``
  * ``docs/``

    * ``index.rst``

  * ``examples/``

    * ``CMakeLists.txt``

  * ``include/``

    * ``hpx/``

      * ``<lib_name>``

  * ``src/``

    * ``CMakeLists.txt``

  * ``tests/``

    * ``CMakeLists.txt``
    * ``unit/``

      * ``CMakeLists.txt``

    * ``regressions/``

      * ``CMakeLists.txt``

    * ``performance/``

      * ``CMakeLists.txt``

A ``README.rst`` should be always included which explains the basic purpose of
the library and a link to the generated documentation.

A main ``CMakeLists.txt`` is created in the root directory of the module. By
default it contains a call to ``add_hpx_module`` which takes care of most of the
boilerplate required for a module. You only need to fill in the source and
header files in most cases.

``add_hpx_module`` requires a module name. Optional flags are:

Optional single-value arguments are:

* ``INSTALL_BINARIES``: Install the resulting library.

Optional multi-value arguments-are:

* ``SOURCES``: List of source files.
* ``HEADERS``: List of header files.
* ``COMPAT_HEADERS``: List of compatibility header files.
* ``DEPENDENCIES``: Libraries that this module depends on, such as other modules.
* ``CMAKE_SUBDIRS``: List of subdirectories to add to the module.

The ``include`` directory should contain only headers that other libraries need.
For each of those headers, an automatic header test to check for self
containment will be generated. Private headers should be placed under the
``src`` directory. This allows for clear separation. The ``cmake`` subdirectory
may include additional |cmake|_ scripts needed to generate the respective build
configurations.

Compatibility headers (forwarding headers for headers whose location is changed
when creating a module, if moving them from the main library) should be placed
in an ``include_compatibility`` directory. This directory is not created by
default.

Documentation is placed in the ``docs`` folder. A empty skeleton for the index
is created, which is picked up by the main build system and will be part of the
generated documentation. Each header inside the ``include`` directory will
automatically be processed by Doxygen and included into the documentation. If a
header should be excluded from the API reference, a comment ``//
sphinx:undocumented`` needs to be added.

Tests are placed in suitable subdirectories of ``tests``.

When in doubt, consult existing modules for examples on how to structure the
module.

Finding circular dependencies
=============================

Our CI will perform a check to see if there are circular dependencies between
modules. In cases where it's not clear what is causing the circular dependency,
running the |cppdependencies|_ tool manually can be helpful. It can give you
detailed information on exactly which files are causing the circular dependency.
If you do not have the ``cpp-dependencies`` tool already installed, one way of
obtaining it is by using our docker image. This way you will have exactly the
same environment as on the CI. See :ref:`using_docker` for details on how to use
the docker image.

To produce the graph produced by CI run the following command (``HPX_SOURCE`` is
assumed to hold the path to the |hpx| source directory):

.. code-block:: shell-session

   $ cpp-dependencies --dir $HPX_SOURCE/libs --graph-cycles circular_dependencies.dot

This will produce a ``dot`` file in the current directory. You can inspect this
manually with a text editor. You can also convert this to an image if you have
``graphviz`` installed:

.. code-block:: shell-session

   $ dot circular_dependencies.dot -Tsvg -o circular_dependencies.svg

This produces an ``svg`` file in the current directory which shows the circular
dependencies. Note that if there are no cycles the image will be empty.

You can use ``cpp-dependencies`` to print the include paths between two modules.

.. code-block:: shell-session

   $ cpp-dependencies --dir $HPX_SOURCE/libs --shortest <from> <to>

prints all possible paths from the module ``<from>`` to the module ``<to>``. For
example, as most modules depend on ``config``, the following should give you a
long list of paths from ``algorithms`` to ``config``:

.. code-block:: shell-session

   $ cpp-dependencies --dir $HPX_SOURCE/libs --shortest algorithms config

The following should report that it can't find a path between the two modules:

.. code-block:: shell-session

   $ cpp-dependencies --dir $HPX_SOURCE/libs --shortest config algorithms
..
    Copyright (C) 2007-2017 Hartmut Kaiser
                  2014 University of Oregon

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============================
Optimizing |hpx| applications
=============================

.. _performance_counters:

Performance counters
====================

Performance counters in |hpx| are used to provide information as to how well the
runtime system or an application is performing. The counter data can help
determine system bottlenecks, and fine-tune system and application performance.
The |hpx| runtime system, its networking, and other layers provide counter data
that an application can consume to provide users with information about how
well the application is performing.

Applications can also use counter data to determine how much system resources to
consume. For example, an application that transfers data over the network could
consume counter data from a network switch to determine how much data to
transfer without competing for network bandwidth with other network traffic. The
application could use the counter data to adjust its transfer rate as the
bandwidth usage from other network traffic increases or decreases.

Performance counters are |hpx| parallel processes that expose a predefined
interface. |hpx| exposes special API functions that allow one to create, manage,
and read the counter data, and release instances of performance counters.
Performance Counter instances are accessed by name, and these names have a
predefined structure which is described in the section
:ref:`performance_counter_names`. The advantage of this is that any Performance
Counter can be accessed remotely (from a different :term:`locality`) or locally
(from the same :term:`locality`). Moreover, since all counters expose their data
using the same API, any code consuming counter data can be utilized to access
arbitrary system information with minimal effort.

Counter data may be accessed in real time. More information about how to consume
counter data can be found in the section :ref:`consuming`.

All |hpx| applications provide command line options related to performance
counters, such as the ability to list available counter types, or periodically
query specific counters to be printed to the screen or save them in a file. For
more information, please refer to the section :ref:`commandline`.

.. _performance_counter_names:

Performance counter names
-------------------------

All Performance Counter instances have a name uniquely identifying each
instance. This name can be used to access the counter, retrieve all related meta
data, and to query the counter data (as described in the section
:ref:`consuming`). Counter names are strings with a predefined structure. The
general form of a countername is:

.. code-block:: text

   /objectname{full_instancename}/countername@parameters

where ``full_instancename`` could be either another (full) counter name or a
string formatted as:

.. code-block:: text

   parentinstancename#parentindex/instancename#instanceindex

Each separate part of a countername (e.g., ``objectname``, ``countername``
``parentinstancename``, ``instancename``, and ``parameters``) should start with
a letter (``'a'``\ ...\ ``'z'``, ``'A'``\ ...\ ``'Z'``) or an underscore
character (``'_'``), optionally followed by letters, digits (``'0'``\ ...\
``'9'``), hyphen (``'-'``), or underscore characters. Whitespace is not allowed
inside a counter name. The characters ``'/'``, ``'{'``, ``'}'``, ``'#'`` and
``'@'`` have a special meaning and are used to delimit the different parts of
the counter name.

The parts ``parentinstanceindex`` and ``instanceindex`` are integers. If an
index is not specified, |hpx| will assume a default of ``-1``.

.. _example:

Two counter name examples
-------------------------

This section gives examples of both simple counter names and aggregate
counter names. For more information on simple and aggregate counter
names, please see :ref:`performance_counter_instances`.

An example of a well-formed (and meaningful) simple counter name would be:

.. code-block:: text

   /threads{locality#0/total}/count/cumulative

This counter returns the current cumulative number of executed (retired)
|hpx| threads for the :term:`locality` ``0``. The counter type of this counter
is ``/threads/count/cumulative`` and the full instance name is
``locality#0/total``. This counter type does not require an ``instanceindex`` or
``parameters`` to be specified.

In this case, the ``parentindex`` (the ``'0'``) designates the :term:`locality`
for which the counter instance is created. The counter will return the number of
|hpx| threads retired on that particular :term:`locality`.

Another example for a well formed (aggregate) counter name is:

.. code-block:: text

   /statistics{/threads{locality#0/total}/count/cumulative}/average@500

This counter takes the simple counter from the first example, samples its values
every ``500`` milliseconds, and returns the average of the value samples
whenever it is queried. The counter type of this counter is
``/statistics/average`` and the instance name is the full name of the counter
for which the values have to be averaged. In this case, the ``parameters`` (the
``'500'``) specify the sampling interval for the averaging to take place (in
milliseconds).

.. _types:

Performance counter types
-------------------------

Every performance counter belongs to a specific performance counter type which
classifies the counters into groups of common semantics. The type of a counter
is identified by the ``objectname`` and the ``countername`` parts of the name.

.. code-block:: text

   /objectname/countername

When an application starts |hpx| will register all available counter types on each of
the localities. These counter types are held in a special performance counter
registration database, which can be used to retrieve the meta data related
to a counter type and to create counter instances based on a given counter
instance name.

.. _performance_counter_instances:

Performance counter instances
-----------------------------

The ``full_instancename`` distinguishes different counter instances of the same
counter type. The formatting of the ``full_instancename`` depends on the counter
type. There are two types of counters: simple counters, which usually generate
the counter values based on direct measurements, and aggregate counters, which
take another counter and transform its values before generating their own
counter values. An example for a simple counter is given :ref:`above <example>`:
counting retired |hpx| threads. An aggregate counter is shown as an example
:ref:`above <example>` as well: calculating the average of the underlying
counter values sampled at constant time intervals.

While simple counters use instance names formatted as
``parentinstancename#parentindex/instancename#instanceindex``, most aggregate
counters have the full counter name of the embedded counter as their instance
name.

Not all simple counter types require specifying all four elements of a full counter
instance name; some of the parts (``parentinstancename``, ``parentindex``,
``instancename``, and ``instanceindex``) are optional for specific counters.
Please refer to the documentation of a particular counter for more information
about the formatting requirements for the name of this counter (see
:ref:`counters`).

The ``parameters`` are used to pass additional information to a counter at
creation time. They are optional, and they fully depend on the concrete counter.
Even if a specific counter type allows additional parameters to be given, those
usually are not required as sensible defaults will be chosen. Please refer to
the documentation of a particular counter for more information about what
parameters are supported, how to specify them, and what default values are
assumed (see also :ref:`counters`).

Every :term:`locality` of an application exposes its own set of performance
counter types and performance counter instances. The set of exposed counters is
determined dynamically at application start based on the execution environment
of the application. For instance, this set is influenced by the current hardware
environment for the :term:`locality` (such as whether the :term:`locality` has
access to accelerators), and the software environment of the application (such
as the number of OS threads used to execute |hpx| threads).

.. _wildcards:

Using wildcards in performance counter names
--------------------------------------------

It is possible to use wildcard characters when specifying performance counter
names. Performance counter names can contain two types of wildcard characters:

* Wildcard characters in the performance counter type
* Wildcard characters in the performance counter instance name

A wildcard character has a meaning which is very close to usual file name
wildcard matching rules implemented by common shells (like bash).

.. list-table:: Wildcard characters in the performance counter type

   * * Wildcard
     * Description
   * * ``*``
     * This wildcard character matches any number (zero or more) of arbitrary
       characters.
   * * ``?``
     * This wildcard character matches any single arbitrary character.
   * * ``[...]``
     * This wildcard character matches any single character from the list of
       specified within the square brackets.

.. list-table:: Wildcard characters in the performance counter instance name

   * * Wildcard
     * Description
   * * ``*``
     * This wildcard character matches any :term:`locality` or any thread,
       depending on whether it is used for ``locality#*`` or
       ``worker-thread#*``. No other wildcards are allowed in counter instance
       names.

.. _consuming:

Consuming performance counter data
----------------------------------

You can consume performance data using either the command line interface,
the |hpx| application or the |hpx| API. The command line interface is easier to
use, but it is less flexible and does not allow one to adjust the behaviour of
your application at runtime. The command line interface provides a convenience
abstraction but simplified abstraction for querying and logging performance
counter data for a set of performance counters.

.. _performance_counters_commandline:

Consuming performance counter data from the command line
--------------------------------------------------------

|hpx| provides a set of predefined command line options for every application
that uses ``hpx::init`` for its initialization. While there are many more
command line options available (see :ref:`commandline`), the set of options related
to performance counters allows one to list existing counters, and query existing
counters once at application termination or repeatedly after a constant time
interval.

The following table summarizes the available command line options:

.. list-table:: |hpx| Command Line Options Related to Performance Counters

   * * Command line option
     * Description
   * * ``--hpx:print-counter``
     * Prints the specified performance counter either repeatedly and/or at the
       times specified by ``--hpx:print-counter-at`` (see also option
       ``--hpx:print-counter-interval``).
   * * ``--hpx:print-counter-reset``
     * Prints the specified performance counter either repeatedly and/or at the
       times specified by ``--hpx:print-counter-at``. Reset the counter after the
       value is queried (see also option ``--hpx:print-counter-interval``).
   * * ``--hpx:print-counter-interval``
     * Prints the performance counter(s) specified with ``--hpx:print-counter``
       repeatedly after the time interval (specified in milliseconds)
       (default:``0`` which means print once at shutdown).
   * * ``--hpx:print-counter-destination``
     * Prints the performance counter(s) specified with ``--hpx:print-counter``
       to the given file (default: console).
   * * ``--hpx:list-counters``
     * Lists the names of all registered performance counters.
   * * ``--hpx:list-counter-infos``
     * Lists the description of all registered performance counters.
   * * ``--hpx:print-counter-format``
     * Prints the performance counter(s) specified with ``--hpx:print-counter``.
       Possible formats in CVS format with header or without any header (see
       option ``--hpx:no-csv-header``), possible values: ``csv`` (prints counter
       values in CSV format with full names as header) ``csv-short`` (prints
       counter values in CSV format with shortnames provided with
       ``--hpx:print-counter`` as ``--hpx:print-counter
       shortname,full-countername``).
   * * ``--hpx:no-csv-header``
     * Prints the performance counter(s) specified with ``--hpx:print-counter``
       and ``csv`` or ``csv-short`` format specified with
       ``--hpx:print-counter-format`` without header.
   * * ``--hpx:print-counter-at arg``
     * Prints the performance counter(s) specified with ``--hpx:print-counter``
       (or ``--hpx:print-counter-reset``) at the given point in time. Possible
       argument values: ``startup``, ``shutdown`` (default), ``noshutdown``.
   * * ``--hpx:reset-counters``
     * Resets all performance counter(s) specified with ``--hpx:print-counter``
       after they have been evaluated.
   * * ``--hpx:print-counter-types``
     * Appends counter type description to generated output.
   * * ``--hpx:print-counters-locally``
     * Each locality prints only its own local counters.

While the options ``--hpx:list-counters`` and ``--hpx:list-counter-infos`` give
a short list of all available counters, the full documentation for those can
be found in the section :ref:`counters`.

A simple example
----------------

All of the commandline options mentioned above can be tested using
the ``hello_world_distributed`` example.

Listing all available counters ``hello_world_distributed --hpx:list-counters``
yields:

.. code-block:: text

   List of available counter instances (replace * below with the appropriate
   sequence number)
   -------------------------------------------------------------------------
   /agas/count/allocate /agas/count/bind /agas/count/bind_gid
   /agas/count/bind_name ... /threads{locality#*/allocator#*}/count/objects
   /threads{locality#*/total}/count/stack-recycles
   /threads{locality#*/total}/idle-rate
   /threads{locality#*/worker-thread#*}/idle-rate

Providing more information about all available counters,
``hello_world_distributed --hpx:list-counter-infos`` yields:

.. code-block:: text

   Information about available counter instances (replace * below with the
   appropriate sequence number)
   ------------------------------------------------------------------------------
   fullname: /agas/count/allocate helptext: returns the number of invocations of
   the AGAS service 'allocate' type: counter_raw version: 1.0.0
   ------------------------------------------------------------------------------

   ------------------------------------------------------------------------------
   fullname: /agas/count/bind helptext: returns the number of invocations of the
   AGAS service 'bind' type: counter_raw version: 1.0.0
   ------------------------------------------------------------------------------

   ------------------------------------------------------------------------------
   fullname: /agas/count/bind_gid helptext: returns the number of invocations of
   the AGAS service 'bind_gid' type: counter_raw version: 1.0.0
   ------------------------------------------------------------------------------

   ...

This command will not only list the counter names but also a short description
of the data exposed by this counter.

.. note::

   The list of available counters may differ depending on the concrete execution
   environment (hardware or software) of your application.

Requesting the counter data for one or more performance counters can be achieved
by invoking ``hello_world_distributed`` with a list of counter names:

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:print-counter=/threads{locality#0/total}/count/cumulative \
       --hpx:print-counter=/agas{locality#0/total}/count/bind

which yields for instance:

.. code-block:: bash

   hello world from OS-thread 0 on locality 0
   /threads{locality#0/total}/count/cumulative,1,0.212527,[s],33
   /agas{locality#0/total}/count/bind,1,0.212790,[s],11

The first line is the normal output generated by ``hello_world_distributed`` and
has no relation to the counter data listed. The last two lines contain the
counter data as gathered at application shutdown. These lines have six fields, the
counter name, the sequence number of the counter invocation, the time stamp at
which this information has been sampled, the unit of measure for the time stamp,
the actual counter value and an optional unit of measure for the counter value.

.. note::

   The command line option ``--hpx:print-counter-types`` will append a seventh
   field to the generated output. This field will hold an abbreviated counter
   type.

The actual counter value can be represented by a single number (for counters
returning singular values) or a list of numbers separated by ``':'`` (for
counters returning an array of values, like for instance a histogram).

.. note::

   The name of the performance counter will be enclosed in double quotes ``'"'``
   if it contains one or more commas ``','``.

Requesting to query the counter data once after a constant time interval with
this command line:

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:print-counter=/threads{locality#0/total}/count/cumulative \
       --hpx:print-counter=/agas{locality#0/total}/count/bind \
       --hpx:print-counter-interval=20

yields for instance (leaving off the actual console output of the
``hello_world_distributed`` example for brevity):

.. code-block:: text

   threads{locality#0/total}/count/cumulative,1,0.002409,[s],22
   agas{locality#0/total}/count/bind,1,0.002542,[s],9
   threads{locality#0/total}/count/cumulative,2,0.023002,[s],41
   agas{locality#0/total}/count/bind,2,0.023557,[s],10
   threads{locality#0/total}/count/cumulative,3,0.037514,[s],46
   agas{locality#0/total}/count/bind,3,0.038679,[s],10

The command ``--hpx:print-counter-destination=<file>`` will redirect all counter
data gathered to the specified file name, which avoids cluttering the console
output of your application.

The command line option ``--hpx:print-counter`` supports using a limited set of
wildcards for a (very limited) set of use cases. In particular, all occurrences
of ``#*`` as in ``locality#*`` and in ``worker-thread#*`` will be automatically
expanded to the proper set of performance counter names representing the actual
environment for the executed program. For instance, if your program is utilizing
four worker threads for the execution of |hpx| threads (see command line option
:option:`--hpx:threads`) the following command line

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:threads=4 \
       --hpx:print-counter=/threads{locality#0/worker-thread#*}/count/cumulative

will print the value of the performance counters monitoring each of the worker
threads:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0
   hello world from OS-thread 3 on locality 0
   hello world from OS-thread 2 on locality 0
   /threads{locality#0/worker-thread#0}/count/cumulative,1,0.0025214,[s],27
   /threads{locality#0/worker-thread#1}/count/cumulative,1,0.0025453,[s],33
   /threads{locality#0/worker-thread#2}/count/cumulative,1,0.0025683,[s],29
   /threads{locality#0/worker-thread#3}/count/cumulative,1,0.0025904,[s],33

The command ``--hpx:print-counter-format`` takes values ``csv`` and
``csv-short`` to generate CSV formatted counter values with a header.

With format as csv:

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:threads=2 \
       --hpx:print-counter-format csv \
       --hpx:print-counter /threads{locality#*/total}/count/cumulative \
       --hpx:print-counter /threads{locality#*/total}/count/cumulative-phases

will print the values of performance counters in CSV format with the full
countername as a header:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0
   /threads{locality#*/total}/count/cumulative,/threads{locality#*/total}/count/cumulative-phases
   39,93

With format csv-short:

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:threads 2 \
       --hpx:print-counter-format csv-short \
       --hpx:print-counter cumulative,/threads{locality#*/total}/count/cumulative \
       --hpx:print-counter phases,/threads{locality#*/total}/count/cumulative-phases

will print the values of performance counters in CSV format with the short countername
as a header:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0
   cumulative,phases
   39,93

With format csv and csv-short when used with ``--hpx:print-counter-interval``:

.. code-block:: shell-session

   $ hello_world_distributed \
       --hpx:threads 2 \
       --hpx:print-counter-format csv-short \
       --hpx:print-counter cumulative,/threads{locality#*/total}/count/cumulative \
       --hpx:print-counter phases,/threads{locality#*/total}/count/cumulative-phases \
       --hpx:print-counter-interval 5

will print the header only once repeating the performance counter value(s) repeatedly:

.. code-block:: text

   cum,phases
   25,42
   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0
   44,95

The command ``--hpx:no-csv-header`` can be used with
``--hpx:print-counter-format`` to print performance counter values in CSV format
without any header:

.. code-block:: shell-session

   $ hello_world_distributed \
   --hpx:threads 2 \
   --hpx:print-counter-format csv-short \
   --hpx:print-counter cumulative,/threads{locality#*/total}/count/cumulative \
   --hpx:print-counter phases,/threads{locality#*/total}/count/cumulative-phases \
   --hpx:no-csv-header

will print:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0
   37,91

.. _api:

Consuming performance counter data using the |hpx| API
------------------------------------------------------

|hpx| provides an API that allows users to discover performance counters and
to retrieve the current value of any existing performance counter from any application.

Discover existing performance counters
--------------------------------------

Retrieve the current value of any performance counter
-----------------------------------------------------

Performance counters are specialized |hpx| components. In order to retrieve a
counter value, the performance counter needs to be instantiated. |hpx| exposes a
client component object for this purpose::

    hpx::performance_counters::performance_counter counter(std::string const& name);

Instantiating an instance of this type will create the performance counter
identified by the given ``name``. Only the first invocation for any given counter
name will create a new instance of that counter. All following invocations for a
given counter name will reference the initially created instance. This ensures
that at any point in time there is never more than one active instance of
any of the existing performance counters.

In order to access the counter value (or to invoke any of the other functionality
related to a performance counter, like ``start``, ``stop`` or ``reset``) member
functions of the created client component instance should be called::

    // print the current number of threads created on locality 0
    hpx::performance_counters::performance_counter count(
        "/threads{locality#0/total}/count/cumulative");
    hpx::cout << count.get_value<int>().get() << hpx::endl;

For more information about the client component type, see
:cpp:class:`hpx::performance_counters::performance_counter`

.. note::

   In the above example ``count.get_value()`` returns a future. In order to print
   the result we must append ``.get()`` to retrieve the value. You could write the
   above example like this for more clarity::

       // print the current number of threads created on locality 0
       hpx::performance_counters::performance_counter count(
           "/threads{locality#0/total}/count/cumulative");
       hpx::future<int> result = count.get_value<int>();
       hpx::cout << result.get() << hpx::endl;

.. _providing:

Providing performance counter data
----------------------------------

|hpx| offers several ways by which you may provide your own data as a
performance counter. This has the benefit of exposing additional, possibly
application-specific information using the existing Performance Counter
framework, unifying the process of gathering data about your application.

An application that wants to provide counter data can implement a performance
counter to provide the data. When a consumer queries performance data, the |hpx|
runtime system calls the provider to collect the data. The runtime system uses
an internal registry to determine which provider to call.

Generally, there are two ways of exposing your own performance counter data: a
simple, function-based way and a more complex, but more powerful way of
implementing a full performance counter. Both alternatives are described in the
following sections.

.. _simple_counters:

Exposing performance counter data using a simple function
---------------------------------------------------------

The simplest way to expose arbitrary numeric data is to write a function which
will then be called whenever a consumer queries this counter. Currently, this
type of performance counter can only be used to expose integer values. The
expected signature of this function is::

    std::int64_t some_performance_data(bool reset);

The argument ``bool reset`` (which is supplied by the runtime system when the
function is invoked) specifies whether the counter value should be reset after
evaluating the current value (if applicable).

For instance, here is such a function returning how often it was invoked::

    // The atomic variable 'counter' ensures the thread safety of the counter.
    boost::atomic<std::int64_t> counter(0);

    std::int64_t some_performance_data(bool reset)
    {
        std::int64_t result = ++counter;
        if (reset)
            counter = 0;
        return result;
    }

This example function exposes a linearly-increasing value as our performance
data. The value is incremented on each invocation, i.e., each time a consumer
requests the counter data of this performance counter.

The next step in exposing this counter to the runtime system is to register the
function as a new raw counter type using the |hpx| API function
:cpp:func:`hpx::performance_counters::install_counter_type`. A counter type
represents certain common characteristics of counters, like their counter type
name and any associated description information. The following snippet shows an
example of how to register the function ``some_performance_data``, which is shown
above, for a counter type named ``"/test/data"``. This registration has to be
executed before any consumer instantiates, and queries an instance of this
counter type::

    #include <hpx/include/performance_counters.hpp>

    void register_counter_type()
    {
        // Call the HPX API function to register the counter type.
        hpx::performance_counters::install_counter_type(
            "/test/data",                                   // counter type name
            &some_performance_data,                         // function providing counter data
            "returns a linearly increasing counter value"   // description text (optional)
            ""                                              // unit of measure (optional)
        );
    }

Now it is possible to instantiate a new counter instance based on the naming
scheme ``"/test{locality#*/total}/data"`` where ``*`` is a zero-based integer
index identifying the :term:`locality` for which the counter instance should be
accessed. The function
:cpp:func:`hpx::performance_counters::install_counter_type` enables users to
instantiate exactly one counter instance for each :term:`locality`. Repeated
requests to instantiate such a counter will return the same instance, i.e., the
instance created for the first request.

If this counter needs to be accessed using the standard |hpx| command line
options, the registration has to be performed during application startup, before
``hpx_main`` is executed. The best way to achieve this is to register an |hpx|
startup function using the API function
:cpp:func:`hpx::register_startup_function` before calling ``hpx::init`` to
initialize the runtime system::

    int main(int argc, char* argv[])
    {
        // By registering the counter type we make it available to any consumer
        // who creates and queries an instance of the type "/test/data".
        //
        // This registration should be performed during startup. The
        // function 'register_counter_type' should be executed as an HPX thread right
        // before hpx_main is executed.
        hpx::register_startup_function(&register_counter_type);

        // Initialize and run HPX.
        return hpx::init(argc, argv);
    }

Please see the code in :download:`simplest_performance_counter.cpp <../../examples/performance_counters/simplest_performance_counter.cpp>`
for a full example demonstrating this functionality.

.. _full_counters:

Implementing a full performance counter
---------------------------------------

Sometimes, the simple way of exposing a single value as a performance counter is
not sufficient. For that reason, |hpx| provides a means of implementing full
performance counters which support:

* Retrieving the descriptive information about the performance counter
* Retrieving the current counter value
* Resetting the performance counter (value)
* Starting the performance counter
* Stopping the performance counter
* Setting the (initial) value of the performance counter

Every full performance counter will implement a predefined interface:

.. literalinclude:: ../../libs/full/performance_counters/include/hpx/performance_counters/performance_counter.hpp
   :language: c++

In order to implement a full performance counter, you have to create an |hpx|
component exposing this interface. To simplify this task, |hpx| provides a
ready-made base class which handles all the boiler plate of creating
a component for you. The remainder of this section will explain the process of creating a full
performance counter based on the Sine example, which you can find in the
directory ``examples/performance_counters/sine/``.

The base class is defined in the header file :download:`base_performance_counter.cpp <../../libs/full/performance_counters/include/hpx/performance_counters/base_performance_counter.hpp>`
as:

.. literalinclude:: ../../libs/full/performance_counters/include/hpx/performance_counters/base_performance_counter.hpp
   :language: c++

The single template parameter is expected to receive the type of the
derived class implementing the performance counter. In the Sine example
this looks like:

.. literalinclude:: ../../examples/performance_counters/sine/server/sine.hpp
   :language: c++

i.e., the type ``sine_counter`` is derived from the base class passing the type
as a template argument (please see :download:`simplest_performance_counter.cpp <../../examples/performance_counters/simplest_performance_counter.cpp>`
for the full source code of the counter definition). For more information about this
technique (called Curiously Recurring Template Pattern - CRTP), please see for
instance the corresponding `Wikipedia article
<http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_. This base
class itself is derived from the ``performance_counter`` interface described
above.

Additionally, a full performance counter implementation not only exposes the
actual value but also provides information about:

* The point in time a particular value was retrieved.
* A (sequential) invocation count.
* The actual counter value.
* An optional scaling coefficient.
* Information about the counter status.

.. _counters:

Existing |hpx| performance counters
-----------------------------------

The |hpx| runtime system exposes a wide variety of predefined performance
counters. These counters expose critical information about different modules of
the runtime system. They can help determine system bottlenecks and fine-tune
system and application performance.

.. list-table:: :term:`AGAS` performance counters

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/agas/count/<agas_service>``
   
       .. _agas-count-agas-service: 

       :ref:`🔗<agas-count-agas-service>`

       where:

       ``<agas_service>`` is one of the following:

       *primary namespace services*: ``route``, ``bind_gid``, ``resolve_gid``,
       ``unbind_gid``, ``increment_credit``, ``decrement_credit``, ``allocate``,
       ``begin_migration``, ``end_migration``

       *component namespace services*: ``bind_prefix``, ``bind_name``,
       ``resolve_id``, ``unbind_name``, ``iterate_types``,
       ``get_component_typename``, ``num_localities_type``

       *locality namespace services*: ``free``, ``localities``,
       ``num_localities``, ``num_threads``, ``resolve_locality``,
       ``resolved_localities``

       *symbol namespace services*: ``bind``, ``resolve``, ``unbind``,
       ``iterate_names``, ``on_symbol_namespace_event``
     * ``<agas_instance>/total``

       where:

       ``<agas_instance>`` is the name of the :term:`AGAS` service to query.
       Currently, this value will be ``locality#0`` where ``0`` is the root
       :term:`locality` (the id of the locality hosting the :term:`AGAS`
       service).

       The value for ``*`` can be any :term:`locality` id for the following
       ``<agas_service>``: ``route``, ``bind_gid``, ``resolve_gid``,
       ``unbind_gid``, ``increment_credit``, ``decrement_credit``, ``bin``,
       ``resolve``, ``unbind``, and ``iterate_names`` (only the primary and
       symbol :term:`AGAS` service components live on all localities, whereas
       all other :term:`AGAS` services are available on ``locality#0`` only).
     * None
     * Returns the total number of invocations of the specified :term:`AGAS`
       service since its creation.
   * * ``/agas/<agas_service_category>/count``

       .. _agas-agas-service-category-count: 

       :ref:`🔗<agas-agas-service-category-count>`

       where:

       ``<agas_service_category>`` is one of the following: ``primary``,
       ``locality``, ``component`` or ``symbol``

     * ``<agas_instance>/total``

       where:

       ``<agas_instance>`` is the name of the :term:`AGAS` service to query.
       Currently, this value will be ``locality#0`` where ``0`` is the root
       :term:`locality` (the id of the :term:`locality` hosting the :term:`AGAS`
       service). Except for ``<agas_service_category>``, ``primary`` or
       ``symbol`` for which the value for ``*`` can be any :term:`locality` id
       (only the primary and symbol :term:`AGAS` service components live on all
       localities, whereas all other :term:`AGAS` services are available on
       ``locality#0`` only).
     * None
     * Returns the overall total number of invocations of all :term:`AGAS`
       services provided by the given :term:`AGAS` service category since its
       creation.
   * * ``agas/time/<agas_service>``

       .. _agas-time-agas-service: 

       :ref:`🔗<agas-time-agas-service>`

       where:

       ``<agas_service>`` is one of the following:


       *primary namespace services*: ``route``, ``bind_gid``, ``resolve_gid``,
       ``unbind_gid``, ``increment_credit``, ``decrement_credit``, ``allocate``
       ``begin_migration``, ``end_migration``

       *component namespace services*: ``bind_prefix``, ``bind_name``,
       ``resolve_id``, ``unbind_name``, ``iterate_types``,
       ``get_component_typename``, ``num_localities_type``

       *locality namespace services*: ``free``, ``localities``,
       ``num_localities``, ``num_threads``, ``resolve_locality``,
       ``resolved_localities``

       *symbol namespace services*: ``bind``, ``resolve``, ``unbind``,
       ``iterate_names``, ``on_symbol_namespace_event``

     * ``<agas_instance>/total``

       where:

       ``<agas_instance>`` is the name of the :term:`AGAS` service to query.
       Currently, this value will be ``locality#0`` where ``0`` is the root
       :term:`locality` (the id of the :term:`locality` hosting the :term:`AGAS`
       service).

       The value for ``*`` can be any :term:`locality` id for the following
       ``<agas_service>``: ``route``, ``bind_gid``, ``resolve_gid``,
       ``unbind_gid``, ``increment_credit``, ``decrement_credit``, ``bin``,
       ``resolve``, ``unbind``, and ``iterate_names`` (only the primary and
       symbol :term:`AGAS` service components live on all localities, whereas
       all other :term:`AGAS` services are available on ``locality#0`` only).
     * None
     * Returns the overall execution time of the specified :term:`AGAS` service
       since its creation (in nanoseconds).
   * * ``/agas/<agas_service_category>/time``

       .. _agas-agas-service-category-time: 

       :ref:`🔗<agas-agas-service-category-time>`

       where:

       ``<agas_service_category>`` is one of the following: ``primary``,
       ``locality``, ``component`` or ``symbol``
     * ``<agas_instance>/total``

       where:

       ``<agas_instance>`` is the name of the :term:`AGAS` service to query.
       Currently, this value will be ``locality#0`` where ``0`` is the root
       :term:`locality` (the id of the :term:`locality` hosting the :term:`AGAS`
       service). Except for ``<agas_service_category`` ``primary`` or ``symbol``
       for which the value for ``*`` can be any :term:`locality` id (only the
       primary and symbol :term:`AGAS` service components live on all
       localities, whereas all other :term:`AGAS` services are available on
       ``locality#0`` only).
     * None
     * Returns the overall execution time of all :term:`AGAS` services provided
       by the given :term:`AGAS` service category since its creation (in
       nanoseconds).
   * * ``/agas/count/entries``
       
       .. _agas-count-entries: 

       :ref:`🔗<agas-count-entries>`
     
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the :term:`AGAS`
       cache should be queried. The :term:`locality` id is a (zero based) number
       identifying the :term:`locality`.
     * None
     * Returns the number of cache entries resident in the :term:`AGAS` cache of
       the specified :term:`locality` (see ``<cache_statistics>``).
   * * ``/agas/count/<cache_statistics>``

       .. _agas-count-cache-statistics: 

       :ref:`🔗<agas-count-cache-statistics>`

       where:

       ``<cache_statistics>`` is one of the following: ``cache/evictions``,
       ``cache/hits``, ``cache/insertions``, ``cache/misses``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the :term:`AGAS`
       cache should be queried. The :term:`locality` id is a (zero based) number
       identifying the :term:`locality`.
     * None
     * Returns the number of cache events (evictions, hits, inserts, and misses)
       in the :term:`AGAS` cache of the specified :term:`locality` (see
       ``<cache_statistics>``).
   * * ``/agas/count/<full_cache_statistics>``

       .. _agas-count-full-cache-statistics: 

       :ref:`🔗<agas-count-full-cache-statistics>`

       where:

       ``<full_cache_statistics>`` is one of the following: ``cache/get_entry``,
       ``cache/insert_entry``, ``cache/update_entry``, ``cache/erase_entry``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the :term:`AGAS`
       cache should be queried. The :term:`locality` id is a (zero based) number
       identifying the :term:`locality`.
     * None
     * Returns the number of invocations of the specified cache API function of
       the :term:`AGAS` cache.
   * * ``/agas/time/<full_cache_statistics>``

       .. _agas-time-full-cache-statistics:

       :ref:`🔗<agas-time-full-cache-statistics>`

       where:

       ``<full_cache_statistics>`` is one of the following:
       ``cache/get_entry``, ``cache/insert_entry``, ``cache/update_entry``,
       ``cache/erase_entry``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the :term:`AGAS`
       cache should be queried. The :term:`locality` id is a (zero based) number
       identifying the :term:`locality`.
     * None
     * Returns the overall time spent executing of the specified API function of
       the :term:`AGAS` cache.

.. list-table:: :term:`Parcel` layer performance counters

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/data/count/<connection_type>/<operation>``

       .. _data-count-connection-type-operation:

       :ref:`🔗<data-count-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the overall
       number of transmitted bytes should be queried for. The :term:`locality`
       id is a (zero based) number identifying the :term:`locality`.
     * Returns the overall number of raw (uncompressed) bytes sent or received
       (see ``<operation``, e.g. ``en`` or ``eceived``) for the specified
       ``<connection_type>``.

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * None
   * * ``/data/time/<connection_type>/<operation>``

       .. _data-time-connection-type-operation:

       :ref:`🔗<data-time-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the total
       transmission time should be queried for. The :term:`locality` id is a
       (zero based) number identifying the :term:`locality`.
     * Returns the total time (in nanoseconds) between the start of each
       asynchronous transmission operation and the end of the corresponding
       operation for the specified ``<connection_type>`` the given
       :term:`locality` (see ``<operation``, e.g. ``en`` or ``eceived``).

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * None
   * * ``/serialize/count/<connection_type>/<operation>``

       .. _serialize-count-connection-type-operation:

       :ref:`🔗<serialize-count-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the overall
       number of transmitted bytes should be queried for. The :term:`locality`
       id is a (zero based) number identifying the :term:`locality`.
     * Returns the overall number of bytes transferred (see ``<operation>``,
       e.g. ``sent`` or ``received`` possibly compressed) for the specified
       ``<connection_type>`` by the given :term:`locality`.

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
       was specified, this counter allows one to specify an optional action name
       as its parameter. In this case the counter will report the number of
       bytes transmitted for the given action only.
   * * ``/serialize/time/<connection_type>/<operation>``

       .. _serialize-time-connection-type-operation:

       :ref:`🔗<serialize-time-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the
       serialization time should be queried for. The :term:`locality` id is a
       (zero based) number identifying the :term:`locality`.
     * Returns the overall time spent performing outgoing data serialization for
       the specified ``<connection_type>`` on the given :term:`locality` (see
       ``<operation``, e.g. ``sent`` or ``received``).

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
       was specified, this counter allows one to specify an optional action name
       as its parameter. In this case the counter will report the serialization
       time for the given action only.
   * * ``/parcels/count/routed``

       .. _parcels-count-routed:

       :ref:`🔗<parcels-count-routed>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       routed parcels should be queried for. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the overall number of routed (outbound) parcels transferred by
       the given :term:`locality`.

       Routed parcels are those which cannot directly be delivered to its
       destination as the local :term:`AGAS` is not able to resolve the
       destination address. In this case a parcel is sent to the :term:`AGAS`
       service component which is responsible for creating the destination GID
       (and is responsible for resolving the destination address). This
       :term:`AGAS` service component will deliver the parcel to its final
       target.
     * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
       was specified, this counter allows one to specify an optional action name
       as its parameter. In this case the counter will report the number of
       parcels for the given action only.
   * * ``/parcels/count/<connection_type>/<operation>``

       .. _parcels-count-connection-type-operation:

       :ref:`🔗<parcels-count-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       parcels should be queried for. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall number of parcels transferred using the specified
       ``<connection_type`` by the given :term:`locality` (see ``operation>``,
       e.g. ``sent`` or ``received``.

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * None
   * * ``/messages/count/<connection_type>/<operation>``

       .. _messages-count-connection-type-operation:

       :ref:`🔗<messages-count-connection-type-operation>`

       where:

       ``<operation>`` is one of the following: ``sent``, ``received``

       ``<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       messages should be queried for. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall number of messages [#]_ transferred using the
       specified ``<connection_type>`` by the given :term:`locality` (see
       ``<operation``, e.g. ``sent`` or ``received``)

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * None
   * * ``/parcelport/count/<connection_type>/<cache_statistics>``

       .. _parcelport-count-connection-type-cache-statistics:

       :ref:`🔗<parcelport-count-connection-type-cache-statistics>`

       where:

       ``<cache_statistics>`` is one of the following: ``cache/insertions``,
       ``cache/evictions``, ``cache/hits``, ``cache/misses``

       `<connection_type`` is one of the following: ``tcp``, ``mpi``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       messages should be queried for. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall number cache events (evictions, hits, inserts,
       misses, and reclaims) for the connection cache of the given connection
       type on the given :term:`locality` (see ``<cache_statistics``, e.g.
       ``ache/insertions``, ``cache/evictions``, ``cache/hits``,
       ``cache/misses`` or``cache/reclaims``.

       The performance counters for the connection type ``mpi`` are available
       only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` was defined
       while compiling the |hpx| core library (which is not defined by default,
       the corresponding cmake configuration constant is
       ``HPX_WITH_PARCELPORT_MPI``.

       Please see :ref:`cmake_variables` for more details.
     * None
   * * ``/parcelqueue/length/<operation>``

       .. _parcelqueue-length-operation:

       :ref:`🔗<parcelqueue-length-operation>`

       where:

       ``<operation>`` is one of the following: ``send``, ``receive``
     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the :term:`parcel` queue
       should be queried. The :term:`locality` id is a (zero based) number
       identifying the :term:`locality`.
     * Returns the current number of parcels stored in the :term:`parcel` queue (see
       ``<operation`` for which queue to query, e.g. ``sent`` or ``received``).
     * None

.. list-table:: Thread manager performance counters

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/threads/count/cumulative``

       .. _threads-count-cumulative:

       :ref:`🔗<threads-count-cumulative>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the overall
       number of retired |hpx|-threads should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
        idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the overall
        number of retired |hpx|-threads should be queried for. The worker thread
        number (given by the ``*`` is a (zero based) number identifying the
        worker thread. The number of available worker threads is usually
        specified on the command line for the application using the option
        :option:`--hpx:threads`. If no pool-name is specified the counter refers
        to the 'default' pool.
     * Returns the overall number of executed (retired) |hpx|-threads on the
       given :term:`locality` since application start. If the instance name is
       ``total`` the counter returns the accumulated number of retired
       |hpx|-threads for all worker threads (cores) on that :term:`locality`. If
       the instance name is ``worker-thread#*`` the counter will return the
       overall number of retired |hpx|-threads for all worker threads
       separately. This counter is available only if the configuration time
       constant ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` is set to ``ON`` (default:
       ``ON``).
     * None
   * * ``/threads/time/average``

       .. _threads-time-average:

       :ref:`🔗<threads-time-average>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or


       ``locality#*/pool#*/worker-thread#*``

       where:


       ``locality#*`` is defining the :term:`locality` for which the average
       time spent executing one |hpx|-thread should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the average
       time spent executing one |hpx|-thread should be queried for. The worker
       thread number (given by the ``*`` is a (zero based) number identifying
       the worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the average time spent executing one |hpx|-thread on the given
       :term:`locality` since application start. If the instance name is ``total``
       the counter returns the average time spent executing one |hpx|-thread for
       all worker threads (cores) on that :term:`locality`. If the instance name
       is ``worker-thread#*`` the counter will return the average time spent
       executing one |hpx|-thread for all worker threads separately. This counter
       is available only if the configuration time constants
       ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The unit
       of measure for this counter is nanosecond [ns].
     * None
   * * ``/threads/time/average-overhead``
       
       .. _threads-time-average-overhead:

       :ref:`🔗<threads-time-average-overhead>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       overhead spent executing one |hpx|-thread should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the average
       overhead spent executing one |hpx|-thread should be queried for. The
       worker thread number (given by the ``*`` is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the
       option :option:`--hpx:threads`. If no pool-name is specified the counter
       refers to the 'default' pool.
     * Returns the average time spent on overhead while executing one
       |hpx|-thread on the given :term:`locality` since application start. If
       the instance name is ``total`` the counter returns the average time spent
       on overhead while executing one |hpx|-thread for all worker threads
       (cores) on that :term:`locality`. If the instance name is
       ``worker-thread#*`` the counter will return the average time spent on
       overhead executing one |hpx|-thread for all worker threads separately.
       This counter is available only if the configuration time constants
       ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure for this counter is nanosecond [ns].
     * None
   * * ``/threads/count/cumulative-phases``

       .. _threads-count-cumulative-phases:

       :ref:`🔗<threads-count-cumulative-phases>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the overall
       number of executed |hpx|-thread phases (invocations) should be queried
       for. The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the overall
       number of executed |hpx|-thread phases (invocations) should be queried
       for. The worker thread number (given by the ``*`` is a (zero based)
       number identifying the worker thread. The number of available worker
       threads is usually specified on the command line for the application
       using the option :option:`--hpx:threads`. If no pool-name is specified
       the counter refers to the 'default' pool.
     * Returns the overall number of executed |hpx|-thread phases (invocations)
       on the given :term:`locality` since application start. If the instance
       name is ``total`` the counter returns the accumulated number of executed
       |hpx|-thread phases (invocations) for all worker threads (cores) on that
       :term:`locality`. If the instance name is ``worker-thread#*`` the counter
       will return the overall number of executed |hpx|-thread phases for all
       worker threads separately. This counter is available only if the
       configuration time constant ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` is set
       to ``ON`` (default: ``ON``). The unit of measure for this counter is
       nanosecond [ns].
     * None
   * * ``/threads/time/average-phase``

       .. _threads-time-average-phase:

       :ref:`🔗<threads-time-average-phase>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       time spent executing one |hpx|-thread phase (invocation) should be
       queried for. The :term:`locality` id (given by ``*`` is a (zero based)
       number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the average
       time executing one |hpx|-thread phase (invocation) should be queried for.
       The worker thread number (given by the ``*`` is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the
       option :option:`--hpx:threads`. If no pool-name is specified the counter
       refers to the 'default' pool.
     * Returns the average time spent executing one |hpx|-thread phase
       (invocation) on the given :term:`locality` since application start. If
       the instance name is ``total`` the counter returns the average time spent
       executing one |hpx|-thread phase (invocation) for all worker threads
       (cores) on that :term:`locality`. If the instance name is
       ``worker-thread#*`` the counter will return the average time spent
       executing one |hpx|-thread phase for all worker threads separately. This
       counter is available only if the configuration time constants
       ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure for this counter is nanosecond [ns].
     * None
   * * ``/threads/time/average-phase-overhead``

       .. _threads-time-average-phase-overhead:

       :ref:`🔗<threads-time-average-phase-overhead>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:


       ``locality#*`` is defining the :term:`locality` for which the average
       time overhead executing one |hpx|-thread phase (invocation) should be
       queried for. The :term:`locality` id (given by ``*`` is a (zero based)
       number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the average
       overhead executing one |hpx|-thread phase (invocation) should be queried
       for. The worker thread number (given by the ``*`` is a (zero based)
       number identifying the worker thread. The number of available worker
       threads is usually specified on the command line for the application
       using the option :option:`--hpx:threads`. If no pool-name is specified
       the counter refers to the 'default' pool.
     * Returns the average time spent on overhead executing one |hpx|-thread
       phase (invocation) on the given :term:`locality` since application start.
       If the instance name is ``total`` the counter returns the average time
       spent on overhead while executing one |hpx|-thread phase (invocation) for
       all worker threads (cores) on that :term:`locality`. If the instance name
       is ``worker-thread#*`` the counter will return the average time spent on
       overhead executing one |hpx|-thread phase for all worker threads
       separately. This counter is available only if the configuration time
       constants ``HPX_WITH_THREAD_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure for this counter is nanosecond [ns].
     * None
   * * ``/threads/time/overall``

       .. _threads-time-overall:

       :ref:`🔗<threads-time-overall>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the overall
       time spent running the scheduler should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the overall
       time spent running the scheduler should be queried for. The worker thread
       number (given by the ``*`` is a (zero based) number identifying the
       worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the overall time spent running the scheduler on the given
       :term:`locality` since application start. If the instance name is ``total``
       the counter returns the overall time spent running the scheduler for all
       worker threads (cores) on that :term:`locality`. If the instance name is
       ``worker-thread#*`` the counter will return the overall time spent running
       the scheduler for all worker threads separately. This counter is available
       only if the configuration time constant ``HPX_WITH_THREAD_IDLE_RATES`` is
       set to ``ON`` (default: ``OFF``). The unit of measure for this counter is
       nanosecond [ns].
     * None
   * * ``/threads/time/cumulative``

       .. _threads-time-cumulative:

       :ref:`🔗<threads-time-cumulative>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the overall
       time spent executing all |hpx|-threads should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the overall
       time spent executing all |hpx|-threads should be queried for. The worker
       thread number (given by the ``*`` is a (zero based) number identifying
       the worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the overall time spent executing all |hpx|-threads on the given
       :term:`locality` since application start. If the instance name is ``total``
       the counter returns the overall time spent executing all |hpx|-threads for
       all worker threads (cores) on that :term:`locality`. If the instance name
       is ``worker-thread#*`` the counter will return the overall time spent
       executing all |hpx|-threads for all worker threads separately. This counter
       is available only if the configuration time constants
       ``HPX_THREAD_MAINTAIN_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_THREAD_MAINTAIN_IDLE_RATES`` are set to ``ON`` (default: ``OFF``).
     * None
   * * ``/threads/time/cumulative-overheads``

       .. _threads-time-cumulative-overheads:

       :ref:`🔗<threads-time-cumulative-overheads>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the overall
       overhead time incurred by executing all |hpx|-threads should be queried
       for. The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the the
       overall overhead time incurred by executing all |hpx|-threads should be
       queried for. The worker thread number (given by the ``*`` is a (zero
       based) number identifying the worker thread. The number of available
       worker threads is usually specified on the command line for the
       application using the option :option:`--hpx:threads`. If no pool-name is
       specified the counter refers to the 'default' pool.
     * Returns the overall overhead time incurred executing all |hpx|-threads on
       the given :term:`locality` since application start. If the instance name
       is ``total`` the counter returns the overall overhead time incurred
       executing all |hpx|-threads for all worker threads (cores) on that
       :term:`locality`. If the instance name is ``worker-thread#*`` the counter
       will return the overall overhead time incurred executing all
       |hpx|-threads for all worker threads separately. This counter is
       available only if the configuration time constants
       ``HPX_THREAD_MAINTAIN_CUMULATIVE_COUNTS`` (default: ``ON``) and
       ``HPX_THREAD_MAINTAIN_IDLE_RATES`` are set to ``ON`` (default: ``OFF``).
       The unit of measure for this counter is nanosecond [ns].
     * None
   * * ``threads/count/instantaneous/<thread-state>``

       .. _threads-count-instantaneous-thread-state:

       :ref:`🔗<threads-count-instantaneous-thread-state>`

       where:

       ``<thread-state>`` is one of the following: ``all``, ``active``,
       ``pending``, ``suspended``, ``terminated``, ``staged``
     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       number of threads with the given state should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the current
       number of threads with the given state should be queried for. The worker
       thread number (given by the ``*`` is a (zero based) number identifying
       the worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.

       The ``staged`` thread state refers to registered tasks before they are
       converted to thread objects.
     * Returns the current number of |hpx|-threads having the given thread state
       on the given :term:`locality`. If the instance name is ``total`` the
       counter returns the current number of |hpx|-threads of the given state
       for all worker threads (cores) on that :term:`locality`. If the instance
       name is ``worker-thread#*`` the counter will return the current number of
       |hpx|-threads in the given state for all worker threads separately.
     * None
   * * ``threads/wait-time/<thread-state>``

       .. _threads-wait-time-thread-state:

       :ref:`🔗<threads-wait-time-thread-state>`

       where:

       ``<thread-state>`` is one of the following: ``pending`` ``staged``
     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       wait time of |hpx|-threads (pending) or thread descriptions (staged) with
       the given state should be queried for. The :term:`locality` id (given by
       ``*`` is a (zero based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the average
       wait time for the given state should be queried for. The worker thread
       number (given by the ``*`` is a (zero based) number identifying the
       worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.

       The ``staged`` thread state refers to the wait time of registered tasks
       before they are converted into thread objects, while the ``pending``
       thread state refers to the wait time of threads in any of the scheduling
       queues.
     * Returns the average wait time of |hpx|-threads (if the thread state is
       ``pending`` or of task descriptions (if the thread state is ``staged`` on
       the given :term:`locality` since application start. If the instance name
       is ``total`` the counter returns the wait time of |hpx|-threads of the
       given state for all worker threads (cores) on that :term:`locality`. If
       the instance name is ``worker-thread#*`` the counter will return the wait
       time of |hpx|-threads in the given state for all worker threads
       separately.

       These counters are available only if the compile time constant
       ``HPX_WITH_THREAD_QUEUE_WAITTIME`` was defined while compiling the |hpx|
       core library (default: ``OFF``). The unit of measure for this counter is
       nanosecond [ns].
     * None
   * * ``/threads/idle-rate``

       .. _threads-idle-rate:

       :ref:`🔗<threads-idle-rate>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       idle rate of all (or one) worker threads should be queried for. The
       :term:`locality` id (given by ``*`` is a (zero based) number identifying
       the :term:`locality`

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the averaged
       idle rate should be queried for. The worker thread number (given by the
       ``*`` is a (zero based) number identifying the worker thread. The number
       of available worker threads is usually specified on the command line for
       the application using the option :option:`--hpx:threads`. If no pool-name
       is specified the counter refers to the 'default' pool.
     * Returns the average idle rate for the given worker thread(s) on the given
       :term:`locality`. The idle rate is defined as the ratio of the time spent
       on scheduling and management tasks and the overall time spent executing
       work since the application started. This counter is available only if the
       configuration time constant ``HPX_WITH_THREAD_IDLE_RATES`` is set to ``ON``
       (default: ``OFF``).
     * None
   * * ``/threads/creation-idle-rate``

       .. _threads-creation-idle-rate:

       :ref:`🔗<threads-creation-idle-rate>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       creation idle rate of all (or one) worker threads should be queried for.
       The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the averaged
       idle rate should be queried for. The worker thread number (given by the
       ``*`` is a (zero based) number identifying the worker thread. The number
       of available worker threads is usually specified on the command line for
       the application using the option :option:`--hpx:threads`. If no pool-name
       is specified the counter refers to the 'default' pool.
     * Returns the average idle rate for the given worker thread(s) on the given
       :term:`locality` which is caused by creating new threads. The creation idle
       rate is defined as the ratio of the time spent on creating new threads and
       the overall time spent executing work since the application started. This
       counter is available only if the configuration time constants
       ``HPX_WITH_THREAD_IDLE_RATES`` (default: ``OFF``) and
       ``HPX_WITH_THREAD_CREATION_AND_CLEANUP_RATES`` are set to ``ON``.
     * None
   * * ``/threads/cleanup-idle-rate``

       .. _threads-cleanup-idle-rate:

       :ref:`🔗<threads-cleanup-idle-rate>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or


       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the average
       cleanup idle rate of all (or one) worker threads should be queried for.
       The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the averaged
       cleanup idle rate should be queried for. The worker thread number (given
       by the ``*`` is a (zero based) number identifying the worker thread. The
       number of available worker threads is usually specified on the command
       line for the application using the option :option:`--hpx:threads`. If no
       pool-name is specified the counter refers to the 'default' pool.
     * Returns the average idle rate for the given worker thread(s) on the given
       :term:`locality` which is caused by cleaning up terminated threads. The
       cleanup idle rate is defined as the ratio of the time spent on cleaning up
       terminated thread objects and the overall time spent executing work since
       the application started. This counter is available only if the
       configuration time constants ``HPX_WITH_THREAD_IDLE_RATES`` (default:
       ``OFF``) and ``HPX_WITH_THREAD_CREATION_AND_CLEANUP_RATES`` are set to
       ``ON``.
     * None
   * * ``/threadqueue/length``

       .. _threadqueue-length:

       :ref:`🔗<threadqueue-length>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       length of all thread queues in the scheduler for all (or one) worker
       threads should be queried for. The :term:`locality` id (given by ``*`` is
       a (zero based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the current
       length of all thread queues in the scheduler should be queried for. The
       worker thread number (given by the ``*`` is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the
       option :option:`--hpx:threads`. If no pool-name is specified the counter
       refers to the 'default' pool.
     * Returns the overall length of all queues for the given worker thread(s)
       on the given :term:`locality`.
     * None
   * * ``/threads/count/stack-unbinds``

       .. _threads-count-stack-unbinds:

       :ref:`🔗<threads-count-stack-unbinds>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the unbind
       (madvise) operations should be queried for. The :term:`locality` id is a
       (zero based) number identifying the :term:`locality`.
     * Returns the total number of |hpx|-thread unbind (madvise) operations
       performed for the referenced :term:`locality`. Note that this counter is
       not available on Windows based platforms.
     * None
   * * ``/threads/count/stack-recycles``

       .. _threads-count-stack-recycles:

       :ref:`🔗<threads-count-stack-recycles>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the recycling
       operations should be queried for. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the total number of |hpx|-thread recycling operations performed.
     * None
   * * ``/threads/count/stolen-from-pending``

       .. _threads-count-stolen-from-pending:

       :ref:`🔗<threads-count-stolen-from-pending>`

     * ``locality#*/total``

          where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       'stole' threads should be queried for. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the total number of |hpx|-threads 'stolen' from the pending
       thread queue by a neighboring thread worker thread (these threads are
       executed by a different worker thread than they were initially scheduled
       on). This counter is available only if the configuration time constant
       ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON`` (default: ``ON``).
     * None
   * * ``/threads/count/pending-misses``

       .. _threads-count-pending-misses:

       :ref:`🔗<threads-count-pending-misses>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the number of
       pending queue misses of all (or one) worker threads should be queried
       for. The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the number of
       pending queue misses should be queried for. The worker thread number
       (given by the ``*`` is a (zero based) number identifying the worker
       thread. The number of available worker threads is usually specified on
       the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the total number of times that the referenced worker-thread on
       the referenced :term:`locality` failed to find pending |hpx|-threads in
       its associated queue. This counter is available only if the configuration
       time constant ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON``
       (default: ``ON``).
     * None
   * * ``/threads/count/pending-accesses``
 
       .. _threads-count-pending-accesses:

       :ref:`🔗<threads-count-pending-accesses>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the number of
       pending queue accesses of all (or one) worker threads should be queried
       for. The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the number of
       pending queue accesses should be queried for. The worker thread number
       (given by the ``*`` is a (zero based) number identifying the worker
       thread. The number of available worker threads is usually specified on
       the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the total number of times that the referenced worker-thread on
       the referenced :term:`locality` looked for pending |hpx|-threads in its
       associated queue. This counter is available only if the configuration
       time constant ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON``
       (default: ``ON``).
     * None
   * * ``/threads/count/stolen-from-staged``

       .. _threads-count-stolen-from-staged:

       :ref:`🔗<threads-count-stolen-from-staged>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the number of
       |hpx|-threads stolen from the staged queue of all (or one) worker threads
       should be queried for. The :term:`locality` id (given by ``*`` is a (zero
       based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the number of
       |hpx|-threads stolen from the staged queue should be queried for. The
       worker thread number (given by the ``*`` is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the
       option :option:`--hpx:threads`. If no pool-name is specified the counter
       refers to the 'default' pool.
     * Returns the total number of |hpx|-threads 'stolen' from the staged thread
       queue by a neighboring worker thread (these threads are executed by a
       different worker thread than they were initially scheduled on). This
       counter is available only if the configuration time constant
       ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON`` (default: ``ON``).
     * None
   * * ``/threads/count/stolen-to-pending``

       .. _threads-count-stolen-to-pending:

       :ref:`🔗<threads-count-stolen-to-pending>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the number of
       |hpx|-threads stolen to the pending queue of all (or one) worker threads
       should be queried for. The :term:`locality` id (given by ``*`` is a (zero
       based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the number of
       |hpx|-threads stolen to the pending queue should be queried for. The
       worker thread number (given by the ``*`` is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the
       option :option:`--hpx:threads`. If no pool-name is specified the counter
       refers to the 'default' pool.
     * Returns the total number of |hpx|-threads 'stolen' to the pending thread
       queue of the worker thread (these threads are executed by a different
       worker thread than they were initially scheduled on). This counter is
       available only if the configuration time constant
       ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON`` (default: ``ON``).
     * None
   * * ``/threads/count/stolen-to-staged``

       .. _threads-count-stolen-to-staged:

       :ref:`🔗<threads-count-stolen-to-staged>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the number of
       |hpx|-threads stolen to the staged queue of all (or one) worker threads
       should be queried for. The :term:`locality` id (given by ``*`` is a (zero
       based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the number of
       |hpx|-threads stolen to the staged queue should be queried for. The
       worker thread number (given by the ``*`` is a (zero based) worker thread
       number (given by the ``*`` is a (zero based) number identifying the
       worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`. If no pool-name is specified the counter refers
       to the 'default' pool.
     * Returns the total number of |hpx|-threads 'stolen' to the staged thread
       queue of a neighboring worker thread (these threads are executed by a
       different worker thread than they were initially scheduled on). This
       counter is available only if the configuration time constant
       ``HPX_WITH_THREAD_STEALING_COUNTS`` is set to ``ON`` (default: ``ON``).
     * None
   * * ``/threads/count/objects``

       .. _threads-count-objects:

       :ref:`🔗<threads-count-objects>`

     * ``locality#*/total`` or

       ``locality#*/allocator#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       (cumulative) number of all created |hpx|-thread objects should be queried
       for. The :term:`locality` id (given by ``*`` is a (zero based) number
       identifying the :term:`locality`.

       ``allocator#*`` is defining the number of the allocator instance using
       which the threads have been created. |hpx| uses a varying number of
       allocators to create (and recycle) |hpx|-thread objects, most likely
       these counters are of use for debugging purposes only. The allocator id
       (given by ``*`` is a (zero based) number identifying the allocator to
       query.
     * Returns the total number of |hpx|-thread objects created. Note that
       thread objects are reused to improve system performance, thus this number
       does not reflect the number of actually executed (retired) |hpx|-threads.
     * None
   * * ``/scheduler/utilization/instantaneous``

       .. _scheduler-utilization-instantaneous:

       :ref:`🔗<scheduler-utilization-instantaneous>`

     * ``locality#*/total``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       (instantaneous) scheduler utilization queried for. The :term:`locality`
       id (given by ``*`` is a (zero based) number identifying the
       :term:`locality`.
     * Returns the total (instantaneous) scheduler utilization. This is the
        current percentage of scheduler threads executing |hpx| threads.
     * Percent
   * * ``/threads/idle-loop-count/instantaneous``

       .. _threads-idle-loop-count-instantaneous:

       :ref:`🔗<threads-idle-loop-count-instantaneous>`
       
     * ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       current accumulated value of all idle-loop counters of all worker threads
       should be queried. The :term:`locality` id (given by ``*`` is a (zero
       based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the current
       value of the idle-loop counter should be queried for. The worker thread
       number (given by the ``*`` is a (zero based) worker thread number (given
       by the ``*`` is a (zero based) number identifying the worker thread. The
       number of available worker threads is usually specified on the command
       line for the application using the option :option:`--hpx:threads`. If no
       pool-name is specified the counter refers to the 'default' pool.
     * Returns the current (instantaneous) idle-loop count for the given
       |hpx|- worker thread or the accumulated value for all worker threads.
     * None
   * * ``/threads/busy-loop-count/instantaneous``

       .. _threads-busy-loop-count-instantaneous:

       :ref:`🔗<threads-busy-loop-count-instantaneous>`
       
     * ``locality#*/worker-thread#*`` or

       ``locality#*/pool#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       current accumulated value of all busy-loop counters of all worker threads
       should be queried. The :term:`locality` id (given by ``*`` is a (zero
       based) number identifying the :term:`locality`.

       ``pool#*`` is defining the pool for which the current value of the
       idle-loop counter should be queried for.

       ``worker-thread#*`` is defining the worker thread for which the current
       value of the busy-loop counter should be queried for. The worker thread
       number (given by the ``*`` is a (zero based) worker thread number (given
       by the ``*`` is a (zero based) number identifying the worker thread. The
       number of available worker threads is usually specified on the command
       line for the application using the option :option:`--hpx:threads`. If no
       pool-name is specified the counter refers to the 'default' pool.
     * Returns the current (instantaneous) busy-loop count for the given |hpx|-
       worker thread or the accumulated value for all worker threads.
     * None
   * * ``/threads/time/background-work-duration``

       .. _threads-time-background-work-duration:

       :ref:`🔗<threads-time-background-work-duration>`
       
     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the overall time spent
       performing background work should be queried for. The locality id (given
       by ``*``) is a (zero based) number identifying the locality.

       ``worker-thread#*`` is defining the worker thread for which the overall
       time spent performing background work should be queried for. The worker
       thread number (given by the ``*``) is a (zero based) number identifying
       the worker thread. The number of available worker threads is usually
       specified on the command line for the application using the option
       :option:`--hpx:threads`.

     * Returns the overall time spent performing background work on the given
       locality since application start. If the instance name is ``total`` the
       counter returns the overall time spent performing background work for all
       worker threads (cores) on that locality. If the instance name is
       ``worker-thread#*`` the counter will return the overall time spent
       performing background work for all worker threads separately. This
       counter is available only if the configuration time constants
       ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure for this counter is nanosecond [ns].

     * None
   * * ``/threads/background-overhead``

       .. _threads-background-overhead:

       :ref:`🔗<threads-background-overhead>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the background overhead
       should be queried for. The locality id (given by ``*``) is a (zero based)
       number identifying the locality.

       ``worker-thread#*`` is defining the worker thread for which the
       background overhead should be queried for. The worker thread number
       (given by the ``*``) is a (zero based) number identifying the worker
       thread. The number of available worker threads is usually specified on
       the command line for the application using the option
       :option:`--hpx:threads`.
     * Returns the background overhead on the given locality since application
       start. If the instance name is ``total`` the counter returns the
       background overhead for all worker threads (cores) on that locality. If
       the instance name is ``worker-thread#*`` the counter will return
       background overhead for all worker threads separately. This counter is
       available only if the configuration time constants
       ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure displayed for this counter is 0.1%.
     * None
   * * ``/threads/time/background-send-duration``

       .. _threads-time-background-send-duration:

       :ref:`🔗<threads-time-background-send-duration>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the overall time spent
       performing background work related to sending parcels should be queried
       for. The locality id (given by ``*``) is a (zero based) number
       identifying the locality.

       ``worker-thread#*`` is defining the worker thread for which the overall
       time spent performing background work related to sending parcels should
       be queried for. The worker thread number (given by the ``*``) is a (zero
       based) number identifying the worker thread. The number of available
       worker threads is usually specified on the command line for the
       application using the option :option:`--hpx:threads`.

     * Returns the overall time spent performing background work related to
       sending parcels on the given locality since application start. If the
       instance name is ``total`` the counter returns the overall time spent
       performing background work for all worker threads (cores) on that
       locality. If the instance name is ``worker-thread#*`` the counter will
       return the overall time spent performing background work for all worker
       threads separately. This counter is available only if the configuration
       time constants ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``)
       and ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``).
       The unit of measure for this counter is nanosecond [ns].

       This counter will currently return meaningful values for the MPI
       parcelport only.

     * None
   * * ``/threads/background-send-overhead``

       .. _threads-background-send-overhead:

       :ref:`🔗<threads-background-send-overhead>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the background overhead
       related to sending parcels should be queried for. The locality id (given
       by ``*``) is a (zero based) number identifying the locality.

       ``worker-thread#*`` is defining the worker thread for which the
       background overhead related to sending parcels should be queried for.
       The worker thread number (given by the ``*``) is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the option
       :option:`--hpx:threads`.
     * Returns the background overhead related to sending parcels on the given
       locality since application start. If the instance name is ``total`` the
       counter returns the background overhead for all worker threads (cores) on
       that locality. If the instance name is ``worker-thread#*`` the counter
       will return background overhead for all worker threads separately. This
       counter is available only if the configuration time constants
       ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure displayed for this counter is 0.1%.

       This counter will currently return meaningful values for the MPI
       parcelport only.
     * None
   * * ``/threads/time/background-receive-duration``

       .. _threads-time-background-receive-duration:

       :ref:`🔗<threads-time-background-receive-duration>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the overall time spent
       performing background work related to receiving parcels should be queried
       for. The locality id (given by ``*``) is a (zero based) number identifying
       the locality.

       ``worker-thread#*`` is defining the worker thread for which the overall
       time spent performing background work related to receiving parcels should
       be queried for. The worker thread number (given by the ``*``) is a (zero
       based) number identifying the worker thread. The number of available
       worker threads is usually specified on the command line for the
       application using the option :option:`--hpx:threads`.

     * Returns the overall time spent performing background work related to
       receiving parcels on the given locality since application start. If the
       instance name is ``total`` the counter returns the overall time spent
       performing background work for all worker threads (cores) on that
       locality. If the instance name is ``worker-thread#*`` the counter will
       return the overall time spent performing background work for all worker
       threads separately. This counter is available only if the configuration
       time constants ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``)
       and ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``).
       The unit of measure for this counter is nanosecond [ns].

       This counter will currently return meaningful values for the MPI
       parcelport only.
     * None
   * * ``/threads/background-receive-overhead``

       .. _threads-background-receive-overhead:
       
       :ref:`🔗<threads-background-receive-overhead>`

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the locality for which the background overhead
       related to receiving should be queried for. The locality id (given by
       ``*``) is a (zero based) number identifying the locality.

       ``worker-thread#*`` is defining the worker thread for which the
       background overhead related to receiving parcels should be queried for.
       The worker thread number (given by the ``*``) is a (zero based) number
       identifying the worker thread. The number of available worker threads is
       usually specified on the command line for the application using the option
       :option:`--hpx:threads`.
     * Returns the background overhead related to receiving parcels on the given
       locality since application start. If the instance name is ``total`` the
       counter returns the background overhead for all worker threads (cores) on
       that locality. If the instance name is ``worker-thread#*`` the counter
       will return background overhead for all worker threads separately. This
       counter is available only if the configuration time constants
       ``HPX_WITH_BACKGROUND_THREAD_COUNTERS`` (default: ``OFF``) and
       ``HPX_WITH_THREAD_IDLE_RATES`` are set to ``ON`` (default: ``OFF``). The
       unit of measure displayed for this counter is 0.1%.

       This counter will currently return meaningful values for the MPI
       parcelport only.
     * None

.. list-table:: General performance counters exposing characteristics of localities

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/runtime/count/component``

       .. _runtime-count-component: 

       :ref:`🔗<runtime-count-component>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       components should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall number of currently active components of the
       specified type on the given :term:`locality`.
     * The type of the component. This is the string which has been used while
       registering the component with |hpx|, e.g. which has been passed as the
       second parameter to the macro :c:macro:`HPX_REGISTER_COMPONENT`.
   * * ``/runtime/count/action-invocation``

       .. _runtime-count-action-invocation: 

       :ref:`🔗<runtime-count-action-invocation>`

     * ``locality#*/total``

         where:

       ``*`` is the :term:`locality` id of the locality the number of action
       invocations should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall (local) invocation count of the specified action type
       on the given :term:`locality`.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`.
   * * ``/runtime/count/remote-action-invocation``

       .. _runtime-count-remote-action-invocation:

       :ref:`🔗<runtime-count-remote-action-invocation>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       action invocations should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the overall (remote) invocation count of the specified action
       type on the given :term:`locality`.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`.
   * * ``/runtime/uptime``

       .. _runtime-uptime:

       :ref:`🔗<runtime-uptime>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the system
       uptime should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the overall time since application start on the given
       :term:`locality` in nanoseconds.
     * None
   * * ``/runtime/memory/virtual``

       .. _runtime-memory-virtual:

       :ref:`🔗<runtime-memory-virtual>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the allocated
       virtual memory should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the amount of virtual memory currently allocated by the
       referenced :term:`locality` (in bytes).
     * None
   * * ``/runtime/memory/resident``

       .. _runtime-memory-resident:

       :ref:`🔗<runtime-memory-resident>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the allocated
       resident memory should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the amount of resident memory currently allocated by the
       referenced :term:`locality` (in bytes).
     * None
   * * ``/runtime/memory/total``

       .. _runtime-memory-total:

       :ref:`🔗<runtime-memory-total>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the total
       available memory should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`. Note: only supported in
       Linux.
     * Returns the total available memory for use by the referenced
        :term:`locality` (in bytes). This counter is available on Linux and
        Windows systems only.
     * None
   * * ``/runtime/io/read_bytes_issued``

       .. _runtime-io-read-bytes-issued:

       :ref:`🔗<runtime-io-read-bytes-issued>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       bytes read should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the number of bytes read by the process (aggregate of count
       arguments passed to read() call or its analogues). This performance
       counter is available only on systems which expose the related data
       through the /proc file system.
     * None
   * * ``/runtime/io/write_bytes_issued``

       .. _runtime-io-write-bytes-issued:

       :ref:`🔗<runtime-io-write-bytes-issued>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       bytes written should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the number of bytes written by the process (aggregate of count
       arguments passed to write() call or its analogues). This performance
       counter is available only on systems which expose the related data
       through the /proc file system.
     * None
   * * ``/runtime/io/read_syscalls``

       .. _runtime-io-read-syscalls:

       :ref:`🔗<runtime-io-read-syscalls>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       system calls should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the number of system calls that perform I/O reads. This
       performance counter is available only on systems which expose the
       related data through the /proc file system.
     * None
   * * ``/runtime/io/write_syscalls``

       .. _runtime-io-write-syscalls:

       :ref:`🔗<runtime-io-write-syscalls>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       system calls should be queried. The :term:`locality` id is a (zero based)
       number identifying the :term:`locality`.
     * Returns the number of system calls that perform I/O writes. This
       performance counter is available only on systems which expose the
       related data through the /proc file system.
     * None
   * * ``/runtime/io/read_bytes_transferred``

       .. _runtime-io-read-bytes-transferred:

       :ref:`🔗<runtime-io-read-bytes-transferred>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       bytes transferred should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the number of bytes retrieved from storage by I/O operations.
       This performance counter is available only on systems which expose the
       related data through the /proc file system.
     * None
   * * ``/runtime/io/write_bytes_transferred``

       .. _runtime-io-write-bytes-transferred:

       :ref:`🔗<runtime-io-write-bytes-transferred>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       bytes transferred should be queried. The :term:`locality` id is a (zero
       based) number identifying the :term:`locality`.
     * Returns the number of bytes retrieved from storage by I/O operations.
       This performance counter is available only on systems which expose the
       related data through the /proc file system.
     * None
   * * ``/runtime/io/write_bytes_cancelled``

       .. _runtime-io-write-bytes-cancelled:

       :ref:`🔗<runtime-io-write-bytes-cancelled>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       bytes not being transferred should be queried. The :term:`locality` id is
       a (zero based) number identifying the :term:`locality`.
     * Returns the number of bytes accounted by write_bytes_transferred that
       has not been ultimately stored due to truncation or deletion. This
       performance counter is available only on systems which expose the
       related data through the /proc file system.
     * None

.. list-table:: Performance counters exposing PAPI hardware counters

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/papi/<papi_event>``

       .. _papi-papi-event:

       :ref:`🔗<papi-papi-event>`

       where:

       ``<papi_event>`` is the name of the PAPI event to expose as a performance
       counter (such as ``PAPI_SR_INS``). Note that the list of available PAPI
       events changes depending on the used architecture.

       For a full list of available PAPI events and their (short) description
       use the ``--hpx:list-counters`` and ``--hpx:papi-event-info=all`` command
       line options.

     * ``locality#*/total`` or

       ``locality#*/worker-thread#*``

       where:

       ``locality#*`` is defining the :term:`locality` for which the current
       current accumulated value of all busy-loop counters of all worker threads
       should be queried. The :term:`locality` id (given by ``*``) is a (zero
       based) number identifying the :term:`locality`.

       ``worker-thread#*`` is defining the worker thread for which the current
       value of the busy-loop counter should be queried for. The worker thread
       number (given by the ``*``) is a (zero based) worker thread number (given
       by the ``*``) is a (zero based) number identifying the worker thread. The
       number of available worker threads is usually specified on the command
       line for the application using the option :option:`--hpx:threads`.

     * This counter returns the current count of occurrences of the specified
       PAPI event. This counter is available only if the configuration time
       constant ``HPX_WITH_PAPI`` is set to ``ON`` (default: ``OFF``).
     * None

.. list-table:: Performance counters for general statistics

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/statistics/average``

       .. _statistics-average:

       :ref:`🔗<statistics-average>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current average (mean) value calculated based on the values
       queried from the underlying counter (the one specified as the instance
       name).
     * Any parameter will be interpreted as a list of up to two comma separated
       (integer) values, where the first is the time interval (in milliseconds)
       at which the underlying counter should be queried. If no value is
       specified, the counter will assume ``1000`` [ms] as the default. The
       second value can be either ``0`` or ``1`` and specifies whether the
       underlying counter should be reset during evaluation ``1`` or not ``0``.
       The default value is ``0``.

   * * ``/statistics/rolling_average``

       .. _statistics-rolling-average:

       :ref:`🔗<statistics-rolling-average>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current rolling average (mean) value calculated based on the
       values queried from the underlying counter (the one specified as the
       instance name).
     * Any parameter will be interpreted as a list of up to three comma
       separated (integer) values, where the first is the time interval (in
       milliseconds) at which the underlying counter should be queried. If no
       value is specified, the counter will assume ``1000`` [ms] as the default.
       The second value will be interpreted as the size of the rolling window
       (the number of latest values to use to calculate the rolling average).
       The default value for this is ``10``. The third value can be
       either ``0`` or ``1`` and specifies whether the underlying counter should
       be reset during evaluation ``1`` or not ``0``. The default value is ``0``.

   * * ``/statistics/stddev``

       .. _statistics-stddev:

       :ref:`🔗<statistics-stddev>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current standard deviation (stddev) value calculated based on
       the values queried from the underlying counter (the one specified as the
       instance name).
     * Any parameter will be interpreted as a list of up to two comma separated
       (integer) values, where the first is the time interval (in milliseconds)
       at which the underlying counter should be queried. If no value is
       specified, the counter will assume ``1000`` [ms] as the default. The
       second value can be either ``0`` or ``1`` and specifies whether the
       underlying counter should be reset during evaluation ``1`` or not ``0``.
       The default value is ``0``.

   * * ``/statistics/rolling_stddev``

       .. _statistics-rolling-stddev:

       :ref:`🔗<statistics-rolling-stddev>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current rolling variance (stddev) value calculated based on
       the values queried from the underlying counter (the one specified as the
       instance name).
     * Any parameter will be interpreted as a list of up to three comma
       separated (integer) values, where the first is the time interval (in
       milliseconds) at which the underlying counter should be queried. If no
       value is specified, the counter will assume ``1000`` [ms] as the default.
       The second value will be interpreted as the size of the rolling window
       (the number of latest values to use to calculate the rolling average).
       The default value for this is ``10``. The third value can be either ``0``
       or ``1`` and specifies whether the underlying counter should be reset
       during evaluation ``1`` or not ``0``. The default value is ``0``.

   * * ``/statistics/median``

       .. _statistics-median:

       :ref:`🔗<statistics-median>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current (statistically estimated) median value calculated
       based on the values queried from the underlying counter (the one
       specified as the instance name).
     * Any parameter will be interpreted as a list of up to two comma separated
       (integer) values, where the first is the time interval (in milliseconds)
       at which the underlying counter should be queried. If no value is
       specified, the counter will assume ``1000`` [ms] as the default. The
       second value can be either ``0`` or ``1`` and specifies whether the
       underlying counter should be reset during evaluation ``1`` or not ``0``.
       The default value is ``0``.

   * * ``/statistics/max``

       .. _statistics-max:

       :ref:`🔗<statistics-max>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current maximum value calculated based on the values queried
       from the underlying counter (the one specified as the instance name).
     * Any parameter will be interpreted as a list of up to two comma separated
       (integer) values, where the first is the time interval (in milliseconds)
       at which the underlying counter should be queried. If no value is
       specified, the counter will assume ``1000`` [ms] as the default. The
       second value can be either ``0`` or ``1`` and specifies whether the
       underlying counter should be reset during evaluation ``1`` or not ``0``.
       The default value is ``0``.

   * * ``/statistics/rolling_max``

       .. _statistics-rolling-max:

       :ref:`🔗<statistics-rolling-max>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current rolling maximum value calculated based on the values
       queried from the underlying counter (the one specified as the instance
       name).
     * Any parameter will be interpreted as a list of up to three comma
       separated (integer) values, where the first is the time interval (in
       milliseconds) at which the underlying counter should be queried. If no
       value is specified, the counter will assume ``1000`` [ms] as the default.
       The second value will be interpreted as the size of the rolling window
       (the number of latest values to use to calculate the rolling average).
       The default value for this is ``10``. The third value can be either ``0``
       or ``1`` and specifies whether the underlying counter should be reset
       during evaluation ``1`` or not ``0``. The default value is ``0``.

   * * ``/statistics/min``

       .. _statistics-min:

       :ref:`🔗<statistics-min>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current minimum value calculated based on the values queried
       from the underlying counter (the one specified as the instance name).
     * Any parameter will be interpreted as a list of up to two comma separated
       (integer) values, where the first is the time interval (in milliseconds)
       at which the underlying counter should be queried. If no value is
       specified, the counter will assume ``1000`` [ms] as the default. The
       second value can be either ``0`` or ``1`` and specifies whether the
       underlying counter should be reset during evaluation ``1`` or not ``0``.
       The default value is ``0``.

   * * ``/statistics/rolling_min``

       .. _statistics-rolling-min:

       :ref:`🔗<statistics-rolling-min>`

     * Any full performance counter name. The referenced performance counter is
       queried at fixed time intervals as specified by the first parameter.
     * Returns the current rolling minimum value calculated based on the values
       queried from the underlying counter (the one specified as the instance
       name).
     * Any parameter will be interpreted as a list of up to three comma
       separated (integer) values, where the first is the time interval (in
       milliseconds) at which the underlying counter should be queried. If no
       value is specified, the counter will assume ``1000`` [ms] as the default.
       The second value will be interpreted as the size of the rolling window
       (the number of latest values to use to calculate the rolling average).
       The default value for this is ``10``. The third value can be either ``0``
       or ``1`` and specifies whether the underlying counter should be reset
       during evaluation ``1`` or not ``0``. The default value is ``0``.

.. list-table:: Performance counters for elementary arithmetic operations

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters
   * * ``/arithmetics/add``

       .. _arithmetics-add:

       :ref:`🔗<arithmetics-add>`
   
     * None
     * Returns the sum calculated based on the values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/subtract``

       .. _arithmetics-subtract:

       :ref:`🔗<arithmetics-subtract>`

     * None
     * Returns the difference calculated based on the values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/multiply``

       .. _arithmetics-multiply:

       :ref:`🔗<arithmetics-multiply>`

     * None
     * Returns the product calculated based on the values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/divide``

          .. _arithmetics-divide:

       :ref:`🔗<arithmetics-divide>`

     * None
     * Returns the result of division of the values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/mean``

       .. _arithmetics-mean:

       :ref:`🔗<arithmetics-mean>`

     * None
     * Returns the average value of all values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/variance``

       .. _arithmetics-variance:

       :ref:`🔗<arithmetics-variance>`

     * None
     * Returns the standard deviation of all values queried from the underlying
       counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/median``

       .. _arithmetics-median:

       :ref:`🔗<arithmetics-median>`

     * None
     * Returns the median value of all values queried from the underlying
       counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/min``

       .. _arithmetics-min:

       :ref:`🔗<arithmetics-min>`

     * None
     * Returns the minimum value of all values queried from the underlying
       counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/max``

       .. _arithmetics-max:

       :ref:`🔗<arithmetics-max>`

     * None
     * Returns the maximum value of all values queried from the
       underlying counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.
   * * ``/arithmetics/count``

       .. _arithmetics-count:

       :ref:`🔗<arithmetics-count>`

     * None
     * Returns the count value of all values queried from the underlying
       counters (the ones specified as the parameters).
     * The parameter will be interpreted as a comma separated list of full
       performance counter names which are queried whenever this counter is
       accessed. Any wildcards in the counter names will be expanded.

.. note::

   The ``/arithmetics`` counters can consume an arbitrary number of other
   counters. For this reason those have to be specified as parameters (a comma
   separated list of counters appended after a ``'@'``). For instance:

   .. code-block:: shell-session

      $ ./bin/hello_world_distributed -t2 \
          --hpx:print-counter=/threads{locality#0/worker-thread#*}/count/cumulative \
          --hpx:print-counter=/arithmetics/add@/threads{locality#0/worker-thread#*}/count/cumulative
      hello world from OS-thread 0 on locality 0
      hello world from OS-thread 1 on locality 0
      /threads{locality#0/worker-thread#0}/count/cumulative,1,0.515640,[s],25
      /threads{locality#0/worker-thread#1}/count/cumulative,1,0.515520,[s],36
      /arithmetics/add@/threads{locality#0/worker-thread#*}/count/cumulative,1,0.516445,[s],64

   Since all wildcards in the parameters are expanded, this example is fully
   equivalent to specifying both counters separately to ``/arithmetics/add``:

   .. code-block:: shell-session

      $ ./bin/hello_world_distributed -t2 \
          --hpx:print-counter=/threads{locality#0/worker-thread#*}/count/cumulative \
          --hpx:print-counter=/arithmetics/add@\
              /threads{locality#0/worker-thread#0}/count/cumulative,\
              /threads{locality#0/worker-thread#1}/count/cumulative

.. list-table:: Performance counters tracking :term:`parcel` coalescing

   * * Counter type
     * Counter instance formatting
     * Description
     * Parameters

   * * ``/coalescing/count/parcels``

       .. _coalescing-count-parcels:

       :ref:`🔗<coalescing-count-parcels>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       parcels for the given action should be queried for. The :term:`locality`
       id is a (zero based) number identifying the :term:`locality`.
     * Returns the number of parcels handled by the message handler
       associated with the action which is given by the counter parameter.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`.

   * * ``/coalescing/count/messages``

       .. _coalescing-count-messages:

       :ref:`🔗<coalescing-count-messages>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       messages for the given action should be queried for. The :term:`locality`
       id is a (zero based) number identifying the :term:`locality`.
     * Returns the number of messages generated by the message handler
       associated with the action which is given by the counter parameter.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`.

   * * ``/coalescing/count/average-parcels-per-message``

       .. _coalescing-count-average-parcels-per-message:

       :ref:`🔗<coalescing-count-average-parcels-per-message>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the number of
       messages for the given action should be queried for. The :term:`locality`
       id is a (zero based) number identifying the :term:`locality`.
     * Returns the average number of parcels sent in a message generated by the
       message handler associated with the action which is given by the counter
       parameter.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`

   * * ``/coalescing/time/average-parcel-arrival``

       .. _coalescing-time-average-parcel-arrival:

       :ref:`🔗<coalescing-time-average-parcel-arrival>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the average time
       between parcels for the given action should be queried for. The
       :term:`locality` id is a (zero based) number identifying the
       :term:`locality`.
     * Returns the average time between arriving parcels for the
       action which is given by the counter parameter.
     * The action type. This is the string which has been used while registering
       the action with |hpx|, e.g. which has been passed as the second parameter
       to the macro :c:macro:`HPX_REGISTER_ACTION` or
       :c:macro:`HPX_REGISTER_ACTION_ID`

   * * ``/coalescing/time/parcel-arrival-histogram``

       .. _coalescing-time-parcel-arrival-histogram:

       :ref:`🔗<coalescing-time-parcel-arrival-histogram>`

     * ``locality#*/total``

       where:

       ``*`` is the :term:`locality` id of the :term:`locality` the average time
       between parcels for the given action should be queried for. The
       :term:`locality` id is a (zero based) number identifying the
       :term:`locality`.
     * Returns a histogram representing the times between arriving parcels for
       the action which is given by the counter parameter.

       This counter returns an array of values, where the first three values
       represent the three parameters used for the histogram followed by one
       value for each of the histogram buckets.

       The first unit of measure displayed for this counter ``[ns]`` refers to
       the lower and upper boundary values in the returned histogram data only.
       The second unit of measure displayed ``[0.1%]`` refers to the actual
       histogram data.

       For each bucket the counter shows a value between ``0`` and ``1000``
       which corresponds to a percentage value between ``0%`` and ``100%``.

     * The action type and optional histogram parameters. The action type is
       the string which has been used while registering the action with |hpx|,
       e.g. which has been passed as the second parameter to the macro
       :c:macro:`HPX_REGISTER_ACTION` or :c:macro:`HPX_REGISTER_ACTION_ID`.

       The action type may be followed by a comma separated list of up-to three
       numbers: the lower and upper boundaries for the collected histogram, and
       the number of buckets for the histogram to generate. By default these
       three numbers will be assumed to be ``0`` (``[ns]``, lower
       bound), ``1000000`` (``[ns]``, upper bound), and ``20`` (number of
       buckets to generate).

.. note::

   The performance counters related to :term:`parcel` coalescing are available only if
   the configuration time constant ``HPX_WITH_PARCEL_COALESCING`` is set to
   ``ON`` (default: ``ON``). However, even in this case it will be available
   only for actions that are enabled for parcel coalescing (see the
   macros :c:macro:`HPX_ACTION_USES_MESSAGE_COALESCING` and
   :c:macro:`HPX_ACTION_USES_MESSAGE_COALESCING_NOTHROW`).

.. [#] A message can potentially consist of more than one :term:`parcel`.

APEX integration
================

|hpx| provides integration with |apex|_, which is a framework for application
profiling using task timers and various performance counters :footcite:t:`2015:apex`.
It can be added as a ``git`` submodule by turning on the option :option:`HPX_WITH_APEX:BOOL`
during |cmake| configuration. |tau|_ is an optional dependency when using |apex|.

To build |hpx| with |apex|, add :option:`HPX_WITH_APEX`\ ``=ON``, and,
optionally, ``TAU_ROOT=$PATH_TO_TAU`` to your |cmake| configuration. In
addition, you can override the tag used for |apex| with the
:option:`HPX_WITH_APEX_TAG` option. Please see the |apex_hpx_doc|_ for detailed
instructions on using |apex| with |hpx|.

References
==========

.. footbibliography::
..
    Copyright (C) 2018 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============================
Debugging |hpx| applications
============================

Using a debugger with |hpx| applications
========================================

Using a debugger such as ``gdb`` with |hpx| applications is no problem. However,
there are some things to keep in mind to make the experience somewhat more
productive.

Call stacks in |hpx| can often be quite unwieldy as the library is heavily
templated and the call stacks can be very deep. For this reason it is sometimes
a good idea compile |hpx| in ``RelWithDebInfo`` mode, which applies some
optimizations but keeps debugging symbols. This can often compress call stacks
significantly. On the other hand, stepping through the code can also be more
difficult because of statements being reordered and variables being optimized
away. Also, note that because |hpx| implements user-space threads and context
switching, call stacks may not always be complete in a debugger.

|hpx| launches not only worker threads but also a few helper threads. The first
thread is the main thread, which typically does no work in an |hpx| application,
except at startup and shutdown. If using the default settings, |hpx| will spawn
six additional threads (used for service thread pools). The first worker thread
is usually the eighth thread, and most user codes will be run on these worker
threads. The last thread is a helper thread used for |hpx| shutdown.

Finally, since |hpx| is a multi-threaded runtime, the following ``gdb`` options
can be helpful:

.. code-block:: text

   set pagination off
   set non-stop on

Non-stop mode allows users to have a single thread stop on a breakpoint without
stopping all other threads as well.

Using sanitizers with |hpx| applications
========================================

.. warning::

   Not all parts of |hpx| are sanitizer clean. This means that users may end up
   with false positives from |hpx| itself when using sanitizers for their
   applications.

To use sanitizers with |hpx|, turn on ``HPX_WITH_SANITIZERS`` and turn
off ``HPX_WITH_STACKOVERFLOW_DETECTION`` during |cmake| configuration. It's
recommended to also build |boost| with the same sanitizers that will be
used for |hpx|. The appropriate sanitizers can then be enabled using |cmake| by
appending ``-fsanitize=address -fno-omit-frame-pointer`` to ``CMAKE_CXX_FLAGS``
and ``-fsanitize=address`` to ``CMAKE_EXE_LINKER_FLAGS``. Replace ``address``
with the sanitizer that you want to use.

.. _debugging_core:

Debugging applications using core files
========================================

For |hpx| to generate useful core files, |hpx| has to be compiled without signal
and exception handlers
:option:`HPX_WITH_DISABLED_SIGNAL_EXCEPTION_HANDLERS:BOOL`. If this option is
not specified, the signal handlers change the application state. For example,
after a segmentation fault the stack trace will show the signal handler.
Similarly, unhandled exceptions are also caught by these handlers and the
stack trace will not point to the location where the unhandled exception was
thrown.

In general, core files are a helpful tool to inspect the state of the
application at the moment of the crash (post-mortem debugging), without the need
of attaching a debugger beforehand. This approach to debugging is especially
useful if the error cannot be reliably reproduced, as only a single crashed
application run is required to gain potentially helpful information like a
stacktrace.

To debug with core files, the operating system first has to be told to actually
write them. On most Unix systems this can be done by calling:

.. code-block:: shell-session

   $ ulimit -c unlimited

in the shell. Now the debugger can be started up with:

.. code-block:: shell-session

   $ gdb <application> <core file name>

The debugger should now display the last state of the application. The default
file name for core files is ``core``.
..
    Copyright (C) 2007-2014 Hartmut Kaiser
    Copyright (C) 2011 Bryce Lelbach
    Copyright (C) 2013 Pyry Jahkola
    Copyright (C) 2013 Thomas Heller

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _running_on_batch_systems:

========================
Running on batch systems
========================

This section walks you through launching |hpx| applications on various batch
systems.

.. _unix_pbs:

How to use |hpx| applications with PBS
======================================

Most |hpx| applications are executed on parallel computers. These platforms
typically provide integrated job management services that facilitate the
allocation of computing resources for each parallel program. |hpx| includes
support for one of the most common job management systems, the
Portable Batch System (PBS).

All PBS jobs require a script to specify the resource requirements and other
parameters associated with a parallel job. The PBS script is basically a shell
script with PBS directives placed within commented sections at the beginning of
the file. The remaining (not commented-out) portions of the file executes just
like any other regular shell script. While the description of all available PBS
options is outside the scope of this tutorial (the interested reader may refer
to in-depth `documentation <http://www.clusterresources.com/torquedocs21/>`_ for
more information), below is a minimal example to illustrate the approach. The following
test application will use the multithreaded ``hello_world_distributed``
program, explained in the section :ref:`examples_hello_world`.

.. code-block:: bash

   #!/bin/bash
   #
   #PBS -l nodes=2:ppn=4

   APP_PATH=~/packages/hpx/bin/hello_world_distributed
   APP_OPTIONS=

   pbsdsh -u $APP_PATH $APP_OPTIONS --hpx:nodes=`cat $PBS_NODEFILE`

.. caution::

   If the first application specific argument (inside ``$APP_OPTIONS``) is a
   non-option (i.e., does not start with a ``-`` or a ``--``), then the argument has to
   be placed before the option :option:`--hpx:nodes`, which, in this case, should
   be the last option on the command line.

   Alternatively, use the option :option:`--hpx:endnodes` to explicitly mark the
   end of the list of node names:

   .. code-block:: shell-session

      $ pbsdsh -u $APP_PATH --hpx:nodes`cat $PBS_NODEFILE` --hpx:endnodes $APP_OPTIONS

The ``#PBS -l nodes=2:ppn=4`` directive will cause two compute nodes to be
allocated for the application, as specified in the option ``nodes``. Each of the
nodes will dedicate four cores to the program, as per the option ``ppn``, short
for "processors per node" (PBS does not distinguish between processors and
cores). Note that requesting more cores per node than physically available is
pointless and may prevent PBS from accepting the script.

On newer PBS versions the PBS command syntax might be different. For instance,
the PBS script above would look like:

.. code-block:: bash

   #!/bin/bash
   #
   #PBS -l select=2:ncpus=4

   APP_PATH=~/packages/hpx/bin/hello_world_distributed
   APP_OPTIONS=

   pbsdsh -u $APP_PATH $APP_OPTIONS --hpx:nodes=`cat $PBS_NODEFILE`

``APP_PATH`` and ``APP_OPTIONS`` are shell variables that respectively specify
the correct path to the executable (``hello_world_distributed`` in this case)
and the command line options. Since the ``hello_world_distributed`` application
doesn't need any command line options, ``APP_OPTIONS`` has been left empty.
Unlike in other execution environments, there is no need to use the
:option:`--hpx:threads` option to indicate the required number of OS threads per
node; the |hpx| library will derive this parameter automatically from PBS.

Finally, |pbsdsh| is a PBS command that starts tasks to the resources allocated
to the current job. It is recommended to leave this line as shown and modify
only the PBS options and shell variables as needed for a specific application.

.. important::

   A script invoked by |pbsdsh| starts in a very basic environment: the user's
   ``$HOME`` directory is defined and is the current directory, the ``LANG``
   variable is set to ``C`` and the ``PATH`` is set to the basic
   ``/usr/local/bin:/usr/bin:/bin`` as defined in a system-wide file
   pbs_environment. Nothing that would normally be set up by a system shell
   profile or user shell profile is defined, unlike the environment for the main
   job script.

Another choice is for the |pbsdsh| command in your main job script to invoke
your program via a shell, like ``sh`` or ``bash``, so that it gives an initialized
environment for each instance. Users can create a small script ``runme.sh``, which is used
to invoke the program:

.. code-block:: bash

   #!/bin/bash
   # Small script which invokes the program based on what was passed on its
   # command line.
   #
   # This script is executed by the bash shell which will initialize all
   # environment variables as usual.
   $@

Now, the script is invoked using the |pbsdsh| tool:

.. code-block:: bash

   #!/bin/bash
   #
   #PBS -l nodes=2:ppn=4

   APP_PATH=~/packages/hpx/bin/hello_world_distributed
   APP_OPTIONS=

   pbsdsh -u runme.sh $APP_PATH $APP_OPTIONS --hpx:nodes=`cat $PBS_NODEFILE`

All that remains now is submitting the job to the queuing system. Assuming that
the contents of the PBS script were saved in the file ``pbs_hello_world.sh`` in the
current directory, this is accomplished by typing:

.. code-block:: shell-session

   $ qsub ./pbs_hello_world_pbs.sh

If the job is accepted, |qsub| will print out the assigned job ID, which may
look like:

.. code-block:: shell-session

   $ 42.supercomputer.some.university.edu

To check the status of your job, issue the following command:

.. code-block:: shell-session

   $ qstat 42.supercomputer.some.university.edu

and look for a single-letter job status symbol. The common cases include:

* *Q* - signifies that the job is queued and awaiting its turn to be executed.
* *R* - indicates that the job is currently running.
* *C* - means that the job has completed.

The example |qstat| output below shows a job waiting for execution resources
to become available:

.. code-block:: text

   Job id                    Name             User            Time Use S Queue
   ------------------------- ---------------- --------------- -------- - -----
   42.supercomputer          ...ello_world.sh joe_user               0 Q batch

After the job completes, PBS will place two files, ``pbs_hello_world.sh.o42`` and
``pbs_hello_world.sh.e42``, in the directory where the job was submitted. The
first contains the standard output and the second contains the standard error
from all the nodes on which the application executed. In our example, the error
output file should be empty and the standard output file should contain something
similar to:

.. code-block:: text

   hello world from OS-thread 3 on locality 0
   hello world from OS-thread 2 on locality 0
   hello world from OS-thread 1 on locality 1
   hello world from OS-thread 0 on locality 0
   hello world from OS-thread 3 on locality 1
   hello world from OS-thread 2 on locality 1
   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 1

Congratulations! You have just run your first distributed |hpx| application!

.. _unix_slurm:

How to use |hpx| applications with SLURM
========================================

Just like PBS (described in section :ref:`unix_pbs`), |slurm| is a job
management system which is widely used on large supercomputing systems. Any
|hpx| application can easily be run using SLURM. This section describes how this
can be done.

The easiest way to run an |hpx| application using SLURM is to utilize the
command line tool |srun|, which interacts with the SLURM batch scheduling system:

.. code-block:: shell-session

   $ srun -p <partition> -N <number-of-nodes> hpx-application <application-arguments>

Here, ``<partition>`` is one of the node partitions existing on the target
machine (consult the machine's documentation to get a list of existing
partitions) and ``<number-of-nodes>`` is the number of compute nodes that should
be used. By default, the |hpx| application is started with one :term:`locality` per
node and uses all available cores on a node. You can change the number of
localities started per node (for example, to account for NUMA effects) by
specifying the ``-n`` option of srun. The number of cores per :term:`locality`
can be set by ``-c``. The ``<application-arguments>`` are any application
specific arguments that need to be passed on to the application.

.. note::

   There is no need to use any of the |hpx| command line options related to the
   number of localities, number of threads, or related to networking ports. All
   of this information is automatically extracted from the SLURM environment by
   the |hpx| startup code.

.. important::

   The |srun| documentation explicitly states: "If ``-c`` is specified without
   ``-n``, as many tasks will be allocated per node as possible while satisfying
   the ``-c`` restriction. For instance on a cluster with 8 CPUs per node, a job
   request for 4 nodes and 3 CPUs per task may be allocated 3 or 6 CPUs per node
   (1 or 2 tasks per node) depending upon resource consumption by other jobs."
   For this reason, it's recommended to always specify ``-n <number-of-instances>``,
   even if ``<number-of-instances>`` is equal to one (``1``).

Interactive shells
------------------

To get an interactive development shell on one of the nodes, users can issue the
following command:

.. code-block:: shell-session

   $ srun -p <node-type> -N <number-of-nodes> --pty /bin/bash -l

After the shell has been opened, users can run their |hpx| application. By default,
it uses all available cores. Note that if you requested one node, you don't need
to do ``srun`` again. However, if you requested more than one node, and want to
run your distributed application, you can use ``srun`` again to start up the
distributed |hpx| application. It will use the resources that have been requested
for the interactive shell.

Scheduling batch jobs
---------------------

The above mentioned method of running |hpx| applications is fine for development
purposes. The disadvantage that comes with ``srun`` is that it only returns once
the application is finished. This might not be appropriate for longer-running
applications (for example, benchmarks or larger scale simulations). In order to
cope with that limitation, users can use the |sbatch| command.

The ``sbatch`` command expects a script that it can run once the requested
resources are available. In order to request resources, users need to add
``#SBATCH`` comments in their script or provide the necessary parameters to
``sbatch`` directly. The parameters are the same as with ``run``. The commands
you need to execute are the same you would need to start your application as if
you were in an interactive shell.

..
    Copyright (C) 2007-2015 Hartmut Kaiser
    Copyright (C) 2011-2012 Bryce Adelstein-Lelbach

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _launching_and_configuring:

============================================
Launching and configuring |hpx| applications
============================================

.. _configuration:

Configuring |hpx| applications
==============================

All |hpx| applications can be configured using special command line options
and/or using special configuration files. This section describes the available
options, the configuration file format, and the algorithm used to locate
possible predefined configuration files. Additionally this section describes the
defaults assumed if no external configuration information is supplied.

During startup any |hpx| application applies a predefined search pattern to
locate one or more configuration files. All found files will be read and merged
in the sequence they are found into one single internal database holding all
configuration properties. This database is used during the execution of the
application to configure different aspects of the runtime system.

In addition to the ini files, any application can supply its own configuration
files, which will be merged with the configuration database as well. Moreover,
the user can specify additional configuration parameters on the command line
when executing an application. The |hpx| runtime system will merge all command
line configuration options (see the description of the :option:`--hpx:ini`,
:option:`--hpx:config`, and :option:`--hpx:app-config` command line options).

.. _ini_format:

The |hpx| INI File Format
-------------------------

All |hpx| applications can be configured using a special file format which is
similar to the well-known |ini_file_format|_. This is a structured text format
allowing to group key/value pairs (properties) into sections. The basic element
contained in an ini file is the property. Every property has a name and a
value, delimited by an equals sign ``'='``. The name appears to the left of the
equals sign:

.. code-block:: ini

   name=value

The value may contain equal signs as only the first ``'='`` character
is interpreted as the delimiter between ``name`` and ``value`` Whitespace before
the name, after the value and immediately before and after the delimiting equal
sign is ignored. Whitespace inside the value is retained.

Properties may be grouped into arbitrarily named sections. The section name
appears on a line by itself, in square brackets ``[`` and ``]``. All properties
after the section declaration are associated with that section. There is no
explicit "end of section" delimiter; sections end at the next section
declaration, or the end of the file:

.. code-block:: ini

   [section]

In |hpx| sections can be nested. A nested section has a name composed of
all section names it is embedded in. The section names are concatenated using
a dot ``'.'``:

.. code-block:: ini

   [outer_section.inner_section]

Here ``inner_section`` is logically nested within ``outer_section``.

It is possible to use the full section name concatenated with the property
name to refer to a particular property. For example in:

.. code-block:: ini

    [a.b.c]
    d = e

the property value of ``d`` can be referred to as ``a.b.c.d=e``.

In |hpx| ini files can contain comments. Hash signs ``'#'`` at the beginning
of a line indicate a comment. All characters starting with the ``'#'`` until the
end of line are ignored.

If a property with the same name is reused inside a section, the second
occurrence of this property name will override the first occurrence (discard the
first value). Duplicate sections simply merge their properties together, as if
they occurred contiguously.

In |hpx| ini files, a property value ``${FOO:default}`` will use the environmental
variable ``FOO`` to extract the actual value if it is set and ``default`` otherwise.
No default has to be specified. Therefore ``${FOO}`` refers to the environmental
variable ``FOO``. If ``FOO`` is not set or empty the overall expression will evaluate
to an empty string. A property value ``$[section.key:default]`` refers to the value
held by the property ``section.key`` if it exists and ``default`` otherwise. No
default has to be specified. Therefore ``$[section.key]`` refers to the property
``section.key``. If the property ``section.key`` is not set or empty, the overall
expression will evaluate to an empty string.

.. note::

   Any property ``$[section.key:default]`` is evaluated whenever it is queried
   and not when the configuration data is initialized. This allows for lazy
   evaluation and relaxes initialization order of different sections. The only
   exception are recursive property values, e.g. values referring to the very
   key they are associated with. Those property values are evaluated at
   initialization time to avoid infinite recursion.

.. _config_defaults:

Built-in Default Configuration Settings
---------------------------------------

During startup any |hpx| application applies a predefined search pattern to
locate one or more configuration files. All found files will be read and merged
in the sequence they are found into one single internal data structure holding
all configuration properties.

As a first step the internal configuration database is filled with a set of
default configuration properties. Those settings are described on a section
by section basis below.

.. note::

   You can print the default configuration settings used for an executable
   by specifying the command line option :option:`--hpx:dump-config`.

The ``system`` configuration section
....................................

.. code-block:: ini

   [system]
   pid = <process-id>
   prefix = <current prefix path of core HPX library>
   executable = <current prefix path of executable>

.. _ini_system:

.. list-table::

   * * Property
     * Description
   * * ``system.pid``
     * This is initialized to store the current OS-process id of the application
       instance.
   * * ``system.prefix``
     * This is initialized to the base directory |hpx| has been loaded from.
   * * ``system.executable_prefix``
     * This is initialized to the base directory the current executable has been
       loaded from.

The ``hpx`` configuration section
.................................

.. code-block:: ini

   [hpx]
   location = ${HPX_LOCATION:$[system.prefix]}
   component_path = $[hpx.location]/lib/hpx:$[system.executable_prefix]/lib/hpx:$[system.executable_prefix]/../lib/hpx
   master_ini_path = $[hpx.location]/share/hpx-<version>:$[system.executable_prefix]/share/hpx-<version>:$[system.executable_prefix]/../share/hpx-<version>
   ini_path = $[hpx.master_ini_path]/ini
   os_threads = 1
   localities = 1
   program_name =
   cmd_line =
   lock_detection = ${HPX_LOCK_DETECTION:0}
   throw_on_held_lock = ${HPX_THROW_ON_HELD_LOCK:1}
   minimal_deadlock_detection = <debug>
   spinlock_deadlock_detection = <debug>
   spinlock_deadlock_detection_limit = ${HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT:1000000}
   max_background_threads = ${HPX_MAX_BACKGROUND_THREADS:$[hpx.os_threads]}
   max_idle_loop_count = ${HPX_MAX_IDLE_LOOP_COUNT:<hpx_idle_loop_count_max>}
   max_busy_loop_count = ${HPX_MAX_BUSY_LOOP_COUNT:<hpx_busy_loop_count_max>}
   max_idle_backoff_time = ${HPX_MAX_IDLE_BACKOFF_TIME:<hpx_idle_backoff_time_max>}
   exception_verbosity = ${HPX_EXCEPTION_VERBOSITY:2}

   [hpx.stacks]
   small_size = ${HPX_SMALL_STACK_SIZE:<hpx_small_stack_size>}
   medium_size = ${HPX_MEDIUM_STACK_SIZE:<hpx_medium_stack_size>}
   large_size = ${HPX_LARGE_STACK_SIZE:<hpx_large_stack_size>}
   huge_size = ${HPX_HUGE_STACK_SIZE:<hpx_huge_stack_size>}
   use_guard_pages = ${HPX_THREAD_GUARD_PAGE:1}

.. _ini_hpx:

.. list-table::

   * * Property
     * Description
   * * ``hpx.location``
     * This is initialized to the id of the :term:`locality` this application
       instance is running on.
   * * ``hpx.component_path``
     * Duplicates are discarded.
       This property can refer to a list of directories separated by ``':'``
       (Linux, Android, and MacOS) or using ``';'`` (Windows).
   * * ``hpx.master_ini_path``
     * This is initialized to the list of default paths of the main hpx.ini
       configuration files. This property can refer to a list of directories
       separated by ``':'`` (Linux, Android, and MacOS) or using ``';'``
       (Windows).
   * * ``hpx.ini_path``
     * This is initialized to the default path where |hpx| will look for more
       ini configuration files. This property can refer to a list of directories
       separated by ``':'`` (Linux, Android, and MacOS) or using ``';'``
       (Windows).
   * * ``hpx.os_threads``
     * This setting reflects the number of OS-threads used for running
       |hpx|-threads. Defaults to number of detected cores (not hyperthreads/PUs).
   * * ``hpx.localities``
     * This setting reflects the number of localities the application is running
       on. Defaults to ``1``.
   * * ``hpx.program_name``
     * This setting reflects the program name of the application instance.
       Initialized from the command line ``argv[0]``.
   * * ``hpx.cmd_line``
     * This setting reflects the actual command line used to launch this
       application instance.
   * * ``hpx.lock_detection``
     * This setting verifies that no locks are being held while a |hpx| thread
       is suspended. This setting is applicable only if
       ``HPX_WITH_VERIFY_LOCKS`` is set during configuration in CMake.
   * * ``hpx.throw_on_held_lock``
     * This setting causes an exception if during lock detection at least one
       lock is being held while a |hpx| thread is suspended. This setting is
       applicable only if ``HPX_WITH_VERIFY_LOCKS`` is set during configuration
       in CMake. This setting has no effect if ``hpx.lock_detection=0``.
   * * ``hpx.minimal_deadlock_detection``
     * This setting enables support for minimal deadlock detection for
       |hpx|-threads. By default this is set to ``1`` (for Debug builds) or to
       ``0`` (for Release, RelWithDebInfo, RelMinSize builds), this setting is
       effective only if ``HPX_WITH_THREAD_DEADLOCK_DETECTION`` is set during
       configuration in CMake.
   * * ``hpx.spinlock_deadlock_detection``
     * This setting verifies that spinlocks don't spin longer than specified
       using the ``hpx.spinlock_deadlock_detection_limit``. This setting is
       applicable only if ``HPX_WITH_SPINLOCK_DEADLOCK_DETECTION`` is set during
       configuration in CMake. By default this is set to ``1`` (for Debug
       builds) or to ``0`` (for Release, RelWithDebInfo, RelMinSize builds).
   * * ``hpx.spinlock_deadlock_detection_limit``
     * This setting specifies the upper limit of allowed number of spins that
       spinlocks are allowed to perform. This setting is applicable only if
       ``HPX_WITH_SPINLOCK_DEADLOCK_DETECTION`` is set during configuration in
       CMake. By default this is set to ``1000000``.
   * * ``hpx.max_background_threads``
     * This setting defines the number of threads in the scheduler which are
       used to execute background work. By default this is the same as the
       number of cores used for the scheduler.
   * * ``hpx.max_idle_loop_count``
     * By default this is defined by the preprocessor constant
       ``HPX_IDLE_LOOP_COUNT_MAX``. This is an internal setting which you should
       change only if you know exactly what you are doing.
   * * ``hpx.max_busy_loop_count``
     * This setting defines the maximum value of the busy-loop counter in the
       scheduler. By default this is defined by the preprocessor constant
       ``HPX_BUSY_LOOP_COUNT_MAX``. This is an internal setting which you should
       change only if you know exactly what you are doing.
   * * ``hpx.max_idle_backoff_time``
     * This setting defines the maximum time (in milliseconds) for the scheduler
       to sleep after being idle for ``hpx.max_idle_loop_count`` iterations.
       This setting is applicable only if
       ``HPX_WITH_THREAD_MANAGER_IDLE_BACKOFF`` is set during configuration in
       |cmake|. By default this is defined by the preprocessor constant
       ``HPX_IDLE_BACKOFF_TIME_MAX``. This is an internal setting which you
       should change only if you know exactly what you are doing.
   * * ``hpx.exception_verbosity``
     * This setting defines the verbosity of exceptions. Valid values are
       integers. A setting of ``2`` or higher prints all available information.
       A setting of ``1`` leaves out the build configuration and environment
       variables. A setting of ``0`` or lower prints only the description of the
       thrown exception and the file name, function, and line number where the
       exception was thrown. The default value is ``2`` or the value of the
       environment variable ``HPX_EXCEPTION_VERBOSITY``.
   * * ``hpx.stacks.small_size``
     * This is initialized to the small stack size to be used by |hpx|-threads.
       Set by default to the value of the compile time preprocessor constant
       ``HPX_SMALL_STACK_SIZE`` (defaults to ``0x8000``). This value is used for
       all |hpx| threads by default, except for the thread running ``hpx_main``
       (which runs on a large stack).
   * * ``hpx.stacks.medium_size``
     * This is initialized to the medium stack size to be used by |hpx|-threads.
       Set by default to the value of the compile time preprocessor constant
       ``HPX_MEDIUM_STACK_SIZE`` (defaults to ``0x20000``).
   * * ``hpx.stacks.large_size``
     * This is initialized to the large stack size to be used by |hpx|-threads.
       Set by default to the value of the compile time preprocessor constant
       ``HPX_LARGE_STACK_SIZE`` (defaults to ``0x200000``). This setting is used
       by default for the thread running ``hpx_main`` only.
   * * ``hpx.stacks.huge_size``
     * This is initialized to the huge stack size to be used by |hpx|-threads.
       Set by default to the value of the compile time preprocessor constant
       ``HPX_HUGE_STACK_SIZE`` (defaults to ``0x2000000``).
   * * ``hpx.stacks.use_guard_pages``
     * This entry controls whether the coroutine library will generate stack
       guard pages or not. This entry is applicable on Linux only and only if
       the ``HPX_USE_GENERIC_COROUTINE_CONTEXT`` option is not enabled and the
       ``HPX_WITH_THREAD_GUARD_PAGE`` is set to 1 while configuring the build
       system. It is set by default to ``1``.

The ``hpx.threadpools`` configuration section
.............................................

.. code-block:: ini

   [hpx.threadpools]
   io_pool_size = ${HPX_NUM_IO_POOL_SIZE:2}
   parcel_pool_size = ${HPX_NUM_PARCEL_POOL_SIZE:2}
   timer_pool_size = ${HPX_NUM_TIMER_POOL_SIZE:2}

.. _ini_hpx_thread_pools:

.. list-table::

   * * Property
     * Description
   * * ``hpx.threadpools.io_pool_size``
     * The value of this property defines the number of OS-threads created for
       the internal I/O thread pool.
   * * ``hpx.threadpools.parcel_pool_size``
     * The value of this property defines the number of OS-threads created for
       the internal parcel thread pool.
   * * ``hpx.threadpools.timer_pool_size``
     * The value of this property defines the number of OS-threads created for
       the internal timer thread pool.

The ``hpx.thread_queue`` configuration section
..............................................

.. important::

   These setting control internal values used by the thread scheduling queues in
   the |hpx| scheduler. You should not modify these settings except if you know
   exactly what you are doing]

.. code-block:: ini

   [hpx.thread_queue]
   min_tasks_to_steal_pending = ${HPX_THREAD_QUEUE_MIN_TASKS_TO_STEAL_PENDING:0}
   min_tasks_to_steal_staged = ${HPX_THREAD_QUEUE_MIN_TASKS_TO_STEAL_STAGED:0}
   min_add_new_count = ${HPX_THREAD_QUEUE_MIN_ADD_NEW_COUNT:10}
   max_add_new_count = ${HPX_THREAD_QUEUE_MAX_ADD_NEW_COUNT:10}
   max_delete_count = ${HPX_THREAD_QUEUE_MAX_DELETE_COUNT:1000}

.. _ini_hpx_thread_queue:

.. list-table::

   * * Property
     * Description
   * * ``hpx.thread_queue.min_tasks_to_steal_pending``
     * The value of this property defines the number of pending |hpx| threads
       which have to be available before neighboring cores are allowed to steal
       work. The default is to allow stealing always.
   * * ``hpx.thread_queue.min_tasks_to_steal_staged``
     * The value of this property defines the number of staged |hpx| tasks have
       which to be available before neighboring cores are allowed to steal work.
       The default is to allow stealing always.
   * * ``hpx.thread_queue.min_add_new_count``
     * The value of this property defines the minimal number tasks to be
       converted into |hpx| threads whenever the thread queues for a core have
       run empty.
   * * ``hpx.thread_queue.max_add_new_count``
     * The value of this property defines the maximal number tasks to be
       converted into |hpx| threads whenever the thread queues for a core have
       run empty.
   * * ``hpx.thread_queue.max_delete_count``
     * The value of this property defines the number of terminated |hpx| threads
       to discard during each invocation of the corresponding function.

The ``hpx.components`` configuration section
............................................

.. code-block:: ini

    [hpx.components]
    load_external = ${HPX_LOAD_EXTERNAL_COMPONENTS:1}

.. _ini_hpx_components:

.. list-table::

   * * Property
     * Description
   * * ``hpx.components.load_external``
     * This entry defines whether external components will be loaded on this
       :term:`locality`. This entry normally is set to ``1`` and usually there is
       no need to directly change this value. It is automatically set to ``0`` for
       a dedicated :term:`AGAS` server :term:`locality`.

Additionally, the section ``hpx.components`` will be populated with the
information gathered from all found components. The information loaded for each
of the components will contain at least the following properties:

.. code-block:: ini

    [hpx.components.<component_instance_name>]
    name = <component_name>
    path = <full_path_of_the_component_module>
    enabled = $[hpx.components.load_external]

.. _ini_hpx_components_custom:

.. list-table::

   * * Property
     * Description
   * * ``hpx.components.<component_instance_name>.name``
     * This is the name of a component, usually the same as the second argument
       to the macro used while registering the component with
       :c:macro:`HPX_REGISTER_COMPONENT`. Set by the component factory.
   * * ``hpx.components.<component_instance_name>.path``
     * This is either the full path file name of the component module or the
       directory the component module is located in. In this case, the component
       module name will be derived from the property
       ``hpx.components.<component_instance_name>.name``. Set by the component
       factory.
   * * ``hpx.components.<component_instance_name>.enabled``
     * This setting explicitly enables or disables the component. This is an
       optional property, |hpx| assumed that the component is enabled if it is
       not defined.

The value for ``<component_instance_name>`` is usually the same as for the
corresponding ``name`` property. However generally it can be defined to any
arbitrary instance name. It is used to distinguish between different ini
sections, one for each component.

The ``hpx.parcel`` configuration section
........................................

.. code-block:: ini

    [hpx.parcel]
    address = ${HPX_PARCEL_SERVER_ADDRESS:<hpx_initial_ip_address>}
    port = ${HPX_PARCEL_SERVER_PORT:<hpx_initial_ip_port>}
    bootstrap = ${HPX_PARCEL_BOOTSTRAP:<hpx_parcel_bootstrap>}
    max_connections = ${HPX_PARCEL_MAX_CONNECTIONS:<hpx_parcel_max_connections>}
    max_connections_per_locality = ${HPX_PARCEL_MAX_CONNECTIONS_PER_LOCALITY:<hpx_parcel_max_connections_per_locality>}
    max_message_size = ${HPX_PARCEL_MAX_MESSAGE_SIZE:<hpx_parcel_max_message_size>}
    max_outbound_message_size = ${HPX_PARCEL_MAX_OUTBOUND_MESSAGE_SIZE:<hpx_parcel_max_outbound_message_size>}
    array_optimization = ${HPX_PARCEL_ARRAY_OPTIMIZATION:1}
    zero_copy_optimization = ${HPX_PARCEL_ZERO_COPY_OPTIMIZATION:$[hpx.parcel.array_optimization]}
    async_serialization = ${HPX_PARCEL_ASYNC_SERIALIZATION:1}
    message_handlers = ${HPX_PARCEL_MESSAGE_HANDLERS:0}

.. _ini_hpx_parcel:

.. list-table::

   * * Property
     * Description
   * * ``hpx.parcel.address``
     * This property defines the default IP address to be used for the :term:`parcel`
       layer to listen to. This IP address will be used as long as no other
       values are specified (for instance using the :option:`--hpx:hpx` command
       line option). The expected format is any valid IP address or domain name
       format which can be resolved into an IP address. The default depends on
       the compile time preprocessor constant ``HPX_INITIAL_IP_ADDRESS``
       (``"127.0.0.1"``).
   * * ``hpx.parcel.port``
     * This property defines the default IP port to be used for the :term:`parcel` layer
       to listen to. This IP port will be used as long as no other values are
       specified (for instance using the :option:`--hpx:hpx` command line
       option). The default depends on the compile time preprocessor
       constant ``HPX_INITIAL_IP_PORT`` (``7910``).
   * * ``hpx.parcel.bootstrap``
     * This property defines which parcelport type should be used during
       application bootstrap. The default depends on the compile time
       preprocessor constant ``HPX_PARCEL_BOOTSTRAP`` (``"tcp"``).
   * * ``hpx.parcel.max_connections``
     * This property defines how many network connections between different
       localities are overall kept alive by each of :term:`locality`. The
       default depends on the compile time preprocessor constant
       ``HPX_PARCEL_MAX_CONNECTIONS`` (``512``).
   * * ``hpx.parcel.max_connections_per_locality``
     * This property defines the maximum number of network connections that one
       :term:`locality` will open to another :term:`locality`. The default depends
       on the compile time preprocessor constant
       ``HPX_PARCEL_MAX_CONNECTIONS_PER_LOCALITY`` (``4``).
   * * ``hpx.parcel.max_message_size``
     * This property defines the maximum allowed message size which will be
       transferable through the :term:`parcel` layer. The default depends on the
       compile time preprocessor constant ``HPX_PARCEL_MAX_MESSAGE_SIZE``
       (``1000000000`` bytes).
   * * ``hpx.parcel.max_outbound_message_size``
     * This property defines the maximum allowed outbound coalesced message size
       which will be transferable through the parcel layer. The default depends
       on the compile time preprocessor constant
       ``HPX_PARCEL_MAX_OUTBOUND_MESSAGE_SIZE`` (``1000000`` bytes).
   * * ``hpx.parcel.array_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       array optimizations during serialization of :term:`parcel` data. The default is
       ``1``.
   * * ``hpx.parcel.zero_copy_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       zero copy optimizations during serialization of :term:`parcel` data. The default
       is the same value as set for ``hpx.parcel.array_optimization``.
   * * ``hpx.parcel.async_serialization``
     * This property defines whether this :term:`locality` is allowed to spawn a
       new thread for serialization (this is both for encoding and decoding
       parcels). The default is ``1``.
   * * ``hpx.parcel.message_handlers``
     * This property defines whether message handlers are loaded. The default is
       ``0``.

The following settings relate to the TCP/IP parcelport.

.. code-block:: ini

   [hpx.parcel.tcp]
   enable = ${HPX_HAVE_PARCELPORT_TCP:$[hpx.parcel.enabled]}
   array_optimization = ${HPX_PARCEL_TCP_ARRAY_OPTIMIZATION:$[hpx.parcel.array_optimization]}
   zero_copy_optimization = ${HPX_PARCEL_TCP_ZERO_COPY_OPTIMIZATION:$[hpx.parcel.zero_copy_optimization]}
   async_serialization = ${HPX_PARCEL_TCP_ASYNC_SERIALIZATION:$[hpx.parcel.async_serialization]}
   parcel_pool_size = ${HPX_PARCEL_TCP_PARCEL_POOL_SIZE:$[hpx.threadpools.parcel_pool_size]}
   max_connections =  ${HPX_PARCEL_TCP_MAX_CONNECTIONS:$[hpx.parcel.max_connections]}
   max_connections_per_locality = ${HPX_PARCEL_TCP_MAX_CONNECTIONS_PER_LOCALITY:$[hpx.parcel.max_connections_per_locality]}
   max_message_size =  ${HPX_PARCEL_TCP_MAX_MESSAGE_SIZE:$[hpx.parcel.max_message_size]}
   max_outbound_message_size =  ${HPX_PARCEL_TCP_MAX_OUTBOUND_MESSAGE_SIZE:$[hpx.parcel.max_outbound_message_size]}

.. _ini_hpx_parcel_tcp:

.. list-table::

   * * Property
     * Description
   * * ``hpx.parcel.tcp.enable``
     * Enable the use of the default TCP parcelport. Note that the initial
       bootstrap of the overall |hpx| application will be performed using the
       default TCP connections. This parcelport is enabled by default. This will
       be disabled only if MPI is enabled (see below).
   * * ``hpx.parcel.tcp.array_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       array optimizations in the TCP/IP parcelport during serialization of
       parcel data. The default is the same value as set for
       ``hpx.parcel.array_optimization``.
   * * ``hpx.parcel.tcp.zero_copy_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       zero copy optimizations in the TCP/IP parcelport during serialization of
       parcel data. The default is the same value as set for
       ``hpx.parcel.zero_copy_optimization``.
   * * ``hpx.parcel.tcp.async_serialization``
     * This property defines whether this :term:`locality` is allowed to spawn a
       new thread for serialization in the TCP/IP parcelport (this is both for
       encoding and decoding parcels). The default is the same value as set for
       ``hpx.parcel.async_serialization``.
   * * ``hpx.parcel.tcp.parcel_pool_size``
     * The value of this property defines the number of OS-threads created for
       the internal parcel thread pool of the TCP :term:`parcel` port. The default is
       taken from ``hpx.threadpools.parcel_pool_size``.
   * * ``hpx.parcel.tcp.max_connections``
     * This property defines how many network connections between different
       localities are overall kept alive by each of :term:`locality`. The
       default is taken from ``hpx.parcel.max_connections``.
   * * ``hpx.parcel.tcp.max_connections_per_locality``
     * This property defines the maximum number of network connections that one
       :term:`locality` will open to another :term:`locality`. The default is
       taken from ``hpx.parcel.max_connections_per_locality``.
   * * ``hpx.parcel.tcp.max_message_size``
     * This property defines the maximum allowed message size which will be
       transferable through the :term:`parcel` layer. The default is taken from
       ``hpx.parcel.max_message_size``.
   * * ``hpx.parcel.tcp.max_outbound_message_size``
     * This property defines the maximum allowed outbound coalesced message size
       which will be transferable through the :term:`parcel` layer. The default is
       taken from ``hpx.parcel.max_outbound_connections``.

The following settings relate to the MPI parcelport. These settings take effect
only if the compile time constant ``HPX_HAVE_PARCELPORT_MPI`` is set (the
equivalent cmake variable is ``HPX_WITH_PARCELPORT_MPI`` and has to be set to
``ON``.

.. code-block:: ini

   [hpx.parcel.mpi]
   enable = ${HPX_HAVE_PARCELPORT_MPI:$[hpx.parcel.enabled]}
   env = ${HPX_HAVE_PARCELPORT_MPI_ENV:MV2_COMM_WORLD_RANK,PMI_RANK,OMPI_COMM_WORLD_SIZE,ALPS_APP_PE,PALS_NODEID}
   multithreaded = ${HPX_HAVE_PARCELPORT_MPI_MULTITHREADED:1}
   rank = <MPI_rank>
   processor_name = <MPI_processor_name>
   array_optimization = ${HPX_HAVE_PARCEL_MPI_ARRAY_OPTIMIZATION:$[hpx.parcel.array_optimization]}
   zero_copy_optimization = ${HPX_HAVE_PARCEL_MPI_ZERO_COPY_OPTIMIZATION:$[hpx.parcel.zero_copy_optimization]}
   use_io_pool = ${HPX_HAVE_PARCEL_MPI_USE_IO_POOL:$1}
   async_serialization = ${HPX_HAVE_PARCEL_MPI_ASYNC_SERIALIZATION:$[hpx.parcel.async_serialization]}
   parcel_pool_size = ${HPX_HAVE_PARCEL_MPI_PARCEL_POOL_SIZE:$[hpx.threadpools.parcel_pool_size]}
   max_connections =  ${HPX_HAVE_PARCEL_MPI_MAX_CONNECTIONS:$[hpx.parcel.max_connections]}
   max_connections_per_locality = ${HPX_HAVE_PARCEL_MPI_MAX_CONNECTIONS_PER_LOCALITY:$[hpx.parcel.max_connections_per_locality]}
   max_message_size =  ${HPX_HAVE_PARCEL_MPI_MAX_MESSAGE_SIZE:$[hpx.parcel.max_message_size]}
   max_outbound_message_size =  ${HPX_HAVE_PARCEL_MPI_MAX_OUTBOUND_MESSAGE_SIZE:$[hpx.parcel.max_outbound_message_size]}

.. _ini_hpx_parcel_mpi:

.. list-table::

   * * Property
     * Description
   * * ``hpx.parcel.mpi.enable``
     * Enable the use of the MPI parcelport. HPX tries to detect if the
       application was started within a parallel MPI environment. If the
       detection was successful, the MPI parcelport is enabled by default. To
       explicitly disable the MPI parcelport, set to 0. Note that the initial
       bootstrap of the overall |hpx| application will be performed using MPI as
       well.
   * * ``hpx.parcel.mpi.env``
     * This property influences which environment variables (comma separated)
       will be analyzed to find out whether the application was invoked by MPI.
   * * ``hpx.parcel.mpi.multithreaded``
     * This property is used to determine what threading mode to use when
       initializing MPI. If this setting is ``0`` |hpx| will initialize MPI with
       ``MPI_THREAD_SINGLE`` if the value is not equal to ``0`` |hpx| will
       initialize MPI with ``MPI_THREAD_MULTI``.
   * * ``hpx.parcel.mpi.rank``
     * This property will be initialized to the MPI rank of the
       :term:`locality`.
   * * ``hpx.parcel.mpi.processor_name``
     * This property will be initialized to the MPI processor name of the
       :term:`locality`.
   * * ``hpx.parcel.mpi.array_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       array optimizations in the MPI parcelport during serialization of
       :term:`parcel` data. The default is the same value as set for
       ``hpx.parcel.array_optimization``.
   * * ``hpx.parcel.mpi.zero_copy_optimization``
     * This property defines whether this :term:`locality` is allowed to utilize
       zero copy optimizations in the MPI parcelport during serialization of
       parcel data. The default is the same value as set for
       ``hpx.parcel.zero_copy_optimization``.
   * * ``hpx.parcel.mpi.use_io_pool``
     * This property can be set to run the progress thread inside of HPX threads
       instead of a separate thread pool. The default is ``1``.
   * * ``hpx.parcel.mpi.async_serialization``
     * This property defines whether this :term:`locality` is allowed to spawn a
       new thread for serialization in the MPI parcelport (this is both for
       encoding and decoding parcels). The default is the same value as set for
       ``hpx.parcel.async_serialization``.
   * * ``hpx.parcel.mpi.parcel_pool_size``
     * The value of this property defines the number of OS-threads created for
       the internal parcel thread pool of the MPI :term:`parcel` port. The default is
       taken from ``hpx.threadpools.parcel_pool_size``.
   * * ``hpx.parcel.mpi.max_connections``
     * This property defines how many network connections between different
       localities are overall kept alive by each of :term:`locality`. The
       default is taken from ``hpx.parcel.max_connections``.
   * * ``hpx.parcel.mpi.max_connections_per_locality``
     * This property defines the maximum number of network connections that one
       :term:`locality` will open to another :term:`locality`. The default is
       taken from ``hpx.parcel.max_connections_per_locality``.
   * * ``hpx.parcel.mpi.max_message_size``
     * This property defines the maximum allowed message size which will be
       transferable through the :term:`parcel` layer. The default is taken from
       ``hpx.parcel.max_message_size``.
   * * ``hpx.parcel.mpi.max_outbound_message_size``
     * This property defines the maximum allowed outbound coalesced message size
       which will be transferable through the :term:`parcel` layer. The default is
       taken from ``hpx.parcel.max_outbound_connections``.

The ``hpx.agas`` configuration section
......................................

.. code-block:: ini

   [hpx.agas]
   address = ${HPX_AGAS_SERVER_ADDRESS:<hpx_initial_ip_address>}
   port = ${HPX_AGAS_SERVER_PORT:<hpx_initial_ip_port>}
   service_mode = hosted
   dedicated_server = 0
   max_pending_refcnt_requests = ${HPX_AGAS_MAX_PENDING_REFCNT_REQUESTS:<hpx_initial_agas_max_pending_refcnt_requests>}
   use_caching = ${HPX_AGAS_USE_CACHING:1}
   use_range_caching = ${HPX_AGAS_USE_RANGE_CACHING:1}
   local_cache_size = ${HPX_AGAS_LOCAL_CACHE_SIZE:<hpx_agas_local_cache_size>}

.. REVIEW regarding hpx.agas.address and hpx.agas.port: Technically, I believe
   --hpx:agas sets this parameter, this may need to be reworded.

.. _ini_hpx_agas:

.. list-table::

   * * Property
     * Description
   * * ``hpx.agas.address``
     * This property defines the default IP address to be used for the
       :term:`AGAS` root server. This IP address will be used as long as no
       other values are specified (for instance using the :option:`--hpx:agas`
       command line option). The expected format is any valid IP address or
       domain name format which can be resolved into an IP address. The default
       depends on the compile time preprocessor constant
       ``HPX_INITIAL_IP_ADDRESS`` (``"127.0.0.1"``).
   * * ``hpx.agas.port``
     * This property defines the default IP port to be used for the :term:`AGAS`
       root server. This IP port will be used as long as no other values are
       specified (for instance using the :option:`--hpx:agas` command line
       option). The default depends on the compile time preprocessor constant
       ``HPX_INITIAL_IP_PORT`` (``7009``).
   * * ``hpx.agas.service_mode``
     * This property specifies what type of :term:`AGAS` service is running on
       this :term:`locality`. Currently, two modes exist. The :term:`locality`
       that acts as the :term:`AGAS` server runs in ``bootstrap`` mode. All other
       localities are in ``hosted`` mode.
   * * ``hpx.agas.dedicated_server``
     * This property specifies whether the :term:`AGAS` server is exclusively
       running :term:`AGAS` services and not hosting any application components.
       It is a boolean value. Set to ``1`` if
       :option:`--hpx:run-agas-server-only` is present.
   * * ``hpx.agas.max_pending_refcnt_requests``
     * This property defines the number of reference counting requests
       (increments or decrements) to buffer. The default depends on the compile
       time preprocessor constant
       ``HPX_INITIAL_AGAS_MAX_PENDING_REFCNT_REQUESTS`` (``4096``).
   * * ``hpx.agas.use_caching``
     * This property specifies whether a software address translation cache is
       used. It is a boolean value. Defaults to ``1``.
   * * ``hpx.agas.use_range_caching``
     * This property specifies whether range-based caching is used by the
       software address translation cache. This property is ignored if
       `hpx.agas.use_caching` is false. It is a boolean value. Defaults to ``1``.
   * * ``hpx.agas.local_cache_size``
     * This property defines the size of the software address translation cache
       for :term:`AGAS` services. This property is ignored
       if ``hpx.agas.use_caching`` is false. Note that if
       ``hpx.agas.use_range_caching`` is true, this size will refer to the
       maximum number of ranges stored in the cache, not the number of entries
       spanned by the cache. The default depends on the compile time
       preprocessor constant ``HPX_AGAS_LOCAL_CACHE_SIZE`` (``4096``).

The ``hpx.commandline`` configuration section
.............................................

The following table lists the definition of all pre-defined command line option
shortcuts. For more information about commandline options see the section
:ref:`commandline`.

.. code-block:: ini

   [hpx.commandline]
   aliasing = ${HPX_COMMANDLINE_ALIASING:1}
   allow_unknown = ${HPX_COMMANDLINE_ALLOW_UNKNOWN:0}

   [hpx.commandline.aliases]
   -a = --hpx:agas
   -c = --hpx:console
   -h = --hpx:help
   -I = --hpx:ini
   -l = --hpx:localities
   -p = --hpx:app-config
   -q = --hpx:queuing
   -r = --hpx:run-agas-server
   -t = --hpx:threads
   -v = --hpx:version
   -w = --hpx:worker
   -x = --hpx:hpx
   -0 = --hpx:node=0
   -1 = --hpx:node=1
   -2 = --hpx:node=2
   -3 = --hpx:node=3
   -4 = --hpx:node=4
   -5 = --hpx:node=5
   -6 = --hpx:node=6
   -7 = --hpx:node=7
   -8 = --hpx:node=8
   -9 = --hpx:node=9

.. _ini_hpx_shortuts:

.. list-table::

   * * Property
     * Description
   * * ``hpx.commandline.aliasing``
     * Enable command line aliases as defined in the section
       ``hpx.commandline.aliases`` (see below). Defaults to ``1``.
   * * ``hpx.commandline.allow_unknown``
     * Allow for unknown command line options to be passed through to
       ``hpx_main()`` Defaults to ``0``.
   * * ``hpx.commandline.aliases.-a``
     * On the commandline, ``-a`` expands to: :option:`--hpx:agas`.
   * * ``hpx.commandline.aliases.-c``
     * On the commandline, ``-c`` expands to: :option:`--hpx:console`.
   * * ``hpx.commandline.aliases.-h``
     * On the commandline, ``-h`` expands to: :option:`--hpx:help`.
   * * ``hpx.commandline.aliases.--help``
     * On the commandline, ``--help`` expands to: :option:`--hpx:help`.
   * * ``hpx.commandline.aliases.-I``
     * On the commandline, ``-I`` expands to: :option:`--hpx:ini`.
   * * ``hpx.commandline.aliases.-l``
     * On the commandline, ``-l`` expands to: :option:`--hpx:localities`.
   * * ``hpx.commandline.aliases.-p``
     * On the commandline, ``-p`` expands to: :option:`--hpx:app-config`.
   * * ``hpx.commandline.aliases.-q``
     * On the commandline, ``-q`` expands to: :option:`--hpx:queuing`.
   * * ``hpx.commandline.aliases.-r``
     * On the commandline, ``-r`` expands to: :option:`--hpx:run-agas-server`.
   * * ``hpx.commandline.aliases.-t``
     * On the commandline, ``-t`` expands to: :option:`--hpx:threads`.
   * * ``hpx.commandline.aliases.-v``
     * On the commandline, ``-v`` expands to: :option:`--hpx:version`.
   * * ``hpx.commandline.aliases.--version``
     * On the commandline, ``--version`` expands to: :option:`--hpx:version`.
   * * ``hpx.commandline.aliases.-w``
     * On the commandline, ``-w`` expands to: :option:`--hpx:worker`.
   * * ``hpx.commandline.aliases.-x``
     * On the commandline, ``-x`` expands to: :option:`--hpx:hpx`.
   * * ``hpx.commandline.aliases.-0``
     * On the commandline, ``-0`` expands to: :option:`--hpx:node`\ ``=0``.
   * * ``hpx.commandline.aliases.-1``
     * On the commandline, ``-1`` expands to: :option:`--hpx:node`\ ``=1``.
   * * ``hpx.commandline.aliases.-2``
     * On the commandline, ``-2`` expands to: :option:`--hpx:node`\ ``=2``.
   * * ``hpx.commandline.aliases.-3``
     * On the commandline, ``-3`` expands to: :option:`--hpx:node`\ ``=3``.
   * * ``hpx.commandline.aliases.-4``
     * On the commandline, ``-4`` expands to: :option:`--hpx:node`\ ``=4``.
   * * ``hpx.commandline.aliases.-5``
     * On the commandline, ``-5`` expands to: :option:`--hpx:node`\ ``=5``.
   * * ``hpx.commandline.aliases.-6``
     * On the commandline, ``-6`` expands to: :option:`--hpx:node`\ ``=6``.
   * * ``hpx.commandline.aliases.-7``
     * On the commandline, ``-7`` expands to: :option:`--hpx:node`\ ``=7``.
   * * ``hpx.commandline.aliases.-8``
     * On the commandline, ``-8`` expands to: :option:`--hpx:node`\ ``=8``.
   * * ``hpx.commandline.aliases.-9``
     * On the commandline, ``-9`` expands to: :option:`--hpx:node`\ ``=9``.

.. _loading_ini_files:

Loading INI files
-----------------

During startup and after the internal database has been initialized as
described in the section :ref:`config_defaults`, |hpx| will try to locate and
load additional ini files to be used as a source for configuration properties.
This allows for a wide spectrum of additional customization possibilities by
the user and system administrators. The sequence of locations where |hpx|
will try loading the ini files is well defined and documented in this section.
All ini files found are merged into the internal configuration database.
The merge operation itself conforms to the rules as described in the section
:ref:`ini_format`.

#. Load all component shared libraries found in the directories specified by the
   property ``hpx.component_path`` and retrieve their default configuration
   information (see section :ref:`loading_components` for more details). This
   property can refer to a list of directories separated by ``':'`` (Linux,
   Android, and MacOS) or using ``';'`` (Windows).
#. Load all files named ``hpx.ini`` in the directories referenced by the property
   ``hpx.master_ini_path`` This property can refer to a list of directories
   separated by ``':'`` (Linux, Android, and MacOS) or using ``';'`` (Windows).
#. Load a file named ``.hpx.ini`` in the current working directory, e.g. the
   directory the application was invoked from.
#. Load a file referenced by the environment variable ``HPX_INI``. This variable
   is expected to provide the full path name of the ini configuration file (if
   any).
#. Load a file named ``/etc/hpx.ini``. This lookup is done on non-Windows systems
   only.
#. Load a file named ``.hpx.ini`` in the home directory of the current user,
   e.g. the directory referenced by the environment variable ``HOME``.
#. Load a file named ``.hpx.ini`` in the directory referenced by the environment
   variable ``PWD``.
#. Load the file specified on the command line using the option
   :option:`--hpx:config`.
#. Load all properties specified on the command line using the option
   :option:`--hpx:ini`. The properties will be added to the database in the
   same sequence as they are specified on the command line. The format for those
   options is for instance :option:`--hpx:ini`\ ``=hpx.default_stack_size=0x4000``. In
   addition to the explicit command line options, this will set the following
   properties as implied from other settings:

   * ``hpx.parcel.address`` and ``hpx.parcel.port`` as set by
     :option:`--hpx:hpx`
   * ``hpx.agas.address``, ``hpx.agas.port`` and ``hpx.agas.service_mode`` as
     set by :option:`--hpx:agas`
   * ``hpx.program_name`` and ``hpx.cmd_line`` will be derived from the actual
     command line
   * ``hpx.os_threads`` and ``hpx.localities`` as set by
      :option:`--hpx:threads` and :option:`--hpx:localities`
   * ``hpx.runtime_mode`` will be derived from any explicit
     :option:`--hpx:console`, :option:`--hpx:worker`, or :option:`--hpx:connect`,
     or it will be derived from other settings, such as :option:`--hpx:node`
     ``=0`` which implies :option:`--hpx:console`
#. Load files based on the pattern ``*.ini`` in all directories listed by the
   property ``hpx.ini_path``. All files found during this search will be merged.
   The property ``hpx.ini_path`` can hold a list of directories separated by
   ``':'`` (on Linux or Mac) or ``';'`` (on Windows).
#. Load the file specified on the command line using the option
   :option:`--hpx:app-config`. Note that this file will be merged as the content
   for a top level section ``[application]``.

.. note::

   Any changes made to the configuration database caused by one of the steps
   will influence the loading process for all subsequent steps. For instance, if
   one of the ini files loaded changes the property ``hpx.ini_path`` this will
   influence the directories searched in step 9 as described above.

.. important::

   The |hpx| core library will verify that all configuration settings specified
   on the command line (using the :option:`--hpx:ini` option) will be checked
   for validity. That means that the library will accept only *known*
   configuration settings. This is to protect the user from unintentional typos
   while specifying those settings. This behavior can be overwritten by
   appending a ``'!'`` to the configuration key, thus forcing the setting to be
   entered into the configuration database, for instance: :option:`--hpx:ini`\
   ``=hpx.foo! = 1``

If any of the environment variables or files listed above is not found the
corresponding loading step will be silently skipped.

.. _loading_components:

Loading components
==================

|hpx| relies on loading application specific components during the runtime of an
application. Moreover, |hpx| comes with a set of preinstalled components
supporting basic functionalities useful for almost every application. Any
component in |hpx| is loaded from a shared library, where any of the shared
libraries can contain more than one component type. During startup, |hpx| tries
to locate all available components (e.g. their corresponding shared libraries)
and creates an internal component registry for later use. This section describes
the algorithm used by |hpx| to locate all relevant shared libraries on a system.
As described, this algorithm is customizable by the configuration properties
loaded from the ini files (see section :ref:`loading_ini_files`).

Loading components is a two stage process. First |hpx| tries to locate all
component shared libraries, loads those, and generates default configuration
section in the internal configuration database for each component found. For
each found component the following information is generated:

.. code-block:: ini

    [hpx.components.<component_instance_name>]
    name = <name_of_shared_library>
    path = $[component_path]
    enabled = $[hpx.components.load_external]
    default = 1

The values in this section correspond to the expected configuration information
for a component as described in the section :ref:`config_defaults`.

In order to locate component shared libraries, |hpx| will try loading all
shared libraries (files with the platform specific extension of a shared
library, Linux: ``*.so``, Windows: ``*.dll``, MacOS: ``*.dylib`` found in the
directory referenced by the ini property ``hpx.component_path``).

This first step corresponds to step 1) during the process of filling the
internal configuration database with default information as described in section
:ref:`loading_ini_files`.

After all of the configuration information has been loaded, |hpx| performs the
second step in terms of loading components. During this step, |hpx| scans all
existing configuration sections
``[hpx.component.<some_component_instance_name>]`` and instantiates a special
factory object for each of the successfully located and loaded components.
During the application's life time, these factory objects will be responsible to
create new and discard old instances of the component they are associated with.
This step is performed after step 11) of the process of filling the internal
configuration database with default information as described in section
:ref:`loading_ini_files`.

.. _component_example:

Application specific component example
--------------------------------------

In this section we assume to have a simple application component which exposes
one member function as a component action. The header file ``app_server.hpp``
declares the C++ type to be exposed as a component. This type has a member
function ``print_greeting()`` which is exposed as an action
``print_greeting_action``. We assume the source files for this example are
located in a directory referenced by ``$APP_ROOT``:

.. code-block:: c++

   // file: $APP_ROOT/app_server.hpp
   #include <hpx/hpx.hpp>
   #include <hpx/include/iostreams.hpp>

   namespace app
   {
       // Define a simple component exposing one action 'print_greeting'
       class HPX_COMPONENT_EXPORT server
         : public hpx::components::component_base<server>
       {
           void print_greeting ()
           {
               hpx::cout << "Hey, how are you?\n" << hpx::flush;
           }

           // Component actions need to be declared, this also defines the
           // type 'print_greeting_action' representing the action.
           HPX_DEFINE_COMPONENT_ACTION(server, print_greeting, print_greeting_action);
       };
   }

   // Declare boilerplate code required for each of the component actions.
   HPX_REGISTER_ACTION_DECLARATION(app::server::print_greeting_action);

The corresponding source file contains mainly macro invocations which define
boilerplate code needed for |hpx| to function properly:

.. code-block:: c++

   // file: $APP_ROOT/app_server.cpp
   #include "app_server.hpp"

   // Define boilerplate required once per component module.
   HPX_REGISTER_COMPONENT_MODULE();

   // Define factory object associated with our component of type 'app::server'.
   HPX_REGISTER_COMPONENT(app::server, app_server);

   // Define boilerplate code required for each of the component actions. Use the
   // same argument as used for HPX_REGISTER_ACTION_DECLARATION above.
   HPX_REGISTER_ACTION(app::server::print_greeting_action);

The following gives an example of how the component can be used. We create one
instance of the ``app::server`` component on the current :term:`locality` and
invoke the exposed action ``print_greeting_action`` using the global id of the
newly created instance. Note, that no special code is required to delete the
component instance after it is not needed anymore. It will be deleted
automatically when its last reference goes out of scope, here at the closing
brace of the block surrounding the code:

.. code-block:: c++

   // file: $APP_ROOT/use_app_server_example.cpp
   #include <hpx/hpx_init.hpp>
   #include "app_server.hpp"

   int hpx_main()
   {
       {
           // Create an instance of the app_server component on the current locality.
           hpx::naming:id_type app_server_instance =
               hpx::create_component<app::server>(hpx::find_here());

           // Create an instance of the action 'print_greeting_action'.
           app::server::print_greeting_action print_greeting;

           // Invoke the action 'print_greeting' on the newly created component.
           print_greeting(app_server_instance);
       }
       return hpx::finalize();
   }

   int main(int argc, char* argv[])
   {
       return hpx::init(argc, argv);
   }

In order to make sure that the application will be able to use the component
``app::server``, special configuration information must be passed to |hpx|. The
simples way to allow |hpx| to 'find' the component is to provide special ini
configuration files, which add the necessary information to the internal
configuration database. The component should have a special ini file containing
the information specific to the component ``app_server``.

.. code-block:: ini

    # file: $APP_ROOT/app_server.ini
    [hpx.components.app_server]
    name = app_server
    path = $APP_LOCATION/

Here ``$APP_LOCATION`` is the directory where the (binary) component shared
library is located. |hpx| will attempt to load the shared library from there.
The section name ``hpx.components.app_server`` reflects the instance name of the
component (``app_server`` is an arbitrary, but unique name). The property value
for ``hpx.components.app_server.name`` should be the same as used for the second
argument to the macro :c:macro:`HPX_REGISTER_COMPONENT` above.

Additionally a file ``.hpx.ini`` which could be located in the current working
directory (see step 3 as described in the section :ref:`loading_ini_files`) can
be used to add to the ini search path for components:

.. code-block:: ini

    # file: $PWD/.hpx.ini
    [hpx]
    ini_path = $[hpx.ini_path]:$APP_ROOT/

This assumes that the above ini file specific to the component is located in
the directory ``$APP_ROOT``.

.. note::

   It is possible to reference the defined property from inside its value. |hpx|
   will gracefully use the previous value of ``hpx.ini_path`` for the reference
   on the right hand side and assign the overall (now expanded) value to the
   property.

.. _logging:

Logging
=======

|hpx| uses a sophisticated logging framework allowing to follow in detail
what operations have been performed inside the |hpx| library in what sequence.
This information proves to be very useful for diagnosing problems or just for
improving the understanding what is happening in |hpx| as a consequence of
invoking |hpx| API functionality.

Default logging
---------------

Enabling default logging is a simple process. The detailed description in the
remainder of this section explains different ways to customize the defaults.
Default logging can be enabled by using one of the following:

* a command line switch :option:`--hpx:debug-hpx-log`, which will enable
  logging to the console terminal
* the command line switch :option:`--hpx:debug-hpx-log`\ ``=<filename>``, which
  enables logging to a given file ``<filename>``, or
* setting an environment variable ``HPX_LOGLEVEL=<loglevel>`` while running the
  |hpx| application. In this case ``<loglevel>`` should be a number between (or
  equal to) ``1`` and ``5`` where ``1`` means minimal logging and ``5`` causes
  to log all available messages. When setting the environment variable the logs
  will be written to a file named ``hpx.<PID>.lo`` in the current working
  directory, where ``<PID>`` is the process id of the console instance of the
  application.

Customizing logging
-------------------

Generally, logging can be customized either using environment variable settings
or using by an ini configuration file. Logging is generated in several
categories, each of which can be customized independently. All customizable
configuration parameters have reasonable defaults, allowing to use logging
without any additional configuration effort. The following table lists the
available categories.

.. list-table:: Logging categories

   * * Category
     * Category shortcut
     * Information to be generated
     * Environment variable
   * * General
     * None
     * Logging information generated by different subsystems of |hpx|, such as
       thread-manager, parcel layer, LCOs, etc.
     * ``HPX_LOGLEVEL``
   * * :term:`AGAS`
     * ``AGAS``
     * Logging output generated by the :term:`AGAS` subsystem
     * ``HPX_AGAS_LOGLEVEL``
   * * Application
     * ``APP``
     * Logging generated by applications.
     * ``HPX_APP_LOGLEVEL``

By default, all logging output is redirected to the console instance of an
application, where it is collected and written to a file, one file for each
logging category.

Each logging category can be customized at two levels, the parameters for each
are stored in the ini configuration sections ``hpx.logging.CATEGORY`` and
``hpx.logging.console.CATEGORY`` (where ``CATEGORY`` is the category shortcut as
listed in the table above). The former influences logging at the source
:term:`locality` and the latter modifies the logging behaviour for each of the
categories at the console instance of an application.

Levels
------

All |hpx| logging output has seven different logging levels. These levels can
be set explicitly or through environmental variables in the main |hpx| ini file
as shown below. The logging levels and their associated integral values are
shown in the table below, ordered from most verbose to least verbose. By
default, all |hpx| logs are set to 0, e.g. all logging output is disabled by
default.

.. table:: Logging levels

   ============= ==============
   Logging level Integral value
   ============= ==============
   ``<debug>``   ``5``
   ``<info>``    ``4``
   ``<warning>`` ``3``
   ``<error>``   ``2``
   ``<fatal>``   ``1``
   No logging    ``0``
   ============= ==============


.. tip::

   The easiest way to enable logging output is to set the environment variable
   corresponding to the logging category to an integral value as described in
   the table above. For instance, setting ``HPX_LOGLEVEL=5`` will enable full
   logging output for the general category. Please note that the syntax and
   means of setting environment variables varies between operating systems.

Configuration
-------------

Logs will be saved to destinations as configured by the user. By default,
logging output is saved on the console instance of an application to
``hpx.<CATEGORY>.<PID>.lo`` (where ``CATEGORY`` and ``PID>`` are placeholders
for the category shortcut and the OS process id). The output for the general
logging category is saved to ``hpx.<PID>.log``. The default settings for the
general logging category are shown here (the syntax is described in the section
:ref:`ini_format`):

.. code-block:: ini

    [hpx.logging]
    level = ${HPX_LOGLEVEL:0}
    destination = ${HPX_LOGDESTINATION:console}
    format = ${HPX_LOGFORMAT:(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) P%parentloc%/%hpxparent%.%hpxparentphase% %time%($hh:$mm.$ss.$mili) [%idx%]|\\n}

The logging level is taken from the environment variable ``HPX_LOGLEVEL`` and
defaults to zero, e.g. no logging. The default logging destination is read from
the environment variable ``HPX_LOGDESTINATION`` On any of the localities it
defaults to ``console`` which redirects all generated logging output to the
console instance of an application. The following table lists the possible
destinations for any logging output. It is possible to specify more than one
destination separated by whitespace.

.. list-table:: Logging destinations

   * * Logging destination
     * Description
   * * file(``<filename>``)
     * Direct all output to a file with the given <filename>.
   * * cout
     * Direct all output to the local standard output of the application
       instance on this :term:`locality`.
   * * cerr
     * Direct all output to the local standard error output of the application
       instance on this :term:`locality`.
   * * console
     * Direct all output to the console instance of the application. The console
       instance has its logging destinations configured separately.
   * * android_log
     * Direct all output to the (Android) system log (available on Android
       systems only).

The logging format is read from the environment variable ``HPX_LOGFORMAT`` and
it defaults to a complex format description. This format consists of several
placeholder fields (for instance ``%locality%`` which will be replaced by
concrete values when the logging output is generated. All other information is
transferred verbatim to the output. The table below describes the available
field placeholders. The separator character ``|`` separates the logging message
prefix formatted as shown and the actual log message which will replace the
separator.

.. list-table:: Available field placeholders

   * * Name
     * Description
   * * :term:`locality`
     * The id of the :term:`locality` on which the logging message was
       generated.
   * * hpxthread
     * The id of the |hpx|-thread generating this logging output.
   * * hpxphase
     * The phase [#]_ of the |hpx|-thread generating this logging output.
   * * hpxcomponent
     * The local virtual address of the component which the current |hpx|-thread
       is accessing.
   * * parentloc
     * The id of the :term:`locality` where the |hpx| thread was running which
       initiated the current |hpx|-thread. The current |hpx|-thread is
       generating this logging output.
   * * hpxparent
     * The id of the |hpx|-thread which initiated the current |hpx|-thread. The
       current |hpx|-thread is generating this logging output.
   * * hpxparentphase
     * The phase of the |hpx|-thread when it initiated the current |hpx|-thread.
       The current |hpx|-thread is generating this logging output.
   * * time
     * The time stamp for this logging outputline as generated by the source
       :term:`locality`.
   * * idx
     * The sequence number of the logging output line as generated on the source
       :term:`locality`.
   * * osthread
     * The sequence number of the OS-thread which executes the current
       |hpx|-thread.

.. note::

   Not all of the field placeholder may be expanded for all generated logging
   output. If no value is available for a particular field it is replaced with a
   sequence of ``'-'`` characters.]

Here is an example line from a logging output generated by one of the |hpx|
examples (please note that this is generated on a single line, without line
break):

.. code-block:: text

   (T00000000/0000000002d46f90.01/00000000009ebc10) P--------/0000000002d46f80.02 17:49.37.320 [000000000000004d]
       <info>  [RT] successfully created component {0000000100ff0001, 0000000000030002} of type: component_barrier[7(3)]

The default settings for the general logging category on the console is shown
here:

.. code-block:: ini

   [hpx.logging.console]
   level = ${HPX_LOGLEVEL:$[hpx.logging.level]}
   destination = ${HPX_CONSOLE_LOGDESTINATION:file(hpx.$[system.pid].log)}
   format = ${HPX_CONSOLE_LOGFORMAT:|}

These settings define how the logging is customized once the logging output is
received by the console instance of an application. The logging level is read
from the environment variable ``HPX_LOGLEVEL`` (as set for the console instance
of the application). The level defaults to the same values as the corresponding
settings in the general logging configuration shown before. The destination on
the console instance is set to be a file which name is generated based from its
OS process id. Setting the environment variable ``HPX_CONSOLE_LOGDESTINATION``
allows customization of the naming scheme for the output file. The logging
format is set to leave the original logging output unchanged, as received from
one of the localities the application runs on.

.. _commandline:

|hpx| Command Line Options
==========================

The predefined command line options for any application using
:cpp:func:`hpx::init` are described in the following subsections.

.. todo:: Proofread the options.

|hpx| options (allowed on command line only)
--------------------------------------------

.. option:: --hpx:help

   print out program usage (default: this message), possible values: ``full``
   (additionally prints options from components)

.. option:: --hpx:version

   print out |hpx| version and copyright information

.. option:: --hpx:info

   print out |hpx| configuration information

.. option:: --hpx:options-file arg

   specify a file containing command line options (alternatively: @filepath)

|hpx| options (additionally allowed in an options file)
-------------------------------------------------------

.. option:: --hpx:worker

   run this instance in worker mode

.. option:: --hpx:console

   run this instance in console mode

.. option:: --hpx:connect

   run this instance in worker mode, but connecting late

.. option:: --hpx:run-agas-server

   run :term:`AGAS` server as part of this runtime instance

.. option:: --hpx:run-hpx-main

   run the hpx_main function, regardless of :term:`locality` mode

.. option:: --hpx:hpx arg

   the IP address the |hpx| parcelport is listening on, expected format:
   ``address:port`` (default: ``127.0.0.1:7910``)

.. option:: --hpx:agas arg

   the IP address the :term:`AGAS` root server is running on, expected format:
   ``address:port`` (default: ``127.0.0.1:7910``)

.. option:: --hpx:run-agas-server-only

   run only the :term:`AGAS` server

.. option:: --hpx:nodefile arg

   the file name of a node file to use (list of nodes, one node name per line
   and core)

.. option:: --hpx:nodes arg

   the (space separated) list of the nodes to use (usually this is extracted
   from a node file)

.. option:: --hpx:endnodes

   this can be used to end the list of nodes specified using the option
   :option:`--hpx:nodes`

.. option:: --hpx:ifsuffix arg

   suffix to append to host names in order to resolve them to the proper network
   interconnect

.. option:: --hpx:ifprefix arg

   prefix to prepend to host names in order to resolve them to the proper
   network interconnect

.. option:: --hpx:iftransform arg

   sed-style search and replace (``s/search/replace/``) used to transform host
   names to the proper network interconnect

.. option:: --hpx:localities arg

   the number of localities to wait for at application startup (default: ``1``)

.. option:: --hpx:node arg

   number of the node this :term:`locality` is run on (must be unique)

.. option:: --hpx:ignore-batch-env

   ignore batch environment variables

.. option:: --hpx:expect-connecting-localities

   this :term:`locality` expects other localities to dynamically connect (this
   is implied if the number of initial localities is larger than 1)

.. option:: --hpx:pu-offset

   the first processing unit this instance of |hpx| should be run on (default:
   ``0``)

.. option:: --hpx:pu-step

   the step between used processing unit numbers for this instance of |hpx|
   (default: ``1``)

.. option:: --hpx:threads arg

   the number of operating system threads to spawn for this |hpx|
   :term:`locality`. Possible values are: numeric values ``1``, ``2``, ``3`` and
   so on, ``all`` (which spawns one thread per processing unit, includes
   hyperthreads), or ``cores`` (which spawns one thread per core) (default:
   ``cores``).

.. option:: --hpx:cores arg

   the number of cores to utilize for this |hpx| :term:`locality` (default:
   ``all``, i.e. the number of cores is based on the number of threads
   :option:`--hpx:threads` assuming :option:`--hpx:bind`\ ``=compact``

.. option:: --hpx:affinity arg

   the affinity domain the OS threads will be confined to, possible values:
   ``pu``, ``core``, ``numa``, ``machine`` (default: ``pu``)

.. option:: --hpx:bind arg

   the detailed affinity description for the OS threads, see :ref:`details` for
   a detailed description of possible values. Do not use with
   :option:`--hpx:pu-step`, :option:`--hpx:pu-offset` or
   :option:`--hpx:affinity` options. Implies :option:`--hpx:numa-sensitive`
   (:option:`--hpx:bind`\ ``=none``) disables defining thread affinities).

.. option:: --hpx:use-process-mask

   use the process mask to restrict available hardware resources (implies
   :option:`--hpx:ignore-batch-env`)

.. option:: --hpx:print-bind

   print to the console the bit masks calculated from the arguments specified to
   all :option:`--hpx:bind` options.

.. option:: --hpx:queuing arg

   the queue scheduling policy to use, options are ``local``,
   ``local-priority-fifo``, ``local-priority-lifo``, ``static``,
   ``static-priority``, ``abp-priority-fifo`` and ``abp-priority-lifo``
   (default: ``local-priority-fifo``)

.. option:: --hpx:high-priority-threads arg

   the number of operating system threads maintaining a high priority queue
   (default: number of OS threads), valid for :option:`--hpx:queuing`\
   ``=abp-priority``, :option:`--hpx:queuing`\ ``=static-priority`` and
   :option:`--hpx:queuing`\ ``=local-priority`` only

.. option:: --hpx:numa-sensitive

   makes the scheduler NUMA sensitive


|hpx| configuration options
---------------------------

.. option:: --hpx:app-config arg

   load the specified application configuration (ini) file

.. option:: --hpx:config arg

   load the specified hpx configuration (ini) file

.. option:: --hpx:ini arg

   add a configuration definition to the default runtime configuration

.. option:: --hpx:exit

   exit after configuring the runtime

|hpx| debugging options
-----------------------

.. option:: --hpx:list-symbolic-names

   list all registered symbolic names after startup

.. option:: --hpx:list-component-types

   list all dynamic component types after startup

.. option:: --hpx:dump-config-initial

   print the initial runtime configuration

.. option:: --hpx:dump-config

   print the final runtime configuration

.. option:: --hpx:debug-hpx-log [arg]

   enable all messages on the |hpx| log channel and send all |hpx| logs to the
   target destination (default: ``cout``)

.. option:: --hpx:debug-agas-log [arg]

   enable all messages on the :term:`AGAS` log channel and send all :term:`AGAS`
   logs to the target destination (default: ``cout``)

.. option:: --hpx:debug-parcel-log [arg]

   enable all messages on the parcel transport log channel and send all parcel
   transport logs to the target destination (default: ``cout``)

.. option:: --hpx:debug-timing-log [arg]

   enable all messages on the timing log channel and send all timing logs to the
   target destination (default: ``cout``)

.. option:: --hpx:debug-app-log [arg]

   enable all messages on the application log channel and send all application
   logs to the target destination (default: ``cout``)

.. option:: --hpx:debug-clp

   debug command line processing

.. option:: --hpx:attach-debugger arg

   wait for a debugger to be attached, possible arg values: ``startup`` or
   ``exception`` (default: ``startup``)

|hpx| options related to performance counters
---------------------------------------------

.. option:: --hpx:print-counter

   print the specified performance counter either repeatedly and/or at the times
   specified by :option:`--hpx:print-counter-at` (see also option
   :option:`--hpx:print-counter-interval`)

.. option:: --hpx:print-counter-reset

   print the specified performance counter either repeatedly and/or at the times
   specified by :option:`--hpx:print-counter-at` reset the counter after the
   value is queried. (see also option :option:`--hpx:print-counter-interval`)

.. option:: --hpx:print-counter-interval

   print the performance counter(s) specified with :option:`--hpx:print-counter`
   repeatedly after the time interval (specified in milliseconds), (default:
   ``0``, which means print once at shutdown)

.. option:: --hpx:print-counter-destination

   print the performance counter(s) specified with :option:`--hpx:print-counter` to
   the given file (default: ``console``)

.. option:: --hpx:list-counters

   list the names of all registered performance counters, possible values:
   ``minimal`` (prints counter name skeletons), ``full`` (prints all available
   counter names)

.. option:: --hpx:list-counter-infos

   list the description of all registered performance counters, possible values:
   ``minimal`` (prints info for counter name skeletons), ``full`` (prints all
   available counter infos)

.. option:: --hpx:print-counter-format

   print the performance counter(s) specified with :option:`--hpx:print-counter`
   possible formats in csv format with header or without any header (see option
   :option:`--hpx:no-csv-header`, possible values: ``csv`` (prints counter
   values in CSV format with full names as header), ``csv-short`` (prints
   counter values in CSV format with shortnames provided with
   :option:`--hpx:print-counter` as :option:`--hpx:print-counter`
   ``shortname,full-countername``

.. option:: --hpx:no-csv-header

   print the performance counter(s) specified with :option:`--hpx:print-counter`
   and ``csv`` or ``csv-short`` format specified with
   :option:`--hpx:print-counter-format` without header

.. option:: --hpx:print-counter-at arg

   print the performance counter(s) specified with :option:`--hpx:print-counter`
   (or :option:`--hpx:print-counter-reset` at the given point in time, possible
   argument values: ``startup``, ``shutdown`` (default), ``noshutdown``

.. option:: --hpx:reset-counters

   reset all performance counter(s) specified with :option:`--hpx:print-counter`
   after they have been evaluated.

.. option:: --hpx:print-counters-locally

   Each :term:`locality` prints only its own local counters. If this is used
   with :option:`--hpx:print-counter-destination`\ ``=<file>``, the code will
   append a ``".<locality_id>"`` to the file name in order to avoid clashes
   between localities.

Command line argument shortcuts
-------------------------------

Additionally, the following shortcuts are available from every |hpx|
application.

.. table:: Predefined command line option shortcuts

   =============== ======================
   Shortcut option Equivalent long option
   =============== ======================
   ``-a``          :option:`--hpx:agas`
   ``-c``          :option:`--hpx:console`
   ``-h``          :option:`--hpx:help`
   ``-I``          :option:`--hpx:ini`
   ``-l``          :option:`--hpx:localities`
   ``-p``          :option:`--hpx:app-config`
   ``-q``          :option:`--hpx:queuing`
   ``-r``          :option:`--hpx:run-agas-server`
   ``-t``          :option:`--hpx:threads`
   ``-v``          :option:`--hpx:version`
   ``-w``          :option:`--hpx:worker`
   ``-x``          :option:`--hpx:hpx`
   ``-0``          :option:`--hpx:node`\ ``=0``
   ``-1``          :option:`--hpx:node`\ ``=1``
   ``-2``          :option:`--hpx:node`\ ``=2``
   ``-3``          :option:`--hpx:node`\ ``=3``
   ``-4``          :option:`--hpx:node`\ ``=4``
   ``-5``          :option:`--hpx:node`\ ``=5``
   ``-6``          :option:`--hpx:node`\ ``=6``
   ``-7``          :option:`--hpx:node`\ ``=7``
   ``-8``          :option:`--hpx:node`\ ``=8``
   ``-9``          :option:`--hpx:node`\ ``=9``
   =============== ======================

It is possible to define your own shortcut options. In fact, all of the
shortcuts listed above are pre-defined using the technique described here. Also,
it is possible to redefine any of the pre-defined shortcuts to expand
differently as well.

Shortcut options are obtained from the internal configuration database. They are
stored as key-value properties in a special properties section named
``hpx.commandline``. You can define your own shortcuts by adding the
corresponding definitions to one of the ``ini`` configuration files as described
in the section :ref:`configuration`. For instance, in order to define a command
line shortcut ``--p`` which should expand to ``-hpx:print-counter``, the
following configuration information needs to be added to one of the ``ini``
configuration files:

.. code-block:: ini

   [hpx.commandline.aliases]
   --pc = --hpx:print-counter

.. note::

   Any arguments for shortcut options passed on the command line are retained
   and passed as arguments to the corresponding expanded option. For instance,
   given the definition above, the command line option:

   .. code-block:: bash

      --pc=/threads{locality#0/total}/count/cumulative

   would be expanded to:

   .. code-block:: bash

      --hpx:print-counter=/threads{locality#0/total}/count/cumulative

.. important::

   Any shortcut option should either start with a single ``'-'`` or with two
   ``'--'`` characters. Shortcuts starting with a single ``'-'`` are interpreted
   as short options (i.e. everything after the first character following the
   ``'-'`` is treated as the argument). Shortcuts starting with ``'--'`` are
   interpreted as long options. No other shortcut formats are supported.

Specifying options for single localities only
---------------------------------------------

For runs involving more than one :term:`locality` it is sometimes desirable to
supply specific command line options to single localities only. When the |hpx|
application is launched using a scheduler (like PBS, for more details see
section :ref:`unix_pbs`), specifying dedicated command line options for single
localities may be desirable. For this reason all of the command line options
which have the general format ``--hpx:<some_key>`` can be used in a more general
form: ``--hpx:<N>:<some_key>``, where <N> is the number of the :term:`locality`
this command line options will be applied to, all other localities will simply
ignore the option. For instance, the following PBS script passes the option
:option:`--hpx:pu-offset`\ ``=4`` to the :term:`locality` ``'1'`` only.

.. code-block:: bash

   #!/bin/bash
   #
   #PBS -l nodes=2:ppn=4

   APP_PATH=~/packages/hpx/bin/hello_world_distributed
   APP_OPTIONS=

   pbsdsh -u $APP_PATH $APP_OPTIONS --hpx:1:pu-offset=4 --hpx:nodes=`cat $PBS_NODEFILE`

.. caution::

   If the first application specific argument (inside ``$APP_OPTIONS`` is a
   non-option (i.e. does not start with a ``-`` or a ``--``, then it must be
   placed before the option :option:`--hpx:nodes`, which, in this case,
   should be the last option on the command line.

   Alternatively, use the option :option:`--hpx:endnodes` to explicitly
   mark the end of the list of node names:

   .. code-block:: shell-session

      $ pbsdsh -u $APP_PATH --hpx:1:pu-offset=4 --hpx:nodes=`cat $PBS_NODEFILE` --hpx:endnodes $APP_OPTIONS

.. _details:

More details about |hpx| command line options
---------------------------------------------

This section documents the following list of the command line options in more
detail:

* :ref:`bind`

.. _bind:

The command line option :option:`--hpx:bind`
............................................

This command line option allows one to specify the required affinity of the
|hpx| worker threads to the underlying processing units. As a result the worker
threads will run only on the processing units identified by the corresponding
bind specification. The affinity settings are to be specified using
:option:`--hpx:bind`\ ``=<BINDINGS>``, where ``<BINDINGS>`` have to be formatted as
described below.

In addition to the syntax described below one can use :option:`--hpx:bind`\
``=none`` to disable all binding of any threads to a particular core. This is
mostly supported for debugging purposes.

The specified affinities refer to specific regions within a machine hardware
topology. In order to understand the hardware topology of a particular machine
it may be useful to run the lstopo tool which is part of |hwloc| to see the
reported topology tree. Seeing and understanding a topology tree will definitely
help in understanding the concepts that are discussed below.

Affinities can be specified using HWLOC (|hwloc|) tuples. Tuples of HWLOC
*objects* and associated *indexes* can be specified in the form
``object:index``, ``object:index-index`` or ``object:index,...,index``. HWLOC
objects represent types of mapped items in a topology tree. Possible values for
objects are ``socket``, ``numanode``, ``core`` and ``pu`` (processing unit).
Indexes are non-negative integers that specify a unique physical object in a
topology tree using its logical sequence number.

Chaining multiple tuples together in the more general form
``object1:index1[.object2:index2[...]]`` is permissible. While the first tuple's
object may appear anywhere in the topology, the Nth tuple's object must have a
shallower topology depth than the (N+1)th tuple's object. Put simply: as you
move right in a tuple chain, objects must go deeper in the topology tree.
Indexes specified in chained tuples are relative to the scope of the parent
object. For example, ``socket:0.core:1`` refers to the second core in the first
socket (all indices are zero based).

Multiple affinities can be specified using several :option:`--hpx:bind` command
line options or by appending several affinities separated by a ``';'`` By
default, if multiple affinities are specified, they are added.

.. If prefixed with``"~"`` the given affinity will be cleared instead of added
   to the current list of locations. If prefixed with``"x"`` the given location
   will be and'ed instead of added to the current list. If prefixed with ``"^"``
   the given location will be xor'ed.

``"all"`` is a special affinity consisting in the entire current topology.

.. note::

   All 'names' in an affinity specification, such as ``thread``, ``socket``,
   ``numanode``, ``pu`` or ``all`` can be abbreviated. Thus the affinity
   specification ``threads:0-3=socket:0.core:1.pu:1`` is fully equivalent to its
   shortened form ``t:0-3=s:0.c:1.p:1``.

Here is a full grammar describing the possible format of mappings:

.. productionlist::
   mappings: `distribution` | `mapping` (";" `mapping`)*
   distribution: "compact" | "scatter" | "balanced" | "numa-balanced"
   mapping: `thread_spec` "=" `pu_specs`
   thread_spec: "thread:" `range_specs`
   pu_specs: `pu_spec` ("." `pu_spec`)*
   pu_spec: `type` ":" `range_specs` | "~" `pu_spec`
   range_specs: `range_spec` ("," `range_spec`)*
   range_spec: int | int "-" int | "all"
   type: "socket" | "numanode" | "core" | "pu"

The following example assumes a system with at least 4 cores, where each core
has more than 1 processing unit (hardware threads). Running
``hello_world_distributed`` with 4 OS-threads (on 4 processing units), where
each of those threads is bound to the first processing unit of each of the
cores, can be achieved by invoking:

.. code-block:: shell-session

   $ hello_world_distributed -t4 --hpx:bind=thread:0-3=core:0-3.pu:0

Here ``thread:0-3`` specifies the OS threads for which to define affinity
bindings, and ``core:0-3.pu:`` defines that for each of the cores (``core:0-3``)
only their first processing unit ``pu:0`` should be used.

.. note::

   The command line option :option:`--hpx:print-bind` can be used to print the
   bitmasks generated from the affinity mappings as specified with
   :option:`--hpx:bind`. For instance, on a system with hyperthreading enabled
   (i.e. 2 processing units per core), the command line:

   .. code-block:: shell-session

      $ hello_world_distributed -t4 --hpx:bind=thread:0-3=core:0-3.pu:0 --hpx:print-bind

   will cause this output to be printed:

   .. code-block:: text

      0: PU L#0(P#0), Core L#0, Socket L#0, Node L#0(P#0)
      1: PU L#2(P#2), Core L#1, Socket L#0, Node L#0(P#0)
      2: PU L#4(P#4), Core L#2, Socket L#0, Node L#0(P#0)
      3: PU L#6(P#6), Core L#3, Socket L#0, Node L#0(P#0)

   where each bit in the bitmasks corresponds to a processing unit the listed
   worker thread will be bound to run on.

The difference between the four possible predefined distribution schemes
(``compact``, ``scatter``, ``balanced`` and ``numa-balanced``) is best explained
with an example. Imagine that we have a system with 4 cores and 4 hardware
threads per core on 2 sockets. If we place 8 threads the assignments produced by
the ``compact``, ``scatter``, ``balanced`` and ``numa-balanced`` types are shown
in the figure below. Notice that ``compact`` does not fully utilize all the
cores in the system. For this reason it is recommended that applications are run
using the ``scatter`` or ``balanced``/``numa-balanced`` options in most cases.

.. _commandline_affinities:

.. figure:: ../_static/images/affinities.png

   Schematic of thread affinity type distributions.

In addition to the predefined distributions it is possible to restrict the
resources used by |hpx| to the process CPU mask. The CPU mask is typically set
by e.g. |mpi|_ and batch environments. Using the command line option
:option:`--hpx:use-process-mask` makes |hpx| act as if only the processing units
in the CPU mask are available for use by |hpx|. The number of threads is
automatically determined from the CPU mask. The number of threads can still be
changed manually using this option, but only to a number less than or equal to
the number of processing units in the CPU mask. The option
:option:`--hpx:print-bind` is useful in conjunction with
:option:`--hpx:use-process-mask` to make sure threads are placed as expected.

.. [#] The phase of a |hpx|-thread counts how often this thread has been
       activated.
..
    Copyright (C)      2017 Adrian Serio
    Copyright (C) 2007-2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============
Miscellaneous
=============

.. _error_handling:

Error handling
==============

Like in any other asynchronous invocation scheme, it is important to be able to
handle error conditions occurring while the asynchronous (and possibly remote)
operation is executed. In |hpx| all error handling is based on standard C++
exception handling. Any exception thrown during the execution of an asynchronous
operation will be transferred back to the original invocation :term:`locality`,
where it will be rethrown during synchronization with the calling thread.

The source code for this example can be found here:
:download:`error_handling.cpp <../../examples/quickstart/error_handling.cpp>`.

.. _exceptions:

Working with exceptions
-----------------------

For the following description assume that the function ``raise_exception()``
is executed by invoking the plain action ``raise_exception_type``.

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 13-17

The exception is thrown using the macro :c:macro:`HPX_THROW_EXCEPTION`. The type
of the thrown exception is :cpp:class:`hpx::exception`. This associates
additional diagnostic information with the exception, such as file name and line
number, :term:`locality` id and thread id, and stack backtrace from the point
where the exception was thrown.

Any exception thrown during the execution of an action is transferred back to
the (asynchronous) invocation site. It will be rethrown in this context when the
calling thread tries to wait for the result of the action by invoking either
``future<>::get()`` or the synchronous action invocation wrapper as shown here:

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 27-42

.. note::

   The exception is transferred back to the invocation site even if it is
   executed on a different :term:`locality`.

Additionally, this example demonstrates how an exception thrown by an (possibly
remote) action can be handled. It shows the use of
:cpp:func:`hpx::diagnostic_information`, which retrieves all available diagnostic
information from the exception as a formatted string. This includes, for
instance, the name of the source file and line number, the sequence number of
the OS thread and the |hpx| thread id, the :term:`locality` id and the stack
backtrace of the point where the original exception was thrown.

Under certain circumstances it is desirable to output only some of the
diagnostics, or to output those using different formatting. For this case, |hpx|
exposes a set of lower-level functions as demonstrated in the following code
snippet:

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 47-72

.. _error_code:

Working with error codes
------------------------

Most of the API functions exposed by |hpx| can be invoked in two different
modes. By default those will throw an exception on error as described above.
However, sometimes it is desirable not to throw an exception in case of an error
condition. In this case an object instance of the :cpp:class:`hpx::error_code`
type can be passed as the last argument to the API function. In case of an error,
the error condition will be returned in that :cpp:class:`hpx::error_code`
instance. The following example demonstrates extracting the full diagnostic
information without exception handling:

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 79-100

.. note::

   The error information is transferred back to the invocation site even if it
   is executed on a different :term:`locality`.

This example show how an error can be handled without having to resolve to
exceptions and that the returned :cpp:class:`hpx::error_code` instance can be
used in a very similar way as the :cpp:class:`hpx::exception` type above. Simply
pass it to the :cpp:func:`hpx::diagnostic_information`, which retrieves all
available diagnostic information from the error code instance as a formatted
string.

As for handling exceptions, when working with error codes, under certain
circumstances it is desirable to output only some of the diagnostics, or to
output those using different formatting. For this case, |hpx| exposes a set of
lower-level functions usable with error codes as demonstrated in the following
code snippet:

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 107-139

For more information please refer to the documentation of
:cpp:func:`hpx::get_error_what`, :cpp:func:`hpx::get_error_locality_id`,
:cpp:func:`hpx::get_error_host_name`, :cpp:func:`hpx::get_error_process_id`,
:cpp:func:`hpx::get_error_function_name`, :cpp:func:`hpx::get_error_file_name`,
:cpp:func:`hpx::get_error_line_number`, :cpp:func:`hpx::get_error_os_thread`,
:cpp:func:`hpx::get_error_thread_id`,
:cpp:func:`hpx::get_error_thread_description`,
:cpp:func:`hpx::get_error_backtrace`, :cpp:func:`hpx::get_error_env`, and
:cpp:func:`hpx::get_error_state`.

.. _lightweight_error_code:

Lightweight error codes
-----------------------

Sometimes it is not desirable to collect all the ambient information about the
error at the point where it happened as this might impose too much overhead for
simple scenarios. In this case, |hpx| provides a lightweight error code facility
that will hold the error code only. The following snippet demonstrates its use:

.. literalinclude:: ../../examples/quickstart/error_handling.cpp
   :language: c++
   :lines: 146-166

All functions that retrieve other diagnostic elements from the
:cpp:class:`hpx::error_code` will fail if called with a lightweight error_code
instance.

.. _utilities:

Utilities in |hpx|
==================

In order to ease the burden of programming, |hpx| provides several
utilities to users. The following section documents those facilies.

.. _checkpoint:

Checkpoint
----------

See :ref:`modules_checkpoint`.

.. _iostreams:

The |hpx| I/O-streams component
===============================

The |hpx| I/O-streams subsystem extends the standard C++ output streams
``std::cout`` and ``std::cerr`` to work in the distributed setting of an |hpx|
application. All of the output streamed to ``hpx::cout`` will be dispatched to
``std::cout`` on the console :term:`locality`. Likewise, all output generated
from ``hpx::cerr`` will be dispatched to ``std::cerr`` on the console
:term:`locality`.

.. note::

   All existing standard manipulators can be used in conjunction with
   ``hpx::cout`` and ``hpx::cerr`` Historically, |hpx| also defines
   ``hpx::endl`` and ``hpx::flush`` but those are just aliases for the
   corresponding standard manipulators.

In order to use either ``hpx::cout`` or ``hpx::cerr``, application codes need to
``#include <hpx/include/iostreams.hpp>``. For an example, please see the
following 'Hello world' program:

.. literalinclude:: ../../examples/quickstart/hello_world_1.cpp
   :language: c++

Additionally, those applications need to link with the iostreams component. When
using CMake this can be achieved by using the ``COMPONENT_DEPENDENCIES``
parameter; for instance:

.. code-block:: cmake

   include(HPX_AddExecutable)

   add_hpx_executable(
       hello_world
       SOURCES hello_world.cpp
       COMPONENT_DEPENDENCIES iostreams
   )

.. note::

   The ``hpx::cout`` and ``hpx::cerr`` streams buffer all output locally until a
   ``std::endl`` or ``std::flush`` is encountered. That means that no output
   will appear on the console as long as either of these is explicitly used.
..
    Copyright (C) 2019 Mikael Simberg

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _troubleshooting:

===============
Troubleshooting
===============

This section contains commonly encountered problems when compiling or using HPX.

.. _troubleshooting_program_options:

``Undefined reference to boost::program_options``
=================================================

Boost.ProgramOptions is not ABI compatible between all C++ versions and
compilers. Because of this you may see linker errors similar to this:

.. code-block:: text

   ...: undefined reference to `boost::program_options::operator<<(std::ostream&, boost::program_options::options_description const&)'

if you are not linking to a compatible version of Boost.ProgramOptions. We
recommend that you use ``hpx::program_options``, which is part of |hpx|, as a
replacement for ``boost::program_options`` (see :ref:`modules_program_options`).
Until you have migrated to use ``hpx::program_options`` we recommend that you
always build |boost|_ libraries and |hpx| with the same compiler and C++
standard.

.. _troubleshooting_iostreams:

``Undefined reference to hpx::cout``
====================================

You may see an linker error message that looks a bit like this:

.. code-block:: text

   hello_world.cpp:(.text+0x5aa): undefined reference to `hpx::cout'
   hello_world.cpp:(.text+0x5c3): undefined reference to `hpx::iostreams::flush'

This usually happens if you are trying to use |hpx| iostreams functionality such
as ``hpx::cout`` but are not linking against it. The iostreams functionality is
not part of the core |hpx| library, and must be linked to explicitly. Typically
this can be solved by adding ``COMPONENT_DEPENDENCIES iostreams`` to a call to
``add_hpx_library/add_hpx_executable/hpx_setup_target`` if using |cmake|. See
:ref:`creating_hpx_projects` for more details.
..
    Copyright (C) 2018 Mikael Simberg
    Copyright (C) 2014 Thomas Heller
    Copyright (C) 2007-2013 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _creating_hpx_projects:

=======================
Creating |hpx| projects
=======================

.. _pkgconfig:

Using HPX with pkg-config
=========================

.. _apps:

How to build |hpx| applications with pkg-config
-----------------------------------------------

After you are done installing |hpx|, you should be able to build the following
program. It prints ``Hello World!`` on the :term:`locality` you run it on.

.. literalinclude:: ../../examples/quickstart/hello_world_1.cpp
   :language: c++
   :start-after: //[hello_world_1_getting_started
   :end-before: //]

Copy the text of this program into a file called hello_world.cpp.

Now, in the directory where you put hello_world.cpp, issue the following
commands (where ``$HPX_LOCATION`` is the build directory or
``CMAKE_INSTALL_PREFIX`` you used while building |hpx|):

.. code-block:: shell-session

   $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
   $ c++ -o hello_world hello_world.cpp \
      `pkg-config --cflags --libs hpx_application`\
       -lhpx_iostreams -DHPX_APPLICATION_NAME=hello_world

.. important::

   When using pkg-config with |hpx|, the pkg-config flags must go after the
   ``-o`` flag.

.. note::

   |hpx| libraries have different names in debug and release mode. If you want
   to link against a debug |hpx| library, you need to use the ``_debug`` suffix
   for the pkg-config name. That means instead of ``hpx_application`` or
   ``hpx_component``, you will have to use ``hpx_application_debug`` or
   ``hpx_component_debug`` Moreover, all referenced |hpx| components need to
   have an appended ``d`` suffix. For example, instead of ``-lhpx_iostreams`` you will
   need to specify ``-lhpx_iostreamsd``.

.. important::

    If the |hpx| libraries are in a path that is not found by the dynamic
    linker, you will need to add the path ``$HPX_LOCATION/lib`` to your linker search
    path (for example ``LD_LIBRARY_PATH`` on Linux).

To test the program, type:

.. code-block:: shell-session

   $ ./hello_world

which should print ``Hello World!`` and exit.

.. _comps:

How to build |hpx| components with pkg-config
---------------------------------------------

Let's try a more complex example involving an |hpx| component. An |hpx|
component is a class that exposes |hpx| actions. |hpx| components are compiled
into dynamically loaded modules called component libraries. Here's the source
code:

**hello_world_component.cpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_component.cpp
   :language: c++
   :start-after: //[hello_world_cpp_getting_started
   :end-before: //]

**hello_world_component.hpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_component.hpp
   :language: c++
   :start-after: //[hello_world_hpp_getting_started
   :end-before: //]

**hello_world_client.cpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_client.cpp
   :language: c++
   :start-after: //[hello_world_client_getting_started
   :end-before: //]

Copy the three source files above into three files (called
``hello_world_component.cpp``, ``hello_world_component.hpp`` and
``hello_world_client.cpp``, respectively).

Now, in the directory where you put the files, run the following command to
build the component library. (where ``$HPX_LOCATION`` is the build directory or
``CMAKE_INSTALL_PREFIX`` you used while building |hpx|):

.. code-block:: shell-session

   $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
   $ c++ -o libhpx_hello_world.so hello_world_component.cpp \
      `pkg-config --cflags --libs hpx_component` \
       -lhpx_iostreams -DHPX_COMPONENT_NAME=hpx_hello_world

Now pick a directory in which to install your |hpx| component libraries. For
this example, we'll choose a directory named ``my_hpx_libs``:

.. code-block:: shell-session

   $ mkdir ~/my_hpx_libs
   $ mv libhpx_hello_world.so ~/my_hpx_libs

.. note::

   |hpx| libraries have different names in debug and release mode. If you want
   to link against a debug |hpx| library, you need to use the ``_debug`` suffix
   for the pkg-config name. That means instead of ``hpx_application`` or
   ``hpx_component`` you will have to use ``hpx_application_debug`` or
   ``hpx_component_debug``. Moreover, all referenced |hpx| components need to
   have a appended ``d`` suffix, e.g. instead of ``-lhpx_iostreams`` you will
   need to specify ``-lhpx_iostreamsd``.

.. important::

   If the |hpx| libraries are in a path that is not found by the dynamic linker.
   You need to add the path ``$HPX_LOCATION/lib`` to your linker search path
   (for example ``LD_LIBRARY_PATH`` on Linux).

Now, to build the application that uses this component (``hello_world_client.cpp``),
we do:

.. code-block:: shell-session

   $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
   $ c++ -o hello_world_client hello_world_client.cpp \
      ``pkg-config --cflags --libs hpx_application``\
       -L${HOME}/my_hpx_libs -lhpx_hello_world -lhpx_iostreams

.. important::

   When using pkg-config with |hpx|, the pkg-config flags must go after the
   ``-o`` flag.

Finally, you'll need to set your LD_LIBRARY_PATH before you can run the program.
To run the program, type:

.. code-block:: shell-session

   $ export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$HOME/my_hpx_libs"
   $ ./hello_world_client

which should print ``Hello HPX World!`` and exit.

.. _using_hpx_cmake:

Using |hpx| with CMake-based projects
=====================================

In addition to the pkg-config support discussed on the previous pages, |hpx|
comes with full CMake support. In order to integrate |hpx| into existing or
new CMakeLists.txt, you can leverage the `find_package
<https://www.cmake.org/cmake/help/latest/command/find_package.html>`_ command
integrated into CMake. Following, is a Hello World component example using CMake.

Let's revisit what we have. We have three files that compose our example
application:

* ``hello_world_component.hpp``
* ``hello_world_component.cpp``
* ``hello_world_client.hpp``

The basic structure to include |hpx| into your CMakeLists.txt is shown here:

.. code-block:: cmake

   # Require a recent version of cmake
   cmake_minimum_required(VERSION 3.18 FATAL_ERROR)

   # This project is C++ based.
   project(your_app CXX)

   # Instruct cmake to find the HPX settings
   find_package(HPX)

In order to have CMake find |hpx|, it needs to be told where to look for the
``HPXConfig.cmake`` file that is generated when |hpx| is built or installed. It is
used by ``find_package(HPX)`` to set up all the necessary macros needed to use
|hpx| in your project. The ways to achieve this are:

* Set the ``HPX_DIR`` CMake variable to point to the directory containing the
  ``HPXConfig.cmake`` script on the command line when you invoke CMake:

  .. code-block:: shell-session

     $ cmake -DHPX_DIR=$HPX_LOCATION/lib/cmake/HPX ...

  where ``$HPX_LOCATION`` is the build directory or ``CMAKE_INSTALL_PREFIX`` you
  used when building/configuring |hpx|.

* Set the ``CMAKE_PREFIX_PATH`` variable to the root directory of your |hpx|
  build or install location on the command line when you invoke CMake:

  .. code-block:: shell-session

     $ cmake -DCMAKE_PREFIX_PATH=$HPX_LOCATION ...

  The difference between ``CMAKE_PREFIX_PATH`` and ``HPX_DIR`` is that CMake
  will add common postfixes, such as ``lib/cmake/<project``, to the
  ``CMAKE_PREFIX_PATH`` and search in these locations too. Note that if your
  project uses |hpx| as well as other CMake-managed projects, the paths to the
  locations of these multiple projects may be concatenated in the
  ``CMAKE_PREFIX_PATH``.

* The variables above may be set in the CMake GUI or curses ccmake interface
  instead of the command line.

Additionally, if you wish to require |hpx| for your project, replace the
``find_package(HPX)`` line with ``find_package(HPX REQUIRED)``.

You can check if |hpx| was successfully found with the ``HPX_FOUND`` CMake variable.

.. _using_hpx_cmake_targets:

Using |cmake| targets
---------------------

The recommended way of setting up your targets to use |hpx| is to link to the
``HPX::hpx`` |cmake| target:

.. code-block:: cmake

   target_link_libraries(hello_world_component PUBLIC HPX::hpx)

This requires that you have already created the target like this:

.. code-block:: cmake

   add_library(hello_world_component SHARED hello_world_component.cpp)
   target_include_directories(hello_world_component PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

When you link your library to the ``HPX::hpx`` |cmake| target, you will be able
use |hpx| functionality in your library. To use ``main()`` as the implicit entry
point in your application you must additionally link your application to the
|cmake| target ``HPX::wrap_main``. This target is automatically linked to
executables if you are using the macros described below
(:ref:`using_hpx_cmake_macros`). See :ref:`minimal` for more information on
implicitly using ``main()`` as the entry point.

Creating a component requires setting two additional compile definitions:

.. code-block:: cmake

   target_compile_options(hello_world_component
     HPX_COMPONENT_NAME=hello_world
     HPX_COMPONENT_EXPORTS)

Instead of setting these definitions manually you may link to the
``HPX::component`` target, which sets ``HPX_COMPONENT_NAME`` to
``hpx_<target_name>``, where ``<target_name>`` is the target name of your
library. Note that these definitions should be ``PRIVATE`` to make sure these
definitions are not propagated transitively to dependent targets.

In addition to making your library a component you can make it a plugin. To do
so link to the ``HPX::plugin`` target. Similarly to ``HPX::component`` this will
set ``HPX_PLUGIN_NAME`` to ``hpx_<target_name>``. This definition should also be
``PRIVATE``. Unlike regular shared libraries, plugins are loaded at runtime from
certain directories and will not be found without additional configuration.
Plugins should be installed into a directory containing only plugins. For
example, the plugins created by |hpx| itself are installed into the ``hpx``
subdirectory in the library install directory (typically ``lib`` or ``lib64``).
When using the ``HPX::plugin`` target you need to install your plugins into an
appropriate directory. You may also want to set the location of your plugin in
the build directory with the ``*_OUTPUT_DIRECTORY*`` CMake target properties to
be able to load the plugins in the build directory. Once you've set the install
or output directory of your plugin you need to tell your executable where to
find it at runtime. You can do this either by setting the environment variable
``HPX_COMPONENT_PATHS`` or the ini setting ``hpx.component_paths`` (see
:option:`--hpx:ini`) to the directory containing your plugin.

.. _using_hpx_cmake_macros:

Using macros to create new targets
----------------------------------

In addition to the targets described above, |hpx| provides convenience macros
to hide optional boilerplate code that may be useful for your project. The link
to the targets described above. We recommend that you use the targets directly
whenever possible as they tend to compose better with other targets.

The macro for adding an |hpx| component is ``add_hpx_component``. It can be
used in your ``CMakeLists.txt`` file like this:

.. code-block:: cmake

   # build your application using HPX
   add_hpx_component(hello_world
       SOURCES hello_world_component.cpp
       HEADERS hello_world_component.hpp
       COMPONENT_DEPENDENCIES iostreams)

.. note::

   ``add_hpx_component`` adds a ``_component`` suffix to the target name. In the
   example above, a ``hello_world_component`` target will be created.

The available options to ``add_hpx_component`` are:

* ``SOURCES``: The source files for that component
* ``HEADERS``: The header files for that component
* ``DEPENDENCIES``: Other libraries or targets this component depends on
* ``COMPONENT_DEPENDENCIES``: The components this component depends on
* ``PLUGIN``: Treats this component as a plugin-able library
* ``COMPILE_FLAGS``: Additional compiler flags
* ``LINK_FLAGS``: Additional linker flags
* ``FOLDER``: Adds the headers and source files to this Source Group folder

..
   * ``SOURCE_ROOT``
   * ``HEADER_ROOT``
   * ``SOURCE_GLOB``
   * ``HEADER_GLOB``
   * ``OUTPUT_SUFFIX``
   * ``INSTALL_SUFFIX``

* ``EXCLUDE_FROM_ALL``: Do not build this component as part of the ``all`` target

..
   * ``LANGUAGE``

After adding the component, the way you add the executable is as follows:

.. code-block:: cmake

   # build your application using HPX
   add_hpx_executable(hello_world
       SOURCES hello_world_client.cpp
       COMPONENT_DEPENDENCIES hello_world)

.. note::

   ``add_hpx_executable`` automatically adds a ``_component`` suffix to dependencies
   specified in ``COMPONENT_DEPENDENCIES``, meaning you can directly use the name given
   when adding a component using ``add_hpx_component``.

When you configure your application, all you need to do is set the ``HPX_DIR``
variable to point to the installation of |hpx|.

.. note::

   All library targets built with |hpx| are exported and readily available to be
   used as arguments to `target_link_libraries
   <https://www.cmake.org/cmake/help/latest/command/target_link_libraries.html>`_
   in your targets. The |hpx| include directories are available with the
   ``HPX_INCLUDE_DIRS`` CMake variable.

.. _hpxcxx_documentation:

Using the |hpx| compiler wrapper ``hpxcxx``
-------------------------------------------

The ``hpxcxx`` compiler wrapper helps to compile a |hpx| component, application,
or object file, based on the arguments passed to it.

.. code-block:: shell-session

   $ hpxcxx [--exe=<APPLICATION_NAME> | --comp=<COMPONENT_NAME> | -c] FLAGS FILES

The ``hpxcxx`` command **requires** that either an application or a component is
built or ``-c`` flag is specified. If the build is against a debug build, the
``-g`` is to be specified while building.

Optional ``FLAGS``
..................

* ``-l <LIBRARY> | -l<LIBRARY>``: Links ``<LIBRARY>`` to the build
* ``-g``: Specifies that the application or component build is against a debug
  build
* ``-rd``: Sets ``release-with-debug-info`` option
* ``-mr``: Sets ``minsize-release`` option

All other flags (like ``-o OUTPUT_FILE``) are directly passed to the underlying
C++ compiler.
 
.. _cmake_integrate_hpx:

Using macros to set up existing targets to use |hpx|
----------------------------------------------------

In addition to the ``add_hpx_component`` and ``add_hpx_executable``, you can use
the ``hpx_setup_target`` macro to have an already existing target to be used
with the |hpx| libraries:

.. code-block:: cmake

   hpx_setup_target(target)

Optional parameters are:

* ``EXPORT``: Adds it to the CMake export list HPXTargets
* ``INSTALL``: Generates an install rule for the target
* ``PLUGIN``: Treats this component as a plugin-able library
* ``TYPE``: The type can be: EXECUTABLE, LIBRARY or COMPONENT
* ``DEPENDENCIES``: Other libraries or targets this component depends on
* ``COMPONENT_DEPENDENCIES``: The components this component depends on
* ``COMPILE_FLAGS``: Additional compiler flags
* ``LINK_FLAGS``: Additional linker flags

..
   * ``NO_HPXINIT``
   * ``NOLIBS``
   * ``FOLDER``
   * ``NAME``
   * ``SOVERSION``
   * ``VERSION``

If you do not use CMake, you can still build against |hpx|, but you should refer
to the section on :ref:`comps`.

.. note::

   Since |hpx| relies on dynamic libraries, the dynamic linker needs to know
   where to look for them. If |hpx| isn't installed into a path that is
   configured as a linker search path, external projects need to either set
   ``RPATH`` or adapt ``LD_LIBRARY_PATH`` to point to where the |hpx| libraries
   reside. In order to set ``RPATH``\ s, you can include ``HPX_SetFullRPATH`` in
   your project after all libraries you want to link against have been added.
   Please also consult the CMake documentation `here
   <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/RPATH-handling>`_.

.. _makefile:

Using |hpx| with Makefile
=========================

A basic project building with |hpx| is through creating makefiles. The process
of creating one can get complex depending upon the use of cmake parameter
``HPX_WITH_HPX_MAIN`` (which defaults to ON).

How to build |hpx| applications with makefile
---------------------------------------------

If |hpx| is installed correctly, you should be able to build and run a simple
Hello World program. It prints ``Hello World!`` on the :term:`locality` you
run it on.

.. literalinclude:: ../../examples/quickstart/hello_world_1.cpp
   :language: c++
   :start-after: //[hello_world_1_getting_started
   :end-before: //]
 
Copy the content of this program into a file called hello_world.cpp.

Now, in the directory where you put hello_world.cpp, create a Makefile.
Add the following code:

.. code-block:: makefile

   CXX=(CXX)  # Add your favourite compiler here or let makefile choose default.

   CXXFLAGS=-O3 -std=c++17

   BOOST_ROOT=/path/to/boost
   HWLOC_ROOT=/path/to/hwloc
   TCMALLOC_ROOT=/path/to/tcmalloc
   HPX_ROOT=/path/to/hpx

   INCLUDE_DIRECTIVES=$(HPX_ROOT)/include $(BOOST_ROOT)/include $(HWLOC_ROOT)/include

   LIBRARY_DIRECTIVES=-L$(HPX_ROOT)/lib $(HPX_ROOT)/lib/libhpx_init.a $(HPX_ROOT)/lib/libhpx.so $(BOOST_ROOT)/lib/libboost_atomic-mt.so $(BOOST_ROOT)/lib/libboost_filesystem-mt.so $(BOOST_ROOT)/lib/libboost_program_options-mt.so $(BOOST_ROOT)/lib/libboost_regex-mt.so $(BOOST_ROOT)/lib/libboost_system-mt.so -lpthread $(TCMALLOC_ROOT)/libtcmalloc_minimal.so $(HWLOC_ROOT)/libhwloc.so -ldl -lrt

   LINK_FLAGS=$(HPX_ROOT)/lib/libhpx_wrap.a -Wl,-wrap=main  # should be left empty for HPX_WITH_HPX_MAIN=OFF

   hello_world: hello_world.o
      $(CXX) $(CXXFLAGS) -o hello_world hello_world.o $(LIBRARY_DIRECTIVES) $(LINK_FLAGS)

   hello_world.o:
      $(CXX) $(CXXFLAGS) -c -o hello_world.o hello_world.cpp $(INCLUDE_DIRECTIVES)

.. important::

   ``LINK_FLAGS`` should be left empty if HPX_WITH_HPX_MAIN is set to OFF.
   Boost in the above example is build with ``--layout=tagged``. Actual Boost
   flags may vary on your build of Boost.

To build the program, type:

.. code-block:: shell-session

   $ make

A successful build should result in hello_world binary. To test, type:

.. code-block:: shell-session

   $ ./hello_world

How to build |hpx| components with makefile
-------------------------------------------

Let's try a more complex example involving an |hpx| component. An |hpx|
component is a class that exposes |hpx| actions. |hpx| components are compiled
into dynamically-loaded modules called component libraries. Here's the source
code:

**hello_world_component.cpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_component.cpp
   :language: c++
   :start-after: //[hello_world_cpp_getting_started
   :end-before: //]

**hello_world_component.hpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_component.hpp
   :language: c++
   :start-after: //[hello_world_hpp_getting_started
   :end-before: //]

**hello_world_client.cpp**

.. literalinclude:: ../../examples/hello_world_component/hello_world_client.cpp
   :language: c++
   :start-after: //[hello_world_client_getting_started
   :end-before: //]

Now, in the directory, create a Makefile. Add the following code:

.. code-block:: makefile

   CXX=(CXX)  # Add your favourite compiler here or let makefile choose default.

   CXXFLAGS=-O3 -std=c++17

   BOOST_ROOT=/path/to/boost
   HWLOC_ROOT=/path/to/hwloc
   TCMALLOC_ROOT=/path/to/tcmalloc
   HPX_ROOT=/path/to/hpx

   INCLUDE_DIRECTIVES=$(HPX_ROOT)/include $(BOOST_ROOT)/include $(HWLOC_ROOT)/include

   LIBRARY_DIRECTIVES=-L$(HPX_ROOT)/lib $(HPX_ROOT)/lib/libhpx_init.a $(HPX_ROOT)/lib/libhpx.so $(BOOST_ROOT)/lib/libboost_atomic-mt.so $(BOOST_ROOT)/lib/libboost_filesystem-mt.so $(BOOST_ROOT)/lib/libboost_program_options-mt.so $(BOOST_ROOT)/lib/libboost_regex-mt.so $(BOOST_ROOT)/lib/libboost_system-mt.so -lpthread $(TCMALLOC_ROOT)/libtcmalloc_minimal.so $(HWLOC_ROOT)/libhwloc.so -ldl -lrt

   LINK_FLAGS=$(HPX_ROOT)/lib/libhpx_wrap.a -Wl,-wrap=main  # should be left empty for HPX_WITH_HPX_MAIN=OFF

   hello_world_client: libhpx_hello_world hello_world_client.o
     $(CXX) $(CXXFLAGS) -o hello_world_client $(LIBRARY_DIRECTIVES) libhpx_hello_world $(LINK_FLAGS)

   hello_world_client.o: hello_world_client.cpp
     $(CXX) $(CXXFLAGS) -o hello_world_client.o hello_world_client.cpp $(INCLUDE_DIRECTIVES)

   libhpx_hello_world: hello_world_component.o
     $(CXX) $(CXXFLAGS) -o libhpx_hello_world hello_world_component.o $(LIBRARY_DIRECTIVES)

   hello_world_component.o: hello_world_component.cpp
     $(CXX) $(CXXFLAGS) -c -o hello_world_component.o hello_world_component.cpp $(INCLUDE_DIRECTIVES)

To build the program, type:

.. code-block:: shell-session

   $ make

A successful build should result in hello_world binary. To test, type:

.. code-block:: shell-session

   $ ./hello_world

.. note::

   Due to high variations in CMake flags and library dependencies, it is
   recommended to build |hpx| applications and components with pkg-config
   or CMakeLists.txt. Writing Makefile may result in broken builds if
   due care is not taken.
   pkg-config files and CMake systems are configured with CMake build of
   |hpx|. Hence, they are stable when used together and provide better support overall.
..
    Copyright (C) 2018 Nikunj Gupta
    Copyright (C) 2007-2017 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _starting_hpx:

==========================
Starting the |hpx| runtime
==========================

In order to write an application which uses services from the |hpx| runtime
system you need to initialize the |hpx| library by inserting certain calls
into the code of your application. Depending on your use case, this can be done
in 3 different ways:

* :ref:`Minimally invasive <minimal>`: Re-use the ``main()`` function as the
  main |hpx| entry point.
* :ref:`Balanced use case <medium>`: Supply your own main |hpx| entry point
  while blocking the main thread.
* :ref:`Most flexibility <flexible>`: Supply your own main |hpx| entry point
  while avoiding to block the main thread.
* :ref:`Suspend and resume <suspend_resume>`: As above but suspend and resume
  the |hpx| runtime to allow for other runtimes to be used.

.. _minimal:

Re-use the ``main()`` function as the main |hpx| entry point
============================================================

This method is the least intrusive to your code. It however provides you with
the smallest flexibility in terms of initializing the |hpx| runtime system. The
following code snippet shows what a minimal |hpx| application using this
technique looks like:

.. code-block:: c++

    #include <hpx/hpx_main.hpp>

    int main(int argc, char* argv[])
    {
        return 0;
    }

The only change to your code you have to make is to include the file
``hpx/hpx_main.hpp``. In this case the function ``main()`` will be invoked as
the first |hpx| thread of the application. The runtime system will be
initialized behind the scenes before the function ``main()`` is executed and
will automatically stop after ``main()`` has returned. For this method to work
you must link your application to the |cmake| target ``HPX::wrap_main``. This is
done automatically if you are using the provided macros
(:ref:`using_hpx_cmake_macros`) to set up your application, but must be done
explicitly if you are using targets directly (:ref:`using_hpx_cmake_targets`).
All |hpx| API functions can be used from within the ``main()`` function now.

.. note::

   The function ``main()`` does not need to expect receiving ``argc`` and
   ``argv`` as shown above, but could expose the signature ``int main()``. This
   is consistent with the usually allowed prototypes for the function ``main()``
   in C++ applications.

All command line arguments specific to |hpx| will still be processed by the
|hpx| runtime system as usual. However, those command line options will be
removed from the list of values passed to ``argc``/\ ``argv`` of the function
``main()``. The list of values passed to ``main()`` will hold only the
commandline options which are not recognized by the |hpx| runtime system (see
the section :ref:`commandline` for more details on what options are recognized
by |hpx|).

.. note::

   In this mode all one-letter-shortcuts are disabled which are normally
   available on the |hpx| command line (such as ``-t`` or ``-l`` see
   :ref:`commandline`). This is done to minimize any possible interaction
   between the command line options recognized by the |hpx| runtime system and
   any command line options defined by the application.

The value returned from the function ``main()`` as shown above will be returned
to the operating system as usual.

.. important::

   To achieve this seamless integration, the header file ``hpx/hpx_main.hpp``
   defines a macro::

        #define main hpx_startup::user_main

   which could result in unexpected behavior.

.. important::

   To achieve this seamless integration, we use different implementations for
   different operating systems. In case of Linux or macOS, the code present in
   ``hpx_wrap.cpp`` is put into action. We hook into the system function in case
   of Linux and provide alternate entry point in case of macOS. For other
   operating systems we rely on a macro::

       #define main hpx_startup::user_main

   provided in the header file ``hpx/hpx_main.hpp``. This implementation can
   result in unexpected behavior.

.. caution::

   We make use of an *override* variable ``include_libhpx_wrap`` in the header
   file ``hpx/hpx_main.hpp`` to swiftly choose the function call stack at
   runtime. Therefore, the header file should *only* be included in the main
   executable. Including it in the components will result in multiple definition
   of the variable.

.. _medium:

Supply your own main |hpx| entry point while blocking the main thread
=====================================================================

With this method you need to provide an explicit main thread function named
``hpx_main`` at global scope. This function will be invoked as the main entry
point of your |hpx| application on the console :term:`locality` only (this
function will be invoked as the first |hpx| thread of your application). All
|hpx| API functions can be used from within this function.

The thread executing the function :cpp:func:`hpx::init` will block waiting for
the runtime system to exit. The value returned from ``hpx_main`` will be
returned from :cpp:func:`hpx::init` after the runtime system has stopped.

The function :cpp:func:`hpx::finalize` has to be called on one of the |hpx|
localities in order to signal that all work has been scheduled and the runtime
system should be stopped after the scheduled work has been executed.

This method of invoking |hpx| has the advantage of you being able to decide
which version of :cpp:func:`hpx::init` to call. This allows to pass
additional configuration parameters while initializing the |hpx| runtime system.

.. code-block:: c++

   #include <hpx/hpx_init.hpp>

   int hpx_main(int argc, char* argv[])
   {
       // Any HPX application logic goes here...
       return hpx::finalize();
   }

   int main(int argc, char* argv[])
   {
       // Initialize HPX, run hpx_main as the first HPX thread, and
       // wait for hpx::finalize being called.
       return hpx::init(argc, argv);
   }

.. note::

   The function ``hpx_main`` does not need to expect receiving ``argc``/``argv``
   as shown above, but could expose one of the following signatures::

       int hpx_main();
       int hpx_main(int argc, char* argv[]);
       int hpx_main(hpx::program_options::variables_map& vm);

   This is consistent with (and extends) the usually allowed prototypes for the
   function ``main()`` in C++ applications.

The header file to include for this method of using |hpx| is
``hpx/hpx_init.hpp``.

There are many additional overloads of :cpp:func:`hpx::init` available, such as
for instance to provide your own entry point function instead of ``hpx_main``.
Please refer to the function documentation for more details (see: ``hpx/hpx_init.hpp``).

.. _flexible:

Supply your own main |hpx| entry point while avoiding to block the main thread
==============================================================================

With this method you need to provide an explicit main thread function named
``hpx_main`` at global scope. This function will be invoked as the main entry
point of your |hpx| application on the console :term:`locality` only (this
function will be invoked as the first |hpx| thread of your application). All
|hpx| API functions can be used from within this function.

The thread executing the function :cpp:func:`hpx::start` will *not* block
waiting for the runtime system to exit, but will return immediately.
The function :cpp:func:`hpx::finalize` has to be called on one of the |hpx|
localities in order to signal that all work has been scheduled and the runtime
system should be stopped after the scheduled work has been executed.

This method of invoking |hpx| is useful for applications where the main thread
is used for special operations, such a GUIs. The function :cpp:func:`hpx::stop`
can be used to wait for the |hpx| runtime system to exit and should be at least
used as the last function called in ``main()``. The value returned from
``hpx_main`` will be returned from :cpp:func:`hpx::stop` after the runtime
system has stopped.

.. code-block:: c++

    #include <hpx/hpx_start.hpp>

    int hpx_main(int argc, char* argv[])
    {
        // Any HPX application logic goes here...
        return hpx::finalize();
    }

    int main(int argc, char* argv[])
    {
        // Initialize HPX, run hpx_main.
        hpx::start(argc, argv);

        // ...Execute other code here...

        // Wait for hpx::finalize being called.
        return hpx::stop();
    }

.. note::

   The function ``hpx_main`` does not need to expect receiving ``argc``/``argv``
   as shown above, but could expose one of the following signatures::

       int hpx_main();
       int hpx_main(int argc, char* argv[]);
       int hpx_main(hpx::program_options::variables_map& vm);

   This is consistent with (and extends) the usually allowed prototypes for the
   function ``main()`` in C++ applications.

The header file to include for this method of using |hpx| is
``hpx/hpx_start.hpp``.

There are many additional overloads of :cpp:func:`hpx::start` available, such as
for instance to provide your own entry point function instead of ``hpx_main``.
Please refer to the function documentation for more details (see:
``hpx/hpx_start.hpp``).

.. _suspend_resume:

Suspending and resuming the |hpx| runtime
=========================================

In some applications it is required to combine |hpx| with other runtimes. To
support this use case |hpx| provides two functions: :cpp:func:`hpx::suspend` and
:cpp:func:`hpx::resume`. :cpp:func:`hpx::suspend` is a blocking call which will
wait for all scheduled tasks to finish executing and then put the thread pool OS
threads to sleep. :cpp:func:`hpx::resume` simply wakes up the sleeping threads
so that they are ready to accept new work. :cpp:func:`hpx::suspend` and
:cpp:func:`hpx::resume` can be found in the header ``hpx/hpx_suspend.hpp``.

.. code-block:: c++

   #include <hpx/hpx_start.hpp>
   #include <hpx/hpx_suspend.hpp>

   int main(int argc, char* argv[])
   {

      // Initialize HPX, don't run hpx_main
       hpx::start(nullptr, argc, argv);

       // Schedule a function on the HPX runtime
       hpx::apply(&my_function, ...);

       // Wait for all tasks to finish, and suspend the HPX runtime
       hpx::suspend();

       // Execute non-HPX code here

       // Resume the HPX runtime
       hpx::resume();

       // Schedule more work on the HPX runtime

       // hpx::finalize has to be called from the HPX runtime before hpx::stop
       hpx::apply([]() { hpx::finalize(); });
       return hpx::stop();
   }

.. note::

   :cpp:func:`hpx::suspend` does not wait for :cpp:func:`hpx::finalize` to be
   called. Only call :cpp:func:`hpx::finalize` when you wish to fully stop the
   |hpx| runtime.

.. warning::

   :cpp:func:`hpx::suspend` only waits for local tasks, i.e. tasks on the
    current locality, to finish executing. When using :cpp:func:`hpx::suspend`
    in a multi-locality scenario the user is responsible for ensuring that any
    work required from other localities has also finished.

|hpx| also supports suspending individual thread pools and threads. For details
on how to do that see the documentation for :cpp:class:`hpx::threads::thread_pool_base`.

Automatically suspending worker threads
---------------------------------------

The previous method guarantees that the worker threads are suspended when you
ask for it and that they stay suspended. An alternative way to achieve the same
effect is to tweak how quickly |hpx| suspends its worker threads when they run
out of work. The following configuration values make sure that |hpx| idles very
quickly:

.. code-block:: ini

   hpx.max_idle_backoff_time = 1000
   hpx.max_idle_loop_count = 0

They can be set on the command line using
``--hpx:ini=hpx.max_idle_backoff_time=1000`` and
``--hpx:ini=hpx.max_idle_loop_count=0``. See :ref:`launching_and_configuring`
for more details on how to set configuration parameters.

After setting idling parameters the previous example could now be written like
this instead:

.. code-block:: c++

   #include <hpx/hpx_start.hpp>

   int main(int argc, char* argv[])
   {

      // Initialize HPX, don't run hpx_main
       hpx::start(nullptr, argc, argv);

       // Schedule some functions on the HPX runtime
       // NOTE: run_as_hpx_thread blocks until completion.
       hpx::run_as_hpx_thread(&my_function, ...);
       hpx::run_as_hpx_thread(&my_other_function, ...);

       // hpx::finalize has to be called from the HPX runtime before hpx::stop
       hpx::apply([]() { hpx::finalize(); });
       return hpx::stop();
   }

In this example each call to :cpp:func:`hpx::run_as_hpx_thread` acts as a
"parallel region".

.. _hpx_main_implementation:

Working of ``hpx_main.hpp``
===========================

In order to initialize |hpx| from ``main()``, we make use of linker tricks.

It is implemented differently for different Operating Systems. Method of
implementation is as follows:

* :ref:`Linux <hpx_main_implementation_linux>`: Using linker ``--wrap`` option.
* :ref:`Mac OSX <hpx_main_implementation_osx>`: Using the linker ``-e`` option.
* :ref:`Windows <hpx_main_implementation_windows>`: Using ``#define main
  hpx_startup::user_main``

.. _hpx_main_implementation_linux:

Linux implementation
--------------------

We make use of the Linux linker ``ld``\ 's ``--wrap`` option to wrap the
``main()`` function. This way any call to ``main()`` are redirected to our own
implementation of main. It is here that we check for the existence of
``hpx_main.hpp`` by making use of a shadow variable ``include_libhpx_wrap``. The
value of this variable determines the function stack at runtime.

The implementation can be found in ``libhpx_wrap.a``.

.. important::

   It is necessary that ``hpx_main.hpp`` be not included more than once.
   Multiple inclusions can result in multiple definition of
   ``include_libhpx_wrap``.

.. _hpx_main_implementation_osx:

Mac OSX implementation
----------------------

Here we make use of yet another linker option ``-e`` to change the entry point
to our custom entry function ``initialize_main``. We initialize the |hpx|
runtime system from this function and call main from the initialized system. We
determine the function stack at runtime by making use of the shadow variable
``include_libhpx_wrap``.

The implementation can be found in ``libhpx_wrap.a``.

.. important::

   It is necessary that ``hpx_main.hpp`` be not included more than once.
   Multiple inclusions can result in multiple definition of
   ``include_libhpx_wrap``.

.. _hpx_main_implementation_windows:

Windows implementation
----------------------

We make use of a macro ``#define main hpx_startup::user_main`` to take care of
the initializations.

This implementation could result in unexpected behaviors.
..
    Copyright (C) 2017 Antoine Tran Tan
    Copyright (C) 2007-2015 Hartmut Kaiser
    Copyright (C) 2012 Bryce Adelstein-Lelbach

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _writing_distributed_hpx_applications:

======================================
Writing distributed |hpx| applications
======================================

This section focuses on the features of |hpx| needed to write distributed
applications, namely the :term:`Active Global Address Space` (:term:`AGAS`),
remotely executable functions (i.e. :term:`actions <action>`), and distributed
objects (i.e. :term:`components <component>`).

.. _global_names:

Global names
============

|hpx| implements an :term:`Active Global Address Space` (:term:`AGAS`) which is
exposing a single uniform address space spanning all localities an application
runs on. :term:`AGAS` is a fundamental component of the ParalleX execution
model. Conceptually, there is no rigid demarcation of local or global memory in
:term:`AGAS`; all available memory is a part of the same address space.
:term:`AGAS` enables named objects to be moved (migrated) across localities
without having to change the object's name, i.e., no references to migrated
objects have to be ever updated. This feature has significance for dynamic load
balancing and in applications where the workflow is highly dynamic, allowing
work to be migrated from heavily loaded nodes to less loaded nodes. In addition,
immutability of names ensures that :term:`AGAS` does not have to keep extra
indirections ("bread crumbs") when objects move, hence minimizing complexity of
code management for system developers as well as minimizing overheads in
maintaining and managing aliases.

The :term:`AGAS` implementation in |hpx| does not automatically expose every
local address to the global address space. It is the responsibility of the
programmer to explicitly define which of the objects have to be globally visible
and which of the objects are purely local.

In |hpx| global addresses (global names) are represented using the
``hpx::id_type`` data type. This data type is conceptually very similar to
``void*`` pointers as it does not expose any type information of the object it
is referring to.

The only predefined global addresses are assigned to all localities. The
following |hpx| API functions allow one to retrieve the global addresses of
localities:

* :cpp:func:`hpx::find_here`: retrieve the global address of the
  :term:`locality` this function is called on.
* :cpp:func:`hpx::find_all_localities()`: retrieve the global addresses of all
  localities available to this application (including the :term:`locality` the
  function is being called on).
* :cpp:func:`hpx::find_remote_localities()`: retrieve the global addresses of
  all remote localities available to this application (not including the
  :term:`locality` the function is being called on)
* :cpp:func:`hpx::get_num_localities()`: retrieve the number of localities
  available to this application.
* :cpp:func:`hpx::find_locality()`: retrieve the global address of any
  :term:`locality` supporting the given component type.
* :cpp:func:`hpx::get_colocation_id()`: retrieve the global address of the
  :term:`locality` currently hosting the object with the given global address.

Additionally, the global addresses of localities can be used to create new
instances of components using the following |hpx| API function:

* :cpp:func:`hpx::components::new_()`: Create a new instance of the given
  ``Component`` type on the specified :term:`locality`.

.. note::

   |hpx| does not expose any functionality to delete component instances. All
   global addresses (as represented using ``hpx::id_type``) are automatically
   garbage collected. When the last (global) reference to a particular component
   instance goes out of scope the corresponding component instance is
   automatically deleted.

.. _applying_actions:

Applying actions
================

.. _action_type_definition:

Action type definition
----------------------

Actions are special types we use to describe possibly remote operations. For
every global function and every member function which has to be invoked
distantly, a special type must be defined. For any global function the special
macro :c:macro:`HPX_PLAIN_ACTION` can be used to define the
action type. Here is an example demonstrating this::

    namespace app
    {
        void some_global_function(double d)
        {
            cout << d;
        }
    }

    // This will define the action type 'some_global_action' which represents
    // the function 'app::some_global_function'.
    HPX_PLAIN_ACTION(app::some_global_function, some_global_action);

.. important::

   The macro :c:macro:`HPX_PLAIN_ACTION` has to be placed in
   global namespace, even if the wrapped function is located in some other
   namespace. The newly defined action type is placed in the global namespace as
   well.

If the action type should be defined somewhere not in global namespace, the
action type definition has to be split into two macro invocations
(:c:macro:`HPX_DEFINE_PLAIN_ACTION` and :c:macro:`HPX_REGISTER_ACTION`) as shown
in the next example::

    namespace app
    {
        void some_global_function(double d)
        {
            cout << d;
        }

        // On conforming compilers the following macro expands to:
        //
        //    typedef hpx::actions::make_action<
        //        decltype(&some_global_function), &some_global_function
        //    >::type some_global_action;
        //
        // This will define the action type 'some_global_action' which represents
        // the function 'some_global_function'.
        HPX_DEFINE_PLAIN_ACTION(some_global_function, some_global_action);
    }

    // The following macro expands to a series of definitions of global objects
    // which are needed for proper serialization and initialization support
    // enabling the remote invocation of the function``some_global_function``
    HPX_REGISTER_ACTION(app::some_global_action, app_some_global_action);

The shown code defines an action type ``some_global_action`` inside the namespace
``app``.

.. important::

   If the action type definition is split between two macros as shown above, the
   name of the action type to create has to be the same for both macro
   invocations (here ``some_global_action``).

.. important::

   The second argument passed to :c:macro:`HPX_REGISTER_ACTION` (``app_some_global_action``) has
   to comprise a globally unique C++ identifier representing the action. This is
   used for serialization purposes.

For member functions of objects which have been registered with :term:`AGAS`
(e.g. 'components') a different registration macro
:c:macro:`HPX_DEFINE_COMPONENT_ACTION` has to be utilized. Any component needs
to be declared in a header file and have some special support macros defined in
a source file. Here is an example demonstrating this. The first snippet has to
go into the header file::

    namespace app
    {
        struct some_component
          : hpx::components::component_base<some_component>
        {
            int some_member_function(std::string s)
            {
                return boost::lexical_cast<int>(s);
            }

            // This will define the action type 'some_member_action' which
            // represents the member function 'some_member_function' of the
            // object type 'some_component'.
            HPX_DEFINE_COMPONENT_ACTION(some_component, some_member_function,
                some_member_action);
        };
    }

    // Note: The second argument to the macro below has to be systemwide-unique
    //       C++ identifiers
    HPX_REGISTER_ACTION_DECLARATION(app::some_component::some_member_action, some_component_some_action);

The next snippet belongs into a source file (e.g. the main application source
file) in the simplest case::

    typedef hpx::components::component<app::some_component> component_type;
    typedef app::some_component some_component;

    HPX_REGISTER_COMPONENT(component_type, some_component);

    // The parameters for this macro have to be the same as used in the corresponding
    // HPX_REGISTER_ACTION_DECLARATION() macro invocation above
    typedef some_component::some_member_action some_component_some_action;
    HPX_REGISTER_ACTION(some_component_some_action);

Granted, these macro invocations are a bit more complex than for simple global
functions, however we believe they are still manageable.

The most important macro invocation is the :c:macro:`HPX_DEFINE_COMPONENT_ACTION` in the header file
as this defines the action type we need to invoke the member function. For a
complete example of a simple component action see :download:`component_in_executable.cpp <../../examples/quickstart/component_in_executable.cpp>`.

.. _action_invocation:

Action invocation
-----------------

The process of invoking a global function (or a member function of an object)
with the help of the associated action is called 'applying the action'. Actions
can have arguments, which will be supplied while the action is applied. At the
minimum, one parameter is required to apply any action - the id of the
:term:`locality` the associated function should be invoked on (for global
functions), or the id of the component instance (for member functions).
Generally, |hpx| provides several ways to apply an action, all of which are
described in the following sections.

Generally, |hpx| actions are very similar to 'normal' C++ functions except that
actions can be invoked remotely. :numref:`figure_hpx_the_api` below shows an
overview of the main API exposed by HPX. This shows the function invocation
syntax as defined by the C++ language (dark gray), the additional invocation
syntax as provided through C++ Standard Library features (medium gray), and the
extensions added by |hpx| (light gray) where:

* ``f`` function to invoke,
* ``p..``: (optional) arguments,
* ``R``: return type of ``f``,
* ``action``: action type defined by, :c:macro:`HPX_DEFINE_PLAIN_ACTION` or
  :c:macro:`HPX_DEFINE_COMPONENT_ACTION` encapsulating ``f``,
* ``a``: an instance of the type ```action``,
* ``id``: the global address the action is applied to.

.. _figure_hpx_the_api:

.. figure:: ../_static/images/hpx_the_api.png

   Overview of the main API exposed by |hpx|.

This figure shows that |hpx| allows the user to apply actions with a syntax
similar to the C++ standard. In fact, all action types have an overloaded
function operator allowing to synchronously apply the action. Further, |hpx|
implements ``hpx::async`` which semantically works similar to the
way ``std::async`` works for plain C++ function.

.. note::

   The similarity of applying an action to conventional function invocations
   extends even further. |hpx| implements ``hpx::bind`` and ``hpx::function``
   two facilities which are semantically equivalent to the ``std::bind`` and
   ``std::function`` types as defined by the C++11 Standard. While
   ``hpx::async`` extends beyond the conventional semantics by supporting
   actions and conventional C++ functions, the |hpx| facilities ``hpx::bind``
   and ``hpx::function`` extend beyond the conventional standard facilities too.
   The |hpx| facilities not only support conventional functions, but can be used
   for actions as well.

Additionally, |hpx| exposes ``hpx::apply`` and ``hpx::async_continue`` both of
which refine and extend the standard C++ facilities.

The different ways to invoke a function in |hpx| will be explained in more
detail in the following sections.

.. _apply:

Applying an action asynchronously without any synchronization
-------------------------------------------------------------

This method ('fire and forget') will make sure the function associated with the
action is scheduled to run on the target :term:`locality`. Applying the action
does not wait for the function to start running, instead it is a fully
asynchronous operation. The following example shows how to apply the action as
defined :ref:`in the previous section <action_type_definition>` on the local
:term:`locality` (the :term:`locality` this code runs on)::

    some_global_action act;     // define an instance of some_global_action
    hpx::apply(act, hpx::find_here(), 2.0);

(the function ``hpx::find_here()`` returns the id of the local :term:`locality`,
i.e. the :term:`locality` this code executes on).

Any component member function can be invoked using the same syntactic construct.
Given that ``id`` is the global address for a component instance created
earlier, this invocation looks like::

    some_component_action act;     // define an instance of some_component_action
    hpx::apply(act, id, "42");

In this case any value returned from this action (e.g. in this case the integer
``42`` is ignored. Please look at :ref:`action_type_definition` for the code
defining the component action ``some_component_action`` used.

.. _async:

Applying an action asynchronously with synchronization
------------------------------------------------------

This method will make sure the action is scheduled to run on the target
:term:`locality`. Applying the action itself does not wait for the function to
start running or to complete, instead this is a fully asynchronous operation
similar to using ``hpx::apply`` as described above. The difference is that this
method will return an instance of a ``hpx::future<>`` encapsulating the result
of the (possibly remote) execution. The future can be used to synchronize with
the asynchronous operation. The following example shows how to apply the action
from above on the local :term:`locality`::

    some_global_action act;     // define an instance of some_global_action
    hpx::future<void> f = hpx::async(act, hpx::find_here(), 2.0);
    //
    // ... other code can be executed here
    //
    f.get();    // this will possibly wait for the asynchronous operation to 'return'

(as before, the function ``hpx::find_here()`` returns the id of the local
:term:`locality` (the :term:`locality` this code is executed on).

.. note::

   The use of a ``hpx::future<void>`` allows the current thread to synchronize
   with any remote operation not returning any value.

.. note::

   Any ``std::future<>`` returned from ``std::async()`` is required to block in
   its destructor if the value has not been set for this future yet. This is not
   true for ``hpx::future<>`` which will never block in its destructor, even if
   the value has not been returned to the future yet. We believe that
   consistency in the behavior of futures is more important than standards
   conformance in this case.

Any component member function can be invoked using the same syntactic construct.
Given that ``id`` is the global address for a component instance created
earlier, this invocation looks like::

    some_component_action act;     // define an instance of some_component_action
    hpx::future<int> f = hpx::async(act, id, "42");
    //
    // ... other code can be executed here
    //
    cout << f.get();    // this will possibly wait for the asynchronous operation to 'return' 42

.. note::

   The invocation of ``f.get()`` will return the result immediately (without
   suspending the calling thread) if the result from the asynchronous operation
   has already been returned. Otherwise, the invocation of ``f.get()`` will
   suspend the execution of the calling thread until the asynchronous operation
   returns its result.

.. _sync:

Applying an action synchronously
--------------------------------

This method will schedule the function wrapped in the specified action on the
target :term:`locality`. While the invocation appears to be synchronous (as we
will see), the calling thread will be suspended while waiting for the function
to return. Invoking a plain action (e.g. a global function) synchronously is
straightforward::

    some_global_action act;     // define an instance of some_global_action
    act(hpx::find_here(), 2.0);

While this call looks just like a normal synchronous function invocation, the
function wrapped by the action will be scheduled to run on a new thread and the
calling thread will be suspended. After the new thread has executed the wrapped
global function, the waiting thread will resume and return from the synchronous
call.

Equivalently, any action wrapping a component member function can be invoked
synchronously as follows::

    some_component_action act;     // define an instance of some_component_action
    int result = act(id, "42");

The action invocation will either schedule a new thread locally to execute the
wrapped member function (as before, ``id`` is the global address of the
component instance the member function should be invoked on), or it will send a
parcel to the remote :term:`locality` of the component causing a new thread to
be scheduled there. The calling thread will be suspended until the function
returns its result. This result will be returned from the synchronous action
invocation.

It is very important to understand that this 'synchronous' invocation syntax in
fact conceals an asynchronous function call. This is beneficial as the calling
thread is suspended while waiting for the outcome of a potentially remote
operation. The |hpx| thread scheduler will schedule other work in the meantime,
allowing the application to make further progress while the remote result is
computed. This helps overlapping computation with communication and hiding
communication latencies.

.. note::

   The syntax of applying an action is always the same, regardless whether the
   target :term:`locality` is remote to the invocation :term:`locality` or not.
   This is a very important feature of |hpx| as it frees the user from the task
   of keeping track what actions have to be applied locally and which actions
   are remote. If the target for applying an action is local, a new thread is
   automatically created and scheduled. Once this thread is scheduled and run,
   it will execute the function encapsulated by that action. If the target is
   remote, |hpx| will send a parcel to the remote :term:`locality` which
   encapsulates the action and its parameters. Once the parcel is received on
   the remote :term:`locality` |hpx| will create and schedule a new thread
   there. Once this thread runs on the remote :term:`locality`, it will execute
   the function encapsulated by the action.

.. _async_continue:

Applying an action with a continuation but without any synchronization
----------------------------------------------------------------------

This method is very similar to the method described in section :ref:`apply`. The
difference is that it allows the user to chain a sequence of asynchronous
operations, while handing the (intermediate) results from one step to the next
step in the chain. Where ``hpx::apply`` invokes a single function using 'fire
and forget' semantics, ``hpx::apply_continue`` asynchronously triggers a chain
of functions without the need for the execution flow 'to come back' to the
invocation site. Each of the asynchronous functions can be executed on a
different :term:`locality`.

.. _apply_continue:

Applying an action with a continuation and with synchronization
---------------------------------------------------------------

This method is very similar to the method described in section :ref:`async`. In
addition to what ``hpx::async`` can do, the functions ``hpx::async_continue``
takes an additional function argument. This function will be called as the
continuation of the executed action. It is expected to perform additional
operations and to make sure that a result is returned to the original invocation
site. This method chains operations asynchronously by providing a continuation
operation which is automatically executed once the first action has finished
executing.

As an example we chain two actions, where the result of the first action is
forwarded to the second action and the result of the second action is sent back
to the original invocation site::

    // first action
    std::int32_t action1(std::int32_t i)
    {
        return i+1;
    }
    HPX_PLAIN_ACTION(action1);    // defines action1_type

    // second action
    std::int32_t action2(std::int32_t i)
    {
        return i*2;
    }
    HPX_PLAIN_ACTION(action2);    // defines action2_type

    // this code invokes 'action1' above and passes along a continuation
    // function which will forward the result returned from 'action1' to
    // 'action2'.
    action1_type act1;     // define an instance of 'action1_type'
    action2_type act2;     // define an instance of 'action2_type'
    hpx::future<int> f =
        hpx::async_continue(act1, hpx::make_continuation(act2),
            hpx::find_here(), 42);
    hpx::cout << f.get() << "\n";   // will print: 86 ((42 + 1) * 2)

By default, the continuation is executed on the same :term:`locality` as
``hpx::async_continue`` is invoked from. If you want to specify the
:term:`locality` where the continuation should be executed, the code above has
to be written as::

    // this code invokes 'action1' above and passes along a continuation
    // function which will forward the result returned from 'action1' to
    // 'action2'.
    action1_type act1;     // define an instance of 'action1_type'
    action2_type act2;     // define an instance of 'action2_type'
    hpx::future<int> f =
        hpx::async_continue(act1, hpx::make_continuation(act2, hpx::find_here()),
            hpx::find_here(), 42);
    hpx::cout << f.get() << "\n";   // will print: 86 ((42 + 1) * 2)

Similarly, it is possible to chain more than 2 operations::

    action1_type act1;     // define an instance of 'action1_type'
    action2_type act2;     // define an instance of 'action2_type'
    hpx::future<int> f =
        hpx::async_continue(act1,
            hpx::make_continuation(act2, hpx::make_continuation(act1)),
            hpx::find_here(), 42);
    hpx::cout << f.get() << "\n";   // will print: 87 ((42 + 1) * 2 + 1)

The function ``hpx::make_continuation`` creates a special function object
which exposes the following prototype::

    struct continuation
    {
        template <typename Result>
        void operator()(hpx::id_type id, Result&& result) const
        {
            ...
        }
    };

where the parameters passed to the overloaded function operator ``operator()()``
are:

* the ``id`` is the global id where the final result of the asynchronous chain
  of operations should be sent to (in most cases this is the id of the
  ``hpx::future`` returned from the initial call to ``hpx::async_continue``. Any
  custom continuation function should make sure this ``id`` is forwarded to the
  last operation in the chain.
* the ``result`` is the result value of the current operation in the
  asynchronous execution chain. This value needs to be forwarded to the next
  operation.

.. note::

   All of those operations are implemented by the predefined continuation
   function object which is returned from ``hpx::make_continuation``. Any (custom)
   function object used as a continuation should conform to the same interface.

.. _action_error_handling:

Action error handling
---------------------

Like in any other asynchronous invocation scheme it is important to be able to
handle error conditions occurring while the asynchronous (and possibly remote)
operation is executed. In |hpx| all error handling is based on standard C++
exception handling. Any exception thrown during the execution of an asynchronous
operation will be transferred back to the original invocation :term:`locality`,
where it is rethrown during synchronization with the calling thread.

.. important::

   Exceptions thrown during asynchronous execution can be transferred back to
   the invoking thread only for the synchronous and the asynchronous case with
   synchronization. Like with any other unhandled exception, any exception
   thrown during the execution of an asynchronous action *without*
   synchronization will result in calling ``hpx::terminate`` causing the running
   application to exit immediately.

.. note::

   Even if error handling internally relies on exceptions, most of the API
   functions exposed by |hpx| can be used without throwing an exception. Please
   see :ref:`exceptions` for more information.

As an example, we will assume that the following remote function will be
executed::

    namespace app
    {
        void some_function_with_error(int arg)
        {
            if (arg < 0) {
                HPX_THROW_EXCEPTION(bad_parameter, "some_function_with_error",
                    "some really bad error happened");
            }
            // do something else...
        }
    }

    // This will define the action type 'some_error_action' which represents
    // the function 'app::some_function_with_error'.
    HPX_PLAIN_ACTION(app::some_function_with_error, some_error_action);

The use of :c:macro:`HPX_THROW_EXCEPTION` to report the error encapsulates the
creation of a :cpp:class:`hpx::exception` which is initialized with the error
code ``hpx::bad_parameter``. Additionally it carries the passed strings, the
information about the file name, line number, and call stack of the point the
exception was thrown from.

We invoke this action using the synchronous syntax as described before::

    // note: wrapped function will throw hpx::exception
    some_error_action act;            // define an instance of some_error_action
    try {
        act(hpx::find_here(), -3);    // exception will be rethrown from here
    }
    catch (hpx::exception const& e) {
        // prints: 'some really bad error happened: HPX(bad parameter)'
        cout << e.what();
    }

If this action is invoked asynchronously with synchronization, the exception is
propagated to the waiting thread as well and is re-thrown from the future's
function ``get()``::

    // note: wrapped function will throw hpx::exception
    some_error_action act;            // define an instance of some_error_action
    hpx::future<void> f = hpx::async(act, hpx::find_here(), -3);
    try {
        f.get();                      // exception will be rethrown from here
    }
    catch (hpx::exception const& e) {
        // prints: 'some really bad error happened: HPX(bad parameter)'
        cout << e.what();
    }

For more information about error handling please refer to the section
:ref:`exceptions`. There we also explain how to handle error conditions without
having to rely on exception.

.. _components:

Writing components
==================

A component in |hpx| is a C++ class which can be created remotely and for which
its member functions can be invoked remotely as well. The following sections
highlight how components can be defined, created, and used.

.. _components_server:

Defining components
-------------------

In order for a C++ class type to be managed remotely in |hpx|, the type must be
derived from the ``hpx::components::component_base`` template type. We
call such C++ class types 'components'.

Note that the component type itself is passed as a template argument to the base
class::

    // header file some_component.hpp

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a new component type 'some_component'
        struct some_component
          : hpx::components::component_base<some_component>
        {
            // This member function is has to be invoked remotely
            int some_member_function(std::string const& s)
            {
                return boost::lexical_cast<int>(s);
            }

            // This will define the action type 'some_member_action' which
            // represents the member function 'some_member_function' of the
            // object type 'some_component'.
            HPX_DEFINE_COMPONENT_ACTION(some_component, some_member_function, some_member_action);
        };
    }

    // This will generate the necessary boiler-plate code for the action allowing
    // it to be invoked remotely. This declaration macro has to be placed in the
    // header file defining the component itself.
    //
    // Note: The second argument to the macro below has to be systemwide-unique
    //       C++ identifiers
    //
    HPX_REGISTER_ACTION_DECLARATION(app::some_component::some_member_action, some_component_some_action);

There is more boiler plate code which has to be placed into a source file in
order for the component to be usable. Every component type is required to have
macros placed into its source file, one for each component type and one macro
for each of the actions defined by the component type.

For instance::

    // source file some_component.cpp

    #include "some_component.hpp"

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'app::some_component' instances with 'hpx::new_<>()'
    //
    using some_component = app::some_component;
    using some_component_type = hpx::components::component<some_component>;

    // Please note that the second argument to this macro must be a
    // (system-wide) unique C++-style identifier (without any namespaces)
    //
    HPX_REGISTER_COMPONENT(some_component_type, some_component);

    // The parameters for this macro have to be the same as used in the corresponding
    // HPX_REGISTER_ACTION_DECLARATION() macro invocation in the corresponding
    // header file.
    //
    // Please note that the second argument to this macro must be a
    // (system-wide) unique C++-style identifier (without any namespaces)
    //
    HPX_REGISTER_ACTION(app::some_component::some_member_action, some_component_some_action);

.. _components_client:

Defining client side representation classes
-------------------------------------------

Often it is very convenient to define a separate type for a component which can
be used on the client side (from where the component is instantiated and used).
This step might seem as unnecessary duplicating code, however it significantly
increases the type safety of the code.

A possible implementation of such a client side representation for the component
described in the previous section could look like::

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a client side representation type for the component type
        // 'some_component' defined in the previous section.
        //
        struct some_component_client
          : hpx::components::client_base<some_component_client, some_component>
        {
            using base_type = hpx::components::client_base<
                    some_component_client, some_component>;

            some_component_client(hpx::future<hpx::id_type> && id)
              : base_type(std::move(id))
            {}

            hpx::future<int> some_member_function(std::string const& s)
            {
                some_component::some_member_action act;
                return hpx::async(act, get_id(), s);
            }
        };
    }

A client side object stores the global id of the component instance it
represents. This global id is accessible by calling the function
``client_base<>::get_id()``. The special constructor which is provided in the
example allows to create this client side object directly using the API function
:cpp:func:`hpx::new_`.

.. _create_components:

Creating component instances
----------------------------

Instances of defined component types can be created in two different ways. If
the component to create has a defined client side representation type, then this
can be used, otherwise use the server type.

The following examples assume that ``some_component_type`` is the type of the
server side implementation of the component to create. All additional arguments
(see ``, ...`` notation below) are passed through to the corresponding
constructor calls of those objects::

    // create one instance on the given locality
    hpx::id_type here = hpx::find_here();
    hpx::future<hpx::id_type> f =
        hpx::new_<some_component_type>(here, ...);

    // create one instance using the given distribution
    // policy (here: hpx::colocating_distribution_policy)
    hpx::id_type here = hpx::find_here();
    hpx::future<hpx::id_type> f =
        hpx::new_<some_component_type>(hpx::colocated(here), ...);

    // create multiple instances on the given locality
    hpx::id_type here = find_here();
    hpx::future<std::vector<hpx::id_type>> f =
        hpx::new_<some_component_type[]>(here, num, ...);

    // create multiple instances using the given distribution
    // policy (here: hpx::binpacking_distribution_policy)
    hpx::future<std::vector<hpx::id_type>> f = hpx::new_<some_component_type[]>(
        hpx::binpacking(hpx::find_all_localities()), num, ...);

The examples below demonstrate the use of the same API functions for creating
client side representation objects (instead of just plain ids). These examples
assume that ``client_type`` is the type of the client side representation of the
component type to create. As above, all additional arguments
(see ``, ...`` notation below) are passed through to the corresponding constructor
calls of the server side implementation objects corresponding to the
``client_type``::

    // create one instance on the given locality
    hpx::id_type here = hpx::find_here();
    client_type c = hpx::new_<client_type>(here, ...);

    // create one instance using the given distribution
    // policy (here: hpx::colocating_distribution_policy)
    hpx::id_type here = hpx::find_here();
    client_type c = hpx::new_<client_type>(hpx::colocated(here), ...);

    // create multiple instances on the given locality
    hpx::id_type here = hpx::find_here();
    hpx::future<std::vector<client_type>> f =
        hpx::new_<client_type[]>(here, num, ...);

    // create multiple instances using the given distribution
    // policy (here: hpx::binpacking_distribution_policy)
    hpx::future<std::vector<client_type>> f = hpx::new_<client_type[]>(
        hpx::binpacking(hpx::find_all_localities()), num, ...);

.. _use_components:

Using component instances
-------------------------

.. _containers:

Segmented containers
====================

In parallel programming, there is now a plethora of solutions aimed at
implementing "partially contiguous" or segmented data structures, whether on
shared memory systems or distributed memory systems. |hpx| implements such
structures by drawing inspiration from Standard C++ containers.

.. _parallel_containers:

Using segmented containers
--------------------------

A segmented container is a template class that is described in the namespace
``hpx``. All segmented containers are very similar semantically to their
sequential counterpart (defined in ``namespace std`` but with an additional
template parameter named ``DistPolicy``). The distribution policy is an optional
parameter that is passed last to the segmented container constructor (after the
container size when no default value is given, after the default value if not).
The distribution policy describes the manner in which a container is segmented
and the placement of each segment among the available runtime localities.

However, only a part of the ``std`` container member functions were
reimplemented:

* ``(constructor)``, ``(destructor)``, ``operator=``
* ``operator[]``
* ``begin``, ``cbegin``, ``end``, ``cend``
* ``size``

An example of how to use the ``partitioned_vector`` container would be::

    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    // By default, the number of segments is equal to the current number of
    // localities
    //
    hpx::partitioned_vector<double> va(50);
    hpx::partitioned_vector<double> vb(50, 0.0);

An example of how to use the ``partitioned_vector`` container
with distribution policies would be::

    #include <hpx/include/partitioned_vector.hpp>
    #include <hpx/runtime_distributed/find_localities.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    std::size_t num_segments = 10;
    std::vector<hpx::id_type> locs = hpx::find_all_localities()

    auto layout =
            hpx::container_layout( num_segments, locs );

    // The number of segments is 10 and those segments are spread across the
    // localities collected in the variable locs in a Round-Robin manner
    //
    hpx::partitioned_vector<double> va(50, layout);
    hpx::partitioned_vector<double> vb(50, 0.0, layout);

By definition, a segmented container must be accessible from any thread although
its construction is synchronous only for the thread who has called its
constructor. To overcome this problem, it is possible to assign a symbolic name
to the segmented container::

    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    hpx::future<void> fserver = hpx::async(
      [](){
        hpx::partitioned_vector<double> v(50);

        // Register the 'partitioned_vector' with the name "some_name"
        //
        v.register_as("some_name");

        /* Do some code  */
      });

    hpx::future<void> fclient =
      hpx::async(
        [](){
          // Naked 'partitioned_vector'
          //
          hpx::partitioned_vector<double> v;

          // Now the variable v points to the same 'partitioned_vector' that has
          // been registered with the name "some_name"
          //
          v.connect_to("some_name");

          /* Do some code  */
        });

Segmented containers
....................

|hpx| provides the following segmented containers:

.. list-table:: Sequence containers

   * * Name
     * Description
     * In header
     * Class page at cppreference.com
   * * ``hpx::partitioned_vector``
     * Dynamic segmented contiguous array.
     * ``<hpx/include/partitioned_vector.hpp>``
     * :cppreference-container:`vector`

.. list-table:: Unordered associative containers

   * * Name
     * Description
     * In header
     * Class page at cppreference.com
   * * ``hpx::unordered_map``
     * Segmented collection of key-value pairs, hashed by keys, keys are unique.
     * ``<hpx/include/unordered_map.hpp>``
     * :cppreference-container:`unordered_map`

.. _segmented_iterators:

Segmented iterators and segmented iterator traits
-------------------------------------------------

The basic iterator used in the STL library is only suitable for one-dimensional
structures. The iterators we use in |hpx| must adapt to the segmented format of
our containers. Our iterators are then able to know when incrementing themselves
if the next element of type ``T`` is in the same data segment or in another
segment. In this second case, the iterator will automatically point to the
beginning of the next segment.

.. note::

   Note that the dereference operation ``operator *`` does not directly return a
   reference of type ``T&`` but an intermediate object wrapping this reference.
   When this object is used as an l-value, a remote write operation is
   performed; When this object is used as an r-value, implicit conversion to
   ``T`` type will take care of performing remote read operation.

It is sometimes useful not only to iterate element by element, but also segment
by segment, or simply get a local iterator in order to avoid additional
construction costs at each deferencing operations. To mitigate this need, the
:cpp:class:`hpx::traits::segmented_iterator_traits` are used.

With ``segmented_iterator_traits`` users can uniformly get the iterators
which specifically iterates over segments (by providing a segmented iterator
as a parameter), or get the local begin/end iterators of the nearest
local segment (by providing a per-segment iterator as a parameter)::

    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    using iterator = hpx::partitioned_vector<T>::iterator;
    using traits   = hpx::traits::segmented_iterator_traits<iterator>;

    hpx::partitioned_vector<T> v;
    std::size_t count = 0;

    auto seg_begin = traits::segment(v.begin());
    auto seg_end   = traits::segment(v.end());

    // Iterate over segments
    for (auto seg_it = seg_begin; seg_it != seg_end; ++seg_it)
    {
        auto loc_begin = traits::begin(seg_it);
        auto loc_end   = traits::end(seg_it);

        // Iterate over elements inside segments
        for (auto lit = loc_begin; lit != loc_end; ++lit, ++count)
        {
            *lit = count;
        }
    }

Which is equivalent to::

    hpx::partitioned_vector<T> v;
    std::size_t count = 0;

    auto begin = v.begin();
    auto end   = v.end();

    for (auto it = begin; it != end; ++it, ++count)
    {
        *it = count;
    }

.. _partitioned_vector_views:

Using views
-----------

The use of multidimensional arrays is quite common in the numerical field
whether to perform dense matrix operations or to process images. It exist many
libraries which implement such object classes overloading their basic operators
(e.g.``+``, ``-``, ``*``, ``()``, etc.). However, such operation becomes more
delicate when the underlying data layout is segmented or when it is mandatory to
use optimized linear algebra subroutines (i.e. BLAS subroutines).

Our solution is thus to relax the level of abstraction by allowing the user to
work not directly on n-dimensionnal data, but on "n-dimensionnal collections of
1-D arrays". The use of well-accepted techniques on contiguous data is thus
preserved at the segment level, and the composability of the segments is made
possible thanks to multidimensional array-inspired access mode.

.. _spmd_block:

Preface: Why SPMD?
..................

Although |hpx| refutes by design this programming model, the :term:`locality`
plays a dominant role when it comes to implement vectorized code. To maximize
local computations and avoid unneeded data transfers, a parallel section (or
Single Programming Multiple Data section) is required. Because the use of global
variables is prohibited, this parallel section is created via the RAII idiom.

To define a parallel section, simply write an action taking a ``spmd_block``
variable as a first parameter::

    #include <hpx/collectives/spmd_block.hpp>

    void bulk_function(hpx::lcos::spmd_block block /* , arg0, arg1, ... */)
    {
        // Parallel section

        /* Do some code */
    }
    HPX_PLAIN_ACTION(bulk_function, bulk_action);

.. note::

   In the following paragraphs, we will use the term "image" several times. An
   image is defined as a lightweight process whose entry point is a function
   provided by the user. It's an "image of the function".

The ``spmd_block`` class contains the following methods:

* [def Team information] ``get_num_images``, ``this_image``, ``images_per_locality``
* [def Control statements] ``sync_all``, ``sync_images``

Here is a sample code summarizing the features offered by the ``spmd_block``
class::

    #include <hpx/collectives/spmd_block.hpp>

    void bulk_function(hpx::lcos::spmd_block block /* , arg0, arg1, ... */)
    {
        std::size_t num_images = block.get_num_images();
        std::size_t this_image = block.this_image();
        std::size_t images_per_locality = block.images_per_locality();

        /* Do some code */

        // Synchronize all images in the team
        block.sync_all();

        /* Do some code */

        // Synchronize image 0 and image 1
        block.sync_images(0,1);

        /* Do some code */

        std::vector<std::size_t> vec_images = {2,3,4};

        // Synchronize images 2, 3 and 4
        block.sync_images(vec_images);

        // Alternative call to synchronize images 2, 3 and 4
        block.sync_images(vec_images.begin(), vec_images.end());

        /* Do some code */

        // Non-blocking version of sync_all()
        hpx::future<void> event =
            block.sync_all(hpx::launch::async);

        // Callback waiting for 'event' to be ready before being scheduled
        hpx::future<void> cb =
            event.then(
              [](hpx::future<void>)
              {

                /* Do some code */

              });

        // Finally wait for the execution tree to be finished
        cb.get();
    }
    HPX_PLAIN_ACTION(bulk_test_function, bulk_test_action);

Then, in order to invoke the parallel section, call the function
``define_spmd_block`` specifying an arbitrary symbolic name and indicating the
number of images per :term:`locality` to create::

    void bulk_function(hpx::lcos::spmd_block block, /* , arg0, arg1, ... */)
    {

    }
    HPX_PLAIN_ACTION(bulk_test_function, bulk_test_action);

    int main()
    {
        /* std::size_t arg0, arg1, ...; */

        bulk_action act;
        std::size_t images_per_locality = 4;

        // Instantiate the parallel section
        hpx::lcos::define_spmd_block(
            "some_name", images_per_locality, std::move(act) /*, arg0, arg1, ... */);

        return 0;
    }

.. note::

   In principle, the user should never call the ``spmd_block`` constructor. The
   ``define_spmd_block`` function is responsible of instantiating ``spmd_block``
   objects and broadcasting them to each created image.

.. _spmd_views:

SPMD multidimensional views
...........................

Some classes are defined as "container views" when the purpose is to observe
and/or modify the values of a container using another perspective than the one
that characterizes the container. For example, the values of an ``std::vector``
object can be accessed via the expression ``[i]``. Container views can be used,
for example, when it is desired for those values to be "viewed" as a 2D matrix
that would have been flattened in a ``std::vector``. The values would be
possibly accessible via the expression ``vv(i,j)`` which would call internally
the expression ``v[k]``.

By default, the ``partitioned_vector`` class integrates 1-D views of its segments::

    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    using iterator = hpx::partitioned_vector<double>::iterator;
    using traits   = hpx::traits::segmented_iterator_traits<iterator>;

    hpx::partitioned_vector<double> v;

    // Create a 1-D view of the vector of segments
    auto vv = traits::segment(v.begin());

    // Access segment i
    std::vector<double> v = vv[i];

Our views are called "multidimensional" in the sense that they generalize to N
dimensions the purpose of ``segmented_iterator_traits::segment()`` in the 1-D
case. Note that in a parallel section, the 2-D expression ``a(i,j) = b(i,j)`` is
quite confusing because without convention, each of the images invoked will race
to execute the statement. For this reason, our views are not only
multidimensional but also "spmd-aware".

.. note::

   SPMD-awareness: The convention is simple. If an assignment statement contains
   a view subscript as an l-value, it is only and only the image holding the
   r-value who is evaluating the statement. (In MPI sense, it is called a Put
   operation).

.. _subscripts:

Subscript-based operations
,,,,,,,,,,,,,,,,,,,,,,,,,,

Here are some examples of using subscripts in the 2-D view case::

    #include <hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp>
    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(double);

    using Vec = hpx::partitioned_vector<double>;
    using View_2D = hpx::partitioned_vector_view<double,2>;

    /* Do some code */

    Vec v;

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        std::size_t height, width;

        // Instantiate the view
        View_2D vv(block, v.begin(), v.end(), {height,width});

        // The l-value is a view subscript, the image that owns vv(1,0)
        // evaluates the assignment.
        vv(0,1) = vv(1,0);

        // The l-value is a view subscript, the image that owns the r-value
        // (result of expression 'std::vector<double>(4,1.0)') evaluates the
        // assignment : oops! race between all participating images.
        vv(2,3) = std::vector<double>(4,1.0);
    }

.. _view_iterators:

Iterator-based operations
,,,,,,,,,,,,,,,,,,,,,,,,,

Here are some examples of using iterators in the 3-D view case::

    #include <hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp>
    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(int);

    using Vec = hpx::partitioned_vector<int>;
    using View_3D = hpx::partitioned_vector_view<int,3>;

    /* Do some code */

    Vec v1, v2;

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        std::size_t sixe_x, size_y, size_z;

        // Instantiate the views
        View_3D vv1(block, v1.begin(), v1.end(), {sixe_x,size_y,size_z});
        View_3D vv2(block, v2.begin(), v2.end(), {sixe_x,size_y,size_z});

        // Save previous segments covered by vv1 into segments covered by vv2
        auto vv2_it = vv2.begin();
        auto vv1_it = vv1.cbegin();

        for(; vv2_it != vv2.end(); vv2_it++, vv1_it++)
        {
            // It's a Put operation
            *vv2_it = *vv1_it;
        }

        // Ensure that all images have performed their Put operations
        block.sync_all();

        // Ensure that only one image is putting updated data into the different
        // segments covered by vv1
        if(block.this_image() == 0)
        {
            int idx = 0;

            // Update all the segments covered by vv1
            for(auto i = vv1.begin(); i != vv1.end(); i++)
            {
                // It's a Put operation
                *i = std::vector<float>(elt_size,idx++);
            }
        }
    }

Here is an example that shows how to iterate only over segments
owned by the current image::

    #include <hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp>
    #include <hpx/components/containers/partitioned_vector/partitioned_vector_local_view.hpp>
    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(float);

    using Vec = hpx::partitioned_vector<float>;
    using View_1D = hpx::partitioned_vector_view<float,1>;

    /* Do some code */

    Vec v;

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        std::size_t num_segments;

        // Instantiate the view
        View_1D vv(block, v.begin(), v.end(), {num_segments});

        // Instantiate the local view from the view
        auto local_vv = hpx::local_view(vv);

        for ( auto i = local_vv.begin(); i != local_vv.end(); i++ )
        {
            std::vector<float> & segment = *i;

            /* Do some code */
        }

    }

.. _sub_views:

Instantiating sub-views
,,,,,,,,,,,,,,,,,,,,,,,

It is possible to construct views from other views: we call it sub-views. The
constraint nevertheless for the subviews is to retain the dimension and the
value type of the input view. Here is an example showing how to create a
sub-view::

    #include <hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp>
    #include <hpx/include/partitioned_vector.hpp>

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'partitioned_vector' segments
    //
    HPX_REGISTER_PARTITIONED_VECTOR(float);

    using Vec = hpx::partitioned_vector<float>;
    using View_2D = hpx::partitioned_vector_view<float,2>;

    /* Do some code */

    Vec v;

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        std::size_t N = 20;
        std::size_t tilesize = 5;

        // Instantiate the view
        View_2D vv(block, v.begin(), v.end(), {N,N});

        // Instantiate the subview
        View_2D svv(
            block,&vv(tilesize,0),&vv(2*tilesize-1,tilesize-1),{tilesize,tilesize},{N,N});

        if(block.this_image() == 0)
        {
            // Equivalent to 'vv(tilesize,0) = 2.0f'
            svv(0,0) = 2.0f;

            // Equivalent to 'vv(2*tilesize-1,tilesize-1) = 3.0f'
            svv(tilesize-1,tilesize-1) = 3.0f;
        }

    }

.. note::

   The last parameter of the subview constructor is the size of the original
   view. If one would like to create a subview of the subview and so on, this
   parameter should stay unchanged. ``{N,N}`` for the above example).

C++ co-arrays
-------------

Fortran has extended its scalar element indexing approach to reference each
segment of a distributed array. In this extension, a segment is attributed a
?co-index? and lives in a specific :term:`locality`. A co-index provides the
application with enough information to retrieve the corresponding data
reference. In C++, containers present themselves as a ?smarter? alternative of
Fortran arrays but there are still no corresponding standardized features
similar to the Fortran co-indexing approach. We present here an implementation
of such features in |hpx|.

Preface: co-array, a segmented container tied to a SPMD multidimensional views
..............................................................................

As mentioned before, a co-array is a distributed array whose segments are
accessible through an array-inspired access mode. We have previously seen that
it is possible to reproduce such access mode using the concept of views.
Nevertheless, the user must pre-create a segmented container to instantiate this
view. We illustrate below how a single constructor call can perform those two
operations::

    #include <hpx/components/containers/coarray/coarray.hpp>
    #include <hpx/collectives/spmd_block.hpp>

    // The following code generates all necessary boiler plate to enable the
    // co-creation of 'coarray'
    //
    HPX_REGISTER_COARRAY(double);

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        using hpx::container::placeholders::_;

        std::size_t height=32, width=4, segment_size=10;

        hpx::coarray<double,3> a(block, "a", {height,width,_}, segment_size);

        /* Do some code */
    }

Unlike segmented containers, a co-array object can only be instantiated within a
parallel section. Here is the description of the parameters to provide to the
coarray constructor:

.. list-table:: Parameters of coarray constructor

   * * Parameter
     * Description
   * * ``block``
     * Reference to a ``spmd_block`` object
   * * ``"a"``
     * Symbolic name of type ``std::string``
   * * ``{height,width,_}``
     * Dimensions of the ``coarray`` object
   * * ``segment_size``
     * Size of a co-indexed element (i.e. size of the object referenced by the
       expression ``a(i,j,k)``)

Note that the "last dimension size" cannot be set by the user. It only accepts
the constexpr variable ``hpx::container::placeholders::_``. This size, which is
considered private, is equal to the number of current images (value returned by
``block.get_num_images()``).

.. note::

   An important constraint to remember about coarray objects is that all
   segments sharing the same "last dimension index" are located in the same
   image.

Using co-arrays
...............

The member functions owned by the ``coarray`` objects are exactly the same as
those of spmd multidimensional views. These are::

* Subscript-based operations
* Iterator-based operations

However, one additional functionality is provided. Knowing that the element
``a(i,j,k)`` is in the memory of the ``k``\ th image, the use of local subscripts
is possible.

.. note::

   For spmd multidimensional views, subscripts are only global as it still
   involves potential remote data transfers.

Here is an example of using local subscripts::

    #include <hpx/components/containers/coarray/coarray.hpp>
    #include <hpx/collectives/spmd_block.hpp>

    // The following code generates all necessary boiler plate to enable the
    // co-creation of 'coarray'
    //
    HPX_REGISTER_COARRAY(double);

    // Parallel section (suppose 'block' an spmd_block instance)
    {
        using hpx::container::placeholders::_;

        std::size_t height=32, width=4, segment_size=10;

        hpx::coarray<double,3> a(block, "a", {height,width,_}, segment_size);

        double idx = block.this_image()*height*width;

        for (std::size_t j = 0; j<width; j++)
        for (std::size_t i = 0; i<height; i++)
        {
            // Local write operation performed via the use of local subscript
            a(i,j,_) = std::vector<double>(elt_size,idx);
            idx++;
        }

        block.sync_all();
    }

.. note::

   When the "last dimension index" of a subscript is equal to
   ``hpx::container::placeholders::_``, local subscript (and not global
   subscript) is used. It is equivalent to a global subscript used with a "last
   dimension index" equal to the value returned by ``block.this_image()``.
..
    Copyright (C) 2020      ETH Zurich
    Copyright (C) 2013      Patricia Grubel
    Copyright (C) 2007-2014 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

===========================
|hpx| runtime and resources
===========================

.. _schedulers:

|hpx| thread scheduling policies
================================

The HPX runtime has five thread scheduling policies: local-priority,
static-priority, local, static and abp-priority. These policies can be specified
from the command line using the command line option :option:`--hpx:queuing`. In
order to use a particular scheduling policy, the runtime system must be built
with the appropriate scheduler flag turned on (e.g. ``cmake
-DHPX_THREAD_SCHEDULERS=local``, see :ref:`cmake_variables` for more
information).

Priority local scheduling policy (default policy)
-------------------------------------------------

* default or invoke using: :option:`--hpx:queuing`\ ``local-priority-fifo``

The priority local scheduling policy maintains one queue per operating system
(OS) thread. The OS thread pulls its work from this queue. By default the number
of high priority queues is equal to the number of OS threads; the number of high
priority queues can be specified on the command line using
:option:`--hpx:high-priority-threads`. High priority threads are executed by any
of the OS threads before any other work is executed. When a queue is empty work
will be taken from high priority queues first. There is one low priority queue
from which threads will be scheduled only when there is no other work.

For this scheduling policy there is an option to turn on NUMA sensitivity using
the command line option :option:`--hpx:numa-sensitive`. When NUMA sensitivity is
turned on work stealing is done from queues associated with the same NUMA domain
first, only after that work is stolen from other NUMA domains.

This scheduler is enabled at build time by default and will be available always.

This scheduler can be used with two underlying queuing policies (FIFO:
first-in-first-out, and LIFO: last-in-first-out). The default is FIFO. In order
to use the LIFO policy use the command line option :option:`--hpx:queuing`\
``=local-priority-lifo``.

Static priority scheduling policy
---------------------------------

* invoke using: :option:`--hpx:queuing`\ ``=static-priority`` (or ``-qs``)
* flag to turn on for build: ``HPX_THREAD_SCHEDULERS=all`` or
  ``HPX_THREAD_SCHEDULERS=static-priority``

The static scheduling policy maintains one queue per OS thread from which each
OS thread pulls its tasks (user threads). Threads are distributed in a round
robin fashion. There is no thread stealing in this policy.

Local scheduling policy
-----------------------

* invoke using: :option:`--hpx:queuing`\ ``=local`` (or ``-ql``)
* flag to turn on for build: ``HPX_THREAD_SCHEDULERS=all`` or
  ``HPX_THREAD_SCHEDULERS=local``

The local scheduling policy maintains one queue per OS thread from which each OS
thread pulls its tasks (user threads).

Static scheduling policy
------------------------

* invoke using: :option:`--hpx:queuing`\ ``=static``
* flag to turn on for build: ``HPX_THREAD_SCHEDULERS=all`` or
  ``HPX_THREAD_SCHEDULERS=static``

The static scheduling policy maintains one queue per OS thread from which each
OS thread pulls its tasks (user threads). Threads are distributed in a round
robin fashion. There is no thread stealing in this policy.

Priority ABP scheduling policy
------------------------------

* invoke using: :option:`--hpx:queuing`\ ``=abp-priority-fifo``
* flag to turn on for build: ``HPX_THREAD_SCHEDULERS=all`` or
  ``HPX_THREAD_SCHEDULERS=abp-priority``

Priority ABP policy maintains a double ended lock free queue for each OS thread.
By default the number of high priority queues is equal to the number of OS
threads; the number of high priority queues can be specified on the command line
using :option:`--hpx:high-priority-threads`. High priority threads are executed
by the first OS threads before any other work is executed. When a queue is empty
work will be taken from high priority queues first. There is one low priority
queue from which threads will be scheduled only when there is no other work. For
this scheduling policy there is an option to turn on NUMA sensitivity using the
command line option :option:`--hpx:numa-sensitive`. When NUMA sensitivity
is turned on work stealing is done from queues associated with the same NUMA
domain first, only after that work is stolen from other NUMA domains.

This scheduler can be used with two underlying queuing policies (FIFO:
first-in-first-out, and LIFO: last-in-first-out). In order to use the LIFO
policy use the command line option :option:`--hpx:queuing`\
``=abp-priority-lifo``.

..
    Questions, concerns and notes:

    Are all the work queues FIFO except perhaps the deque ABP?

    What is the low priority thread for priority policies?
    One of the comments says that there are exactly one queue per OS threads
    then an additional number of high-priority-threads queues plus an additional
    low priority queue.

    Is numa-sensitive only for local priority??? I know it says that in the
    documentation and error messages but seems to be available for abp
    priority and periodic priority

    There should be some way of verifying which policy is being used.

    --hpx-high-priority-threads option ********* it seems to me this option
    should be =< number of OS threads but command line accepts any number.
    Okay so I'm confused, in the documentation for command line options it
    states: the number of operating system threads maintaining a high priority
    queue (default: number of OS threads), valid for
    --hpx:queuing=local-priority only examples/spell_check/example_text.txt
    but in hpx_init.cpp the comment states: local scheduler with priority queue
    (one queue for each OS threads plus one separate queue for high priority
    HPX-threads)

    SCHEDULER
    initialization parameters:
    max count per queue (1000) this is for all policies
    number of queues  (OS threads) all except global
    number of high priority queues (selectable on command line  local priority,
    periodic and abp priority policies)
    minimum add thread count (10)  for periodic priority policy the number of
    threads will be incremented in steps of this count

    maximum number of active threads = 1000 is that per queue? I don't understand
    the comment:
    The maximum number of active threads this thread manager should

    // create. This number will be a constraint only as long as the work
    // items queue is not empty. Otherwise the number of active threads
    // will be incremented in steps equal to the \a min_add_new_count
    // specified above.
    enum { max_thread_count = 1000 };

    I see both FIFO and double ended queues in ABP policies?

The |hpx| resource partitioner
==============================

The |hpx| resource partitioner lets you take the execution resources available
on a system---processing units, cores, and numa domains---and assign them to
thread pools. By default |hpx| creates a single thread pool name ``default``.
While this is good for most use cases, the resource partitioner lets you create
multiple thread pools with custom resources and options.

Creating custom thread pools is useful for cases where you have tasks which
absolutely need to run without interference from other tasks. An example of this
is when using |mpi|_ for distribution instead of the built-in mechanisms in
|hpx| (useful in legacy applications). In this case one can create a thread pool
containing a single thread for |mpi|_ communication. |mpi|_ tasks will then
always run on the same thread, instead of potentially being stuck in a queue
behind other threads.

Note that |hpx| thread pools are completely independent from each other in the
sense that task stealing will never happen between different thread pools.
However, tasks running on a particular thread pool can schedule tasks on another
thread pool.

.. note::

   It is simpler in some situations to schedule important tasks with high
   priority instead of using a separate thread pool.

.. _using_resource_partitioner:

Using the resource partitioner
------------------------------

The :cpp:class:`hpx::resource::partitioner` is now created during |hpx| runtime
initialization without explicit action needed from the user. To specify some of
the initialization parameters you can use the :cpp:struct:`hpx::init_params`.

.. literalinclude:: ../../libs/full/resource_partitioner/examples/simplest_resource_partitioner_1.cpp
   :start-after: //[body
   :end-before: //body]

The resource partitioner callback is the interface to add thread pools to the
|hpx| runtime and to assign resources to the thread pools.  In order to create
custom thread pools you can specify the resource partitioner callback
:cpp:member:`hpx::init_params::rp_callback` which will be called once the
resource partitioner will be created , see the example below. You can also
specify other parameters, see :cpp:struct:`hpx::init_params`.

To add a thread pool use the
:cpp:member:`hpx::resource::partitioner::create_thread_pool` method. If you
simply want to use the default scheduler and scheduler options it is enough to
call ``rp.create_thread_pool("my-thread-pool")``.

Then, to add resources to the thread pool you can use the
:cpp:member:`hpx::resource::partitioner::add_resource` method. The resource
partitioner exposes the hardware topology retrieved using |hwloc|_ and lets you
iterate through the topology to add the wanted processing units to the thread
pool. Below is an example of adding all processing units from the first NUMA
domain to a custom thread pool, unless there is only one NUMA domain in which
case we leave the first processing unit for the default thread pool:

.. literalinclude:: ../../libs/full/resource_partitioner/examples/simplest_resource_partitioner_2.cpp
   :start-after: //[body
   :end-before: //body]

.. note::

   Whatever processing units not assigned to a thread pool by the time
   :cpp:func:`hpx::init` is called will be added to the default thread pool. It
   is also possible to explicitly add processing units to the default thread
   pool, and to create the default thread pool manually (in order to e.g. set
   the scheduler type).

.. tip::

   The command line option :option:`--hpx:print-bind` is useful for checking
   that the thread pools have been set up the way you expect.

Difference between the old and new version
------------------------------------------

In the old version, you had to create an instance of the
:cpp:class:`resource_partitioner` with ``argc`` and ``argv``.

.. code-block:: c++

    int main(int argc, char** argv)
    {
        hpx::resource::partitioner rp(argc, argv);
        hpx::init();
    }

From |hpx| 1.5.0 onwards, you just pass ``argc`` and ``argv`` to ``hpx::init()``
or ``hpx::start()`` for the binding options to be parsed by the resource
partitioner.

.. code-block:: c++

    int main(int argc, char** argv)
    {
        hpx::init_params init_args;
        hpx::init(argc, argv, init_args);
    }

In the old version, when creating a custom thread pool, you just called the
utilities on the resource partitioner instantiated previously.

.. code-block:: c++

    int main(int argc, char** argv)
    {
        hpx::resource::partitioner rp(argc, argv);

        rp.create_thread_pool("my-thread-pool");

        bool one_numa_domain = rp.numa_domains().size() == 1;
        bool skipped_first_pu = false;

        hpx::resource::numa_domain const& d = rp.numa_domains()[0];

        for (const hpx::resource::core& c : d.cores())
        {
            for (const hpx::resource::pu& p : c.pus())
            {
                if (one_numa_domain && !skipped_first_pu)
                {
                    skipped_first_pu = true;
                    continue;
                }

                rp.add_resource(p, "my-thread-pool");
            }
        }

        hpx::init();
    }

You now specify the resource partitioner callback which will tie the resources
to the resource partitioner created during runtime initialization.

.. code-block:: c++

    void init_resource_partitioner_handler(hpx::resource::partitioner& rp)
    {
        rp.create_thread_pool("my-thread-pool");

        bool one_numa_domain = rp.numa_domains().size() == 1;
        bool skipped_first_pu = false;

        hpx::resource::numa_domain const& d = rp.numa_domains()[0];

        for (const hpx::resource::core& c : d.cores())
        {
            for (const hpx::resource::pu& p : c.pus())
            {
                if (one_numa_domain && !skipped_first_pu)
                {
                    skipped_first_pu = true;
                    continue;
                }

                rp.add_resource(p, "my-thread-pool");
            }
        }
    }

    int main(int argc, char* argv[])
    {
        hpx::init_params init_args;
        init_args.rp_callback = &init_resource_partitioner_handler;

        hpx::init(argc, argv, init_args);
    }

Advanced usage
--------------

It is possible to customize the built in schedulers by passing scheduler options
to :cpp:member:`hpx::resource::partitioner::create_thread_pool`. It is also possible
to create and use custom schedulers.

.. note::

   It is not recommended to create your own scheduler. The |hpx| developers use
   this to experiment with new scheduler designs before making them available to
   users via the standard mechanisms of choosing a scheduler (command line
   options). If you would like to experiment with a custom scheduler the
   resource partitioner example ``shared_priority_queue_scheduler.cpp`` contains
   a fully implemented scheduler with logging etc. to make exploration easier.

To choose a scheduler and custom mode for a thread pool, pass additional options
when creating the thread pool like this::

    rp.create_thread_pool("my-thread-pool",
        hpx::resource::policies::local_priority_lifo,
        hpx::policies::scheduler_mode(
            hpx::policies::scheduler_mode::default |
            hpx::policies::scheduler_mode::enable_elasticity));

The available schedulers are documented here:
:cpp:enum:`hpx::resource::scheduling_policy`, and the available scheduler modes
here: :cpp:enum:`hpx::threads::policies::scheduler_mode`. Also see the examples
folder for examples of advanced resource partitioner usage:
``simple_resource_partitioner.cpp`` and
``oversubscribing_resource_partitioner.cpp``.
..
    Copyright (C) 2012 Bryce Adelstein-Lelbach
    Copyright (C) 2007-2016 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _writing_single_node_hpx_applications:

======================================
Writing single-node |hpx| applications
======================================

|hpx| is a C++ Standard Library for Concurrency and Parallelism. This means that
it implements all of the corresponding facilities as defined by the C++
Standard. Additionally, |hpx| implements functionalities proposed as part
of the ongoing C++ standardization process. This section focuses on the features
available in |hpx| for parallel and concurrent computation on a single node,
although many of the features presented here are also implemented to work in the
distributed case.

.. _lcos:

Using :term:`LCO`\ s
====================

:term:`Lightweight Control Object`\ s (LCOs) provide synchronization for |hpx| applications. Most
of them are familiar from other frameworks, but a few of them work in slightly
different ways adapted to |hpx|. The following synchronization objects are available in |hpx|:

#. ``future``

#. ``queue``

#. ``object_semaphore``

#. ``barrier``

Channels
--------

Channels combine communication (the exchange of a value) with synchronization
(guaranteeing that two calculations (tasks) are in a known state). A channel can
transport any number of values of a given type from a sender to a receiver:

.. literalinclude:: ../../examples/quickstart/local_channel_docs.cpp
   :language: c++
   :start-after: //[local_channel_minimal
   :end-before: //]

Channels can be handed to another thread (or in case of channel components, to
other localities), thus establishing a communication channel between two
independent places in the program:

.. literalinclude:: ../../examples/quickstart/local_channel_docs.cpp
   :language: c++
   :start-after: //[local_channel_send_receive
   :end-before: //]

Note how :cpp:member:`hpx::lcos::local::channel::get` without any arguments
returns a future which is ready when a value has been set on the channel. The
launch policy ``hpx::launch::sync`` can be used to make
:cpp:member:`hpx::lcos::local::channel::get` block until a value is set and
return the value directly.

A channel component is created on one :term:`locality` and can be sent to
another :term:`locality` using an action. This example also demonstrates how a
channel can be used as a range of values:

.. literalinclude:: ../../examples/quickstart/channel_docs.cpp
   :language: c++
   :start-after: //[channel
   :end-before: //]

Composable guards
-----------------

Composable guards operate in a manner similar to locks, but are applied only to
asynchronous functions. The guard (or guards) is automatically locked at the
beginning of a specified task and automatically unlocked at the end. Because
guards are never added to an existing task's execution context, the calling of
guards is freely composable and can never deadlock.

To call an application with a single guard, simply declare the guard and call
run_guarded() with a function (task)::

     hpx::lcos::local::guard gu;
     run_guarded(gu,task);

If a single method needs to run with multiple guards, use a guard set::

     boost::shared<hpx::lcos::local::guard> gu1(new hpx::lcos::local::guard());
     boost::shared<hpx::lcos::local::guard> gu2(new hpx::lcos::local::guard());
     gs.add(*gu1);
     gs.add(*gu2);
     run_guarded(gs,task);

Guards use two atomic operations (which are not called repeatedly) to manage
what they do, so overhead should be extremely low. The following guards are available in |hpx|:

#. ``conditional_trigger``

#. ``counting_semaphore``

#. ``dataflow``

#. ``event``

#. ``mutex``

#. ``once``

#. ``recursive_mutex``

#. ``spinlock``

#. ``spinlock_no_backoff``

#. ``trigger``

.. _extend_futures:

Extended facilities for futures
===============================

Concurrency is about both decomposing and composing the program from the parts
that work well individually and together. It is in the composition of connected
and multicore components where today's C++ libraries are still lacking.

The functionality of ``std::future`` offers a partial solution. It allows for
the separation of the initiation of an operation and the act of waiting for its
result; however, the act of waiting is synchronous. In communication-intensive
code this act of waiting can be unpredictable, inefficient and simply
frustrating. The example below illustrates a possible synchronous wait using
futures::

    #include <future>
    using namespace std;
    int main()
    {
        future<int> f = async([]() { return 123; });
        int result = f.get(); // might block
    }

For this reason, |hpx| implements a set of extensions to ``std::future`` (as
proposed by __cpp11_n4107__). This proposal introduces the following key
asynchronous operations to ``hpx::future``, ``hpx::shared_future`` and
``hpx::async``, which enhance and enrich these facilities.

.. list-table:: Facilities extending ``std::future``

   * * Facility
     * Description
   * * ``hpx::future::then``
     * In asynchronous programming, it is very common for one asynchronous
       operation, on completion, to invoke a second operation and pass data to
       it. The current C++ standard does not allow one to register a
       continuation to a future. With ``then``, instead of waiting for the result,
       a continuation is "attached" to the asynchronous operation, which is
       invoked when the result is ready. Continuations registered using then
       function will help to avoid blocking waits or wasting threads on polling,
       greatly improving the responsiveness and scalability of an application.
   * * unwrapping constructor for ``hpx::future``
     * In some scenarios, you might want to create a future that returns another
       future, resulting in nested futures. Although it is possible to write
       code to unwrap the outer future and retrieve the nested future and its
       result, such code is not easy to write because users must handle exceptions
       and it may cause a blocking call. Unwrapping can allow users to mitigate
       this problem by doing an asynchronous call to unwrap the outermost
       future.
   * * ``hpx::future::is_ready``
     * There are often situations where a ``get()`` call on a future may not be
       a blocking call, or is only a blocking call under certain circumstances.
       This function gives the ability to test for early completion and allows
       us to avoid associating a continuation, which needs to be scheduled with
       some non-trivial overhead and near-certain loss of cache efficiency.
   * * ``hpx::make_ready_future``
     * Some functions may know the value at the point of construction. In these
       cases the value is immediately available, but needs to be returned as a
       future. By using ``hpx::make_ready_future`` a future can be created that
       holds a pre-computed result in its shared state. In the current standard
       it is non-trivial to create a future directly from a value. First a
       promise must be created, then the promise is set, and lastly the future
       is retrieved from the promise. This can now be done with one operation.

The standard also omits the ability to compose multiple futures. This is a
common pattern that is ubiquitous in other asynchronous frameworks and is
absolutely necessary in order to make C++ a powerful asynchronous programming
language. Not including these functions is synonymous to Boolean algebra without
AND/OR.

In addition to the extensions proposed by |cpp11_n4107|_, |hpx| adds functions
allowing users to compose several futures in a more flexible way.

.. list-table:: Facilities for composing ``hpx::future``\ s

   * * Facility
     * Description
     * Comment
   * * :cpp:func:`hpx::when_any`, :cpp:func:`hpx::when_any_n`
     * Asynchronously wait for at least one of multiple future or shared_future
       objects to finish.
     * |cpp11_n4107|_, ``..._n`` versions are |hpx| only
   * * :cpp:func:`hpx::wait_any`, :cpp:func:`hpx::wait_any_n`
     * Synchronously wait for at least one of multiple future or shared_future
       objects to finish.
     * |hpx| only
   * * :cpp:func:`hpx::when_all`, :cpp:func:`hpx::when_all_n`
     * Asynchronously wait for all future and shared_future objects to finish.
     * |cpp11_n4107|_, ``..._n`` versions are |hpx| only
   * * :cpp:func:`hpx::wait_all`, :cpp:func:`hpx::wait_all_n`
     * Synchronously wait for all future and shared_future objects to finish.
     * |hpx| only
   * * :cpp:func:`hpx::when_some`, :cpp:func:`hpx::when_some_n`
     * Asynchronously wait for multiple future and shared_future objects to
       finish.
     * |hpx| only
   * * :cpp:func:`hpx::wait_some`, :cpp:func:`hpx::wait_some_n`
     * Synchronously wait for multiple future and shared_future objects to
       finish.
     * |hpx| only
   * * :cpp:func:`hpx::when_each`
     * Asynchronously wait for multiple future and shared_future objects to
       finish and call a function for each of the future objects as soon as it
       becomes ready.
     * |hpx| only
   * * :cpp:func:`hpx::wait_each`, :cpp:func:`hpx::wait_each_n`
     * Synchronously wait for multiple future and shared_future objects to
       finish and call a function for each of the future objects as soon as it
       becomes ready.
     * |hpx| only

.. _parallel:

High level parallel facilities
==============================

In preparation for the upcoming C++ Standards, there are currently several proposals
targeting different facilities supporting parallel programming. |hpx| implements
(and extends) some of those proposals. This is well aligned with our strategy to
align the APIs exposed from |hpx| with current and future C++ Standards.

At this point, |hpx| implements several of the C++ Standardization working
papers, most notably |cpp11_n4104|_ (Working Draft, Technical Specification for
C++ Extensions for Parallelism), |cpp11_n4088|_ (Task Blocks), and
|cpp11_n4406|_ (Parallel Algorithms Need Executors).

.. _parallel_algorithms:

Using parallel algorithms
-------------------------

.. |sequenced_execution_policy| replace:: :cpp:class:`hpx::execution::sequenced_policy`
.. |sequenced_task_execution_policy| replace:: :cpp:class:`hpx::execution::sequenced_task_policy`
.. |parallel_execution_policy| replace:: :cpp:class:`hpx::execution::parallel_policy`
.. |parallel_unsequenced_execution_policy| replace:: :cpp:class:`hpx::execution::parallel_unsequenced_policy`
.. |parallel_task_execution_policy| replace:: :cpp:class:`hpx::execution::parallel_task_policy`
.. |execution_policy| replace:: :cpp:class:`hpx::parallel::v1::execution_policy`
.. |exception_list| replace:: :cpp:class:`hpx::exception_list`
.. |par_for_each| replace:: :cpp:class:`hpx::parallel::v1::for_each`

A parallel algorithm is a function template described by this document
which is declared in the (inline) namespace ``hpx::parallel::v1``.

.. note::

   For compilers that do not support inline namespaces, all of the ``namespace
   v1`` is imported into the namespace ``hpx::parallel``. The effect is similar
   to what inline namespaces would do, namely all names defined in
   ``hpx::parallel::v1`` are accessible from the namespace ``hpx::parallel`` as
   well.

All parallel algorithms are very similar in semantics to their sequential
counterparts (as defined in the ``namespace std``) with an additional formal
template parameter named ``ExecutionPolicy``. The execution policy is generally
passed as the first argument to any of the parallel algorithms and describes the
manner in which the execution of these algorithms may be parallelized and the
manner in which they apply user-provided function objects.

The applications of function objects in parallel algorithms invoked with an
execution policy object of type |sequenced_execution_policy| or
|sequenced_task_execution_policy| execute in sequential order. For
|sequenced_execution_policy| the execution happens in the calling thread.

The applications of function objects in parallel algorithms invoked with an
execution policy object of type |parallel_execution_policy| or
|parallel_task_execution_policy| are permitted to execute in an unordered
fashion in unspecified threads, and are indeterminately sequenced within each
thread.

.. important::

   It is the caller's responsibility to ensure correctness, such as making sure that the
   invocation does not introduce data races or deadlocks.

The applications of function objects in parallel algorithms invoked with an
execution policy of type |parallel_unsequenced_execution_policy| is, in |hpx|,
equivalent to the use of the execution policy |parallel_execution_policy|.

Algorithms invoked with an execution policy object of type |execution_policy|
execute internally as if invoked with the contained execution policy object. No
exception is thrown when an |execution_policy| contains an execution policy of
type |sequenced_task_execution_policy| or |parallel_task_execution_policy|
(which normally turn the algorithm into its asynchronous version). In this case
the execution is semantically equivalent to the case of passing a
|sequenced_execution_policy| or |parallel_execution_policy| contained in the
|execution_policy| object respectively.

Parallel exceptions
-------------------

During the execution of a standard parallel algorithm, if temporary memory
resources are required by any of the algorithms and no memory is available, the
algorithm throws a ``std::bad_alloc`` exception.

During the execution of any of the parallel algorithms, if the application of a
function object terminates with an uncaught exception, the behavior of the
program is determined by the type of execution policy used to invoke the
algorithm:

* If the execution policy object is of type
  |parallel_unsequenced_execution_policy|, :cpp:func:`hpx::terminate` shall
  be called.
* If the execution policy object is of type |sequenced_execution_policy|,
  |sequenced_task_execution_policy|, |parallel_execution_policy|, or
  |parallel_task_execution_policy|, the execution of the algorithm terminates
  with an |exception_list| exception. All uncaught exceptions thrown during the
  application of user-provided function objects shall be contained in the
  |exception_list|.

For example, the number of invocations of the user-provided function object in
for_each is unspecified. When |par_for_each| is executed sequentially, only one
exception will be contained in the |exception_list| object.

These guarantees imply that, unless the algorithm has failed to allocate memory
and terminated with ``std::bad_alloc``, all exceptions thrown during the
execution of the algorithm are communicated to the caller. It is unspecified
whether an algorithm implementation will "forge ahead" after encountering and
capturing a user exception.

The algorithm may terminate with the ``std::bad_alloc`` exception even if one or
more user-provided function objects have terminated with an exception. For
example, this can happen when an algorithm fails to allocate memory while
creating or adding elements to the |exception_list| object.

Parallel algorithms
-------------------

|hpx| provides implementations of the following parallel algorithms:

.. list-table:: Non-modifying parallel algorithms (in header: ``<hpx/algorithm.hpp>``)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::adjacent_find`
     * Computes the differences between adjacent elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`adjacent_find`
   * * :cpp:func:`hpx::all_of`
     * Checks if a predicate is ``true`` for all of the elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`all_any_none_of`
   * * :cpp:func:`hpx::any_of`
     * Checks if a predicate is ``true`` for any of the elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`all_any_none_of`
   * * :cpp:func:`hpx::count`
     * Returns the number of elements equal to a given value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`count`
   * * :cpp:func:`hpx::count_if`
     * Returns the number of elements satisfying a specific criteria.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`count_if`
   * * :cpp:func:`hpx::equal`
     * Determines if two sets of elements are the same.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`equal`
   * * :cpp:func:`hpx::find`
     * Finds the first element equal to a given value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`find`
   * * :cpp:func:`hpx::find_end`
     * Finds the last sequence of elements in a certain range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`find_end`
   * * :cpp:func:`hpx::find_first_of`
     * Searches for any one of a set of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`find_first_of`
   * * :cpp:func:`hpx::find_if`
     * Finds the first element satisfying a specific criteria.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`find_if`
   * * :cpp:func:`hpx::find_if_not`
     * Finds the first element not satisfying a specific criteria.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`find_if_not`
   * * :cpp:func:`hpx::for_each`
     * Applies a function to a range of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`for_each`
   * * :cpp:func:`hpx::for_each_n`
     * Applies a function to a number of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`for_each_n`
   * * :cpp:func:`hpx::lexicographical_compare`
     * Checks if a range of values is lexicographically less than another range of values.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`lexicographical_compare`
   * * :cpp:func:`hpx::parallel::v1::mismatch`
     * Finds the first position where two ranges differ.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`mismatch`
   * * :cpp:func:`hpx::none_of`
     * Checks if a predicate is ``true`` for none of the elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`all_any_none_of`
   * * :cpp:func:`hpx::search`
     * Searches for a range of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`search`
   * * :cpp:func:`hpx::search_n`
     * Searches for a number consecutive copies of an element in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`search_n`

.. list-table:: Modifying parallel algorithms (In Header: `<hpx/algorithm.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::copy`
     * Copies a range of elements to a new location.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`exclusive_scan`
   * * :cpp:func:`hpx::copy_n`
     * Copies a number of elements to a new location.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`copy_n`
   * * :cpp:func:`hpx::copy_if`
     * Copies the elements from a range to a new location for which the given predicate is ``true``
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`copy`
   * * :cpp:func:`hpx::move`
     * Moves a range of elements to a new location.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`move`
   * * :cpp:func:`hpx::fill`
     * Assigns a range of elements a certain value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`fill`
   * * :cpp:func:`hpx::fill_n`
     * Assigns a value to a number of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`fill_n`
   * * :cpp:func:`hpx::generate`
     * Saves the result of a function in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`generate`
   * * :cpp:func:`hpx::generate_n`
     * Saves the result of N applications of a function.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`generate_n`
   * * :cpp:func:`hpx::remove`
     * Removes the elements from a range that are equal to the given value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`remove`
   * * :cpp:func:`hpx::remove_if`
     * Removes the elements from a range that are equal to the given predicate is ``false``
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`remove`
   * * :cpp:func:`hpx::remove_copy`
     * Copies the elements from a range to a new location that are not equal to the given value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`remove_copy`
   * * :cpp:func:`hpx::remove_copy_if`
     * Copies the elements from a range to a new location for which the given predicate is ``false``
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`remove_copy`
   * * :cpp:func:`hpx::replace`
     * Replaces all values satisfying specific criteria with another value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`replace`
   * * :cpp:func:`hpx::replace_if`
     * Replaces all values satisfying specific criteria with another value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`replace`
   * * :cpp:func:`hpx::replace_copy`
     * Copies a range, replacing elements satisfying specific criteria with another value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`replace_copy`
   * * :cpp:func:`hpx::replace_copy_if`
     * Copies a range, replacing elements satisfying specific criteria with another value.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`replace_copy`
   * * :cpp:func:`hpx::reverse`
     * Reverses the order elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`reverse`
   * * :cpp:func:`hpx::reverse_copy`
     * Creates a copy of a range that is reversed.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`reverse_copy`
   * * :cpp:func:`hpx::parallel::v1::rotate`
     * Rotates the order of elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`rotate`
   * * :cpp:func:`hpx::parallel::v1::rotate_copy`
     * Copies and rotates a range of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`rotate_copy`
   * * :cpp:func:`hpx::shift_left`
     * Shifts the elements in the range left by n positions.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`shift_left`
   * * :cpp:func:`hpx::shift_right`
     * Shifts the elements in the range right by n positions.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`shift_right`
   * * :cpp:func:`hpx::swap_ranges`
     * Swaps two ranges of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`swap_ranges`
   * * :cpp:func:`hpx::transform`
     * Applies a function to a range of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`transform`
   * * :cpp:func:`hpx::unique`
     * Eliminates all but the first element from every consecutive group of equivalent elements from a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`unique`
   * * :cpp:func:`hpx::unique_copy`
     * Copies the elements from one range to another in such a way that there are no consecutive equal elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`unique_copy`

.. list-table:: Set operations on sorted sequences (In Header: `<hpx/algorithm.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::merge`
     * Merges two sorted ranges.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`merge`
   * * :cpp:func:`hpx::inplace_merge`
     * Merges two ordered ranges in-place.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`inplace_merge`
   * * :cpp:func:`hpx::includes`
     * Returns true if one set is a subset of another.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`includes`
   * * :cpp:func:`hpx::set_difference`
     * Computes the difference between two sets.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`set_difference`
   * * :cpp:func:`hpx::set_intersection`
     * Computes the intersection of two sets.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`set_intersection`
   * * :cpp:func:`hpx::set_symmetric_difference`
     * Computes the symmetric difference between two sets.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`set_symmetric_difference`
   * * :cpp:func:`hpx::set_union`
     * Computes the union of two sets.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`set_union`

.. list-table:: Heap operations (In Header: <hpx/algorithm.hpp>)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::is_heap`
     * Returns ``true`` if the range is max heap.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`is_heap`
   * * :cpp:func:`hpx::is_heap_until`
     * Returns the first element that breaks a max heap.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`is_heap_until`
   * * :cpp:func:`hpx::make_heap`
     * Constructs a max heap in the range [first, last).
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`make_heap`

.. list-table:: Minimum/maximum operations (In Header: <hpx/algorithm.hpp>)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::max_element`
     * Returns the largest element in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`max_element`
   * * :cpp:func:`hpx::min_element`
     * Returns the smallest element in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`min_element`
   * * :cpp:func:`hpx::minmax_element`
     * Returns the smallest and the largest element in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`minmax_element`

.. list-table:: Partitioning Operations (In Header: `<hpx/algorithm.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::nth_element`
       * Partially sorts the given range making sure that it is partitioned by the given element
       * ``<hpx/algorithm.hpp>``
       * :cppreference-algorithm:`nth_element`
   * * :cpp:func:`hpx::is_partitioned`
     * Returns ``true`` if each true element for a predicate precedes the false elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`is_partitioned`
   * * :cpp:func:`hpx::parallel::v1::partition`
     * Divides elements into two groups without preserving their relative order.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`partition`
   * * :cpp:func:`hpx::partition_copy`
     * Copies a range dividing the elements into two groups.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`partition_copy`
   * * :cpp:func:`hpx::stable_partition`
     * Divides elements into two groups while preserving their relative order.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`stable_partition`

.. list-table:: Sorting Operations (In Header: `<hpx/algorithm.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::is_sorted`
     * Returns ``true`` if each element in a range is sorted.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`is_sorted`
   * * :cpp:func:`hpx::is_sorted_until`
     * Returns the first unsorted element.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`is_sorted_until`
   * * :cpp:func:`hpx::sort`
     * Sorts the elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`sort`
   * * :cpp:func:`hpx::stable_sort`
     * Sorts the elements in a range, maintain sequence of equal elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`stable_sort`
   * * :cpp:func:`hpx::partial_sort`
     * Sorts the first elements in a range.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`partial_sort`
   * * :cpp:func:`hpx::partial_sort_copy`
       * Sorts the first elements in a range, storing the result in another range.
       * ``<hpx/algorithm.hpp>``
       * :cppreference-algorithm:`partial_sort_copy`
   * * :cpp:func:`hpx::parallel::v1::sort_by_key`
     * Sorts one range of data using keys supplied in another range.
     * ``<hpx/algorithm.hpp>``
     *


.. list-table:: Numeric Parallel Algorithms (In Header: `<hpx/numeric.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::adjacent_difference`
     * Calculates the difference between each element in an input range and the preceding element.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`adjacent_difference`
   * * :cpp:func:`hpx::exclusive_scan`
     * Does an exclusive parallel scan over a range of elements.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`exclusive_scan`
   * * :cpp:func:`hpx::reduce`
     * Sums up a range of elements.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`reduce`
   * * :cpp:func:`hpx::inclusive_scan`
     * Does an inclusive parallel scan over a range of elements.
     * ``<hpx/algorithm.hpp>``
     * :cppreference-algorithm:`inclusive_scan`
   * * :cpp:func:`hpx::parallel::v1::reduce_by_key`
     * Performs an inclusive scan on consecutive elements with matching keys,
       with a reduction to output only the final sum for each key. The key
       sequence ``{1,1,1,2,3,3,3,3,1}`` and value sequence
       ``{2,3,4,5,6,7,8,9,10}`` would be reduced to ``keys={1,2,3,1}``,
       ``values={9,5,30,10}``.
     * ``<hpx/numeric.hpp>``
     *
   * * :cpp:func:`hpx::transform_reduce`
     * Sums up a range of elements after applying a function. Also, accumulates the inner products of two input ranges.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`transform_reduce`
   * * :cpp:func:`hpx::transform_inclusive_scan`
     * Does an inclusive parallel scan over a range of elements after applying a function.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`transform_inclusive_scan`
   * * :cpp:func:`hpx::parallel::v1::transform_exclusive_scan`
     * Does an exclusive parallel scan over a range of elements after applying a function.
     * ``<hpx/numeric.hpp>``
     * :cppreference-algorithm:`transform_exclusive_scan`

.. list-table:: Dynamic Memory Management (In Header: `<hpx/memory.hpp>`)

   * * Name
     * Description
     * In header
     * Algorithm page at cppreference.com
   * * :cpp:func:`hpx::destroy`
     * Destroys a range of objects.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`destroy`
   * * :cpp:func:`hpx::destroy_n`
     * Destroys a range of objects.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`destroy_n`
   * * :cpp:func:`hpx::uninitialized_copy`
     * Copies a range of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_copy`
   * * :cpp:func:`hpx::uninitialized_copy_n`
     * Copies a number of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_copy_n`
   * * :cpp:func:`hpx::uninitialized_default_construct`
     * Copies a range of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_default_construct`
   * * :cpp:func:`hpx::uninitialized_default_construct_n`
     * Copies a number of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_default_construct_n`
   * * :cpp:func:`hpx::uninitialized_fill`
     * Copies an object to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_fill`
   * * :cpp:func:`hpx::uninitialized_fill_n`
     * Copies an object to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_fill_n`
   * * :cpp:func:`hpx::uninitialized_move`
     * Moves a range of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_move`
   * * :cpp:func:`hpx::uninitialized_move_n`
     * Moves a number of objects to an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_move_n`
   * * :cpp:func:`hpx::uninitialized_value_construct`
     * Constructs objects in an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_value_construct`
   * * :cpp:func:`hpx::uninitialized_value_construct_n`
     * Constructs objects in an uninitialized area of memory.
     * ``<hpx/memory.hpp>``
     * :cppreference-memory:`uninitialized_value_construct_n`

.. list-table:: Index-based for-loops (In Header: `<hpx/algorithm.hpp>`)

   * * Name
     * Description
     * In header
   * * :cpp:func:`hpx::for_loop`
     * Implements loop functionality over a range specified by integral or iterator bounds.
     * ``<hpx/algorithm.hpp>``
   * * :cpp:func:`hpx::for_loop_strided`
     * Implements loop functionality over a range specified by integral or iterator bounds.
     * ``<hpx/algorithm.hpp>``
   * * :cpp:func:`hpx::for_loop_n`
     * Implements loop functionality over a range specified by integral or iterator bounds.
     * ``<hpx/algorithm.hpp>``
   * * :cpp:func:`hpx::for_loop_n_strided`
     * Implements loop functionality over a range specified by integral or iterator bounds.
     * ``<hpx/algorithm.hpp>``

.. _executor_parameters:

Executor parameters and executor parameter traits
-------------------------------------------------

|hpx| introduces the notion of execution parameters and execution parameter
traits. At this point, the only parameter that can be customized is the size of
the chunks of work executed on a single |hpx| thread (such as the number of loop
iterations combined to run as a single task).

An executor parameter object is responsible for exposing the calculation of the
size of the chunks scheduled. It abstracts the (potentially platform-specific)
algorithms of determining those chunk sizes.

The way executor parameters are implemented is aligned with the way executors
are implemented. All functionalities of concrete executor parameter types are
exposed and accessible through a corresponding
:cpp:class:`hpx::parallel::executor_parameter_traits` type.

With ``executor_parameter_traits``, clients access all types of executor
parameters uniformly::

    std::size_t chunk_size =
        executor_parameter_traits<my_parameter_t>::get_chunk_size(my_parameter,
            my_executor, [](){ return 0; }, num_tasks);

This call synchronously retrieves the size of a single chunk of loop iterations
(or similar) to combine for execution on a single |hpx| thread if the overall
number of tasks to schedule is given by ``num_tasks``. The lambda function
exposes a means of test-probing the execution of a single iteration for
performance measurement purposes. The execution parameter type might dynamically
determine the execution time of one or more tasks in order to calculate the
chunk size; see :cpp:class:`hpx::execution::auto_chunk_size` for an example of
this executor parameter type.

Other functions in the interface exist to discover whether an executor parameter
type should be invoked once (i.e., it returns a static chunk size; see
:cpp:class:`hpx::execution::static_chunk_size`) or whether it should be invoked
for each scheduled chunk of work (i.e., it returns a variable chunk size; for an
example, see :cpp:class:`hpx::execution::guided_chunk_size`).

Although this interface appears to require executor parameter type authors to
implement all different basic operations, none are required. In
practice, all operations have sensible defaults. However, some executor
parameter types will naturally specialize all operations for maximum efficiency.

|hpx|  implements the following executor parameter types:

* :cpp:class:`hpx::execution::auto_chunk_size`: Loop iterations are divided into
  pieces and then assigned to threads. The number of loop iterations combined is
  determined based on measurements of how long the execution of 1% of the
  overall number of iterations takes. This executor parameter type makes sure
  that as many loop iterations are combined as necessary to run for the amount
  of time specified.
* :cpp:class:`hpx::execution::static_chunk_size`: Loop iterations are divided
  into pieces of a given size and then assigned to threads. If the size is not
  specified, the iterations are, if possible, evenly divided contiguously among
  the threads. This executor parameters type is equivalent to OpenMP's STATIC
  scheduling directive.
* :cpp:class:`hpx::execution::dynamic_chunk_size`: Loop iterations are divided
  into pieces of a given size and then dynamically scheduled among the cores;
  when a core finishes one chunk, it is dynamically assigned another. If the
  size is not specified, the default chunk size is 1. This executor parameter
  type is equivalent to OpenMP's DYNAMIC scheduling directive.
* :cpp:class:`hpx::execution::guided_chunk_size`: Iterations are dynamically
  assigned to cores in blocks as cores request them until no blocks remain to be
  assigned. This is similar to ``dynamic_chunk_size`` except that the block size
  decreases each time a number of loop iterations is given to a thread. The size
  of the initial block is proportional to ``number_of_iterations /
  number_of_cores``. Subsequent blocks are proportional to
  ``number_of_iterations_remaining / number_of_cores``. The optional chunk size
  parameter defines the minimum block size. The default minimal chunk size is 1.
  This executor parameter type is equivalent to OpenMP's GUIDED scheduling
  directive.

.. _using_task_block:

Using task blocks
=================

The ``define_task_block``, ``run`` and the ``wait`` functions implemented based
on |cpp11_n4088|_ are based on the ``task_block`` concept that is a part of the
common subset of the |ppl|_ and the |tbb|_ libraries.

These implementations adopt a simpler syntax than exposed by those libraries---
one that is influenced by language-based concepts, such as spawn and sync from
|cilk_pp|_ and async and finish from |x10|_. They improve on existing practice in
the following ways:

* The exception handling model is simplified and more consistent with normal C++
  exceptions.
* Most violations of strict fork-join parallelism can be enforced at compile
  time (with compiler assistance, in some cases).
* The syntax allows scheduling approaches other than child stealing.

Consider an example of a parallel traversal of a tree, where a user-provided
function compute is applied to each node of the tree, returning the sum of the
results::

    template <typename Func>
    int traverse(node& n, Func && compute)
    {
        int left = 0, right = 0;
        define_task_block(
            [&](task_block<>& tr) {
                if (n.left)
                    tr.run([&] { left = traverse(*n.left, compute); });
                if (n.right)
                    tr.run([&] { right = traverse(*n.right, compute); });
            });

        return compute(n) + left + right;
    }

The example above demonstrates the use of two of the functions,
:cpp:func:`hpx::parallel::define_task_block` and the
:cpp:member:`hpx::parallel::task_block::run` member function of a
:cpp:class:`hpx::parallel::task_block`.

The ``task_block`` function delineates a region in a program code potentially
containing invocations of threads spawned by the ``run`` member function of the
``task_block`` class. The ``run`` function spawns an |hpx| thread, a unit of
work that is allowed to execute in parallel with respect to the caller. Any
parallel tasks spawned by ``run`` within the task block are joined back to a
single thread of execution at the end of the ``define_task_block``. ``run``
takes a user-provided function object ``f`` and starts it asynchronously---i.e.,
it may return before the execution of ``f`` completes. The |hpx| scheduler may
choose to run ``f`` immediately or delay running ``f`` until compute resources
become available.

A ``task_block`` can be constructed only by ``define_task_block`` because it has
no public constructors. Thus, ``run`` can be invoked directly or indirectly
only from a user-provided function passed to ``define_task_block``::

    void g();

    void f(task_block<>& tr)
    {
        tr.run(g);          // OK, invoked from within task_block in h
    }

    void h()
    {
        define_task_block(f);
    }

    int main()
    {
        task_block<> tr;    // Error: no public constructor
        tr.run(g);          // No way to call run outside of a define_task_block
        return 0;
    }

.. _task_block_extensions:

Extensions for task blocks
--------------------------

Using execution policies with task blocks
.........................................

|hpx| implements some extensions for ``task_block`` beyond the actual
standards proposal |cpp11_n4088|_. The main addition is that a ``task_block``
can be invoked with an execution policy as its first argument, very similar to
the parallel algorithms.

An execution policy is an object that expresses the requirements on the
ordering of functions invoked as a consequence of the invocation of a
task block. Enabling passing an execution policy to ``define_task_block``
gives the user control over the amount of parallelism employed by the
created ``task_block``. In the following example the use of an explicit
``par`` execution policy makes the user's intent explicit::

    template <typename Func>
    int traverse(node *n, Func&& compute)
    {
        int left = 0, right = 0;

        define_task_block(
            execution::par,                // execution::parallel_policy
            [&](task_block<>& tb) {
                if (n->left)
                    tb.run([&] { left = traverse(n->left, compute); });
                if (n->right)
                    tb.run([&] { right = traverse(n->right, compute); });
            });

        return compute(n) + left + right;
    }

This also causes the :cpp:class:`hpx::parallel::v2::task_block` object to be a
template in our implementation. The template argument is the type of the
execution policy used to create the task block. The template argument defaults
to :cpp:class:`hpx::execution::parallel_policy`.

|hpx| still supports calling :cpp:func:`hpx::parallel::v2::define_task_block`
without an explicit execution policy. In this case the task block will run using
the :cpp:class:`hpx::execution::parallel_policy`.

|hpx| also adds the ability to access the execution policy that was used to
create a given ``task_block``.

Using executors to run tasks
............................

Often, users want to be able to not only define an execution policy to use by
default for all spawned tasks inside the task block, but also to
customize the execution context for one of the tasks executed by
``task_block::run``. Adding an optionally passed executor instance to that
function enables this use case::

    template <typename Func>
    int traverse(node *n, Func&& compute)
    {
        int left = 0, right = 0;

        define_task_block(
            execution::par,                // execution::parallel_policy
            [&](auto& tb) {
                if (n->left)
                {
                    // use explicitly specified executor to run this task
                    tb.run(my_executor(), [&] { left = traverse(n->left, compute); });
                }
                if (n->right)
                {
                    // use the executor associated with the par execution policy
                    tb.run([&] { right = traverse(n->right, compute); });
                }
            });

        return compute(n) + left + right;
    }

|hpx| still supports calling :cpp:func:`hpx::parallel::v2::task_block::run`
without an explicit executor object. In this case the task will be run using the
executor associated with the execution policy that was used to call
:cpp:func:`hpx::parallel::v2::define_task_block`.
..
    Copyright (c) 2015 Adrian Serio
    Copyright (c) 2015 Harris Brakmic
    Copyright (C) 2014 Thomas Heller
    Copyright (C) 2007-2013 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_build_system:

==================
|hpx| build system
==================

.. _prerequisites:

Prerequisites
=============

Supported platforms
-------------------

At this time, |hpx| supports the following platforms. Other platforms may
work, but we do not test |hpx| with other platforms, so please be warned.

.. table:: Supported Platforms for |hpx|

   ========= ================== ====================
   Name      Minimum Version    Architectures
   ========= ================== ====================
   Linux     2.6                x86-32, x86-64, k1om
   BlueGeneQ V1R2M0             PowerPC A2
   Windows   Any Windows system x86-32, x86-64
   Mac OSX   Any OSX system     x86-64
   ========= ================== ====================

Supported compilers
-------------------
The table below shows the supported compilers for |hpx|.

.. table:: Supported Compilers for |hpx|

   =================== ==================
   Name                Minimum Version
   =================== ==================
   |gcc|_              7.0
   |clang|_            7.0
   |visual_cxx|_ (x64) 2015
   =================== ==================

Software and libraries
----------------------

The table below presents all the necessary prerequisites for building |hpx|.

.. table:: Software prerequisites for |hpx|

   ====================== =================== ==================
   \                      Name                Minimum Version
   ====================== =================== ==================
   **Build System**       |cmake|_            3.18
   **Required Libraries** |boost|_            1.71.0
   \                      |hwloc|_            1.5
   \                      |asio|_             1.12.0
   ====================== =================== ==================

The most important dependencies are |boost|_ and |hwloc|_. The installation of Boost
is described in detail in Boost's `Getting Started <https://www.boost.org/more/getting_started/index.html>`_
document. A recent version of hwloc is required in order to support thread
pinning and NUMA awareness and can be found in |hwloc_downloads|_.

|hpx| is written in 99.99% Standard C++ (the remaining 0.01% is platform
specific assembly code). As such, |hpx| is compilable with almost any standards
compliant C++ compiler. The code base takes advantage of C++ language and
standard library features when available.

.. note::

   When building Boost using gcc, please note that it is required to specify a
   ``cxxflags=-std=c++17`` command line argument to ``b2`` (``bjam``).

.. note::

   In most configurations, |hpx| depends only on header-only Boost.
   Boost.Filesystem is required if the standard library does not support
   filesystem. The following are not needed by default, but are required in
   certain configurations: Boost.Chrono, Boost.DateTime, Boost.Log,
   Boost.LogSetup, Boost.Regex, and Boost.Thread.

Depending on the options you chose while building and installing |hpx|,
you will find that |hpx| may depend on several other libraries such as those
listed below.

.. note::

   In order to use a high speed parcelport, we currently recommend configuring
   |hpx| to use MPI so that MPI can be used for communication between different
   localities. Please set the CMake variable ``MPI_CXX_COMPILER`` to your MPI
   C++ compiler wrapper if not detected automatically.

.. list-table:: Optional software prerequisites for |hpx|

   * * Name
     * Minimum version
   * * |google_perftools|_
     * 1.7.1
   * * |jemalloc|_
     * 2.1.0
   * * |mimalloc|_
     * 1.0.0
   * * |papi|
     *

.. _getting_hpx:

Getting |hpx|
==============

Download a tarball of the latest release from |stellar_hpx_download|_ and
unpack it or clone the repository directly using ``git``:

.. code-block:: shell-session

    $ git clone https://github.com/STEllAR-GROUP/hpx.git

It is also recommended that you check out the latest stable tag:

.. code-block:: shell-session

    $ cd hpx
    $ git checkout 1.7.1

.. _building_hpx:

Building |hpx|
==============

.. _info:

Basic information
-----------------

The build system for |hpx| is based on |cmake|_, a cross-platform
build-generator tool which is not responsible for building the project
but rather generates the files needed by your build tool (GNU make, Visual
Studio, etc.) for building |hpx|. If CMake is not already installed in your
system, you can download it and install it here: |cmake_download|_.

Once |cmake| has been run, the build process can be started. The |hpx| build
process is highly configurable through |cmake|, and various |cmake| variables
influence the build process. The build process consists of the following parts:

* The |hpx| core libraries (target ``core``): This forms the basic set of |hpx|
  libraries.
* |hpx| Examples (target ``examples``): This target is enabled by default and
  builds all |hpx| examples (disable by setting
  :option:`HPX_WITH_EXAMPLES:BOOL`\ ``=Off``). |hpx| examples are part of the
  ``all`` target and are included in the installation if enabled.
* |hpx| Tests (target ``tests``): This target builds the |hpx| test suite and is
  enabled by default (disable by setting :option:`HPX_WITH_TESTS:BOOL`
  ``=Off``). They are not built by the ``all`` target and have to be built
  separately.
* |hpx| Documentation (target ``docs``): This target builds the documentation,
  and is not enabled by default (enable by setting
  :option:`HPX_WITH_DOCUMENTATION:BOOL`\ ``=On``. For more information see
  :ref:`documentation`.

For a complete list of available |cmake| variables that influence the build of
|hpx|, see :ref:`cmake_variables`.

The variables can be used to refine the recipes that can be found at
:ref:`build_recipes` which show some basic steps on how to build |hpx| for a
specific platform.

In order to use |hpx|, only the core libraries are required. In order to use the optional
libraries, you need to specify them as link dependencies in your build (See
:ref:`creating_hpx_projects`).

.. _important_cmake_options:

Most important |cmake| options 
------------------------------

While building |hpx|, you are provided with multiple CMake options which correspond 
to different configurations. Below, there is a set of the most important and frequently 
used CMake options.

.. option:: HPX_WITH_MALLOC

   Use a custom allocator. Using a custom allocator tuned for multithreaded applications is very 
   important for the performance of |hpx| applications. When debugging applications, it's useful to set 
   this to ``system``, as custom allocators can hide some memory-related bugs. Note that setting this to 
   something other than ``system`` requires an external dependency.

.. option:: HPX_WITH_CUDA

   Enable support for CUDA. Use ``CMAKE_CUDA_COMPILER`` to set the CUDA compiler. This is a standard |cmake| variable, 
   like ``CMAKE_CXX_COMPILER``. 

.. option:: HPX_WITH_PARCELPORT_MPI

   Enable the MPI parcelport. This enables the use of MPI for the networking operations in the HPX runtime. 
   The default value is ``OFF`` because it's not available on all systems and/or requires another dependency. However, 
   it is the recommended parcelport.

.. option:: HPX_WITH_PARCELPORT_TCP

   Enable the TCP parcelport. Enables the use of TCP for networking in the runtime. The default value is ``ON``. 
   However, it's only recommended for debugging purposes, as it is slower than the MPI parcelport.

.. option:: HPX_WITH_APEX
   
   Enable APEX integration. `APEX <https://uo-oaciss.github.io/apex/quickstarthpx/>`_ can be used to profile |hpx|
   applications. In particular, it provides information about individual tasks in the |hpx| runtime.

.. option:: HPX_WITH_GENERIC_CONTEXT_COROUTINES

   Enable Boost. Context for task context switching. It must be enabled for non-x86 architectures such as ARM and Power.

.. option:: HPX_WITH_MAX_CPU_COUNT

   Set the maximum CPU count supported by |hpx|. The default value is 64, and should be set to a number at least as
   high as the number of cores on a system including virtual cores such as hyperthreads.

.. option:: HPX_WITH_CXX_STANDARD

   Set a specific C++ standard version e.g. ``HPX_WITH_CXX_STANDARD=20``. The default and minimum value is 17. 

.. option:: HPX_WITH_EXAMPLES

   Build examples.

.. option:: HPX_WITH_TESTS
   
   Build tests.

.. _build_types:

Build types
-----------

|cmake| can be configured to generate project files suitable for builds that
have enabled debugging support or for an optimized build (without debugging
support). The |cmake| variable used to set the build type is
``CMAKE_BUILD_TYPE`` (for more information see the `CMake Documentation
<https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html>`_).
Available build types are:

* **Debug**: Full debug symbols are available as well as additional assertions to
  help debugging. To enable the debug build type for the |hpx| API, the C++ Macro
  ``HPX_DEBUG`` is defined.
* **RelWithDebInfo**: Release build with debugging symbols. This is most useful
  for profiling applications
* **Release**: Release build. This disables assertions and enables default
  compiler optimizations.
* **RelMinSize**: Release build with optimizations for small binary sizes.

.. important::

   We currently don't guarantee ABI compatibility between Debug and Release
   builds. Please make sure that applications built against |hpx| use the same
   build type as you used to build |hpx|. For CMake builds, this means that
   the ``CMAKE_BUILD_TYPE`` variables have to match and for projects not using
   |cmake|_, the ``HPX_DEBUG`` macro has to be set in debug mode.

.. _build_recipes:

Platform specific build recipes
-------------------------------

.. _unix_installation:

Unix variants
.............

Once you have the source code and the dependencies and assuming all your dependencies are in paths
known to |cmake|, the following gets you started:

#. First, set up a separate build directory to configure the project:

   .. code-block:: shell-session

      $ mkdir build && cd build

#. To configure the project you have the following options:

   * To build the core |hpx| libraries and examples, and install them to your chosen location (recommended):

    .. code-block:: shell-session

        $ cmake -DCMAKE_INSTALL_PREFIX=/install/path ..

    .. tip::

       If you want to change |cmake| variables for your build, it is usually a good
       idea to start with a clean build directory to avoid configuration problems.
       It is especially important that you use a clean build directory when changing
       between ``Release`` and ``Debug`` modes.

   * To install |hpx| to the default system folders, simply leave out the ``CMAKE_INSTALL_PREFIX`` option:

    .. code-block:: shell-session

        $ cmake ..

   * If your dependencies are in custom locations, you may need to tell |cmake| where to find them by passing one or more options to |cmake| as shown below:

    .. code-block:: shell-session

        $ cmake -DBOOST_ROOT=/path/to/boost
              -DHWLOC_ROOT=/path/to/hwloc
              -DTCMALLOC_ROOT=/path/to/tcmalloc
              -DJEMALLOC_ROOT=/path/to/jemalloc
              [other CMake variable definitions]
              /path/to/source/tree

    For instance:

    .. code-block:: shell-session

        $ cmake -DBOOST_ROOT=~/packages/boost -DHWLOC_ROOT=/packages/hwloc -DCMAKE_INSTALL_PREFIX=~/packages/hpx ~/downloads/hpx_1.5.1

   * If you want to try |hpx| without using a custom allocator pass ``-DHPX_WITH_MALLOC=system`` to |cmake|:

    .. code-block:: shell-session

        $ cmake -DCMAKE_INSTALL_PREFIX=/install/path -DHPX_WITH_MALLOC=system ..

    .. note::
       Please pay special attention to the section about :option:`HPX_WITH_MALLOC:STRING` as this is crucial for getting decent performance.

   .. important::

       If you are building |hpx| for a system with more than 64 processing units,
       you must change the |cmake| variable ``HPX_WITH_MAX_CPU_COUNT`` (to a value at least as big as the
       number of (virtual) cores on your system). Note that the default value is 64.

   .. caution::

       Compiling and linking |hpx| needs a considerable amount of memory. It is
       advisable that at least 2 GB of memory per parallel process is available.

#. Once the configuration is complete, to build the project you run:

  .. code-block:: shell-session

      $ cmake --build . --target install

.. _windows_installation:

Windows
.......

.. note::

   The following build recipes are mostly user-contributed and may be outdated.
   We always welcome updated and new build recipes.

To build |hpx| under Windows 10 x64 with Visual Studio 2015:

* Download the CMake V3.18.1 installer (or latest version) from `here
  <https://blog.kitware.com/cmake-3-18-1-available-for-download/>`__
* Download the hwloc V1.11.0 (or the latest version) from `here
  <http://www.open-mpi.org/software/hwloc/v1.11/downloads/hwloc-win64-build-1.11.0.zip>`__
  and unpack it.
* Download the latest Boost libraries from `here
  <https://www.boost.org/users/download/>`__ and unpack them.
* Build the Boost DLLs and LIBs by using these commands from Command Line (or
  PowerShell). Open CMD/PowerShell inside the Boost dir and type in:

  .. code-block:: bash

     bootstrap.bat

  This batch file will set up everything needed to create a successful build.
  Now execute:

  .. code-block:: bash

     b2.exe link=shared variant=release,debug architecture=x86 address-model=64 threading=multi --build-type=complete install

  This command will start a (very long) build of all available Boost libraries.
  Please, be patient.

* Open CMake-GUI.exe and set up your source directory (input field 'Where is the
  source code') to the *base directory* of the source code you downloaded from
  |hpx|'s GitHub pages. Here's an example of CMake path settings, which point to
  the ``Documents/GitHub/hpx`` folder:

  .. _win32_cmake_settings1:

  .. figure:: ../_static/images/cmake_settings1.png

     Example CMake path settings.

  Inside 'Where is the source-code' enter the base directory of your |hpx|
  source directory (do not enter the "src" sub-directory!). Inside 'Where to
  build the binaries' you should put in the path where all the building processes
  will happen. This is important because the building machinery will do an
  "out-of-tree" build. CMake will not touch or change the original source files
  in any way. Instead, it will generate Visual Studio Solution Files, which
  will build |hpx| packages out of the |hpx| source tree.

* Set three new environment variables (in CMake, not in Windows environment):
  ``BOOST_ROOT``, ``HWLOC_ROOT``, ``CMAKE_INSTALL_PREFIX``. The meaning of
  these variables is as follows:

  * ``BOOST_ROOT`` the |hpx| root directory of the unpacked Boost headers/cpp files.
  * ``HWLOC_ROOT`` the |hpx| root directory of the unpacked Portable Hardware Locality
    files.
  * ``CMAKE_INSTALL_PREFIX`` the |hpx| root directory where the future builds of |hpx|
    should be installed.

    .. note::

       |hpx| is a very large software collection, so it is not recommended to use the
       default ``C:\Program Files\hpx``. Many users may prefer to use simpler paths *without*
       whitespace, like ``C:\bin\hpx`` or ``D:\bin\hpx`` etc.

  To insert new env-vars click on "Add Entry" and then insert the name inside
  "Name", select ``PATH`` as Type and put the path-name in the "Path" text field.
  Repeat this for the first three variables.

  This is how variable insertion will look:

  .. _win32_cmake_settings2:

  .. figure:: ../_static/images/cmake_settings2.png

     Example CMake adding entry.

  Alternatively, users could provide ``BOOST_LIBRARYDIR`` instead of
  ``BOOST_ROOT``; the difference is that ``BOOST_LIBRARYDIR`` should point to
  the subdirectory inside Boost root where all the compiled DLLs/LIBs are. For
  example, ``BOOST_LIBRARYDIR`` may point to the ``bin.v2`` subdirectory under
  the Boost rootdir. It is important to keep the meanings of these two variables
  separated from each other: ``BOOST_DIR`` points to the ROOT folder of the
  Boost library. ``BOOST_LIBRARYDIR`` points to the subdir inside the Boost root
  folder where the compiled binaries are.

* Click the 'Configure' button of CMake-GUI. You will be immediately presented with a
  small window where you can select the C++ compiler to be used within Visual
  Studio. This has been tested using the latest v14 (a.k.a C++ 2015) but older
  versions should be sufficient too. Make sure to select the 64Bit compiler.

* After the generate process has finished successfully, click the 'Generate'
  button. Now, CMake will put new VS Solution files into the BUILD folder you
  selected at the beginning.

* Open Visual Studio and load the ``HPX.sln`` from your build folder.

* Go to ``CMakePredefinedTargets`` and build the ``INSTALL`` project:

  .. _win32_vs_targets:

  .. figure:: ../_static/images/vs_targets_install.png

     Visual Studio INSTALL target.

  It will take some time to compile everything, and in the end you should see an
  output similar to this one:

  .. _win32_vs_build_output:

  .. figure:: ../_static/images/vs_build_output.png

     Visual Studio build output.

.. _tests_examples:

Tests and examples
------------------

Running tests
.............

To build the tests:

.. code-block:: shell-session

    $ cmake --build . --target tests

To control which tests to run use ``ctest``:

* To run single tests, for example a test for ``for_loop``:

.. code-block:: shell-session

    $ ctest --output-on-failure -R tests.unit.modules.algorithms.for_loop

* To run a whole group of tests:

.. code-block:: shell-session

    $ ctest --output-on-failure -R tests.unit

Running examples
................

* To build (and install) all examples invoke:

.. code-block:: shell-session

   $ cmake -DHPX_WITH_EXAMPLES=On .
   $ make examples
   $ make install

* To build the ``hello_world_1`` example run:

.. code-block:: shell-session

   $ make hello_world_1

|hpx| executables end up in the ``bin`` directory in your build directory. You
can now run ``hello_world_1`` and should see the following output:

.. code-block:: shell-session

   $ ./bin/hello_world_1
   Hello World!

You've just run an example which prints ``Hello World!`` from the |hpx| runtime.
The source for the example is in ``examples/quickstart/hello_world_1.cpp``. The
``hello_world_distributed`` example (also available in the
``examples/quickstart`` directory) is a distributed hello world program, which is
described in :ref:`examples_hello_world`. It provides a gentle introduction to
the distributed aspects of |hpx|.

.. tip::

   Most build targets in |hpx| have two names: a simple name and
   a hierarchical name corresponding to what type of example or
   test the target is. If you are developing |hpx| it is often helpful to run
   ``make help`` to get a list of available targets. For example, ``make help |
   grep hello_world`` outputs the following:

   .. code-block:: sh

      ... examples.quickstart.hello_world_2
      ... hello_world_2
      ... examples.quickstart.hello_world_1
      ... hello_world_1
      ... examples.quickstart.hello_world_distributed
      ... hello_world_distributed

   It is also possible to build, for instance, all quickstart examples using ``make
   examples.quickstart``.

.. include:: ../../generated/cmake_variables.rst
..
    Copyright (C) 2020-2021 ETH Zurich
    Copyright (C) 2007-2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_6_0:

===========================
|hpx| V1.6.0 (Feb 17, 2021)
===========================

General changes
===============

This release continues the focus on C++20 conformance with multiple new
algorithms adapted to be C++20 conformant and becoming customization point
objects (CPOs). We have also added experimental support for HIP, allowing
previous CUDA features to now be compiled with hipcc and run on AMD GPUs.

* The following algorithms have been adapted to be C++20 conformant:
  ``adjacent_find``, ``includes``, ``inplace_merge``, ``is_heap``,
  ``is_heap_until``, ``is_partitioned``, ``is_sorted``, ``is_sorted_until``,
  ``merge``, ``set_difference``, ``set_intersection``,
  ``set_symmetric_difference``, ``set_union``.
* Experimental HIP support can be enabled by compiling |hpx| with ``hipcc``. All
  CUDA functionality in |hpx| can now be used with HIP. The HIP functionality is
  for the time being exposed through the same API as the CUDA functionality,
  i.e. no changes are required in user code. The CUDA, and now HIP,
  functionality is in the ``hpx::cuda`` namespace.
* We have added ``partial_sort`` based on Francisco Tapia's implementation.
* ``hpx::init`` and ``hpx::start`` gained new overloads taking an
  ``hpx::init_params`` struct in 1.5.0. All overloads not taking an
  ``hpx::init_params`` are now deprecated.
* We have added an experimental ``fork_join_executor``. This executor can be
  used for OpenMP-style fork-join parallelism, where the latency of a parallel
  region is important for performance.
* The ``parallel_executor`` now uses a hierarchical spawning scheme for bulk
  execution, which improves data locality and performance.
* ``hpx::dataflow`` can now be used with executors that inject additional
  parameters into the call of the user-provided function.
* We have added experimental support for properties as proposed in |p2220|_.
  Currently the only supported property is the scheduling hint on
  ``parallel_executor``.
* :cpp:func:`hpx::util::annotated_function` can now be passed a dynamically
  generated ``std::string``.
* In moving functionality to new namespaces, old names have been deprecated.  A
  deprecation warning will be issued if you are using deprecated functionality,
  with instructions on how to correct or ignore the warning.
* We have removed all support for C and Fortran from our build system.
* We have further reduced the use of Boost types within |hpx|
  (``boost::system::error_code`` and ``boost::detail::spinlock``).
* We have enabled more warnings in our CI builds (unused variables and unused
  typedefs).

Breaking changes
================

* hpxMP support has been completely removed.
* The ``verbs`` parcelport has been removed.
* The following compatibility options have been disabled by default:
  ``HPX_WITH_ACTION_BASE_COMPATIBILITY``,
  ``HPX_WITH_REGISTER_THREAD_COMPATIBILITY``,
  ``HPX_WITH_PROMISE_ALIAS_COMPATIBILITY``,
  ``HPX_WITH_UNSCOPED_ENUM_COMPATIBILITY``,
  ``HPX_PROGRAM_OPTIONS_WITH_BOOST_PROGRAM_OPTIONS_COMPATIBILITY``,
  ``HPX_WITH_EMBEDDED_THREAD_POOLS_COMPATIBILITY``,
  ``HPX_WITH_THREAD_POOL_OS_EXECUTOR_COMPATIBILITY``,
  ``HPX_WITH_THREAD_EXECUTORS_COMPATIBILITY``,
  ``HPX_THREAD_AWARE_TIMER_COMPATIBILITY``,
  ``HPX_WITH_POOL_EXECUTOR_COMPATIBILITY``. Unless noted here, the above
  functionalities do not come with replacements. Unscoped enumerations have been
  replaced by scoped enumerations. Previously deprecated unscoped enumerations
  are disabled by ``HPX_WITH_UNSCOPED_ENUM_COMPATIBILITY``. Newly deprecated
  unscoped enumerations have been given deprecation warnings and replaced by
  scoped enumerations. ``hpx::promise`` has been replaced with
  ``hpx::distributed::promise``. ``hpx::program_options`` is a drop-in
  replacement for ``boost::program_options``.
  ``hpx::execution::parallel_executor`` now has constructors which take a thread
  pool, covering the use case of ``hpx::threads::executors::pool_executor``. A
  pool can be supplied with ``hpx::resource::get_thread_pool``.

Closed issues
=============

* :hpx-issue:`5148` - ``runtime_support.hpp`` does not work with newer cling
* :hpx-issue:`5147` - Wrong results with parallel reduce
* :hpx-issue:`5129` - Missing specialization for ``std::hash<hpx::thread::id>``
* :hpx-issue:`5126` - Use ``std::string`` for task annotations
* :hpx-issue:`5115` - Don't expect hwloc to always report Cores
* :hpx-issue:`5113` - Handle threadmanager exceptions during startup
* :hpx-issue:`5112` - libatomic problems causing unexpected fails
* :hpx-issue:`5089` - Remove non-BSL files
* :hpx-issue:`5088` - Unwrapping problem
* :hpx-issue:`5087` - Remove hpxMP support
* :hpx-issue:`5077` - PAPI counters are not accessible when HPX is installed
* :hpx-issue:`5075` - Make the structs in all ``iter_sent.hpp`` lower case
* :hpx-issue:`5067` - Bug ``string_util/split.hpp``
* :hpx-issue:`5049` - Change back the hipcc jenkins config to the fury partition
  on rostam
* :hpx-issue:`5038` - Not all examples link in the latest HPX master
* :hpx-issue:`5035` - Build with ``HPX_WITH_EXAMPLES`` fails
* :hpx-issue:`5019` - Broken help string for hpx
* :hpx-issue:`5016` - ``hpx::parallel::fill`` fails compiling
* :hpx-issue:`5014` - Rename all ``.cc`` to ``.cpp`` and ``.hh`` to ``.hpp``
* :hpx-issue:`4988` - MPI is not finalized if running with only one locality
* :hpx-issue:`4978` - Change feature test macros to expand to zero/one
* :hpx-issue:`4949` - Crash when not enabling TCP parcelport
* :hpx-issue:`4933` - Improve test coverage for unused variable warnings etc.
* :hpx-issue:`4878` - HPX mpi async might call ``MPI_FINALIZE`` before app calls it
* :hpx-issue:`4127` - Local runtime entry-points

Closed pull requests
====================

* :hpx-pr:`5178` - Fix parallel ``remove``\ /\ ``remove_copy``\ /\ ``transform``
  namespace references in docs
* :hpx-pr:`5169` - Attempt to get Piz Daint jenkins setup running after
  maintenance
* :hpx-pr:`5168` - Remove include of itself
* :hpx-pr:`5167` - Fixing deprecation warnings that slipped through the net
* :hpx-pr:`5159` - Update APEX tag to 2.3.1
* :hpx-pr:`5154` - Splitting unit tests on circleci to avoid timeouts
* :hpx-pr:`5151` - Use C++20 on ``clang-newest`` Jenkins CI configuration
* :hpx-pr:`5149` - Rename ``'module'`` symbols to avoid keyword conflict
* :hpx-pr:`5145` - Adjust handling of CUDA/HIP options in CMake
* :hpx-pr:`5142` - Store annotated_function annotations as ``std::strings``
* :hpx-pr:`5140` - Scheduler mode
* :hpx-pr:`5139` - Fix path problem in pre-commit hook, add summary commit line
* :hpx-pr:`5138` - Add program options variable map to resource partitioner init
* :hpx-pr:`5137` - Remove the use of ``boost::throw_exception``
* :hpx-pr:`5136` - Make sure codespell checks run on CircleCI
* :hpx-pr:`5132` - Fixing spelling errors
* :hpx-pr:`5131` - Mark ``counting_iterator`` member functions as
  ``HPX_HOST_DEVICE``
* :hpx-pr:`5130` - Adding specialization for ``std::hash<hpx::thread::id>``
* :hpx-pr:`5128` - Fixing environment handling for FreeBSD
* :hpx-pr:`5127` - Fix typo in fibonacci documentation
* :hpx-pr:`5123` - Reduce vector sizes in partial sort benchmarks when running
  in debug mode
* :hpx-pr:`5122` - Making sure exceptions during runtime initialization are
  correctly reported
* :hpx-pr:`5121` - Working around hwloc limitation on certain platforms
* :hpx-pr:`5120` - Fixing compatibility warnings in ``hpx::transform``
  implementation
* :hpx-pr:`5119` - Use ``sequential_find`` and friends from separate detail
  header
* :hpx-pr:`5116` - Fix compilation with timer pool off
* :hpx-pr:`5114` - Fix 5112 - make sure libatomic is used when needed
* :hpx-pr:`5109` - Remove default runtime mode argument from init overload,
  again
* :hpx-pr:`5108` - Refactor ``iter_sent.hpp`` to make structs lowercase
* :hpx-pr:`5107` - Relax ``dataflow`` internals
* :hpx-pr:`5106` - Change initialization of property CPOs to satisfy older nvcc
  versions
* :hpx-pr:`5104` - Fix regeneration of two files that trigger unnecessary
  rebuilds
* :hpx-pr:`5103` - Remove default runtime mode argument from start/init
  overloads
* :hpx-pr:`5102` - Untie deprecated thread enums from the CMake option
* :hpx-pr:`5101` - Update APEX tag for 1.6.0
* :hpx-pr:`5100` - Bump minimum required Boost version to 1.66 and update CI
  configurations
* :hpx-pr:`5098` - Minor fixes to public API listing
* :hpx-pr:`5097` - Remove hpxMP support
* :hpx-pr:`5096` - Remove fractals examples
* :hpx-pr:`5095` - Use all AMD nodes again on rostam
* :hpx-pr:`5094` - Attempt to remove macOS workaround for GH actions environment
* :hpx-pr:`5093` - Remove verbs parcelport
* :hpx-pr:`5091` - Avoid moving from lvalues
* :hpx-pr:`5090` - Adopt C++20 ``std::endian``
* :hpx-pr:`5085` - Update daint CI to use Boost 1.75.0
* :hpx-pr:`5084` - Disable compatibility options for 1.6.0 release
* :hpx-pr:`5083` - Remove duplicated call to the ``limiting_executor`` in
  ``future_overhead`` test
* :hpx-pr:`5079` - Add checks to make sure that MPI/CUDA polling is enabled/not
  disabled too early
* :hpx-pr:`5078` - Add install lib directory to list of component search paths
* :hpx-pr:`5076` - Fix a typo in the jenkins ``clang-newest`` cmake config
* :hpx-pr:`5074` - Fixing warnings generated by MSVC
* :hpx-pr:`5073` - Allow using noncopyable types with unwrapping
* :hpx-pr:`5072` - Fix ``is_convertible`` args in ``result_types``
* :hpx-pr:`5071` - Fix unused parameters
* :hpx-pr:`5070` - Fix unused variables warnings in hipcc
* :hpx-pr:`5069` - Add support for sentinels to ``adjacent_find``
* :hpx-pr:`5068` - Fix string split function
* :hpx-pr:`5066` - Adapt ``search`` to C++20 and Range TS
* :hpx-pr:`5065` - Fix ``hpx::range::adjacent_find`` doxygen function signatures
* :hpx-pr:`5064` - Refactor runtime configuration, command line handling, and
  resource partitioner
* :hpx-pr:`5063` - Limit the device code guards to the distributed parts of the
  ``future_overhead`` bench
* :hpx-pr:`5061` - Remove hipcc guards in examples and tests
* :hpx-pr:`5060` - Fix deprecation warnings generated by msvc
* :hpx-pr:`5059` - Add warning about suspending/resuming the runtime in
  multi-locality scenarios
* :hpx-pr:`5057` - Fix unused variable warnings
* :hpx-pr:`5056` - Fix ``hpx::util::get``
* :hpx-pr:`5055` - Remove hipcc guards
* :hpx-pr:`5054` - Fix typo
* :hpx-pr:`5051` - Adapt transform to C++20
* :hpx-pr:`5050` - Replace old init overloads in tests and examples
* :hpx-pr:`5048` - Limit jenkins hipcc to the reno node
* :hpx-pr:`5047` - Limit cuda jenkins run to nodes with exclusively Nvidia GPUs
* :hpx-pr:`5046` - Convert thread and future enums to class enums
* :hpx-pr:`5043` - Improve ``hpxrun.py`` for Phylanx
* :hpx-pr:`5042` - Add missing header to partial sort test
* :hpx-pr:`5041` - Adding Francisco Tapia's implementation of ``partial_sort``
* :hpx-pr:`5040` - Remove generated headers left behind from a previous
  configuration
* :hpx-pr:`5039` - Fix GCC 10 release builds
* :hpx-pr:`5037` - Add ``is_invocable`` typedefs to top-level ``hpx`` namespace
  and public API list
* :hpx-pr:`5036` - Deprecate ``hpx::util::decay`` in favor of ``std::decay``
* :hpx-pr:`5034` - Use versioned container image on CircleCI
* :hpx-pr:`5033` - Implement P2220 properties module
* :hpx-pr:`5032` - Do codespell comparison only on files changed from common
  ancestor
* :hpx-pr:`5031` - Moving traits files to ``actions_base``
* :hpx-pr:`5030` - Add codespell version print in circleci
* :hpx-pr:`5029` - Work around problems in GitHub actions macOS builder
* :hpx-pr:`5028` - Moving move files to naming and naming_base
* :hpx-pr:`5027` - Lessen constraints on certain algorithm arguments
* :hpx-pr:`5025` - Adapt ``is_sorted`` and ``is_sorted_until`` to C++20
* :hpx-pr:`5024` - Moving ``naming_base`` to full modules
* :hpx-pr:`5022` - Remove C language from ``CMakeLists.txt``
* :hpx-pr:`5021` - Warn about unused arguments given to ``add_hpx_module``
* :hpx-pr:`5020` - Fixing help string
* :hpx-pr:`5018` - Update CSCS jenkins configuration to clang 11
* :hpx-pr:`5017` - Fixing broken backwards compatibility for
  ``hpx::parallel::fill``
* :hpx-pr:`5015` - Detect if generated global header conflicts with explicitly
  listed module headers
* :hpx-pr:`5012` - Properly reset pointer tracking data in ``output_archive``
* :hpx-pr:`5011` - Inspect command line tweaks
* :hpx-pr:`5010` - Creating AGAS module
* :hpx-pr:`5009` - Replace ``boost::system::error_code`` with
  ``std::error_code``
* :hpx-pr:`5008` - Replace uses of ``boost::detail::spinlock``
* :hpx-pr:`5007` - Bump minimal Boost version to 1.65.0
* :hpx-pr:`5006` - Adapt is_partitioned to C++20
* :hpx-pr:`5005` - Making sure ``reduce_by_key`` compiles again
* :hpx-pr:`5004` - Fixing template specializations that make extra archive data
  types unique across module boundaries
* :hpx-pr:`5003` - Relax ``dataflow`` argument constraints
* :hpx-pr:`5001` - Add ``<random>`` inspect check
* :hpx-pr:`4999` - Attempt to fix MacOS Github action error
* :hpx-pr:`4997` - Fix unused variable and typedef warnings
* :hpx-pr:`4996` - Adapt ``adjacent_find`` to C++20
* :hpx-pr:`4995` - Test all schedulers in ``cross_pool_injection`` test except
  ``shared_priority_queue_scheduler``
* :hpx-pr:`4993` - Fix deprecation warnings
* :hpx-pr:`4991` - Avoid unnecessarily including entire modules
* :hpx-pr:`4990` - Fixing some warnings from HPX complaining about use of
  obsolete types
* :hpx-pr:`4989` - add a \*destroy\* trait for ParcelPort plugins
* :hpx-pr:`4986` - Remove serialization to functional module dependency
* :hpx-pr:`4985` - Compatibility header generation
* :hpx-pr:`4980` - Add ranges overloads to ``for_loop`` (and variants)
* :hpx-pr:`4979` - Actually enable unity builds on Jenkins
* :hpx-pr:`4977` - Cleaning up ``debug::print`` functionalities
* :hpx-pr:`4976` - Remove indirection layer in ``at_index_impl``
* :hpx-pr:`4975` - Remove indirection layer in ``at_index_impl``
* :hpx-pr:`4973` - Avoid warnings/errors for older gcc complaining about
  multi-line comments
* :hpx-pr:`4970` - Making set algorithms conform to C++20
* :hpx-pr:`4969` - Moving ``is_execution_policy`` and friends into namespace
  ``hpx``
* :hpx-pr:`4968` - Enable deprecation warnings for 1.6.0 and move ``any``
  functionality to hpx namespace
* :hpx-pr:`4967` - Define deprecation macros conditionally
* :hpx-pr:`4966` - Add ``clang-format`` and ``cmake-format`` version prints
* :hpx-pr:`4965` - Making ``is_heap`` and ``is_heap_until`` conforming to C++20
* :hpx-pr:`4964` - Adding parallel ``make_heap``
* :hpx-pr:`4962` - Fix external timer function pointer exports
* :hpx-pr:`4960` - Fixing folder names for module tests and examples
* :hpx-pr:`4959` - Adding communications set
* :hpx-pr:`4958` - Deprecate tuple and timing functionality ``in hpx::util``
* :hpx-pr:`4957` - Fixing unity build option for parcelports
* :hpx-pr:`4953` - Fixing MSVC problems after recent restructurings
* :hpx-pr:`4952` - Make ``parallel_executor`` use ``thread_pool_executor``
  spawning mechanism
* :hpx-pr:`4948` - Clean up old artifacts better and more aggressively on
  Jenkins
* :hpx-pr:`4947` - Add HIP support for AMD GPUs
* :hpx-pr:`4945` - Enable ``HPX_WITH_UNITY_BUILD`` option on one of the Jenkins
  configurations
* :hpx-pr:`4943` - Move public ``hpx::parallel::execution`` functionality to
  hpx::execution
* :hpx-pr:`4938` - Post release cleanup
* :hpx-pr:`4858` - Extending resilience APIs to support distributed invocations
* :hpx-pr:`4744` - Fork-join executor
* :hpx-pr:`4665` - Implementing sender, receiver, and ``operation_state``
  concepts in terms of P0443r13
* :hpx-pr:`4649` - Split libhpx into multiple libraries
* :hpx-pr:`4642` - Implementing ``operation_state`` concept in terms of P0443r13
* :hpx-pr:`4640` - Implementing receiver concept in terms of P0443r13
* :hpx-pr:`4622` - Sanitizer fixes
..
    Copyright (C) 2020-2021 ETH Zurich
    Copyright (C) 2007-2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_7_1:

===========================
|hpx| V1.7.1 (Aug 12, 2021)
===========================

This is a bugfix release with a few minor fixes.

General changes
===============

- Added a CMake option to assume that all types are bitwise serializable by
  default: ``HPX_SERIALIZATION_WITH_ALL_TYPES_ARE_BITWISE_SERIALIZABLE``. The
  default value ``OFF`` corresponds to the old behaviour.
- Added a version check for Asio. The minimum Asio version supported by |hpx| is
  1.12.0.
- Fixed a bug affecting usage of actions, where the internals of |hpx| relied on
  function addresses being unique. This was fixed by relying on variable
  addresses being unique instead.
- Made ``hpx::util::bind`` more strict in checking the validity of placeholders.
- Small performance improvement to spinlocks.
- Adapted the following parallel algorithms to C++20: ``inclusive_scan``,
  ``exclusive_scan``, ``transform_inclusive_scan``,
  ``transform_exclusive_scan``.

Breaking changes
================

- The experimental ``hpx::execution::simdpar`` execution policy (introduced in
  1.7.0) was renamed to ``hpx::execution::par_simd`` for consistency with the
  other parallel policies.

Closed issues
=============

* :hpx-issue:`5494` - Rename `simdpar` execution policy to `par_simd`
* :hpx-issue:`5488` - `hpx::util::bind` doesn't bounds-check placeholders
* :hpx-issue:`5486` - Possible V1.7.1 release

Closed pull requests
====================

* :hpx-pr:`5500` - Minor bug fix in transform exclusive and inclusive scan tests
* :hpx-pr:`5499` - Rename simdpar to par_simd
* :hpx-pr:`5489` - Adding bound-checking for bind placeholders
* :hpx-pr:`5485` - Add Asio version check
* :hpx-pr:`5482` - Change extra archive data to rely on uniqueness of a variable address, not a function address
* :hpx-pr:`5448` - More fixes to enable for all types to be assumed to be bitwise copyable
* :hpx-pr:`5445` - Improve performance of Spinlocks
* :hpx-pr:`5444` - Adapt transform_inclusive_scan to C++ 20
* :hpx-pr:`5440` - Adapt transform_exclusive_scan to C++ 20
* :hpx-pr:`5439` - Adapt inclusive_scan to C++ 20
* :hpx-pr:`5436` - Adapt exclusive_scan to C++20
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_0:

==========================
|hpx| V0.9.0 (Jul 5, 2012)
==========================

We have had roughly 800 commits since the last release and we have closed
approximately 80 tickets (bugs, feature requests, etc.).

General changes
===============

* Significant improvements made to the usability of |hpx| in large-scale,
  distributed environments.
* Renamed :cpp:class:`hpx::lcos::packaged_task` to
  :cpp:class:`hpx::lcos::packaged_action` to reflect the semantic differences to
  a packaged_task as defined by the |cpp11|_.
* |hpx| now exposes :cpp:class:`hpx::thread` which is compliant to the C++11
  std::thread type except that it (purely locally) represents an |hpx| thread.
  This new type does not expose any of the remote capabilities of the underlying
  |hpx|-thread implementation.
* The type :cpp:class:`hpx::lcos::future` is now compliant to the C++11
  std::future<> type. This type can be used to synchronize both, local and
  remote operations. In both cases the control flow will 'return' to the future
  in order to trigger any continuation.
* The types :cpp:class:`hpx::lcos::local::promise` and
  :cpp:class:`hpx::lcos::local::packaged_task` are now compliant to the C++11
  ``std::promise<>`` and ``std::packaged_task<>`` types. These can be used to
  create a future representing local work only. Use the types
  :cpp:class:`hpx::lcos::promise` and :cpp:class:`hpx::lcos::packaged_action`
  to wrap any (possibly remote) action into a future.
* :cpp:class:`hpx::thread` and :cpp:class:`hpx::lcos::future` are now
  cancelable.
* Added support for sequential and logic composition of
  :cpp:class:`hpx::lcos::future`\ s. The member function
  :cpp:member:`hpx::lcos::future::when` permits futures to be sequentially
  composed. The helper functions :cpp:func:`hpx::wait_all`,
  :cpp:func:`hpx::wait_any`, and :cpp:func:`hpx::wait_n` can be used to wait for
  more than one future at a time.
* |hpx| now exposes :cpp:func:`hpx::apply` and :cpp:func:`hpx::async` as the
  preferred way of creating (or invoking) any deferred work. These functions are
  usable with various types of functions, function objects, and actions and
  provide a uniform way to spawn deferred tasks.
* |hpx| now utilizes :cpp:func:`hpx::util::bind` to (partially) bind local
  functions and function objects, and also actions. Remote bound actions can
  have placeholders as well.
* |hpx| continuations are now fully polymorphic. The class
  :cpp:class:`hpx::actions::forwarding_continuation` is an example of how the
  user can write is own types of continuations. It can be used to execute any
  function as an continuation of a particular action.
* Reworked the action invocation API to be fully conformant to normal functions.
  Actions can now be invoked using :cpp:func:`hpx::apply`,
  :cpp:func:`hpx::async`, or using the ``operator()`` implemented on actions.
  Actions themselves can now be cheaply instantiated as they do not have any
  members anymore.
* Reworked the lazy action invocation API. Actions can now be directly bound
  using :cpp:func:`hpx::util::bind` by passing an action instance as the first
  argument.
* A minimal |hpx| program now looks like this::

      #include <hpx/hpx_init.hpp>

      int hpx_main()
      {
          return hpx::finalize();
      }

      int main()
      {
          return hpx::init();
      }

  This removes the immediate dependency on the |boost_program_options|_ library.

  .. note::

     This minimal version of an |hpx| program does not support any of the
     default command line arguments (such as --help, or command line options
     related to PBS). It is suggested to always pass ``argc`` and ``argv`` to
     |hpx| as shown in the example below.

* In order to support those, but still not to depend on |boost_program_options|_,
  the minimal program can be written as::

      #include <hpx/hpx_init.hpp>

      // The arguments for hpx_main can be left off, which very similar to the
      // behavior of ``main()`` as defined by C++.
      int hpx_main(int argc, char* argv[])
      {
          return hpx::finalize();
      }

      int main(int argc, char* argv[])
      {
          return hpx::init(argc, argv);
      }

* Added performance counters exposing the number of component instances which
  are alive on a given locality.
* Added performance counters exposing then number of messages sent and received,
  the number of parcels sent and received, the number of bytes sent and
  received, the overall time required to send and receive data, and the overall
  time required to serialize and deserialize the data.
* Added a new component: :cpp:class:`hpx::components::binpacking_factory` which
  is equivalent to the existing
  :cpp:class:`hpx::components::distributing_factory` component, except that it
  equalizes the overall population of the components to create. It exposes two
  factory methods, one based on the number of existing instances of the
  component type to create, and one based on an arbitrary performance counter
  which will be queried for all relevant localities.
* Added API functions allowing to access elements of the diagnostic information
  embedded in the given exception: :cpp:func:`hpx::get_locality_id`,
  :cpp:func:`hpx::get_host_name`, :cpp:func:`hpx::get_process_id`,
  :cpp:func:`hpx::get_function_name`, :cpp:func:`hpx::get_file_name`,
  :cpp:func:`hpx::get_line_number`, :cpp:func:`hpx::get_os_thread`,
  :cpp:func:`hpx::get_thread_id`, and :cpp:func:`hpx::get_thread_description`.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release:

* :hpx-issue:`71` - GIDs that are not serialized via ``handle_gid<>`` should
  raise an exception
* :hpx-issue:`105` - Allow for :cpp:class:`hpx::util::function`\ s to be registered
  in the AGAS symbolic namespace
* :hpx-issue:`107` - Nasty threadmanger race condition (reproducible in
  sheneos_test)
* :hpx-issue:`108` - Add millisecond resolution to |hpx| logs on Linux
* :hpx-issue:`110` - Shutdown hang in distributed with release build
* :hpx-issue:`116` - Don't use TSS for the applier and runtime pointers
* :hpx-issue:`162` - Move local synchronous execution shortcut from
  hpx::function to the applier
* :hpx-issue:`172` - Cache sources in CMake and check if they change manually
* :hpx-issue:`178` - Add an INI option to turn off ranged-based AGAS caching
* :hpx-issue:`187` - Support for disabling performance counter deployment
* :hpx-issue:`202` - Support for sending performance counter data to a specific
  file
* :hpx-issue:`218` - boost.coroutines allows different stack sizes, but stack
  pool is unaware of this
* :hpx-issue:`231` - Implement movable ``boost::bind``
* :hpx-issue:`232` - Implement movable ``boost::function``
* :hpx-issue:`236` - Allow binding :cpp:class:`hpx::util::function` to actions
* :hpx-issue:`239` - Replace ``hpx::function`` with
  :cpp:class:`hpx::util::function`
* :hpx-issue:`240` - Can't specify RemoteResult with lcos::async
* :hpx-issue:`242` - REGISTER_TEMPLATE support for plain actions
* :hpx-issue:`243` - ``handle_gid<>`` support for
  :cpp:class:`hpx::util::function`
* :hpx-issue:`245` - ``*_c_cache code`` throws an exception if the queried GID
  is not in the local cache
* :hpx-issue:`246` - Undefined references in dataflow/adaptive1d example
* :hpx-issue:`252` - Problems configuring sheneos with CMake
* :hpx-issue:`254` - Lifetime of components doesn't end when client goes out of
  scope
* :hpx-issue:`259` - CMake does not detect that MSVC10 has lambdas
* :hpx-issue:`260` - io_service_pool segfault
* :hpx-issue:`261` - Late parcel executed outside of pxthread
* :hpx-issue:`263` - Cannot select allocator with CMake
* :hpx-issue:`264` - Fix allocator select
* :hpx-issue:`267` - Runtime error for hello_world
* :hpx-issue:`269` - pthread_affinity_np test fails to compile
* :hpx-issue:`270` - Compiler noise due to -Wcast-qual
* :hpx-issue:`275` - Problem with configuration tests/include paths on Gentoo
* :hpx-issue:`325` - Sheneos is 200-400 times slower than the fortran equivalent
* :hpx-issue:`331` - :cpp:func:`hpx::init` and ``hpx_main()`` should not depend
  on program_options
* :hpx-issue:`333` - Add doxygen support to CMake for doc toolchain
* :hpx-issue:`340` - Performance counters for parcels
* :hpx-issue:`346` - Component loading error when running hello_world in
  distributed on MSVC2010
* :hpx-issue:`362` - Missing initializer error
* :hpx-issue:`363` - Parcel port serialization error
* :hpx-issue:`366` - Parcel buffering leads to types incompatible exception
* :hpx-issue:`368` - Scalable alternative to rand() needed for |hpx|
* :hpx-issue:`369` - IB over IP is substantially slower than just using standard
  TCP/IP
* :hpx-issue:`374` - :cpp:func:`hpx::lcos::wait` should work with dataflows and
  arbitrary classes meeting the future interface
* :hpx-issue:`375` - Conflicting/ambiguous overloads of
  :cpp:func:`hpx::lcos::wait`
* :hpx-issue:`376` - Find_HPX.cmake should set CMake variable HPX_FOUND for out
  of tree builds
* :hpx-issue:`377` - ShenEOS interpolate bulk and interpolate_one_bulk are
  broken
* :hpx-issue:`379` - Add support for distributed runs under SLURM
* :hpx-issue:`382` - _Unwind_Word not declared in boost.backtrace
* :hpx-issue:`387` - Doxygen should look only at list of specified files
* :hpx-issue:`388` - Running ``make install`` on an out-of-tree application is
  broken
* :hpx-issue:`391` - Out-of-tree application segfaults when running in qsub
* :hpx-issue:`392` - Remove HPX_NO_INSTALL option from cmake build system
* :hpx-issue:`396` - Pragma related warnings when compiling with older gcc
  versions
* :hpx-issue:`399` - Out of tree component build problems
* :hpx-issue:`400` - Out of source builds on Windows: linker should not receive
  compiler flags
* :hpx-issue:`401` - Out of source builds on Windows: components need to be
  linked with hpx_serialization
* :hpx-issue:`404` - gfortran fails to link automatically when fortran files are
  present
* :hpx-issue:`405` - Inability to specify linking order for external libraries
* :hpx-issue:`406` - Adapt action limits such that dataflow applications work
  without additional defines
* :hpx-issue:`415` - ``locality_results`` is not a member of
  ``hpx::components::server``
* :hpx-issue:`425` - Breaking changes to ``traits::*result`` wrt
  ``std::vector<id_type>``
* :hpx-issue:`426` - AUTOGLOB needs to be updated to support fortran

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_9:

============================================
|hpx| V0.9.9 (Oct 31, 2014, codename Spooky)
============================================

General changes
===============

We have had over 1500 commits since the last release and we have closed over 200
tickets (bugs, feature requests, pull requests, etc.). These are by far the
largest numbers of commits and resolved issues for any of the |hpx| releases so
far. We are especially happy about the large number of people who contributed
for the first time to |hpx|.

* We completed the transition from the older (non-conforming) implementation of
  ``hpx::future`` to the new and fully conforming version by removing the old
  code and by renaming the type ``hpx::unique_future`` to ``hpx::future``. In
  order to maintain backwards compatibility with existing code which uses the
  type ``hpx::unique_future`` we support the configuration variable
  ``HPX_UNIQUE_FUTURE_ALIAS``. If this variable is set to ``ON`` while running
  cmake it will additionally define a template alias for this type.
* We rewrote and significantly changed our build system. Please have a look at
  the new (now generated) documentation here: :ref:`hpx_build_system`. Please
  revisit your build scripts to adapt to the changes. The most notable changes
  are:

   * ``HPX_NO_INSTALL`` is no longer necessary.
   * For external builds, you need to set ``HPX_DIR`` instead of ``HPX_ROOT`` as
     described here: :ref:`using_hpx_cmake`.
   * IDEs that support multiple configurations (Visual Studio and XCode) can now
     be used as intended. that means no build dir.
   * Building HPX statically (without dynamic libraries) is now supported
     (``-DHPX_STATIC_LINKING=On``).
   * Please note that many variables used to configure the build process have
     been renamed to unify the naming conventions (see the section
     :ref:`cmake_variables` for more information).
   * This also fixes a long list of issues, for more information see
     :hpx-issue:`1204`.
* We started to implement various proposals to the C++ Standardization committee
  related to parallelism and concurrency, most notably |cpp11_n4104|_ (Working
  Draft, Technical Specification for C++ Extensions for Parallelism),
  |cpp11_n4088|_ (Task Region Rev. 3), and |cpp11_n4107|_ (Working Draft,
  Technical Specification for C++ Extensions for Concurrency).
* We completely remodeled our automatic build system to run builds and unit
  tests on various systems and compilers. This allows us to find most bugs right
  as they were introduced and helps to maintain a high level of quality and
  compatibility. The newest build logs can be found at |hpx_buildbot|_.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-issue:`1296` - Rename make_error_future to make_exceptional_future,
  adjust to N4123
* :hpx-issue:`1295` - building issue
* :hpx-issue:`1293` - Transpose example
* :hpx-issue:`1292` - Wrong abs() function used in example
* :hpx-issue:`1291` - non-synchronized shift operators have been removed
* :hpx-issue:`1290` - RDTSCP is defined as true for Xeon Phi build
* :hpx-issue:`1289` - Fixing 1288
* :hpx-issue:`1288` - Add new performance counters
* :hpx-issue:`1287` - Hierarchy scheduler broken performance counters
* :hpx-issue:`1286` - Algorithm cleanup
* :hpx-issue:`1285` - Broken Links in Documentation
* :hpx-issue:`1284` - Uninitialized copy
* :hpx-issue:`1283` - missing boost::scoped_ptr includes
* :hpx-issue:`1282` - Update documentation of build options for schedulers
* :hpx-issue:`1281` - reset idle rate counter
* :hpx-issue:`1280` - Bug when executing on Intel MIC
* :hpx-issue:`1279` - Add improved when_all/wait_all
* :hpx-issue:`1278` - Implement improved when_all/wait_all
* :hpx-issue:`1277` - feature request: get access to argc argv and variables_map
* :hpx-issue:`1276` - Remove merging map
* :hpx-issue:`1274` - Weird (wrong) string code in papi.cpp
* :hpx-issue:`1273` - Sequential task execution policy
* :hpx-issue:`1272` - Avoid CMake name clash for Boost.Thread library
* :hpx-issue:`1271` - Updates on HPX Test Units
* :hpx-issue:`1270` - hpx/util/safe_lexical_cast.hpp is added
* :hpx-issue:`1269` - Added default value for "LIB" cmake variable
* :hpx-issue:`1268` - Memory Counters not working
* :hpx-issue:`1266` - FindHPX.cmake is not installed
* :hpx-issue:`1263` - apply_remote test takes too long
* :hpx-issue:`1262` - Chrono cleanup
* :hpx-issue:`1261` - Need make install for papi counters and this builds all
  the examples
* :hpx-issue:`1260` - Documentation of Stencil example claims
* :hpx-issue:`1259` - Avoid double-linking Boost on Windows
* :hpx-issue:`1257` - Adding additional parameter to create_thread
* :hpx-issue:`1256` - added buildbot changes to release notes
* :hpx-issue:`1255` - Cannot build MiniGhost
* :hpx-issue:`1253` - hpx::thread defects
* :hpx-issue:`1252` - HPX_PREFIX is too fragile
* :hpx-issue:`1250` - switch_to_fiber_emulation does not work properly
* :hpx-issue:`1249` - Documentation is generated under Release folder
* :hpx-issue:`1248` - Fix usage of hpx_generic_coroutine_context and get tests
  passing on powerpc
* :hpx-issue:`1247` - Dynamic linking error
* :hpx-issue:`1246` - Make cpuid.cpp C++11 compliant
* :hpx-issue:`1245` - HPX fails on startup (setting thread affinity mask)
* :hpx-issue:`1244` - HPX_WITH_RDTSC configure test fails, but should succeed
* :hpx-issue:`1243` - CTest dashboard info for CSCS CDash drop location
* :hpx-issue:`1242` - Mac fixes
* :hpx-issue:`1241` - Failure in Distributed with Boost 1.56
* :hpx-issue:`1240` - fix a race condition in examples.diskperf
* :hpx-issue:`1239` - fix wait_each in examples.diskperf
* :hpx-issue:`1238` - Fixed #1237: hpx::util::portable_binary_iarchive failed
* :hpx-issue:`1237` - hpx::util::portable_binary_iarchive faileds
* :hpx-issue:`1235` - Fixing clang warnings and errors
* :hpx-issue:`1234` - TCP runs fail: Transport endpoint is not connected
* :hpx-issue:`1233` - Making sure the correct number of threads is registered
  with AGAS
* :hpx-issue:`1232` - Fixing race in wait_xxx
* :hpx-issue:`1231` - Parallel minmax
* :hpx-issue:`1230` - Distributed run of 1d_stencil_8 uses less threads than
  spec. & sometimes gives errors
* :hpx-issue:`1229` - Unstable number of threads
* :hpx-issue:`1228` - HPX link error (cmake / MPI)
* :hpx-issue:`1226` - Warning about struct/class thread_counters
* :hpx-issue:`1225` - Adding parallel::replace etc
* :hpx-issue:`1224` - Extending dataflow to pass through non-future arguments
* :hpx-issue:`1223` - Remaining find algorithms implemented, N4071
* :hpx-issue:`1222` - Merging all the changes
* :hpx-issue:`1221` - No error output when using mpirun with hpx
* :hpx-issue:`1219` - Adding new AGAS cache performance counters
* :hpx-issue:`1216` - Fixing using futures (clients) as arguments to actions
* :hpx-issue:`1215` - Error compiling simple component
* :hpx-issue:`1214` - Stencil docs
* :hpx-issue:`1213` - Using more than a few dozen MPI processes on SuperMike
  results in a seg fault before getting to hpx_main
* :hpx-issue:`1212` - Parallel rotate
* :hpx-issue:`1211` - Direct actions cause the future's shared_state to be
  leaked
* :hpx-issue:`1210` - Refactored local::promise to be standard conformant
* :hpx-issue:`1209` - Improve command line handling
* :hpx-issue:`1208` - Adding parallel::reverse and parallel::reverse_copy
* :hpx-issue:`1207` - Add copy_backward and move_backward
* :hpx-issue:`1206` - N4071 additional algorithms implemented
* :hpx-issue:`1204` - Cmake simplification and various other minor changes
* :hpx-issue:`1203` - Implementing new launch policy for (local) async:
  ``hpx::launch::fork``.
* :hpx-issue:`1202` - Failed assertion in connection_cache.hpp
* :hpx-issue:`1201` - pkg-config doesn't add mpi link directories
* :hpx-issue:`1200` - Error when querying time performance counters
* :hpx-issue:`1199` - library path is now configurable (again)
* :hpx-issue:`1198` - Error when querying performance counters
* :hpx-issue:`1197` - tests fail with intel compiler
* :hpx-issue:`1196` - Silence several warnings
* :hpx-issue:`1195` - Rephrase initializers to work with VC++ 2012
* :hpx-issue:`1194` - Simplify parallel algorithms
* :hpx-issue:`1193` - Adding ``parallel::equal``
* :hpx-issue:`1192` - HPX(out_of_memory) on including <hpx/hpx.hpp>
* :hpx-issue:`1191` - Fixing #1189
* :hpx-issue:`1190` - Chrono cleanup
* :hpx-issue:`1189` - Deadlock .. somewhere? (probably serialization)
* :hpx-issue:`1188` - Removed ``future::get_status()``
* :hpx-issue:`1186` - Fixed FindOpenCL to find current AMD APP SDK
* :hpx-issue:`1184` - Tweaking future unwrapping
* :hpx-issue:`1183` - Extended ``parallel::reduce``
* :hpx-issue:`1182` - ``future::unwrap`` hangs for ``launch::deferred``
* :hpx-issue:`1181` - Adding ``all_of``, ``any_of``, and ``none_of`` and
  corresponding documentation
* :hpx-issue:`1180` - ``hpx::cout`` defect
* :hpx-issue:`1179` - ``hpx::async`` does not work for member function pointers
  when called on types with self-defined unary ``operator*``
* :hpx-issue:`1178` - Implemented variadic ``hpx::util::zip_iterator``
* :hpx-issue:`1177` - MPI parcelport defect
* :hpx-issue:`1176` - ``HPX_DEFINE_COMPONENT_CONST_ACTION_TPL`` does not have a
  2-argument version
* :hpx-issue:`1175` - Create util::zip_iterator working with util::tuple<>
* :hpx-issue:`1174` - Error Building HPX on linux,
  root_certificate_authority.cpp
* :hpx-issue:`1173` - hpx::cout output lost
* :hpx-issue:`1172` - HPX build error with Clang 3.4.2
* :hpx-issue:`1171` - ``CMAKE_INSTALL_PREFIX`` ignored
* :hpx-issue:`1170` - Close hpx_benchmarks repository on Github
* :hpx-issue:`1169` - Buildbot emails have syntax error in url
* :hpx-issue:`1167` - Merge partial implementation of standards proposal N3960
* :hpx-issue:`1166` - Fixed several compiler warnings
* :hpx-issue:`1165` - cmake warns: "tests.regressions.actions" does not exist
* :hpx-issue:`1164` - Want my own serialization of hpx::future
* :hpx-issue:`1162` - Segfault in hello_world example
* :hpx-issue:`1161` - Use ``HPX_ASSERT`` to aid the compiler
* :hpx-issue:`1160` - Do not put -DNDEBUG into hpx_application.pc
* :hpx-issue:`1159` - Support Clang 3.4.2
* :hpx-issue:`1158` - Fixed #1157: Rename when_n/wait_n, add
  when_xxx_n/wait_xxx_n
* :hpx-issue:`1157` - Rename when_n/wait_n, add when_xxx_n/wait_xxx_n
* :hpx-issue:`1156` - Force inlining fails
* :hpx-issue:`1155` - changed header of printout to be compatible with python
  csv module
* :hpx-issue:`1154` - Fixing iostreams
* :hpx-issue:`1153` - Standard manipulators (like std::endl) do not work with
  hpx::ostream
* :hpx-issue:`1152` - Functions revamp
* :hpx-issue:`1151` - Suppressing cmake 3.0 policy warning for CMP0026
* :hpx-issue:`1150` - Client Serialization error
* :hpx-issue:`1149` - Segfault on Stampede
* :hpx-issue:`1148` - Refactoring mini-ghost
* :hpx-issue:`1147` - N3960 copy_if and copy_n implemented and tested
* :hpx-issue:`1146` - Stencil print
* :hpx-issue:`1145` - N3960 hpx::parallel::copy implemented and tested
* :hpx-issue:`1144` - OpenMP examples 1d_stencil do not build
* :hpx-issue:`1143` - 1d_stencil OpenMP examples do not build
* :hpx-issue:`1142` - Cannot build HPX with gcc 4.6 on OS X
* :hpx-issue:`1140` - Fix OpenMP lookup, enable usage of config tests in
  external CMake projects.
* :hpx-issue:`1139` - hpx/hpx/config/compiler_specific.hpp
* :hpx-issue:`1138` - clean up pkg-config files
* :hpx-issue:`1137` - Improvements to create binary packages
* :hpx-issue:`1136` - HPX_GCC_VERSION not defined on all compilers
* :hpx-issue:`1135` - Avoiding collision between winsock2.h and windows.h
* :hpx-issue:`1134` - Making sure, that hpx::finalize can be called from any
  locality
* :hpx-issue:`1133` - 1d stencil examples
* :hpx-issue:`1131` - Refactor unique_function implementation
* :hpx-issue:`1130` - Unique function
* :hpx-issue:`1129` - Some fixes to the Build system on OS X
* :hpx-issue:`1128` - Action future args
* :hpx-issue:`1127` - Executor causes segmentation fault
* :hpx-issue:`1124` - Adding new API functions: ``register_id_with_basename``,
  ``unregister_id_with_basename``, ``find_ids_from_basename``; adding test
* :hpx-issue:`1123` - Reduce nesting of try-catch construct in
  ``encode_parcels``?
* :hpx-issue:`1122` - Client base fixes
* :hpx-issue:`1121` - Update ``hpxrun.py.in``
* :hpx-issue:`1120` - HTTS2 tests compile errors on v110 (VS2012)
* :hpx-issue:`1119` - Remove references to boost::atomic in accumulator example
* :hpx-issue:`1118` - Only build test thread_pool_executor_1114_test if
  ``HPX_SCHEDULER`` is set
* :hpx-issue:`1117` - local_queue_executor linker error on vc110
* :hpx-issue:`1116` - Disabled performance counter should give runtime errors,
  not invalid data
* :hpx-issue:`1115` - Compile error with Intel C++ 13.1
* :hpx-issue:`1114` - Default constructed executor is not usable
* :hpx-issue:`1113` - Fast compilation of logging causes ABI incompatibilities
  between different ``NDEBUG`` values
* :hpx-issue:`1112` - Using thread_pool_executors causes segfault
* :hpx-issue:`1111` - ``hpx::threads::get_thread_data`` always returns zero
* :hpx-issue:`1110` - Remove unnecessary null pointer checks
* :hpx-issue:`1109` - More tests adjustments
* :hpx-issue:`1108` - Clarify build rules for "libboost_atomic-mt.so"?
* :hpx-issue:`1107` - Remove unnecessary null pointer checks
* :hpx-issue:`1106` - network_storage benchmark improvements, adding legends to
  plots and tidying layout
* :hpx-issue:`1105` - Add more plot outputs and improve instructions doc
* :hpx-issue:`1104` - Complete quoting for parameters of some CMake commands
* :hpx-issue:`1103` - Work on test/scripts
* :hpx-issue:`1102` - Changed minimum requirement of window install to 2012
* :hpx-issue:`1101` - Changed minimum requirement of window install to 2012
* :hpx-issue:`1100` - Changed readme to no longer specify using MSVC 2010
  compiler
* :hpx-issue:`1099` - Error returning futures from component actions
* :hpx-issue:`1098` - Improve storage test
* :hpx-issue:`1097` - data_actions quickstart example calls missing function
  decorate_action of data_get_action
* :hpx-issue:`1096` - MPI parcelport broken with new zero copy optimization
* :hpx-issue:`1095` - Warning C4005: _WIN32_WINNT: Macro redefinition
* :hpx-issue:`1094` - Syntax error for -DHPX_UNIQUE_FUTURE_ALIAS in master
* :hpx-issue:`1093` - Syntax error for -DHPX_UNIQUE_FUTURE_ALIAS
* :hpx-issue:`1092` - Rename unique_future<> back to future<>
* :hpx-issue:`1091` - Inconsistent error message
* :hpx-issue:`1090` - On windows 8.1 the examples crashed if using more than one
  os thread
* :hpx-issue:`1089` - Components should be allowed to have their own executor
* :hpx-issue:`1088` - Add possibility to select a network interface for the
  ibverbs parcelport
* :hpx-issue:`1087` - ibverbs and ipc parcelport uses zero copy optimization
* :hpx-issue:`1083` - Make shell examples copyable in docs
* :hpx-issue:`1082` - Implement proper termination detection during shutdown
* :hpx-issue:`1081` - Implement thread_specific_ptr for hpx::threads
* :hpx-issue:`1072` - make install not working properly
* :hpx-issue:`1070` - Complete quoting for parameters of some CMake commands
* :hpx-issue:`1059` - Fix more unused variable warnings
* :hpx-issue:`1051` - Implement when_each
* :hpx-issue:`973` - Would like option to report hwloc bindings
* :hpx-issue:`970` - Bad flags for Fortran compiler
* :hpx-issue:`941` - Create a proper user level context switching class for BG/Q
* :hpx-issue:`935` - Build error with gcc 4.6 and Boost 1.54.0 on hpx trunk and
  0.9.6
* :hpx-issue:`934` - Want to build HPX without dynamic libraries
* :hpx-issue:`927` - Make hpx/lcos/reduce.hpp accept futures of id_type
* :hpx-issue:`926` - All unit tests that are run with more than one thread with
  CTest/hpx_run_test should configure hpx.os_threads
* :hpx-issue:`925` - regression_dataflow_791 needs to be brought in line with
  HPX standards
* :hpx-issue:`899` - Fix race conditions in regression tests
* :hpx-issue:`879` - Hung test leads to cascading test failure; make tests
  should support the MPI parcelport
* :hpx-issue:`865` - future<T> and friends shall work for movable only Ts
* :hpx-issue:`847` - Dynamic libraries are not installed on OS X
* :hpx-issue:`816` - First Program tutorial pull request
* :hpx-issue:`799` - Wrap lexical_cast to avoid exceptions
* :hpx-issue:`720` - broken configuration when using ccmake on Ubuntu
* :hpx-issue:`622` - ``--hpx:hpx`` and ``--hpx:debug-hpx-log`` is nonsensical
* :hpx-issue:`525` - Extend barrier LCO test to run in distributed
* :hpx-issue:`515` - Multi-destination version of hpx::apply is broken
* :hpx-issue:`509` - Push Boost.Atomic changes upstream
* :hpx-issue:`503` - Running HPX applications on Windows should not require
  setting %PATH%
* :hpx-issue:`461` - Add a compilation sanity test
* :hpx-issue:`456` - hpx_run_tests.py should log output from tests that timeout
* :hpx-issue:`454` - Investigate threadmanager performance
* :hpx-issue:`345` - Add more versatile environmental/cmake variable support to
  hpx_find_* CMake macros
* :hpx-issue:`209` - Support multiple configurations in generated build files
* :hpx-issue:`190` - hpx::cout should be a std::ostream
* :hpx-issue:`189` - iostreams component should use startup/shutdown functions
* :hpx-issue:`183` - Use Boost.ICL for correctness in AGAS
* :hpx-issue:`44` - Implement real futures

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_10:

============================
|hpx| V0.9.10 (Mar 24, 2015)
============================

General changes
===============

This is the 12th official release of |hpx|. It coincides with the 7th
anniversary of the first commit to our source code repository. Since then, we
have seen over 12300 commits amounting to more than 220000 lines of C++ code.

The major focus of this release was to improve the reliability of large scale
runs. We believe to have achieved this goal as we now can reliably run |hpx|
applications on up to ~24k cores. We have also shown that HPX can be used with
success for symmetric runs (applications using both, host cores and Intel
Xeon/Phi coprocessors). This is a huge step forward in terms of the usability of
|hpx|. The main focus of this work involved isolating the causes of the
segmentation faults at start up and shut down. Many of these issues were
discovered to be the result of the suspension of threads which hold locks.

A very important improvement introduced with this release is the refactoring of
the code representing our parcel-port implementation. Parcel- ports can now be
implemented by 3rd parties as independent plugins which are dynamically loaded
at runtime (static linking of parcel-ports is also supported). This refactoring
also includes a massive improvement of the performance of our existing
parcel-ports. We were able to significantly reduce the networking latencies and
to improve the available networking bandwidth. Please note that in this release
we disabled the ibverbs and ipc parcel ports as those have not been ported to
the new plugin system yet (see :hpx-issue:`839`).

Another corner stone of this release is our work towards a complete
implementation of __cpp11_n4104__ (Working Draft, Technical Specification for
C++ Extensions for Parallelism). This document defines a set of parallel
algorithms to be added to the C++ standard library. We now have implemented
about 75% of all specified parallel algorithms (see [link
hpx.manual.parallel.parallel_algorithms Parallel Algorithms] for more details).
We also implemented some extensions to __cpp11_n4104__ allowing to invoke all of
the algorithms asynchronously.

This release adds a first implementation of ``hpx::vector`` which is a
distributed data structure closely aligned to the functionality of
``std::vector``. The difference is that ``hpx::vector`` stores the data in
partitions where the partitions can be distributed over different localities. We
started to work on allowing to use the parallel algorithms with ``hpx::vector``.
At this point we have implemented only a few of the parallel algorithms to
support distributed data structures (like ``hpx::vector``) for testing purposes
(see :hpx-issue:`1338` for a documentation of our progress).

Breaking changes
================

With this release we put a lot of effort into changing the code base to be more
compatible to C++11. These changes have caused the following issues for backward
compatibility:

* Move to Variadics- All of the API now uses variadic templates. However, this
  change required to modify the argument sequence for some of the exiting API
  functions (:cpp:func:`hpx::async_continue`, :cpp:func:`hpx::apply_continue`,
  :cpp:func:`hpx::when_each`, :cpp:func:`hpx::wait_each`, synchronous invocation
  of actions).
* Changes to Macros- We also removed the macros ``HPX_STD_FUNCTION`` and
  ``HPX_STD_TUPLE``. This shouldn't affect any user code as we replaced
  ``HPX_STD_FUNCTION`` with ``hpx::util::function_nonser`` which was the default
  expansion used for this macro. All |hpx| API functions which expect a
  ``hpx::util::function_nonser`` (or a ``hpx::util::unique_function_nonser``)
  can now be transparently called with a compatible ``std::function`` instead.
  Similarly, ``HPX_STD_TUPLE`` was replaced by its default expansion as well:
  ``hpx::util::tuple``.
* Changes to ``hpx::unique_future``- ``hpx::unique_future``, which was
  deprecated in the previous release for :cpp:func:`hpx::future` is now
  completely removed from |hpx|. This completes the transition to a completely
  standards conforming implementation of ``hpx::future``.
* Changes to Supported Compilers. Finally, in order to utilize more C++11
  semantics, we have officially dropped support for GCC 4.4 and MSVC 2012.
  Please see our :ref:`prerequisites` page for more details.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-issue:`1402` - Internal shared_future serialization copies
* :hpx-issue:`1399` - Build takes unusually long time...
* :hpx-issue:`1398` - Tests using the scan partitioner are broken on at least
  gcc 4.7 and intel compiler
* :hpx-issue:`1397` - Completely remove hpx::unique_future
* :hpx-issue:`1396` - Parallel scan algorithms with different initial values
* :hpx-issue:`1395` - Race Condition - 1d_stencil_8 - SuperMIC
* :hpx-issue:`1394` - "suspending thread while at least one lock is being
  held" - 1d_stencil_8 - SuperMIC
* :hpx-issue:`1393` - SEGFAULT in 1d_stencil_8 on SuperMIC
* :hpx-issue:`1392` - Fixing #1168
* :hpx-issue:`1391` - Parallel Algorithms for scan partitioner for small number
  of elements
* :hpx-issue:`1387` - Failure with more than 4 localities
* :hpx-issue:`1386` - Dispatching unhandled exceptions to outer user code
* :hpx-issue:`1385` - Adding Copy algorithms, fixing ``parallel::copy_if``
* :hpx-issue:`1384` - Fixing 1325
* :hpx-issue:`1383` - Fixed #504: Refactor Dataflow LCO to work with futures,
  this removes the dataflow component as it is obsolete
* :hpx-issue:`1382` - ``is_sorted``, ``is_sorted_until`` and ``is_partitioned``
  algorithms
* :hpx-issue:`1381` - fix for CMake versions prior to 3.1
* :hpx-issue:`1380` - resolved warning in CMake 3.1 and newer
* :hpx-issue:`1379` - Compilation error with papi
* :hpx-issue:`1378` - Towards safer migration
* :hpx-issue:`1377` - HPXConfig.cmake should include ``TCMALLOC_LIBRARY`` and
  ``TCMALLOC_INCLUDE_DIR``
* :hpx-issue:`1376` - Warning on uninitialized member
* :hpx-issue:`1375` - Fixing 1163
* :hpx-issue:`1374` - Fixing the MSVC 12 release builder
* :hpx-issue:`1373` - Modifying parallel search algorithm for zero length
  searches
* :hpx-issue:`1372` - Modifying parallel search algorithm for zero length
  searches
* :hpx-issue:`1371` - Avoid holding a lock during agas::incref while doing a
  credit split
* :hpx-issue:`1370` - ``--hpx:bind`` throws unexpected error
* :hpx-issue:`1369` - Getting rid of (void) in loops
* :hpx-issue:`1368` - Variadic templates support for tuple
* :hpx-issue:`1367` - One last batch of variadic templates support
* :hpx-issue:`1366` - Fixing symbolic namespace hang
* :hpx-issue:`1365` - More held locks
* :hpx-issue:`1364` - Add counters 1363
* :hpx-issue:`1363` - Add thread overhead counters
* :hpx-issue:`1362` - Std config removal
* :hpx-issue:`1361` - Parcelport plugins
* :hpx-issue:`1360` - Detuplify transfer_action
* :hpx-issue:`1359` - Removed obsolete checks
* :hpx-issue:`1358` - Fixing 1352
* :hpx-issue:`1357` - Variadic templates support for runtime_support and
  components
* :hpx-issue:`1356` - fixed coordinate test for intel13
* :hpx-issue:`1355` - fixed coordinate.hpp
* :hpx-issue:`1354` - Lexicographical Compare completed
* :hpx-issue:`1353` - HPX should set ``Boost_ADDITIONAL_VERSIONS`` flags
* :hpx-issue:`1352` - Error: Cannot find action '' in type registry:
  HPX(bad_action_code)
* :hpx-issue:`1351` - Variadic templates support for appliers
* :hpx-issue:`1350` - Actions simplification
* :hpx-issue:`1349` - Variadic when and wait functions
* :hpx-issue:`1348` - Added hpx_init header to test files
* :hpx-issue:`1347` - Another batch of variadic templates support
* :hpx-issue:`1346` - Segmented copy
* :hpx-issue:`1345` - Attempting to fix hangs during shutdown
* :hpx-issue:`1344` - Std config removal
* :hpx-issue:`1343` - Removing various distribution policies for hpx::vector
* :hpx-issue:`1342` - Inclusive scan
* :hpx-issue:`1341` - Exclusive scan
* :hpx-issue:`1340` - Adding ``parallel::count`` for distributed data
  structures, adding tests
* :hpx-issue:`1339` - Update argument order for transform_reduce
* :hpx-issue:`1337` - Fix dataflow to handle properly ranges of futures
* :hpx-issue:`1336` - dataflow needs to hold onto futures passed to it
* :hpx-issue:`1335` - Fails to compile with msvc14
* :hpx-issue:`1334` - Examples build problem
* :hpx-issue:`1333` - Distributed transform reduce
* :hpx-issue:`1332` - Variadic templates support for actions
* :hpx-issue:`1331` - Some ambiguous calls of map::erase have been prevented by
  adding additional check in locality constructor.
* :hpx-issue:`1330` - Defining Plain Actions does not work as described in the
  documentation
* :hpx-issue:`1329` - Distributed vector cleanup
* :hpx-issue:`1328` - Sync docs and comments with code in hello_world example
* :hpx-issue:`1327` - Typos in docs
* :hpx-issue:`1326` - Documentation and code diverged in Fibonacci tutorial
* :hpx-issue:`1325` - Exceptions thrown during parcel handling are not handled
  correctly
* :hpx-issue:`1324` - fixed bandwidth calculation
* :hpx-issue:`1323` - mmap() failed to allocate thread stack due to insufficient
  resources
* :hpx-issue:`1322` - HPX fails to build aa182cf
* :hpx-issue:`1321` - Limiting size of outgoing messages while coalescing
  parcels
* :hpx-issue:`1320` - passing a future with launch::deferred in remote function
  call causes hang
* :hpx-issue:`1319` - An exception when tries to specify number high priority
  threads with abp-priority
* :hpx-issue:`1318` - Unable to run program with abp-priority and
  numa-sensitivity enabled
* :hpx-issue:`1317` - N4071 Search/Search_n finished, minor changes
* :hpx-issue:`1316` - Add config option to make -Ihpx.run_hpx_main!=1 the
  default
* :hpx-issue:`1314` - Variadic support for async and apply
* :hpx-issue:`1313` - Adjust when_any/some to the latest proposed interfaces
* :hpx-issue:`1312` - Fixing #857: hpx::naming::locality leaks parcelport
  specific information into the public interface
* :hpx-issue:`1311` - Distributed get'er/set'er_values for distributed vector
* :hpx-issue:`1310` - Crashing in
  hpx::parcelset::policies::mpi::connection_handler::handle_messages() on
  SuperMIC
* :hpx-issue:`1308` - Unable to execute an application with --hpx:threads
* :hpx-issue:`1307` - merge_graph linking issue
* :hpx-issue:`1306` - First batch of variadic templates support
* :hpx-issue:`1305` - Create a compiler wrapper
* :hpx-issue:`1304` - Provide a compiler wrapper for hpx
* :hpx-issue:`1303` - Drop support for GCC44
* :hpx-issue:`1302` - Fixing #1297
* :hpx-issue:`1301` - Compilation error when tried to use boost range iterators
  with wait_all
* :hpx-issue:`1298` - Distributed vector
* :hpx-issue:`1297` - Unable to invoke component actions recursively
* :hpx-issue:`1294` - HDF5 build error
* :hpx-issue:`1275` - The parcelport implementation is non-optimal
* :hpx-issue:`1267` - Added classes and unit tests for local_file, orangefs_file
  and pxfs_file
* :hpx-issue:`1264` - Error "assertion '!m_fun' failed" randomly occurs when
  using TCP
* :hpx-issue:`1254` - thread binding seems to not work properly
* :hpx-issue:`1220` - parallel::copy_if is broken
* :hpx-issue:`1217` - Find a better way of fixing the issue patched by #1216
* :hpx-issue:`1168` - Starting HPX on Cray machines using aprun isn't working
  correctly
* :hpx-issue:`1085` - Replace startup and shutdown barriers with broadcasts
* :hpx-issue:`981` - With SLURM, --hpx:threads=8 should not be necessary
* :hpx-issue:`857` - hpx::naming::locality leaks parcelport specific information
  into the public interface
* :hpx-issue:`850` - "flush" not documented
* :hpx-issue:`763` - Create buildbot instance that uses std::bind as
  HPX_STD_BIND
* :hpx-issue:`680` - Convert parcel ports into a plugin system
* :hpx-issue:`582` - Make exception thrown from HPX threads available from
  ``hpx::init``
* :hpx-issue:`504` - Refactor Dataflow LCO to work with futures
* :hpx-issue:`196` - Don't store copies of the locality network metadata in the
  gva table

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_8_0:

===========================
|hpx| V0.8.0 (Mar 23, 2012)
===========================

We have had roughly 1000 commits since the last release and we have closed
approximately 70 tickets (bugs, feature requests, etc.).

General changes
===============

* Improved PBS support, allowing for arbitrary naming schemes of node-hostnames.
* Finished verification of the reference counting framework.
* Implemented decrement merging logic to optimize the distributed reference
  counting system.
* Restructured the LCO framework. Renamed ``hpx::lcos::eager_future<>`` and
  ``hpx::lcos::lazy_future<>`` into :cpp:class:`hpx::lcos::packaged_task` and
  :cpp:class:`hpx::lcos::deferred_packaged_task`. Split
  :cpp:class:`hpx::lcos::promise` into :cpp:class:`hpx::lcos::packaged_task` and
  :cpp:class:`hpx::lcos::future`. Added 'local' futures (in namespace
  ``hpx::lcos::local``).
* Improved the general performance of local and remote action invocations. This
  (under certain circumstances) drastically reduces the number of copies created
  for each of the parameters and return values.
* Reworked the performance counter framework. Performance counters are now
  created only when needed, which reduces the overall resource requirements. The
  new framework allows for much more flexible creation and management of
  performance counters. The new sine example application demonstrates some of
  the capabilities of the new infrastructure.
* Added a buildbot-based continuous build system which gives instant, automated
  feedback on each commit to SVN.
* Added more automated tests to verify proper functioning of |hpx|.
* Started to create documentation for |hpx| and its API.
* Added documentation toolchain to the build system.
* Added dataflow LCO.
* Changed default |hpx| command line options to have ``hpx:`` prefix. For
  instance, the former option ``--threads`` is now :option:`--hpx:threads`. This
  has been done to make ambiguities with possible application specific command
  line options as unlikely as possible. See the section :ref:`commandline` for a
  full list of available options.
* Added the possibility to define command line aliases. The former short
  (one-letter) command line options have been predefined as aliases for
  backwards compatibility. See the section :ref:`commandline` for a detailed
  description of command line option aliasing.
* Network connections are now cached based on the connected host. The number of
  simultaneous connections to a particular host is now limited. Parcels are
  buffered and bundled if all connections are in use.
* Added more refined thread affinity control. This is based on the external
  library |hwloc|.
* Improved support for Windows builds with CMake.
* Added support for components to register their own command line options.
* Added the possibility to register custom startup/shutdown functions for any
  component. These functions are guaranteed to be executed by an |hpx| thread.
* Added two new experimental thread schedulers: hierarchy_scheduler and
  periodic_priority_scheduler. These can be activated by using the command line
  options :option:`--hpx:queuing`\ ``=hierarchy`` or :option:`--hpx:queuing`\
  ``=periodic``.

Example applications
====================

* `Graph500 performance benchmark <http://www.graph500.org/>`_ (thanks to
  Matthew Anderson for contributing this application).
* `GTC (Gyrokinetic Toroidal Code)
  <http://www.nersc.gov/research-and-development/benchmarking-and-workload-characterization/nersc-6-benchmarks/gtc/>`_:
  a skeleton for particle in cell type codes.
* Random Memory Access: an example demonstrating random memory accesses in a
  large array
* `ShenEOS example <http://stellarcollapse.org/equationofstate>`_, demonstrating
  partitioning of large read-only data structures and exposing an interpolation
  API.
* Sine performance counter demo.
* Accumulator examples demonstrating how to write and use |hpx| components.
* Quickstart examples (like hello_world, fibonacci, quicksort, factorial, etc.)
  demonstrating simple |hpx| concepts which introduce some of the concepts in
  |hpx|.
* Load balancing and work stealing demos.

API changes
===========

* Moved all local LCOs into a separate namespace ``hpx::lcos::local`` (for
  instance, ``hpx::lcos::local_mutex`` is now
  :cpp:class:`hpx::lcos::local::mutex`).
* Replaced ``hpx::actions::function`` with :cpp:class:`hpx::util::function`.
  Cleaned up related code.
* Removed ``hpx::traits::handle_gid`` and moved handling of global reference
  counts into the corresponding serialization code.
* Changed terminology: ``prefix`` is now called ``locality_id``, renamed the
  corresponding API functions (such as ``hpx::get_prefix``, which is now called
  ``hpx::get_locality_id``).
* Adding :cpp:func:`hpx::find_remote_localities`, and
  :cpp:func:`hpx::get_num_localities`.
* Changed performance counter naming scheme to make it more bash friendly.
  The new performance counter naming scheme is now

  .. code-block:: text

     /object{parentname#parentindex/instance#index}/counter#parameters

* Added ``hpx::get_worker_thread_num`` replacing
  ``hpx::threadmanager_base::get_thread_num``.
* Renamed ``hpx::get_num_os_threads`` to ``hpx::get_os_threads_count``.
* Added ``hpx::threads::get_thread_count``.
* Restructured the Futures sub-system, renaming types in accordance with the
  terminology used by the C++11 ISO standard.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release:

* :hpx-issue:`31` - Specialize handle_gid<> for examples and tests
* :hpx-issue:`72` - Fix AGAS reference counting
* :hpx-issue:`104` - heartbeat throws an exception when decrefing the
  performance counter it's watching
* :hpx-issue:`111` - throttle causes an exception on the target application
* :hpx-issue:`142` - One failed component loading causes an unrelated component
  to fail
* :hpx-issue:`165` - Remote exception propagation bug in AGAS reference counting
  test
* :hpx-issue:`186` - Test credit exhaustion/splitting (e.g. prepare_gid and
  symbol NS)
* :hpx-issue:`188` - Implement remaining AGAS reference counting test cases
* :hpx-issue:`258` - No type checking of GIDs in stubs classes
* :hpx-issue:`271` - Seg fault/shared pointer assertion in distributed code
* :hpx-issue:`281` - CMake options need descriptive text
* :hpx-issue:`283` - AGAS caching broken (gva_cache needs to be rewritten
  with ICL)
* :hpx-issue:`285` - HPX_INSTALL root directory not the same as
  CMAKE_INSTALL_PREFIX
* :hpx-issue:`286` - New segfault in dataflow applications
* :hpx-issue:`289` - Exceptions should only be logged if not handled
* :hpx-issue:`290` - c++11 tests failure
* :hpx-issue:`293` - Build target for component libraries
* :hpx-issue:`296` - Compilation error with Boost V1.49rc1
* :hpx-issue:`298` - Illegal instructions on termination
* :hpx-issue:`299` - gravity aborts with multiple threads
* :hpx-issue:`301` - Build error with Boost trunk
* :hpx-issue:`303` - Logging assertion failure in distributed runs
* :hpx-issue:`304` - Exception 'what' strings are lost when exceptions from
  decode_parcel are reported
* :hpx-issue:`306` - Performance counter user interface issues
* :hpx-issue:`307` - Logging exception in distributed runs
* :hpx-issue:`308` - Logging deadlocks in distributed
* :hpx-issue:`309` - Reference counting test failures and exceptions
* :hpx-issue:`311` - Merge AGAS remote_interface with the runtime_support object
* :hpx-issue:`314` - Object tracking for id_types
* :hpx-issue:`315` - Remove handle_gid and handle credit splitting in id_type
  serialization
* :hpx-issue:`320` - applier::get_locality_id() should return an error value (or
  throw an exception)
* :hpx-issue:`321` - Optimization for id_types which are never split should be
  restored
* :hpx-issue:`322` - Command line processing ignored with Boost 1.47.0
* :hpx-issue:`323` - Credit exhaustion causes object to stay alive
* :hpx-issue:`324` - Duplicate exception messages
* :hpx-issue:`326` - Integrate Quickbook with CMake
* :hpx-issue:`329` - --help and --version should still work
* :hpx-issue:`330` - Create pkg-config files
* :hpx-issue:`337` - Improve usability of performance counter timestamps
* :hpx-issue:`338` - Non-std exceptions deriving from std::exceptions in tfunc
  may be sliced
* :hpx-issue:`339` - Decrease the number of send_pending_parcels threads
* :hpx-issue:`343` - Dynamically setting the stack size doesn't work
* :hpx-issue:`351` - 'make install' does not update documents
* :hpx-issue:`353` - Disable FIXMEs in the docs by default; add a doc developer
  CMake option to enable FIXMEs
* :hpx-issue:`355` - 'make' doesn't do anything after correct configuration
* :hpx-issue:`356` - Don't use ``hpx::util::static_`` in topology code
* :hpx-issue:`359` - Infinite recursion in hpx::tuple serialization
* :hpx-issue:`361` - Add compile time option to disable logging completely
* :hpx-issue:`364` - Installation seriously broken in r7443

.. Proofread by:
   Adrian Serio 3-13-12
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_7:

===========================
|hpx| V0.9.7 (Nov 13, 2013)
===========================

We have had over 1000 commits since the last release and we have closed over 180
tickets (bugs, feature requests, etc.).

General changes
===============

* Ported HPX to BlueGene/Q
* Improved HPX support for Xeon/Phi accelerators
* Reimplemented ``hpx::bind``, ``hpx::tuple``, and ``hpx::function`` for better
  performance and better compliance with the |cpp11|. Added ``hpx::mem_fn``.
* Reworked ``hpx::when_all`` and ``hpx::when_any`` for better compliance with
  the ongoing C++ standardization effort, added heterogeneous version for those
  functions. Added ``hpx::when_any_swapped``.
* Added ``hpx::copy`` as a precursor for a migrate functionality
* Added ``hpx::get_ptr`` allowing to directly access the memory underlying a
  given component
* Added the ``hpx::lcos::broadcast``, ``hpx::lcos::reduce``, and
  ``hpx::lcos::fold`` collective operations
* Added ``hpx::get_locality_name`` allowing to retrieve the name of any of the
  localities for the application.
* Added support for more flexible thread affinity control from the HPX command
  line, such as new modes for ``--hpx:bind`` (``balanced``, ``scattered``,
  ``compact``), improved default settings when running multiple localities on
  the same node.
* Added experimental executors for simpler thread pooling and scheduling. This
  API may change in the future as it will stay aligned with the ongoing C++
  standardization efforts.
* Massively improved the performance of the HPX serialization code. Added
  partial support for zero copy serialization of array and bitwise-copyable
  types.
* General performance improvements of the code related to threads and futures.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-issue:`1005` - Allow one to disable array optimizations and zero copy
  optimizations for each parcelport
* :hpx-issue:`1004` - Generate new HPX logo image for the docs
* :hpx-issue:`1002` - If MPI parcelport is not available, running HPX under
  mpirun should fail
* :hpx-issue:`1001` - Zero copy serialization raises assert
* :hpx-issue:`1000` - Can't connect to a HPX application running with the MPI
  parcelport from a non MPI parcelport locality
* :hpx-issue:`999` - Optimize ``hpx::when_n``
* :hpx-issue:`998` - Fixed const-correctness
* :hpx-issue:`997` - Making serialize_buffer::data() type save
* :hpx-issue:`996` - Memory leak in hpx::lcos::promise
* :hpx-issue:`995` - Race while registering pre-shutdown functions
* :hpx-issue:`994` - thread_rescheduling regression test does not compile
* :hpx-issue:`992` - Correct comments and messages
* :hpx-issue:`991` - setcap cap_sys_rawio=ep for power profiling causes an HPX
  application to abort
* :hpx-issue:`989` - Jacobi hangs during execution
* :hpx-issue:`988` - multiple_init test is failing
* :hpx-issue:`986` - Can't call a function called "init" from "main" when using
  ``<hpx/hpx_main.hpp>``
* :hpx-issue:`984` - Reference counting tests are failing
* :hpx-issue:`983` - thread_suspension_executor test fails
* :hpx-issue:`980` - Terminating HPX threads don't leave stack in virgin state
* :hpx-issue:`979` - Static scheduler not in documents
* :hpx-issue:`978` - Preprocessing limits are broken
* :hpx-issue:`977` - Make tests.regressions.lcos.future_hang_on_get shorter
* :hpx-issue:`976` - Wrong library order in pkgconfig
* :hpx-issue:`975` - Please reopen #963
* :hpx-issue:`974` - Option pu-offset ignored in fixing_588 branch
* :hpx-issue:`972` - Cannot use MKL with HPX
* :hpx-issue:`969` - Non-existent INI files requested on the command line via
  ``--hpx:config`` do not cause warnings or errors.
* :hpx-issue:`968` - Cannot build examples in fixing_588 branch
* :hpx-issue:`967` - Command line description of ``--hpx:queuing`` seems wrong
* :hpx-issue:`966` - ``--hpx:print-bind`` physical core numbers are wrong
* :hpx-issue:`965` - Deadlock when building in Release mode
* :hpx-issue:`963` - Not all worker threads are working
* :hpx-issue:`962` - Problem with SLURM integration
* :hpx-issue:`961` - ``--hpx:print-bind`` outputs incorrect information
* :hpx-issue:`960` - Fix cut and paste error in documentation of
  get_thread_priority
* :hpx-issue:`959` - Change link to boost.atomic in documentation to point to
  boost.org
* :hpx-issue:`958` - Undefined reference to intrusive_ptr_release
* :hpx-issue:`957` - Make tuple standard compliant
* :hpx-issue:`956` - Segfault with a3382fb
* :hpx-issue:`955` - ``--hpx:nodes`` and ``--hpx:nodefiles`` do not work with
  foreign nodes
* :hpx-issue:`954` - Make order of arguments for hpx::async and hpx::broadcast
  consistent
* :hpx-issue:`953` - Cannot use MKL with HPX
* :hpx-issue:`952` - ``register_[pre_]shutdown_function`` never throw
* :hpx-issue:`951` - Assert when number of threads is greater than hardware
  concurrency
* :hpx-issue:`948` - ``HPX_HAVE_GENERIC_CONTEXT_COROUTINES`` conflicts with
  ``HPX_HAVE_FIBER_BASED_COROUTINES``
* :hpx-issue:`947` - Need MPI_THREAD_MULTIPLE for backward compatibility
* :hpx-issue:`946` - HPX does not call ``MPI_Finalize``
* :hpx-issue:`945` - Segfault with ``hpx::lcos::broadcast``
* :hpx-issue:`944` - OS X: assertion ``pu_offset_ < hardware_concurrency``
  failed
* :hpx-issue:`943` - #include <hpx/hpx_main.hpp> does not work
* :hpx-issue:`942` - Make the BG/Q work with -O3
* :hpx-issue:`940` - Use separator when concatenating locality name
* :hpx-issue:`939` - Refactor MPI parcelport to use ``MPI_Wait`` instead of
  multiple ``MPI_Test`` calls
* :hpx-issue:`938` - Want to officially access ``client_base::gid_``
* :hpx-issue:`937` - ``client_base::gid_`` should be private``
* :hpx-issue:`936` - Want doxygen-like source code index
* :hpx-issue:`935` - Build error with gcc 4.6 and Boost 1.54.0 on hpx trunk and
  0.9.6
* :hpx-issue:`933` - Cannot build HPX with Boost 1.54.0
* :hpx-issue:`932` - Components are destructed too early
* :hpx-issue:`931` - Make HPX work on BG/Q
* :hpx-issue:`930` - make git-docs is broken
* :hpx-issue:`929` - Generating index in docs broken
* :hpx-issue:`928` - Optimize ``hpx::util::static_`` for C++11 compilers
  supporting magic statics
* :hpx-issue:`924` - Make kill_process_tree (in process.py) more robust on Mac
  OSX
* :hpx-issue:`923` - Correct BLAS and RNPL cmake tests
* :hpx-issue:`922` - Cannot link against BLAS
* :hpx-issue:`921` - Implement ``hpx::mem_fn``
* :hpx-issue:`920` - Output locality with ``--hpx:print-bind``
* :hpx-issue:`919` - Correct grammar; simplify boolean expressions
* :hpx-issue:`918` - Link to hello_world.cpp is broken
* :hpx-issue:`917` - adapt cmake file to new boostbook version
* :hpx-issue:`916` - fix problem building documentation with xsltproc >= 1.1.27
* :hpx-issue:`915` - Add another TBBMalloc library search path
* :hpx-issue:`914` - Build problem with Intel compiler on Stampede (TACC)
* :hpx-issue:`913` - fix error messages in fibonacci examples
* :hpx-issue:`911` - Update OS X build instructions
* :hpx-issue:`910` - Want like to specify MPI_ROOT instead of compiler wrapper
  script
* :hpx-issue:`909` - Warning about void* arithmetic
* :hpx-issue:`908` - Buildbot for MIC is broken
* :hpx-issue:`906` - Can't use ``--hpx:bind=balanced`` with multiple MPI
  processes
* :hpx-issue:`905` - ``--hpx:bind`` documentation should describe full grammar
* :hpx-issue:`904` - Add hpx::lcos::fold and hpx::lcos::inverse_fold collective
  operation
* :hpx-issue:`903` - Add ``hpx::when_any_swapped()``
* :hpx-issue:`902` - Add ``hpx::lcos::reduce`` collective operation
* :hpx-issue:`901` - Web documentation is not searchable
* :hpx-issue:`900` - Web documentation for trunk has no index
* :hpx-issue:`898` - Some tests fail with GCC 4.8.1 and MPI parcel port
* :hpx-issue:`897` - HWLOC causes failures on Mac
* :hpx-issue:`896` - pu-offset leads to startup error
* :hpx-issue:`895` - ``hpx::get_locality_name`` not defined
* :hpx-issue:`894` - Race condition at shutdown
* :hpx-issue:`893` - ``--hpx:print-bind`` switches std::cout to hexadecimal mode
* :hpx-issue:`892` - ``hwloc_topology_load`` can be expensive -- don't call
  multiple times
* :hpx-issue:`891` - The documentation for ``get_locality_name`` is wrong
* :hpx-issue:`890` - ``--hpx:print-bind`` should not exit
* :hpx-issue:`889` - ``--hpx:debug-hpx-log=FILE`` does not work
* :hpx-issue:`888` - MPI parcelport does not exit cleanly for --hpx:print-bind
* :hpx-issue:`887` - Choose thread affinities more cleverly
* :hpx-issue:`886` - Logging documentation is confusing
* :hpx-issue:`885` - Two threads are slower than one
* :hpx-issue:`884` - is_callable failing with member pointers in C++11
* :hpx-issue:`883` - Need help with is_callable_test
* :hpx-issue:`882` - tests.regressions.lcos.future_hang_on_get does not
  terminate
* :hpx-issue:`881` - tests/regressions/block_matrix/matrix.hh won't compile with
  GCC 4.8.1
* :hpx-issue:`880` - HPX does not work on OS X
* :hpx-issue:`878` - ``future::unwrap`` triggers assertion
* :hpx-issue:`877` - "make tests" has build errors on Ubuntu 12.10
* :hpx-issue:`876` - tcmalloc is used by default, even if it is not present
* :hpx-issue:`875` - global_fixture is defined in a header file
* :hpx-issue:`874` - Some tests take very long
* :hpx-issue:`873` - Add block-matrix code as regression test
* :hpx-issue:`872` - HPX documentation does not say how to run tests with
  detailed output
* :hpx-issue:`871` - All tests fail with "make test"
* :hpx-issue:`870` - Please explicitly disable serialization in classes that
  don't support it
* :hpx-issue:`868` - boost_any test failing
* :hpx-issue:`867` - Reduce the number of copies of ``hpx::function`` arguments
* :hpx-issue:`863` - Futures should not require a default constructor
* :hpx-issue:`862` - value_or_error shall not default construct its result
* :hpx-issue:`861` - ``HPX_UNUSED`` macro
* :hpx-issue:`860` - Add functionality to copy construct a component
* :hpx-issue:`859` - ``hpx::endl`` should flush
* :hpx-issue:`858` - Create ``hpx::get_ptr<>`` allowing to access component
  implementation
* :hpx-issue:`855` - Implement ``hpx::INVOKE``
* :hpx-issue:`854` - ``hpx/hpx.hpp`` does not include
  ``hpx/include/iostreams.hpp``
* :hpx-issue:`853` - Feature request: null future
* :hpx-issue:`852` - Feature request: Locality names
* :hpx-issue:`851` - ``hpx::cout`` output does not appear on screen
* :hpx-issue:`849` - All tests fail on OS X after installing
* :hpx-issue:`848` - Update OS X build instructions
* :hpx-issue:`846` - Update hpx_external_example
* :hpx-issue:`845` - Issues with having both debug and release modules in the
  same directory
* :hpx-issue:`844` - Create configuration header
* :hpx-issue:`843` - Tests should use CTest
* :hpx-issue:`842` - Remove buffer_pool from MPI parcelport
* :hpx-issue:`841` - Add possibility to broadcast an index with
  hpx::lcos::broadcast
* :hpx-issue:`838` - Simplify ``util::tuple``
* :hpx-issue:`837` - Adopt boost::tuple tests for ``util::tuple``
* :hpx-issue:`836` - Adopt boost::function tests for ``util::function``
* :hpx-issue:`835` - Tuple interface missing pieces
* :hpx-issue:`833` - Partially preprocessing files not working
* :hpx-issue:`832` - Native papi counters do not work with wild cards
* :hpx-issue:`831` - Arithmetics counter fails if only one parameter is given
* :hpx-issue:`830` - Convert hpx::util::function to use new scheme for
  serializing its base pointer
* :hpx-issue:`829` - Consistently use ``decay<T>`` instead of ``remove_const<
  remove_reference<T>>``
* :hpx-issue:`828` - Update future implementation to N3721 and N3722
* :hpx-issue:`827` - Enable MPI parcelport for bootstrapping whenever
  application was started using mpirun
* :hpx-issue:`826` - Support command line option ``--hpx:print-bind`` even if
  ``--hpx::bind`` was not used
* :hpx-issue:`825` - Memory counters give segfault when attempting to use thread
  wild cards or numbers only total works
* :hpx-issue:`824` - Enable lambda functions to be used with
  hpx::async/hpx::apply
* :hpx-issue:`823` - Using a hashing filter
* :hpx-issue:`822` - Silence unused variable warning
* :hpx-issue:`821` - Detect if a function object is callable with given
  arguments
* :hpx-issue:`820` - Allow wildcards to be used for performance counter names
* :hpx-issue:`819` - Make the AGAS symbolic name registry distributed
* :hpx-issue:`818` - Add future::then() overload taking an executor
* :hpx-issue:`817` - Fixed typo
* :hpx-issue:`815` - Create an lco that is performing an efficient broadcast of
  actions
* :hpx-issue:`814` - Papi counters cannot specify thread#* to get the counts for
  all threads
* :hpx-issue:`813` - Scoped unlock
* :hpx-issue:`811` - simple_central_tuplespace_client run error
* :hpx-issue:`810` - ostream error when << any objects
* :hpx-issue:`809` - Optimize parcel serialization
* :hpx-issue:`808` - HPX applications throw exception when executed from the
  build directory
* :hpx-issue:`807` - Create performance counters exposing overall AGAS
  statistics
* :hpx-issue:`795` - Create timed make_ready_future
* :hpx-issue:`794` - Create heterogeneous ``when_all``/``when_any``/etc.
* :hpx-issue:`721` - Make HPX usable for Xeon Phi
* :hpx-issue:`694` - CMake should complain if you attempt to build an example
  without its dependencies
* :hpx-issue:`692` - SLURM support broken
* :hpx-issue:`683` - python/hpx/process.py imports epoll on all platforms
* :hpx-issue:`619` - Automate the doc building process
* :hpx-issue:`600` - GTC performance broken
* :hpx-issue:`577` - Allow for zero copy serialization/networking
* :hpx-issue:`551` - Change executable names to have debug postfix in Debug
  builds
* :hpx-issue:`544` - Write a custom .lib file on Windows pulling in hpx_init and
  hpx.dll, phase out hpx_init
* :hpx-issue:`534` - ``hpx::init`` should take functions by ``std::function``
  and should accept all forms of hpx_main
* :hpx-issue:`508` - FindPackage fails to set FOO_LIBRARY_DIR
* :hpx-issue:`506` - Add cmake support to generate ini files for external
  applications
* :hpx-issue:`470` - Changing build-type after configure does not update boost
  library names
* :hpx-issue:`453` - Document ``hpx_run_tests.py``
* :hpx-issue:`445` - Significant performance mismatch between MPI and HPX in SMP
  for allgather example
* :hpx-issue:`443` - Make docs viewable from build directory
* :hpx-issue:`421` - Support multiple HPX instances per node in a batch
  environment like PBS or SLURM
* :hpx-issue:`316` - Add message size limitation
* :hpx-issue:`249` - Clean up locking code in big boot barrier
* :hpx-issue:`136` - Persistent CMake variables need to be marked as cache
  variables

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. include:: <isonum.txt>

.. _hpx_0_9_8:

===========================
|hpx| V0.9.8 (Mar 24, 2014)
===========================

We have had over 800 commits since the last release and we have closed over 65
tickets (bugs, feature requests, etc.).

With the changes below, |hpx| is once again leading the charge of a whole new
era of computation. By intrinsically breaking down and synchronizing the work to
be done, |hpx| insures that application developers will no longer have to fret
about where a segment of code executes. That allows coders to focus their time
and energy to understanding the data dependencies of their algorithms and
thereby the core obstacles to an efficient code. Here are some of the advantages
of using |hpx|:

* |hpx| is solidly rooted in a sophisticated theoretical execution model --
  ParalleX
* |hpx| exposes an API fully conforming to the C++11 and the draft C++14
  standards, extended and applied to distributed computing. Everything
  programmers know about the concurrency primitives of the standard C++ library
  is still valid in the context of |hpx|.
* It provides a competitive, high performance implementation of modern,
  future-proof ideas which gives an smooth migration path from today's
  mainstream techniques
* There is no need for the programmer to worry about lower level parallelization
  paradigms like threads or message passing; no need to understand pthreads,
  MPI, OpenMP, or Windows threads, etc.
* There is no need to think about different types of parallelism such as tasks,
  pipelines, or fork-join, task or data parallelism.
* The same source of your program compiles and runs on Linux, BlueGene/Q, Mac OS
  X, Windows, and Android.
* The same code runs on shared memory multi-core systems and supercomputers, on
  handheld devices and Intel\ |reg| Xeon Phi\ |trade| accelerators, or a
  heterogeneous mix of those.

General changes
===============

* A major API breaking change for this release was introduced by implementing
  ``hpx::future`` and ``hpx::shared_future`` fully in conformance with the
  |cpp11|_. While ``hpx::shared_future`` is new and will not create any
  compatibility problems, we revised the interface and implementation of the
  existing ``hpx::future``. For more details please see the `mailing list
  archive
  <http://mail.cct.lsu.edu/pipermail/hpx-users/2014-January/000141.html>`_. To
  avoid any incompatibilities for existing code we named the type which
  implements the ``std::future`` interface as ``hpx::unique_future``. For the
  next release this will be renamed to ``hpx::future``, making it full
  conforming to |cpp11|_.
* A large part of the code base of |hpx| has been refactored and partially
  re-implemented. The main changes were related to

  * The threading subsystem: these changes significantly reduce the amount of
    overheads caused by the schedulers, improve the modularity of the code
    base, and extend the variety of available scheduling algorithms.
  * The parcel subsystem: these changes improve the performance of the |hpx|
    networking layer, modularize the structure of the parcelports, and
    simplify the creation of new parcelports for other underlying networking
    libraries.
  * The API subsystem: these changes improved the conformance of the API to
    |cpp11|, extend and unify the available API functionality, and decrease
    the overheads created by various elements of the API.
  * The robustness of the component loading subsystem has been improved
    significantly, allowing to more portably and more reliably register the
    components needed by an application as startup. This additionally speeds up
    general application initialization.
* We added new API functionality like ``hpx::migrate`` and ``hpx::copy_component``
  which are the basic building blocks necessary for implementing higher level
  abstractions for system-wide load balancing, runtime-adaptive resource
  management, and object-oriented checkpointing and state-management.
* We removed the use of C++11 move emulation (using Boost.Move), replacing it
  with C++11 rvalue references. This is the first step towards using more and
  more native C++11 facilities which we plan to introduce in the future.
* We improved the reference counting scheme used by |hpx| which helps
  managing distributed objects and memory. This improves the overall stability
  of |hpx| and further simplifies writing real world applications.
* The minimal Boost version required to use |hpx| is now V1.49.0.
* This release coincides with the first release of |hpxpi| (V0.1.0), the
  first implementation of the |xpi_spec|_.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-issue:`1086` - Expose internal boost::shared_array to allow user
  management of array lifetime
* :hpx-issue:`1083` - Make shell examples copyable in docs
* :hpx-issue:`1080` - /threads{locality#*/total}/count/cumulative broken
* :hpx-issue:`1079` - Build problems on OS X
* :hpx-issue:`1078` - Improve robustness of component loading
* :hpx-issue:`1077` - Fix a missing enum definition for 'take' mode
* :hpx-issue:`1076` - Merge Jb master
* :hpx-issue:`1075` - Unknown CMake command "add_hpx_pseudo_target"
* :hpx-issue:`1074` - Implement ``apply_continue_callback`` and
  ``apply_colocated_callback``
* :hpx-issue:`1073` - The new ``apply_colocated`` and ``async_colocated``
  functions lead to automatic registered functions
* :hpx-issue:`1071` - Remove deferred_packaged_task
* :hpx-issue:`1069` - serialize_buffer with allocator fails at destruction
* :hpx-issue:`1068` - Coroutine include and forward declarations missing
* :hpx-issue:`1067` - Add allocator support to util::serialize_buffer
* :hpx-issue:`1066` - Allow for MPI_Init being called before HPX launches
* :hpx-issue:`1065` - AGAS cache isn't used/populated on worker localities
* :hpx-issue:`1064` - Reorder includes to ensure ws2 includes early
* :hpx-issue:`1063` - Add ``hpx::runtime::suspend`` and ``hpx::runtime::resume``
* :hpx-issue:`1062` - Fix ``async_continue`` to properly handle return types
* :hpx-issue:`1061` - Implement ``async_colocated`` and ``apply_colocated``
* :hpx-issue:`1060` - Implement minimal component migration
* :hpx-issue:`1058` - Remove ``HPX_UTIL_TUPLE`` from code base
* :hpx-issue:`1057` - Add performance counters for threading subsystem
* :hpx-issue:`1055` - Thread allocation uses two memory pools
* :hpx-issue:`1053` - Work stealing flawed
* :hpx-issue:`1052` - Fix a number of warnings
* :hpx-issue:`1049` - Fixes for TLS on OSX and more reliable test running
* :hpx-issue:`1048` - Fixing after 588 hang
* :hpx-issue:`1047` - Use port '0' for networking when using one locality
* :hpx-issue:`1046` - ``composable_guard`` test is broken when having more than
  one thread
* :hpx-issue:`1045` - Security missing headers
* :hpx-issue:`1044` - Native TLS on FreeBSD via __thread
* :hpx-issue:`1043` - ``async`` et.al. compute the wrong result type
* :hpx-issue:`1042` - ``async`` et.al. implicitly unwrap reference_wrappers
* :hpx-issue:`1041` - Remove redundant costly Kleene stars from regex searches
* :hpx-issue:`1040` - CMake script regex match patterns has unnecessary kleenes
* :hpx-issue:`1039` - Remove use of Boost.Move and replace with std::move and
  real rvalue refs
* :hpx-issue:`1038` - Bump minimal required Boost to 1.49.0
* :hpx-issue:`1037` - Implicit unwrapping of futures in async broken
* :hpx-issue:`1036` - Scheduler hangs when user code attempts to "block"
  OS-threads
* :hpx-issue:`1035` - Idle-rate counter always reports 100% idle rate
* :hpx-issue:`1034` - Symbolic name registration causes application hangs
* :hpx-issue:`1033` - Application options read in from an options file generate
  an error message
* :hpx-issue:`1032` - ``hpx::id_type`` local reference counting is wrong
* :hpx-issue:`1031` - Negative entry in reference count table
* :hpx-issue:`1030` - Implement condition_variable
* :hpx-issue:`1029` - Deadlock in thread scheduling subsystem
* :hpx-issue:`1028` - HPX-thread cumulative count performance counters report
  incorrect value
* :hpx-issue:`1027` - Expose ``hpx::thread_interrupted`` error code as a
  separate exception type
* :hpx-issue:`1026` - Exceptions thrown in asynchronous calls can be lost if the
  value of the future is never queried
* :hpx-issue:`1025` - ``future::wait_for``/``wait_until`` do not remove callback
* :hpx-issue:`1024` - Remove dependence to boost assert and create hpx assert
* :hpx-issue:`1023` - Segfaults with tcmalloc
* :hpx-issue:`1022` - prerequisites link in readme is broken
* :hpx-issue:`1020` - HPX Deadlock on external synchronization
* :hpx-issue:`1019` - Convert using ``BOOST_ASSERT`` to ``HPX_ASSERT``
* :hpx-issue:`1018` - compiling bug with gcc 4.8.1
* :hpx-issue:`1017` - Possible crash in io_pool executor
* :hpx-issue:`1016` - Crash at startup
* :hpx-issue:`1014` - Implement Increment/Decrement Merging
* :hpx-issue:`1013` - Add more logging channels to enable greater control over
  logging granularity
* :hpx-issue:`1012` - ``--hpx:debug-hpx-log`` and ``--hpx:debug-agas-log`` lead
  to non-thread safe writes
* :hpx-issue:`1011` - After installation, running applications from the
  build/staging directory no longer works
* :hpx-issue:`1010` - Mergeable decrement requests are not being merged
* :hpx-issue:`1009` - ``--hpx:list-symbolic-names`` crashes
* :hpx-issue:`1007` - Components are not properly destroyed
* :hpx-issue:`1006` - Segfault/hang in set_data
* :hpx-issue:`1003` - Performance counter naming issue
* :hpx-issue:`982` - Race condition during startup
* :hpx-issue:`912` - OS X: component type not found in map
* :hpx-issue:`663` - Create a buildbot slave based on Clang 3.2/OSX
* :hpx-issue:`636` - Expose ``this_locality::apply<act>(p1, p2);`` for local
  execution
* :hpx-issue:`197` - Add ``--console=address`` option for PBS runs
* :hpx-issue:`175` - Asynchronous AGAS API

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_11:

============================
|hpx| V0.9.11 (Nov 11, 2015)
============================

Our main focus for this release was the design and development of a coherent set
of higher-level APIs exposing various types of parallelism to the application
programmer. We introduced the concepts of an ``executor``, which can be used to
customize the ``where`` and ``when`` of execution of tasks in the context of
parallelizing codes. We extended all APIs related to managing parallel tasks to
support executors which gives the user the choce of either using one of the
predefined executor types or to provide its own, possibly application specific,
executor. We paid very close attention to align all of these changes with the
existing C++ Standards documents or with the ongoing proposals for
standardization.

This release is the first after our change to a new development policy. We
switched all development to be strictly performed on branches only, all direct
commits to our main branch (``master``) are prohibited. Any change has to go
through a peer review before it will be merged to ``master``. As a result the
overall stability of our code base has significantly increased, the development
process itself has been simplified. This change manifests itself in a large
number of pull-requests which have been merged (please see below for a full list
of closed issues and pull-requests). All in all for this release, we closed
almost 100 issues and merged over 290 pull-requests. There have been over 1600
commits to the master branch since the last release.

General changes
===============

* We are moving into the direction of unifying managed and simple components. As
  such, the classes :cpp:class:`hpx::components::component` and
  :cpp:class:`hpx::components::component_base` have been added which currently
  just forward to the currently existing simple component facilities. The
  examples have been converted to only use those two classes.
* Added integration with the `CircleCI
  <https://circleci.com/gh/STEllAR-GROUP/hpx>`__ hosted continuous integration
  service. This gives us constant and immediate feedback on the health of our
  master branch.
* The compiler configuration subsystem in the build system has been
  reimplemented. Instead of using Boost.Config we now use our own lightweight
  set of cmake scripts to determine the available language and library features
  supported by the used compiler.
* The API for creating instances of components has been consolidated. All
  component instances should be created using the :cpp:func:`hpx::new_` only. It
  allows one to instantiate both, single component instances and multiple
  component instances. The placement of the created components can be controlled
  by special distribution policies. Please see the corresponding documentation
  outlining the use of :cpp:func:`hpx::new_`.
* Introduced four new distribution policies which can be used with many API
  functions which traditionally expected to be used with a locality id. The new
  distribution policies are:

  * :cpp:class:`hpx::components::default_distribution_policy` which tries to
    place multiple component instances as evenly as possible.
  * :cpp:class:`hpx::components::colocating_distribution_policy` which will
    refer to the locality where a given component instance is currently placed.
  * :cpp:class:`hpx::components::binpacking_distribution_policy` which will
    place multiple component instances as evenly as possible based on any
    performance counter.
  * :cpp:class:`hpx::components::target_distribution_policy` which allows one to
    represent a given locality in the context of a distrwibution policy.
* The new distribution policies can now be also used with ``hpx::async``. This
  change also deprecates ``hpx::async_colocated(id, ...)`` which now is replaced
  by a distribution policy: ``hpx::async(hpx::colocated(id), ...)``.
* The ``hpx::vector`` and ``hpx::unordered_map`` data structures can now be used
  with the new distribution policies as well.
* The parallel facility ``hpx::parallel::task_region`` has been renamed to
  :cpp:class:`hpx::parallel::task_block` based on the changes in the
  corresponding standardization proposal |cpp11_n4088|_.
* Added extensions to the parallel facility
  :cpp:class:`hpx::parallel::task_block` allowing to combine a task_block with
  an execution policy. This implies a minor breaking change as the
  ``hpx::parallel::task_block`` is now a template.
* Added new LCOs: ``hpx::lcos::latch`` and ``hpx::lcos::local::latch`` which
  semantically conform to the proposed ``std::latch`` (see |cpp17_n4399|_).
* Added performance counters exposing data related to data transferred by
  input/output (filesystem) operations (thanks to Maciej Brodowicz).
* Added performance counters allowing to track the number of action invocations
  (local and remote invocations).
* Added new command line options `--hpx:print-counter-at <commandline>`_ and
  `--hpx:reset-counters <commandline>`_.
* The ``hpx::vector`` component has been renamed to ``hpx::partitioned_vector``
  to make it explicit that the underlying memory is not contiguous.
* Introduced a completely new and uniform higher-level parallelism API which is
  based on executors. All existing parallelism APIs have been adapted to this.
  We have added a large number of different executor types, such as a numa-aware
  executor, a this-thread executor, etc.
* Added support for the MingW toolchain on Windows (thanks to Eric Lemanissier).
* HPX now includes support for APEX, (Autonomic Performance Environment for
  eXascale). APEX is an instrumentation and software adaptation library that
  provides an interface to TAU profiling / tracing as well as runtime adaptation
  of HPX applications through policy definitions. For more information and
  documentation, please see `<https://github.com/UO-OACISS/xpress-apex>`_. To
  enable APEX at configuration time, specify ``-DHPX_WITH_APEX=On``. To also
  include support for TAU profiling, specify ``-DHPX_WITH_TAU=On`` and specify
  the ``-DTAU_ROOT``, ``-DTAU_ARCH`` and ``-DTAU_OPTIONS`` cmake parameters.
* We have implemented many more of the :ref:`parallel_algorithms`. Please see
  :hpx-issue:`1141` for the list of all available parallel algorithms (thanks to
  Daniel Bourgeois and John Biddiscombe for contributing their work).

Breaking changes
================

* We are moving into the direction of unifying managed and simple components. In
  order to stop exposing the old facilities, all examples have been converted to
  use the new classes. The breaking change in this release is that performance
  counters are now a :cpp:class:`hpx::components::component_base` instead of
  :cpp:class:`hpx::components::managed_component_base`.
* We removed the support for stackless threads. It turned out that there was no
  performance benefit when using stackless threads. As such, we decided to clean
  up our codebase. This feature was not documented.
* The CMake project name has changed from 'hpx' to 'HPX' for consistency and
  compatibility with naming conventions and other CMake projects. Generated
  config files go into <prefix>/lib/cmake/HPX and not <prefix>/lib/cmake/hpx.
* The macro ``HPX_REGISTER_MINIMAL_COMPONENT_FACTORY`` has been deprecated.
  Please use :c:macro:`HPX_REGISTER_COMPONENT`.
  instead. The old macro will be removed in the next release.
* The obsolete distributing_factory and binpacking_factory components have been
  removed. The corresponding functionality is now provided by the
  :cpp:func:`hpx::new_()` API function in conjunction with the
  ``hpx::default_layout`` and ``hpx::binpacking`` distribution policies
  (:cpp:class:`hpx::components::default_distribution_policy` and
  :cpp:class:`hpx::components::binpacking_distribution_policy`)
* The API function ``hpx::new_colocated`` has been deprecated. Please use the
  consolidated API :cpp:func:`hpx::new_` in conjunction with the new
  ``hpx::colocated`` distribution policy
  (:cpp:class:`hpx::components::colocating_distribution_policy`) instead. The
  old API function will still be available for at least one release of |hpx| if
  the configuration variable ``HPX_WITH_COLOCATED_BACKWARDS_COMPATIBILITY`` is
  enabled.
* The API function ``hpx::async_colocated`` has been deprecated. Please use the
  consolidated API ``hpx::async`` in conjunction with the new ``hpx::colocated``
  distribution policy
  (:cpp:class:`hpx::components::colocating_distribution_policy`) instead. The
  old API function will still be available for at least one release of |hpx| if
  the configuration variable ``HPX_WITH_COLOCATED_BACKWARDS_COMPATIBILITY`` is
  enabled.
* The obsolete remote_object component has been removed.
* Replaced the use of Boost.Serialization with our own solution. While the new
  version is mostly compatible with Boost.Serialization, this change requires
  some minor code modifications in user code. For more information, please see
  the corresponding `announcement
  <http://thread.gmane.org/gmane.comp.lib.hpx.devel/196>`_ on the
  |stellar_list|_ mailing list.
* The names used by cmake to influence various configuration options have been
  unified. The new naming scheme relies on all configuration constants to start
  with ``HPX_WITH_...``, while the preprocessor constant which is used at build
  time starts with ``HPX_HAVE_...``. For instance, the former cmake command line
  ``-DHPX_MALLOC=...`` now has to be specified a ``-DHPX_WITH_MALLOC=...`` and
  will cause the preprocessor constant ``HPX_HAVE_MALLOC`` to be defined. The
  actual name of the constant (i.e. ``MALLOC``) has not changed. Please see the
  corresponding documentation for more details (:ref:`cmake_variables`).
* The ``get_gid()`` functions exposed by the component base classes
  ``hpx::components::server::simple_component_base``,
  ``hpx::components::server::managed_component_base``, and
  ``hpx::components::server::fixed_component_base`` have been replaced by two
  new functions: ``get_unmanaged_id()`` and ``get_id()``. To enable the old
  function name for backwards compatibility, use the cmake configuration option
  ``HPX_WITH_COMPONENT_GET_GID_COMPATIBILITY=On``.
* All functions which were named ``get_gid()`` but were returning
  ``hpx::id_type`` have been renamed to ``get_id()``. To enable the old function
  names for backwards compatibility, use the cmake configuration option
  ``HPX_WITH_COMPONENT_GET_GID_COMPATIBILITY=On``.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-pr:`1855` - Completely removing external/endian
* :hpx-pr:`1854` - Don't pollute CMAKE_CXX_FLAGS through find_package()
* :hpx-pr:`1853` - Updating CMake configuration to get correct version of TAU
  library
* :hpx-pr:`1852` - Fixing Performance Problems with MPI Parcelport
* :hpx-pr:`1851` - Fixing hpx_add_link_flag() and hpx_remove_link_flag()
* :hpx-pr:`1850` - Fixing 1836, adding parallel::sort
* :hpx-pr:`1849` - Fixing configuration for use of more than 64 cores
* :hpx-pr:`1848` - Change default APEX version for release
* :hpx-pr:`1847` - Fix client_base::then on release
* :hpx-pr:`1846` - Removing broken lcos::local::channel from release
* :hpx-pr:`1845` - Adding example demonstrating a possible safe-object
  implementation to release
* :hpx-pr:`1844` - Removing stubs from accumulator examples
* :hpx-pr:`1843` - Don't pollute CMAKE_CXX_FLAGS through find_package()
* :hpx-pr:`1841` - Fixing client_base<>::then
* :hpx-pr:`1840` - Adding example demonstrating a possible safe-object
  implementation
* :hpx-pr:`1838` - Update version rc1
* :hpx-pr:`1837` - Removing broken lcos::local::channel
* :hpx-pr:`1835` - Adding explicit move constructor and assignment operator to
  hpx::lcos::promise
* :hpx-pr:`1834` - Making hpx::lcos::promise move-only
* :hpx-pr:`1833` - Adding fedora docs
* :hpx-issue:`1832` - hpx::lcos::promise<> must be move-only
* :hpx-pr:`1831` - Fixing resource manager gcc5.2
* :hpx-pr:`1830` - Fix intel13
* :hpx-pr:`1829` - Unbreaking thread test
* :hpx-pr:`1828` - Fixing #1620
* :hpx-pr:`1827` - Fixing a memory management issue for the Parquet application
* :hpx-issue:`1826` - Memory management issue in hpx::lcos::promise
* :hpx-pr:`1825` - Adding hpx::components::component and
  hpx::components::component_base
* :hpx-pr:`1823` - Adding git commit id to circleci build
* :hpx-pr:`1822` - applying fixes suggested by clang 3.7
* :hpx-pr:`1821` - Hyperlink fixes
* :hpx-pr:`1820` - added parallel multi-locality sanity test
* :hpx-pr:`1819` - Fixing #1667
* :hpx-issue:`1817` - Hyperlinks generated by inspect tool are wrong
* :hpx-pr:`1816` - Support hpxrx
* :hpx-pr:`1814` - Fix async to dispatch to the correct locality in all cases
* :hpx-issue:`1813` - async(launch::..., action(), ...) always invokes locally
* :hpx-pr:`1812` - fixed syntax error in CMakeLists.txt
* :hpx-pr:`1811` - Agas optimizations
* :hpx-pr:`1810` - drop superfluous typedefs
* :hpx-pr:`1809` - Allow HPX to be used as an optional package in 3rd party code
* :hpx-pr:`1808` - Fixing #1723
* :hpx-pr:`1807` - Making sure resolve_localities does not hang during normal
  operation
* :hpx-issue:`1806` - Spinlock no longer movable and deletes operator '=',
  breaks MiniGhost
* :hpx-issue:`1804` - register_with_basename causes hangs
* :hpx-pr:`1801` - Enhanced the inspect tool to take user directly to the
  problem with hyperlinks
* :hpx-issue:`1800` - Problems compiling application on smic
* :hpx-pr:`1799` - Fixing cv exceptions
* :hpx-pr:`1798` - Documentation refactoring & updating
* :hpx-pr:`1797` - Updating the activeharmony CMake module
* :hpx-pr:`1795` - Fixing cv
* :hpx-pr:`1794` - Fix connect with hpx::runtime_mode_connect
* :hpx-pr:`1793` - fix a wrong use of HPX_MAX_CPU_COUNT instead of
  HPX_HAVE_MAX_CPU_COUNT
* :hpx-pr:`1792` - Allow for default constructed parcel instances to be moved
* :hpx-pr:`1791` - Fix connect with hpx::runtime_mode_connect
* :hpx-issue:`1790` - assertion ``action_.get()`` failed: HPX(assertion_failure)
  when running Octotiger with pull request 1786
* :hpx-pr:`1789` - Fixing discover_counter_types API function
* :hpx-issue:`1788` - connect with hpx::runtime_mode_connect
* :hpx-issue:`1787` - discover_counter_types not working
* :hpx-pr:`1786` - Changing addressing_service to use std::unordered_map instead
  of std::map
* :hpx-pr:`1785` - Fix is_iterator for container algorithms
* :hpx-pr:`1784` - Adding new command line options:
* :hpx-pr:`1783` - Minor changes for APEX support
* :hpx-pr:`1782` - Drop legacy forwarding action traits
* :hpx-pr:`1781` - Attempt to resolve the race between cv::wait_xxx and
  cv::notify_all
* :hpx-pr:`1780` - Removing serialize_sequence
* :hpx-pr:`1779` - Fixed #1501: hwloc configuration options are wrong for MIC
* :hpx-pr:`1778` - Removing ability to enable/disable parcel handling
* :hpx-pr:`1777` - Completely removing stackless threads
* :hpx-pr:`1776` - Cleaning up util/plugin
* :hpx-pr:`1775` - Agas fixes
* :hpx-pr:`1774` - Action invocation count
* :hpx-pr:`1773` - replaced MSVC variable with WIN32
* :hpx-pr:`1772` - Fixing Problems in MPI parcelport and future serialization.
* :hpx-pr:`1771` - Fixing intel 13 compiler errors related to variadic template
  template parameters for ``lcos::when_`` tests
* :hpx-pr:`1770` - Forwarding decay to ``std::``
* :hpx-pr:`1769` - Add more characters with special regex meaning to the
  existing patch
* :hpx-pr:`1768` - Adding test for receive_buffer
* :hpx-pr:`1767` - Making sure that uptime counter throws exception on any
  attempt to be reset
* :hpx-pr:`1766` - Cleaning up code related to throttling scheduler
* :hpx-pr:`1765` - Restricting thread_data to creating only with
  intrusive_pointers
* :hpx-pr:`1764` - Fixing 1763
* :hpx-issue:`1763` - UB in thread_data::operator delete
* :hpx-pr:`1762` - Making sure all serialization registries/factories are unique
* :hpx-pr:`1761` - Fixed #1751: hpx::future::wait_for fails a simple test
* :hpx-pr:`1758` - Fixing #1757
* :hpx-issue:`1757` - pinning not correct using --hpx:bind
* :hpx-issue:`1756` - compilation error with MinGW
* :hpx-pr:`1755` - Making output serialization const-correct
* :hpx-issue:`1753` - HPX performance degrades with time since execution begins
* :hpx-issue:`1752` - Error in AGAS
* :hpx-issue:`1751` - hpx::future::wait_for fails a simple test
* :hpx-pr:`1750` - Removing hpx_fwd.hpp includes
* :hpx-pr:`1749` - Simplify result_of and friends
* :hpx-pr:`1747` - Removed superfluous code from message_buffer.hpp
* :hpx-pr:`1746` - Tuple dependencies
* :hpx-issue:`1745` - Broken when_some which takes iterators
* :hpx-pr:`1744` - Refining archive interface
* :hpx-pr:`1743` - Fixing when_all when only a single future is passed
* :hpx-pr:`1742` - Config includes
* :hpx-pr:`1741` - Os executors
* :hpx-issue:`1740` - hpx::promise has some problems
* :hpx-pr:`1739` - Parallel composition with generic containers
* :hpx-issue:`1738` - After building program and successfully linking to a
  version of hpx DHPX_DIR seems to be ignored
* :hpx-issue:`1737` - Uptime problems
* :hpx-pr:`1736` - added convenience c-tor and begin()/end() to serialize_buffer
* :hpx-pr:`1735` - Config includes
* :hpx-pr:`1734` - Fixed #1688: Add timer counters for tfunc_total and
  exec_total
* :hpx-issue:`1733` - Add unit test for hpx/lcos/local/receive_buffer.hpp
* :hpx-pr:`1732` - Renaming get_os_thread_count
* :hpx-pr:`1731` - Basename registration
* :hpx-issue:`1730` - Use after move of thread_init_data
* :hpx-pr:`1729` - Rewriting channel based on new gate component
* :hpx-pr:`1728` - Fixing #1722
* :hpx-pr:`1727` - Fixing compile problems with apply_colocated
* :hpx-pr:`1726` - Apex integration
* :hpx-pr:`1725` - fixed test timeouts
* :hpx-pr:`1724` - Renaming vector
* :hpx-issue:`1723` - Drop support for intel compilers and gcc 4.4. based
  standard libs
* :hpx-issue:`1722` - Add support for detecting non-ready futures before
  serialization
* :hpx-pr:`1721` - Unifying parallel executors, initializing from launch policy
* :hpx-pr:`1720` - dropped superfluous typedef
* :hpx-issue:`1718` - Windows 10 x64, VS 2015 - Unknown CMake command
  "add_hpx_pseudo_target".
* :hpx-pr:`1717` - Timed executor traits for thread-executors
* :hpx-pr:`1716` - serialization of arrays didn't work with non-pod types. fixed
* :hpx-pr:`1715` - List serialization
* :hpx-pr:`1714` - changing misspellings
* :hpx-pr:`1713` - Fixed distribution policy executors
* :hpx-pr:`1712` - Moving library detection to be executed after feature tests
* :hpx-pr:`1711` - Simplify parcel
* :hpx-pr:`1710` - Compile only tests
* :hpx-pr:`1709` - Implemented timed executors
* :hpx-pr:`1708` - Implement parallel::executor_traits for thread-executors
* :hpx-pr:`1707` - Various fixes to threads::executors to make custom schedulers
  work
* :hpx-pr:`1706` - Command line option --hpx:cores does not work as expected
* :hpx-issue:`1705` - command line option --hpx:cores does not work as expected
* :hpx-pr:`1704` - vector deserialization is speeded up a little
* :hpx-pr:`1703` - Fixing shared_mutes
* :hpx-issue:`1702` - Shared_mutex does not compile with no_mutex cond_var
* :hpx-pr:`1701` - Add distribution_policy_executor
* :hpx-pr:`1700` - Executor parameters
* :hpx-pr:`1699` - Readers writer lock
* :hpx-pr:`1698` - Remove leftovers
* :hpx-pr:`1697` - Fixing held locks
* :hpx-pr:`1696` - Modified Scan Partitioner for Algorithms
* :hpx-pr:`1695` - This thread executors
* :hpx-pr:`1694` - Fixed #1688: Add timer counters for tfunc_total and
  exec_total
* :hpx-pr:`1693` - Fix #1691: is_executor template specification fails for
  inherited executors
* :hpx-pr:`1692` - Fixed #1662: Possible exception source in
  coalescing_message_handler
* :hpx-issue:`1691` - is_executor template specification fails for inherited
  executors
* :hpx-pr:`1690` - added macro for non-intrusive serialization of classes
  without a default c-tor
* :hpx-pr:`1689` - Replace value_or_error with custom storage, unify future_data
  state
* :hpx-issue:`1688` - Add timer counters for tfunc_total and exec_total
* :hpx-pr:`1687` - Fixed interval timer
* :hpx-pr:`1686` - Fixing cmake warnings about not existing pseudo target
  dependencies
* :hpx-pr:`1685` - Converting partitioners to use bulk async execute
* :hpx-pr:`1683` - Adds a tool for inspect that checks for character limits
* :hpx-pr:`1682` - Change project name to (uppercase) HPX
* :hpx-pr:`1681` - Counter shortnames
* :hpx-pr:`1680` - Extended Non-intrusive Serialization to Ease Usage for
  Library Developers
* :hpx-pr:`1679` - Working on 1544: More executor changes
* :hpx-pr:`1678` - Transpose fixes
* :hpx-pr:`1677` - Improve Boost compatibility check
* :hpx-pr:`1676` - 1d stencil fix
* :hpx-issue:`1675` - hpx project name is not HPX
* :hpx-pr:`1674` - Fixing the MPI parcelport
* :hpx-pr:`1673` - added move semantics to map/vector deserialization
* :hpx-pr:`1672` - Vs2015 await
* :hpx-pr:`1671` - Adapt transform for #1668
* :hpx-pr:`1670` - Started to work on #1668
* :hpx-pr:`1669` - Add this_thread_executors
* :hpx-issue:`1667` - Apple build instructions in docs are out of date
* :hpx-pr:`1666` - Apex integration
* :hpx-pr:`1665` - Fixes an error with the whitespace check that showed the
  incorrect location of the error
* :hpx-issue:`1664` - Inspect tool found incorrect endline whitespace
* :hpx-pr:`1663` - Improve use of locks
* :hpx-issue:`1662` - Possible exception source in coalescing_message_handler
* :hpx-pr:`1661` - Added support for 128bit number serialization
* :hpx-pr:`1660` - Serialization 128bits
* :hpx-pr:`1659` - Implemented inner_product and adjacent_diff algos
* :hpx-pr:`1658` - Add serialization for std::set (as there is for std::vector
  and std::map)
* :hpx-pr:`1657` - Use of shared_ptr in io_service_pool changed to unique_ptr
* :hpx-issue:`1656` - 1d_stencil codes all have wrong factor
* :hpx-pr:`1654` - When using runtime_mode_connect, find the correct localhost
  public ip address
* :hpx-pr:`1653` - Fixing 1617
* :hpx-pr:`1652` - Remove traits::action_may_require_id_splitting
* :hpx-pr:`1651` - Fixed performance counters related to AGAS cache timings
* :hpx-pr:`1650` - Remove leftovers of traits::type_size
* :hpx-pr:`1649` - Shorten target names on Windows to shorten used path names
* :hpx-pr:`1648` - Fixing problems introduced by merging #1623 for older
  compilers
* :hpx-pr:`1647` - Simplify running automatic builds on Windows
* :hpx-issue:`1646` - Cache insert and update performance counters are broken
* :hpx-issue:`1644` - Remove leftovers of traits::type_size
* :hpx-issue:`1643` - Remove traits::action_may_require_id_splitting
* :hpx-pr:`1642` - Adds spell checker to the inspect tool for qbk and doxygen
  comments
* :hpx-pr:`1640` - First step towards fixing 688
* :hpx-pr:`1639` - Re-apply remaining changes from limit_dataflow_recursion
  branch
* :hpx-pr:`1638` - This fixes possible deadlock in the test
  ignore_while_locked_1485
* :hpx-pr:`1637` - Fixing hpx::wait_all() invoked with two vector<future<T>>
* :hpx-pr:`1636` - Partially re-apply changes from limit_dataflow_recursion
  branch
* :hpx-pr:`1635` - Adding missing test for #1572
* :hpx-pr:`1634` - Revert "Limit recursion-depth in dataflow to a configurable
  constant"
* :hpx-pr:`1633` - Add command line option to ignore batch environment
* :hpx-pr:`1631` - hpx::lcos::queue exhibits strange behavior
* :hpx-pr:`1630` - Fixed endline_whitespace_check.cpp to detect lines with only
  whitespace
* :hpx-issue:`1629` - Inspect trailing whitespace checker problem
* :hpx-pr:`1628` - Removed meaningless const qualifiers. Minor icpc fix.
* :hpx-pr:`1627` - Fixing the queue LCO and add example demonstrating its use
* :hpx-pr:`1626` - Deprecating get_gid(), add get_id() and get_unmanaged_id()
* :hpx-pr:`1625` - Allowing to specify whether to send credits along with
  message
* :hpx-issue:`1624` - Lifetime issue
* :hpx-issue:`1623` - hpx::wait_all() invoked with two vector<future<T>> fails
* :hpx-pr:`1622` - Executor partitioners
* :hpx-pr:`1621` - Clean up coroutines implementation
* :hpx-issue:`1620` - Revert #1535
* :hpx-pr:`1619` - Fix result type calculation for hpx::make_continuation
* :hpx-pr:`1618` - Fixing RDTSC on Xeon/Phi
* :hpx-issue:`1617` - hpx cmake not working when run as a subproject
* :hpx-issue:`1616` - cmake problem resulting in RDTSC not working correctly for
  Xeon Phi creates very strange results for duration counters
* :hpx-issue:`1615` - hpx::make_continuation requires input and output to be the
  same
* :hpx-pr:`1614` - Fixed remove copy test
* :hpx-issue:`1613` - Dataflow causes stack overflow
* :hpx-pr:`1612` - Modified foreach partitioner to use bulk execute
* :hpx-pr:`1611` - Limit recursion-depth in dataflow to a configurable constant
* :hpx-pr:`1610` - Increase timeout for CircleCI
* :hpx-pr:`1609` - Refactoring thread manager, mainly extracting thread pool
* :hpx-pr:`1608` - Fixed running multiple localities without localities
  parameter
* :hpx-pr:`1607` - More algorithm fixes to adjacentfind
* :hpx-issue:`1606` - Running without localities parameter binds to bogus port
  range
* :hpx-issue:`1605` - Too many serializations
* :hpx-pr:`1604` - Changes the HPX image into a hyperlink
* :hpx-pr:`1601` - Fixing problems with remove_copy algorithm tests
* :hpx-pr:`1600` - Actions with ids cleanup
* :hpx-pr:`1599` - Duplicate binding of global ids should fail
* :hpx-pr:`1598` - Fixing array access
* :hpx-pr:`1597` - Improved the reliability of connecting/disconnecting
  localities
* :hpx-issue:`1596` - Duplicate id binding should fail
* :hpx-pr:`1595` - Fixing more cmake config constants
* :hpx-pr:`1594` - Fixing preprocessor constant used to enable C++11 chrono
* :hpx-pr:`1593` - Adding operator|() for hpx::launch
* :hpx-issue:`1592` - Error (typo) in the docs
* :hpx-issue:`1590` - CMake fails when CMAKE_BINARY_DIR contains '+'.
* :hpx-issue:`1589` - Disconnecting a locality results in segfault using
  heartbeat example
* :hpx-pr:`1588` - Fix doc string for config option HPX_WITH_EXAMPLES
* :hpx-pr:`1586` - Fixing 1493
* :hpx-pr:`1585` - Additional Check for Inspect Tool to detect Endline
  Whitespace
* :hpx-issue:`1584` - Clean up coroutines implementation
* :hpx-pr:`1583` - Adding a check for end line whitespace
* :hpx-pr:`1582` - Attempt to fix assert firing after scheduling loop was exited
* :hpx-pr:`1581` - Fixed adjacentfind_binary test
* :hpx-pr:`1580` - Prevent some of the internal cmake lists from growing
  indefinitely
* :hpx-pr:`1579` - Removing type_size trait, replacing it with special archive
  type
* :hpx-issue:`1578` - Remove demangle_helper
* :hpx-pr:`1577` - Get ptr problems
* :hpx-issue:`1576` - Refactor async, dataflow, and future::then
* :hpx-pr:`1575` - Fixing tests for parallel rotate
* :hpx-pr:`1574` - Cleaning up schedulers
* :hpx-pr:`1573` - Fixing thread pool executor
* :hpx-pr:`1572` - Fixing number of configured localities
* :hpx-pr:`1571` - Reimplement decay
* :hpx-pr:`1570` - Refactoring async, apply, and dataflow APIs
* :hpx-pr:`1569` - Changed range for mach-o library lookup
* :hpx-pr:`1568` - Mark decltype support as required
* :hpx-pr:`1567` - Removed const from algorithms
* :hpx-issue:`1566` - CMAKE Configuration Test Failures for clang 3.5 on debian
* :hpx-pr:`1565` - Dylib support
* :hpx-pr:`1564` - Converted partitioners and some algorithms to use executors
* :hpx-pr:`1563` - Fix several #includes for Boost.Preprocessor
* :hpx-pr:`1562` - Adding configuration option disabling/enabling all message
  handlers
* :hpx-pr:`1561` - Removed all occurrences of boost::move replacing it with
  std::move
* :hpx-issue:`1560` - Leftover HPX_REGISTER_ACTION_DECLARATION_2
* :hpx-pr:`1558` - Revisit async/apply SFINAE conditions
* :hpx-pr:`1557` - Removing type_size trait, replacing it with special archive
  type
* :hpx-pr:`1556` - Executor algorithms
* :hpx-pr:`1555` - Remove the necessity to specify archive flags on the
  receiving end
* :hpx-pr:`1554` - Removing obsolete Boost.Serialization macros
* :hpx-pr:`1553` - Properly fix HPX_DEFINE_*_ACTION macros
* :hpx-pr:`1552` - Fixed algorithms relying on copy_if implementation
* :hpx-pr:`1551` - Pxfs - Modifying FindOrangeFS.cmake based on OrangeFS 2.9.X
* :hpx-issue:`1550` - Passing plain identifier inside HPX_DEFINE_PLAIN_ACTION_1
* :hpx-pr:`1549` - Fixing intel14/libstdc++4.4
* :hpx-pr:`1548` - Moving raw_ptr to detail namespace
* :hpx-pr:`1547` - Adding support for executors to future.then
* :hpx-pr:`1546` - Executor traits result types
* :hpx-pr:`1545` - Integrate executors with dataflow
* :hpx-pr:`1543` - Fix potential zero-copy for
  primarynamespace::bulk_service_async et.al.
* :hpx-pr:`1542` - Merging HPX0.9.10 into pxfs branch
* :hpx-pr:`1541` - Removed stale cmake tests, unused since the great cmake
  refactoring
* :hpx-pr:`1540` - Fix idle-rate on platforms without TSC
* :hpx-pr:`1539` - Reporting situation if zero-copy-serialization was performed
  by a parcel generated from a plain apply/async
* :hpx-pr:`1538` - Changed return type of bulk executors and added test
* :hpx-issue:`1537` - Incorrect cpuid config tests
* :hpx-pr:`1536` - Changed return type of bulk executors and added test
* :hpx-pr:`1535` - Make sure promise::get_gid() can be called more than once
* :hpx-pr:`1534` - Fixed async_callback with bound callback
* :hpx-pr:`1533` - Updated the link in the documentation to a publically-
  accessible URL
* :hpx-pr:`1532` - Make sure sync primitives are not copyable nor movable
* :hpx-pr:`1531` - Fix unwrapped issue with future ranges of void type
* :hpx-pr:`1530` - Serialization complex
* :hpx-issue:`1528` - Unwrapped issue with future<void>
* :hpx-issue:`1527` - HPX does not build with Boost 1.58.0
* :hpx-pr:`1526` - Added support for boost.multi_array serialization
* :hpx-pr:`1525` - Properly handle deferred futures, fixes #1506
* :hpx-pr:`1524` - Making sure invalid action argument types generate clear
  error message
* :hpx-issue:`1522` - Need serialization support for boost multi array
* :hpx-issue:`1521` - Remote async and zero-copy serialization optimizations
  don't play well together
* :hpx-pr:`1520` - Fixing UB whil registering polymorphic classes for
  serialization
* :hpx-pr:`1519` - Making detail::condition_variable safe to use
* :hpx-pr:`1518` - Fix when_some bug missing indices in its result
* :hpx-issue:`1517` - Typo may affect CMake build system tests
* :hpx-pr:`1516` - Fixing Posix context
* :hpx-pr:`1515` - Fixing Posix context
* :hpx-pr:`1514` - Correct problems with loading dynamic components
* :hpx-pr:`1513` - Fixing intel glibc4 4
* :hpx-issue:`1508` - memory and papi counters do not work
* :hpx-issue:`1507` - Unrecognized Command Line Option Error causing exit status
  0
* :hpx-issue:`1506` - Properly handle deferred futures
* :hpx-pr:`1505` - Adding #include - would not compile without this
* :hpx-issue:`1502` - ``boost::filesystem::exists`` throws unexpected exception
* :hpx-issue:`1501` - hwloc configuration options are wrong for MIC
* :hpx-pr:`1504` - Making sure boost::filesystem::exists() does not throw
* :hpx-pr:`1500` - Exit application on ``--hpx:version``/``-v`` and
  ``--hpx:info``
* :hpx-pr:`1498` - Extended task block
* :hpx-pr:`1497` - Unique ptr serialization
* :hpx-pr:`1496` - Unique ptr serialization (closed)
* :hpx-pr:`1495` - Switching circleci build type to debug
* :hpx-issue:`1494` - ``--hpx:version``/``-v`` does not exit after printing
  version information
* :hpx-issue:`1493` - add an ``hpx_`` prefix to libraries and components to
  avoid name conflicts
* :hpx-issue:`1492` - Define and ensure limitations for arguments to async/apply
* :hpx-pr:`1489` - Enable idle rate counter on demand
* :hpx-pr:`1488` - Made sure ``detail::condition_variable`` can be safely
  destroyed
* :hpx-pr:`1487` - Introduced default (main) template implementation for
  ``ignore_while_checking``
* :hpx-pr:`1486` - Add HPX inspect tool
* :hpx-issue:`1485` - ``ignore_while_locked`` doesn't support all Lockable types
* :hpx-pr:`1484` - Docker image generation
* :hpx-pr:`1483` - Move external endian library into HPX
* :hpx-pr:`1482` - Actions with integer type ids
* :hpx-issue:`1481` - Sync primitives safe destruction
* :hpx-issue:`1480` - Move external/boost/endian into hpx/util
* :hpx-issue:`1478` - Boost inspect violations
* :hpx-pr:`1479` - Adds serialization for arrays; some further/minor fixes
* :hpx-pr:`1477` - Fixing problems with the Intel compiler using a GCC 4.4 std
  library
* :hpx-pr:`1476` - Adding ``hpx::lcos::latch`` and ``hpx::lcos::local::latch``
* :hpx-issue:`1475` - Boost inspect violations
* :hpx-pr:`1473` - Fixing action move tests
* :hpx-issue:`1471` - Sync primitives should not be movable
* :hpx-pr:`1470` - Removing ``hpx::util::polymorphic_factory``
* :hpx-pr:`1468` - Fixed container creation
* :hpx-issue:`1467` - HPX application fail during finalization
* :hpx-issue:`1466` - HPX doesn't pick up Torque's nodefile on SuperMIC
* :hpx-issue:`1464` - HPX option for pre and post bootstrap performance counters
* :hpx-pr:`1463` - Replacing ``async_colocated(id, ...)`` with
  ``async(colocated(id), ...)``
* :hpx-pr:`1462` - Consolidated task_region with N4411
* :hpx-pr:`1461` - Consolidate inconsistent CMake option names
* :hpx-issue:`1460` - Which malloc is actually used? or at least which one is
  HPX built with
* :hpx-issue:`1459` - Make cmake configure step fail explicitly if compiler
  version is not supported
* :hpx-issue:`1458` - Update ``parallel::task_region`` with N4411
* :hpx-pr:`1456` - Consolidating ``new_<>()``
* :hpx-issue:`1455` - Replace ``async_colocated(id, ...)`` with
  ``async(colocated(id), ...)``
* :hpx-pr:`1454` - Removed harmful std::moves from return statements
* :hpx-pr:`1453` - Use range-based for-loop instead of Boost.Foreach
* :hpx-pr:`1452` - C++ feature tests
* :hpx-pr:`1451` - When serializing, pass archive flags to traits::get_type_size
* :hpx-issue:`1450` - traits:get_type_size needs archive flags to enable
  zero_copy optimizations
* :hpx-issue:`1449` - "couldn't create performance counter" - AGAS
* :hpx-issue:`1448` - Replace distributing factories with ``new_<T[]>(...)``
* :hpx-pr:`1447` - Removing obsolete remote_object component
* :hpx-pr:`1446` - Hpx serialization
* :hpx-pr:`1445` - Replacing travis with circleci
* :hpx-pr:`1443` - Always stripping HPX command line arguments before executing
  start function
* :hpx-pr:`1442` - Adding --hpx:bind=none to disable thread affinities
* :hpx-issue:`1439` - Libraries get linked in multiple times, RPATH is not
  properly set
* :hpx-pr:`1438` - Removed superfluous typedefs
* :hpx-issue:`1437` - ``hpx::init()`` should strip HPX-related flags from argv
* :hpx-issue:`1436` - Add strong scaling option to htts
* :hpx-pr:`1435` - Adding ``async_cb``, ``async_continue_cb``, and
  ``async_colocated_cb``
* :hpx-pr:`1434` - Added missing install rule, removed some dead CMake code
* :hpx-pr:`1433` - Add GitExternal and SubProject cmake scripts from
  eyescale/cmake repo
* :hpx-issue:`1432` - Add command line flag to disable thread pinning
* :hpx-pr:`1431` - Fix #1423
* :hpx-issue:`1430` - Inconsistent CMake option names
* :hpx-issue:`1429` - Configure setting ``HPX_HAVE_PARCELPORT_MPI`` is ignored
* :hpx-pr:`1428` - Fixes #1419 (closed)
* :hpx-pr:`1427` - Adding stencil_iterator and transform_iterator
* :hpx-pr:`1426` - Fixes #1419
* :hpx-pr:`1425` - During serialization memory allocation should honour
  allocator chunk size
* :hpx-issue:`1424` - chunk allocation during serialization does not use memory
  pool/allocator chunk size
* :hpx-issue:`1423` - Remove ``HPX_STD_UNIQUE_PTR``
* :hpx-issue:`1422` - hpx:threads=all allocates too many os threads
* :hpx-pr:`1420` - added .travis.yml
* :hpx-issue:`1419` - Unify enums: ``hpx::runtime::state`` and ``hpx::state``
* :hpx-pr:`1416` - Adding travis builder
* :hpx-issue:`1414` - Correct directory for dispatch_gcc46.hpp iteration
* :hpx-issue:`1410` - Set operation algorithms
* :hpx-issue:`1389` - Parallel algorithms relying on scan partitioner break for
  small number of elements
* :hpx-issue:`1325` - Exceptions thrown during parcel handling are not handled
  correctly
* :hpx-issue:`1315` - Errors while running performance tests
* :hpx-issue:`1309` - ``hpx::vector`` partitions are not easily extendable by
  applications
* :hpx-pr:`1300` - Added serialization/de-serialization to examples.tuplespace
* :hpx-issue:`1251` - hpx::threads::get_thread_count doesn't consider pending
  threads
* :hpx-issue:`1008` - Decrease in application performance overtime; occasional
  spikes of major slowdown
* :hpx-issue:`1001` - Zero copy serialization raises assert
* :hpx-issue:`721` - Make HPX usable for Xeon Phi
* :hpx-issue:`524` - Extend scheduler to support threads which can't be stolen

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_2_0:

===========================
|hpx| V1.2.0 (Nov 12, 2018)
===========================

General changes
===============

Here are some of the main highlights and changes for this release:

* Thanks to the work of our Google Summer of Code student, Nikunj Gupta, we now
  have a new implementation of ``hpx_main.hpp`` on supported platforms (Linux,
  BSD and MacOS). This is intended to be a less fragile drop-in replacement for
  the old implementation relying on preprocessor macros. The new implementation
  does not require changes if you are using the |cmake|_ or pkg-config. The old
  behaviour can be restored by setting ``HPX_WITH_DYNAMIC_HPX_MAIN=OFF`` during
  |cmake|_ configuration. The implementation on Windows is unchanged.
* We have added functionality to allow passing scheduling hints to our
  schedulers. These will allow us to create executors that for example target a
  specific NUMA domain or allow for |hpx| threads to be pinned to a particular
  worker thread.
* We have significantly improved the performance of our futures implementation
  by making the shared state atomic.
* We have replaced Boostbook by Sphinx for our documentation. This means the
  documentation is easier to navigate with built-in search and table of
  contents. We have also added a quick start section and restructured the
  documentation to be easier to follow for new users.
* We have added a new option to the :option:`--hpx:threads` command line option.
  It is now possible to use ``cores`` to tell |hpx| to only use one worker
  thread per core, unlike the existing option ``all`` which uses one worker
  thread per processing unit (processing unit can be a hyperthread if
  hyperthreads are available). The default value of :option:`--hpx:threads` has
  also been changed to ``cores`` as this leads to better performance in most
  cases.
* All command line options can now be passed alongside configuration options
  when initializing |hpx|. This means that some options that were previously
  only available on the command line can now be set as configuration options.
* HPXMP is a portable, scalable, and flexible application programming interface
  using the OpenMP specification that supports multi-platform shared memory
  multiprocessing programming in C and C++. HPXMP can be enabled within |hpx| by
  setting ``DHPX_WITH_HPXMP=ON`` during |cmake|_ configuration.
* Two new performance counters were added for measuring the time spent doing
  background work. ``/threads/time/background-work-duration`` returns the time
  spent doing background on a given thread or locality, while
  ``/threads/time/background-overhead`` returns the fraction of time spent doing
  background work with respect to the overall time spent running the scheduler.
  The new performance counters are disabled by default and can be turned on by
  setting ``HPX_WITH_BACKGROUND_THREAD_COUNTERS=ON`` during |cmake|_
  configuration.
* The idling behaviour of |hpx| has been tweaked to allow for faster idling.
  This is useful in interactive applications where the |hpx| worker threads may
  not have work all the time. This behaviour can be tweaked and turned off as
  before with ``HPX_WITH_THREAD_MANAGER_IDLE_BACKOFF=OFF`` during |cmake|_
  configuration.
* It is now possible to register callback functions for |hpx| worker thread
  events. Callbacks can be registered for starting and stopping worker threads,
  and for when errors occur.

Breaking changes
================

* The implementation of ``hpx_main.hpp`` has changed. If you are using custom
  Makefiles you will need to make changes. Please see the documentation on
  :ref:`using Makefiles <makefile>` for more details.
* The default value of :option:`--hpx:threads` has changed from ``all`` to
  ``cores``. The new option ``cores`` only starts one worker thread per core.
* We have dropped support for Boost 1.56 and 1.57. The minimal version of Boost
  we now test is 1.58.
* Our ``boost::format``\ -based formatting implementation has been revised and
  replaced with a custom implementation. This changes the formatting syntax and
  requires changes if you are relying on :cpp:func:`hpx::util::format` or
  :cpp:func:`hpx::util::format_to`. The pull request for this change contains
  more information: :hpx-pr:`3266`.
* The following deprecated options have now been completely removed:
  ``HPX_WITH_ASYNC_FUNCTION_COMPATIBILITY``, ``HPX_WITH_LOCAL_DATAFLOW``,
  ``HPX_WITH_GENERIC_EXECUTION_POLICY``,
  ``HPX_WITH_BOOST_CHRONO_COMPATIBILITY``, ``HPX_WITH_EXECUTOR_COMPATIBILITY``,
  ``HPX_WITH_EXECUTION_POLICY_COMPATIBILITY``, and
  ``HPX_WITH_TRANSFORM_REDUCE_COMPATIBILITY``.

Closed issues
=============

* :hpx-issue:`3538` - numa handling incorrect for hwloc 2
* :hpx-issue:`3533` - Cmake version 3.5.1does not work (git ff26b35 2018-11-06)
* :hpx-issue:`3526` - Failed building hpx-1.2.0-rc1 on Ubuntu16.04 x86-64 Virtualbox VM
* :hpx-issue:`3512` - Build on aarch64 fails
* :hpx-issue:`3475` - HPX fails to link if the MPI parcelport is enabled
* :hpx-issue:`3462` - CMake configuration shows a minor and inconsequential failure to create a symlink
* :hpx-issue:`3461` - Compilation Problems with the most recent Clang
* :hpx-issue:`3460` - Deadlock when create_partitioner fails (assertion fails) in debug mode
* :hpx-issue:`3455` - HPX build failing with HWLOC errors on POWER8 with hwloc 1.8
* :hpx-issue:`3438` - HPX no longer builds on IBM POWER8
* :hpx-issue:`3426` - hpx build failed on MacOS
* :hpx-issue:`3424` - CircleCI builds broken for forked repositories
* :hpx-issue:`3422` - Benchmarks in tests.performance.local are not run nightly
* :hpx-issue:`3408` - CMake Targets for HPX
* :hpx-issue:`3399` - processing unit out of bounds
* :hpx-issue:`3395` - Floating point bug in hpx/runtime/threads/policies/scheduler_base.hpp
* :hpx-issue:`3378` - compile error with lcos::communicator
* :hpx-issue:`3376` - Failed to build HPX with APEX using clang
* :hpx-issue:`3366` - Adapted Safe_Object example fails for --hpx:threads > 1
* :hpx-issue:`3360` - Segmentation fault when passing component id as parameter
* :hpx-issue:`3358` - HPX runtime hangs after multiple (~thousands) start-stop sequences
* :hpx-issue:`3352` - Support TCP provider in libfabric ParcelPort
* :hpx-issue:`3342` - undefined reference to __atomic_load_16
* :hpx-issue:`3339` - setting command line options/flags from init cfg is not obvious
* :hpx-issue:`3325` - AGAS migrates components prematurely
* :hpx-issue:`3321` - hpx bad_parameter handling is awful
* :hpx-issue:`3318` - Benchmarks fail to build with C++11
* :hpx-issue:`3304` - hpx::threads::run_as_hpx_thread does not properly handle exceptions
* :hpx-issue:`3300` - Setting pu step or offset results in no threads in default pool
* :hpx-issue:`3297` - Crash with APEX when running Phylanx lra_csv with > 1 thread
* :hpx-issue:`3296` - Building HPX with APEX configuration gives compiler warnings
* :hpx-issue:`3290` - make tests failing at hello_world_component
* :hpx-issue:`3285` - possible compilation error when "using namespace std;" is defined before including "hpx" headers files
* :hpx-issue:`3280` - HPX fails on OSX
* :hpx-issue:`3272` - CircleCI does not upload generated docker image any more
* :hpx-issue:`3270` - Error when compiling CUDA examples
* :hpx-issue:`3267` - ``tests.unit.host_.block_allocator`` fails occasionally
* :hpx-issue:`3264` - Possible move to Sphinx for documentation
* :hpx-issue:`3263` - Documentation improvements
* :hpx-issue:`3259` - ``set_parcel_write_handler`` test fails occasionally
* :hpx-issue:`3258` - Links to source code in documentation are broken
* :hpx-issue:`3247` - Rare ``tests.unit.host_.block_allocator`` test failure on 1.1.0-rc1
* :hpx-issue:`3244` - Slowing down and speeding up an interval_timer
* :hpx-issue:`3215` - Cannot build both tests and examples on MSVC with pseudo-dependencies enabled
* :hpx-issue:`3195` - Unnecessary customization point route causing performance penalty
* :hpx-issue:`3088` - A strange thing in parallel::sort.
* :hpx-issue:`2650` - libfabric support for passive endpoints
* :hpx-issue:`1205` - TSS is broken

Closed pull requests
====================

* :hpx-pr:`3542` - Fix numa lookup from pu when using hwloc 2.x
* :hpx-pr:`3541` - Fixing the build system of the MPI parcelport
* :hpx-pr:`3540` - Updating HPX people section
* :hpx-pr:`3539` - Splitting test to avoid OOM on CircleCI
* :hpx-pr:`3537` - Fix guided exec
* :hpx-pr:`3536` - Updating grants which support the LSU team
* :hpx-pr:`3535` - Fix hiding of docker credentials
* :hpx-pr:`3534` - Fixing #3533
* :hpx-pr:`3532` - fixing minor doc typo --hpx:print-counter-at arg
* :hpx-pr:`3530` - Changing APEX default tag to v2.1.0
* :hpx-pr:`3529` - Remove leftover security options and documentation
* :hpx-pr:`3528` - Fix hwloc version check
* :hpx-pr:`3524` - Do not build guided pool examples with older GCC compilers
* :hpx-pr:`3523` - Fix logging regression
* :hpx-pr:`3522` - Fix more warnings
* :hpx-pr:`3521` - Fixing argument handling in induction and reduction clauses for parallel::for_loop
* :hpx-pr:`3520` - Remove docs symlink and versioned docs folders
* :hpx-pr:`3519` - hpxMP release
* :hpx-pr:`3518` - Change all steps to use new docker image on CircleCI
* :hpx-pr:`3516` - Drop usage of deprecated facilities removed in C++17
* :hpx-pr:`3515` - Remove remaining uses of Boost.TypeTraits
* :hpx-pr:`3513` - Fixing a CMake problem when trying to use libfabric
* :hpx-pr:`3508` - Remove memory_block component
* :hpx-pr:`3507` - Propagating the MPI compile definitions to all relevant targets
* :hpx-pr:`3503` - Update documentation colors and logo
* :hpx-pr:`3502` - Fix bogus \`throws\` bindings in scheduled_thread_pool_impl
* :hpx-pr:`3501` - Split parallel::remove_if tests to avoid OOM on CircleCI
* :hpx-pr:`3500` - Support NONAMEPREFIX in add_hpx_library()
* :hpx-pr:`3497` - Note that cuda support requires cmake 3.9
* :hpx-pr:`3495` - Fixing dataflow
* :hpx-pr:`3493` - Remove deprecated options for 1.2.0 part 2
* :hpx-pr:`3492` - Add CUDA_LINK_LIBRARIES_KEYWORD to allow PRIVATE keyword in linkage t…
* :hpx-pr:`3491` - Changing Base docker image
* :hpx-pr:`3490` - Don't create tasks immediately with hpx::apply
* :hpx-pr:`3489` - Remove deprecated options for 1.2.0
* :hpx-pr:`3488` - Revert "Use BUILD_INTERFACE generator expression to fix cmake flag exports"
* :hpx-pr:`3487` - Revert "Fixing type attribute warning for transfer_action"
* :hpx-pr:`3485` - Use BUILD_INTERFACE generator expression to fix cmake flag exports
* :hpx-pr:`3483` - Fixing type attribute warning for transfer_action
* :hpx-pr:`3481` - Remove unused variables
* :hpx-pr:`3480` - Towards a more lightweight transfer action
* :hpx-pr:`3479` - Fix FLAGS - Use correct version of target_compile_options
* :hpx-pr:`3478` - Making sure the application's exit code is properly propagated back to the OS
* :hpx-pr:`3476` - Don't print docker credentials as part of the environment.
* :hpx-pr:`3473` - Fixing invalid cmake code if no jemalloc prefix was given
* :hpx-pr:`3472` - Attempting to work around recent clang test compilation failures
* :hpx-pr:`3471` - Enable jemalloc on windows
* :hpx-pr:`3470` - Updates readme
* :hpx-pr:`3468` - Avoid hang if there is an exception thrown during startup
* :hpx-pr:`3467` - Add compiler specific fallthrough attributes if C++17 attribute is not available
* :hpx-pr:`3466` - - bugfix : fix compilation with llvm-7.0
* :hpx-pr:`3465` - This patch adds various optimizations extracted from the thread_local_allocator work
* :hpx-pr:`3464` - Check for forked repos in CircleCI docker push step
* :hpx-pr:`3463` - - cmake : create the parent directory before symlinking
* :hpx-pr:`3459` - Remove unused/incomplete functionality from util/logging
* :hpx-pr:`3458` - Fix a problem with scope of CMAKE_CXX_FLAGS and hpx_add_compile_flag
* :hpx-pr:`3457` - Fixing more size_t -> int16_t (and similar) warnings
* :hpx-pr:`3456` - Add #ifdefs to topology.cpp to support old hwloc versions again
* :hpx-pr:`3454` - Fixing warnings related to silent conversion of size_t --> int16_t
* :hpx-pr:`3451` - Add examples as unit tests
* :hpx-pr:`3450` - Constexpr-fying bind and other functional facilities
* :hpx-pr:`3446` - Fix some thread suspension timeouts
* :hpx-pr:`3445` - Fix various warnings
* :hpx-pr:`3443` - Only enable service pool config options if pools are enabled
* :hpx-pr:`3441` - Fix missing closing brackets in documentation
* :hpx-pr:`3439` - Use correct MPI CXX libraries for MPI parcelport
* :hpx-pr:`3436` - Add projection function to find_* (and fix very bad bug)
* :hpx-pr:`3435` - Fixing 1205
* :hpx-pr:`3434` - Fix threads cores
* :hpx-pr:`3433` - Add Heise Online to release announcement list
* :hpx-pr:`3432` - Don't track task dependencies for distributed runs
* :hpx-pr:`3431` - Circle CI setting changes for hpxMP
* :hpx-pr:`3430` - Fix unused params warning
* :hpx-pr:`3429` - One thread per core
* :hpx-pr:`3428` - This suppresses a deprecation warning that is being issued by MSVC 19.15.26726
* :hpx-pr:`3427` - Fixes #3426
* :hpx-pr:`3425` - Use source cache and workspace between job steps on CircleCI
* :hpx-pr:`3421` - Add CDash timing output to future overhead test (for graphs)
* :hpx-pr:`3420` - Add guided_pool_executor
* :hpx-pr:`3419` - Fix typo in CircleCI config
* :hpx-pr:`3418` - Add sphinx documentation
* :hpx-pr:`3415` - Scheduler NUMA hint and shared priority scheduler
* :hpx-pr:`3414` - Adding step to synchronize the APEX release
* :hpx-pr:`3413` - Fixing multiple defines of APEX_HAVE_HPX
* :hpx-pr:`3412` - Fixes linking with libhpx_wrap error with BSD and Windows based systems
* :hpx-pr:`3410` - Fix typo in CMakeLists.txt
* :hpx-pr:`3409` - Fix brackets and indentation in existing_performance_counters.qbk
* :hpx-pr:`3407` - Fix unused param and extra ; warnings emitted by gcc 8.x
* :hpx-pr:`3406` - Adding thread local allocator and use it for future shared states
* :hpx-pr:`3405` - Adding DHPX_HAVE_THREAD_LOCAL_STORAGE=ON to builds
* :hpx-pr:`3404` - fixing multiple definition of main() in linux
* :hpx-pr:`3402` - Allow debug option to be enabled only for Linux systems with dynamic main on
* :hpx-pr:`3401` - Fix cuda_future_helper.h when compiling with C++11
* :hpx-pr:`3400` - Fix floating point exception scheduler_base idle backoff
* :hpx-pr:`3398` - Atomic future state
* :hpx-pr:`3397` - Fixing code for older gcc versions
* :hpx-pr:`3396` - Allowing to register thread event functions (start/stop/error)
* :hpx-pr:`3394` - Fix small mistake in primary_namespace_server.cpp
* :hpx-pr:`3393` - Explicitly instantiate configured schedulers
* :hpx-pr:`3392` - Add performance counters background overhead and background work duration
* :hpx-pr:`3391` - Adapt integration of HPXMP to latest build system changes
* :hpx-pr:`3390` - Make AGAS measurements optional
* :hpx-pr:`3389` - Fix deadlock during shutdown
* :hpx-pr:`3388` - Add several functionalities allowing to optimize synchronous action invocation
* :hpx-pr:`3387` - Add cmake option to opt out of fail-compile tests
* :hpx-pr:`3386` - Adding support for boost::container::small_vector to dataflow
* :hpx-pr:`3385` - Adds Debug option for hpx initializing from main
* :hpx-pr:`3384` - This hopefully fixes two tests that occasionally fail
* :hpx-pr:`3383` - Making sure thread local storage is enable for hpxMP
* :hpx-pr:`3382` - Fix usage of HPX_CAPTURE together with default value capture [=]
* :hpx-pr:`3381` - Replace undefined instantiations of uniform_int_distribution
* :hpx-pr:`3380` - Add missing semicolons to uses of HPX_COMPILER_FENCE
* :hpx-pr:`3379` - Fixing #3378
* :hpx-pr:`3377` - Adding build system support to integrate hpxmp into hpx at the user's machine
* :hpx-pr:`3375` - Replacing wrapper for __libc_start_main with main
* :hpx-pr:`3374` - Adds hpx_wrap to HPX_LINK_LIBRARIES which links only when specified.
* :hpx-pr:`3373` - Forcing cache settings in HPXConfig.cmake to guarantee updated values
* :hpx-pr:`3372` - Fix some more c++11 build problems
* :hpx-pr:`3371` - Adds HPX_LINKER_FLAGS to HPX applications without editing their source codes
* :hpx-pr:`3370` - util::format: add type_specifier<> specializations for %!s(MISSING) and %!l(MISSING)s
* :hpx-pr:`3369` - Adding configuration option to allow explicit disable of the new hpx_main feature on Linux
* :hpx-pr:`3368` - Updates doc with recent hpx_wrap implementation
* :hpx-pr:`3367` - Adds Mac OS implementation to hpx_main.hpp
* :hpx-pr:`3365` - Fix order of hpx libs in HPX_CONF_LIBRARIES.
* :hpx-pr:`3363` - Apex fixing null wrapper
* :hpx-pr:`3361` - Making sure all parcels get destroyed on an HPX thread (TCP pp)
* :hpx-pr:`3359` - Feature/improveerrorforcompiler
* :hpx-pr:`3357` - Static/dynamic executable implementation
* :hpx-pr:`3355` - Reverting changes introduced by #3283 as those make applications hang
* :hpx-pr:`3354` - Add external dependencies to HPX_LIBRARY_DIR
* :hpx-pr:`3353` - Fix libfabric tcp
* :hpx-pr:`3351` - Move obsolete header to tests directory.
* :hpx-pr:`3350` - Renaming two functions to avoid problem described in #3285
* :hpx-pr:`3349` - Make idle backoff exponential with maximum sleep time
* :hpx-pr:`3347` - Replace `simple_component*` with `component*` in the Documentation
* :hpx-pr:`3346` - Fix CMakeLists.txt example in quick start
* :hpx-pr:`3345` - Fix automatic setting of HPX_MORE_THAN_64_THREADS
* :hpx-pr:`3344` - Reduce amount of information printed for unknown command line options
* :hpx-pr:`3343` - Safeguard HPX against destruction in global contexts
* :hpx-pr:`3341` - Allowing for all command line options to be used as configuration settings
* :hpx-pr:`3340` - Always convert inspect results to JUnit XML
* :hpx-pr:`3336` - Only run docker push on master on CircleCI
* :hpx-pr:`3335` - Update description of hpx.os_threads config parameter.
* :hpx-pr:`3334` - Making sure early logging settings don't get mixed with others
* :hpx-pr:`3333` - Update CMake links and versions in documentation
* :hpx-pr:`3332` - Add notes on target suffixes to CMake documentation
* :hpx-pr:`3331` - Add quickstart section to documentation
* :hpx-pr:`3330` - Rename resource_partitioner test to avoid conflicts with pseudodependencies
* :hpx-pr:`3328` - Making sure object is pinned while executing actions, even if action returns a future
* :hpx-pr:`3327` - Add missing std::forward to tuple.hpp
* :hpx-pr:`3326` - Make sure logging is up and running while modules are being discovered.
* :hpx-pr:`3324` - Replace C++14 overload of std::equal with C++11 code.
* :hpx-pr:`3323` - Fix a missing apex thread data (wrapper) initialization
* :hpx-pr:`3320` - Adding support for -std=c++2a (define `HPX_WITH_CXX2A=On`)
* :hpx-pr:`3319` - Replacing C++14 feature with equivalent C++11 code
* :hpx-pr:`3317` - Fix compilation with VS 15.7.1 and /std:c++latest
* :hpx-pr:`3316` - Fix includes for 1d_stencil_*_omp examples
* :hpx-pr:`3314` - Remove some unused parameter warnings
* :hpx-pr:`3313` - Fix pu-step and pu-offset command line options
* :hpx-pr:`3312` - Add conversion of inspect reports to JUnit XML
* :hpx-pr:`3311` - Fix escaping of closing braces in format specification syntax
* :hpx-pr:`3310` - Don't overwrite user settings with defaults in registration database
* :hpx-pr:`3309` - Fixing potential stack overflow for dataflow
* :hpx-pr:`3308` - This updates the .clang-format configuration file to utilize newer features
* :hpx-pr:`3306` - Marking migratable objects in their gid to allow not handling migration in AGAS
* :hpx-pr:`3305` - Add proper exception handling to run_as_hpx_thread
* :hpx-pr:`3303` - Changed std::rand to a better inbuilt PRNG Generator
* :hpx-pr:`3302` - All non-migratable (simple) components now encode their lva and component type in their gid
* :hpx-pr:`3301` - Add nullptr_t overloads to resource partitioner
* :hpx-pr:`3298` - Apex task wrapper memory bug
* :hpx-pr:`3295` - Fix mistakes after merge of CircleCI config
* :hpx-pr:`3294` - Fix partitioned vector include in partitioned_vector_find tests
* :hpx-pr:`3293` - Adding emplace support to promise and make_ready_future
* :hpx-pr:`3292` - Add new cuda kernel synchronization with hpx::future demo
* :hpx-pr:`3291` - Fixes #3290
* :hpx-pr:`3289` - Fixing Docker image creation
* :hpx-pr:`3288` - Avoid allocating shared state for wait_all
* :hpx-pr:`3287` - Fixing /scheduler/utilization/instantaneous performance counter
* :hpx-pr:`3286` - dataflow() and future::then() use sync policy where possible
* :hpx-pr:`3284` - Background thread can use relaxed atomics to manipulate thread state
* :hpx-pr:`3283` - Do not unwrap ready future
* :hpx-pr:`3282` - Fix virtual method override warnings in static schedulers
* :hpx-pr:`3281` - Disable set_area_membind_nodeset for OSX
* :hpx-pr:`3279` - Add two variations to the future_overhead benchmark
* :hpx-pr:`3278` - Fix circleci workspace
* :hpx-pr:`3277` - Support external plugins
* :hpx-pr:`3276` - Fix missing parenthesis in hello_compute.cu.
* :hpx-pr:`3274` - Reinit counters synchronously in reinit_counters test
* :hpx-pr:`3273` - Splitting tests to avoid compiler OOM
* :hpx-pr:`3271` - Remove leftover code from context_generic_context.hpp
* :hpx-pr:`3269` - Fix bulk_construct with count = 0
* :hpx-pr:`3268` - Replace constexpr with HPX_CXX14_CONSTEXPR and HPX_CONSTEXPR
* :hpx-pr:`3266` - Replace boost::format with custom sprintf-based implementation
* :hpx-pr:`3265` - Split parallel tests on CircleCI
* :hpx-pr:`3262` - Making sure documentation correctly links to source files
* :hpx-pr:`3261` - Apex refactoring fix rebind
* :hpx-pr:`3260` - Isolate performance counter parser into a separate TU
* :hpx-pr:`3256` - Post 1.1.0 version bumps
* :hpx-pr:`3254` - Adding trait for actions allowing to make runtime decision on whether to execute it directly
* :hpx-pr:`3253` - Bump minimal supported Boost to 1.58.0
* :hpx-pr:`3251` - Adds new feature: changing interval used in interval_timer (issue 3244)
* :hpx-pr:`3239` - Changing std::rand() to a better inbuilt PRNG generator.
* :hpx-pr:`3234` - Disable background thread when networking is off
* :hpx-pr:`3232` - Clean up suspension tests
* :hpx-pr:`3230` - Add optional scheduler mode parameter to create_thread_pool function
* :hpx-pr:`3228` - Allow suspension also on static schedulers
* :hpx-pr:`3163` - libfabric parcelport w/o HPX_PARCELPORT_LIBFABRIC_ENDPOINT_RDM
* :hpx-pr:`3036` - Switching to CircleCI 2.0

..
    Copyright (C) 2007-2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_4_1:

===========================
|hpx| V1.4.1 (Feb 12, 2020)
===========================

General changes
===============

This is a bugfix release. It contains the following changes:

* Fix compilation issues on Windows, macOS, FreeBSD, and with gcc 10
* Install missing ``pdb`` files on Windows
* Allow running tests using an installed version of |hpx|
* Skip MPI finalization if HPX has not initialized MPI
* Give a hard error when attempting to use IO counters on Windows

Closed issues
=============

* :hpx-issue:`4320` - HPX 1.4.0 does not compile with gcc 10
* :hpx-issue:`4336` - Building HPX 1.4.0 with IO Counters breaks (Windows)
* :hpx-issue:`4334` - HPX ``Debug`` and ``RelWithDebinfo`` builds on Windows not
  installing ``.pdb`` files
* :hpx-issue:`4322` - Undefine VT1 and VT2 after boost includes
* :hpx-issue:`4314` - Compile error on 1.4.0
* :hpx-issue:`4307` - ``ld: error: duplicate symbol: freebsd_environ``


Closed pull requests
====================

* :hpx-pr:`4376` - Attempt to fix some test build errors on Windows
* :hpx-pr:`4357` - Adding missing ``#include``\ s to fix gcc V10 linker problems
* :hpx-pr:`4353` - Skip ``MPI_Finalize`` if ``MPI_Init`` is not called from HPX
* :hpx-pr:`4343` - Give a hard error if IO counters are enabled on non-Linux
  systems
* :hpx-pr:`4337` - Installing pdb files on Windows
* :hpx-pr:`4335` - Adding capability to buildsystem to use an installed version
  of HPX
* :hpx-pr:`4315` - Forcing exported symbols from composable_guard to be linked
  into core library
* :hpx-pr:`4310` - Remove environment handling from ``exception.cpp``
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_8_1:

===========================
|hpx| V0.8.1 (Apr 21, 2012)
===========================

This is a point release including important bug fixes for :ref:`hpx_0_8_0`.

General changes
===============

* |hpx| does not need to be installed anymore to be functional.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this point release:

* :hpx-issue:`295` - Don't require install path to be known at compile time.
* :hpx-issue:`371` - Add hpx iostreams to standard build.
* :hpx-issue:`384` - Fix compilation with GCC 4.7.
* :hpx-issue:`390` - Remove keep_factory_alive startup call from ShenEOS; add
  shutdown call to H5close.
* :hpx-issue:`393` - Thread affinity control is broken.

Bug fixes (commits)
===================

Here is a list of the important commits included in this point release:

* r7642 - External: Fix backtrace memory violation.
* r7775 - Components: Fix symbol visibility bug with component startup
          providers. This prevents one components providers from overriding
          another components.
* r7778 - Components: Fix startup/shutdown provider shadowing issues.

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_1_0:

===========================
|hpx| V1.1.0 (Mar 24, 2018)
===========================

General changes
===============

Here are some of the main highlights and changes for this release (in no
particular order):

* We have changed the way |hpx| manages the processing units on a node. We do
  not longer implicitly bind all available cores to a single thread pool. The
  user has now full control over what processing units are bound to what thread
  pool, each with a separate scheduler. It is now also possible to create your
  own scheduler implementation and control what processing units this scheduler
  should use. We added the ``hpx::resource::partitioner`` that manages all
  available processing units and assigns resources to the used thread pools.
  Thread pools can be now be suspended/resumed independently. This functionality
  helps in running |hpx| concurrently to code that is directly relying on
  |openmp|_ and/or |mpi|_.
* We have continued to implement various parallel algorithms. |hpx| now almost
  completely implements all of the parallel algorithms as specified by the
  |cpp17|_. We have also continued to implement these algorithms for the
  distributed use case (for segmented data structures, such as
  ``hpx::partitioned_vector``).
* Added a compatibility layer for ``std::thread``, ``std::mutex``, and
  ``std::condition_variable`` allowing for the code to use those facilities
  where available and to fall back to the corresponding Boost facilities
  otherwise. The |cmake|_ configuration option
  ``-DHPX_WITH_THREAD_COMPATIBILITY=On`` can be used to force using the Boost
  equivalents.
* The parameter sequence for the ``hpx::parallel::transform_inclusive_scan``
  overload taking one iterator range has changed (again) to match the changes
  this algorithm has undergone while being moved to C++17. The old overloads can
  be still enabled at configure time by passing
  ``-DHPX_WITH_TRANSFORM_REDUCE_COMPATIBILITY=On`` to |cmake|_.
* The parameter sequence for the ``hpx::parallel::inclusive_scan`` overload
  taking one iterator range has changed to match the changes this algorithm has
  undergone while being moved to C++17. The old overloads can be still enabled
  at configure time by passing ``-DHPX_WITH_INCLUSIVE_SCAN_COMPATIBILITY=On`` to
  |cmake|.
* Added a helper facility ``hpx::local_new`` which is equivalent to
  ``hpx::new_`` except that it creates components locally only. As a
  consequence, the used component constructor may accept non-serializable
  argument types and/or non-const references or pointers.
* Removed the (broken) component type ``hpx::lcos::queue<T>``. The old type is
  still available at configure time by passing
  ``-DHPX_WITH_QUEUE_COMPATIBILITY=On`` to |cmake|.
* The parallel algorithms adopted for C++17 restrict the iterator categories
  usable with those to at least forward iterators. Our implementation of the
  parallel algorithms was supporting input iterators (and output iterators) as
  well by simply falling back to sequential execution. We have now made our
  implementations conforming by requiring at least forward iterators. In order
  to enable the old behavior use the compatibility option
  ``-DHPX_WITH_ALGORITHM_INPUT_ITERATOR_SUPPORT=On`` on the |cmake|_ command
  line.
* We have added the functionalities allowing for LCOs being implemented using
  (simple) components. Before LCOs had to always be implemented using managed
  components.
* User defined components don't have to be default-constructible anymore. Return
  types from actions don't have to be default-constructible anymore either. Our
  serialization layer now in general supports non-default-constructible types.
* We have added a new launch policy ``hpx::launch::lazy`` that allows oneto
  defer the decision on what launch policy to use to the point of execution.
  This policy is initialized with a function (object) that -- when invoked -- is
  expected to produce the desired launch policy.

Breaking changes
================

* We have dropped support for the gcc compiler version V4.8. The minimal gcc
  version we now test on is gcc V4.9. The minimally required version of |cmake|_
  is now V3.3.2.
* We have dropped support for the Visual Studio 2013 compiler version. The
  minimal Visual Studio version we now test on is Visual Studio 2015.5.
* We have dropped support for the Boost V1.51-V1.54. The minimal version of
  Boost we now test is Boost V1.55.
* We have dropped support for the ``hpx::util::unwrapped`` API.
  ``hpx::util::unwrapped`` will stay functional to some degree, until it finally
  gets removed in a later version of HPX. The functional usage of
  ``hpx::util::unwrapped`` should be changed to the new
  ``hpx::util::unwrapping`` function whereas the immediate usage should be
  replaced to ``hpx::util::unwrap``.
* The performance counter names referring to properties as exposed by the
  threading subsystem have changes as those now additionally have to specify the
  thread-pool. See the corresponding documentation for more details.
* The overloads of ``hpx::async`` that invoke an action do not perform implicit
  unwrapping of the returned future anymore in case the invoked function does
  return a future in the first place. In this case ``hpx::async`` now returns a
  ``hpx::future<future<T>>`` making its behavior conforming to its local
  counterpart.
* We have replaced the use of ``boost::exception_ptr`` in our APIs with the
  equivalent ``std::exception_ptr``. Please change your codes accordingly. No
  compatibility settings are provided.
* We have removed the compatibility settings for
  ``HPX_WITH_COLOCATED_BACKWARDS_COMPATIBILITY`` and
  ``HPX_WITH_COMPONENT_GET_GID_COMPATIBILITY`` as their life-cycle has reached
  its end.
* We have removed the experimental thread schedulers hierarchy_scheduler,
  periodic_priority_scheduler and throttling_scheduler in an effort to clean up
  and consolidate our thread schedulers.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-pr:`3250` - Apex refactoring with guids
* :hpx-pr:`3249` - Updating People.qbk
* :hpx-pr:`3246` - Assorted fixes for CUDA
* :hpx-pr:`3245` - Apex refactoring with guids
* :hpx-pr:`3242` - Modify task counting in thread_queue.hpp
* :hpx-pr:`3240` - Fixed typos
* :hpx-pr:`3238` - Readding accidentally removed std::abort
* :hpx-pr:`3237` - Adding Pipeline example
* :hpx-pr:`3236` - Fixing memory_block
* :hpx-pr:`3233` - Make schedule_thread take suspended threads into account
* :hpx-issue:`3226` - memory_block is breaking, signaling SIGSEGV on a thread on
  creation and freeing
* :hpx-pr:`3225` - Applying quick fix for hwloc-2.0
* :hpx-issue:`3224` - HPX counters crashing the application
* :hpx-pr:`3223` - Fix returns when setting config entries
* :hpx-issue:`3222` - Errors linking libhpx.so
* :hpx-issue:`3221` - HPX on Mac OS X with HWLoc 2.0.0 fails to run
* :hpx-pr:`3216` - Reorder a variadic array to satisfy VS 2017 15.6
* :hpx-pr:`3214` - Changed prerequisites.qbk to avoid confusion while building
  boost
* :hpx-pr:`3213` - Relax locks for thread suspension to avoid holding locks when
  yielding
* :hpx-pr:`3212` - Fix check in sequenced_executor test
* :hpx-pr:`3211` - Use preinit_array to set argc/argv in init_globally example
* :hpx-pr:`3210` - Adapted parallel::{search | search_n} for Ranges TS (see
  #1668)
* :hpx-pr:`3209` - Fix locking problems during shutdown
* :hpx-issue:`3208` - init_globally throwing a run-time error
* :hpx-pr:`3206` - Addition of new arithmetic performance counter "Count"
* :hpx-pr:`3205` - Fixing return type calculation for bulk_then_execute
* :hpx-pr:`3204` - Changing std::rand() to a better inbuilt PRNG generator
* :hpx-pr:`3203` - Resolving problems during shutdown for VS2015
* :hpx-pr:`3202` - Making sure resource partitioner is not accessed if its not
  valid
* :hpx-pr:`3201` - Fixing optional::swap
* :hpx-issue:`3200` - hpx::util::optional fails
* :hpx-pr:`3199` - Fix sliding_semaphore test
* :hpx-pr:`3198` - Set pre_main status before launching run_helper
* :hpx-pr:`3197` - Update README.rst
* :hpx-pr:`3194` - parallel::{fill|fill_n} updated for Ranges TS
* :hpx-pr:`3193` - Updating Runtime.cpp by adding correct description of
  Performance counters during register
* :hpx-pr:`3191` - Fix sliding_semaphore_2338 test
* :hpx-pr:`3190` - Topology improvements
* :hpx-pr:`3189` - Deleting one include of median from BOOST library to
  arithmetics_counter file
* :hpx-pr:`3188` - Optionally disable printing of diagnostics during terminate
* :hpx-pr:`3187` - Suppressing cmake warning issued by cmake > V3.11
* :hpx-pr:`3185` - Remove unused scoped_unlock, unlock_guard_try
* :hpx-pr:`3184` - Fix nqueen example
* :hpx-pr:`3183` - Add runtime start/stop, resume/suspend and OpenMP benchmarks
* :hpx-issue:`3182` - bulk_then_execute has unexpected return type/does not
  compile
* :hpx-issue:`3181` - hwloc 2.0 breaks topo class and cannot be used
* :hpx-issue:`3180` - Schedulers that don't support suspend/resume are unusable
* :hpx-pr:`3179` - Various minor changes to support FLeCSI
* :hpx-pr:`3178` - Fix #3124
* :hpx-pr:`3177` - Removed allgather
* :hpx-pr:`3176` - Fixed Documentation for "using_hpx_pkgconfig"
* :hpx-pr:`3174` - Add hpx::iostreams::ostream overload to format_to
* :hpx-pr:`3172` - Fix lifo queue backend
* :hpx-pr:`3171` - adding the missing unset() function to cpu_mask() for case of
  more than 64 threads
* :hpx-pr:`3170` - Add cmake flag -DHPX_WITH_FAULT_TOLERANCE=ON (OFF by default)
* :hpx-pr:`3169` - Adapted parallel::{count|count_if} for Ranges TS (see #1668)
* :hpx-pr:`3168` - Changing used namespace for seq execution policy
* :hpx-issue:`3167` - Update GSoC projects
* :hpx-issue:`3166` - Application (Octotiger) gets stuck on hpx::finalize when
  only using one thread
* :hpx-issue:`3165` - Compilation of parallel algorithms with HPX_WITH_DATAPAR
  is broken
* :hpx-pr:`3164` - Fixing component migration
* :hpx-pr:`3162` - regex_from_pattern: escape regex special characters to avoid
  misinterpretation
* :hpx-issue:`3161` - Building HPX with hwloc 2.0.0 fails
* :hpx-pr:`3160` - Fixing the handling of quoted command line arguments.
* :hpx-pr:`3158` - Fixing a race with timed suspension (second attempt)
* :hpx-pr:`3157` - Revert "Fixing a race with timed suspension"
* :hpx-pr:`3156` - Fixing serialization of classes with incompatible serialize
  signature
* :hpx-pr:`3154` - More refactorings based on clang-tidy reports
* :hpx-pr:`3153` - Fixing a race with timed suspension
* :hpx-pr:`3152` - Documentation for runtime suspension
* :hpx-pr:`3151` - Use small_vector only from boost version 1.59 onwards
* :hpx-pr:`3150` - Avoiding more stack overflows
* :hpx-pr:`3148` - Refactoring component_base and
  base_action/transfer_base_action
* :hpx-pr:`3147` - Move yield_while out of detail namespace and into own file
* :hpx-pr:`3145` - Remove a leftover of the cxx11 std array cleanup
* :hpx-pr:`3144` - Minor changes to how actions are executed
* :hpx-pr:`3143` - Fix stack overhead
* :hpx-pr:`3142` - Fix typo in config.hpp
* :hpx-pr:`3141` - Fixing small_vector compatibility with older boost version
* :hpx-pr:`3140` - is_heap_text fix
* :hpx-issue:`3139` - Error in is_heap_tests.hpp
* :hpx-pr:`3138` - Partially reverting #3126
* :hpx-pr:`3137` - Suspend speedup
* :hpx-pr:`3136` - Revert "Fixing #2325"
* :hpx-pr:`3135` - Improving destruction of threads
* :hpx-issue:`3134` - HPX_SERIALIZATION_SPLIT_FREE does not stop compiler from
  looking for serialize() method
* :hpx-pr:`3133` - Make hwloc compulsory
* :hpx-pr:`3132` - Update CXX14 constexpr feature test
* :hpx-pr:`3131` - Fixing #2325
* :hpx-pr:`3130` - Avoid completion handler allocation
* :hpx-pr:`3129` - Suspend runtime
* :hpx-pr:`3128` - Make docbook dtd and xsl path names consistent
* :hpx-pr:`3127` - Add hpx::start nullptr overloads
* :hpx-pr:`3126` - Cleaning up coroutine implementation
* :hpx-pr:`3125` - Replacing nullptr with hpx::threads::invalid_thread_id
* :hpx-issue:`3124` - Add hello_world_component to CI builds
* :hpx-pr:`3123` - Add new constructor.
* :hpx-pr:`3122` - Fixing #3121
* :hpx-issue:`3121` - HPX_SMT_PAUSE is broken on non-x86 platforms when __GNUC__
  is defined
* :hpx-pr:`3120` - Don't use boost::intrusive_ptr for thread_id_type
* :hpx-pr:`3119` - Disable default executor compatibility with V1 executors
* :hpx-pr:`3118` - Adding performance_counter::reinit to allow for dynamically
  changing counter sets
* :hpx-pr:`3117` - Replace uses of boost/experimental::optional with
  util::optional
* :hpx-pr:`3116` - Moving background thread APEX timer #2980
* :hpx-pr:`3115` - Fixing race condition in channel test
* :hpx-pr:`3114` - Avoid using util::function for thread function wrappers
* :hpx-pr:`3113` - cmake V3.10.2 has changed the variable names used for MPI
* :hpx-pr:`3112` - Minor fixes to exclusive_scan algorithm
* :hpx-pr:`3111` - Revert "fix detection of cxx11_std_atomic"
* :hpx-pr:`3110` - Suspend thread pool
* :hpx-pr:`3109` - Fixing thread scheduling when yielding a thread id
* :hpx-pr:`3108` - Revert "Suspend thread pool"
* :hpx-pr:`3107` - Remove UB from thread::id relational operators
* :hpx-pr:`3106` - Add cmake test for std::decay_t to fix cuda build
* :hpx-pr:`3105` - Fixing refcount for async traversal frame
* :hpx-pr:`3104` - Local execution of direct actions is now actually performed
  directly
* :hpx-pr:`3103` - Adding support for generic counter_raw_values performance
  counter type
* :hpx-issue:`3102` - Introduce generic performance counter type returning an
  array of values
* :hpx-pr:`3101` - Revert "Adapting stack overhead limit for gcc 4.9"
* :hpx-pr:`3100` - Fix #3068 (condition_variable deadlock)
* :hpx-pr:`3099` - Fixing lock held during suspension in papi counter component
* :hpx-pr:`3098` - Unbreak broadcast_wait_for_2822 test
* :hpx-pr:`3097` - Adapting stack overhead limit for gcc 4.9
* :hpx-pr:`3096` - fix detection of cxx11_std_atomic
* :hpx-pr:`3095` - Add ciso646 header to get _LIBCPP_VERSION for testing inplace
  merge
* :hpx-pr:`3094` - Relax atomic operations on performance counter values
* :hpx-pr:`3093` - Short-circuit all_of/any_of/none_of instantiations
* :hpx-pr:`3092` - Take advantage of C++14 lambda capture initialization syntax,
  where possible
* :hpx-pr:`3091` - Remove more references to Boost from logging code
* :hpx-pr:`3090` - Unify use of yield/yield_k
* :hpx-pr:`3089` - Fix a strange thing in parallel::detail::handle_exception.
  (Fix #2834.)
* :hpx-issue:`3088` - A strange thing in parallel::sort.
* :hpx-pr:`3087` - Fixing assertion in default_distribution_policy
* :hpx-pr:`3086` - Implement parallel::remove and parallel::remove_if
* :hpx-pr:`3085` - Addressing breaking changes in Boost V1.66
* :hpx-pr:`3084` - Ignore build warnings round 2
* :hpx-pr:`3083` - Fix typo HPX_WITH_MM_PREFECTH
* :hpx-pr:`3081` - Pre-decay template arguments early
* :hpx-pr:`3080` - Suspend thread pool
* :hpx-pr:`3079` - Ignore build warnings
* :hpx-pr:`3078` - Don't test inplace_merge with libc++
* :hpx-pr:`3076` - Fixing 3075: Part 1
* :hpx-pr:`3074` - Fix more build warnings
* :hpx-pr:`3073` - Suspend thread cleanup
* :hpx-pr:`3072` - Change existing symbol_namespace::iterate to return all data
  instead of invoking a callback
* :hpx-pr:`3071` - Fixing pack_traversal_async test
* :hpx-pr:`3070` - Fix dynamic_counters_loaded_1508 test by adding dependency to
  memory_component
* :hpx-pr:`3069` - Fix scheduling loop exit
* :hpx-issue:`3068` - hpx::lcos::condition_variable could be suspect to
  deadlocks
* :hpx-pr:`3067` - #ifdef out random_shuffle deprecated in later c++
* :hpx-pr:`3066` - Make coalescing test depend on coalescing library to ensure
  it gets built
* :hpx-pr:`3065` - Workaround for minimal_timed_async_executor_test compilation
  failures, attempts to copy a deferred call (in unevaluated context)
* :hpx-pr:`3064` - Fixing wrong condition in wrapper_heap
* :hpx-pr:`3062` - Fix exception handling for execution::seq
* :hpx-pr:`3061` - Adapt MSVC C++ mode handling to VS15.5
* :hpx-pr:`3060` - Fix compiler problem in MSVC release mode
* :hpx-pr:`3059` - Fixing #2931
* :hpx-issue:`3058` - minimal_timed_async_executor_test_exe fails to compile on
  master (d6f505c)
* :hpx-pr:`3057` - Fix stable_merge_2964 compilation problems
* :hpx-pr:`3056` - Fix some build warnings caused by unused
  variables/unnecessary tests
* :hpx-pr:`3055` - Update documentation for running tests
* :hpx-issue:`3054` - Assertion failure when using bulk hpx::new_ in
  asynchronous mode
* :hpx-pr:`3052` - Do not bind test running to cmake test build rule
* :hpx-pr:`3051` - Fix HPX-Qt interaction in Qt example.
* :hpx-issue:`3048` - nqueen example fails occasionally
* :hpx-pr:`3047` - Fixing #3044
* :hpx-pr:`3046` - Add OS thread suspension
* :hpx-pr:`3042` - PyCicle - first attempt at a build toold for checking PR's
* :hpx-pr:`3041` - Fix a problem about asynchronous execution of parallel::merge
  and parallel::partition.
* :hpx-pr:`3040` - Fix a mistake about exception handling in asynchronous
  execution of scan_partitioner.
* :hpx-pr:`3039` - Consistently use executors to schedule work
* :hpx-pr:`3038` - Fixing local direct function execution and lambda actions
  perfect forwarding
* :hpx-pr:`3035` - Make parallel unit test names match build target/folder names
* :hpx-pr:`3033` - Fix setting of default build type
* :hpx-issue:`3032` - Fix partitioner arg copy found in #2982
* :hpx-issue:`3031` - Errors linking libhpx.so due to missing references (master
  branch, commit 6679a8882)
* :hpx-pr:`3030` - Revert "implement executor then interface with && forwarding
  reference"
* :hpx-pr:`3029` - Run CI inspect checks before building
* :hpx-pr:`3028` - Added range version of parallel::move
* :hpx-issue:`3027` - Implement all scheduling APIs in terms of executors
* :hpx-pr:`3026` - implement executor then interface with && forwarding
  reference
* :hpx-pr:`3025` - Fix typo unitialized to uninitialized
* :hpx-pr:`3024` - Inspect fixes
* :hpx-pr:`3023` - P0356 Simplified partial function application
* :hpx-pr:`3022` - Master fixes
* :hpx-pr:`3021` - Segfault fix
* :hpx-pr:`3020` - Disable command-line aliasing for applications that use
  user_main
* :hpx-pr:`3019` - Adding enable_elasticity option to pool configuration
* :hpx-pr:`3018` - Fix stack overflow detection configuration in header files
* :hpx-pr:`3017` - Speed up local action execution
* :hpx-pr:`3016` - Unify stack-overflow detection options, remove reference to
  libsigsegv
* :hpx-pr:`3015` - Speeding up accessing the resource partitioner and the
  topology info
* :hpx-issue:`3014` - HPX does not compile on POWER8 with gcc 5.4
* :hpx-issue:`3013` - hello_world occasionally prints multiple lines from a
  single OS-thread
* :hpx-pr:`3012` - Silence warning about casting away qualifiers in
  itt_notify.hpp
* :hpx-pr:`3011` - Fix cpuset leak in hwloc_topology_info.cpp
* :hpx-pr:`3010` - Remove useless decay_copy
* :hpx-pr:`3009` - Fixing 2996
* :hpx-pr:`3008` - Remove unused internal function
* :hpx-pr:`3007` - Fixing wrapper_heap alignment problems
* :hpx-issue:`3006` - hwloc memory leak
* :hpx-pr:`3004` - Silence C4251 (needs to have dll-interface) for
  future_data_void
* :hpx-issue:`3003` - Suspension of runtime
* :hpx-pr:`3001` - Attempting to avoid data races in async_traversal while
  evaluating dataflow()
* :hpx-pr:`3000` - Adding hpx::util::optional as a first step to replace
  experimental::optional
* :hpx-pr:`2998` - Cleanup up and Fixing component creation and deletion
* :hpx-issue:`2996` - Build fails with HPX_WITH_HWLOC=OFF
* :hpx-pr:`2995` - Push more future_data functionality to source file
* :hpx-pr:`2994` - WIP: Fix throttle test
* :hpx-pr:`2993` - Making sure --hpx:help does not throw for required (but
  missing) arguments
* :hpx-pr:`2992` - Adding non-blocking (on destruction) service executors
* :hpx-issue:`2991` - run_as_os_thread locks up
* :hpx-issue:`2990` - --help will not work until all required options are
  provided
* :hpx-pr:`2989` - Improve error messages caused by misuse of dataflow
* :hpx-pr:`2988` - Improve error messages caused by misuse of .then
* :hpx-issue:`2987` - stack overflow detection producing false positives
* :hpx-pr:`2986` - Deduplicate non-dependent thread_info logging types
* :hpx-pr:`2985` - Adapted parallel::{all_of|any_of|none_of} for Ranges TS (see
  #1668)
* :hpx-pr:`2984` - Refactor one_size_heap code to simplify code
* :hpx-pr:`2983` - Fixing local_new_component
* :hpx-pr:`2982` - Clang tidy
* :hpx-pr:`2981` - Simplify allocator rebinding in pack traversal
* :hpx-pr:`2979` - Fixing integer overflows
* :hpx-pr:`2978` - Implement parallel::inplace_merge
* :hpx-issue:`2977` - Make hwloc compulsory instead of optional
* :hpx-pr:`2976` - Making sure client_base instance that registered the
  component does not unregister it when being destructed
* :hpx-pr:`2975` - Change version of pulled APEX to master
* :hpx-pr:`2974` - Fix domain not being freed at the end of scheduling loop
* :hpx-pr:`2973` - Fix small typos
* :hpx-pr:`2972` - Adding uintstd.h header
* :hpx-pr:`2971` - Fall back to creating local components using local_new
* :hpx-pr:`2970` - Improve is_tuple_like trait
* :hpx-pr:`2969` - Fix HPX_WITH_MORE_THAN_64_THREADS default value
* :hpx-pr:`2968` - Cleaning up dataflow overload set
* :hpx-pr:`2967` - Make parallel::merge is stable. (Fix #2964.)
* :hpx-pr:`2966` - Fixing a couple of held locks during exception handling
* :hpx-pr:`2965` - Adding missing #include
* :hpx-issue:`2964` - parallel merge is not stable
* :hpx-pr:`2963` - Making sure any function object passed to dataflow is
  released after being invoked
* :hpx-pr:`2962` - Partially reverting #2891
* :hpx-pr:`2961` - Attempt to fix the gcc 4.9 problem with the async pack
  traversal
* :hpx-issue:`2959` - Program terminates during error handling
* :hpx-issue:`2958` - HPX_PLAIN_ACTION breaks due to missing include
* :hpx-pr:`2957` - Fixing errors generated by mixing different attribute
  syntaxes
* :hpx-issue:`2956` - Mixing attribute syntaxes leads to compiler errors
* :hpx-issue:`2955` - Fix OS-Thread throttling
* :hpx-pr:`2953` - Making sure any hpx.os_threads=N supplied through a
  --hpx::config file is taken into account
* :hpx-pr:`2952` - Removing wrong call to cleanup_terminated_locked
* :hpx-pr:`2951` - Revert "Make sure the function vtables are initialized before
  use"
* :hpx-pr:`2950` - Fix a namespace compilation error when some schedulers are
  disabled
* :hpx-issue:`2949` - master branch giving lockups on shutdown
* :hpx-issue:`2947` - hpx.ini is not used correctly at initialization
* :hpx-pr:`2946` - Adding explicit feature test for thread_local
* :hpx-pr:`2945` - Make sure the function vtables are initialized before use
* :hpx-pr:`2944` - Attempting to solve affinity problems on CircleCI
* :hpx-pr:`2943` - Changing channel actions to be direct
* :hpx-pr:`2942` - Adding split_future for std::vector
* :hpx-pr:`2941` - Add a feature test to test for CXX11 override
* :hpx-issue:`2940` - Add split_future for future<vector<T>>
* :hpx-pr:`2939` - Making error reporting during problems with setting affinity
  masks more verbose
* :hpx-pr:`2938` - Fix this various executors
* :hpx-pr:`2937` - Fix some typos in documentation
* :hpx-pr:`2934` - Remove the need for "complete" SFINAE checks
* :hpx-pr:`2933` - Making sure parallel::for_loop is executed in parallel if
  requested
* :hpx-pr:`2932` - Classify chunk_size_iterator to input iterator tag. (Fix
  #2866)
* :hpx-issue:`2931` - --hpx:help triggers unusual error with clang build
* :hpx-pr:`2930` - Add #include files needed to set _POSIX_VERSION for debug
  check
* :hpx-pr:`2929` - Fix a couple of deprecated c++ features
* :hpx-pr:`2928` - Fixing execution parameters
* :hpx-issue:`2927` - CMake warning: ... cycle in constraint graph
* :hpx-pr:`2926` - Default pool rename
* :hpx-issue:`2925` - Default pool cannot be renamed
* :hpx-issue:`2924` - hpx:attach-debugger=startup does not work any more
* :hpx-pr:`2923` - Alloc membind
* :hpx-pr:`2922` - This fixes CircleCI errors when running with --hpx:bind=none
* :hpx-pr:`2921` - Custom pool executor was missing priority and stacksize
  options
* :hpx-pr:`2920` - Adding test to trigger problem reported in #2916
* :hpx-pr:`2919` - Make sure the resource_partitioner is properly destructed on
  hpx::finalize
* :hpx-issue:`2918` - hpx::init calls wrong (first) callback when called
  multiple times
* :hpx-pr:`2917` - Adding util::checkpoint
* :hpx-issue:`2916` - Weird runtime failures when using a channel and chained
  continuations
* :hpx-pr:`2915` - Introduce executor parameters customization points
* :hpx-issue:`2914` - Task assignment to current Pool has unintended
  consequences
* :hpx-pr:`2913` - Fix rp hang
* :hpx-pr:`2912` - Update contributors
* :hpx-pr:`2911` - Fixing CUDA problems
* :hpx-pr:`2910` - Improve error reporting for process component on POSIX
  systems
* :hpx-pr:`2909` - Fix typo in include path
* :hpx-pr:`2908` - Use proper container according to iterator tag in benchmarks
  of parallel algorithms
* :hpx-pr:`2907` - Optionally force-delete remaining channel items on close
* :hpx-pr:`2906` - Making sure generated performance counter names are correct
* :hpx-issue:`2905` - collecting idle-rate performance counters on multiple
  localities produces an error
* :hpx-issue:`2904` - build broken for Intel 17 compilers
* :hpx-pr:`2903` - Documentation Updates-- Adding New People
* :hpx-pr:`2902` - Fixing service_executor
* :hpx-pr:`2901` - Fixing partitioned_vector creation
* :hpx-pr:`2900` - Add numa-balanced mode to hpx::bind, spread cores over numa
  domains
* :hpx-issue:`2899` - hpx::bind does not have a mode that balances cores over
  numa domains
* :hpx-pr:`2898` - Adding missing #include and missing guard for optional code
  section
* :hpx-pr:`2897` - Removing dependency on Boost.ICL
* :hpx-issue:`2896` - Debug build fails without -fpermissive with GCC 7.1 and
  Boost 1.65
* :hpx-pr:`2895` - Fixing SLURM environment parsing
* :hpx-pr:`2894` - Fix incorrect handling of compile definition with value 0
* :hpx-issue:`2893` - Disabling schedulers causes build errors
* :hpx-pr:`2892` - added list serializer
* :hpx-pr:`2891` - Resource Partitioner Fixes
* :hpx-issue:`2890` - Destroying a non-empty channel causes an assertion failure
* :hpx-pr:`2889` - Add check for libatomic
* :hpx-pr:`2888` - Fix compilation problems if HPX_WITH_ITT_NOTIFY=ON
* :hpx-pr:`2887` - Adapt broadcast() to non-unwrapping async<Action>
* :hpx-pr:`2886` - Replace Boost.Random with C++11 <random>
* :hpx-issue:`2885` - regression in broadcast?
* :hpx-issue:`2884` - linking ``-latomic`` is not portable
* :hpx-pr:`2883` - Explicitly set -pthread flag if available
* :hpx-pr:`2882` - Wrap boost::format uses
* :hpx-issue:`2881` - hpx not compiling with ``HPX_WITH_ITTNOTIFY=On``
* :hpx-issue:`2880` - hpx::bind scatter/balanced give wrong pu masks
* :hpx-pr:`2878` - Fix incorrect pool usage masks setup in RP/thread manager
* :hpx-pr:`2877` - Require ``std::array`` by default
* :hpx-pr:`2875` - Deprecate use of BOOST_ASSERT
* :hpx-pr:`2874` - Changed serialization of boost.variant to use variadic
  templates
* :hpx-issue:`2873` - building with parcelport_mpi fails on cori
* :hpx-pr:`2871` - Adding missing support for throttling scheduler
* :hpx-pr:`2870` - Disambiguate use of base_lco_with_value macros with channel
* :hpx-issue:`2869` - Difficulty compiling
  ``HPX_REGISTER_CHANNEL_DECLARATION(double)``
* :hpx-pr:`2868` - Removing unneeded assert
* :hpx-pr:`2867` - Implement parallel::unique
* :hpx-issue:`2866` - The chunk_size_iterator violates multipass guarantee
* :hpx-pr:`2865` - Only use sched_getcpu on linux machines
* :hpx-pr:`2864` - Create redistribution archive for successful builds
* :hpx-pr:`2863` - Replace casts/assignments with hard-coded memcpy operations
* :hpx-issue:`2862` - sched_getcpu not available on MacOS
* :hpx-pr:`2861` - Fixing unmatched header defines and recursive inclusion of
  threadmanager
* :hpx-issue:`2860` - Master program fails with assertion 'type ==
  data_type_address' failed: HPX(assertion_failure)
* :hpx-issue:`2852` - Support for ARM64
* :hpx-pr:`2858` - Fix misplaced #if #endif's that cause build failure without
  THREAD_CUMULATIVE_COUNTS
* :hpx-pr:`2857` - Fix some listing in documentation
* :hpx-pr:`2856` - Fixing component handling for lcos
* :hpx-pr:`2855` - Add documentation for coarrays
* :hpx-pr:`2854` - Support ARM64 in timestamps
* :hpx-pr:`2853` - Update Table 17. Non-modifying Parallel Algorithms in
  Documentation
* :hpx-pr:`2851` - Allowing for non-default-constructible component types
* :hpx-pr:`2850` - Enable returning future<R> from actions where R is not
  default-constructible
* :hpx-pr:`2849` - Unify serialization of non-default-constructable types
* :hpx-issue:`2848` - Components have to be default constructible
* :hpx-issue:`2847` - Returning a future<R> where R is not default-constructable
  broken
* :hpx-issue:`2846` - Unify serialization of non-default-constructible types
* :hpx-pr:`2845` - Add Visual Studio 2015 to the tested toolchains in Appveyor
* :hpx-issue:`2844` - Change the appveyor build to use the minimal required MSVC
  version
* :hpx-issue:`2843` - multi node hello_world hangs
* :hpx-pr:`2842` - Correcting Spelling mistake in docs
* :hpx-pr:`2841` - Fix usage of std::aligned_storage
* :hpx-pr:`2840` - Remove constexpr from a void function
* :hpx-issue:`2839` - memcpy buffer overflow: load_construct_data() and
  std::complex members
* :hpx-issue:`2835` - ``constexpr`` functions with ``void`` return type break
  compilation with CUDA 8.0
* :hpx-issue:`2834` - One suspicion in parallel::detail::handle_exception
* :hpx-pr:`2833` - Implement parallel::merge
* :hpx-pr:`2832` - Fix a strange thing in
  parallel::util::detail::handle_local_exceptions. (Fix #2818)
* :hpx-pr:`2830` - Break the debugger when a test failed
* :hpx-issue:`2831` - ``parallel/executors/execution_fwd.hpp`` causes
  compilation failure in C++11 mode.
* :hpx-pr:`2829` - Implement an API for asynchronous pack traversal
* :hpx-pr:`2828` - Split unit test builds on CircleCI to avoid timeouts
* :hpx-issue:`2827` - failure to compile hello_world example with -Werror
* :hpx-pr:`2824` - Making sure promises are marked as started when used as
  continuations
* :hpx-pr:`2823` - Add documentation for partitioned_vector_view
* :hpx-issue:`2822` - Yet another issue with wait_for similar to #2796
* :hpx-pr:`2821` - Fix bugs and improve that about
  HPX_HAVE_CXX11_AUTO_RETURN_VALUE of CMake
* :hpx-pr:`2820` - Support C++11 in benchmark codes of parallel::partition and
  parallel::partition_copy
* :hpx-pr:`2819` - Fix compile errors in unit test of container version of
  parallel::partition
* :hpx-issue:`2818` - A strange thing in
  parallel::util::detail::handle_local_exceptions
* :hpx-issue:`2815` - HPX fails to compile with HPX_WITH_CUDA=ON and the new
  CUDA 9.0 RC
* :hpx-issue:`2814` - Using 'gmakeN' after 'cmake' produces error in
  src/CMakeFiles/hpx.dir/runtime/agas/addressing_service.cpp.o
* :hpx-pr:`2813` - Properly support [[noreturn]] attribute if available
* :hpx-issue:`2812` - Compilation fails with gcc 7.1.1
* :hpx-pr:`2811` - Adding hpx::launch::lazy and support for async, dataflow, and
  future::then
* :hpx-pr:`2810` - Add option allowing to disable deprecation warning
* :hpx-pr:`2809` - Disable throttling scheduler if HWLOC is not found/used
* :hpx-pr:`2808` - Fix compile errors on some environments of
  parallel::partition
* :hpx-issue:`2807` - Difficulty building with ``HPX_WITH_HWLOC=Off``
* :hpx-pr:`2806` - Partitioned vector
* :hpx-pr:`2805` - Serializing collections with non-default constructible data
* :hpx-pr:`2802` - Fix FreeBSD 11
* :hpx-issue:`2801` - Rate limiting techniques in io_service
* :hpx-issue:`2800` - New Launch Policy: async_if
* :hpx-pr:`2799` - Fix a unit test failure on GCC in tuple_cat
* :hpx-pr:`2798` - bump minimum required cmake to 3.0 in test
* :hpx-pr:`2797` - Making sure future::wait_for et.al. work properly for action
  results
* :hpx-issue:`2796` - wait_for does always in "deferred" state for calls on
  remote localities
* :hpx-issue:`2795` - Serialization of types without default constructor
* :hpx-pr:`2794` - Fixing test for partitioned_vector iteration
* :hpx-pr:`2792` - Implemented segmented find and its variations for partitioned
  vector
* :hpx-pr:`2791` - Circumvent scary warning about placement new
* :hpx-pr:`2790` - Fix OSX build
* :hpx-pr:`2789` - Resource partitioner
* :hpx-pr:`2788` - Adapt parallel::is_heap and parallel::is_heap_until to Ranges
  TS
* :hpx-pr:`2787` - Unwrap hotfixes
* :hpx-pr:`2786` - Update CMake Minimum Version to 3.3.2 (refs #2565)
* :hpx-issue:`2785` - Issues with masks and cpuset
* :hpx-pr:`2784` - Error with reduce and transform reduce fixed
* :hpx-pr:`2783` - StackOverflow integration with libsigsegv
* :hpx-pr:`2782` - Replace boost::atomic with std::atomic (where possible)
* :hpx-pr:`2781` - Check for and optionally use [[deprecated]] attribute
* :hpx-pr:`2780` - Adding empty (but non-trivial) destructor to circumvent
  warnings
* :hpx-pr:`2779` - Exception info tweaks
* :hpx-pr:`2778` - Implement parallel::partition
* :hpx-pr:`2777` - Improve error handling in gather_here/gather_there
* :hpx-pr:`2776` - Fix a bug in compiler version check
* :hpx-pr:`2775` - Fix compilation when HPX_WITH_LOGGING is OFF
* :hpx-pr:`2774` - Removing dependency on Boost.Date_Time
* :hpx-pr:`2773` - Add sync_images() method to spmd_block class
* :hpx-pr:`2772` - Adding documentation for PAPI counters
* :hpx-pr:`2771` - Removing boost preprocessor dependency
* :hpx-pr:`2770` - Adding test, fixing deadlock in config registry
* :hpx-pr:`2769` - Remove some other warnings and errors detected by clang 5.0
* :hpx-issue:`2768` - Is there iterator tag for HPX?
* :hpx-pr:`2767` - Improvements to continuation annotation
* :hpx-pr:`2765` - gcc split stack support for HPX threads #620
* :hpx-pr:`2764` - Fix some uses of begin/end, remove unnecessary includes
* :hpx-pr:`2763` - Bump minimal Boost version to 1.55.0
* :hpx-pr:`2762` - hpx::partitioned_vector serializer
* :hpx-pr:`2761` - Adding configuration summary to cmake output and --hpx:info
* :hpx-pr:`2760` - Removing 1d_hydro example as it is broken
* :hpx-pr:`2758` - Remove various warnings detected by clang 5.0
* :hpx-issue:`2757` - In case of a "raw thread" is needed per core for
  implementing parallel algorithm, what is good practice in HPX?
* :hpx-pr:`2756` - Allowing for LCOs to be simple components
* :hpx-pr:`2755` - Removing make_index_pack_unrolled
* :hpx-pr:`2754` - Implement parallel::unique_copy
* :hpx-pr:`2753` - Fixing detection of [[fallthrough]] attribute
* :hpx-pr:`2752` - New thread priority names
* :hpx-pr:`2751` - Replace boost::exception with proposed exception_info
* :hpx-pr:`2750` - Replace boost::iterator_range
* :hpx-pr:`2749` - Fixing hdf5 examples
* :hpx-issue:`2748` - HPX fails to build with enabled hdf5 examples
* :hpx-issue:`2747` - Inherited task priorities break certain DAG optimizations
* :hpx-issue:`2746` - HPX segfaulting with valgrind
* :hpx-pr:`2745` - Adding extended arithmetic performance counters
* :hpx-pr:`2744` - Adding ability to statistics counters to reset base counter
* :hpx-issue:`2743` - Statistics counter does not support resetting
* :hpx-pr:`2742` - Making sure Vc V2 builds without additional HPX configuration
  flags
* :hpx-pr:`2741` - Deprecate unwrapped and implement unwrap and unwrapping
* :hpx-pr:`2740` - Coroutine stackoverflow detection for linux/posix; Issue
  #2408
* :hpx-pr:`2739` - Add files via upload
* :hpx-pr:`2738` - Appveyor support
* :hpx-pr:`2737` - Fixing 2735
* :hpx-issue:`2736` - 1d_hydro example doesn't work
* :hpx-issue:`2735` - partitioned_vector_subview test failing
* :hpx-pr:`2734` - Add C++11 range utilities
* :hpx-pr:`2733` - Adapting iterator requirements for parallel algorithms
* :hpx-pr:`2732` - Integrate C++ Co-arrays
* :hpx-pr:`2731` - Adding on_migrated event handler to migratable component
  instances
* :hpx-issue:`2729` - Add on_migrated() event handler to migratable components
* :hpx-issue:`2728` - Why Projection is needed in parallel algorithms?
* :hpx-pr:`2727` - Cmake files for StackOverflow Detection
* :hpx-pr:`2726` - CMake for Stack Overflow Detection
* :hpx-pr:`2725` - Implemented segmented algorithms for partitioned vector
* :hpx-pr:`2724` - Fix examples in Action documentation
* :hpx-pr:`2723` - Enable lcos::channel<T>::register_as
* :hpx-issue:`2722` - channel register_as() failing on compilation
* :hpx-pr:`2721` - Mind map
* :hpx-pr:`2720` - reorder forward declarations to get rid of C++14-only auto
  return types
* :hpx-pr:`2719` - Add documentation for partitioned_vector and add features in
  pack.hpp
* :hpx-issue:`2718` - Some forward declarations in execution_fwd.hpp aren't
  C++11-compatible
* :hpx-pr:`2717` - Config support for fallthrough attribute
* :hpx-pr:`2716` - Implement parallel::partition_copy
* :hpx-pr:`2715` - initial import of icu string serializer
* :hpx-pr:`2714` - initial import of valarray serializer
* :hpx-pr:`2713` - Remove slashes before CMAKE_FILES_DIRECTORY variables
* :hpx-pr:`2712` - Fixing wait for 1751
* :hpx-pr:`2711` - Adjust code for minimal supported GCC having being bumped to
  4.9
* :hpx-pr:`2710` - Adding code of conduct
* :hpx-pr:`2709` - Fixing UB in destroy tests
* :hpx-pr:`2708` - Add inline to prevent multiple definition issue
* :hpx-issue:`2707` - Multiple defined symbols for task_block.hpp in VS2015
* :hpx-pr:`2706` - Adding .clang-format file
* :hpx-pr:`2704` - Add a synchronous mapping API
* :hpx-issue:`2703` - Request: Add the .clang-format file to the repository
* :hpx-issue:`2702` - STEllAR-GROUP/Vc slower than VCv1 possibly due to wrong
  instructions generated
* :hpx-issue:`2701` - Datapar with STEllAR-GROUP/Vc requires obscure flag
* :hpx-issue:`2700` - Naming inconsistency in parallel algorithms
* :hpx-issue:`2699` - Iterator requirements are different from standard in
  parallel copy_if.
* :hpx-pr:`2698` - Properly releasing parcelport write handlers
* :hpx-issue:`2697` - Compile error in addressing_service.cpp
* :hpx-issue:`2696` - Building and using HPX statically: undefined references
  from runtime_support_server.cpp
* :hpx-issue:`2695` - Executor changes cause compilation failures
* :hpx-pr:`2694` - Refining C++ language mode detection for MSVC
* :hpx-pr:`2693` - P0443 r2
* :hpx-pr:`2692` - Partially reverting changes to parcel_await
* :hpx-issue:`2689` - HPX build fails when HPX_WITH_CUDA is enabled
* :hpx-pr:`2688` - Make Cuda Clang builds pass
* :hpx-pr:`2687` - Add an is_tuple_like trait for sequenceable type detection
* :hpx-pr:`2686` - Allowing throttling scheduler to be used without idle backoff
* :hpx-pr:`2685` - Add support of std::array to hpx::util::tuple_size and
  tuple_element
* :hpx-pr:`2684` - Adding new statistics performance counters
* :hpx-pr:`2683` - Replace boost::exception_ptr with std::exception_ptr
* :hpx-issue:`2682` - HPX does not compile with
  HPX_WITH_THREAD_MANAGER_IDLE_BACKOFF=OFF
* :hpx-pr:`2681` - Attempt to fix problem in managed_component_base
* :hpx-pr:`2680` - Fix bad size during archive creation
* :hpx-issue:`2679` - Mismatch between size of archive and container
* :hpx-issue:`2678` - In parallel algorithm, other tasks are executed to the end
  even if an exception occurs in any task.
* :hpx-pr:`2677` - Adding include check for std::addressof
* :hpx-pr:`2676` - Adding parallel::destroy and destroy_n
* :hpx-pr:`2675` - Making sure statistics counters work as expected
* :hpx-pr:`2674` - Turning assertions into exceptions
* :hpx-pr:`2673` - Inhibit direct conversion from future<future<T>> -->
  future<void>
* :hpx-pr:`2672` - C++17 invoke forms
* :hpx-pr:`2671` - Adding uninitialized_value_construct and
  uninitialized_value_construct_n
* :hpx-pr:`2670` - Integrate spmd multidimensional views for
  partitioned_vectors
* :hpx-pr:`2669` - Adding uninitialized_default_construct and
  uninitialized_default_construct_n
* :hpx-pr:`2668` - Fixing documentation index
* :hpx-issue:`2667` - Ambiguity of nested hpx::future<void>'s
* :hpx-issue:`2666` - Statistics Performance counter is not working
* :hpx-pr:`2664` - Adding uninitialized_move and uninitialized_move_n
* :hpx-issue:`2663` - Seg fault in managed_component::get_base_gid, possibly
  cause by util::reinitializable_static
* :hpx-issue:`2662` - Crash in managed_component::get_base_gid due to problem
  with util::reinitializable_static
* :hpx-pr:`2665` - Hide the ``detail`` namespace in doxygen per default
* :hpx-pr:`2660` - Add documentation to hpx::util::unwrapped and
  hpx::util::unwrapped2
* :hpx-pr:`2659` - Improve integration with vcpkg
* :hpx-pr:`2658` - Unify access_data trait for use in both, serialization and
  de-serialization
* :hpx-pr:`2657` - Removing hpx::lcos::queue<T>
* :hpx-pr:`2656` - Reduce MAX_TERMINATED_THREADS default, improve memory use on
  manycore cpus
* :hpx-pr:`2655` - Mainteinance for emulate-deleted macros
* :hpx-pr:`2654` - Implement parallel is_heap and is_heap_until
* :hpx-pr:`2653` - Drop support for VS2013
* :hpx-pr:`2652` - This patch makes sure that all parcels in a batch are
  properly handled
* :hpx-pr:`2649` - Update docs (Table 18) - move transform to end
* :hpx-issue:`2647` - hpx::parcelset::detail::parcel_data::has_continuation_ is
  uninitialized
* :hpx-issue:`2644` - Some .vcxproj in the HPX.sln fail to build
* :hpx-issue:`2641` - ``hpx::lcos::queue`` should be deprecated
* :hpx-pr:`2640` - A new throttling policy with public APIs to suspend/resume
* :hpx-pr:`2639` - Fix a tiny typo in tutorial.
* :hpx-issue:`2638` - Invalid return type 'void' of constexpr function
* :hpx-pr:`2636` - Add and use HPX_MSVC_WARNING_PRAGMA for #pragma warning
* :hpx-pr:`2633` - Distributed define_spmd_block
* :hpx-pr:`2632` - Making sure container serialization uses size-compatible
  types
* :hpx-pr:`2631` - Add lcos::local::one_element_channel
* :hpx-pr:`2629` - Move unordered_map out of parcelport into hpx/concurrent
* :hpx-pr:`2628` - Making sure that shutdown does not hang
* :hpx-pr:`2627` - Fix serialization
* :hpx-pr:`2626` - Generate ``cmake_variables.qbk`` and ``cmake_toolchains.qbk``
  outside of the source tree
* :hpx-pr:`2625` - Supporting -std=c++17 flag
* :hpx-pr:`2624` - Fixing a small cmake typo
* :hpx-pr:`2622` - Update CMake minimum required version to 3.0.2 (closes #2621)
* :hpx-issue:`2621` - Compiling hpx master fails with /usr/bin/ld: final link
  failed: Bad value
* :hpx-pr:`2620` - Remove warnings due to some captured variables
* :hpx-pr:`2619` - LF multiple parcels
* :hpx-pr:`2618` - Some fixes to libfabric that didn't get caught before the
  merge
* :hpx-pr:`2617` - Adding ``hpx::local_new``
* :hpx-pr:`2616` - Documentation: Extract all entities in order to autolink
  functions correctly
* :hpx-issue:`2615` - Documentation: Linking functions is broken
* :hpx-pr:`2614` - Adding serialization for std::deque
* :hpx-pr:`2613` - We need to link with boost.thread and boost.chrono if we use
  boost.context
* :hpx-pr:`2612` - Making sure for_loop_n(par, ...) is actually executed in
  parallel
* :hpx-pr:`2611` - Add documentation to invoke_fused and friends NFC
* :hpx-pr:`2610` - Added reduction templates using an identity value
* :hpx-pr:`2608` - Fixing some unused vars in inspect
* :hpx-pr:`2607` - Fixed build for mingw
* :hpx-pr:`2606` - Supporting generic context for boost >= 1.61
* :hpx-pr:`2605` - Parcelport libfabric3
* :hpx-pr:`2604` - Adding allocator support to promise and friends
* :hpx-pr:`2603` - Barrier hang
* :hpx-pr:`2602` - Changes to scheduler to steal from one high-priority queue
* :hpx-issue:`2601` - High priority tasks are not executed first
* :hpx-pr:`2600` - Compat fixes
* :hpx-pr:`2599` - Compatibility layer for threading support
* :hpx-pr:`2598` - V1.1
* :hpx-pr:`2597` - Release V1.0
* :hpx-pr:`2592` - First attempt to introduce spmd_block in hpx
* :hpx-pr:`2586` - local_segment in segmented_iterator_traits
* :hpx-issue:`2584` - Add allocator support to promise, packaged_task and
  friends
* :hpx-pr:`2576` - Add missing dependencies of cuda based tests
* :hpx-pr:`2575` - Remove warnings due to some captured variables
* :hpx-issue:`2574` - MSVC 2015 Compiler crash when building HPX
* :hpx-issue:`2568` - Remove throttle_scheduler as it has been abandoned
* :hpx-issue:`2566` - Add an inline versioning namespace before 1.0 release
* :hpx-issue:`2565` - Raise minimal cmake version requirement
* :hpx-pr:`2556` - Fixing scan partitioner
* :hpx-pr:`2546` - Broadcast async
* :hpx-issue:`2543` - make install fails due to a non-existing .so file
* :hpx-pr:`2495` - wait_or_add_new returning thread_id_type
* :hpx-issue:`2480` - Unable to register new performance counter
* :hpx-issue:`2471` - no type named 'fcontext_t' in namespace
* :hpx-issue:`2456` - Re-implement hpx::util::unwrapped
* :hpx-issue:`2455` - Add more arithmetic performance counters
* :hpx-pr:`2454` - Fix a couple of warnings and compiler errors
* :hpx-pr:`2453` - Timed executor support
* :hpx-pr:`2447` - Implementing new executor API (P0443)
* :hpx-issue:`2439` - Implement executor proposal
* :hpx-issue:`2408` - Stackoverflow detection for linux, e.g. based on
  libsigsegv
* :hpx-pr:`2377` - Add a customization point for put_parcel so we can override
  actions
* :hpx-issue:`2368` - HPX_ASSERT problem
* :hpx-issue:`2324` - Change default number of threads used to the maximum of
  the system
* :hpx-issue:`2266` - hpx_0.9.99 make tests fail
* :hpx-pr:`2195` - Support for code completion in VIM
* :hpx-issue:`2137` - Hpx does not compile over osx
* :hpx-issue:`2092` - make tests should just build the tests
* :hpx-issue:`2026` - Build HPX with Apple's clang
* :hpx-issue:`1932` - hpx with PBS fails on multiple localities
* :hpx-pr:`1914` - Parallel heap algorithm implementations WIP
* :hpx-issue:`1598` - Disconnecting a locality results in segfault using
  heartbeat example
* :hpx-issue:`1404` - unwrapped doesn't work with movable only types
* :hpx-issue:`1400` - hpx::util::unwrapped doesn't work with non-future types
* :hpx-issue:`1205` - TSS is broken
* :hpx-issue:`1126` - vector<future<T> > does not work gracefully with dataflow,
  when_all and unwrapped
* :hpx-issue:`1056` - Thread manager cleanup
* :hpx-issue:`863` - Futures should not require a default constructor
* :hpx-issue:`856` - Allow runtimemode_connect to be used with security enabled
* :hpx-issue:`726` - Valgrind
* :hpx-issue:`701` - Add RCR performance counter component
* :hpx-issue:`528` - Add support for known failures and warning
  count/comparisons to hpx_run_tests.py

..
    Copyright (C) 2007-2019 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_4_0:

===============================
|hpx| V1.4.0 (January 15, 2020)
===============================

General changes
===============

* We have added the collectives ``all_to_all`` and ``all_reduce``.
* We have added APIs for resiliency, which allows replication and replay for
  failed tasks. See the :ref:`documentation <modules_resiliency>` for more details.
* Components can now be checkpointed.
* Performance improvements to schedulers and coroutines. A significant change is
  the addition of stackless coroutines. These are to be used for tasks that do
  not need to be suspended and can reduce overheads noticeably in applications
  with short tasks. A stackless coroutine can be created with the new stack size
  ``thread_stacksize_nostack``.
* We have added an implementation of ``unique_any``, which is a non-copyable
  version of ``any``.
* The ``shared_priority_queue_scheduler`` has been improved. It now has lower
  overheads than the default scheduler in many situations. Unlike the default
  scheduler it fully supports NUMA scheduling hints. Enable it with the command
  line option :option:`--hpx:queuing`\ ``=shared-priority``. This scheduler
  should still be considered experimental, but its use is encouraged in real
  applications to help us make it production ready.
* We have added the performance counters ``background-receive-duration`` and
  ``background-receive-overhead`` for inspecting the time and overhead spent on
  receiving parcels in the background.
* Compilation time has been further improved when ``HPX_WITH_NETWORKING=OFF``.
* We no longer require compiled Boost dependencies in certain configurations.
  This requires at least Boost 1.70, compiling on x86 with GCC 9, clang (libc++)
  9, or VS2019 in C++17 mode. The dependency on Boost.Filesystem can explicitly
  be turned on with ``HPX_FILESYSTEM_WITH_BOOST_FILESYSTEM_COMPATIBILITY=ON``
  (it is off by default if the standard library supports ``std::filesystem``).
  Boost.ProgramOptions has been copied into the HPX repository. We have a
  compatibility layer for users who must explicitly use Boost.ProgramOptions
  instead of the ProgramOptions provided by HPX. To remove the dependency
  ``HPX_PROGRAM_OPTIONS_WITH_BOOST_PROGRAM_OPTIONS_COMPATIBILITY`` must be
  explicitly set to ``OFF``. This option will be removed in a future release. We
  have also removed several other header-only dependencies on Boost.
* It is now possible to use the process affinity mask set by tools like
  ``numactl`` and various batch environments with the command line option
  :option:`--hpx:use-process-mask`. Enabling this option implies
  :option:`--hpx:ignore-batch-env`.
* It is now possible to create standalone thread pools without starting the
  runtime. See the ``standalone_thread_pool_executor.cpp`` test in the
  ``execution`` module for an example.
* Tasks annotated with :cpp:func:`hpx::util::annotated_function` now have their
  correct name when using APEX to generate OTF2 files.
* Cloning of APEX was defective in previous releases (it required manual
  intervention to check out the correct tag or branch). This has been fixed.
* The option ``HPX_WITH_MORE_THAN_64_THREADS`` is now ignored and will be
  removed in a future release. The value is instead derived directly from
  ``HPX_WITH_MAX_CPU_COUNT`` option.
* We have deprecated compiling in C++11 mode. The next release will require a
  C++14 capable compiler.
* We have deprecated support for the Vc library. This option will be replaced
  with SIMD support from the standard library in a future release.
* We have significantly refactored our CMake setup. This is intended to be a
  non-breaking change and will allow for using HPX through CMake targets in the
  future.
* We have continued modularizing the HPX library. In the process we have
  rearranged many header files into module-specific directories. All moved
  headers have compatibility headers which forward from the old location to the
  new location, together with a deprecation warning. The compatibility headers
  will eventually be removed.
* We now enforce formatting with ``clang-format`` on the majority of our source
  files.
* We have added SPDX license tags to all files.
* Many bugfixes.

Breaking changes
================

* The ``HPX_WITH_THREAD_COMPATIBILITY`` option and the associated compatibility
  layer has been removed.
* The ``HPX_WITH_INCLUSIVE_SCAN_COMPATIBILITY`` option and the associated
  compatibility layer has been removed.
* The ``HPX_WITH_UNWRAPPED_COMPATIBLITY`` option and the associated
  compatibility layer has been removed.

Closed issues
=============

* :hpx-issue:`4282` - Build Issues with Release on Windows
* :hpx-issue:`4278` - Build Issues with CMake 3.14.4
* :hpx-issue:`4273` - Clients of HPX 1.4.0-rc2 with APEX ar not linked to
  libhpx-apex
* :hpx-issue:`4269` - Building HPX 1.4.0-rc2 with support for APEX fails
* :hpx-issue:`4263` - Compilation fail on latest master
* :hpx-issue:`4232` - Configure of HPX project using CMake FetchContent fails
* :hpx-issue:`4223` - "Re-using the main() function as the main HPX entry point"
  doesn't work
* :hpx-issue:`4220` - HPX won't compile - error building
  ``resource_partitioner``
* :hpx-issue:`4215` - HPX 1.4.0rc1 does not link on s390x
* :hpx-issue:`4204` - Trouble compiling HPX with Intel compiler
* :hpx-issue:`4199` - Refactor APEX to eliminate circular dependency
* :hpx-issue:`4187` - HPX can't build on OSX
* :hpx-issue:`4185` - Simple debug output for development
* :hpx-issue:`4182` - ``@HPX_CONF_PREFIX@`` is the empty string
* :hpx-issue:`4169` - HPX won't build with APEX
* :hpx-issue:`4163` - Add back ``HPX_LIBRARIES`` and ``HPX_INCLUDE_DIRS``
* :hpx-issue:`4161` - It should be possible to call ``find_package(HPX)``
  multiple times
* :hpx-issue:`4155` - ``get_self_id()`` for stackless threads returns
  ``invalid_thread_id``
* :hpx-issue:`4151` - build error with MPI code
* :hpx-issue:`4150` - hpx won't build on POWER9 with clang 8
* :hpx-issue:`4148` - ``cacheline_data`` delivers poor performance with C++17
  compared to C++14
* :hpx-issue:`4144` - target general in ``HPX_LIBRARIES`` does not exist
* :hpx-issue:`4134` - CMake Error when ``-DHPX_WITH_HPXMP=ON``
* :hpx-issue:`4132` - parallel fill leaves elements unfilled
* :hpx-issue:`4123` - PAPI performance counters are inaccessible
* :hpx-issue:`4118` - ``static_chunk_size`` is not obeyed in scan algorithms
* :hpx-issue:`4115` - dependency chaining error with APEX
* :hpx-issue:`4107` - Initializing runtime without entry point function and
  command line arguments
* :hpx-issue:`4105` - Bug in ``hpx:bind=numa-balanced``
* :hpx-issue:`4101` - Bound tasks
* :hpx-issue:`4100` - Add SPDX identifier to all files
* :hpx-issue:`4085` - ``hpx_topology`` library should depend on hwloc
* :hpx-issue:`4067` - HPX fails to build on macOS
* :hpx-issue:`4056` - Building without thread manager idle backoff fails
* :hpx-issue:`4052` - Enforce ``clang-format`` style for modules
* :hpx-issue:`4032` - Simple hello world fails to launch correctly
* :hpx-issue:`4030` - Allow threads to skip context switching
* :hpx-issue:`4029` - Add support for mimalloc
* :hpx-issue:`4005` - Can't link HPX when APEX enabled
* :hpx-issue:`4002` - Missing header for algorithm module
* :hpx-issue:`3989` - conversion from ``long`` to ``unsigned int`` requires a
  narrowing conversion on MSVC
* :hpx-issue:`3958` - ``/statistics/average@`` perf counter can't be created
* :hpx-issue:`3953` - CMake errors from ``HPX_AddPseudoDependencies``
* :hpx-issue:`3941` - CMake error for APEX install target
* :hpx-issue:`3940` - Convert pseudo-doxygen function documentation into actual
  doxygen documentation
* :hpx-issue:`3935` - HPX compiler match too strict?
* :hpx-issue:`3929` - Buildbot failures on latest HPX stable
* :hpx-issue:`3912` - I recommend publishing a version that does not depend on
  the boost library
* :hpx-issue:`3890` - ``hpx.ini`` not working
* :hpx-issue:`3883` - cuda compilation fails because of ``-faligned-new``
* :hpx-issue:`3879` - HPX fails to configure with ``-DHPX_WITH_TESTS=OFF``
* :hpx-issue:`3871` - ``dataflow`` does not support void allocators
* :hpx-issue:`3867` - Latest HTML docs placed in wrong directory on GitHub pages
* :hpx-issue:`3866` - Make sure all tests use ``HPX_TEST*`` macros and not
  ``HPX_ASSERT``
* :hpx-issue:`3857` - CMake all-keyword or all-plain for
  ``target_link_libraries``
* :hpx-issue:`3856` - ``hpx_setup_target`` adds rogue flags
* :hpx-issue:`3850` - HPX fails to build on POWER8 with Clang7
* :hpx-issue:`3848` - Remove ``lva`` member from ``thread_init_data``
* :hpx-issue:`3838` - ``hpx::parallel::count/count_if`` failing tests
* :hpx-issue:`3651` - ``hpx::parallel::transform_reduce`` with non const
  reference as lambda parameter
* :hpx-issue:`3560` - Apex integration with HPX not working properly
* :hpx-issue:`3322` - No warning when mixing debug/release builds

Closed pull requests
====================

* :hpx-pr:`4300` - Checks for ``MPI_Init`` being called twice
* :hpx-pr:`4299` - Small CMake fixes
* :hpx-pr:`4298` - Remove extra call to annotate function that messes up traces
* :hpx-pr:`4296` - Fixing collectives locking problem
* :hpx-pr:`4295` - Do not check ``LICENSE_1_0.txt`` for inspect violations
* :hpx-pr:`4293` - Applying two small changes fixing carious MSVC/Windows
  problems
* :hpx-pr:`4285` - Delete ``apex.hpp``
* :hpx-pr:`4276` - Disable doxygen generation for ``hpx/debugging/print.hpp``
  file
* :hpx-pr:`4275` - Make sure APEX is linked to even when not explicitly
  referenced
* :hpx-pr:`4272` - Fix pushing of documentation
* :hpx-pr:`4271` - Updating APEX tag, don't create new task_wrapper on
  ``operator=`` of hpx_thread object
* :hpx-pr:`4268` - Testing for noexcept function specializations in C++11/14
  mode
* :hpx-pr:`4267` - Fixing MSVC warning
* :hpx-pr:`4266` - Make sure macOS Travis CI fails if build step fails
* :hpx-pr:`4264` - Clean up compatibility header options
* :hpx-pr:`4262` - Cleanup modules ``CMakeLists.txt``
* :hpx-pr:`4261` - Fixing HPX/APEX linking and dependencies for external
  projects like Phylanx
* :hpx-pr:`4260` - Fix docs compilation problems
* :hpx-pr:`4258` - Couple of minor changes
* :hpx-pr:`4257` - Fix apex annotation for async dispatch
* :hpx-pr:`4256` - Remove lambdas from assert expressions
* :hpx-pr:`4255` - Ignoring lock in ``all_to_all`` and ``all_reduce``
* :hpx-pr:`4254` - Adding action specializations for noexcept functions
* :hpx-pr:`4253` - Move ``partlit.hpp`` to affinity module
* :hpx-pr:`4252` - Make mismatching build types a hard error in CMake
* :hpx-pr:`4249` - Scheduler improvement
* :hpx-pr:`4248` - update hpxmp tag to v0.3.0
* :hpx-pr:`4245` - Adding high performance channels
* :hpx-pr:`4244` - Ignore lock in ignore_while_locked_1485 test
* :hpx-pr:`4243` - Fix PAPI command line option documentation
* :hpx-pr:`4242` - Ignore lock in target_distribution_policy
* :hpx-pr:`4241` - Fix ``start_stop_callbacks`` test
* :hpx-pr:`4240` - Mostly fix clang CUDA compilation
* :hpx-pr:`4238` - Google Season of Docs updates to documentation; grammar
  edits.
* :hpx-pr:`4237` - fixing annotated task to use the name, not the desc
* :hpx-pr:`4236` - Move module print summary to modules
* :hpx-pr:`4235` - Don't use alignas in ``cache_{aligned,line}_data``
* :hpx-pr:`4234` - Add basic overview sentence to all modules
* :hpx-pr:`4230` - Add OS X builds to Travis CI
* :hpx-pr:`4229` - Remove leftover queue compatibility checks
* :hpx-pr:`4226` - Fixing APEX shutdown by explicitly shutting down throttling
* :hpx-pr:`4225` - Allow ``CMAKE_INSTALL_PREFIX`` to be a relative path
* :hpx-pr:`4224` - Deprecate verbs parcelport
* :hpx-pr:`4222` - Update ``register_{thread,work}`` namespaces
* :hpx-pr:`4221` - Changing ``HPX_GCC_VERSION`` check from ``70000`` to
  ``70300``
* :hpx-pr:`4218` - Google Season of Docs updates to documentation; grammar
  edits.
* :hpx-pr:`4217` - Google Season of Docs updates to documentation; grammar
  edits.
* :hpx-pr:`4216` - Fixing gcc warning on 32bit platforms (integer truncation)
* :hpx-pr:`4214` - Apex callback refactoring
* :hpx-pr:`4213` - Clean up allocator checks for dependent projects
* :hpx-pr:`4212` - Google Season of Docs updates to documentation; grammar
  edits.
* :hpx-pr:`4211` - Google Season of Docs updates to documentation; contributing
  to hpx
* :hpx-pr:`4210` - Attempting to fix Intel compilation
* :hpx-pr:`4209` - Fix CUDA 10 build
* :hpx-pr:`4205` - Making sure that differences in ``CMAKE_BUILD_TYPE`` are not
  reported on multi-configuration cmake generators
* :hpx-pr:`4203` - Deprecate Vc
* :hpx-pr:`4202` - Fix CUDA configuration
* :hpx-pr:`4200` - Making sure ``hpx_wrap`` is not passed on to linker on
  non-Linux systems
* :hpx-pr:`4198` - Fix ``execution_agent.cpp`` compilation with GCC 5
* :hpx-pr:`4197` - Remove deprecated options for 1.4.0 release
* :hpx-pr:`4196` - minor fixes for building on OSX Darwin
* :hpx-pr:`4195` - Use full clone on CircleCI for pushing stable tag
* :hpx-pr:`4193` - Add scheduling hints to hello_world_distributed
* :hpx-pr:`4192` - Set up CUDA in HPXConfig.cmake
* :hpx-pr:`4191` - Export allocators root variables
* :hpx-pr:`4190` - Don't use ``constexpr`` in ``thread_data`` with GCC <= 6
* :hpx-pr:`4189` - Only use ``quick_exit`` if available
* :hpx-pr:`4188` - Google Season of Docs updates to documentation; writing
  single node hpx applications
* :hpx-pr:`4186` - correct vc to cuda in cuda cmake
* :hpx-pr:`4184` - Resetting some cached variables to make sure those are
  re-filled
* :hpx-pr:`4183` - Fix ``hpxcxx`` configuration
* :hpx-pr:`4181` - Rename base libraries var
* :hpx-pr:`4180` - Move header left behind earlier to plugin module
* :hpx-pr:`4179` - Moving ``zip_iterator`` and ``transform_iterator`` to
  iterator_support module
* :hpx-pr:`4178` - Move checkpointing support to its own module
* :hpx-pr:`4177` - Small const fix to ``basic_execution`` module
* :hpx-pr:`4176` - Add back ``HPX_LIBRARIES`` and friends to ``HPXConfig.cmake``
* :hpx-pr:`4175` - Make Vc public and add it to ``HPXConfig.cmake``
* :hpx-pr:`4173` - Wait for runtime to be running before returning from
  hpx::start
* :hpx-pr:`4172` - More protection against shutdown problems in error handling
  scenarios.
* :hpx-pr:`4171` - Ignore lock in ``condition_variable::wait``
* :hpx-pr:`4170` - Adding APEX dependency to MPI parcelport
* :hpx-pr:`4168` - Adding utility include
* :hpx-pr:`4167` - Add a condition to setup the external libraries
* :hpx-pr:`4166` - Add an ``INTERNAL_FLAGS`` option to link to
  ``hpx_internal_flags``
* :hpx-pr:`4165` - Forward ``HPX_*`` cmake cache variables to external projects
* :hpx-pr:`4164` - Affinity and batch environment modules
* :hpx-pr:`4162` - Handle ``quick exit``
* :hpx-pr:`4160` - Using ``target_link_libraries`` for cmake versions >= 3.12
* :hpx-pr:`4159` - Make sure ``HPX_WITH_NATIVE_TLS`` is forwarded to dependent
  projects
* :hpx-pr:`4158` - Adding allocator imported target as a dependency of allocator
  module
* :hpx-pr:`4157` - Add ``hpx_memory`` as a dependency of parcelport plugins
* :hpx-pr:`4156` - Stackless coroutines now can refer to themselves (through
  get_self() and friends)
* :hpx-pr:`4154` - Added CMake policy CMP0060 for HPX applications.
* :hpx-pr:`4153` - add header ``iomanip`` to tests and tool
* :hpx-pr:`4152` - Casting MPI tag value
* :hpx-pr:`4149` - Add back private ``m_desc`` member variable in
  program_options module
* :hpx-pr:`4147` - Resource partitioner and threadmanager modules
* :hpx-pr:`4146` - Google Season of Docs updates to documentation; creating hpx
  projects
* :hpx-pr:`4145` - Adding basic support for stackless threads
* :hpx-pr:`4143` - Exclude ``test_client_1950`` from all target
* :hpx-pr:`4142` - Add a new ``thread_pool_executor``
* :hpx-pr:`4140` - Google Season of Docs updates to documentation; why hpx
* :hpx-pr:`4139` - Remove runtime includes from coroutines module
* :hpx-pr:`4138` - Forking ``boost::intrusive_ptr`` and adding it as
  ``hpx::intrusive_ptr``
* :hpx-pr:`4137` - Fixing TSS destruction
* :hpx-pr:`4136` - HPX.Compute modules
* :hpx-pr:`4133` - Fix ``block_executor``
* :hpx-pr:`4131` - Applying fixes based on reports from PVS Studio
* :hpx-pr:`4130` - Adding missing header to build system
* :hpx-pr:`4129` - Fixing compilation if ``HPX_WITH_DATAPAR_VC`` is enabled
* :hpx-pr:`4128` - Renaming ``moveonly_any`` to ``unique_any``
* :hpx-pr:`4126` - Attempt to fix ``basic_any`` constructor for gcc 7
* :hpx-pr:`4125` - Changing ``extra_archive_data`` implementation
* :hpx-pr:`4124` - Don't link to Boost.System unless required
* :hpx-pr:`4122` - Add kernel launch helper utility (+saxpy demo) and merge in
  octotiger changes
* :hpx-pr:`4121` - Fixing migration test if networking is disabled.
* :hpx-pr:`4120` - Google Season of Docs updates to documentation; hpx build
  system v1
* :hpx-pr:`4119` - Making sure ``chunk_size`` and ``max_chunk`` are actually
  applied to parallel algorithms if specified
* :hpx-pr:`4117` - Make CircleCI formatting check store diff
* :hpx-pr:`4116` - Fix automatically setting C++ standard
* :hpx-pr:`4114` - Module serialization
* :hpx-pr:`4113` - Module datastructures
* :hpx-pr:`4111` - Fixing performance regression introduced earlier
* :hpx-pr:`4110` - Adding missing SPDX tags
* :hpx-pr:`4109` - Overload for start without entry point/argv.
* :hpx-pr:`4108` - Making sure C++ standard is properly detected and propagated
* :hpx-pr:`4106` - use ``std::round`` for guaranteed rounding without errors
* :hpx-pr:`4104` - Extend ``scheduler_mode`` with new ``work_stealing`` and task
  assignment modes
* :hpx-pr:`4103` - Add this to lambda capture list
* :hpx-pr:`4102` - Add spdx license and check
* :hpx-pr:`4099` - Module coroutines
* :hpx-pr:`4098` - Fix append module path in module CMakeLists template
* :hpx-pr:`4097` - Function tests
* :hpx-pr:`4096` - Removing return of ``thread_result_type`` from functions not
  needing them
* :hpx-pr:`4095` - Stop-gap measure until cmake overhaul is in place
* :hpx-pr:`4094` - Deprecate ``HPX_WITH_MORE_THAN_64_THREADS``
* :hpx-pr:`4093` - Fix initialization of ``global_num_tasks`` in
  ``parallel_executor``
* :hpx-pr:`4092` - Add support for mi-malloc
* :hpx-pr:`4090` - Execution context
* :hpx-pr:`4089` - Make counters in coroutines optional
* :hpx-pr:`4087` - Making ``hpx::util::any`` compatible with C++17
* :hpx-pr:`4084` - Making sure destination array for ``std::transform`` is
  properly resized
* :hpx-pr:`4083` - Adapting ``thread_queue_mc`` to behave even if no 128bit
  atomics are available
* :hpx-pr:`4082` - Fix compilation on GCC 5
* :hpx-pr:`4081` - Adding option allowing to force using Boost.FileSystem
* :hpx-pr:`4080` - Updating module dependencies
* :hpx-pr:`4079` - Add missing tests for iterator_support module
* :hpx-pr:`4078` - Disable parcel-layer if networking is disabled
* :hpx-pr:`4077` - Add missing include that causes build fails
* :hpx-pr:`4076` - Enable compatibility headers for functional module
* :hpx-pr:`4075` - Coroutines module
* :hpx-pr:`4073` - Use ``configure_file`` for generated files in modules
* :hpx-pr:`4071` - Fixing MPI detection for PMIx
* :hpx-pr:`4070` - Fix macOS builds
* :hpx-pr:`4069` - Moving more facilities to the collectives module
* :hpx-pr:`4068` - Adding main HPX ``#include`` directory to modules
* :hpx-pr:`4066` - Switching the use of ``message(STATUS "...")`` to hpx_info
* :hpx-pr:`4065` - Move Boost.Filesystem handling to filesystem module
* :hpx-pr:`4064` - Fix program_options test with older boost versions
* :hpx-pr:`4062` - The ``cpu_features`` tool fails to compile on anything but
  x86 architectures
* :hpx-pr:`4061` - Add ``clang-format`` checking step for modules
* :hpx-pr:`4060` - Making sure ``HPX_IDLE_BACKOFF_TIME_MAX`` is always defined
  (even if its unused)
* :hpx-pr:`4059` - Renaming module ``hpx_parallel_executors`` into
  ``hpx_execution``
* :hpx-pr:`4058` - Do not build networking tests when networking disabled
* :hpx-pr:`4057` - Printing configuration summary for modules as well
* :hpx-pr:`4055` - Google Season of Docs updates to documentation; hpx build
  systems
* :hpx-pr:`4054` - Add troubleshooting section to manual
* :hpx-pr:`4051` - Add more variations to ``future_overhead`` test
* :hpx-pr:`4050` - Creating plugin module
* :hpx-pr:`4049` - Move missing modules tests
* :hpx-pr:`4047` - Add boost/filesystem headers to inspect deprecated headers
* :hpx-pr:`4045` - Module functional
* :hpx-pr:`4043` - Fix preconditions and error messages for suspension functions
* :hpx-pr:`4041` - Pass HPX_STANDARD on to dependent projects via
  HPXConfig.cmake
* :hpx-pr:`4040` - Program options module
* :hpx-pr:`4039` - Moving non-serializable ``any`` (``any_nonser``) to
  datastructures module
* :hpx-pr:`4038` - Adding MPark's variant (V1.4.0) to HPX
* :hpx-pr:`4037` - Adding resiliency module
* :hpx-pr:`4036` - Add C++17 filesystem compatibility header
* :hpx-pr:`4035` - Fixing support for mpirun
* :hpx-pr:`4028` - CMake to target based directives
* :hpx-pr:`4027` - Remove GitLab CI configuration
* :hpx-pr:`4026` - Threading refactoring
* :hpx-pr:`4025` - Refactoring thread queue configuration options
* :hpx-pr:`4024` - Fix padding calculation in ``cache_aligned_data.hpp``
* :hpx-pr:`4023` - Fixing Codacy issues
* :hpx-pr:`4022` - Make sure process mask option is passed to ``affinity_data``
* :hpx-pr:`4021` - Warn about compiling in C++11 mode
* :hpx-pr:`4020` - Module concurrency
* :hpx-pr:`4019` - Module topology
* :hpx-pr:`4018` - Update deprecated header in ``thread_queue_mc.hpp``
* :hpx-pr:`4015` - Avoid overwriting artifacts
* :hpx-pr:`4014` - Future overheads
* :hpx-pr:`4013` - Update URL to test output conversion script
* :hpx-pr:`4012` - Fix CUDA compilation
* :hpx-pr:`4011` - Fixing cyclic dependencies between modules
* :hpx-pr:`4010` - Ignore stable tag on CircleCI
* :hpx-pr:`4009` - Check circular dependencies in a circle ci step
* :hpx-pr:`4008` - Extend cache aligned data to handle tuple-like data
* :hpx-pr:`4007` - Fixing migration for components that have actions returning a
  client
* :hpx-pr:`4006` - Move is_value_proxy.hpp to algorithms module
* :hpx-pr:`4004` - Shorten CTest timeout on CircleCI
* :hpx-pr:`4003` - Refactoring to remove (internal) dependencies
* :hpx-pr:`4001` - Exclude tests from all target
* :hpx-pr:`4000` - Module errors
* :hpx-pr:`3999` - Enable support for compatibility headers for logging module
* :hpx-pr:`3998` - Add process thread binding option
* :hpx-pr:`3997` - Export handle_assert function
* :hpx-pr:`3996` - Attempt to solve issue where ``-latomic`` does not support
  128bit atomics
* :hpx-pr:`3993` - Make sure ``__LINE__`` is an unsigned
* :hpx-pr:`3991` - Fix dependencies and flags for header tests
* :hpx-pr:`3990` - Documentation tags fixes
* :hpx-pr:`3988` - Adding missing solution folder for format module test
* :hpx-pr:`3987` - Move runtime-dependent functions out of command line handling
* :hpx-pr:`3986` - Fix CMake configuration with PAPI on
* :hpx-pr:`3985` - Module timing
* :hpx-pr:`3984` - Fix default behaviour of paths in ``add_hpx_component``
* :hpx-pr:`3982` - Parallel executors module
* :hpx-pr:`3981` - Segmented algorithms module
* :hpx-pr:`3980` - Module logging
* :hpx-pr:`3979` - Module util
* :hpx-pr:`3978` - Fix ``clang-tidy`` step on CircleCI
* :hpx-pr:`3977` - Fixing solution folders for moved components
* :hpx-pr:`3976` - Module format
* :hpx-pr:`3975` - Enable deprecation warnings on CircleCI
* :hpx-pr:`3974` - Fix typos in documentation
* :hpx-pr:`3973` - Fix compilation with GCC 9
* :hpx-pr:`3972` - Add condition to clone apex + use of new cmake var APEX_ROOT
* :hpx-pr:`3971` - Add testing module
* :hpx-pr:`3968` - Remove unneeded file in hardware module
* :hpx-pr:`3967` - Remove leftover PIC settings from main CMakeLists.txt
* :hpx-pr:`3966` - Add missing export option in ``add_hpx_module``
* :hpx-pr:`3965` - Change ``current_function_helper`` back to non-constexpr
* :hpx-pr:`3964` - Fixing merge problems
* :hpx-pr:`3962` - Add a trait for ``std::array`` for unwrapping
* :hpx-pr:`3961` - Making ``hpx::util::tuple<Ts...>`` and ``std::tuple<Ts...>``
  convertible
* :hpx-pr:`3960` - fix compilation with CUDA 10 and GCC 6
* :hpx-pr:`3959` - Fix C++11 incompatibility
* :hpx-pr:`3957` - Algorithms module
* :hpx-pr:`3956` - [``HPX_AddModule``] Fix lower name var to upper
* :hpx-pr:`3955` - Fix CMake configuration with examples off and tests on
* :hpx-pr:`3954` - Move components to separate subdirectory in root of
  repository
* :hpx-pr:`3952` - Update ``papi.cpp``
* :hpx-pr:`3951` - Exclude modules header tests from all target
* :hpx-pr:`3950` - Adding ``all_reduce`` facility to collectives module
* :hpx-pr:`3949` - This adds a configuration file that will cause for stale
  issues to be automatically closed
* :hpx-pr:`3948` - Fixing ALPS environment
* :hpx-pr:`3947` - Add major compiler version check for building hpx as a binary
  package
* :hpx-pr:`3946` - [Modules] Move the location of the generated headers
* :hpx-pr:`3945` - Simplify tests and examples cmake
* :hpx-pr:`3943` - Remove example module
* :hpx-pr:`3942` - Add ``NOEXPORT`` option to ``add_hpx_{component,library}``
* :hpx-pr:`3938` - Use https for CDash submissions
* :hpx-pr:`3937` - Add ``HPX_WITH_BUILD_BINARY_PACKAGE`` to the compiler check
  (refs #3935)
* :hpx-pr:`3936` - Fixing installation of binaries on windows
* :hpx-pr:`3934` - Add set function for ``sliding_semaphore`` ``max_difference``
* :hpx-pr:`3933` - Remove ``cudadevrt`` from compile/link flags as it breaks
  downstream projects
* :hpx-pr:`3932` - Fixing 3929
* :hpx-pr:`3931` - Adding ``all_to_all``
* :hpx-pr:`3930` - Add test demonstrating the use of broadcast with component
  actions
* :hpx-pr:`3928` - fixed number of tasks and number of threads for heterogeneous
  slurm environments
* :hpx-pr:`3927` - Moving Cache module's tests into separate solution folder
* :hpx-pr:`3926` - Move unit tests to cache module
* :hpx-pr:`3925` - Move version check to config module
* :hpx-pr:`3924` - Add schedule hint executor parameters
* :hpx-pr:`3923` - Allow aligning objects bigger than the cache line size
* :hpx-pr:`3922` - Add Windows builds with Travis CI
* :hpx-pr:`3921` - Add ccls cache directory to gitignore
* :hpx-pr:`3920` - Fix ``git_external`` fetching of tags
* :hpx-pr:`3905` - Correct rostambod url. Fix typo in doc
* :hpx-pr:`3904` - Fix bug in context_base.hpp
* :hpx-pr:`3903` - Adding new performance counters
* :hpx-pr:`3902` - Add ``add_hpx_module`` function
* :hpx-pr:`3901` - Factoring out container remapping into a separate trait
* :hpx-pr:`3900` - Making sure errors during command line processing are
  properly reported and will not cause assertions
* :hpx-pr:`3899` - Remove old compatibility bases from ``make_action``
* :hpx-pr:`3898` - Make parameter size be of type ``size_t``
* :hpx-pr:`3897` - Making sure all tests are disabled if ``HPX_WITH_TESTS=OFF``
* :hpx-pr:`3895` - Add documentation for annotated_function
* :hpx-pr:`3894` - Working around VS2019 problem with ``make_action``
* :hpx-pr:`3892` - Avoid MSVC compatibility warning in internal allocator
* :hpx-pr:`3891` - Removal of the default intel config include
* :hpx-pr:`3888` - Fix ``async_customization`` dataflow example and Clarify
  what's being tested
* :hpx-pr:`3887` - Add Doxygen documentation
* :hpx-pr:`3882` - Minor docs fixes
* :hpx-pr:`3880` - Updating APEX version tag
* :hpx-pr:`3878` - Making sure symbols are properly exported from modules
  (needed for Windows/MacOS)
* :hpx-pr:`3877` - Documentation
* :hpx-pr:`3876` - Module hardware
* :hpx-pr:`3875` - Converted typedefs in actions submodule to using directives
* :hpx-pr:`3874` - Allow one to suppress target keywords in ``hpx_setup_target``
  for backwards compatibility
* :hpx-pr:`3873` - Add scripts to create releases and generate lists of PRs and
  issues
* :hpx-pr:`3872` - Fix latest HTML docs location
* :hpx-pr:`3870` - Module cache
* :hpx-pr:`3869` - Post 1.3.0 version bumps
* :hpx-pr:`3868` - Replace the macro ``HPX_ASSERT`` by ``HPX_TEST`` in tests
* :hpx-pr:`3845` - Assertion module
* :hpx-pr:`3839` - Make tuple serialization non-intrusive
* :hpx-pr:`3832` - Config module
* :hpx-pr:`3799` - Remove compat namespace and its contents
* :hpx-pr:`3701` - MoodyCamel lockfree
* :hpx-pr:`3496` - Disabling MPI's (deprecated) C++ interface
* :hpx-pr:`3192` - Move type info into ``hpx::debug`` namespace and add print
  helper functions
* :hpx-pr:`3159` - Support Checkpointing Components
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_5:

===========================
|hpx| V0.9.5 (Jan 16, 2013)
===========================

We have had over 1000 commits since the last release and we have closed roughly
150 tickets (bugs, feature requests, etc.).

General changes
===============

This release is continuing along the lines of code and API consolidation, and
overall usability inprovements. We dedicated much attention to performance and
we were able to significantly improve the threading and networking subsystems.

We successfully ported |hpx| to the Android platform. |hpx| applications now not
only can run on mobile devices, but we support heterogeneous applications
running across architecture boundaries. At the Supercomputing Conference 2012 we
demonstrated connecting Android tablets to simulations running on a Linux
cluster. The Android tablet was used to query performance counters from the
Linux simulation and to steer its parameters.

We successfully ported |hpx| to Mac OSX (using the Clang compiler). Thanks to
Pyry Jahkola for contributing the corresponding patches. Please see the section
:ref:`macos_installation` for more details.

We made a special effort to make HPX usable in highly concurrent use cases. Many
of the HPX API functions which possibly take longer than 100 microseconds to
execute now can be invoked asynchronously. We added uniform support for
composing futures which simplifies to write asynchronous code. HPX actions
(function objects encapsulating possibly concurrent remote function invocations)
are now well integrated with all other API facilities such like ``hpx::bind``.

All of the API has been aligned as much as possible with established paradigms.
HPX now mirrors many of the facilities as defined in the |cpp11|, such as
``hpx::thread``, ``hpx::function``, ``hpx::future``, etc.

A lot of work has been put into improving the documentation. Many of the API
functions are documented now, concepts are explained in detail, and examples are
better described than before. The new documentation index enables finding
information with lesser effort.

This is the first release of HPX we perform after the move to |hpx_github|_ This
step has enabled a wider participation from the community and further encourages
us in our decision to release HPX as a true open source library (HPX is licensed
under the very liberal |boost_license|_).

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release. This is by
far the longest list of newly implemented features and fixed issues for any of
HPX' releases so far.

* :hpx-issue:`666` - Segfault on calling hpx::finalize twice
* :hpx-issue:`665` - Adding declaration num_of_cores
* :hpx-issue:`662` - pkgconfig is building wrong
* :hpx-issue:`660` - Need uninterrupt function
* :hpx-issue:`659` - Move our logging library into a different namespace
* :hpx-issue:`658` - Dynamic performance counter types are broken
* :hpx-issue:`657` - HPX v0.9.5 (RC1) hello_world example segfaulting
* :hpx-issue:`656` - Define the affinity of parcel-pool, io-pool, and timer-pool
  threads
* :hpx-issue:`654` - Integrate the Boost auto_index tool with documentation
* :hpx-issue:`653` - Make HPX build on OS X + Clang + libc++
* :hpx-issue:`651` - Add fine-grained control for thread pinning
* :hpx-issue:`650` - Command line no error message when using -hpx:(anything)
* :hpx-issue:`645` - Command line aliases don't work in [teletype]``@file``[c++]
* :hpx-issue:`644` - Terminated threads are not always properly cleaned up
* :hpx-issue:`640` - ``future_data<T>::set_on_completed_`` used without locks
* :hpx-issue:`638` - hpx build with intel compilers fails on linux
* :hpx-issue:`637` - --copy-dt-needed-entries breaks with gold
* :hpx-issue:`635` - Boost V1.53 will add Boost.Lockfree and Boost.Atomic
* :hpx-issue:`633` - Re-add examples to final 0.9.5 release
* :hpx-issue:`632` - Example ``thread_aware_timer`` is broken
* :hpx-issue:`631` - FFT application throws error in parcellayer
* :hpx-issue:`630` - Event synchronization example is broken
* :hpx-issue:`629` - Waiting on futures hangs
* :hpx-issue:`628` - Add an ``HPX_ALWAYS_ASSERT`` macro
* :hpx-issue:`625` - Port coroutines context switch benchmark
* :hpx-issue:`621` - New INI section for stack sizes
* :hpx-issue:`618` - pkg_config support does not work with a HPX debug build
* :hpx-issue:`617` -
  hpx/external/logging/boost/logging/detail/cache_before_init.hpp:139:67: error:
  'get_thread_id' was not declared in this scope
* :hpx-issue:`616` - Change wait_xxx not to use locking
* :hpx-issue:`615` - Revert visibility 'fix'
  (fb0b6b8245dad1127b0c25ebafd9386b3945cca9)
* :hpx-issue:`614` - Fix Dataflow linker error
* :hpx-issue:`613` - find_here should throw an exception on failure
* :hpx-issue:`612` - Thread phase doesn't show up in debug mode
* :hpx-issue:`611` - Make stack guard pages configurable at runtime
  (initialization time)
* :hpx-issue:`610` - Co-Locate Components
* :hpx-issue:`609` - future_overhead
* :hpx-issue:`608` - ``--hpx:list-counter-infos`` problem
* :hpx-issue:`607` - Update Boost.Context based backend for coroutines
* :hpx-issue:`606` - 1d_wave_equation is not working
* :hpx-issue:`605` - Any C++ function that has serializable arguments and a
  serializable return type should be remotable
* :hpx-issue:`604` - Connecting localities isn't working anymore
* :hpx-issue:`603` - Do not verify any ini entries read from a file
* :hpx-issue:`602` - Rename argument_size to type_size/ added implementation to
  get parcel size
* :hpx-issue:`599` - Enable locality specific command line options
* :hpx-issue:`598` - Need an API that accesses the performance counter reporting
  the system uptime
* :hpx-issue:`597` - compiling on ranger
* :hpx-issue:`595` - I need a place to store data in a thread self pointer
* :hpx-issue:`594` - 32/64 interoperability
* :hpx-issue:`593` - Warn if logging is disabled at compile time but requested
  at runtime
* :hpx-issue:`592` - Add optional argument value to ``--hpx:list-counters`` and
  ``--hpx:list-counter-infos``
* :hpx-issue:`591` - Allow for wildcards in performance counter names specified
  with ``--hpx:print-counter``
* :hpx-issue:`590` - Local promise semantic differences
* :hpx-issue:`589` - Create API to query performance counter names
* :hpx-issue:`587` - Add get_num_localities and get_num_threads to AGAS API
* :hpx-issue:`586` - Adjust local AGAS cache size based on number of localities
* :hpx-issue:`585` - Error while using counters in HPX
* :hpx-issue:`584` - counting argument size of actions, initial pass.
* :hpx-issue:`581` - Remove ``RemoteResult`` template parameter for ``future<>``
* :hpx-issue:`580` - Add possibility to hook into actions
* :hpx-issue:`578` - Use angle brackets in HPX error dumps
* :hpx-issue:`576` - Exception incorrectly thrown when ``--help`` is used
* :hpx-issue:`575` - HPX(bad_component_type) with gcc 4.7.2 and boost 1.51
* :hpx-issue:`574` - ``--hpx:connect`` command line parameter not working
  correctly
* :hpx-issue:`571` - ``hpx::wait()`` (callback version) should pass the future
  to the callback function
* :hpx-issue:`570` - ``hpx::wait`` should operate on ``boost::arrays`` and
  ``std::lists``
* :hpx-issue:`569` - Add a logging sink for Android
* :hpx-issue:`568` - 2-argument version of ``HPX_DEFINE_COMPONENT_ACTION``
* :hpx-issue:`567` - Connecting to a running HPX application works only once
* :hpx-issue:`565` - HPX doesn't shutdown properly
* :hpx-issue:`564` - Partial preprocessing of new component creation interface
* :hpx-issue:`563` - Add ``hpx::start``/``hpx::stop`` to avoid blocking main
  thread
* :hpx-issue:`562` - All command line arguments swallowed by hpx
* :hpx-issue:`561` - Boost.Tuple is not move aware
* :hpx-issue:`558` - ``boost::shared_ptr<>`` style semantics/syntax for client
  classes
* :hpx-issue:`556` - Creation of partially preprocessed headers should be
  enabled for Boost newer than V1.50
* :hpx-issue:`555` - ``BOOST_FORCEINLINE`` does not name a type
* :hpx-issue:`554` - Possible race condition in thread ``get_id()``
* :hpx-issue:`552` - Move enable client_base
* :hpx-issue:`550` - Add stack size category 'huge'
* :hpx-issue:`549` - ShenEOS run seg-faults on single or distributed runs
* :hpx-issue:`545` - ``AUTOGLOB`` broken for add_hpx_component
* :hpx-issue:`542` - FindHPX_HDF5 still searches multiple times
* :hpx-issue:`541` - Quotes around application name in hpx::init
* :hpx-issue:`539` - Race conditition occurring with new lightweight threads
* :hpx-issue:`535` - hpx_run_tests.py exits with no error code when tests are
  missing
* :hpx-issue:`530` - Thread description(<unknown>) in logs
* :hpx-issue:`523` - Make thread objects more lightweight
* :hpx-issue:`521` - ``hpx::error_code`` is not usable for lightweight error
  handling
* :hpx-issue:`520` - Add full user environment to HPX logs
* :hpx-issue:`519` - Build succeeds, running fails
* :hpx-issue:`517` - Add a guard page to linux coroutine stacks
* :hpx-issue:`516` - hpx::thread::detach suspends while holding locks, leads to
  hang in debug
* :hpx-issue:`514` - Preprocessed headers for <hpx/apply.hpp> don't compile
* :hpx-issue:`513` - Buildbot configuration problem
* :hpx-issue:`512` - Implement action based stack size customization
* :hpx-issue:`511` - Move action priority into a separate type trait
* :hpx-issue:`510` - trunk broken
* :hpx-issue:`507` - no matching function for call to
  ``boost::scoped_ptr<hpx::threads::topology>::scoped_ptr(hpx::threads::linux_topology*)``
* :hpx-issue:`505` - undefined_symbol regression test currently failing
* :hpx-issue:`502` - Adding OpenCL and OCLM support to HPX for Windows and Linux
* :hpx-issue:`501` - find_package(HPX) sets cmake output variables
* :hpx-issue:`500` - wait_any/wait_all are badly named
* :hpx-issue:`499` - Add support for disabling pbs support in pbs runs
* :hpx-issue:`498` - Error during no-cache runs
* :hpx-issue:`496` - Add partial preprocessing support to cmake
* :hpx-issue:`495` - Support HPX modules exporting startup/shutdown functions
  only
* :hpx-issue:`494` - Allow modules to specify when to run startup/shutdown
  functions
* :hpx-issue:`493` - Avoid constructing a string in make_success_code
* :hpx-issue:`492` - Performance counter creation is no longer synchronized at
  startup
* :hpx-issue:`491` - Performance counter creation is no longer synchronized at
  startup
* :hpx-issue:`490` - Sheneos on_completed_bulk seg fault in distributed
* :hpx-issue:`489` - compiling issue with g++44
* :hpx-issue:`488` - Adding OpenCL and OCLM support to HPX for the MSVC platform
* :hpx-issue:`487` - FindHPX.cmake problems
* :hpx-issue:`485` - Change distributing_factory and binpacking_factory to use
  bulk creation
* :hpx-issue:`484` - Change ``HPX_DONT_USE_PREPROCESSED_FILES`` to
  ``HPX_USE_PREPROCESSED_FILES``
* :hpx-issue:`483` - Memory counter for Windows
* :hpx-issue:`479` - strange errors appear when requesting performance counters
  on multiple nodes
* :hpx-issue:`477` - Create (global) timer for multi-threaded measurements
* :hpx-issue:`472` - Add partial preprocessing using Wave
* :hpx-issue:`471` - Segfault stack traces don't show up in release
* :hpx-issue:`468` - External projects need to link with internal components
* :hpx-issue:`462` - Startup/shutdown functions are called more than once
* :hpx-issue:`458` - Consolidate hpx::util::high_resolution_timer and
  ``hpx::util::high_resolution_clock``
* :hpx-issue:`457` - index out of bounds in ``allgather_and_gate`` on 4 cores or
  more
* :hpx-issue:`448` - Make HPX compile with clang
* :hpx-issue:`447` - 'make tests' should execute tests on local installation
* :hpx-issue:`446` - Remove SVN-related code from the codebase
* :hpx-issue:`444` - race condition in smp
* :hpx-issue:`441` - Patched Boost.Serialization headers should only be
  installed if needed
* :hpx-issue:`439` - Components using ``HPX_REGISTER_STARTUP_MODULE`` fail to
  compile with MSVC
* :hpx-issue:`436` - Verify that no locks are being held while threads are
  suspended
* :hpx-issue:`435` - Installing HPX should not clobber existing Boost
  installation
* :hpx-issue:`434` - Logging external component failed (Boost 1.50)
* :hpx-issue:`433` - Runtime crash when building all examples
* :hpx-issue:`432` - Dataflow hangs on 512 cores/64 nodes
* :hpx-issue:`430` - Problem with distributing factory
* :hpx-issue:`424` - File paths referring to XSL-files need to be properly
  escaped
* :hpx-issue:`417` - Make dataflow LCOs work out of the box by using partial
  preprocessing
* :hpx-issue:`413` - hpx_svnversion.py fails on Windows
* :hpx-issue:`412` - Make hpx::error_code equivalent to hpx::exception
* :hpx-issue:`398` - HPX clobbers out-of-tree application specific CMake
  variables (specifically ``CMAKE_BUILD_TYPE``)
* :hpx-issue:`394` - Remove code generating random port numbers for network
* :hpx-issue:`378` - ShenEOS scaling issues
* :hpx-issue:`354` - Create a coroutines wrapper for Boost.Context
* :hpx-issue:`349` - Commandline option ``--localities=N/-lN`` should be
  necessary only on AGAS locality
* :hpx-issue:`334` - Add auto_index support to cmake based documentation
  toolchain
* :hpx-issue:`318` - Network benchmarks
* :hpx-issue:`317` - Implement network performance counters
* :hpx-issue:`310` - Duplicate logging entries
* :hpx-issue:`230` - Add compile time option to disable thread debugging info
* :hpx-issue:`171` - Add an INI option to turn off deadlock detection
  independently of logging
* :hpx-issue:`170` - OSHL internal counters are incorrect
* :hpx-issue:`103` - Better diagnostics for multiple component/action
  registerations under the same name
* :hpx-issue:`48` - Support for Darwin (Xcode + Clang)
* :hpx-issue:`21` - Build fails with GCC 4.6

..
    Copyright (C) 2007-2019 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_3_0:

===========================
|hpx| V1.3.0 (May 23, 2019)
===========================

General changes
===============

* Performance improvements: the schedulers have significantly reduced overheads
  from removing false sharing and the parallel executor has been updated to
  create fewer futures.
* HPX now defaults to not turning on networking when running on one locality.
  This means that you can run multiple instances on the same system without
  adding command line options.
* Multiple issues reported by Clang sanitizers have been fixed.
* We have added (back) single-page HTML documentation and PDF documentation.
* We have started modularizing the HPX library. This is useful both for
  developers and users. In the long term users will be able to consume only
  parts of the HPX libraries if they do not require all the functionality that
  HPX currently provides.
* We have added an implementation of ``function_ref``.
* The ``barrier`` and ``latch`` classes have gained a few additional member
  functions.

Breaking changes
================

* Executable and library targets are now created without the ``_exe`` and
  ``_lib`` suffix respectively. For example, the target ``1d_stencil_1_exe`` is
  now simply called ``1d_stencil_1``.
* We have removed the following deprecated functionality: ``queue``,
  ``scoped_unlock``, and support for input iterators in algorithms.
* We have turned off the compatibility layer for ``unwrapped`` by default. The
  functionality will be removed in the next release. The option can still be
  turned on using the |cmake|_ option ``HPX_WITH_UNWRAPPED_SUPPORT``. Likewise,
  ``inclusive_scan`` compatibility overloads have been turned off by default.
  They can still be turned on with ``HPX_WITH_INCLUSIVE_SCAN_COMPATIBILITY``.
* The minimum compiler and dependency versions have been updated. We now support
  GCC from version 5 onwards, Clang from version 4 onwards, and Boost from
  version 1.61.0 onwards.
* The headers for preprocessor macros have moved as a result of the
  functionality being moved to a separate module. The old headers are deprecated
  and will be removed in a future version of HPX. You can turn off the warnings
  by setting ``HPX_PREPROCESSOR_WITH_DEPRECATION_WARNINGS=OFF`` or turn off the
  compatibility headers completely with
  ``HPX_PREPROCESSOR_WITH_COMPATIBILITY_HEADERS=OFF``.

Closed issues
=============

* :hpx-issue:`3863` - shouldn't "-faligned-new" be a usage requirement?
* :hpx-issue:`3841` - Build error with msvc 19 caused by SFINAE and C++17
* :hpx-issue:`3836` - master branch does not build with idle rate counters
  enabled
* :hpx-issue:`3819` - Add debug suffix to modules built in debug mode
* :hpx-issue:`3817` - ``HPX_INCLUDE_DIRS`` contains non-existent directory
* :hpx-issue:`3810` - Source groups are not created for files in modules
* :hpx-issue:`3805` - HPX won't compile with ``-DHPX_WITH_APEX=TRUE``
* :hpx-issue:`3792` - Barrier Hangs When Locality Zero not included
* :hpx-issue:`3778` - Replace ``throw()`` with ``noexcept``
* :hpx-issue:`3763` - configurable sort limit per task
* :hpx-issue:`3758` - dataflow doesn't convert ``future<future<T>>`` to
  ``future<T>``
* :hpx-issue:`3757` - When compiling undefined reference to
  ``hpx::hpx_check_version_1_2`` HPX V1.2.1, Ubuntu 18.04.01 Server Edition
* :hpx-issue:`3753` - ``--hpx:list-counters=full`` crashes
* :hpx-issue:`3746` - Detection of MPI with pmix
* :hpx-issue:`3744` - Separate spinlock from same cacheline as internal data for
  all LCOs
* :hpx-issue:`3743` - hpxcxx's shebang doesn't specify the python version
* :hpx-issue:`3738` - Unable to debug parcelport on a single node
* :hpx-issue:`3735` - Latest master: Can't compile in MSVC
* :hpx-issue:`3731` - ``util::bound`` seems broken on Clang with older libstdc++
* :hpx-issue:`3724` - Allow to pre-set command line options through environment
* :hpx-issue:`3723` - examples/resource_partitioner build issue on master branch
  / ubuntu 18
* :hpx-issue:`3721` - faced a building error
* :hpx-issue:`3720` - Hello World example fails to link
* :hpx-issue:`3719` - pkg-config produces invalid output: ``-l-pthread``
* :hpx-issue:`3718` - Please make the python executable configurable through
  cmake
* :hpx-issue:`3717` - interested to contribute to the organisation
* :hpx-issue:`3699` - Remove 'HPX runtime' executable
* :hpx-issue:`3698` - Ignore all locks while handling asserts
* :hpx-issue:`3689` - Incorrect and inconsistent website structure
  `<http://stellar.cct.lsu.edu/downloads/>`_.
* :hpx-issue:`3681` - Broken links on
  `<http://stellar.cct.lsu.edu/2015/05/hpx-archives-now-on-gmane/>`_
* :hpx-issue:`3676` - HPX master built from source, cmake fails to link main.cpp
  example in docs
* :hpx-issue:`3673` - HPX build fails with ``std::atomic`` missing error
* :hpx-issue:`3670` - Generate PDF again from documentation (with Sphinx)
* :hpx-issue:`3643` - Warnings when compiling HPX 1.2.1 with gcc 9
* :hpx-issue:`3641` - Trouble with using ranges-v3 and ``hpx::parallel::reduce``
* :hpx-issue:`3639` - ``util::unwrapping`` does not work well with member
  functions
* :hpx-issue:`3634` - The build fails if ``shared_future<>::then`` is called
  with a thread executor
* :hpx-issue:`3622` - VTune Amplifier 2019 not working with ``use_itt_notify=1``
* :hpx-issue:`3616` - HPX Fails to Build with CUDA 10
* :hpx-issue:`3612` - False sharing of scheduling counters
* :hpx-issue:`3609` - executor_parameters timeout with gcc <= 7 and Debug mode
* :hpx-issue:`3601` - Misleading error message on power pc for rdtsc and rdtscp
* :hpx-issue:`3598` - Build of some examples fails when using Vc
* :hpx-issue:`3594` - Error: The number of OS threads requested (20) does not
  match the number of threads to bind (12): HPX(bad_parameter)
* :hpx-issue:`3592` - Undefined Reference Error
* :hpx-issue:`3589` - include could not find load file: HPX_Utils.cmake
* :hpx-issue:`3587` - HPX won't compile on POWER8 with Clang 7
* :hpx-issue:`3583` - Fedora and openSUSE instructions missing on "Distribution
  Packages" page
* :hpx-issue:`3578` - Build error when configuring with
  ``HPX_HAVE_ALGORITHM_INPUT_ITERATOR_SUPPORT=ON``
* :hpx-issue:`3575` - Merge openSUSE reproducible patch
* :hpx-issue:`3570` - Update HPX to work with the latest VC version
* :hpx-issue:`3567` - Build succeed and make failed for ``hpx:cout``
* :hpx-issue:`3565` - Polymorphic simple component destructor not getting called
* :hpx-issue:`3559` - 1.2.0 is missing from download page
* :hpx-issue:`3554` - Clang 6.0 warning of hiding overloaded virtual function
* :hpx-issue:`3510` - Build on ppc64 fails
* :hpx-issue:`3482` - Improve error message when ``HPX_WITH_MAX_CPU_COUNT`` is
  too low for given system
* :hpx-issue:`3453` - Two HPX applications can't run at the same time.
* :hpx-issue:`3452` - Scaling issue on the change to 2 NUMA domains
* :hpx-issue:`3442` - HPX set_difference, set_intersection failure cases
* :hpx-issue:`3437` - Ensure parent_task pointer when child task is created and
  child/parent are on same locality
* :hpx-issue:`3255` - Suspension with lock for ``--hpx:list-component-types``
* :hpx-issue:`3034` - Use C++17 structured bindings for serialization
* :hpx-issue:`2999` - Change thread scheduling use of ``size_t`` for thread
  indexing

Closed pull requests
====================

* :hpx-pr:`3865` - adds hpx_target_compile_option_if_available
* :hpx-pr:`3864` - Helper functions that are useful in numa binding and testing
  of allocator
* :hpx-pr:`3862` - Temporary fix to local_dataflow_boost_small_vector test
* :hpx-pr:`3860` - Add cache line padding to intermediate results in for loop
  reduction
* :hpx-pr:`3859` - Remove HPX_TLL_PUBLIC and HPX_TLL_PRIVATE from CMake files
* :hpx-pr:`3858` - Add compile flags and definitions to modules
* :hpx-pr:`3851` - update hpxmp release tag to v0.2.0
* :hpx-pr:`3849` - Correct BOOST_ROOT variable name in quick start guide
* :hpx-pr:`3847` - Fix attach_debugger configuration option
* :hpx-pr:`3846` - Add tests for libs header tests
* :hpx-pr:`3844` - Fixing source_groups in preprocessor module to properly
  handle compatibility headers
* :hpx-pr:`3843` - This fixes the launch_process/launched_process pair of tests
* :hpx-pr:`3842` - Fix macro call with ITTNOTIFY enabled
* :hpx-pr:`3840` - Fixing SLURM environment parsing
* :hpx-pr:`3837` - Fixing misplaced #endif
* :hpx-pr:`3835` - make all latch members protected for consistency
* :hpx-pr:`3834` - Disable transpose_block_numa example on CircleCI
* :hpx-pr:`3833` - make latch counter_ protected for deriving latch in hpxmp
* :hpx-pr:`3831` - Fix CircleCI config for modules
* :hpx-pr:`3830` - minor fix: option HPX_WITH_TEST was not working correctly
* :hpx-pr:`3828` - Avoid for binaries that depend on HPX to directly link
  against internal modules
* :hpx-pr:`3827` - Adding shortcut for ``hpx::get_ptr<>(sync, id)`` for a local,
  non-migratable objects
* :hpx-pr:`3826` - Fix and update modules documentation
* :hpx-pr:`3825` - Updating default APEX version to 2.1.3 with HPX
* :hpx-pr:`3823` - Fix pkgconfig libs handling
* :hpx-pr:`3822` - Change includes in hpx_wrap.cpp to more specific includes
* :hpx-pr:`3821` - Disable barrier_3792 test when networking is disabled
* :hpx-pr:`3820` - Assorted CMake fixes
* :hpx-pr:`3815` - Removing left-over debug output
* :hpx-pr:`3814` - Allow setting default scheduler mode via the configuration
  database
* :hpx-pr:`3813` - Make the deprecation warnings issued by the old pp headers
  optional
* :hpx-pr:`3812` - Windows requires to handle symlinks to directories
  differently from those linking files
* :hpx-pr:`3811` - Clean up PP module and library skeleton
* :hpx-pr:`3806` - Moving include path configuration to before APEX
* :hpx-pr:`3804` - Fix latch
* :hpx-pr:`3803` - Update hpxcxx to look at lib64 and use python3
* :hpx-pr:`3802` - Numa binding allocator
* :hpx-pr:`3801` - Remove duplicated includes
* :hpx-pr:`3800` - Attempt to fix Posix context switching after lazy init
  changes
* :hpx-pr:`3798` - count and count_if accepts different iterator types
* :hpx-pr:`3797` - Adding a couple of ``override`` keywords to overloaded
  virtual functions
* :hpx-pr:`3796` - Re-enable testing all schedulers in shutdown_suspended_test
* :hpx-pr:`3795` - Change ``std::terminate`` to std::abort in ``SIGSEGV``
  handler
* :hpx-pr:`3794` - Fixing #3792
* :hpx-pr:`3793` - Extending migrate_polymorphic_component unit test
* :hpx-pr:`3791` - Change ``throw()`` to ``noexcept``
* :hpx-pr:`3790` - Remove deprecated options for 1.3.0 release
* :hpx-pr:`3789` - Remove Boost filesystem compatibility header
* :hpx-pr:`3788` - Disabled even more spots that should not execute if
  networking is disabled
* :hpx-pr:`3787` - Bump minimal boost supported version to 1.61.0
* :hpx-pr:`3786` - Bump minimum required versions for 1.3.0 release
* :hpx-pr:`3785` - Explicitly set number of jobs for all ninja invocations on
  CircleCI
* :hpx-pr:`3784` - Fix leak and address sanitizer problems
* :hpx-pr:`3783` - Disabled even more spots that should not execute is
  networking is disabled
* :hpx-pr:`3782` - Cherry-picked tuple and thread_init_data fixes from #3701
* :hpx-pr:`3781` - Fix generic context coroutines after lazy stack allocation
  changes
* :hpx-pr:`3780` - Rename hello world examples
* :hpx-pr:`3776` - Sort algorithms now use the supplied chunker to determine the
  required minimal chunk size
* :hpx-pr:`3775` - Disable Boost auto-linking
* :hpx-pr:`3774` - Tag and push stable builds
* :hpx-pr:`3773` - Enable migration of polymorphic components
* :hpx-pr:`3771` - Fix link to stackoverflow in documentation
* :hpx-pr:`3770` - Replacing constexpr if in brace-serialization code
* :hpx-pr:`3769` - Fix SIGSEGV handler
* :hpx-pr:`3768` - Adding flags to scheduler allowing to control thread stealing
  and idle back-off
* :hpx-pr:`3767` - Fix help formatting in hpxrun.py
* :hpx-pr:`3765` - Fix a couple of bugs in the thread test
* :hpx-pr:`3764` - Workaround for SFINAE regression in msvc14.2
* :hpx-pr:`3762` - Prevent MSVC from prematurely instantiating things
* :hpx-pr:`3761` - Update python scripts to work with python 3
* :hpx-pr:`3760` - Fix callable vtable for GCC4.9
* :hpx-pr:`3759` - Rename ``PAGE_SIZE`` to ``PAGE_SIZE_`` because AppleClang
* :hpx-pr:`3755` - Making sure locks are not held during suspension
* :hpx-pr:`3754` - Disable more code if networking is not available/not enabled
* :hpx-pr:`3752` - Move ``util::format`` implementation to source file
* :hpx-pr:`3751` - Fixing problems with ``lcos::barrier`` and iostreams
* :hpx-pr:`3750` - Change error message to take into account ``use_guard_page``
  setting
* :hpx-pr:`3749` - Fix lifetime problem in ``run_as_hpx_thread``
* :hpx-pr:`3748` - Fixed unusable behavior of the clang code analyzer.
* :hpx-pr:`3747` - Added ``PMIX_RANK`` to the defaults of
  ``HPX_WITH_PARCELPORT_MPI_ENV``.
* :hpx-pr:`3745` - Introduced ``cache_aligned_data`` and ``cache_line_data``
  helper structure
* :hpx-pr:`3742` - Remove more unused functionality from util/logging
* :hpx-pr:`3740` - Fix includes in partitioned vector tests
* :hpx-pr:`3739` - More fixes to make sure that ``std::flush`` really flushes
  all output
* :hpx-pr:`3737` - Fix potential shutdown problems
* :hpx-pr:`3736` - Fix ``guided_pool_executor`` after dataflow changes caused
  compilation fail
* :hpx-pr:`3734` - Limiting executor
* :hpx-pr:`3732` - More constrained bound constructors
* :hpx-pr:`3730` - Attempt to fix deadlocks during component loading
* :hpx-pr:`3729` - Add latch member function ``count_up`` and reset, requested
  by hpxMP
* :hpx-pr:`3728` - Send even empty buffers on ``hpx::endl`` and ``hpx::flush``
* :hpx-pr:`3727` - Adding example demonstrating how to customize the memory
  management for a component
* :hpx-pr:`3726` - Adding support for passing command line options through the
  ``HPX_COMMANDLINE_OPTIONS`` environment variable
* :hpx-pr:`3722` - Document known broken OpenMPI builds
* :hpx-pr:`3716` - Add barrier reset function, requested by hpxMP for reusing
  barrier
* :hpx-pr:`3715` - More work on functions and vtables
* :hpx-pr:`3714` - Generate single-page HTML, PDF, manpage from documentation
* :hpx-pr:`3713` - Updating default APEX version to 2.1.2
* :hpx-pr:`3712` - Update release procedure
* :hpx-pr:`3710` - Fix the C++11 build, after #3704
* :hpx-pr:`3709` - Move some component_registry functionality to source file
* :hpx-pr:`3708` - Ignore all locks while handling assertions
* :hpx-pr:`3707` - Remove obsolete hpx runtime executable
* :hpx-pr:`3705` - Fix and simplify ``make_ready_future`` overload sets
* :hpx-pr:`3704` - Reduce use of binders
* :hpx-pr:`3703` - Ini
* :hpx-pr:`3702` - Fixing CUDA compiler errors
* :hpx-pr:`3700` - Added ``barrier::increment`` function to increase total
  number of thread
* :hpx-pr:`3697` - One more attempt to fix migration...
* :hpx-pr:`3694` - Fixing component migration
* :hpx-pr:`3693` - Print thread state when getting disallowed value in
  set_thread_state
* :hpx-pr:`3692` - Only disable ``constexpr`` with clang-cuda, not nvcc+gcc
* :hpx-pr:`3691` - Link with libsupc++ if needed for thread_local
* :hpx-pr:`3690` - Remove thousands separators in set_operations_3442 to comply
  with C++11
* :hpx-pr:`3688` - Decouple serialization from function vtables
* :hpx-pr:`3687` - Fix a couple of test failures
* :hpx-pr:`3686` - Make sure tests.unit.build are run after install on CircleCI
* :hpx-pr:`3685` - Revise quickstart CMakeLists.txt explanation
* :hpx-pr:`3684` - Provide concept emulation for Ranges-TS concepts
* :hpx-pr:`3683` - Ignore uninitialized chunks
* :hpx-pr:`3682` - Ignore uninitialized chunks. Check proper indices.
* :hpx-pr:`3680` - Ignore uninitialized chunks. Check proper range indices
* :hpx-pr:`3679` - Simplify basic action implementations
* :hpx-pr:`3678` - Making sure ``HPX_HAVE_LIBATOMIC`` is unset before checking
* :hpx-pr:`3677` - Fix generated full version number to be usable in expressions
* :hpx-pr:`3674` - Reduce functional utilities call depth
* :hpx-pr:`3672` - Change new build system to use existing macros related to
  pseudo dependencies
* :hpx-pr:`3669` - Remove indirection in ``function_ref`` when thread
  description is disabled
* :hpx-pr:`3668` - Unbreaking ``async_*cb*`` tests
* :hpx-pr:`3667` - Generate version.hpp
* :hpx-pr:`3665` - Enabling MPI parcelport for gitlab runners
* :hpx-pr:`3664` - making clang-tidy work properly again
* :hpx-pr:`3662` - Attempt to fix exception handling
* :hpx-pr:`3661` - Move ``lcos::latch`` to source file
* :hpx-pr:`3660` - Fix accidentally explicit gid_type default constructor
* :hpx-pr:`3659` - Parallel executor latch
* :hpx-pr:`3658` - Fixing execution_parameters
* :hpx-pr:`3657` - Avoid dangling references in wait_all
* :hpx-pr:`3656` - Avoiding lifetime problems with sync_put_parcel
* :hpx-pr:`3655` - Fixing nullptr dereference inside of function
* :hpx-pr:`3652` - Attempt to fix ``thread_map_type`` definition with C++11
* :hpx-pr:`3650` - Allowing for end iterator being different from begin iterator
* :hpx-pr:`3649` - Added architecture identification to cmake to be able to
  detect timestamp support
* :hpx-pr:`3645` - Enabling sanitizers on gitlab runner
* :hpx-pr:`3644` - Attempt to tackle timeouts during startup
* :hpx-pr:`3642` - Cleanup parallel partitioners
* :hpx-pr:`3640` - Dataflow now works with functions that return a reference
* :hpx-pr:`3637` - Merging the executor-enabled overloads of
  ``shared_future<>::then``
* :hpx-pr:`3633` - Replace deprecated boost endian macros
* :hpx-pr:`3632` - Add instructions on getting HPX to documentation
* :hpx-pr:`3631` - Simplify parcel creation
* :hpx-pr:`3630` - Small additions and fixes to release procedure
* :hpx-pr:`3629` - Modular pp
* :hpx-pr:`3627` - Implement ``util::function_ref``
* :hpx-pr:`3626` - Fix cancelable_action_client example
* :hpx-pr:`3625` - Added automatic serialization for simple structs (see #3034)
* :hpx-pr:`3624` - Updating the default order of priority for
  ``thread_description``
* :hpx-pr:`3621` - Update copyright year and other small formatting fixes
* :hpx-pr:`3620` - Adding support for gitlab runner
* :hpx-pr:`3619` - Store debug logs and core dumps on CircleCI
* :hpx-pr:`3618` - Various optimizations
* :hpx-pr:`3617` - Fix link to the gpg key (#2)
* :hpx-pr:`3615` - Fix unused variable warnings with networking off
* :hpx-pr:`3614` - Restructuring counter data in scheduler to reduce false
  sharing
* :hpx-pr:`3613` - Adding support for gitlab runners
* :hpx-pr:`3610` - Don't wait for ``stop_condition`` in main thread
* :hpx-pr:`3608` - Add inline keyword to ``invalid_thread_id`` definition for
  nvcc
* :hpx-pr:`3607` - Adding configuration key that allows one to explicitly add a
  directory to the component search path
* :hpx-pr:`3606` - Add nvcc to exclude constexpress since is it not supported by
  nvcc
* :hpx-pr:`3605` - Add ``inline`` to definition of checkpoint stream operators
  to fix link error
* :hpx-pr:`3604` - Use format for string formatting
* :hpx-pr:`3603` - Improve the error message for using to less ``MAX_CPU_COUNT``
* :hpx-pr:`3602` - Improve the error message for to small values of
  ``MAX_CPU_COUNT``
* :hpx-pr:`3600` - Parallel executor aggregated
* :hpx-pr:`3599` - Making sure networking is disabled for default
  one-locality-runs
* :hpx-pr:`3596` - Store thread exit functions in ``forward_list`` instead of
  ``deque`` to avoid allocations
* :hpx-pr:`3590` - Fix typo/mistake in thread queue ``cleanup_terminated``
* :hpx-pr:`3588` - Fix formatting errors in
  launching_and_configuring_hpx_applications.rst
* :hpx-pr:`3586` - Make bind propagate value category
* :hpx-pr:`3585` - Extend Cmake for building hpx as distribution packages (refs
  #3575)
* :hpx-pr:`3584` - Untangle function storage from object pointer
* :hpx-pr:`3582` - Towards Modularized HPX
* :hpx-pr:`3580` - Remove extra ``||`` in merge.hpp
* :hpx-pr:`3577` - Partially revert "Remove vtable empty flag"
* :hpx-pr:`3576` - Make sure empty startup/shutdown functions are not being used
* :hpx-pr:`3574` - Make sure ``DATAPAR`` settings are conveyed to depending
  projects
* :hpx-pr:`3573` - Make sure HPX is usable with latest released version of Vc
  (V1.4.1)
* :hpx-pr:`3572` - Adding test ensuring ticket 3565 is fixed
* :hpx-pr:`3571` - Make empty ``[unique_]function`` vtable non-dependent
* :hpx-pr:`3566` - Fix compilation with dynamic bitset for CPU masks
* :hpx-pr:`3563` - Drop ``util::[unique_]function`` target_type
* :hpx-pr:`3562` - Removing the target suffixes
* :hpx-pr:`3561` - Replace executor traits return type deduction (keep
  non-SFINAE)
* :hpx-pr:`3557` - Replace the last usages of boost::atomic
* :hpx-pr:`3556` - Replace ``boost::scoped_array`` with ``std::unique_ptr``
* :hpx-pr:`3552` - (Re)move APEX readme
* :hpx-pr:`3548` - Replace ``boost::scoped_ptr`` with ``std::unique_ptr``
* :hpx-pr:`3547` - Remove last use of Boost.Signals2
* :hpx-pr:`3544` - Post 1.2.0 version bumps
* :hpx-pr:`3543` - added Ubuntu dependency list to readme
* :hpx-pr:`3531` - Warnings, warnings...
* :hpx-pr:`3527` - Add CircleCI filter for building all tags
* :hpx-pr:`3525` - Segmented algorithms
* :hpx-pr:`3517` - Replace ``boost::regex`` with C++11 ``<regex>``
* :hpx-pr:`3514` - Cleaning up the build system
* :hpx-pr:`3505` - Fixing type attribute warning for ``transfer_action``
* :hpx-pr:`3504` - Add support for rpm packaging
* :hpx-pr:`3499` - Improving spinlock pools
* :hpx-pr:`3498` - Remove thread specific ptr
* :hpx-pr:`3486` - Fix comparison for expect_connecting_localities config entry
* :hpx-pr:`3469` - Enable (existing) code for extracting stack pointer on Power
  platform
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_7_0:

===========================
|hpx| V0.7.0 (Dec 12, 2011)
===========================

We have had roughly 1000 commits since the last release and we have closed
approximately 120 tickets (bugs, feature requests, etc.).

General changes
===============

* Completely removed code related to deprecated AGAS V1, started to work on AGAS
  V2.1.
* Started to clean up and streamline the exposed APIs (see 'API changes' below
  for more details).
* Revamped and unified performance counter framework, added a lot of new
  performance counter instances for monitoring of a diverse set of internal
  |hpx| parameters (queue lengths, access statistics, etc.).
* Improved general error handling and logging support.
* Fixed several race conditions, improved overall stability, decreased memory
  footprint, improved overall performance (major optimizations include native
  TLS support and ranged-based AGAS caching).
* Added support for running |hpx| applications with PBS.
* Many updates to the build system, added support for gcc 4.5.x and 4.6.x, added
  C++11 support.
* Many updates to default command line options.
* Added many tests, set up buildbot for continuous integration testing.
* Better shutdown handling of distributed applications.

Example applications
====================

* quickstart/factorial and quickstart/fibonacci, future-recursive parallel
  algorithms.
* quickstart/hello_world, distributed hello world example.
* quickstart/rma, simple remote memory access example
* quickstart/quicksort, parallel quicksort implementation.
* gtc, gyrokinetic torodial code.
* bfs, breadth-first-search, example code for a graph application.
* sheneos, partitioning of large data sets.
* accumulator, simple component example.
* balancing/os_thread_num, balancing/px_thread_phase, examples demonstrating
  load balancing and work stealing.

API changes
===========

* Added ``hpx::find_all_localities``.
* Added ``hpx::terminate`` for non-graceful termination of applications.
* Added ``hpx::lcos::async`` functions for simpler asynchronous programming.
* Added new AGAS interface for handling of symbolic namespace
  (``hpx::agas::*``).
* Renamed ``hpx::components::wait`` to ``hpx::lcos::wait``.
* Renamed ``hpx::lcos::future_value`` to ``hpx::lcos::promise``.
* Renamed ``hpx::lcos::recursive_mutex`` to
  ``hpx::lcos::local_recursive_mutex``, ``hpx::lcos::mutex`` to
  ``hpx::lcos::local_mutex``
* Removed support for Boost versions older than V1.38, recommended Boost version
  is now V1.47 and newer.
* Removed ``hpx::process`` (this will be replaced by a real process
  implementation in the future).
* Removed non-functional LCO code (``hpx::lcos::dataflow``,
  ``hpx::lcos::thunk``, ``hpx::lcos::dataflow_variable``).
* Removed deprecated ``hpx::naming::full_address``.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release:

* :hpx-issue:`28` - Integrate Windows/Linux CMake code for |hpx| core
* :hpx-issue:`32` - hpx::cout() should be hpx::cout
* :hpx-issue:`33` - AGAS V2 legacy client does not properly handle error_code
* :hpx-issue:`60` - AGAS: allow for registerid to optionally take ownership of
  the gid
* :hpx-issue:`62` - adaptive1d compilation failure in Fusion
* :hpx-issue:`64` - Parcel subsystem doesn't resolve domain names
* :hpx-issue:`83` - No error handling if no console is available
* :hpx-issue:`84` - No error handling if a hosted locality is treated as the
  bootstrap server
* :hpx-issue:`90` - Add general commandline option -N
* :hpx-issue:`91` - Add possibility to read command line arguments from file
* :hpx-issue:`92` - Always log exceptions/errors to the log file
* :hpx-issue:`93` - Log the command line/program name
* :hpx-issue:`95` - Support for distributed launches
* :hpx-issue:`97` - Attempt to create a bad component type in AMR examples
* :hpx-issue:`100` - factorial and factorial_get examples trigger AGAS component
  type assertions
* :hpx-issue:`101` - Segfault when hpx::process::here() is called in fibonacci2
* :hpx-issue:`102` - unknown_component_address in int_object_semaphore_client
* :hpx-issue:`114` - marduk raises assertion with default parameters
* :hpx-issue:`115` - Logging messages for SMP runs (on the console) shouldn't be
  buffered
* :hpx-issue:`119` - marduk linking strategy breaks other applications
* :hpx-issue:`121` - pbsdsh problem
* :hpx-issue:`123` - marduk, dataflow and adaptive1d fail to build
* :hpx-issue:`124` - Lower default preprocessing arity
* :hpx-issue:`125` - Move hpx::detail::diagnostic_information out of the detail
  namespace
* :hpx-issue:`126` - Test definitions for AGAS reference counting
* :hpx-issue:`128` - Add averaging performance counter
* :hpx-issue:`129` - Error with endian.hpp while building adaptive1d
* :hpx-issue:`130` - Bad initialization of performance counters
* :hpx-issue:`131` - Add global startup/shutdown functions to component modules
* :hpx-issue:`132` - Avoid using auto_ptr
* :hpx-issue:`133` - On Windows hpx.dll doesn't get installed
* :hpx-issue:`134` - HPX_LIBRARY does not reflect real library name (on Windows)
* :hpx-issue:`135` - Add detection of unique_ptr to build system
* :hpx-issue:`137` - Add command line option allowing to repeatedly evaluate
  performance counters
* :hpx-issue:`139` - Logging is broken
* :hpx-issue:`140` - CMake problem on windows
* :hpx-issue:`141` - Move all non-component libraries into $PREFIX/lib/hpx
* :hpx-issue:`143` - adaptive1d throws an exception with the default command
  line options
* :hpx-issue:`146` - Early exception handling is broken
* :hpx-issue:`147` - Sheneos doesn't link on Linux
* :hpx-issue:`149` - sheneos_test hangs
* :hpx-issue:`154` - Compilation fails for r5661
* :hpx-issue:`155` - Sine performance counters example chokes on chrono headers
* :hpx-issue:`156` - Add build type to --version
* :hpx-issue:`157` - Extend AGAS caching to store gid ranges
* :hpx-issue:`158` - r5691 doesn't compile
* :hpx-issue:`160` - Re-add AGAS function for resolving a locality to its prefix
* :hpx-issue:`168` - Managed components should be able to access their own GID
* :hpx-issue:`169` - Rewrite AGAS future pool
* :hpx-issue:`179` - Complete switch to request class for AGAS server interface
* :hpx-issue:`182` - Sine performance counter is loaded by other examples
* :hpx-issue:`185` - Write tests for symbol namespace reference counting
* :hpx-issue:`191` - Assignment of read-only variable in point_geometry
* :hpx-issue:`200` - Seg faults when querying performance counters
* :hpx-issue:`204` - --ifnames and suffix stripping needs to be more generic
* :hpx-issue:`205` - --list-* and --print-counter-* options do not work together
  and produce no warning
* :hpx-issue:`207` - Implement decrement entry merging
* :hpx-issue:`208` - Replace the spinlocks in AGAS with hpx::lcos::local_mutexes
* :hpx-issue:`210` - Add an --ifprefix option
* :hpx-issue:`214` - Performance test for PX-thread creation
* :hpx-issue:`216` - VS2010 compilation
* :hpx-issue:`222` - r6045 context_linux_x86.hpp
* :hpx-issue:`223` - fibonacci hangs when changing the state of an active thread
* :hpx-issue:`225` - Active threads end up in the FEB wait queue
* :hpx-issue:`226` - VS Build Error for Accumulator Client
* :hpx-issue:`228` - Move all traits into namespace hpx::traits
* :hpx-issue:`229` - Invalid initialization of reference in thread_init_data
* :hpx-issue:`235` - Invalid GID in iostreams
* :hpx-issue:`238` - Demangle type names for the default implementation of
  get_action_name
* :hpx-issue:`241` - C++11 support breaks GCC 4.5
* :hpx-issue:`247` - Reference to temporary with GCC 4.4
* :hpx-issue:`248` - Seg fault at shutdown with GCC 4.4
* :hpx-issue:`253` - Default component action registration kills compiler
* :hpx-issue:`272` - G++ unrecognized command line option
* :hpx-issue:`273` - quicksort example doesn't compile
* :hpx-issue:`277` - Invalid CMake logic for Windows

..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_6:

===========================
|hpx| V0.9.6 (Jul 30, 2013)
===========================

We have had over 1200 commits since the last release and we have closed
roughly 140 tickets (bugs, feature requests, etc.).

General changes
===============

The major new features in this release are:

* We further consolidated the API exposed by |hpx|. We aligned our APIs as much
  as possible with the existing |cpp11|_ and related proposals to the C++
  standardization committee (such as |cpp11_n3632|_ and |cpp11_n3634|_).
* We implemented a first version of a distributed AGAS service which essentially
  eliminates all explicit AGAS network traffic.
* We created a native ibverbs parcelport allowing to take advantage of the
  superior latency and bandwidth characteristics of Infiniband networks.
* We successfully ported |hpx| to the Xeon Phi platform.
* Support for the SLURM scheduling system was implemented.
* Major efforts have been dedicated to improving the performance counter
  framework, numerous new counters were implemented and new APIs were added.
* We added a modular parcel compression system allowing to improve bandwidth
  utilization (by reducing the overall size of the transferred data).
* We added a modular parcel coalescing system allowing to combine several
  parcels into larger messages. This reduces latencies introduced by the
  communication layer.
* Added an experimental executors API allowing to use different scheduling
  policies for different parts of the code. This API has been modelled after the
  Standards proposal |cpp11_n3562|_. This API is bound to change in the future,
  though.
* Added minimal security support for localities which is enforced on the
  parcelport level. This support is preliminary and experimental and might
  change in the future.
* We created a parcelport using low level MPI functions. This is in support of
  legacy applications which are to be gradually ported and to support platforms
  where MPI is the only available portable networking layer.
* We added a preliminary and experimental implementation of a tuple-space object
  which exposes an interface similar to such systems described in the literature
  (see for instance |linda|_).

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release. This is
again a very long list of newly implemented features and fixed issues.

* :hpx-issue:`806` - make (all) in examples folder does nothing
* :hpx-issue:`805` - Adding the introduction and fixing DOCBOOK dependencies for
  Windows use
* :hpx-issue:`804` - Add stackless (non-suspendable) thread type
* :hpx-issue:`803` - Create proper serialization support functions for
  util::tuple
* :hpx-issue:`800` - Add possibility to disable array optimizations during
  serialization
* :hpx-issue:`798` - HPX_LIMIT does not work for local dataflow
* :hpx-issue:`797` - Create a parcelport which uses MPI
* :hpx-issue:`796` - Problem with Large Numbers of Threads
* :hpx-issue:`793` - Changing dataflow test case to hang consistently
* :hpx-issue:`792` - CMake Error
* :hpx-issue:`791` - Problems with local::dataflow
* :hpx-issue:`790` - wait_for() doesn't compile
* :hpx-issue:`789` - HPX with Intel compiler segfaults
* :hpx-issue:`788` - Intel compiler support
* :hpx-issue:`787` - Fixed SFINAEd specializations
* :hpx-issue:`786` - Memory issues during benchmarking.
* :hpx-issue:`785` - Create an API allowing to register external threads with
  HPX
* :hpx-issue:`784` - util::plugin is throwing an error when a symbol is not
  found
* :hpx-issue:`783` - How does hpx:bind work?
* :hpx-issue:`782` - Added quotes around STRING REPLACE potentially empty
  arguments
* :hpx-issue:`781` - Make sure no exceptions propagate into the thread manager
* :hpx-issue:`780` - Allow arithmetics performance counters to expand its
  parameters
* :hpx-issue:`779` - Test case for 778
* :hpx-issue:`778` - Swapping futures segfaults
* :hpx-issue:`777` - hpx::lcos::details::when_xxx don't restore completion
  handlers
* :hpx-issue:`776` - Compiler chokes on dataflow overload with launch policy
* :hpx-issue:`775` - Runtime error with local dataflow (copying futures?)
* :hpx-issue:`774` - Using local dataflow without explicit namespace
* :hpx-issue:`773` - Local dataflow with unwrap: functor operators need to be
  const
* :hpx-issue:`772` - Allow (remote) actions to return a future
* :hpx-issue:`771` - Setting HPX_LIMIT gives huge boost MPL errors
* :hpx-issue:`770` - Add launch policy to (local) dataflow
* :hpx-issue:`769` - Make compile time configuration information available
* :hpx-issue:`768` - Const correctness problem in local dataflow
* :hpx-issue:`767` - Add launch policies to async
* :hpx-issue:`766` - Mark data structures for optimized (array based)
  serialization
* :hpx-issue:`765` - Align hpx::any with N3508: Any Library Proposal
  (Revision 2)
* :hpx-issue:`764` - Align hpx::future with newest N3558: A Standardized
  Representation of Asynchronous Operations
* :hpx-issue:`762` - added a human readable output for the ping pong example
* :hpx-issue:`761` - Ambiguous typename when constructing derived component
* :hpx-issue:`760` - Simple components can not be derived
* :hpx-issue:`759` - make install doesn't give a complete install
* :hpx-issue:`758` - Stack overflow when using locking_hook<>
* :hpx-issue:`757` - copy paste error; unsupported function overloading
* :hpx-issue:`756` - GTCX runtime issue in Gordon
* :hpx-issue:`755` - Papi counters don't work with reset and evaluate API's
* :hpx-issue:`753` - cmake bugfix and improved component action docs
* :hpx-issue:`752` - hpx simple component docs
* :hpx-issue:`750` - Add hpx::util::any
* :hpx-issue:`749` - Thread phase counter is not reset
* :hpx-issue:`748` - Memory performance counter are not registered
* :hpx-issue:`747` - Create performance counters exposing arithmetic operations
* :hpx-issue:`745` - apply_callback needs to invoke callback when applied
  locally
* :hpx-issue:`744` - CMake fixes
* :hpx-issue:`743` - Problem Building github version of HPX
* :hpx-issue:`742` - Remove HPX_STD_BIND
* :hpx-issue:`741` - assertion 'px != 0' failed: HPX(assertion_failure) for low
  numbers of OS threads
* :hpx-issue:`739` - Performance counters do not count to the end of the program
  or evaluation
* :hpx-issue:`738` - Dedicated AGAS server runs don't work; console ignores -a
  option.
* :hpx-issue:`737` - Missing bind overloads
* :hpx-issue:`736` - Performance counter wildcards do not always work
* :hpx-issue:`735` - Create native ibverbs parcelport based on rdma operations
* :hpx-issue:`734` - Threads stolen performance counter total is incorrect
* :hpx-issue:`733` - Test benchmarks need to be checked and fixed
* :hpx-issue:`732` - Build fails with Mac, using mac ports clang-3.3 on latest
  git branch
* :hpx-issue:`731` - Add global start/stop API for performance counters
* :hpx-issue:`730` - Performance counter values are apparently incorrect
* :hpx-issue:`729` - Unhandled switch
* :hpx-issue:`728` - Serialization of hpx::util::function between two localities
  causes seg faults
* :hpx-issue:`727` - Memory counters on Mac OS X
* :hpx-issue:`725` - Restore original thread priority on resume
* :hpx-issue:`724` - Performance benchmarks do not depend on main HPX libraries
* :hpx-issue:`723` - [teletype]--hpx:nodes=``cat $PBS_NODEFILE`` works;
  --hpx:nodefile=$PBS_NODEFILE does not.[c++]
* :hpx-issue:`722` - Fix binding const member functions as actions
* :hpx-issue:`719` - Create performance counter exposing compression ratio
* :hpx-issue:`718` - Add possibility to compress parcel data
* :hpx-issue:`717` - strip_credit_from_gid has misleading semantics
* :hpx-issue:`716` - Non-option arguments to programs run using ``pbsdsh`` must
  be before ``--hpx:nodes``, contrary to directions
* :hpx-issue:`715` - Re-thrown exceptions should retain the original call site
* :hpx-issue:`714` - failed assertion in debug mode
* :hpx-issue:`713` - Add performance counters monitoring connection caches
* :hpx-issue:`712` - Adjust parcel related performance counters to be connection
  type specific
* :hpx-issue:`711` - configuration failure
* :hpx-issue:`710` - Error "timed out while trying to find room in the
  connection cache" when trying to start multiple localities on a single
  computer
* :hpx-issue:`709` - Add new thread state 'staged' referring to task
  descriptions
* :hpx-issue:`708` - Detect/mitigate bad non-system installs of GCC on Redhat
  systems
* :hpx-issue:`707` - Many examples do not link with Git HEAD version
* :hpx-issue:`706` - ``hpx::init`` removes portions of non-option command line
  arguments before last ``=`` sign
* :hpx-issue:`705` - Create rolling average and median aggregating performance
  counters
* :hpx-issue:`704` - Create performance counter to expose thread queue waiting
  time
* :hpx-issue:`703` - Add support to HPX build system to find librcrtool.a and
  related headers
* :hpx-issue:`699` - Generalize instrumentation support
* :hpx-issue:`698` - compilation failure with hwloc absent
* :hpx-issue:`697` - Performance counter counts should be zero indexed
* :hpx-issue:`696` - Distributed problem
* :hpx-issue:`695` - Bad perf counter time printed
* :hpx-issue:`693` - ``--help`` doesn't print component specific command line
  options
* :hpx-issue:`692` - SLURM support broken
* :hpx-issue:`691` - exception while executing any application linked with hwloc
* :hpx-issue:`690` - thread_id_test and thread_launcher_test failing
* :hpx-issue:`689` - Make the buildbots use hwloc
* :hpx-issue:`687` - compilation error fix (hwloc_topology)
* :hpx-issue:`686` - Linker Error for Applications
* :hpx-issue:`684` - Pinning of service thread fails when number of worker
  threads equals the number of cores
* :hpx-issue:`682` - Add performance counters exposing number of stolen threads
* :hpx-issue:`681` - Add apply_continue for asynchronous chaining of actions
* :hpx-issue:`679` - Remove obsolete async_callback API functions
* :hpx-issue:`678` - Add new API for setting/triggering LCOs
* :hpx-issue:`677` - Add async_continue for true continuation style actions
* :hpx-issue:`676` - Buildbot for gcc 4.4 broken
* :hpx-issue:`675` - Partial preprocessing broken
* :hpx-issue:`674` - HPX segfaults when built with gcc 4.7
* :hpx-issue:`673` - ``use_guard_pages`` has inconsistent preprocessor guards
* :hpx-issue:`672` - External build breaks if library path has spaces
* :hpx-issue:`671` - release tarballs are tarbombs
* :hpx-issue:`670` - CMake won't find Boost headers in layout=versioned install
* :hpx-issue:`669` - Links in docs to source files broken if not installed
* :hpx-issue:`667` - Not reading ini file properly
* :hpx-issue:`664` - Adapt new meanings of 'const' and 'mutable'
* :hpx-issue:`661` - Implement BTL Parcel port
* :hpx-issue:`655` - Make HPX work with the "decltype" result_of
* :hpx-issue:`647` - documentation for specifying the number of high priority
  threads ``--hpx:high-priority-threads``
* :hpx-issue:`643` - Error parsing host file
* :hpx-issue:`642` - HWLoc issue with TAU
* :hpx-issue:`639` - Logging potentially suspends a running thread
* :hpx-issue:`634` - Improve error reporting from parcel layer
* :hpx-issue:`627` - Add tests for async and apply overloads that accept regular
  C++ functions
* :hpx-issue:`626` - hpx/future.hpp header
* :hpx-issue:`601` - Intel support
* :hpx-issue:`557` - Remove action codes
* :hpx-issue:`531` - AGAS request and response classes should use switch
  statements
* :hpx-issue:`529` - Investigate the state of hwloc support
* :hpx-issue:`526` - Make HPX aware of hyper-threading
* :hpx-issue:`518` - Create facilities allowing to use plain arrays as action
  arguments
* :hpx-issue:`473` - hwloc thread binding is broken on CPUs with hyperthreading
* :hpx-issue:`383` - Change result type detection for hpx::util::bind to use
  result_of protocol
* :hpx-issue:`341` - Consolidate route code
* :hpx-issue:`219` - Only copy arguments into actions once
* :hpx-issue:`177` - Implement distributed AGAS
* :hpx-issue:`43` - Support for Darwin (Xcode + Clang)

..
    Copyright (C) 2007-2019 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_2_1:

===========================
|hpx| V1.2.1 (Feb 19, 2019)
===========================

General changes
===============

This is a bugfix release. It contains the following changes:

* Fix compilation on ARM, s390x and 32-bit architectures.
* Fix a critical bug in the ``future`` implementation.
* Fix several problems in the CMake configuration which affects external
  projects.
* Add support for Boost 1.69.0.

Closed issues
=============

* :hpx-issue:`3638` - Build HPX 1.2 with boost 1.69
* :hpx-issue:`3635` - Non-deterministic crashing on Stampede2
* :hpx-issue:`3550` - 1>e:\000work\hpx\src\throw_exception.cpp(54): error C2440:
  '<function-style-cast>': cannot convert from 'boost::system::error_code' to
  'hpx::exception'
* :hpx-issue:`3549` - HPX 1.2.0 does not build on i686, but release candidate
  did
* :hpx-issue:`3511` - Build on s390x fails
* :hpx-issue:`3509` - Build on armv7l fails

Closed pull requests
====================

* :hpx-pr:`3695` - Don't install CMake templates and packaging files
* :hpx-pr:`3666` - Fixing yet another race in future_data
* :hpx-pr:`3663` - Fixing race between setting and getting the value inside
  future_data
* :hpx-pr:`3648` - Adding timestamp option for S390x platform
* :hpx-pr:`3647` - Blind attempt to fix warnings issued by gcc V9
* :hpx-pr:`3611` - Include GNUInstallDirs earlier to have it available for
  subdirectories
* :hpx-pr:`3595` - Use GNUInstallDirs lib path in pkgconfig config file
* :hpx-pr:`3593` - Add include(GNUInstallDirs) to HPXMacros.cmake
* :hpx-pr:`3591` - Fix compilation error on arm7 architecture. Compiles and runs
  on Fedora 29 on Pi 3.
* :hpx-pr:`3558` - Adding constructor `exception(boost::system::error_code
  const&)`
* :hpx-pr:`3555` - cmake: make install locations configurable
* :hpx-pr:`3551` - Fix uint64_t causing compilation fail on i686
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_0_9_99:

============================
|hpx| V0.9.99 (Jul 15, 2016)
============================

General changes
===============

As the version number of this release hints, we consider this release to be a
preview for the upcoming |hpx| V1.0. All of the functionalities we set out to
implement for V1.0 are in place; all of the features we wanted to have exposed
are ready. We are very happy with the stability and performance of |hpx| and we
would like to present this release to the community in order for us to gather
broad feedback before releasing V1.0. We still expect for some minor details to
change, but on the whole this release represents what we would like to have in a
V1.0.

Overall, since the last release we have had almost 1600 commits while closing
almost 400 tickets. These numbers reflect the incredible development activity we
have seen over the last couple of months. We would like to express a big 'Thank
you!' to all contributors and those who helped to make this release happen.

The most notable addition in terms of new functionality available with this
release is the full implementation of object migration (i.e. the ability to
transparently move |hpx| components to a different compute node). Additionally,
this release of |hpx| cleans up many minor issues and some API inconsistencies.

Here are some of the main highlights and changes for this release (in no
particular order):

* We have fixed a couple of issues in AGAS and the parcel layer which have
  caused hangs, segmentation faults at exit, and a slowdown of applications over
  time. Fixing those has significantly increased the overall stability and
  performance of distributed runs.
* We have started to add parallel algorithm overloads based on the C++
  Extensions for Ranges (|cpp17_n4560|_) proposal. This also includes the
  addition of projections to the existing algorithms. Please see
  :hpx-issue:`1668` for a list of algorithms which have been adapted to
  |cpp17_n4560|_.
* We have implemented index-based parallel for-loops based on a corresponding
  standardization proposal (|cpp20_p0075r1|_). Please see :hpx-issue:`2016` for
  a list of available algorithms.
* We have added implementations for more parallel algorithms as proposed for the
  upcoming C++ 17 Standard. See :hpx-issue:`1141` for an overview of which
  algorithms are available by now.
* We have started to implement a new prototypical functionality with
  |hpx_compute| which uniformly exposes some of the higher level APIs to
  heterogeneous architectures (currently CUDA). This functionality is an early
  preview and should not be considered stable. It may change considerably in the
  future.
* We have pervasively added (optional) executor arguments to all API functions
  which schedule new work. Executors are now used throughout the code base as
  the main means of executing tasks.
* Added ``hpx::make_future<R>(future<T> &&)`` allowing to convert a future of
  any type ``T`` into a future of any other type ``R``, either based on default
  conversion rules of the embedded types or using a given explicit conversion
  function.
* We finally finished the implementation of transparent migration of components
  to another locality. It is now possible to trigger a migration operation
  without 'stopping the world' for the object to migrate. |hpx| will make sure
  that no work is being performed on an object before it is migrated and that
  all subsequently scheduled work for the migrated object will be transparently
  forwarded to the new locality. Please note that the global id of the migrated
  object does not change, thus the application will not have to be changed in
  any way to support this new functionality. Please note that this feature is
  currently considered experimental. See :hpx-issue:`559` and :hpx-pr:`1966` for
  more details.
* The ``hpx::dataflow`` facility is now usable with actions. Similarly to
  ``hpx::async``, actions can be specified as an explicit template argument
  (``hpx::dataflow<Action>(target, ...)``) or as the first argument
  (``hpx::dataflow(Action(), target, ...)``). We have also enabled the use of
  distribution policies as the target for dataflow invocations. Please see
  :hpx-issue:`1265` and :hpx-pr:`1912` for more information.
* Adding overloads of ``gather_here`` and ``gather_there`` to accept the plain
  values of the data to gather (in addition to the existing overloads expecting
  futures).
* We have cleaned up and refactored large parts of the code base. This helped
  reducing compile and link times of |hpx| itself and also of applications
  depending on it. We have further decreased the dependency of |hpx| on the
  Boost libraries by replacing part of those with facilities available from the
  standard libraries.
* Wherever possible we have removed dependencies of our API on Boost by
  replacing those with the equivalent facility from the C++11 standard library.
* We have added new performance counters for parcel coalescing, file-IO, the
  AGAS cache, and overall scheduler time. Resetting performance counters has
  been overhauled and fixed.
* We have introduced a generic client type ``hpx::components::client<>`` and
  added support for using it with ``hpx::async``. This removes the necessity to
  implement specific client types for every component type without losing type
  safety. This deemphasizes the need for using the low level ``hpx::id_type``
  for referencing (possibly remote) component instances. The plan is to
  deprecate the direct use of ``hpx::id_type`` in user code in the future.
* We have added a special iterator which supports automatic prefetching of one
  or more arrays for speeding up loop-like code (see
  ``hpx::parallel::util::make_prefetcher_context()``).
* We have extended the interfaces exposed from executors (as proposed by
  |cpp11_n4406|_) to accept an arbitrary number of arguments.

Breaking changes
================

* In order to move the dataflow facility to ``namespace hpx`` we added a
  definition of ``hpx::dataflow`` which might create ambiguities in existing
  codes. The previous definition of this facility (``hpx::lcos::local::dataflow``)
  has been deprecated and is available only if the constant
  ``-DHPX_WITH_LOCAL_DATAFLOW_COMPATIBILITY=On`` to |cmake|_ is defined at
  configuration time.
  Please explicitly qualify all uses of the dataflow facility if you enable
  this compatibility setting and encounter ambiguities.
* The adaptation of the C++ Extensions for Ranges (|cpp17_n4560|_) proposal
  imposes some breaking changes related to the return types of some of the
  parallel algorithms. Please see :hpx-issue:`1668` for a list of algorithms which
  have already been adapted.
* The facility ``hpx::lcos::make_future_void()`` has been replaced by
  ``hpx::make_future<void>()``.
* We have removed support for Intel V13 and gcc 4.4.x.
* We have removed (default) support for the generic
  ``hpx::parallel::execution_poliy`` because it was removed from the Parallelism
  TS (__cpp11_n4104__) while it was being added to the upcoming C++17 Standard.
  This facility can be still enabled at configure time by specifying
  ``-DHPX_WITH_GENERIC_EXECUTION_POLICY=On`` to |cmake|.
* Uses of ``boost::shared_ptr`` and related facilities have been replaced with
  ``std::shared_ptr`` and friends. Uses of ``boost::unique_lock``,
  ``boost::lock_guard`` etc. have also been replaced by the equivalent (and
  equally named) tools available from the C++11 standard library.
* Facilities that used to expect an explicit ``boost::unique_lock`` now take an
  ``std::unique_lock``. Additionally, ``condition_variable`` no longer aliases
  ``condition_variable_any``; its interface now only works with
  ``std::unique_lock<local::mutex>``.
* Uses of ``boost::function``, ``boost::bind``, ``boost::tuple`` have been replaced
  by the corresponding facilities in |hpx| (``hpx::util::function``,
  ``hpx::util::bind``, and ``hpx::util::tuple``, respectively).

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-pr:`2250` - change default chunker of parallel executor to static one
* :hpx-pr:`2247` - HPX on ppc64le
* :hpx-pr:`2244` - Fixing MSVC problems
* :hpx-pr:`2238` - Fixing small typos
* :hpx-pr:`2237` - Fixing small typos
* :hpx-pr:`2234` - Fix broken add test macro when extra args are passed in
* :hpx-pr:`2231` - Fixing possible race during future awaiting in serialization
* :hpx-pr:`2230` - Fix stream nvcc
* :hpx-pr:`2229` - Fixed run_as_hpx_thread
* :hpx-pr:`2228` - On prefetching_test branch : adding prefetching_iterator and
  related tests used for prefetching containers within lambda functions
* :hpx-pr:`2227` - Support for HPXCL's opencl::event
* :hpx-pr:`2226` - Preparing for release of V0.9.99
* :hpx-pr:`2225` - fix issue when compiling components with hpxcxx
* :hpx-pr:`2224` - Compute alloc fix
* :hpx-pr:`2223` - Simplify promise
* :hpx-pr:`2222` - Replace last uses of boost::function by util::function_nonser
* :hpx-pr:`2221` - Fix config tests
* :hpx-pr:`2220` - Fixing gcc 4.6 compilation issues
* :hpx-pr:`2219` - nullptr support for ``[unique_]function``
* :hpx-pr:`2218` - Introducing clang tidy
* :hpx-pr:`2216` - Replace NULL with nullptr
* :hpx-issue:`2214` - Let inspect flag use of NULL, suggest nullptr instead
* :hpx-pr:`2213` - Require support for nullptr
* :hpx-pr:`2212` - Properly find jemalloc through pkg-config
* :hpx-pr:`2211` - Disable a couple of warnings reported by Intel on Windows
* :hpx-pr:`2210` - Fixed host::block_allocator::bulk_construct
* :hpx-pr:`2209` - Started to clean up new sort algorithms, made things compile
  for sort_by_key
* :hpx-pr:`2208` - A couple of fixes that were exposed by a new sort algorithm
* :hpx-pr:`2207` - Adding missing includes in /hpx/include/serialization.hpp
* :hpx-pr:`2206` - Call package_action::get_future before package_action::apply
* :hpx-pr:`2205` - The indirect_packaged_task::operator() needs to be run on a
  HPX thread
* :hpx-pr:`2204` - Variadic executor parameters
* :hpx-pr:`2203` - Delay-initialize members of partitioned iterator
* :hpx-pr:`2202` - Added segmented fill for hpx::vector
* :hpx-issue:`2201` - Null Thread id encountered on partitioned_vector
* :hpx-pr:`2200` - Fix hangs
* :hpx-pr:`2199` - Deprecating hpx/traits.hpp
* :hpx-pr:`2198` - Making explicit inclusion of external libraries into build
* :hpx-pr:`2197` - Fix typo in QT CMakeLists
* :hpx-pr:`2196` - Fixing a gcc warning about attributes being ignored
* :hpx-pr:`2194` - Fixing partitioned_vector_spmd_foreach example
* :hpx-issue:`2193` - partitioned_vector_spmd_foreach seg faults
* :hpx-pr:`2192` - Support Boost.Thread v4
* :hpx-pr:`2191` - HPX.Compute prototype
* :hpx-pr:`2190` - Spawning operation on new thread if remaining stack space
  becomes too small
* :hpx-pr:`2189` - Adding callback taking index and future to when_each
* :hpx-pr:`2188` - Adding new example demonstrating receive_buffer
* :hpx-pr:`2187` - Mask 128-bit ints if CUDA is being used
* :hpx-pr:`2186` - Make startup & shutdown functions unique_function
* :hpx-pr:`2185` - Fixing logging output not to cause hang on shutdown
* :hpx-pr:`2184` - Allowing component clients as action return types
* :hpx-issue:`2183` - Enabling logging output causes hang on shutdown
* :hpx-issue:`2182` - 1d_stencil seg fault
* :hpx-issue:`2181` - Setting small stack size does not change default
* :hpx-pr:`2180` - Changing default bind mode to balanced
* :hpx-pr:`2179` - adding prefetching_iterator and related tests used for
  prefetching containers within lambda functions
* :hpx-pr:`2177` - Fixing 2176
* :hpx-issue:`2176` - Launch process test fails on OSX
* :hpx-pr:`2175` - Fix unbalanced config/warnings includes, add some new ones
* :hpx-pr:`2174` - Fix test categorization : regression not unit
* :hpx-issue:`2172` - Different performance results
* :hpx-issue:`2171` - "negative entry in reference count table" running
  octotiger on 32 nodes on queenbee
* :hpx-issue:`2170` - Error while compiling on Mac + boost 1.60
* :hpx-pr:`2168` - Fixing problems with is_bitwise_serializable
* :hpx-issue:`2167` - startup & shutdown function should accept unique_function
* :hpx-issue:`2166` - Simple receive_buffer example
* :hpx-pr:`2165` - Fix wait all
* :hpx-pr:`2164` - Fix wait all
* :hpx-pr:`2163` - Fix some typos in config tests
* :hpx-pr:`2162` - Improve #includes
* :hpx-pr:`2160` - Add inspect check for missing #include <list>
* :hpx-pr:`2159` - Add missing finalize call to stop test hanging
* :hpx-pr:`2158` - Algo fixes
* :hpx-pr:`2157` - Stack check
* :hpx-issue:`2156` - OSX reports stack space incorrectly (generic context
  coroutines)
* :hpx-issue:`2155` - Race condition suspected in runtime
* :hpx-pr:`2154` - Replace boost::detail::atomic_count with the new
  util::atomic_count
* :hpx-pr:`2153` - Fix stack overflow on OSX
* :hpx-pr:`2152` - Define is_bitwise_serializable as is_trivially_copyable when
  available
* :hpx-pr:`2151` - Adding missing <cstring> for std::mem* functions
* :hpx-issue:`2150` - Unable to use component clients as action return types
* :hpx-pr:`2149` - std::memmove copies bytes, use bytes*sizeof(type) when
  copying larger types
* :hpx-pr:`2146` - Adding customization point for parallel copy/move
* :hpx-pr:`2145` - Applying changes to address warnings issued by latest version
  of PVS Studio
* :hpx-issue:`2148` - hpx::parallel::copy is broken after trivially copyable
  changes
* :hpx-pr:`2144` - Some minor tweaks to compute prototype
* :hpx-pr:`2143` - Added Boost version support information over OSX platform
* :hpx-pr:`2142` - Fixing memory leak in example
* :hpx-pr:`2141` - Add missing specializations in execution policies
* :hpx-pr:`2139` - This PR fixes a few problems reported by Clang's Undefined
  Behavior sanitizer
* :hpx-pr:`2138` - Revert "Adding fedora docs"
* :hpx-pr:`2136` - Removed double semicolon
* :hpx-pr:`2135` - Add deprecated #include check for hpx_fwd.hpp
* :hpx-pr:`2134` - Resolved memory leak in stencil_8
* :hpx-pr:`2133` - Replace uses of boost pointer containers
* :hpx-pr:`2132` - Removing unused typedef
* :hpx-pr:`2131` - Add several include checks for std facilities
* :hpx-pr:`2130` - Fixing parcel compression, adding test
* :hpx-pr:`2129` - Fix invalid attribute warnings
* :hpx-issue:`2128` - hpx::init seems to segfault
* :hpx-pr:`2127` - Making executor_traits N-nary
* :hpx-pr:`2126` - GCC 4.6 fails to deduce the correct type in lambda
* :hpx-pr:`2125` - Making parcel coalescing test actually test something
* :hpx-issue:`2124` - Make a testcase for parcel compression
* :hpx-issue:`2123` - hpx/hpx/runtime/applier_fwd.hpp - Multiple defined types
* :hpx-issue:`2122` - Exception in primary_namespace::resolve_free_list
* :hpx-issue:`2121` - Possible memory leak in 1d_stencil_8
* :hpx-pr:`2120` - Fixing 2119
* :hpx-issue:`2119` - reduce_by_key compilation problems
* :hpx-issue:`2118` - Premature unwrapping of boost::ref'ed arguments
* :hpx-pr:`2117` - Added missing initializer on last constructor for
  thread_description
* :hpx-pr:`2116` - Use a lightweight bind implementation when no placeholders
  are given
* :hpx-pr:`2115` - Replace boost::shared_ptr with std::shared_ptr
* :hpx-pr:`2114` - Adding hook functions for executor_parameter_traits
  supporting timers
* :hpx-issue:`2113` - Compilation error with gcc version 4.9.3 (MacPorts gcc49
  4.9.3_0)
* :hpx-pr:`2112` - Replace uses of safe_bool with explicit operator bool
* :hpx-issue:`2111` - Compilation error on QT example
* :hpx-issue:`2110` - Compilation error when passing non-future argument to
  unwrapped continuation in dataflow
* :hpx-issue:`2109` - Warning while compiling hpx
* :hpx-issue:`2109` - Stack trace of last bug causing issues with octotiger
* :hpx-issue:`2108` - Stack trace of last bug causing issues with octotiger
* :hpx-pr:`2107` - Making sure that a missing parcel_coalescing module does not
  cause startup exceptions
* :hpx-pr:`2106` - Stop using hpx_fwd.hpp
* :hpx-issue:`2105` - coalescing plugin handler is not optional any more
* :hpx-issue:`2104` - Make executor_traits N-nary
* :hpx-issue:`2103` - Build error with octotiger and hpx commit e657426d
* :hpx-pr:`2102` - Combining thread data storage
* :hpx-pr:`2101` - Added repartition version of 1d stencil that uses any
  performance counter
* :hpx-pr:`2100` - Drop obsolete TR1 result_of protocol
* :hpx-pr:`2099` - Replace uses of boost::bind with util::bind
* :hpx-pr:`2098` - Deprecated inspect checks
* :hpx-pr:`2097` - Reduce by key, extends #1141
* :hpx-pr:`2096` - Moving local cache from external to hpx/util
* :hpx-pr:`2095` - Bump minimum required Boost to 1.50.0
* :hpx-pr:`2094` - Add include checks for several Boost utilities
* :hpx-issue:`2093` - /.../local_cache.hpp(89): error #303: explicit type is
  missing ("int" assumed)
* :hpx-pr:`2091` - Fix for Raspberry pi build
* :hpx-pr:`2090` - Fix storage size for util::function<>
* :hpx-pr:`2089` - Fix #2088
* :hpx-issue:`2088` - More verbose output from cmake configuration
* :hpx-pr:`2087` - Making sure init_globally always executes hpx_main
* :hpx-issue:`2086` - Race condition with recent HPX
* :hpx-pr:`2085` - Adding #include checker
* :hpx-pr:`2084` - Replace boost lock types with standard library ones
* :hpx-pr:`2083` - Simplify packaged task
* :hpx-pr:`2082` - Updating APEX version for testing
* :hpx-pr:`2081` - Cleanup exception headers
* :hpx-pr:`2080` - Make call_once variadic
* :hpx-issue:`2079` - With GNU C++, line 85 of hpx/config/version.hpp causes
  link failure when linking application
* :hpx-issue:`2078` - Simple test fails with _GLIBCXX_DEBUG defined
* :hpx-pr:`2077` - Instantiate board in nqueen client
* :hpx-pr:`2076` - Moving coalescing registration to TUs
* :hpx-pr:`2075` - Fixed some documentation typos
* :hpx-pr:`2074` - Adding flush-mode to message handler flush
* :hpx-pr:`2073` - Fixing performance regression introduced lately
* :hpx-pr:`2072` - Refactor local::condition_variable
* :hpx-pr:`2071` - Timer based on boost::asio::deadline_timer
* :hpx-pr:`2070` - Refactor tuple based functionality
* :hpx-pr:`2069` - Fixed typos
* :hpx-issue:`2068` - Seg fault with octotiger
* :hpx-pr:`2067` - Algorithm cleanup
* :hpx-pr:`2066` - Split credit fixes
* :hpx-pr:`2065` - Rename HPX_MOVABLE_BUT_NOT_COPYABLE to HPX_MOVABLE_ONLY
* :hpx-pr:`2064` - Fixed some typos in docs
* :hpx-pr:`2063` - Adding example demonstrating template components
* :hpx-issue:`2062` - Support component templates
* :hpx-pr:`2061` - Replace some uses of lexical_cast<string> with C++11
  std::to_string
* :hpx-pr:`2060` - Replace uses of boost::noncopyable with HPX_NON_COPYABLE
* :hpx-pr:`2059` - Adding missing for_loop algorithms
* :hpx-pr:`2058` - Move several definitions to more appropriate headers
* :hpx-pr:`2057` - Simplify assert_owns_lock and ignore_while_checking
* :hpx-pr:`2056` - Replacing std::result_of with util::result_of
* :hpx-pr:`2055` - Fix process launching/connecting back
* :hpx-pr:`2054` - Add a forwarding coroutine header
* :hpx-pr:`2053` - Replace uses of boost::unordered_map with std::unordered_map
* :hpx-pr:`2052` - Rewrite tuple unwrap
* :hpx-pr:`2050` - Replace uses of BOOST_SCOPED_ENUM with C++11 scoped enums
* :hpx-pr:`2049` - Attempt to narrow down split_credit problem
* :hpx-pr:`2048` - Fixing gcc startup hangs
* :hpx-pr:`2047` - Fixing when_xxx and wait_xxx for MSVC12
* :hpx-pr:`2046` - adding persistent_auto_chunk_size and related tests for
  for_each
* :hpx-pr:`2045` - Fixing HPX_HAVE_THREAD_BACKTRACE_DEPTH build time
  configuration
* :hpx-pr:`2044` - Adding missing service executor types
* :hpx-pr:`2043` - Removing ambiguous definitions for is_future_range and
  future_range_traits
* :hpx-pr:`2042` - Clarify that HPX builds can use (much) more than 2GB per
  process
* :hpx-pr:`2041` - Changing future_iterator_traits to support pointers
* :hpx-issue:`2040` - Improve documentation memory usage warning?
* :hpx-pr:`2039` - Coroutine cleanup
* :hpx-pr:`2038` - Fix cmake policy CMP0042 warning MACOSX_RPATH
* :hpx-pr:`2037` - Avoid redundant specialization of [unique_]function_nonser
* :hpx-pr:`2036` - nvcc dies with an internal error upon pushing/popping
  warnings inside templates
* :hpx-issue:`2035` - Use a less restrictive iterator definition in
  hpx::lcos::detail::future_iterator_traits
* :hpx-pr:`2034` - Fixing compilation error with thread queue wait time
  performance counter
* :hpx-issue:`2033` - Compilation error when compiling with thread queue
  waittime performance counter
* :hpx-issue:`2032` - Ambiguous template instantiation for is_future_range and
  future_range_traits.
* :hpx-pr:`2031` - Don't restart timer on every incoming parcel
* :hpx-pr:`2030` - Unify handling of execution policies in parallel algorithms
* :hpx-pr:`2029` - Make pkg-config .pc files use .dylib on OSX
* :hpx-pr:`2028` - Adding process component
* :hpx-pr:`2027` - Making check for compiler compatibility independent on
  compiler path
* :hpx-pr:`2025` - Fixing inspect tool
* :hpx-pr:`2024` - Intel13 removal
* :hpx-pr:`2023` - Fix errors related to older boost versions and parameter pack
  expansions in lambdas
* :hpx-issue:`2022` - gmake fail: "No rule to make target
  /usr/lib46/libboost_context-mt.so"
* :hpx-pr:`2021` - Added Sudoku example
* :hpx-issue:`2020` - Make errors related to init_globally.cpp example while
  building HPX out of the box
* :hpx-pr:`2019` - Fixed some compilation and cmake errors encountered in nqueen
  example
* :hpx-pr:`2018` - For loop algorithms
* :hpx-pr:`2017` - Non-recursive at_index implementation
* :hpx-issue:`2016` - Add index-based for-loops
* :hpx-issue:`2015` - Change default bind-mode to balanced
* :hpx-pr:`2014` - Fixed dataflow if invoked action returns a future
* :hpx-pr:`2013` - Fixing compilation issues with external example
* :hpx-pr:`2012` - Added Sierpinski Triangle example
* :hpx-issue:`2011` - Compilation error while running sample
  hello_world_component code
* :hpx-pr:`2010` - Segmented move implemented for hpx::vector
* :hpx-issue:`2009` - pkg-config order incorrect on 14.04 / GCC 4.8
* :hpx-issue:`2008` - Compilation error in dataflow of action returning a future
* :hpx-pr:`2007` - Adding new performance counter exposing overall scheduler
  time
* :hpx-pr:`2006` - Function includes
* :hpx-pr:`2005` - Adding an example demonstrating how to initialize HPX from a
  global object
* :hpx-pr:`2004` - Fixing 2000
* :hpx-pr:`2003` - Adding generation parameter to gather to enable using it more
  than once
* :hpx-pr:`2002` - Turn on position independent code to solve link problem with
  hpx_init
* :hpx-issue:`2001` - Gathering more than once segfaults
* :hpx-issue:`2000` - Undefined reference to hpx::assertion_failed
* :hpx-issue:`1999` - Seg fault in
  hpx::lcos::base_lco_with_value<*>::set_value_nonvirt() when running octo-tiger
* :hpx-pr:`1998` - Detect unknown command line options
* :hpx-pr:`1997` - Extending thread description
* :hpx-pr:`1996` - Adding natvis files to solution (MSVC only)
* :hpx-issue:`1995` - Command line handling does not produce error
* :hpx-pr:`1994` - Possible missing include in test_utils.hpp
* :hpx-pr:`1993` - Add missing LANGUAGES tag to a
  hpx_add_compile_flag_if_available() call in CMakeLists.txt
* :hpx-pr:`1992` - Fixing shared_executor_test
* :hpx-pr:`1991` - Making sure the winsock library is properly initialized
* :hpx-pr:`1990` - Fixing bind_test placeholder ambiguity coming from boost-1.60
* :hpx-pr:`1989` - Performance tuning
* :hpx-pr:`1987` - Make configurable size of internal storage in util::function
* :hpx-pr:`1986` - AGAS Refactoring+1753 Cache mods
* :hpx-pr:`1985` - Adding missing task_block::run() overload taking an executor
* :hpx-pr:`1984` - Adding an optimized LRU Cache implementation (for AGAS)
* :hpx-pr:`1983` - Avoid invoking migration table look up for all objects
* :hpx-pr:`1981` - Replacing uintptr_t (which is not defined everywhere) with
  std::size_t
* :hpx-pr:`1980` - Optimizing LCO continuations
* :hpx-pr:`1979` - Fixing Cori
* :hpx-pr:`1978` - Fix test check that got broken in hasty fix to memory
  overflow
* :hpx-pr:`1977` - Refactor action traits
* :hpx-pr:`1976` - Fixes typo in README.rst
* :hpx-pr:`1975` - Reduce size of benchmark timing arrays to fix test failures
* :hpx-pr:`1974` - Add action to update data owned by the partitioned_vector
  component
* :hpx-pr:`1972` - Adding partitioned_vector SPMD example
* :hpx-pr:`1971` - Fixing 1965
* :hpx-pr:`1970` - Papi fixes
* :hpx-pr:`1969` - Fixing continuation recursions to not depend on fixed amount
  of recursions
* :hpx-pr:`1968` - More segmented algorithms
* :hpx-issue:`1967` - Simplify component implementations
* :hpx-pr:`1966` - Migrate components
* :hpx-issue:`1964` - fatal error: 'boost/lockfree/detail/branch_hints.hpp' file
  not found
* :hpx-issue:`1962` - parallel:copy_if has race condition when used on in place
  arrays
* :hpx-pr:`1963` - Fixing Static Parcelport initialization
* :hpx-pr:`1961` - Fix function target
* :hpx-issue:`1960` - Papi counters don't reset
* :hpx-pr:`1959` - Fixing 1958
* :hpx-issue:`1958` - inclusive_scan gives incorrect results with
  non-commutative operator
* :hpx-pr:`1957` - Fixing #1950
* :hpx-pr:`1956` - Sort by key example
* :hpx-pr:`1955` - Adding regression test for #1946: Hang in wait_all() in
  distributed run
* :hpx-issue:`1954` - HPX releases should not use -Werror
* :hpx-pr:`1953` - Adding performance analysis for AGAS cache
* :hpx-pr:`1952` - Adapting test for explicit variadics to fail for gcc 4.6
* :hpx-pr:`1951` - Fixing memory leak
* :hpx-issue:`1950` - Simplify external builds
* :hpx-pr:`1949` - Fixing yet another lock that is being held during suspension
* :hpx-pr:`1948` - Fixed container algorithms for Intel
* :hpx-pr:`1947` - Adding workaround for tagged_tuple
* :hpx-issue:`1946` - Hang in wait_all() in distributed run
* :hpx-pr:`1945` - Fixed container algorithm tests
* :hpx-issue:`1944` - assertion 'p.destination_locality() ==
  hpx::get_locality()' failed
* :hpx-pr:`1943` - Fix a couple of compile errors with clang
* :hpx-pr:`1942` - Making parcel coalescing functional
* :hpx-issue:`1941` - Re-enable parcel coalescing
* :hpx-pr:`1940` - Touching up make_future
* :hpx-pr:`1939` - Fixing problems in over-subscription management in the
  resource manager
* :hpx-pr:`1938` - Removing use of unified Boost.Thread header
* :hpx-pr:`1937` - Cleaning up the use of Boost.Accumulator headers
* :hpx-pr:`1936` - Making sure interval timer is started for aggregating
  performance counters
* :hpx-pr:`1935` - Tagged results
* :hpx-pr:`1934` - Fix remote async with deferred launch policy
* :hpx-issue:`1933` - Floating point exception in
  ``statistics_counter<boost::accumulators::tag::mean>::get_counter_value``
* :hpx-pr:`1932` - Removing superfluous includes of
  boost/lockfree/detail/branch_hints.hpp
* :hpx-pr:`1931` - fix compilation with clang 3.8.0
* :hpx-issue:`1930` - Missing online documentation for HPX 0.9.11
* :hpx-pr:`1929` - LWG2485: get() should be overloaded for const tuple&&
* :hpx-pr:`1928` - Revert "Using ninja for circle-ci builds"
* :hpx-pr:`1927` - Using ninja for circle-ci builds
* :hpx-pr:`1926` - Fixing serialization of std::array
* :hpx-issue:`1925` - Issues with static HPX libraries
* :hpx-issue:`1924` - Performance degrading over time
* :hpx-issue:`1923` - serialization of std::array appears broken in latest
  commit
* :hpx-pr:`1922` - Container algorithms
* :hpx-pr:`1921` - Tons of smaller quality improvements
* :hpx-issue:`1920` - Seg fault in hpx::serialization::output_archive::add_gid
  when running octotiger
* :hpx-issue:`1919` - Intel 15 compiler bug preventing HPX build
* :hpx-pr:`1918` - Address sanitizer fixes
* :hpx-pr:`1917` - Fixing compilation problems of parallel::sort with Intel
  compilers
* :hpx-pr:`1916` - Making sure code compiles if HPX_WITH_HWLOC=Off
* :hpx-issue:`1915` - max_cores undefined if HPX_WITH_HWLOC=Off
* :hpx-pr:`1913` - Add utility member functions for partitioned_vector
* :hpx-pr:`1912` - Adding support for invoking actions to dataflow
* :hpx-pr:`1911` - Adding first batch of container algorithms
* :hpx-pr:`1910` - Keep cmake_module_path
* :hpx-pr:`1909` - Fix mpirun with pbs
* :hpx-pr:`1908` - Changing parallel::sort to return the last iterator as
  proposed by N4560
* :hpx-pr:`1907` - Adding a minimum version for Open MPI
* :hpx-pr:`1906` - Updates to the Release Procedure
* :hpx-pr:`1905` - Fixing #1903
* :hpx-pr:`1904` - Making sure std containers are cleared before serialization
  loads data
* :hpx-issue:`1903` - When running octotiger, I get: assertion
  ``'(*new_gids_)[gid].size() == 1' failed: HPX(assertion_failure)``
* :hpx-issue:`1902` - Immediate crash when running hpx/octotiger with
  _GLIBCXX_DEBUG defined.
* :hpx-pr:`1901` - Making non-serializable classes non-serializable
* :hpx-issue:`1900` - Two possible issues with std::list serialization
* :hpx-pr:`1899` - Fixing a problem with credit splitting as revealed by #1898
* :hpx-issue:`1898` - Accessing component from locality where it was not created
  segfaults
* :hpx-pr:`1897` - Changing parallel::sort to return the last iterator as
  proposed by N4560
* :hpx-issue:`1896` - version 1.0?
* :hpx-issue:`1895` - Warning comment on numa_allocator is not very clear
* :hpx-pr:`1894` - Add support for compilers that have thread_local
* :hpx-pr:`1893` - Fixing 1890
* :hpx-pr:`1892` - Adds typed future_type for executor_traits
* :hpx-pr:`1891` - Fix wording in certain parallel algorithm docs
* :hpx-issue:`1890` - Invoking papi counters give segfault
* :hpx-pr:`1889` - Fixing problems as reported by clang-check
* :hpx-pr:`1888` - WIP parallel is_heap
* :hpx-pr:`1887` - Fixed resetting performance counters related to idle-rate,
  etc
* :hpx-issue:`1886` - Run hpx with qsub does not work
* :hpx-pr:`1885` - Warning cleaning pass
* :hpx-pr:`1884` - Add missing parallel algorithm header
* :hpx-pr:`1883` - Add feature test for thread_local on Clang for TLS
* :hpx-pr:`1882` - Fix some redundant qualifiers
* :hpx-issue:`1881` - Unable to compile Octotiger using HPX and Intel MPI on
  SuperMIC
* :hpx-issue:`1880` - clang with libc++ on Linux needs TLS case
* :hpx-pr:`1879` - Doc fixes for #1868
* :hpx-pr:`1878` - Simplify functions
* :hpx-pr:`1877` - Removing most usage of Boost.Config
* :hpx-pr:`1876` - Add missing parallel algorithms to algorithm.hpp
* :hpx-pr:`1875` - Simplify callables
* :hpx-pr:`1874` - Address long standing FIXME on using ``std::unique_ptr`` with
  incomplete types
* :hpx-pr:`1873` - Fixing 1871
* :hpx-pr:`1872` - Making sure PBS environment uses specified node list even if
  no PBS_NODEFILE env is available
* :hpx-issue:`1871` - Fortran checks should be optional
* :hpx-pr:`1870` - Touch local::mutex
* :hpx-pr:`1869` - Documentation refactoring based off #1868
* :hpx-pr:`1867` - Embrace static_assert
* :hpx-pr:`1866` - Fix #1803 with documentation refactoring
* :hpx-pr:`1865` - Setting OUTPUT_NAME as target properties
* :hpx-pr:`1863` - Use SYSTEM for boost includes
* :hpx-pr:`1862` - Minor cleanups
* :hpx-pr:`1861` - Minor Corrections for Release
* :hpx-pr:`1860` - Fixing hpx gdb script
* :hpx-issue:`1859` - reset_active_counters resets times and thread counts
  before some of the counters are evaluated
* :hpx-pr:`1858` - Release V0.9.11
* :hpx-pr:`1857` - removing diskperf example from 9.11 release
* :hpx-pr:`1856` - fix return in packaged_task_base::reset()
* :hpx-issue:`1842` - Install error: file INSTALL cannot find
  libhpx_parcel_coalescing.so.0.9.11
* :hpx-pr:`1839` - Adding fedora docs
* :hpx-pr:`1824` - Changing version on master to V0.9.12
* :hpx-pr:`1818` - Fixing #1748
* :hpx-issue:`1815` - seg fault in AGAS
* :hpx-issue:`1803` - wait_all documentation
* :hpx-issue:`1796` - Outdated documentation to be revised
* :hpx-issue:`1759` - glibc munmap_chunk or free(): invalid pointer on SuperMIC
* :hpx-issue:`1753` - HPX performance degrades with time since execution begins
* :hpx-issue:`1748` - All public HPX headers need to be self contained
* :hpx-pr:`1719` - How to build HPX with Visual Studio
* :hpx-issue:`1684` - Race condition when using --hpx:connect?
* :hpx-pr:`1658` - Add serialization for std::set (as there is for std::vector
  and std::map)
* :hpx-pr:`1641` - Generic client
* :hpx-issue:`1632` - heartbeat example fails on separate nodes
* :hpx-pr:`1603` - Adds preferred namespace check to inspect tool
* :hpx-issue:`1559` - Extend inspect tool
* :hpx-issue:`1523` - Remote async with deferred launch policy never executes
* :hpx-issue:`1472` - Serialization issues
* :hpx-issue:`1457` - Implement N4392: C++ Latches and Barriers
* :hpx-pr:`1444` - Enabling usage of moveonly types for component construction
* :hpx-issue:`1407` - The Intel 13 compiler has failing unit tests
* :hpx-issue:`1405` - Allow component constructors to take movable only types
* :hpx-issue:`1265` - Enable dataflow() to be usable with actions
* :hpx-issue:`1236` - NUMA aware allocators
* :hpx-issue:`802` - Fix Broken Examples
* :hpx-issue:`559` - Add hpx::migrate facility
* :hpx-issue:`449` - Make actions with template arguments usable and add
  documentation
* :hpx-issue:`279` - Refactor addressing_service into a base class and two
  derived classes
* :hpx-issue:`224` - Changing thread state metadata is not thread safe
* :hpx-issue:`55` - Uniform syntax for enums should be implemented

.. Proofread by:
   Adrian Serio 6-28-16
   Patricia Grubel 3-20-15
..
    Copyright (C) 2020-2021 ETH Zurich
    Copyright (C) 2007-2020 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_7_0:

===========================
|hpx| V1.7.0 (Jul 14, 2021)
===========================

This release is again focused on C++20 conformance of algorithms. Additionally,
many new experimental sender-based algorithms have been added based on the
latest proposals.

General changes
===============

- The following algorithms have been adapted to be C++20 conformant:

  - ``remove``,
  - ``remove_if``,
  - ``remove_copy``,
  - ``remove_copy_if``,
  - ``replace``,
  - ``replace_if``,
  - ``reverse``, and
  - ``lexicographical_compare``.

- When the compiler and standard library support the standard execution policies
  ``std::execution::seq``, ``std::execution::par``, and
  ``std::execution::par_unseq`` they can now be used in all |hpx| parallel
  algorithms with equivalent behaviour to the non-task policies
  ``hpx::execution::seq``, ``hpx::execution::par``, and
  ``hpx::execution::par_unseq``.
- Vc support has been fixed, after being broken in 1.6.0. In addition, |hpx| now
  experimentally supports GCC's SIMD implementation, when available. The
  implementation can be used through the ``hpx::execution::simd`` and
  ``hpx::execution::simdpar`` execution policies.
- The customization points ``sync_execute``, ``async_execute``,
  ``then_execute``, ``post``, ``bulk_sync_execute``, ``bulk_async_execute``, and
  ``bulk_then_execute`` are now implemented using ``tag_dispatch`` (previously
  ``tag_invoke``). Executors can still be implemented by providing the
  aforementioned functions as member functions of an executor.
- New functionality, enhancements, and fixes based on P0443r14 (executors
  proposal) and P1897 (sender-based algorithms) have been added to the
  ``hpx::execution::experimental`` namespace. These can be accessed through the
  ``hpx/execution.hpp`` and ``hpx/local/execution.hpp`` headers. In particular,
  the following sender-based algorithms have been added:

  - ``detach``,
  - ``ensure_started``,
  - ``just``,
  - ``just_on``,
  - ``let_error``,
  - ``let_value``,
  - ``on``,
  - ``transform``, and
  - ``when_all``.

  Additionally, futures now implement the sender
  concept. ``make_future`` can be used to turn a sender into a future. All
  functionality is experimental and can change without notice.
- All ``hpx::init`` and ``hpx::start`` overloads now take ``std::function``\ s
  instead of ``hpx::util::function_nonser``. No changes should be required in
  user code to accommodate this change.
- ``hpx::util::unwrapping`` and other related unwrapping functionality has been
  moved up into the ``hpx`` namespace. Names in ``hpx::util`` are still usable
  with a deprecation warning. This functionality can now be accessed through the
  ``hpx/unwrap.hpp`` and ``hpx/local/unwrap.hpp`` headers.
- The default tag for APEX has been update from 2.3.1 to 2.4.0. In particular,
  this fixes a bug which could lead to hangs in distributed runs.
- The dependency on Boost.Asio has been replaced with the standalone Asio
  available at https://github.com/chriskohlhoff/asio. By default, a
  system-installed Asio will be used. ``ASIO_ROOT`` can be given as a hint to
  tell CMake where to find Asio. Alternatively, Asio can be fetched
  automatically  using CMake's fetchcontent by setting
  ``HPX_WITH_FETCH_ASIO=ON``. In general, dependencies on Boost have again been
  reduced.
- Modularization of the library has continued. In this release almost all
  functionality has been moved into modules. These changes do not generally
  affect user code. Warnings are still issued for headers that have moved.
- hipBLAS is now optional when compiling with ``hipcc``. A warning instead of an
  error will be printed if hipBLAS is not found during configuration.
- Previously ``HPX_COMPUTE_HOST_CODE`` was defined in host code only if HPX was
  configured with CUDA or HIP. In this release ``HPX_COMPUTE_HOST_CODE`` is
  always defined in host code.
- An experimental ``HPX_WITH_PRECOMPILED_HEADERS`` CMake option has been added
  to use precompiled headers when building |hpx|. This option should not be used
  on Windows.
- Numerous bug fixes.

Breaking changes
================

- The minimum required CMake version is now 3.17.
- The minimum required Boost version is now 1.71.0.
- The customization mechanism used to implement and extend sender functionality
  and algorithms has been renamed from ``tag_invoke`` to ``tag_dispatch``. All
  customization of sender functionality should be done by overloading
  ``tag_dispatch``.
- The following compatibility options have been removed, along with their
  compatibility implementations:
  - ``HPX_PROGRAM_OPTIONS_WITH_BOOST_PROGRAM_OPTIONS_COMPATIBILITY``
  - ``HPX_WITH_ACTION_BASE_COMPATIBILITY``
  - ``HPX_WITH_EMBEDDED_THREAD_POOLS_COMPATIBILITY``
  - ``HPX_WITH_POOL_EXECUTOR_COMPATIBILITY``.
  - ``HPX_WITH_PROMISE_ALIAS_COMPATIBILITY``
  - ``HPX_WITH_REGISTER_THREAD_COMPATIBILITY``
  - ``HPX_WITH_REGISTER_THREAD_OVERLOADS_COMPATIBILITY``
  - ``HPX_WITH_THREAD_AWARE_TIMER_COMPATIBILITY``
  - ``HPX_WITH_THREAD_EXECUTORS_COMPATIBILITY``
  - ``HPX_WITH_THREAD_POOL_OS_EXECUTOR_COMPATIBILITY``
- The ``HPX_WITH_THREAD_SCHEDULERS`` CMake option has been removed. All
  schedulers are now enabled when possible.
- ``HPX_WITH_INIT_START_OVERLOADS_COMPATIBILITY`` has been turned off by default.

Closed issues
=============

* :hpx-issue:`5423` - Fix lvalue-ref qualified connect for ``when_all-sender``
* :hpx-issue:`5412` - Link error
* :hpx-issue:`5397` - Performance regression in thread annotations
* :hpx-issue:`5395` - HPX 1.7.0-rc1 fails to build icw APEX + OTF2
* :hpx-issue:`5385` - HPX 1.7 crashes on Piz Daint > 64 nodes
* :hpx-issue:`5380` - CMake should search for asio package installed on the
  system
* :hpx-issue:`5378` - HPX 1.7.0 stopped building on Fedora
* :hpx-issue:`5369` - HPX 1.6 and master hangs on Summit for > 64 nodes
* :hpx-issue:`5358` - HPX init fails for single-core environments
* :hpx-issue:`5345` - Rename P2220 property CPOs?
* :hpx-issue:`5333` - HPX does not compile on the new Mac OSX using the M1 chip
* :hpx-issue:`5317` - Consider making hipblas optional
* :hpx-issue:`5306` - asio fails to build with CUDA 10.0
* :hpx-issue:`5294` - ``execution::on`` should be based on
  ``execution::schedule``
* :hpx-issue:`5275` - HPX V1.6.0 fails on Fedora release
* :hpx-issue:`5270` - HPX-1.6.0 fails to build on Windows 10
* :hpx-issue:`5257` - Allow triggering the output of OS thread affinity from
  configuration settings
* :hpx-issue:`5246` - HPX fails to build on ppc64le
* :hpx-issue:`5232` - Annotation using ``hpx::util::annotated_function`` not
  working
* :hpx-issue:`5222` - Build and link errors with ittnotify enabled
* :hpx-issue:`5204` - Move algorithms to tag_fallback_dispatch
* :hpx-issue:`5163` - Remove module-specific compatibility and deprecation
  options
* :hpx-issue:`5161` - Bump required CMake version to 3.17
* :hpx-issue:`5143` - Searching for HPX-Application to generate work on multiple
  Nodes

Closed pull requests
====================

* :hpx-pr:`5438` - Delete datapar/foreach_tests.hpp
* :hpx-pr:`5437` - Add back explicit -pthread flags when available
* :hpx-pr:`5435` - This adds support for systems that assume all types are
  bitwise serializable by default
* :hpx-pr:`5434` - Update CUDA polling logging to be more verbose
* :hpx-pr:`5433` - Fix ``when_all_sender`` connect for references
* :hpx-pr:`5432` - Add deprecation warnings for v1.8
* :hpx-pr:`5431` - Rename the new P0443/P2300 executor to
  ``thread_pool_scheduler``
* :hpx-pr:`5430` - Revert "Adding the missing defined for
  ``HPX_HAVE_DEPRECATION_WARNINGS``"
* :hpx-pr:`5427` - Removing unneeded typedef
* :hpx-pr:`5426` - Adding more concept checks for sender/receiver algorithms
* :hpx-pr:`5425` - Adding the missing defined for
  ``HPX_HAVE_DEPRECATION_WARNINGS``
* :hpx-pr:`5424` - Disable Vc in final docker image created in CI
* :hpx-pr:`5422` - Adding ``execution::experimental::bulk`` algorithm
* :hpx-pr:`5420` - Update logic to find threading library
* :hpx-pr:`5418` - Reduce max size and number of files in ccache cache
* :hpx-pr:`5417` - Final release notes for 1.7.0
* :hpx-pr:`5416` - Adapt ``uninitialized_value_construct`` and
  ``uninitialized_value_construct_n`` to C++ 20
* :hpx-pr:`5415` - Adapt ``uninitialized_default_construct`` and
  ``uninitialized_default_construct_n`` to C++ 20
* :hpx-pr:`5414` - Improve integration of futures and senders
* :hpx-pr:`5413` - Fixing sender/receiver code base to compile with MSVC
* :hpx-pr:`5407` - Handle exceptions thrown during initialization of parcel
  handler
* :hpx-pr:`5406` - Simplify dispatching to annotation handlers
* :hpx-pr:`5405` - Fetch Asio automatically in perftests CI
* :hpx-pr:`5403` - Create generic executor that adds annotations to any other
  executor
* :hpx-pr:`5402` - Adapt ``uninitialized_fill`` and ``uninitialized_fill_n`` to
  C++ 20
* :hpx-pr:`5401` - Modernize a variety of facilities related to parallel
  algorithms
* :hpx-pr:`5400` - Fix sliding semaphore test
* :hpx-pr:`5399` - Rename leftover ``tag_fallback_invoke`` to
  ``tag_fallback_dispatch``
* :hpx-pr:`5398` - Improve logging in AGAS symbol namespace
* :hpx-pr:`5396` - Introduce compatibility layer for collective operations
* :hpx-pr:`5394` - Enable OTF2 in APEX CI configuration
* :hpx-pr:`5393` - Update APEX tag
* :hpx-pr:`5392` - Fixing wrong usage of ``std::forward``
* :hpx-pr:`5391` - Fix forwarding in transform_receiver constructor
* :hpx-pr:`5390` - Make sure shared priority scheduler steals tasks on the
  current NUMA domain when (core) stealing is enabled
* :hpx-pr:`5389` - Adapt ``uninitialized_move`` and ``uninitialized_move_n`` to
  C++ 20
* :hpx-pr:`5388` - Fixing ``gather_there`` for used with lvalue reference
  argument
* :hpx-pr:`5387` - Extend thread state logging and change default stealing
  parameters
* :hpx-pr:`5386` - Attempt to fix the startup hang with nodes > 32
* :hpx-pr:`5384` - Remove HPX 1.5.0 deprecations
* :hpx-pr:`5382` - Prefer installed Asio before considering FetchContent
* :hpx-pr:`5379` - Allow using pre-downloaded (not installed) versions of Asio
  and/or Apex
* :hpx-pr:`5376` - Remove unnecessary explicit listing of library modules.rst
  files in CMakeLists.txt
* :hpx-pr:`5375` - Slight performance improvement for ``hpx::copy`` and
  ``hpx::move`` et.al.
* :hpx-pr:`5374` - Remove unnecessary moves from future sender implementations
* :hpx-pr:`5373` - More changes to clang-cuda Jenkins configuration
* :hpx-pr:`5372` - Slight improvements to ``min/max/minmax_element`` algorithms
* :hpx-pr:`5371` - Adapt ``uninitialized_copy`` and ``uninitialized_copy_n`` to
  C++ 20
* :hpx-pr:`5370` - Decay types in ``just_sender`` ``value_types`` to match
  stored types
* :hpx-pr:`5367` - Disable pkgconfig by default again on macOS
* :hpx-pr:`5365` - Use ccache for Jenkins builds on Piz Daint
* :hpx-pr:`5363` - Update cudatoolkit module name in clang-cuda Jenkins
  configuration
* :hpx-pr:`5362` - Adding ``channel_communicator``
* :hpx-pr:`5361` - Fix compilation with MPI enabled
* :hpx-pr:`5360` - Update APEX and asio tags
* :hpx-pr:`5359` - Fix check for pu-step in single-core case
* :hpx-pr:`5357` - Making sure collective operations can be reused by
  preallocating communicator
* :hpx-pr:`5356` - Update API documentation
* :hpx-pr:`5355` - Make the ``sequenced_executor`` ``processing_units_count``
  member function const
* :hpx-pr:`5354` - Making sure ``default_stack_size`` is defined whenever
  declared
* :hpx-pr:`5353` - Add CUDA timestamp support to HPX Hardware Clock
* :hpx-pr:`5352` - Adding missing includes
* :hpx-pr:`5351` - Adding ``enable_logging/disable_logging`` API functions
* :hpx-pr:`5350` - Adapt lexicographical_compare to C++20
* :hpx-pr:`5349` - Update minimum boost version needed on the docs
* :hpx-pr:`5348` - Rename ``tag_invoke`` and related facilities to
  ``tag_dispatch``
* :hpx-pr:`5347` - Remove ``make_`` prefix for executor properties
* :hpx-pr:`5346` - Remove and disable compatibility options for 1.7.0
* :hpx-pr:`5343` - Fix timed_executor static cast conversion
* :hpx-pr:`5342` - Refactor CUDA event polling
* :hpx-pr:`5341` - Adding ``make_with_annotation`` and ``get_annotation``
  properties
* :hpx-pr:`5339` - Making sure ``hpx::util::hardware::timestamp()`` is always
  defined
* :hpx-pr:`5338` - Fixing ``timed_executor`` specializations of customization
  points
* :hpx-pr:`5335` - Make ``partial_algorithm`` work with any number of arguments
* :hpx-pr:`5334` - Follow up ``iter_sent`` include on #5225
* :hpx-pr:`5332` - Simplify ``tag_invoke`` and friends
* :hpx-pr:`5331` - More work on cleaning up executor CPOs
* :hpx-pr:`5330` - Add option to disable pkgconfig generation
* :hpx-pr:`5328` - Adapt data parallel support using std-simd
* :hpx-pr:`5327` - Fix missing ``ifdef HPX_SMT_PAUSE``
* :hpx-pr:`5326` - Adding ``resize()`` to ``serialize_buffer`` allowing to
  shrink its size
* :hpx-pr:`5324` - Add get member functions to ``async_rw_mutex`` proxy objects
  for explicitly getting the wrapped value
* :hpx-pr:`5323` - Add ``keep_future`` algorithm
* :hpx-pr:`5322` - Replace executor customization point implementations with
  ``tag_invoke``
* :hpx-pr:`5321` - Seperate segmented algorithms for reduce
* :hpx-pr:`5320` - Fix ``is_sender`` trait and other small fixes to p0443 traits
* :hpx-pr:`5319` - gcc 11.1 c++20 build fixes
* :hpx-pr:`5318` - Make hipblas dependency optional as not always available
* :hpx-pr:`5316` - Attempt to fix checking for libatomic
* :hpx-pr:`5315` - Add explicit keyword to fixture constructor
* :hpx-pr:`5314` - Fix a race condition in async mpi affecting limiting executor
* :hpx-pr:`5312` - Use local runtime and local headers in local-only modules and
  tests
* :hpx-pr:`5311` - Add GCC 11 builder to jenkins
* :hpx-pr:`5310` - Adding ``hpx::execution::experimental::task_group``
* :hpx-pr:`5309` - Seperate datapar
* :hpx-pr:`5308` - Seperate segmented algorithms for ``find``, ``find_if``,
  ``find_if_not``
* :hpx-pr:`5307` - Seperate segmented algorithms for ``fill`` and ``generate``
* :hpx-pr:`5304` - Fix compilation of sender CPOs with nvcc
* :hpx-pr:`5300` - Remove ``PRIVATE`` flag that was propagated into the
  ``LANGUAGES``
* :hpx-pr:`5298` - Seperate datapar
* :hpx-pr:`5297` - Specify exact cmake and ninja versions when loading them in
  jenkins jobs
* :hpx-pr:`5295` - Update clang-newest configuration to use clang 12 and Boost
  1.76.0
* :hpx-pr:`5293` - Fix Clang 11 cuda_future test bug
* :hpx-pr:`5292` - Add ``async_rw_mutex`` based on senders
* :hpx-pr:`5291` - "Fix" termination detection
* :hpx-pr:`5290` - Fixed source file line statements in examples documentation
* :hpx-pr:`5289` - Allow splitting of futures holding ``std::tuple``
* :hpx-pr:`5288` - Move algorithms to ``tag_fallback_invoke``
* :hpx-pr:`5287` - Move algorithms to ``tag_fallback_invoke``
* :hpx-pr:`5285` - Fix clang-format failure on master
* :hpx-pr:`5284` - Replacing ``util::function_nonser`` on std::function in
  ``hpx_init``
* :hpx-pr:`5282` - Update Boost for daint 20.11 after update
* :hpx-pr:`5281` - Fix Segmentation fault on ``foreach_datapar_zipiter``
* :hpx-pr:`5280` - Avoid modulo by zero in ``counting_iterator`` test
* :hpx-pr:`5279` - Fix more GCC 10 deprecation warnings
* :hpx-pr:`5277` - Small fixes and improvements to CUDA/MPI polling
* :hpx-pr:`5276` - Fix typo in docs
* :hpx-pr:`5274` - More P1897 algorithms
* :hpx-pr:`5273` - Retry CDash submissions on failure
* :hpx-pr:`5272` - Fix bogus deprecation warnings with GCC 10
* :hpx-pr:`5271` - Correcting target ids for ``symbol_namespace::iterate``
* :hpx-pr:`5268` - Adding generic ``require``, ``require_concept``, and
  ``query`` properties
* :hpx-pr:`5267` - Support annotations in ``hpx::transform_reduce``
* :hpx-pr:`5266` - Making late command line options available for local runtime
* :hpx-pr:`5265` - Leverage ``no_unique_address`` for ``member_pack``
* :hpx-pr:`5264` - Adopt format in more places
* :hpx-pr:`5262` - Install HPX in Rostam Jenkins jobs
* :hpx-pr:`5261` - Limit Rostam Jenkins jobs to marvin partition temporarily
* :hpx-pr:`5260` - Separate segmented algorithms for transform_reduce
* :hpx-pr:`5259` - Making sure late command line options are recognized as
  configuration options
* :hpx-pr:`5258` - Allow for HPX algorithms being invoked with std execution
  policies
* :hpx-pr:`5256` - Separate segmented algorithms for transform
* :hpx-pr:`5255` - Future/sender adapters
* :hpx-pr:`5254` - Fixing datapar
* :hpx-pr:`5253` - Add utility to format ranges
* :hpx-pr:`5252` - Remove uses of Boost.Bimap
* :hpx-pr:`5251` - Banish ``<iostream>`` from library headers
* :hpx-pr:`5250` - Try fixing vc circle ci
* :hpx-pr:`5249` - Adding missing header
* :hpx-pr:`5248` - Use old Piz Daint modules after upgrade
* :hpx-pr:`5247` - Significantly speedup simple ``for_each``, ``for_loop``, and
  ``transform``
* :hpx-pr:`5245` - P1897 ``operator|`` overloads
* :hpx-pr:`5244` - P1897 ``when_all``
* :hpx-pr:`5243` - Make sure ``HPX_DEBUG`` is set based on HPX's build type, not
  consuming project's build type
* :hpx-pr:`5242` - Moving last files unrelated to parcel layer to modules
* :hpx-pr:`5240` - change namespace for ``transform_loop.hpp``
* :hpx-pr:`5238` - Make sure annotations are used in the binary transform
* :hpx-pr:`5237` - Add P1897 ``just``, ``just_on``, and ``on`` algorithms
* :hpx-pr:`5236` - Add an example demonstrating the use of the
  ``invoke_function_action`` facility
* :hpx-pr:`5235` - Attempting to fix datapar compilation issues
* :hpx-pr:`5234` - Fix small typo in ``--hpx:local`` option description
* :hpx-pr:`5233` - Only find Boost.Iostreams if required for plugins
* :hpx-pr:`5231` - Sort printed config options
* :hpx-pr:`5230` - Fix C++20 replace algo adaptation misses
* :hpx-pr:`5229` - Remove leftover Boost include from ``sync_wait.hpp``
* :hpx-pr:`5228` - Print module name only if it has custom configuration
  settings
* :hpx-pr:`5227` - Update .codespell_whitelist
* :hpx-pr:`5226` - Use new docker image in all CircleCI steps
* :hpx-pr:`5225` - Adapt reverse to C++20
* :hpx-pr:`5224` - Separate segmented algorithms for ``none_of``, ``any_of`` and
  ``all_of``
* :hpx-pr:`5223` - Fixing build system for ittnotify
* :hpx-pr:`5221` - Moving LCO related files to modules
* :hpx-pr:`5220` - Seperate segmented algorithms for ``count`` and ``count_if``
* :hpx-pr:`5218` - Seperate segmented algorithms for ``adjacent_find``
* :hpx-pr:`5217` - Add a HIP github action
* :hpx-pr:`5215` - Update ROCm to 4.0.1 on Rostam
* :hpx-pr:`5214` - Fix clang-format error in sender.hpp
* :hpx-pr:`5213` - Removing ESSENTIAL option to the doc example
* :hpx-pr:`5212` - Seperate segmented algorithms for ``for_each_n``
* :hpx-pr:`5211` - Minor adapted algos fixes
* :hpx-pr:`5210` - Fixing ``is_invocable`` deprecation warnings
* :hpx-pr:`5209` - Moving more files into modules (actions, components,
  init_runtime, etc.)
* :hpx-pr:`5208` - Add examples and explanation on when
  ``tag_fallback/priority`` are useful
* :hpx-pr:`5207` - Always define ``HPX_COMPUTE_HOST_CODE`` for host code
* :hpx-pr:`5206` - Add formatting exceptions for libhpx to
  create_module_skeleton.py
* :hpx-pr:`5205` - Moving all distribution policies into modules
* :hpx-pr:`5203` - Move copy algorithms to ``tag_fallback_invoke``
* :hpx-pr:`5202` - Make ``HPX_WITH_PSEUDO_DEPENDENCIES`` a cache variable
* :hpx-pr:`5201` - Replaced ``tag_invoke`` with ``tag_fallback_invoke`` for
  ``adjacent_find`` algorithm
* :hpx-pr:`5200` - Moving files to (distributed) runtime module
* :hpx-pr:`5199` - Update ICC module name on Piz Daint Jenkins configuration
* :hpx-pr:`5198` - Add doxygen documentation for thread_schedule_hint
* :hpx-pr:`5197` - Attempt to fix compilation of context implementations with
  unity build enabled
* :hpx-pr:`5196` - Re-enable component tests
* :hpx-pr:`5195` - Moving files related to colocation logic
* :hpx-pr:`5194` - Another attempt at fixing the Fedora 35 problem
* :hpx-pr:`5193` - Components module
* :hpx-pr:`5192` - Adapt ``replace(_if)`` to C++20
* :hpx-pr:`5190` - Set compatibility headers by default to on
* :hpx-pr:`5188` - Bump Boost minimum version to 1.71.0
* :hpx-pr:`5187` - Force CMake to set the ``-std=c++XX`` flag
* :hpx-pr:`5186` - Remove message to print .cu extension whenever .cu files are
  encountered
* :hpx-pr:`5185` - Remove some minor unnecessary CMake options
* :hpx-pr:`5184` - Remove some leftover ``HPX_WITH_*_SCHEDULER`` uses
* :hpx-pr:`5183` - Remove dependency on boost/iterators/iterator_categories.hpp
* :hpx-pr:`5182` - Fixing Fedora 35 for Power architectures
* :hpx-pr:`5181` - Bump version number and tag post 1.6.0 release
* :hpx-pr:`5180` - Fix htts_v2 tests linking
* :hpx-pr:`5179` - Make sure ``--hpx:local`` command line option is respected
  with networking is off but distributed runtime is on
* :hpx-pr:`5177` - Remove module cmake options
* :hpx-pr:`5176` - Starting to separate segmented algorithms: ``for_each``
* :hpx-pr:`5174` - Don't run segmented algorithms twice on CircleCI
* :hpx-pr:`5173` - Fetching APEX using cmake FetchContent
* :hpx-pr:`5172` - Add separate local-only entry point
* :hpx-pr:`5171` - Remove ``HPX_WITH_THREAD_SCHEDULERS`` CMake option
* :hpx-pr:`5170` - Add ``HPX_WITH_PRECOMPILED_HEADERS`` option
* :hpx-pr:`5166` - Moving some action tests to modules
* :hpx-pr:`5165` - Require cmake 3.17
* :hpx-pr:`5164` - Move ``thread_pool_suspension_helper`` files to small utility
  module
* :hpx-pr:`5160` - Adding checks ensuring modules are not cross-referenced from
  other module categories
* :hpx-pr:`5158` - Replace boost::asio with standalone asio
* :hpx-pr:`5155` - Allow logging when distributed runtime is off
* :hpx-pr:`5153` - Components module
* :hpx-pr:`5152` - Move more files to performance counter module
* :hpx-pr:`5150` - Adapt ``remove_copy(_if)`` to C++20
* :hpx-pr:`5144` - AGAS module
* :hpx-pr:`5125` - Adapt ``remove`` and ``remove_if`` to C++20
* :hpx-pr:`5117` - Attempt to fix segfaults assumed to be caused by
  ``future_data`` instances going out of scope.
* :hpx-pr:`5099` - Allow mixing debug and release builds
* :hpx-pr:`5092` - Replace spirit.qi with x3
* :hpx-pr:`5053` - Add P0443r14 executor and a a few P1897 algorithms
* :hpx-pr:`5044` - Add performance test in jenkins and reports
..
    Copyright (C) 2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_5_1:

===========================
|hpx| V1.5.1 (Sep 30, 2020)
===========================

General changes
===============

This is a patch release. It contains the following changes:

* Remove restriction on suspending runtime with multiple localities, users are
  now responsible for synchronizing work between localities before suspending.
* Fixes several compilation problems and warnings.
* Adds notes in the documentation explaining how to cite HPX.

Closed issues
=============

* :hpx-issue:`4971` - Parallel sort fails to compile with C++20
* :hpx-issue:`4950` - Build with `HPX_WITH_PARCELPORT_ACTION_COUNTERS` `ON` fails
* :hpx-issue:`4940` - Codespell report for "HPX" (on fossies.org)
* :hpx-issue:`4937` - Allow suspension of runtime for multiple localities

Closed pull requests
====================

* :hpx-pr:`4982` - Add page about citing HPX to documentation
* :hpx-pr:`4981` - Adding the missing include
* :hpx-pr:`4974` - Remove leftover format export hack
* :hpx-pr:`4972` - Removing use of get_temporary_buffer and return_temporary_buffer
* :hpx-pr:`4963` - Renaming files to avoid warnings from the vs build system
* :hpx-pr:`4951` - Fixing build if HPX_WITH_PARCELPORT_ACTION_COUNTERS=On
* :hpx-pr:`4946` - Allow suspension on multiple localities
* :hpx-pr:`4944` - Fix typos reported by fossies codespell report
* :hpx-pr:`4941` - Adding some explanation to README about how to cite HPX
* :hpx-pr:`4939` - Small changes
..
    Copyright (C) 2007-2020 Hartmut Kaiser
    Copyright (C)      2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_5_0:

===========================
|hpx| V1.5.0 (Sep 02, 2020)
===========================

General changes
===============

The main focus of this release is on APIs and C++20 conformance. We have added
many new C++20 features and adapted multiple algorithms to be fully C++20
conformant. As part of the modularization we have begun specifying the public
API of |hpx| in terms of headers and functionality, and aligning it more closely
to the C++ standard. All non-distributed modules are now in place, along with an
experimental option to completely disable distributed features in |hpx|. We have
also added experimental asynchronous MPI and CUDA executors. Lastly this release
introduces |cmake| targets for depending projects, performance improvements,
and many bug fixes.

* We have added the C++20 features ``hpx::jthread`` and ``hpx::stop_token``.
  ``hpx::condition_variable_any`` now exposes new functions supporting
  ``hpx::stop_token``.
* We have added ``hpx::stable_sort`` based on Francisco Tapia's
  implementation.
* We have adapted existing synchronization primitives to be fully conformant
  C++20: ``hpx::barrier``, ``hpx::latch``, ``hpx::counting_semaphore``, and
  ``hpx::binary_semaphore``.
* We have started using customization point objects (CPOs) to make the
  corresponding algorithms fully conformant to C++20 as well as to make
  algorithm extension easier for the user. ``all_of``/``any_of``/``none_of``,
  ``copy``, ``count``, ``destroy``, ``equal``, ``fill``, ``find``, ``for_each``,
  ``generate``, ``mismatch``, ``move``, ``reduce``, ``transform_reduce`` are
  using those CPOs (all in namespace ``hpx``).  We also have adapted their
  corresponding ``hpx::ranges`` versions to be conforming to C++20 in this
  release.
* We have adapted support for ``co_await`` to C++20, in addition to
  ``hpx::future`` it now also supports ``hpx::shared_future``. We have also
  added allocator support for futures returned by ``co_return``. It is no longer
  in the ``experimental`` namespace.
* We added serialization support for ``std::variant`` and ``std::tuple``.
* ``result_of`` and ``is_callable`` are now deprecated and replaced by
  ``invoke_result`` and ``is_invocable`` to conform to C++20.
* We continued with the modularization, making it easier for us to add the new
  experimental ``HPX_WITH_DISTRIBUTED_RUNTIME`` |cmake| option (see below) . An
  significant amount of headers have been deprecated. We adapted the namespaces
  and headers we could to be closer to the standard ones (:ref:`public_api`).
  Depending code should still compile, however warnings are now generated
  instructing to change the include statements accordingly.
* It is now possible to have a basic CUDA support including a helper function to
  get a future from a CUDA stream and target handling. They are available under
  the ``hpx::cuda::experimental`` namespace and they can be enabled with the
  ``-DHPX_WITH_ASYNC_CUDA=ON`` |cmake| option.
* We added a new ``hpx::mpi::experimental`` namespace for getting futures from
  an asynchronous MPI call and a new minimal MPI executor
  ``hpx::mpi::experimental::executor``. These can be enabled with the
  ``-DHPX_WITH_ASYNC_MPI=On`` |cmake| option.
* A polymorphic executor has been implemented to reduce compile times as a
  function accepting executors can potentially be instantiated only once instead
  of multiple times with different executors. It accepts the function signature
  as a template argument. It needs to be constructed from any other executor.
  Please note, that the function signatures that can be scheduled using
  ``then_execute``, ``bulk_sync_execute``, ``bulk_async_execute`` and
  ``bulk_then_execute`` are slightly different (See the comment in
  :hpx-pr:`4514` for more details).
* The underlying executor of ``block_executor`` has been updated to a newer one.
* We have added a parameter to ``auto_chunk_size`` to control the amount of
  iterations to measure.
* All executor parameter hooks can now be exposed through the executor itself.
  This will allow to deprecate the ``.with()`` functionality on execution
  policies in the future. This is also a first step towards simplifying our
  executor APIs in preparation for the upcoming C++23 executors
  (senders/receivers).
* We have moved all of the existing APIs related to resiliency into the
  namespace ``hpx::resiliency::experimental``. Please note this is a breaking
  change without backwards-compatibility option. We have converted all of those
  APIs to be based on customization point objects. Two new executors have been
  added to enable easy integration of the existing resiliency features with
  other facilities (like the parallel algorithms): ``replay_executor`` and
  ``replicate_executor``.
* We have added performance counters type information (``aggregating``,
  ``monotonically increasing``, ``average count``, ``average timer``, etc.).
* HPX threads are now re-scheduled on the same worker thread they were suspended
  on to avoid cache misses from moving from one thread to the other. This
  behavior doesn't prevent the thread from being stolen, however.
* We have added a new configuration option ``hpx.exception_verbosity`` to allow
  to control the level of verbosity of the exceptions (3 levels available).
* ``broadcast_to``, ``broadcast_from``, ``scatter_to`` and ``scatter_from`` have
  been added to the collectives, modernization of ``gather_here`` and
  ``gather_there`` with futures taken by rvalue references. See the breaking
  change on ``all_to_all`` in the next section. None of the collectives need
  supporting macros anymore (e.g. specifying the data types used for a
  collective operation using ``HPX_REGISTER_ALLGATHER`` and similar is not
  needed anymore).
* New API functions have been added: a) to get the number of cores which are idle
  (``hpx::get_idle_core_count``) and b) returning a bitmask
  representing the currently idle cores (``hpx::get_idle_core_mask``).
* We have added an experimental option to only enable the local runtime, you can
  disable the distributed runtime with ``HPX_WITH_DISTRIBUTED_RUNTIME=OFF``. You
  can also enable the local runtime by using the ``--hpx:local`` runtime option.
* We fixed task annotations for actions.
* The alias ``hpx::promise`` to ``hpx::lcos::promise`` is now deprecated. You
  can use ``hpx::lcos::promise`` directly instead. ``hpx::promise`` will refer
  to the local-only promise in the future.
* We have added a ``prepare_checkpoint`` API function that calculates the
  amount of necessary buffer space for a particular set of arguments
  checkpointed.
* We have added ``hpx::upgrade_lock`` and ``hpx::upgrade_to_unique_lock``, which
  make ``hpx::shared_mutex`` (and similar) usable in more flexible ways.
* We have changed the |cmake| targets exposed to the user, it now includes
  ``HPX::hpx``, ``HPX::wrap_main`` (``int main`` as the first |hpx| thread of
  the application, see :ref:`starting_hpx`),
  ``HPX::plugin``, ``HPX::component``.  The |cmake| variables
  ``HPX_INCLUDE_DIRS`` and ``HPX_LIBRARIES`` are deprecated and will be removed
  in a future release, you should now link directly to the ``HPX::hpx`` |cmake|
  target.
* A new example is demonstrating how to create and use a wrapping executor
  (``quickstart/executor_with_thread_hooks.cpp``)
* A new example is demonstrating how to disable thread stealing during the
  execution of parallel algorithms
  (``quickstart/disable_thread_stealing_executor.cpp``)
* We now require for our |cmake| build system configuration files to be
  formatted using cmake-format.
* We have removed more dependencies on various Boost libraries.
* We have added an experimental option enabling unity builds of HPX using the
  ``-DHPX_WITH_UNITY_BUILD=On`` |cmake| option.
* Many bug fixes.

Breaking changes
================

* |hpx| now requires a C++14 capable compiler. We have set the |hpx| C++
  standard automatically to C++14 and if it needs to be set explicitly, it
  should be specified through the ``CMAKE_CXX_STANDARD`` setting as mandated
  by |cmake|. The ``HPX_WITH_CXX*`` variables are now deprecated and will be
  removed in the future.
* Building and using HPX is now supported only when using |cmake| V3.13 or later,
  Boost V1.64 or newer, and when compiling with clang V5, gcc V7, or VS2019, or
  later. Other compilers might still work but have not been tested thoroughly.
* We have added a ``hpx::init_params`` struct to pass parameters for |hpx|
  initialization e.g. the resource partitioner callback to initialize thread
  pools (:ref:`using_resource_partitioner`).
* The ``all_to_all`` algorithm is renamed to ``all_gather``, and the new
  ``all_to_all`` algorithm is not compatible with the old one.
* We have moved all of the existing APIs related to resiliency into the
  namespace ``hpx::resiliency::experimental``.

Closed issues
=============

* :hpx-issue:`4918` - Rename distributed_executors module
* :hpx-issue:`4900` - Adding JOSS status badge to README
* :hpx-issue:`4897` - Compiler warning, deprecated header used by HPX itself
* :hpx-issue:`4886` - A future bound to an action executing on a different locality doesn't capture exception state
* :hpx-issue:`4880` - Undefined reference to main build error when HPX_WITH_DYNAMIC_HPX_MAIN=OFF
* :hpx-issue:`4877` - hpx_main might not able to start hpx runtime properly
* :hpx-issue:`4850` - Issues creating templated component
* :hpx-issue:`4829` - Spack package & HPX_WITH_GENERIC_CONTEXT_COROUTINES
* :hpx-issue:`4820` - PAPI counters don't work
* :hpx-issue:`4818` - HPX can't be used with IO pool turned off
* :hpx-issue:`4816` - Build of HPX fails when find_package(Boost) is called before FetchContent_MakeAvailable(hpx)
* :hpx-issue:`4813` - HPX MPI Future failed
* :hpx-issue:`4811` - Remove HPX::hpx_no_wrap_main target before 1.5.0 release
* :hpx-issue:`4810` - In hpx::for_each::invoke_projected the hpx::util::decay is misguided
* :hpx-issue:`4787` - `transform_inclusive_scan` gives incorrect results for non-commutative operator
* :hpx-issue:`4786` - transform_inclusive_scan tries to implicitly convert between types, instead of using the provided `conv` function
* :hpx-issue:`4779` - HPX build error with GCC 10.1
* :hpx-issue:`4766` - Move HPX.Compute functionality to experimental namespace
* :hpx-issue:`4763` - License file name
* :hpx-issue:`4758` - CMake profiling results
* :hpx-issue:`4755` - Building HPX with support for PAPI fails
* :hpx-issue:`4754` - CMake cache creation breaks when using HPX with mimalloc
* :hpx-issue:`4752` - HPX MPI Future build failed
* :hpx-issue:`4746` - Memory leak when using dataflow icw components
* :hpx-issue:`4731` - Bug in stencil example, calculation of locality IDs
* :hpx-issue:`4723` - Build fail with NETWORKING OFF
* :hpx-issue:`4720` - Add compatibility headers for modules that had their module headers implicitly generated in 1.4.1
* :hpx-issue:`4719` - Undeprecate some module headers
* :hpx-issue:`4712` - Rename HPX_MPI_WITH_FUTURES option
* :hpx-issue:`4709` - Make deprecation warnings overridable in dependent projects
* :hpx-issue:`4691` - Suggestion to fix and enhance the thread_mapper API
* :hpx-issue:`4686` - Fix tutorials examples
* :hpx-issue:`4685` - HPX distributed map fails to compile
* :hpx-issue:`4680` - Build error with HPX_WITH_DYNAMIC_HPX_MAIN=OFF
* :hpx-issue:`4679` - Build error for hpx w/ Apex on Summit
* :hpx-issue:`4675` - build error with HPX_WITH_NETWORKING=OFF
* :hpx-issue:`4674` - Error running Quickstart tests on OS X
* :hpx-issue:`4662` - MPI initialization broken when networking off
* :hpx-issue:`4652` - How to fix distributed action annotation
* :hpx-issue:`4650` - thread descriptions are broken...again
* :hpx-issue:`4648` - Thread stacksize not properly set
* :hpx-issue:`4647` - Rename generated collective headers in modules
* :hpx-issue:`4639` - Update deprecation warnings in compatibility headers to point to collective headers
* :hpx-issue:`4628` - mpi parcelport totally broken
* :hpx-issue:`4619` - Fully document hpx_wrap behaviour and targets
* :hpx-issue:`4612` - Compilation issue with HPX 1.4.1 and 1.4.0
* :hpx-issue:`4594` - Rename modules
* :hpx-issue:`4578` - Default value for HPX_WITH_THREAD_BACKTRACE_DEPTH
* :hpx-issue:`4572` - Thread manager should be given a runtime_configuration
* :hpx-issue:`4571` - Add high-level documentation to new modules
* :hpx-issue:`4569` - Annoying warning when compiling - pls suppress or fix it.
* :hpx-issue:`4555` - HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION compilation error
* :hpx-issue:`4543` - Segfaults in Release builds using `sleep_for`
* :hpx-issue:`4539` - Compilation Error when HPX_MPI_WITH_FUTURES=ON
* :hpx-issue:`4537` - Linking issue with libhpx_initd.a
* :hpx-issue:`4535` - API for checking if pool with a given name exists
* :hpx-issue:`4523` - Build of PR #4311 (git tag 9955e8e) fails
* :hpx-issue:`4519` - Documentation problem
* :hpx-issue:`4513` - HPXConfig.cmake contains ill-formed paths when library paths use backslashes
* :hpx-issue:`4507` - User-polling introduced by MPI futures module should be more generally usable
* :hpx-issue:`4506` - Make sure force_linking.hpp is not included in main module header
* :hpx-issue:`4501` - Fix compilation of PAPI tests
* :hpx-issue:`4497` - Add modules CI checks
* :hpx-issue:`4489` - Polymorphic executor
* :hpx-issue:`4476` - Use CMake targets defined by FindBoost
* :hpx-issue:`4473` - Add vcpkg installation instructions
* :hpx-issue:`4470` - Adapt hpx::future to C++20 co_await
* :hpx-issue:`4468` - Compile error on Raspberry Pi 4
* :hpx-issue:`4466` - Compile error on Windows, current stable:
* :hpx-issue:`4453` - Installing HPX on fedora with dnf is not adding cmake files
* :hpx-issue:`4448` - New std::variant serialization broken
* :hpx-issue:`4438` - Add performance counter flag is monotically increasing
* :hpx-issue:`4436` - Build problem: same code build and works with 1.4.0 but it doesn't with 1.4.1
* :hpx-issue:`4429` - Function descriptions not supported in distributed
* :hpx-issue:`4423` - --hpx:ini=hpx.lock_detection=0 has no effect
* :hpx-issue:`4422` - Add performance counter metadata
* :hpx-issue:`4419` - Weird behavior for --hpx:print-counter-interval with large numbers
* :hpx-issue:`4401` - Create module repository
* :hpx-issue:`4400` - Command line options conflict related to performance counters
* :hpx-issue:`4349` - `--hpx:use-process-mask` option throw an exception on OS X
* :hpx-issue:`4345` - Move gh-pages branch out of hpx repo
* :hpx-issue:`4323` - Const-correctness error in assignment operator of compute::vector
* :hpx-issue:`4318` - ASIO breaks with C++2a concepts
* :hpx-issue:`4317` - Application runs even if `--hpx:help` is specified
* :hpx-issue:`4063` - Document hpxcxx compiler wrapper
* :hpx-issue:`3983` - Implement the C++20 Synchronization Library
* :hpx-issue:`3696` - C++11 `constexpr` support is now required
* :hpx-issue:`3623` - Modular HPX branch and an alternative project layout
* :hpx-issue:`2836` - The worst-case time complexity of parallel::sort seems to be O(N^2).

Closed pull requests
====================

* :hpx-pr:`4936` - Minor documentation fixes part 2
* :hpx-pr:`4935` - Add copyright and license to joss paper file
* :hpx-pr:`4934` - Adding Semicolon in Documentation
* :hpx-pr:`4932` - Fixing compiler warnings
* :hpx-pr:`4931` - Small documentation formatting fixes
* :hpx-pr:`4930` - Documentation Distributed HPX applications localvv with local_vv
* :hpx-pr:`4929` - Add final version of the JOSS paper
* :hpx-pr:`4928` - Add HPX_NODISCARD to enable_user_polling structs
* :hpx-pr:`4926` - Rename distributed_executors module to executors_distributed
* :hpx-pr:`4925` - Making transform_reduce conforming to C++20
* :hpx-pr:`4923` - Don't acquire lock if not needed
* :hpx-pr:`4921` - Update the release notes for the release candidate 3
* :hpx-pr:`4920` - Disable libcds release
* :hpx-pr:`4919` - Make cuda event pool dynamic instead of fixed size
* :hpx-pr:`4917` - Move chrono functionality to hpx::chrono namespace
* :hpx-pr:`4916` - HPX_HAVE_DEPRECATION_WARNINGS needs to be set even when disabled
* :hpx-pr:`4915` - Moving more action related files to actions modules
* :hpx-pr:`4914` - Add alias targets with namespaces used for exporting
* :hpx-pr:`4912` - Aggregate initialize CPOs
* :hpx-pr:`4910` - Explicitly specify hwloc root on Jenkins CSCS builds
* :hpx-pr:`4908` - Fix algorithms documentation
* :hpx-pr:`4907` - Remove HPX::hpx_no_wrap_main target
* :hpx-pr:`4906` - Fixing unused variable warning
* :hpx-pr:`4905` - Adding specializations for simple for_loops
* :hpx-pr:`4904` - Update boost to 1.74.0 for the newest jenkins configs
* :hpx-pr:`4903` - Hide GITHUB_TOKEN environment variables from environment variable output
* :hpx-pr:`4902` - Cancel previous pull requests builds before starting a new one with Jenkins
* :hpx-pr:`4901` - Update public API list with updated algorithms
* :hpx-pr:`4899` - Suggested changes for HPX V1.5 release notes
* :hpx-pr:`4898` - Minor tweak to hpx::equal implementation
* :hpx-pr:`4896` - Making generate() and generate_n conforming to C++20
* :hpx-pr:`4895` - Update apex tag
* :hpx-pr:`4894` - Fix exception handling for tasks
* :hpx-pr:`4893` - Remove last use of std::result_of, removed in C++20
* :hpx-pr:`4892` - Adding replay_executor and replicate_executor
* :hpx-pr:`4889` - Restore old behaviour of not requiring linking to hpx_wrap when HPX_WITH_DYNAMIC_HPX_MAIN=OFF
* :hpx-pr:`4887` - Making sure remotely thrown (non-hpx) exceptions are properly marshaled back to invocation site
* :hpx-pr:`4885` - Adapting hpx::find and friends to C++20
* :hpx-pr:`4884` - Adapting mismatch to C++20
* :hpx-pr:`4883` - Adapting hpx::equal to be conforming to C++20
* :hpx-pr:`4882` - Fixing exception handling for hpx::copy and adding missing tests
* :hpx-pr:`4881` - Adds different runtime exception when registering thread with the HPX runtime
* :hpx-pr:`4876` - Adding example demonstrating how to disable thread stealing during the execution of parallel algorithms
* :hpx-pr:`4874` - Adding non-policy tests to all_of, any_of, and none_of
* :hpx-pr:`4873` - Set CUDA compute capability on rostam Jenkins builds
* :hpx-pr:`4872` - Force partitioned vector scan tests to run serially
* :hpx-pr:`4870` - Making move conforming with C++20
* :hpx-pr:`4869` - Making destroy and destroy_n conforming to C++20
* :hpx-pr:`4868` - Fix miscellaneous header problems
* :hpx-pr:`4867` - Add CPOs for for_each
* :hpx-pr:`4865` - Adapting count and count_if to be conforming to C++20
* :hpx-pr:`4864` - Release notes 1.5.0
* :hpx-pr:`4863` - adding libcds-hpx tag to prepare for hpx1.5 release
* :hpx-pr:`4862` - Adding version specific deprecation options
* :hpx-pr:`4861` - Limiting executor improvements
* :hpx-pr:`4860` - Making fill and fill_n compatible with C++20
* :hpx-pr:`4859` - Adapting all_of, any_of, and none_of to C++20
* :hpx-pr:`4857` - Improve libCDS integration
* :hpx-pr:`4856` - Correct typos in the documentation of the hpx performance counters
* :hpx-pr:`4854` - Removing obsolete code
* :hpx-pr:`4853` - Adding test that derives component from two other components
* :hpx-pr:`4852` - Fix mpi_ring test in distributed mode by ensuring all ranks run hpx_main
* :hpx-pr:`4851` - Converting resiliency APIs to tag_invoke based CPOs
* :hpx-pr:`4849` - Enable use of future_overhead test when DISTRIBUTED_RUNTIME is OFF
* :hpx-pr:`4847` - Fixing 'error prone' constructs as reported by Codacy
* :hpx-pr:`4846` - Disable Boost.Asio concepts support
* :hpx-pr:`4845` - Fix PAPI counters
* :hpx-pr:`4843` - Remove dependency on various Boost headers
* :hpx-pr:`4841` - Rearrange public API headers
* :hpx-pr:`4840` - Fixing TSS problems during thread termination
* :hpx-pr:`4839` - Fix async_cuda build problems when distributed runtime is disabled
* :hpx-pr:`4837` - Restore compatibility for old (now deprecated) copy algorithms
* :hpx-pr:`4836` - Adding CPOs for hpx::reduce
* :hpx-pr:`4835` - Remove `using util::result_of` from namespace hpx
* :hpx-pr:`4834` - Fixing the calculation of the number of idle cores and the corresponding idle masks
* :hpx-pr:`4833` - Allow thread function destructors to yield
* :hpx-pr:`4832` - Fixing assertion in split_gids and memory leaks in 1d_stencil_7
* :hpx-pr:`4831` - Making sure MPI_CXX_COMPILE_FLAGS is interpreted as a sequence  of options
* :hpx-pr:`4830` - Update documentation on using HPX::wrap_main
* :hpx-pr:`4827` - Update clang-newest configuration to use clang 10
* :hpx-pr:`4826` - Add Jenkins configuration for rostam
* :hpx-pr:`4825` - Move all CUDA functionality to hpx::cuda::experimental namespace
* :hpx-pr:`4824` - Add support for building master/release branches to Jenkins configuration
* :hpx-pr:`4821` - Implement customization point for hpx::copy and hpx::ranges::copy
* :hpx-pr:`4819` - Allow finding Boost components before finding HPX
* :hpx-pr:`4817` - Adding range version of stable sort
* :hpx-pr:`4815` - Fix a wrong #ifdef for IO/TIMER pools causing build errors
* :hpx-pr:`4814` - Replace hpx::function_nonser with std::function in error module
* :hpx-pr:`4809` - Foreach adapt
* :hpx-pr:`4808` - Make internal algorithms functions const
* :hpx-pr:`4807` - Add Jenkins configuration for running on Piz Daint
* :hpx-pr:`4806` - Update documentation links to new domain name
* :hpx-pr:`4805` - Applying changes that resolve time complexity issues in sort
* :hpx-pr:`4803` - Adding implementation of stable_sort
* :hpx-pr:`4802` - Fix datapar header paths
* :hpx-pr:`4801` - Replace boost::shared_array<T> with std::shared_ptr<T[]> if supported
* :hpx-pr:`4799` - Fixing #include paths in compatibility headers
* :hpx-pr:`4798` - Include the main module header (fixes partially #4488)
* :hpx-pr:`4797` - Change cmake targets
* :hpx-pr:`4794` - Removing 128bit integer emulation
* :hpx-pr:`4793` - Make sure global variable is handled properly
* :hpx-pr:`4792` - Replace enable_if with HPX_CONCEPT_REQUIRES_ and add is_sentinel_for constraint
* :hpx-pr:`4790` - Move deprecation warnings from base template to template specializations for result_of etc. structs
* :hpx-pr:`4789` - Fix hangs during assertion handling and distributed runtime construction
* :hpx-pr:`4788` - Fixing inclusive transform scan algorithm to properly handle initial value
* :hpx-pr:`4785` - Fixing barrier test
* :hpx-pr:`4784` - Fixing deleter argument bindings in serialize_buffer
* :hpx-pr:`4783` - Add coveralls badge
* :hpx-pr:`4782` - Make header tests parallel again
* :hpx-pr:`4780` - Remove outdated comment about hpx::stop in documentation
* :hpx-pr:`4776` - debug print improvements
* :hpx-pr:`4775` - Checkpoint cleanup
* :hpx-pr:`4771` - Fix compilation with HPX_WITH_NETWORKING=OFF
* :hpx-pr:`4767` - Remove all force linking leftovers
* :hpx-pr:`4765` - Fix 1d stencil index calculation
* :hpx-pr:`4764` - Force some tests to run serially
* :hpx-pr:`4762` - Update pointees in compatibility headers
* :hpx-pr:`4761` - Fix running and building of execution module tests on CircleCI
* :hpx-pr:`4760` - Storing hpx_options in global property to speed up summary report
* :hpx-pr:`4759` - Reduce memory requirements for our main shared state
* :hpx-pr:`4757` - Fix mimalloc linking on Windows
* :hpx-pr:`4756` - Fix compilation issues
* :hpx-pr:`4753` - Re-adding API functions that were lost during merges
* :hpx-pr:`4751` - Revert "Create coverage reports and upload them to codecov.io"
* :hpx-pr:`4750` - Fixing possible race condition during termination detection
* :hpx-pr:`4749` - Deprecate result_of and friends
* :hpx-pr:`4748` - Create coverage reports and upload them to codecov.io
* :hpx-pr:`4747` - Changing #include for MPI parcelport
* :hpx-pr:`4745` - Add `is_sentinel_for` trait implementation and test
* :hpx-pr:`4743` - Fix init_globally example after runtime mode changes
* :hpx-pr:`4742` - Update SUPPORT.md
* :hpx-pr:`4741` - Fixing a warning generated for unity builds with msvc
* :hpx-pr:`4740` - Rename local_lcos and basic_execution modules
* :hpx-pr:`4739` - Undeprecate a couple of hpx/modulename.hpp headers
* :hpx-pr:`4738` - Conditionally test schedulers in thread_stacksize_current test
* :hpx-pr:`4734` - Fixing a bunch of codacy warnings
* :hpx-pr:`4733` - Add experimental unity build option to CMake configuration
* :hpx-pr:`4730` - Fixing compilation problems with unordered map
* :hpx-pr:`4729` - Fix APEX build
* :hpx-pr:`4727` - Fix missing runtime includes for distributed runtime
* :hpx-pr:`4726` - Add more API headers
* :hpx-pr:`4725` - Add more compatibility headers for deprecated module headers
* :hpx-pr:`4724` - Fix 4723
* :hpx-pr:`4721` - Attempt to fixing migration tests
* :hpx-pr:`4717` - Make the compatilibility headers macro conditional
* :hpx-pr:`4716` - Add hpx/runtime.hpp and hpx/distributed/runtime.hpp API headers
* :hpx-pr:`4714` - Add hpx/future.hpp header
* :hpx-pr:`4713` - Remove hpx/runtime/threads_fwd.hpp and hpx/util_fwd.hpp
* :hpx-pr:`4711` - Make module deprecation warnings overridable
* :hpx-pr:`4710` - Add compatibility headers and other fixes after module header renaming
* :hpx-pr:`4708` - Add termination handler for parallel algorithms
* :hpx-pr:`4707` - Use hpx::function_nonser instead of std::function internally
* :hpx-pr:`4706` - Move header file to module
* :hpx-pr:`4705` - Fix incorrect behaviour of cmake-format check
* :hpx-pr:`4704` - Fix resource tests
* :hpx-pr:`4701` - Fix missing includes for future::then specializations
* :hpx-pr:`4700` - Removing obsolete memory component
* :hpx-pr:`4699` - Add short descriptions to modules missing documentation
* :hpx-pr:`4696` - Rename generated modules headers
* :hpx-pr:`4693` - Overhauling thread_mapper for public consumption
* :hpx-pr:`4688` - Fix thread stack size handling
* :hpx-pr:`4687` - Adding all_gather and fixing all_to_all
* :hpx-pr:`4684` - Miscellaneous compilation fixes
* :hpx-pr:`4683` - Fix HPX_WITH_DYNAMIC_HPX_MAIN=OFF
* :hpx-pr:`4682` - Fix compilation of pack_traversal_rebind_container.hpp
* :hpx-pr:`4681` - Add missing hpx/execution.hpp includes for future::then
* :hpx-pr:`4678` - Typeless communicator
* :hpx-pr:`4677` - Forcing registry option to be accepted without checks.
* :hpx-pr:`4676` - Adding scatter_to/scatter_from collective operations
* :hpx-pr:`4673` - Fix PAPI counters compilation
* :hpx-pr:`4671` - Deprecate hpx::promise alias to hpx::lcos::promise
* :hpx-pr:`4670` - Explicitly instantiate get_exception
* :hpx-pr:`4667` - Add `stopValue` in `Sentinel` struct instead of `Iterator`
* :hpx-pr:`4666` - Add release build on Windows to GitHub actions
* :hpx-pr:`4664` - Creating itt_notify module.
* :hpx-pr:`4663` - Mpi fixes
* :hpx-pr:`4659` - Making sure declarations match definitions in register_locks implementation
* :hpx-pr:`4655` - Fixing task annotations for actions
* :hpx-pr:`4653` - Making sure APEX is linked into every application, if needed
* :hpx-pr:`4651` - Update get_function_annotation.hpp
* :hpx-pr:`4646` - Runtime type
* :hpx-pr:`4645` - Add a few more API headers
* :hpx-pr:`4644` - Fixing support for mpirun (and similar)
* :hpx-pr:`4643` - Fixing the fix for get_idle_core_count() API
* :hpx-pr:`4638` - Remove HPX_API_EXPORT missed in previous cleanup
* :hpx-pr:`4636` - Adding C++20 barrier
* :hpx-pr:`4635` - Adding C++20 latch API
* :hpx-pr:`4634` - Adding C++20 counting semaphore API
* :hpx-pr:`4633` - Unify execution parameters customization points
* :hpx-pr:`4632` - Adding missing bulk_sync_execute wrapper to example executor
* :hpx-pr:`4631` - Updates to documentation; grammar edits.
* :hpx-pr:`4630` - Updates to documentation; moved hyperlink
* :hpx-pr:`4624` - Export set_self_ptr in thread_data.hpp instead of with forward declarations where used
* :hpx-pr:`4623` - Clean up export macros
* :hpx-pr:`4621` - Trigger an error for older boost versions on power architectures
* :hpx-pr:`4617` - Ignore user-set compatibility header options if the module does not have compatibility headers
* :hpx-pr:`4616` - Fix cmake-format warning
* :hpx-pr:`4615` - Add handler for serializing custom exceptions
* :hpx-pr:`4614` - Fix error message when HPX_IGNORE_CMAKE_BUILD_TYPE_COMPATIBILITY=OFF
* :hpx-pr:`4613` - Make partitioner constructor private
* :hpx-pr:`4611` - Making auto_chunk_size execute the given function using the given executor
* :hpx-pr:`4610` - Making sure the thread-local lock registration data is moving to the core the suspended HPX thread is resumed on
* :hpx-pr:`4609` - Adding an API function that exposes the number of idle cores
* :hpx-pr:`4608` - Fixing moodycamel namespace
* :hpx-pr:`4607` - Moving winsocket initialization to core library
* :hpx-pr:`4606` - Local runtime module etc.
* :hpx-pr:`4604` - Add config_registry module
* :hpx-pr:`4603` - Deal with distributed modules in their respective CMakeLists.txt
* :hpx-pr:`4602` - Small module fixes
* :hpx-pr:`4598` - Making sure current_executor and service_executor functions are linked into the core library
* :hpx-pr:`4597` - Adding broadcast_to/broadcast_from to collectives module
* :hpx-pr:`4596` - Fix performance regression in block_executor
* :hpx-pr:`4595` - Making sure main.cpp is built as a library if HPX_WITH_DYNAMIC_MAIN=OFF
* :hpx-pr:`4592` - Futures module
* :hpx-pr:`4591` - Adapting co_await support for C++20
* :hpx-pr:`4590` - Adding missing exception test for for_loop()
* :hpx-pr:`4587` - Move traits headers to hpx/modulename/traits directory
* :hpx-pr:`4586` - Remove Travis CI config
* :hpx-pr:`4585` - Update macOS test blacklist
* :hpx-pr:`4584` - Attempting to fix missing symbols in stack trace
* :hpx-pr:`4583` - Fixing bad static_cast
* :hpx-pr:`4582` - Changing download url for Windows prerequisites to circumvent bandwidth limitations
* :hpx-pr:`4581` - Adding missing using placeholder::_X
* :hpx-pr:`4579` - Move get_stack_size_name and related functions
* :hpx-pr:`4575` - Excluding unconditional definition of class backtrace from global header
* :hpx-pr:`4574` - Changing return type of hardware_concurrency() to unsigned int
* :hpx-pr:`4570` - Move tests to modules
* :hpx-pr:`4564` - Reshuffle internal targets and add HPX::hpx_no_wrap_main target
* :hpx-pr:`4563` - fix CMake option typo
* :hpx-pr:`4562` - Unregister lock earlier to avoid holding it while suspending
* :hpx-pr:`4561` - Adding test macros supporting custom output stream
* :hpx-pr:`4560` - Making sure hash_any::operator()() is linked into core library
* :hpx-pr:`4559` - Fixing compilation if HPX_WITH_THREAD_BACKTRACE_ON_SUSPENSION=On
* :hpx-pr:`4557` - Improve spinlock implementation to perform better in high-contention situations
* :hpx-pr:`4553` - Fix a runtime_ptr problem at shutdown when apex is enabled
* :hpx-pr:`4552` - Add configuration option for making exceptions less noisy
* :hpx-pr:`4551` - Clean up thread creation parameters
* :hpx-pr:`4549` - Test FetchContent build on GitHub actions
* :hpx-pr:`4548` - Fix stack size
* :hpx-pr:`4545` - Fix header tests
* :hpx-pr:`4544` - Fix a typo in sanitizer build
* :hpx-pr:`4541` - Add API to check if a thread pool exists
* :hpx-pr:`4540` - Making sure MPI support is enabled if MPI futures are used but networking is disabled
* :hpx-pr:`4538` - Move channel documentation examples to examples directory
* :hpx-pr:`4536` - Add generic allocator for execution policies
* :hpx-pr:`4534` - Enable compatibility headers for thread_executors module
* :hpx-pr:`4532` - Fixing broken url in README.rst
* :hpx-pr:`4531` - Update scripts
* :hpx-pr:`4530` - Make sure module API docs show up in correct order
* :hpx-pr:`4529` - Adding missing template code to module creation script
* :hpx-pr:`4528` - Make sure version module uses HPX's binary dir, not the parent's
* :hpx-pr:`4527` - Creating actions_base and actions module
* :hpx-pr:`4526` - Shared state for cv
* :hpx-pr:`4525` - Changing sub-name sequencing for experimental namespace
* :hpx-pr:`4524` - Add API guarantee notes to API reference documentation
* :hpx-pr:`4522` - Enable and fix deprecation warnings in execution module
* :hpx-pr:`4521` - Moves more miscellaneous files to modules
* :hpx-pr:`4520` - Skip execution customization points when executor is known
* :hpx-pr:`4518` - Module distributed lcos
* :hpx-pr:`4516` - Fix various builds
* :hpx-pr:`4515` - Replace backslashes by slashes in windows paths
* :hpx-pr:`4514` - Adding polymorphic_executor
* :hpx-pr:`4512` - Adding C++20 jthread and stop_token
* :hpx-pr:`4510` - Attempt to fix APEX linking in external packages again
* :hpx-pr:`4508` - Only test pull requests (not all branches) with GitHub actions
* :hpx-pr:`4505` - Fix duplicate linking in tests (ODR violations)
* :hpx-pr:`4504` - Fix C++ standard handling
* :hpx-pr:`4503` - Add CMakelists file check
* :hpx-pr:`4500` - Fix .clang-format version requirement comment
* :hpx-pr:`4499` - Attempting to fix hpx_init linking on macOS
* :hpx-pr:`4498` - Fix compatibility of `pool_executor`
* :hpx-pr:`4496` - Removing superfluous SPDX tags
* :hpx-pr:`4494` - Module executors
* :hpx-pr:`4493` - Pack traversal module
* :hpx-pr:`4492` - Update copyright year in documentation
* :hpx-pr:`4491` - Add missing current_executor header
* :hpx-pr:`4490` - Update GitHub actions configs
* :hpx-pr:`4487` - Properly dispatch exceptions thrown from hpx_main to be rethrown from hpx::init/hpx::stop
* :hpx-pr:`4486` - Fixing an initialization order problem
* :hpx-pr:`4485` - Move miscellaneous files to their rightful modules
* :hpx-pr:`4483` - Clean up imported CMake target naming
* :hpx-pr:`4481` - Add vcpkg installation instructions
* :hpx-pr:`4479` - Add hints to allow to specify MIMALLOC_ROOT
* :hpx-pr:`4478` - Async modules
* :hpx-pr:`4475` - Fix rp init changes
* :hpx-pr:`4474` - Use #pragma once in headers
* :hpx-pr:`4472` - Add more descriptive error message when using x86 coroutines on non-x86 platforms
* :hpx-pr:`4467` - Add mimalloc find cmake script
* :hpx-pr:`4465` - Add thread_executors module
* :hpx-pr:`4464` - Include module
* :hpx-pr:`4462` - Merge hpx_init and hpx_wrap into one static library
* :hpx-pr:`4461` - Making thread_data test more realistic
* :hpx-pr:`4460` - Suppress MPI warnings in version.cpp
* :hpx-pr:`4459` - Make sure pkgconfig applications link with hpx_init
* :hpx-pr:`4458` - Added example demonstrating how to create and use a wrapping executor
* :hpx-pr:`4457` - Fixing execution of thread exit functions
* :hpx-pr:`4456` - Move backtrace files to debugging module
* :hpx-pr:`4455` - Move deadlock_detection and maintain_queue_wait_times source files into schedulers module
* :hpx-pr:`4450` - Fixing compilation with std::filesystem enabled
* :hpx-pr:`4449` - Fixing build system to actually build variant test
* :hpx-pr:`4447` - This fixes an obsolete #include
* :hpx-pr:`4446` - Resume tasks where they were suspended
* :hpx-pr:`4444` - Minor CUDA fixes
* :hpx-pr:`4443` - Add missing tests to CircleCI config
* :hpx-pr:`4442` - Adding a tag to all auto-generated files allowing for tools to visually distinguish those
* :hpx-pr:`4441` - Adding performance counter type information
* :hpx-pr:`4440` - Fixing MSVC build
* :hpx-pr:`4439` - Link HPX::plugin and component privately in hpx_setup_target
* :hpx-pr:`4437` - Adding a test that verifies the problem can be solved using a trait specialization
* :hpx-pr:`4434` - Clean up Boost dependencies and copy string algorithms to new module
* :hpx-pr:`4433` - Fixing compilation issues (!) if MPI parcelport is enabled
* :hpx-pr:`4431` - Ignore warnings about name mangling changing
* :hpx-pr:`4430` - Add performance_counters module
* :hpx-pr:`4428` - Don't add compatibility headers to module API reference
* :hpx-pr:`4426` - Add currently failing tests on GitHub actions to blacklist
* :hpx-pr:`4425` - Clean up and correct minimum required versions
* :hpx-pr:`4424` - Making sure hpx.lock_detection=0 works as advertized
* :hpx-pr:`4421` - Making sure interval time stops underlying timer thread on termination
* :hpx-pr:`4417` - Adding serialization support for std::variant (if available) and std::tuple
* :hpx-pr:`4415` - Partially reverting changes applied by PR 4373
* :hpx-pr:`4414` - Added documentation for the compiler-wrapper script hpxcxx.in in creating_hpx_projects.rst
* :hpx-pr:`4413` - Merging from V1.4.1 release
* :hpx-pr:`4412` - Making sure to issue a warning if a file specified using --hpx:options-file is not found
* :hpx-pr:`4411` - Make test specific to HPX_WITH_SHARED_PRIORITY_SCHEDULER
* :hpx-pr:`4407` - Adding minimal MPI executor
* :hpx-pr:`4405` - Fix cross pool injection test, use default scheduler as falback
* :hpx-pr:`4404` - Fix a race condition and clean-up usage of scheduler mode
* :hpx-pr:`4399` - Add more threading modules
* :hpx-pr:`4398` - Add CODEOWNERS file
* :hpx-pr:`4395` - Adding a parameter to auto_chunk_size allowing to control the amount of iterations to measure
* :hpx-pr:`4393` - Use appropriate cache-line size defaults for different platforms
* :hpx-pr:`4391` - Fixing use of allocator for C++20
* :hpx-pr:`4390` - Making --hpx:help behavior consistent
* :hpx-pr:`4388` - Change the resource partitioner initialization
* :hpx-pr:`4387` - Fix roll_release.sh
* :hpx-pr:`4386` - Add warning messages for using thread binding options on macOS
* :hpx-pr:`4385` - Cuda futures
* :hpx-pr:`4384` - Make enabling dynamic hpx_main on non-Linux systems a configuration error
* :hpx-pr:`4383` - Use configure_file for HPXCacheVariables.cmake
* :hpx-pr:`4382` - Update spellchecking whitelist and fix more typos
* :hpx-pr:`4380` - Add a helper function to get a future from a cuda stream
* :hpx-pr:`4379` - Add Windows and macOS CI with GitHub actions
* :hpx-pr:`4378` - Change C++ standard handling
* :hpx-pr:`4377` - Remove Python scripts
* :hpx-pr:`4374` - Adding overload for `hpx::init`/`hpx::start` for use with resource partitioner
* :hpx-pr:`4373` - Adding test that verifies for 4369 to be fixed
* :hpx-pr:`4372` - Another attempt at fixing the integral mismatch and conversion warnings
* :hpx-pr:`4370` - Doc updates quick start
* :hpx-pr:`4368` - Add a whitelist of words for weird spelling suggestions
* :hpx-pr:`4366` - Suppress or fix clang-tidy-9 warnings
* :hpx-pr:`4365` - Removing more Boost dependencies
* :hpx-pr:`4363` - Update clang-format config file for version 9
* :hpx-pr:`4362` - Fix indices typo
* :hpx-pr:`4361` - Boost cleanup
* :hpx-pr:`4360` - Move plugins
* :hpx-pr:`4358` - Doc updates; generating documentation. Will likely need heavy editing.
* :hpx-pr:`4356` - Remove some minor unused and unnecessary Boost includes
* :hpx-pr:`4355` - Fix spellcheck step in CircleCI config
* :hpx-pr:`4354` - Lightweight utility to hold a pack as members
* :hpx-pr:`4352` - Minor fixes to the C++ standard detection for MSVC
* :hpx-pr:`4351` - Move generated documentation to hpx-docs repo
* :hpx-pr:`4347` - Add cmake policy - CMP0074
* :hpx-pr:`4346` - Remove file committed by mistake
* :hpx-pr:`4342` - Remove HCC and SYCL options from CMakeLists.txt
* :hpx-pr:`4341` - Fix launch process test with APEX enabled
* :hpx-pr:`4340` - Testing Cirrus CI
* :hpx-pr:`4339` - Post 1.4.0 updates
* :hpx-pr:`4338` - Spelling corrections and CircleCI spell check
* :hpx-pr:`4333` - Flatten bound callables
* :hpx-pr:`4332` - This is a collection of mostly minor (cleanup) fixes
* :hpx-pr:`4331` - This adds the missing tests for async_colocated and async_continue_colocated
* :hpx-pr:`4330` - Remove HPX.Compute host default_executor
* :hpx-pr:`4328` - Generate global header for basic_execution module
* :hpx-pr:`4327` - Use INTERNAL_FLAGS option for all examples and components
* :hpx-pr:`4326` - Usage of temporary allocator in assignment operator of compute::vector
* :hpx-pr:`4325` - Use hpx::threads::get_cache_line_size in prefetching.hpp
* :hpx-pr:`4324` - Enable compatibility headers option for execution module
* :hpx-pr:`4316` - Add clang format indentppdirectives
* :hpx-pr:`4313` - Introduce index_pack alias to pack of size_t
* :hpx-pr:`4312` - Fixing compatibility header for pack.hpp
* :hpx-pr:`4311` - Dataflow annotations for APEX
* :hpx-pr:`4309` - Update launching_and_configuring_hpx_applications.rst
* :hpx-pr:`4306` - Fix schedule hint not being taken from executor
* :hpx-pr:`4305` - Implementing `hpx::functional::tag_invoke`
* :hpx-pr:`4304` - Improve pack support utilities
* :hpx-pr:`4303` -  Remove errors module dependency on datastructures
* :hpx-pr:`4301` - Clean up thread executors
* :hpx-pr:`4294` - Logging revamp
* :hpx-pr:`4292` - Remove SPDX tag from Boost License file to allow for github to recognize it
* :hpx-pr:`4291` - Add format support for std::tm
* :hpx-pr:`4290` - Simplify compatible tuples check
* :hpx-pr:`4288` - A lightweight take on boost::lexical_cast
* :hpx-pr:`4287` - Forking boost::lexical_cast as a new module
* :hpx-pr:`4277` - MPI_futures
* :hpx-pr:`4270` - Refactor future implementation
* :hpx-pr:`4265` - Threading module
* :hpx-pr:`4259` - Module naming base
* :hpx-pr:`4251` - Local workrequesting scheduler
* :hpx-pr:`4250` - Inline execution of scoped tasks, if possible
* :hpx-pr:`4247` - Add execution in module headers
* :hpx-pr:`4246` - Expose CMake targets officially
* :hpx-pr:`4239` - Doc updates miscellaneous (partially completed during Google Season of Docs)
* :hpx-pr:`4233` - Remove project() from modules + fix CMAKE_SOURCE_DIR issue
* :hpx-pr:`4231` - Module local lcos
* :hpx-pr:`4207` - Command line handling module
* :hpx-pr:`4206` - Runtime configuration module
* :hpx-pr:`4141` - Doc updates examples local to remote (partially completed during Google Season of Docs)
* :hpx-pr:`4091` - Split runtime into local and distributed parts
* :hpx-pr:`4017` - Require C++14
..
    Copyright (C) 2007-2018 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _hpx_1_0_0:

===========================
|hpx| V1.0.0 (Apr 24, 2017)
===========================

General changes
===============

Here are some of the main highlights and changes for this release (in no
particular order):

* Added the facility ``hpx::split_future`` which allows one to convert a
  ``future<tuple<Ts...>>`` into a ``tuple<future<Ts>...>``. This functionality
  is not available when compiling |hpx| with VS2012.
* Added a new type of performance counter which allows one to return a list of
  values for each invocation. We also added a first counter of this type which
  collects a histogram of the times between parcels being created.
* Added new LCOs: ``hpx::lcos::channel`` and ``hpx::lcos::local::channel`` which
  are very similar to the well known channel constructs used in the Go language.
* Added new performance counters reporting the amount of data handled by the
  networking layer on a action-by-action basis (please see :hpx-pr:`2289` for
  more details).
* Added a new facility ``hpx::lcos::barrier``, replacing the equally named older
  one. The new facility has a slightly changed API and is much more efficient.
  Most notable, the new facility exposes a (global) function
  ``hpx::lcos::barrier::synchronize()`` which represents a global barrier across
  all localities.
* We have started to add support for vectorization to our parallel algorithm
  implementations. This support depends on using an external library, currently
  either |vc| or |boost_simd|_. Please see :hpx-issue:`2333` for a list of
  currently supported algorithms. This is an experimental feature and its
  implementation and/or API might change in the future. Please see this
  `blog-post
  <http://stellar-group.org/2016/09/vectorized-cpp-parallel-algorithms-with-hpx/>`_
  for more information.
* The parameter sequence for the ``hpx::parallel::transform_reduce`` overload
  taking one iterator range has changed to match the changes this algorithm has
  undergone while being moved to C++17. The old overload can be still enabled at
  configure time by specifying ``-DHPX_WITH_TRANSFORM_REDUCE_COMPATIBILITY=On``
  to |cmake|.
* The algorithm ``hpx::parallel::inner_product`` has been renamed to
  ``hpx::parallel::transform_reduce`` to match the changes this algorithm has
  undergone while being moved to C++17. The old inner_product names can be still
  enabled at configure time by specifying
  ``-DHPX_WITH_TRANSFORM_REDUCE_COMPATIBILITY=On`` to |cmake|.
* Added versions of ``hpx::get_ptr`` taking client side representations for
  component instances as their parameter (instead of a global id).
* Added the helper utility
  ``hpx::performance_counters::performance_counter_set`` helping to encapsulate
  a set of performance counters to be managed concurrently.
* All execution policies and related classes have been renamed to be consistent
  with the naming changes applied for C++17. All policies now live in the
  namespace ``hpx::parallel::execution``. The ols names can be still enabled at
  configure time by specifying ``-DHPX_WITH_EXECUTION_POLICY_COMPATIBILITY=On``
  to |cmake|.
* The thread scheduling subsystem has undergone a major refactoring which
  results in significant performance improvements. We have also imroved the
  performance of creating ``hpx::future`` and of various facilities handling
  those.
* We have consolidated all of the code in HPX.Compute related to the integration
  of CUDA. ``hpx::partitioned_vector`` has been enabled to be usable with
  ``hpx::compute::vector`` which allows one to place the partitions on one or
  more GPU devices.
* Added new performance counters exposing various internals of the thread
  scheduling subsystem, such as the current idle- and busy-loop counters and
  instantaneous scheduler utilization.
* Extended and improved the use of the ITTNotify hooks allowing to collect
  performance counter data and function annotation information from within the
  Intel Amplifier tool.

Breaking changes
================

* We have dropped support for the gcc compiler versions V4.6 and 4.7. The
  minimal gcc version we now test on is gcc V4.8.
* We have removed (default) support for ``boost::chrono`` in interfaces, uses of
  it have been replaced with ``std::chrono``. This facility can be still enabled
  at configure time by specifying ``-DHPX_WITH_BOOST_CHRONO_COMPATIBILITY=On``
  to |cmake|.
* The parameter sequence for the ``hpx::parallel::transform_reduce`` overload
  taking one iterator range has changed to match the changes this algorithm has
  undergone while being moved to C++17.
* The algorithm ``hpx::parallel::inner_product`` has been renamed to
  ``hpx::parallel::transform_reduce`` to match the changes this algorithm has
  undergone while being moved to C++17.
* the build options ``HPX_WITH_COLOCATED_BACKWARDS_COMPATIBILITY`` and
  ``HPX_WITH_COMPONENT_GET_GID_COMPATIBILITY`` are now disabled by default. Please
  change your code still depending on the deprecated interfaces.

Bug fixes (closed tickets)
==========================

Here is a list of the important tickets we closed for this release.

* :hpx-pr:`2596` - Adding apex data
* :hpx-pr:`2595` - Remove obsolete file
* :hpx-issue:`2594` - FindOpenCL.cmake mismatch with the official cmake module
* :hpx-pr:`2592` - First attempt to introduce spmd_block in hpx
* :hpx-issue:`2591` - Feature request: continuation (then) which does not
  require the callable object to take a future<R> as parameter
* :hpx-pr:`2588` - Daint fixes
* :hpx-pr:`2587` - Fixing transfer_(continuation)_action::schedule
* :hpx-pr:`2585` - Work around MSVC having an ICE when compiling with -Ob2
* :hpx-pr:`2583` - changing 7zip command to 7za in roll_release.sh
* :hpx-pr:`2582` - First attempt to introduce spmd_block in hpx
* :hpx-pr:`2581` - Enable annotated function for parallel algorithms
* :hpx-pr:`2580` - First attempt to introduce spmd_block in hpx
* :hpx-pr:`2579` - Make thread NICE level setting an option
* :hpx-pr:`2578` - Implementing enqueue instead of busy wait when no sender is
  available
* :hpx-pr:`2577` - Retrieve -std=c++11 consistent nvcc flag
* :hpx-pr:`2576` - Add missing dependencies of cuda based tests
* :hpx-pr:`2575` - Remove warnings due to some captured variables
* :hpx-pr:`2573` - Attempt to resolve resolve_locality
* :hpx-pr:`2572` - Adding APEX hooks to background thread
* :hpx-pr:`2571` - Pick up hpx.ignore_batch_env from config map
* :hpx-pr:`2570` - Add commandline options --hpx:print-counters-locally
* :hpx-pr:`2569` - Fix computeapi unit tests
* :hpx-pr:`2567` - This adds another barrier::synchronize before registering
  performance counters
* :hpx-pr:`2564` - Cray static toolchain support
* :hpx-pr:`2563` - Fixed unhandled exception during startup
* :hpx-pr:`2562` - Remove partitioned_vector.cu from build tree when nvcc is
  used
* :hpx-issue:`2561` - octo-tiger crash with commit
  6e921495ff6c26f125d62629cbaad0525f14f7ab
* :hpx-pr:`2560` - Prevent -Wundef warnings on Vc version checks
* :hpx-pr:`2559` - Allowing CUDA callback to set the future directly from an OS
  thread
* :hpx-pr:`2558` - Remove warnings due to float precisions
* :hpx-pr:`2557` - Removing bogus handling of compile flags for CUDA
* :hpx-pr:`2556` - Fixing scan partitioner
* :hpx-pr:`2554` - Add more diagnostics to error thrown from
  find_appropriate_destination
* :hpx-issue:`2555` - No valid parcelport configured
* :hpx-pr:`2553` - Add cmake cuda_arch option
* :hpx-pr:`2552` - Remove incomplete datapar bindings to libflatarray
* :hpx-pr:`2551` - Rename hwloc_topology to hwloc_topology_info
* :hpx-pr:`2550` - Apex api updates
* :hpx-pr:`2549` - Pre-include defines.hpp to get the macro HPX_HAVE_CUDA value
* :hpx-pr:`2548` - Fixing issue with disconnect
* :hpx-pr:`2546` - Some fixes around cuda clang partitioned_vector example
* :hpx-pr:`2545` - Fix uses of the Vc2 datapar flags; the value, not the type,
  should be passed to functions
* :hpx-pr:`2542` - Make HPX_WITH_MALLOC easier to use
* :hpx-pr:`2541` - avoid recompiles when enabling/disabling examples
* :hpx-pr:`2540` - Fixing usage of target_link_libraries()
* :hpx-pr:`2539` - fix RPATH behaviour
* :hpx-issue:`2538` - HPX_WITH_CUDA corrupts compilation flags
* :hpx-pr:`2537` - Add output of a Bazel Skylark extension for paths and compile
  options
* :hpx-pr:`2536` - Add counter exposing total available memory to Windows as
  well
* :hpx-pr:`2535` - Remove obsolete support for security
* :hpx-issue:`2534` - Remove command line option ``--hpx:run-agas-server``
* :hpx-pr:`2533` - Pre-cache locality endpoints during bootstrap
* :hpx-pr:`2532` - Fixing handling of GIDs during serialization preprocessing
* :hpx-pr:`2531` - Amend uses of the term "functor"
* :hpx-pr:`2529` - added counter for reading available memory
* :hpx-pr:`2527` - Facilities to create actions from lambdas
* :hpx-pr:`2526` - Updated docs: HPX_WITH_EXAMPLES
* :hpx-pr:`2525` - Remove warnings related to unused captured variables
* :hpx-issue:`2524` - CMAKE failed because it is missing: TCMALLOC_LIBRARY
  TCMALLOC_INCLUDE_DIR
* :hpx-pr:`2523` - Fixing compose_cb stack overflow
* :hpx-pr:`2522` - Instead of unlocking, ignore the lock while creating the
  message handler
* :hpx-pr:`2521` - Create ``LPROGRESS_`` logging macro to simplify progress
  tracking and timings
* :hpx-pr:`2520` - Intel 17 support
* :hpx-pr:`2519` - Fix components example
* :hpx-pr:`2518` - Fixing parcel scheduling
* :hpx-issue:`2517` - Race condition during Parcel Coalescing Handler creation
* :hpx-issue:`2516` - HPX locks up when using at least 256 localities
* :hpx-issue:`2515` - error: Install cannot find
  "/lib/hpx/libparcel_coalescing.so.0.9.99" but I can see that file
* :hpx-pr:`2514` - Making sure that all continuations of a shared_future are
  invoked in order
* :hpx-pr:`2513` - Fixing locks held during suspension
* :hpx-pr:`2512` - MPI Parcelport improvements and fixes related to the
  background work changes
* :hpx-pr:`2511` - Fixing bit-wise (zero-copy) serialization
* :hpx-issue:`2509` - Linking errors in hwloc_topology
* :hpx-pr:`2508` - Added documentation for debugging with core files
* :hpx-pr:`2506` - Fixing background work invocations
* :hpx-pr:`2505` - Fix tuple serialization
* :hpx-issue:`2504` - Ensure continuations are called in the order they have
  been attached
* :hpx-pr:`2503` - Adding serialization support for Vc v2 (datapar)
* :hpx-pr:`2502` - Resolve various, minor compiler warnings
* :hpx-pr:`2501` - Some other fixes around cuda examples
* :hpx-issue:`2500` - nvcc / cuda clang issue due to a missing -DHPX_WITH_CUDA
  flag
* :hpx-pr:`2499` - Adding support for std::array to wait_all and friends
* :hpx-pr:`2498` - Execute background work as HPX thread
* :hpx-pr:`2497` - Fixing configuration options for spinlock-deadlock detection
* :hpx-pr:`2496` - Accounting for different compilers in CrayKNL toolchain file
* :hpx-pr:`2494` - Adding component base class which ties a component instance
  to a given executor
* :hpx-pr:`2493` - Enable controlling amount of pending threads which must be
  available to allow thread stealing
* :hpx-pr:`2492` - Adding new command line option --hpx:print-counter-reset
* :hpx-pr:`2491` - Resolve ambiguities when compiling with APEX
* :hpx-pr:`2490` - Resuming threads waiting on future with higher priority
* :hpx-issue:`2489` - nvcc issue because -std=c++11 appears twice
* :hpx-pr:`2488` - Adding performance counters exposing the internal idle and
  busy-loop counters
* :hpx-pr:`2487` - Allowing for plain suspend to reschedule thread right away
* :hpx-pr:`2486` - Only flag HPX code for CUDA if HPX_WITH_CUDA is set
* :hpx-pr:`2485` - Making thread-queue parameters runtime-configurable
* :hpx-pr:`2484` - Added atomic counter for parcel-destinations
* :hpx-pr:`2483` - Added priority-queue lifo scheduler
* :hpx-pr:`2482` - Changing scheduler to steal only if more than a minimal
  number of tasks are available
* :hpx-pr:`2481` - Extending command line option --hpx:print-counter-destination
  to support value 'none'
* :hpx-pr:`2479` - Added option to disable signal handler
* :hpx-pr:`2478` - Making sure the sine performance counter module gets loaded
  only for the corresponding example
* :hpx-issue:`2477` - Breaking at a throw statement
* :hpx-pr:`2476` - Annotated function
* :hpx-pr:`2475` - Ensure that using %osthread% during logging will not throw
  for non-hpx threads
* :hpx-pr:`2474` - Remove now superficial non_direct actions from base_lco and
  friends
* :hpx-pr:`2473` - Refining support for ITTNotify
* :hpx-pr:`2472` - Some fixes around hpx compute
* :hpx-issue:`2470` - redefinition of boost::detail::spinlock
* :hpx-issue:`2469` - Dataflow performance issue
* :hpx-pr:`2468` - Perf docs update
* :hpx-pr:`2466` - Guarantee to execute remote direct actions on HPX-thread
* :hpx-pr:`2465` - Improve demo : Async copy and fixed device handling
* :hpx-pr:`2464` - Adding performance counter exposing instantaneous scheduler
  utilization
* :hpx-pr:`2463` - Downcast to future<void>
* :hpx-pr:`2462` - Fixed usage of ITT-Notify API with Intel Amplifier
* :hpx-pr:`2461` - Cublas demo
* :hpx-pr:`2460` - Fixing thread bindings
* :hpx-pr:`2459` - Make -std=c++11 nvcc flag consistent for in-build and
  installed versions
* :hpx-issue:`2457` - Segmentation fault when registering a partitioned vector
* :hpx-pr:`2452` - Properly releasing global barrier for unhandled exceptions
* :hpx-pr:`2451` - Fixing long shutdown times
* :hpx-pr:`2450` - Attempting to fix initialization errors on newer platforms
  (Boost V1.63)
* :hpx-pr:`2449` - Replace BOOST_COMPILER_FENCE with an HPX version
* :hpx-pr:`2448` - This fixes a possible race in the migration code
* :hpx-pr:`2445` - Fixing dataflow et.al. for futures or future-ranges wrapped
                 into ref()
* :hpx-pr:`2444` - Fix segfaults
* :hpx-pr:`2443` - Issue 2442
* :hpx-issue:`2442` - Mismatch between #if/#endif and namespace scope brackets
  in this_thread_executers.hpp
* :hpx-issue:`2441` - undeclared identifier BOOST_COMPILER_FENCE
* :hpx-pr:`2440` - Knl build
* :hpx-pr:`2438` - Datapar backend
* :hpx-pr:`2437` - Adapt algorithm parameter sequence changes from C++17
* :hpx-pr:`2436` - Adapt execution policy name changes from C++17
* :hpx-issue:`2435` - Trunk broken, undefined reference to
  hpx::thread::interrupt(hpx::thread::id, bool)
* :hpx-pr:`2434` - More fixes to resource manager
* :hpx-pr:`2433` - Added versions of ``hpx::get_ptr`` taking client side
  representations
* :hpx-pr:`2432` - Warning fixes
* :hpx-pr:`2431` - Adding facility representing set of performance counters
* :hpx-pr:`2430` - Fix parallel_executor thread spawning
* :hpx-pr:`2429` - Fix attribute warning for gcc
* :hpx-issue:`2427` - Seg fault running octo-tiger with latest HPX commit
* :hpx-issue:`2426` - Bug in 9592f5c0bc29806fce0dbe73f35b6ca7e027edcb causes
  immediate crash in Octo-tiger
* :hpx-pr:`2425` - Fix nvcc errors due to constexpr specifier
* :hpx-issue:`2424` - Async action on component present on hpx::find_here is
  executing synchronously
* :hpx-pr:`2423` - Fix nvcc errors due to constexpr specifier
* :hpx-pr:`2422` - Implementing hpx::this_thread thread data functions
* :hpx-pr:`2421` - Adding benchmark for wait_all
* :hpx-issue:`2420` - Returning object of a component client from another
  component action fails
* :hpx-pr:`2419` - Infiniband parcelport
* :hpx-issue:`2418` - gcc + nvcc fails to compile code that uses
  partitioned_vector
* :hpx-pr:`2417` - Fixing context switching
* :hpx-pr:`2416` - Adding fixes and workarounds to allow compilation with
  nvcc/msvc (VS2015up3)
* :hpx-pr:`2415` - Fix errors coming from hpx compute examples
* :hpx-pr:`2414` - Fixing msvc12
* :hpx-pr:`2413` - Enable cuda/nvcc or cuda/clang when using
  add_hpx_executable()
* :hpx-pr:`2412` - Fix issue in HPX_SetupTarget.cmake when cuda is used
* :hpx-pr:`2411` - This fixes the core compilation issues with MSVC12
* :hpx-issue:`2410` - ``undefined reference to opal_hwloc191_hwloc_.....``
* :hpx-pr:`2409` - Fixing locking for channel and receive_buffer
* :hpx-pr:`2407` - Solving #2402 and #2403
* :hpx-pr:`2406` - Improve guards
* :hpx-pr:`2405` - Enable parallel::for_each for iterators returning proxy types
* :hpx-pr:`2404` - Forward the explicitly given result_type in the hpx invoke
* :hpx-issue:`2403` - datapar_execution + zip iterator: lambda arguments aren't
  references
* :hpx-issue:`2402` - datapar algorithm instantiated with wrong type #2402
* :hpx-pr:`2401` - Added support for imported libraries to HPX_Libraries.cmake
* :hpx-pr:`2400` - Use CMake policy CMP0060
* :hpx-issue:`2399` - Error trying to push back vector of futures to vector
* :hpx-pr:`2398` - Allow config #defines to be written out to custom
  config/defines.hpp
* :hpx-issue:`2397` - CMake generated config defines can cause tedious rebuilds
  category
* :hpx-issue:`2396` - BOOST_ROOT paths are not used at link time
* :hpx-pr:`2395` - Fix target_link_libraries() issue when HPX Cuda is enabled
* :hpx-issue:`2394` - Template compilation error using
  HPX_WITH_DATAPAR_LIBFLATARRAY
* :hpx-pr:`2393` - Fixing lock registration for recursive mutex
* :hpx-pr:`2392` - Add keywords in target_link_libraries in hpx_setup_target
* :hpx-pr:`2391` - Clang goroutines
* :hpx-issue:`2390` - Adapt execution policy name changes from C++17
* :hpx-pr:`2389` - Chunk allocator and pool are not used and are obsolete
* :hpx-pr:`2388` - Adding functionalities to datapar needed by octotiger
* :hpx-pr:`2387` - Fixing race condition for early parcels
* :hpx-issue:`2386` - Lock registration broken for recursive_mutex
* :hpx-pr:`2385` - Datapar zip iterator
* :hpx-pr:`2384` - Fixing race condition in for_loop_reduction
* :hpx-pr:`2383` - Continuations
* :hpx-pr:`2382` - add LibFlatArray-based backend for datapar
* :hpx-pr:`2381` - remove unused typedef to get rid of compiler warnings
* :hpx-pr:`2380` - Tau cleanup
* :hpx-pr:`2379` - Can send immediate
* :hpx-pr:`2378` - Renaming copy_helper/copy_n_helper/move_helper/move_n_helper
* :hpx-issue:`2376` - Boost trunk's spinlock initializer fails to compile
* :hpx-pr:`2375` - Add support for minimal thread local data
* :hpx-pr:`2374` - Adding API functions set_config_entry_callback
* :hpx-pr:`2373` - Add a simple utility for debugging that gives suspended task
  backtraces
* :hpx-pr:`2372` - Barrier Fixes
* :hpx-issue:`2370` - Can't wait on a wrapped future
* :hpx-pr:`2369` - Fixing stable_partition
* :hpx-pr:`2367` - Fixing find_prefixes for Windows platforms
* :hpx-pr:`2366` - Testing for experimental/optional only in C++14 mode
* :hpx-pr:`2364` - Adding set_config_entry
* :hpx-pr:`2363` - Fix papi
* :hpx-pr:`2362` - Adding missing macros for new non-direct actions
* :hpx-pr:`2361` - Improve cmake output to help debug compiler incompatibility
  check
* :hpx-pr:`2360` - Fixing race condition in condition_variable
* :hpx-pr:`2359` - Fixing shutdown when parcels are still in flight
* :hpx-issue:`2357` - failed to insert console_print_action into
  typename_to_id_t registry
* :hpx-pr:`2356` - Fixing return type of get_iterator_tuple
* :hpx-pr:`2355` - Fixing compilation against Boost 1 62
* :hpx-pr:`2354` - Adding serialization for mask_type if CPU_COUNT > 64
* :hpx-pr:`2353` - Adding hooks to tie in APEX into the parcel layer
* :hpx-issue:`2352` - Compile errors when using intel 17 beta (for KNL) on
  edison
* :hpx-pr:`2351` - Fix function vtable get_function_address implementation
* :hpx-issue:`2350` - Build failure - master branch (4de09f5) with Intel
  Compiler v17
* :hpx-pr:`2349` - Enabling zero-copy serialization support for std::vector<>
* :hpx-pr:`2348` - Adding test to verify #2334 is fixed
* :hpx-pr:`2347` - Bug fixes for hpx.compute and hpx::lcos::channel
* :hpx-pr:`2346` - Removing cmake "find" files that are in the APEX cmake
  Modules
* :hpx-pr:`2345` - Implemented parallel::stable_partition
* :hpx-pr:`2344` - Making hpx::lcos::channel usable with basename registration
* :hpx-pr:`2343` - Fix a couple of examples that failed to compile after recent
  api changes
* :hpx-issue:`2342` - Enabling APEX causes link errors
* :hpx-pr:`2341` - Removing cmake "find" files that are in the APEX cmake
  Modules
* :hpx-pr:`2340` - Implemented all existing datapar algorithms using Boost.SIMD
* :hpx-pr:`2339` - Fixing 2338
* :hpx-pr:`2338` - Possible race in sliding semaphore
* :hpx-pr:`2337` - Adjust osu_latency test to measure window_size parcels in
  flight at once
* :hpx-pr:`2336` - Allowing remote direct actions to be executed without
  spawning a task
* :hpx-pr:`2335` - Making sure multiple components are properly initialized from
  arguments
* :hpx-issue:`2334` - Cannot construct component with large vector on a remote
  locality
* :hpx-pr:`2332` - Fixing hpx::lcos::local::barrier
* :hpx-pr:`2331` - Updating APEX support to include OTF2
* :hpx-pr:`2330` - Support for data-parallelism for parallel algorithms
* :hpx-issue:`2329` - Coordinate settings in cmake
* :hpx-pr:`2328` - fix LibGeoDecomp builds with HPX + GCC 5.3.0 + CUDA 8RC
* :hpx-pr:`2326` - Making scan_partitioner work (for now)
* :hpx-issue:`2323` - Constructing a vector of components only correctly
  initializes the first component
* :hpx-pr:`2322` - Fix problems that bubbled up after merging #2278
* :hpx-pr:`2321` - Scalable barrier
* :hpx-pr:`2320` - Std flag fixes
* :hpx-issue:`2319` - -std=c++14 and -std=c++1y with Intel can't build recent
  Boost builds due to insufficient C++14 support; don't enable these flags by
  default for Intel
* :hpx-pr:`2318` - Improve handling of --hpx:bind=<bind-spec>
* :hpx-pr:`2317` - Making sure command line warnings are printed once only
* :hpx-pr:`2316` - Fixing command line handling for default bind mode
* :hpx-pr:`2315` - Set id_retrieved if set_id is present
* :hpx-issue:`2314` - Warning for requested/allocated thread discrepancy is
  printed twice
* :hpx-issue:`2313` - --hpx:print-bind doesn't work with --hpx:pu-step
* :hpx-issue:`2312` - --hpx:bind range specifier restrictions are overly
  restrictive
* :hpx-issue:`2311` - hpx_0.9.99 out of project build fails
* :hpx-pr:`2310` - Simplify function registration
* :hpx-pr:`2309` - Spelling and grammar revisions in documentation (and some
  code)
* :hpx-pr:`2306` - Correct minor typo in the documentation
* :hpx-pr:`2305` - Cleaning up and fixing parcel coalescing
* :hpx-pr:`2304` - Inspect checks for stream related includes
* :hpx-pr:`2303` - Add functionality allowing to enumerate threads of given
  state
* :hpx-pr:`2301` - Algorithm overloads fix for VS2013
* :hpx-pr:`2300` - Use <cstdint>, add inspect checks
* :hpx-pr:`2299` - Replace boost::[c]ref with std::[c]ref, add inspect checks
* :hpx-pr:`2297` - Fixing compilation with no hw_loc
* :hpx-pr:`2296` - Hpx compute
* :hpx-pr:`2295` - Making sure for_loop(execution::par, 0, N, ...) is actually
  executed in parallel
* :hpx-pr:`2294` - Throwing exceptions if the runtime is not up and running
* :hpx-pr:`2293` - Removing unused parcel port code
* :hpx-pr:`2292` - Refactor function vtables
* :hpx-pr:`2291` - Fixing 2286
* :hpx-pr:`2290` - Simplify algorithm overloads
* :hpx-pr:`2289` - Adding performance counters reporting parcel related data on
  a per-action basis
* :hpx-issue:`2288` - Remove dormant parcelports
* :hpx-issue:`2286` - adjustments to parcel handling to support parcelports that
  do not need a connection cache
* :hpx-pr:`2285` - add CMake option to disable package export
* :hpx-pr:`2283` - Add more inspect checks for use of deprecated components
* :hpx-issue:`2282` - Arithmetic exception in executor static chunker
* :hpx-issue:`2281` - For loop doesn't parallelize
* :hpx-pr:`2280` - Fixing 2277: build failure with PAPI
* :hpx-pr:`2279` - Child vs parent stealing
* :hpx-issue:`2277` - master branch build failure (53c5b4f) with papi
* :hpx-pr:`2276` - Compile time launch policies
* :hpx-pr:`2275` - Replace boost::chrono with std::chrono in interfaces
* :hpx-pr:`2274` - Replace most uses of Boost.Assign with initializer list
* :hpx-pr:`2273` - Fixed typos
* :hpx-pr:`2272` - Inspect checks
* :hpx-pr:`2270` - Adding test verifying -Ihpx.os_threads=all
* :hpx-pr:`2269` - Added inspect check for now obsolete boost type traits
* :hpx-pr:`2268` - Moving more code into source files
* :hpx-issue:`2267` - Add inspect support to deprecate Boost.TypeTraits
* :hpx-pr:`2265` - Adding channel LCO
* :hpx-pr:`2264` - Make support for std::ref mandatory
* :hpx-pr:`2263` - Constrain tuple_member forwarding constructor
* :hpx-issue:`2262` - Test hpx.os_threads=all
* :hpx-issue:`2261` - OS X: Error: no matching constructor for initialization of
  'hpx::lcos::local::condition_variable_any'
* :hpx-issue:`2260` - Make support for std::ref mandatory
* :hpx-pr:`2259` - Remove most of Boost.MPL, Boost.EnableIf and Boost.TypeTraits
* :hpx-pr:`2258` - Fixing #2256
* :hpx-pr:`2257` - Fixing launch process
* :hpx-issue:`2256` - Actions are not registered if not invoked
* :hpx-pr:`2255` - Coalescing histogram
* :hpx-pr:`2254` - Silence explicit initialization in copy-constructor warnings
* :hpx-pr:`2253` - Drop support for GCC 4.6 and 4.7
* :hpx-pr:`2252` - Prepare V1.0
* :hpx-pr:`2251` - Convert to 0.9.99
* :hpx-pr:`2249` - Adding iterator_facade and iterator_adaptor
* :hpx-issue:`2248` - Need a feature to yield to a new task immediately
* :hpx-pr:`2246` - Adding split_future
* :hpx-pr:`2245` - Add an example for handing over a component instance to a
  dynamically launched locality
* :hpx-issue:`2243` - Add example demonstrating AGAS symbolic name registration
* :hpx-issue:`2242` - pkgconfig test broken on CentOS 7 / Boost 1.61
* :hpx-issue:`2241` - Compilation error for partitioned vector in hpx_compute
  branch
* :hpx-pr:`2240` - Fixing termination detection on one locality
* :hpx-issue:`2239` - Create a new facility lcos::split_all
* :hpx-issue:`2236` - hpx::cout vs. std::cout
* :hpx-pr:`2232` - Implement local-only primary namespace service
* :hpx-issue:`2147` - would like to know how much data is being routed by
  particular actions
* :hpx-issue:`2109` - Warning while compiling hpx
* :hpx-issue:`1973` - Setting INTERFACE_COMPILE_OPTIONS for hpx_init in CMake
  taints Fortran_FLAGS
* :hpx-issue:`1864` - run_guarded using bound function ignores reference
* :hpx-issue:`1754` - Running with TCP parcelport causes immediate crash or
  freeze
* :hpx-issue:`1655` - Enable zip_iterator to be used with Boost traversal
  iterator categories
* :hpx-issue:`1591` - Optimize AGAS for shared memory only operation
* :hpx-issue:`1401` - Need an efficient infiniband parcelport
* :hpx-issue:`1125` - Fix the IPC parcelport
* :hpx-issue:`839` - Refactor ibverbs and shmem parcelport
* :hpx-issue:`702` - Add instrumentation of parcel layer
* :hpx-issue:`668` - Implement ispc task interface
* :hpx-issue:`533` - Thread queue/deque internal parameters should be runtime
  configurable
* :hpx-issue:`475` - Create a means of combining performance counters into
  querysets

..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_interest_calculator:

========
Dataflow
========

|hpx| provides its users with several different tools to simply express parallel
concepts. One of these tools is a :term:`local control object` (:term:`LCO`)
called dataflow. An :term:`LCO` is a type of component that can spawn a new
thread when triggered. They are also distinguished from other components by a
standard interface that allow users to understand and use them easily.
A Dataflow, being an :term:`LCO`, is triggered when the values it depends on
become available. For instance, if you have a calculation X that depends on the
results of three other calculations, you could set up a dataflow that would begin
the calculation X as soon as the other three calculations have returned their
values. Dataflows are set up to depend on other dataflows. It is this property
that makes dataflow a powerful parallelization tool. If you understand the
dependencies of your calculation, you can devise a simple algorithm that sets
up a dependency tree to be executed. In this example, we calculate compound
interest. To calculate compound interest, one must calculate the interest made
in each compound period, and then add that interest back to the principal before
calculating the interest made in the next period. A practical person would, of
course, use the formula for compound interest:

.. math::

   F = P(1 + i) ^ n

where :math:`F` is the future value, :math:`P` is the principal value, :math:`i`
is the interest rate, and :math:`n` is the number of compound periods.

However, for the sake of this example, we have chosen to manually calculate the
future value by iterating:

.. math::

   I = Pi

and

.. math::

   P = P + I

Setup
=====

The source code for this example can be found here:
:download:`interest_calculator.cpp
<../../examples/quickstart/interest_calculator.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.quickstart.interest_calculator

To run the program type:

.. code-block:: shell-session

   $ ./bin/interest_calculator --principal 100 --rate 5 --cp 6 --time 36
   Final amount: 134.01
   Amount made: 34.0096

Walkthrough
===========

Let us begin with main. Here we can see that we again are using
|boost_program_options| to set our command line variables (see
:ref:`examples_fibonacci` for more details). These options set the principal,
rate, compound period, and time. It is important to note that the units of time
for ``cp`` and ``time`` must be the same.

.. literalinclude:: ../../examples/quickstart/interest_calculator.cpp
   :language: c++
   :start-after: //[interest_main
   :end-before: //]

Next we look at hpx_main.

.. literalinclude:: ../../examples/quickstart/interest_calculator.cpp
   :language: c++
   :start-after: //[interest_hpx_main
   :end-before: //]


Here we find our command line variables read in, the rate is converted from a
percent to a decimal, the number of calculation iterations is determined, and
then our shared_futures are set up. Notice that we first place our principal and
rate into shares futures by passing the variables ``init_principal`` and
``init_rate`` using :cpp:class:`hpx::make_ready_future`.

In this way :cpp:class:`hpx::shared_future`\ ``<double>`` ``principal``
and ``rate`` will be initialized to ``init_principal`` and ``init_rate`` when
:cpp:class:`hpx::make_ready_future`\ ``<double>`` returns a future containing
those initial values. These shared futures then enter the for loop and are
passed to ``interest``. Next ``principal`` and ``interest`` are passed to the
reassignment of ``principal`` using a :cpp:class:`hpx::dataflow`. A dataflow
will first wait for its arguments to be ready before launching any callbacks, so
``add`` in this case will not begin until both ``principal`` and ``interest``
are ready. This loop continues for each compound period that must be calculated.
To see how ``interest`` and ``principal`` are calculated in the loop, let us look
at ``calc_action`` and ``add_action``:

.. literalinclude:: ../../examples/quickstart/interest_calculator.cpp
   :language: c++
   :start-after: //[interest_calc_add_action
   :end-before: //]

After the shared future dependencies have been defined in hpx_main, we see the
following statement:

.. code-block:: c++

   double result = principal.get();

This statement calls :cpp:member:`hpx::future::get` on the shared future
principal which had its value calculated by our for loop. The program will wait
here until the entire dataflow tree has been calculated and the value assigned
to result. The program then prints out the final value of the investment and the
amount of interest made by subtracting the final value of the investment from
the initial value of the investment.
..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_accumulator:

======================
Components and actions
======================

The accumulator example demonstrates the use of components. Components are C++
classes that expose methods as a type of |hpx| action. These actions are called
component actions.

Components are globally named, meaning that a component action can be called
remotely (e.g.,  from another machine). There are two accumulator examples in
|hpx|.

In the :ref:`examples_fibonacci` and the :ref:`examples_hello_world`, we
introduced plain actions, which wrapped global functions. The target of a plain
action is an identifier which refers to a particular machine involved in the
computation. For plain actions, the target is the machine where the action will
be executed.

Component actions, however, do not target machines. Instead, they target
component instances. The instance may live on the machine that we've invoked the
component action from, or it may live on another machine.

The component in this example exposes three different functions:

* ``reset()`` - Resets the accumulator value to 0.
* ``add(arg)`` - Adds ``arg`` to the accumulators value.
* ``query()`` - Queries the value of the accumulator.

This example creates an instance of the accumulator, and then allows the user to
enter commands at a prompt, which subsequently invoke actions on the accumulator
instance.

Setup
=====

The source code for this example can be found here:
:download:`accumulator_client.cpp
<../../examples/accumulators/accumulator_client.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.accumulators.accumulator

To run the program type:

.. code-block:: shell-session

   $ ./bin/accumulator_client

Once the program starts running, it will print the following prompt and then
wait for input. An example session is given below:

.. code-block:: text

   commands: reset, add [amount], query, help, quit
   > add 5
   > add 10
   > query
   15
   > add 2
   > query
   17
   > reset
   > add 1
   > query
   1
   > quit

Walkthrough
===========

Now, let's take a look at the source code of the accumulator example. This
example consists of two parts: an |hpx| component library (a library that
exposes an |hpx| component) and a client application which uses the library.
This walkthrough will cover the |hpx| component library. The code for the client
application can be found here: :download:`accumulator_client.cpp
<../../examples/accumulators/accumulator_client.cpp>`.

An |hpx| component is represented by two C++ classes:

* **A server class** - The implementation of the component's functionality.
* **A client class** - A high-level interface that acts as a proxy for an
  instance of the component.

Typically, these two classes both have the same name, but the server class
usually lives in different sub-namespaces (``server``). For example, the full
names of the two classes in accumulator are:

* ``examples::server::accumulator`` (server class)
* ``examples::accumulator`` (client class)

The server class
----------------

The following code is from: :download:`accumulator.hpp
<../../examples/accumulators/server/accumulator.hpp>`.

All |hpx| component server classes must inherit publicly from the |hpx|
component base class: :cpp:class:`hpx::components::component_base`

The accumulator component inherits from
:cpp:class:`hpx::components::locking_hook`. This allows the runtime system to
ensure that all action invocations are serialized. That means that the system
ensures that no two actions are invoked at the same time on a given component
instance. This makes the component thread safe and no additional locking has to
be implemented by the user. Moreover, an accumulator component is a component
because it also inherits from :cpp:class:`hpx::components::component_base` (the
template argument passed to locking_hook is used as its base class). The
following snippet shows the corresponding code:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_server_inherit
   :end-before: //]

Our accumulator class will need a data member to store its value in, so let's
declare a data member:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_server_data_member
   :end-before: //]

The constructor for this class simply initializes ``value_`` to 0:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_server_ctor
   :end-before: //]

Next, let's look at the three methods of this component that we will be exposing
as component actions:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_components
   :end-before: //]

Here are the action types. These types wrap the methods we're exposing. The
wrapping technique is very similar to the one used in the
:ref:`examples_fibonacci` and the :ref:`examples_hello_world`:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_action_types
   :end-before: //]

The last piece of code in the server class header is the declaration of the
action type registration code:

.. literalinclude:: ../../examples/accumulators/server/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_registration_declarations
   :end-before: //]

.. note::

   The code above must be placed in the global namespace.

The rest of the registration code is in
:download:`accumulator.cpp <../../examples/accumulators/accumulator.cpp>`

.. literalinclude:: ../../examples/accumulators/accumulator.cpp
   :language: c++
   :start-after: //[accumulator_registration_definitions
   :end-before: //]


.. note::

   The code above must be placed in the global namespace.

The client class
----------------

The following code is from :download:`accumulator.hpp
<../../examples/accumulators/accumulator.hpp>`.

The client class is the primary interface to a component instance. Client classes
are used to create components::

    // Create a component on this locality.
    examples::accumulator c = hpx::new_<examples::accumulator>(hpx::find_here());

and to invoke component actions::

    c.add(hpx::launch::apply, 4);

Clients, like servers, need to inherit from a base class, this time,
:cpp:class:`hpx::components::client_base`:

.. literalinclude:: ../../examples/accumulators/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_client_inherit
   :end-before: //]

For readability, we typedef the base class like so:

.. literalinclude:: ../../examples/accumulators/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_base_type
   :end-before: //]

Here are examples of how to expose actions through a client class:

There are a few different ways of invoking actions:

* **Non-blocking**: For actions that don't have return types, or when we do not
  care about the result of an action, we can invoke the action using
  fire-and-forget semantics. This means that once we have asked |hpx| to compute
  the action, we forget about it completely and continue with our computation.
  We use :cpp:func:`hpx::apply` to invoke an action in a non-blocking fashion.

.. literalinclude:: ../../examples/accumulators/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_client_reset_non_blocking
   :end-before: //]

* **Asynchronous**: Futures, as demonstrated in :ref:`examples_fibonacci_local`,
  :ref:`examples_fibonacci`, and the :ref:`examples_hello_world`, enable
  asynchronous action invocation. Here's an example from the accumulator client
  class:

.. literalinclude:: ../../examples/accumulators/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_client_query_async
   :end-before: //]

* **Synchronous**: To invoke an action in a fully synchronous manner, we can
  simply call :cpp:func:`hpx::async`\ ``().get()`` (i.e., create a future and
  immediately wait on it to be ready). Here's an example from the accumulator
  client class:

.. literalinclude:: ../../examples/accumulators/accumulator.hpp
   :language: c++
   :start-after: //[accumulator_client_add_sync
   :end-before: //]

Note that ``this->get_id()`` references a data member of the
:cpp:class:`hpx::components::client_base` base class which identifies the server
accumulator instance.

:cpp:class:`hpx::naming::id_type` is a type which represents a global identifier
in |hpx|. This type specifies the target of an action. This is the type that is
returned by :cpp:func:`hpx::find_here` in which case it represents the
:term:`locality` the code is running on.
..
    Copyright (c) 2014 Adrian Serio

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_1d_stencil:

===============
Local to remote
===============

When developers write code they typically begin with a simple serial code and
build upon it until all of the required functionality is present. The following
set of examples were developed to demonstrate this iterative process of evolving
a simple serial program to an efficient, fully-distributed |hpx| application. For
this demonstration, we implemented a 1D heat distribution problem. This
calculation simulates the diffusion of heat across a ring from an initialized
state to some user-defined point in the future. It does this by breaking each
portion of the ring into discrete segments and using the current segment's
temperature and the temperature of the surrounding segments to calculate the
temperature of the current segment in the next timestep as shown by
:numref:`1d_stencil_program_flow` below.

.. _1d_stencil_program_flow:

.. figure:: ../_static/images/1d_stencil_program_flow.png

   Heat diffusion example program flow.

We parallelize this code over the following eight examples:

* :download:`Example 1 <../../examples/1d_stencil/1d_stencil_1.cpp>`
* :download:`Example 2 <../../examples/1d_stencil/1d_stencil_2.cpp>`
* :download:`Example 3 <../../examples/1d_stencil/1d_stencil_3.cpp>`
* :download:`Example 4 <../../examples/1d_stencil/1d_stencil_4.cpp>`
* :download:`Example 5 <../../examples/1d_stencil/1d_stencil_5.cpp>`
* :download:`Example 6 <../../examples/1d_stencil/1d_stencil_6.cpp>`
* :download:`Example 7 <../../examples/1d_stencil/1d_stencil_7.cpp>`
* :download:`Example 8 <../../examples/1d_stencil/1d_stencil_8.cpp>`

The first example is straight serial code. In this code we instantiate a vector
``U`` that contains two vectors of doubles as seen in the structure
``stepper``.

.. literalinclude:: ../../examples/1d_stencil/1d_stencil_1.cpp
   :language: c++
   :start-after: //[stepper_1
   :end-before: //]

Each element in the vector of doubles represents a single grid point. To
calculate the change in heat distribution, the temperature of each grid point,
along with its neighbors, is passed to the function ``heat``. In order to
improve readability, references named ``current`` and ``next`` are created
which, depending on the time step, point to the first and second vector of
doubles. The first vector of doubles is initialized with a simple heat ramp.
After calling the heat function with the data in the ``current`` vector, the
results are placed into the ``next`` vector.

In example 2 we employ a technique called futurization. Futurization is a method
by which we can easily transform a code that is serially executed into a code
that creates asynchronous threads. In the simplest case this involves replacing
a variable with a future to a variable, a function with a future to a function,
and adding a ``.get()`` at the point where a value is actually needed. The code
below shows how this technique was applied to the ``struct stepper``.

.. literalinclude:: ../../examples/1d_stencil/1d_stencil_2.cpp
   :language: c++
   :start-after: //[stepper_2
   :end-before: //]

In example 2, we redefine our partition type as a ``shared_future`` and, in
``main``, create the object ``result``, which is a future to a vector of
partitions. We use ``result`` to represent the last vector in a string of
vectors created for each timestep. In order to move to the next timestep, the
values of a partition and its neighbors must be passed to ``heat`` once the
futures that contain them are ready. In |hpx|, we have an LCO (Local Control
Object) named Dataflow that assists the programmer in expressing this
dependency. Dataflow allows us to pass the results of a set of futures to a
specified function when the futures are ready. Dataflow takes three types of
arguments, one which instructs the dataflow on how to perform the function call
(async or sync), the function to call (in this case ``Op``), and futures to the
arguments that will be passed to the function. When called, dataflow immediately
returns a future to the result of the specified function. This allows users to
string dataflows together and construct an execution tree.

After the values of the futures in dataflow are ready, the values must be pulled
out of the future container to be passed to the function ``heat``. In order to
do this, we use the HPX facility ``unwrapping``, which underneath calls
``.get()`` on each of the futures so that the function ``heat`` will be passed
doubles and not futures to doubles.

By setting up the algorithm this way, the program will be able to execute as
quickly as the dependencies of each future are met. Unfortunately, this example
runs terribly slow. This increase in execution time is caused by the overheads
needed to create a future for each data point. Because the work done within each
call to heat is very small, the overhead of creating and scheduling each of the
three futures is greater than that of the actual useful work! In order to
amortize the overheads of our synchronization techniques, we need to be able to
control the amount of work that will be done with each future. We call this
amount of work per overhead grain size.

In example 3, we return to our serial code to figure out how to control the
grain size of our program. The strategy that we employ is to create "partitions"
of data points. The user can define how many partitions are created and how many
data points are contained in each partition. This is accomplished by creating
the ``struct partition``, which contains a member object ``data_``, a vector of
doubles that holds the data points assigned to a particular instance of
``partition``.

In example 4, we take advantage of the partition setup by redefining ``space``
to be a vector of shared_futures with each future representing a partition. In
this manner, each future represents several data points. Because the user can
define how many data points are in each partition, and, therefore, how
many data points are represented by one future, a user can control the
grainsize of the simulation. The rest of the code is then futurized in the same
manner as example 2. It should be noted how strikingly similar
example 4 is to example 2.

Example 4 finally shows good results. This code scales equivalently to the
OpenMP version. While these results are promising, there are more opportunities
to improve the application's scalability. Currently, this code only runs on one
:term:`locality`, but to get the full benefit of |hpx|, we need to be able to
distribute the work to other machines in a cluster. We begin to add this
functionality in example 5.

In order to run on a distributed system, a large amount of boilerplate code must
be added. Fortunately, |hpx| provides us with the concept of a :term:`component`,
which saves us from having to write quite as much code. A component is an object
that can be remotely accessed using its global address. Components are made of
two parts: a server and a client class. While the client class is not required,
abstracting the server behind a client allows us to ensure type safety instead
of having to pass around pointers to global objects. Example 5 renames example
4's ``struct partition`` to ``partition_data`` and adds serialization support.
Next, we add the server side representation of the data in the structure
``partition_server``. ``Partition_server`` inherits from
``hpx::components::component_base``, which contains a server-side component
boilerplate. The boilerplate code allows a component's public members to be
accessible anywhere on the machine via its Global Identifier (GID). To
encapsulate the component, we create a client side helper class. This object
allows us to create new instances of our component and access its members
without having to know its GID. In addition, we are using the client class to
assist us with managing our asynchrony. For example, our client class
``partition``\ 's member function ``get_data()`` returns a future to
``partition_data get_data()``. This struct inherits its boilerplate code from
``hpx::components::client_base``.

In the structure ``stepper``, we have also had to make some changes to
accommodate a distributed environment. In order to get the data from a
particular neighboring partition, which could be remote, we must retrieve the data from all
of the neighboring partitions. These retrievals are asynchronous and the function
``heat_part_data``, which, amongst other things, calls ``heat``, should not be
called unless the data from the neighboring partitions have arrived. Therefore,
it should come as no surprise that we synchronize this operation with another
instance of dataflow (found in ``heat_part``). This dataflow receives futures
to the data in the current and surrounding partitions by calling ``get_data()``
on each respective partition. When these futures are ready, dataflow passes them
to the ``unwrapping`` function, which extracts the shared_array of doubles and
passes them to the lambda. The lambda calls ``heat_part_data`` on the
:term:`locality`, which the middle partition is on.

Although this example could run distributed, it only runs on one
:term:`locality`, as it always uses ``hpx::find_here()`` as the target for the
functions to run on.

In example 6, we begin to distribute the partition data on different nodes. This
is accomplished in ``stepper::do_work()`` by passing the GID of the
:term:`locality` where we wish to create the partition to the partition
constructor.

.. literalinclude:: ../../examples/1d_stencil/1d_stencil_6.cpp
   :language: c++
   :start-after: //[do_work_6
   :end-before: //]

We distribute the partitions evenly based on the number of localities used,
which is described in the function ``locidx``. Because some of the data needed
to update the partition in ``heat_part`` could now be on a new :term:`locality`,
we must devise a way of moving data to the :term:`locality` of the middle
partition. We accomplished this by adding a switch in the function
``get_data()`` that returns the end element of the ``buffer data_`` if it is
from the left partition or the first element of the buffer if the data is from
the right partition. In this way only the necessary elements, not the whole
buffer, are exchanged between nodes. The reader should be reminded that this
exchange of end elements occurs in the function ``get_data()`` and, therefore, is
executed asynchronously.

Now that we have the code running in distributed, it is time to make some
optimizations. The function ``heat_part`` spends most of its time on two tasks:
retrieving remote data and working on the data in the middle partition. Because
we know that the data for the middle partition is local, we can overlap the work
on the middle partition with that of the possibly remote call of ``get_data()``.
This algorithmic change, which was implemented in example 7, can be seen below:

.. literalinclude:: ../../examples/1d_stencil/1d_stencil_7.cpp
   :language: c++
   :start-after: //[stepper_7
   :end-before: //]

Example 8 completes the futurization process and utilizes the full potential of
|hpx| by distributing the program flow to multiple localities, usually defined as
nodes in a cluster. It accomplishes this task by running an instance of |hpx| main
on each :term:`locality`. In order to coordinate the execution of the program,
the ``struct stepper`` is wrapped into a component. In this way, each
:term:`locality` contains an instance of stepper that executes its own instance
of the function ``do_work()``. This scheme does create an interesting
synchronization problem that must be solved. When the program flow was being
coordinated on the head node, the GID of each component was known. However, when
we distribute the program flow, each partition has no notion of the GID of its
neighbor if the next partition is on another :term:`locality`. In order to make
the GIDs of neighboring partitions visible to each other, we created two buffers
to store the GIDs of the remote neighboring partitions on the left and right
respectively. These buffers are filled by sending the GID of newly created
edge partitions to the right and left buffers of the neighboring localities.

In order to finish the simulation, the solution vectors named ``result`` are then
gathered together on :term:`locality` 0 and added into a vector of spaces
``overall_result`` using the |hpx| functions ``gather_id`` and ``gather_here``.

.. todo::

   Insert performance of ``stencil_8``.

Example 8 completes this example series, which takes the serial code of example 1
and incrementally morphs it into a fully distributed parallel code. This
evolution was guided by the simple principles of futurization, the knowledge of
grainsize, and utilization of components. Applying these techniques easily
facilitates the scalable parallelization of most applications.

..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_fibonacci_local:

======================
Asynchronous execution
======================

The Fibonacci sequence is a sequence of numbers starting with 0 and 1 where
every subsequent number is the sum of the previous two numbers. In this example,
we will use |hpx| to calculate the value of the n-th element of the Fibonacci
sequence. In order to compute this problem in parallel, we will use a facility
known as a future.

As shown in the :numref:`future_schematics` below, a future encapsulates a
delayed computation. It acts as a proxy for a result initially not known, most
of the time because the computation of the result has not completed yet. The
future synchronizes the access of this value by optionally suspending any
|hpx|-threads requesting the result until the value is available. When a future
is created, it spawns a new |hpx|-thread (either remotely with a :term:`parcel`
or locally by placing it into the thread queue) which, when run, will execute
the function associated with the future. The arguments of the function are bound
when the future is created.

.. _future_schematics:

.. figure:: ../_static/images/future_schematics.png

   Schematic of a future execution.

Once the function has finished executing, a write operation is performed on the
future. The write operation marks the future as completed, and optionally stores
data returned by the function. When the result of the delayed computation is
needed, a read operation is performed on the future. If the future's function
hasn't completed when a read operation is performed on it, the reader
|hpx|-thread is suspended until the future is ready. The future facility allows
|hpx| to schedule work early in a program so that when the function value is
needed it will already be calculated and available. We use this property in our
Fibonacci example below to enable its parallel execution.

Setup
=====

The source code for this example can be found here:
:download:`fibonacci_local.cpp <../../examples/quickstart/fibonacci_local.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.quickstart.fibonacci_local

To run the program type:

.. code-block:: shell-session

   $ ./bin/fibonacci_local

This should print (time should be approximate):

.. code-block:: text

    fibonacci(10) == 55
    elapsed time: 0.002430 [s]

This run used the default settings, which calculate the tenth element of the
Fibonacci sequence. To declare which Fibonacci value you want to calculate, use
the ``--n-value`` option. Additionally you can use the :option:`--hpx:threads`
option to declare how many OS-threads you wish to use when running the program.
For instance, running:

.. code-block:: shell-session

   $ ./bin/fibonacci --n-value 20 --hpx:threads 4

Will yield:

.. code-block:: text

   fibonacci(20) == 6765
   elapsed time: 0.062854 [s]

Walkthrough
===========

Now that you have compiled and run the code, let's look at how the code works.
Since this code is written in C++, we will begin with the ``main()`` function.
Here you can see that in |hpx|, ``main()`` is only used to initialize the
runtime system. It is important to note that application-specific command line
options are defined here. |hpx| uses |boost_program_options|_ for command line
processing. You can see that our programs ``--n-value`` option is set by calling
the ``add_options()`` method on an instance of
``hpx::program_options::options_description``. The default value of the
variable is set to 10. This is why when we ran the program for the first time
without using the ``--n-value`` option the program returned the 10th value of
the Fibonacci sequence. The constructor argument of the description is the text
that appears when a user uses the :option:`--hpx:help` option to see what
command line options are available. ``HPX_APPLICATION_STRING`` is a macro that
expands to a string constant containing the name of the |hpx| application
currently being compiled.

In |hpx| ``main()`` is used to initialize the runtime system and pass the
command line arguments to the program. If you wish to add command line options
to your program you would add them here using the instance of the Boost class
``options_description``, and invoking the public member function
``.add_options()`` (see |boost_doc|_ for more details). :cpp:func:`hpx::init`
calls ``hpx_main()`` after setting up |hpx|, which is where the logic of our
program is encoded.

.. literalinclude:: ../../examples/quickstart/fibonacci_local.cpp
   :start-after: //[main
   :end-before: //main]

The :cpp:func:`hpx::init` function in ``main()`` starts the runtime system, and
invokes ``hpx_main()`` as the first |hpx|-thread. Below we can see that the
basic program is simple. The command line option ``--n-value`` is read in, a
timer (:cpp:class:`hpx::chrono::high_resolution_timer`) is set up to record the
time it takes to do the computation, the ``fibonacci`` function is invoked
synchronously, and the answer is printed out.

.. literalinclude:: ../../examples/quickstart/fibonacci_local.cpp
   :start-after: //[hpx_main
   :end-before: //hpx_main]

The ``fibonacci`` function itself is synchronous as the work done inside is
asynchronous. To understand what is happening we have to look inside the
``fibonacci`` function:

.. literalinclude:: ../../examples/quickstart/fibonacci_local.cpp
   :start-after: //[fibonacci
   :end-before: //fibonacci]

This block of code looks similar to regular C++ code. First, ``if (n < 2)``,
meaning n is 0 or 1, then we return 0 or 1 (recall the first element of the
Fibonacci sequence is 0 and the second is 1). If n is larger than 1 we spawn two
new tasks whose results are contained in ``n1`` and ``n2``. This is done using
:cpp:func:`hpx::async` which takes as arguments a function (function pointer,
object or lambda) and the arguments to the function. Instead of returning a
``std::uint64_t`` like ``fibonacci`` does, ``hpx::async`` returns a future of a
``std::uint64_t``, i.e. ``hpx::future<std::uint64_t>``. Each of these futures
represents an asynchronous, recursive call to ``fibonacci``. After we've created
the futures, we wait for both of them to finish computing, we add them together,
and return that value as our result. We get the values from the futures using
the ``get`` method. The recursive call tree will continue until n is equal to 0
or 1, at which point the value can be returned because it is implicitly known.
When this termination condition is reached, the futures can then be added up,
producing the n-th value of the Fibonacci sequence.

Note that calling ``get`` potentially blocks the calling |hpx|-thread, and lets
other |hpx|-threads run in the meantime. There are, however, more efficient ways
of doing this. ``examples/quickstart/fibonacci_futures.cpp`` contains many more
variations of locally computing the Fibonacci numbers, where each method makes
different tradeoffs in where asynchrony and parallelism is applied. To get
started, however, the method above is sufficient and optimizations can be
applied once you are more familiar with |hpx|. The example
:ref:`examples_interest_calculator` presents dataflow, which is a way to more
efficiently chain together multiple tasks.
..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_hello_world:

=============================
Remote execution with actions
=============================

This program will print out a hello world message on every OS-thread on every
:term:`locality`. The output will look something like this:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 1 on locality 1
   hello world from OS-thread 0 on locality 0
   hello world from OS-thread 0 on locality 1

Setup
=====

The source code for this example can be found here:
:download:`hello_world_distributed.cpp
<../../examples/quickstart/hello_world_distributed.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.quickstart.hello_world_distributed

To run the program type:

.. code-block:: shell-session

   $ ./bin/hello_world_distributed

This should print:

.. code-block:: text

   hello world from OS-thread 0 on locality 0

To use more OS-threads use the command line option :option:`--hpx:threads` and
type the number of threads that you wish to use. For example, typing:

.. code-block:: shell-session

   $ ./bin/hello_world_distributed --hpx:threads 2

will yield:

.. code-block:: text

   hello world from OS-thread 1 on locality 0
   hello world from OS-thread 0 on locality 0

Notice how the ordering of the two print statements will change with
subsequent runs. To run this program on multiple localities please see the
section :ref:`unix_pbs`.

Walkthrough
===========

Now that you have compiled and run the code, let's look at how the code works,
beginning with ``main()``:

.. literalinclude:: ../../examples/quickstart/hello_world_distributed.cpp
   :language: c++
   :start-after: //[hello_world_hpx_main
   :end-before: //]

In this excerpt of the code we again see the use of futures. This time the
futures are stored in a vector so that they can easily be accessed.
:cpp:func:`hpx::wait_all` is a family of functions that wait on for an
``std::vector<>`` of futures to become ready. In this piece of code, we are
using the synchronous version of :cpp:func:`hpx::wait_all()`, which takes one
argument (the ``std::vector<>`` of futures to wait on). This function will not
return until all the futures in the vector have been executed.

In :ref:`examples_fibonacci` we used :cpp:func:`hpx::find_here()` to specify the
target of our actions. Here, we instead use
:cpp:func:`hpx::find_all_localities()`, which returns an ``std::vector<>``
containing the identifiers of all the machines in the system, including the one
that we are on.

As in :ref:`examples_fibonacci` our futures are set using
:cpp:func:`hpx::async\<>()`. The ``hello_world_foreman_action`` is declared
here:

.. literalinclude:: ../../examples/quickstart/hello_world_distributed.cpp
   :language: c++
   :start-after: //[hello_world_action_wrapper
   :end-before: //]

Another way of thinking about this wrapping technique is as follows: functions
(the work to be done) are wrapped in actions, and actions can be executed
locally or remotely (e.g. on another machine participating in the computation).

Now it is time to look at the ``hello_world_foreman()`` function which was
wrapped in the action above:

.. literalinclude:: ../../examples/quickstart/hello_world_distributed.cpp
   :language: c++
   :start-after: //[hello_world_foreman
   :end-before: //]

Now, before we discuss ``hello_world_foreman()``, let's talk about the
:cpp:func:`hpx::wait_each()` function.
The version of :cpp:func:`hpx::wait_each` invokes a callback function
provided by the user, supplying the callback function with the result of the
future.

In ``hello_world_foreman()``, an ``std::set<>`` called ``attendance`` keeps
track of which OS-threads have printed out the hello world message. When the
OS-thread prints out the statement, the future is marked as ready, and
:cpp:func:`hpx::wait_each` in ``hello_world_foreman()``. If it is not
executing on the correct OS-thread, it returns a value of -1, which causes
``hello_world_foreman()`` to leave the OS-thread id in ``attendance``.

.. literalinclude:: ../../examples/quickstart/hello_world_distributed.cpp
   :language: c++
   :start-after: //[hello_world_worker
   :end-before: //]

Because |hpx| features work stealing task schedulers, there is no way to
guarantee that an action will be scheduled on a particular OS-thread. This is
why we must use a guess-and-check approach.
..
    Copyright (C) 2021 Dimitra Karatza

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_matrix_multiplication:

===================
Parallel algorithms
===================

This program will perform a matrix multiplication in parallel. The output will look something like this:

.. code-block:: text

   Matrix A is : 
   4 9 6 
   1 9 8 

   Matrix B is : 
   4 9 
   6 1 
   9 8 

   Resultant Matrix is : 
   124 93 
   111 127 

Setup
=====

The source code for this example can be found here:
:download:`matrix_multiplication.cpp
<../../examples/quickstart/matrix_multiplication.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.quickstart.matrix_multiplication

To run the program type:

.. code-block:: shell-session

   $ ./bin/matrix_multiplication

or:

.. code-block:: shell-session

   $ ./bin/matrix_multiplication --n 2 --m 3 --k 2 --s 100 --l 0 --u 10 

where the first matrix is `n` x `m` and the second `m` x `k`, s is the seed for creating the random values of 
the matrices and the range of these values is [l,u] 

This should print:

.. code-block:: text

   Matrix A is : 
   4 9 6 
   1 9 8 

   Matrix B is : 
   4 9 
   6 1 
   9 8 
   
   Resultant Matrix is : 
   124 93 
   111 127 

Notice that the numbers may be different because of the random initialization of the matrices.

Walkthrough
===========

Now that you have compiled and run the code, let's look at how the code works.

First, ``main()`` is used to initialize the runtime system and pass the command line arguments to the program. 
``hpx::init`` calls ``hpx_main()`` after setting up HPX, which is where our program is implemented.

.. literalinclude:: ../../examples/quickstart/matrix_multiplication.cpp
   :language: c++
   :start-after: //[mul_main
   :end-before: //]

Proceeding to the ``hpx_main()`` function, we can see that matrix multiplication can be done very easily. 

.. literalinclude:: ../../examples/quickstart/matrix_multiplication.cpp
   :language: c++
   :start-after: //[mul_hpx_main
   :end-before: //]

First, the dimensions of the matrices are defined. If they were not given as command-line arguments, their default 
values are `2` x `3` for the first matrix and `3` x `2` for the second. We use standard vectors to define the matrices 
to be multiplied as well as the resultant matrix. 

To give some random initial values to our matrices, we use `std::uniform_int_distribution
<https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution>`_. Then, ``std::bind()`` is used
along with ``hpx::ranges::generate()`` to yield two matrices A and B, which contain values in the range of [0, 10] or in
the range defined by the user at the command-line arguments. The seed to generate the values can also be defined by the user.

The next step is to perform the matrix multiplication in parallel. This can be done by just using an :cpp:func:`\hpx::for_loop` 
combined with a parallel execution policy ``hpx::execution::par`` as the outer loop of the multiplication. Note that the execution 
of :cpp:func:`\hpx::for_loop` without specifying an execution policy is equivalent to specifying ``hpx::execution::seq`` 
as the execution policy.

Finally, the matrices A, B that are multiplied as well as the resultant matrix R are printed using the following function.

.. literalinclude:: ../../examples/quickstart/matrix_multiplication.cpp
   :language: c++
   :start-after: //[mul_print_matrix
   :end-before: //]
..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _examples_fibonacci:

===================================
Asynchronous execution with actions
===================================

This example extends the :ref:`previous example <examples_fibonacci_local>` by
introducing :term:`actions<action>`: functions that can be run remotely. In this
example, however, we will still only run the action locally. The mechanism to
execute :term:`actions<action>` stays the same: :cpp:func:`hpx::async`. Later
examples will demonstrate running actions on remote :term:`localities<locality>`
(e.g. :ref:`examples_hello_world`).

Setup
=====

The source code for this example can be found here:
:download:`fibonacci.cpp <../../examples/quickstart/fibonacci.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`hpx_build_system` for information on configuring and building |hpx|) and
enter:

.. code-block:: shell-session

   $ make examples.quickstart.fibonacci

To run the program type:

.. code-block:: shell-session

   $ ./bin/fibonacci

This should print (time should be approximate):

.. code-block:: text

    fibonacci(10) == 55
    elapsed time: 0.00186288 [s]

This run used the default settings, which calculate the tenth element of the
Fibonacci sequence. To declare which Fibonacci value you want to calculate, use
the ``--n-value`` option. Additionally you can use the :option:`--hpx:threads`
option to declare how many OS-threads you wish to use when running the program.
For instance, running:

.. code-block:: shell-session

   $ ./bin/fibonacci --n-value 20 --hpx:threads 4

Will yield:

.. code-block:: text

   fibonacci(20) == 6765
   elapsed time: 0.233827 [s]

Walkthrough
===========

The code needed to initialize the |hpx| runtime is the same as in the
:ref:`previous example <examples_fibonacci_local>`:

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :language: c++
   :start-after: //[fib_main
   :end-before: //]


The :cpp:func:`hpx::init` function in ``main()`` starts the runtime system, and
invokes ``hpx_main()`` as the first |hpx|-thread. The command line option
``--n-value`` is read in, a timer
(:cpp:class:`hpx::chrono::high_resolution_timer`) is set up to record the time it
takes to do the computation, the ``fibonacci`` :term:`action` is invoked
synchronously, and the answer is printed out.

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :language: c++
   :start-after: //[fib_hpx_main
   :end-before: //]

Upon a closer look we see that we've created a ``std::uint64_t`` to store the
result of invoking our ``fibonacci_action`` ``fib``. This :term:`action` will
launch synchronously (as the work done inside of the :term:`action` will be
asynchronous itself) and return the result of the Fibonacci sequence. But wait,
what is an :term:`action`? And what is this ``fibonacci_action``? For starters,
an :term:`action` is a wrapper for a function. By wrapping functions, |hpx| can
send packets of work to different processing units. These vehicles allow users
to calculate work now, later, or on certain nodes. The first argument to our
:term:`action` is the location where the :term:`action` should be run. In this
case, we just want to run the :term:`action` on the machine that we are
currently on, so we use :cpp:func:`hpx::find_here`. To
further understand this we turn to the code to find where ``fibonacci_action``
was defined:

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :language: c++
   :start-after: //[fib_action
   :end-before: //]

A plain :term:`action` is the most basic form of :term:`action`. Plain
:term:`action`\ s wrap simple global functions which are not associated with any
particular object (we will discuss other types of :term:`action`\ s in
:ref:`examples_accumulator`). In this block of code the function ``fibonacci()``
is declared. After the declaration, the function is wrapped in an :term:`action`
in the declaration :c:macro:`HPX_PLAIN_ACTION`. This function takes two
arguments: the name of the function that is to be wrapped and the name of the
:term:`action` that you are creating.

This picture should now start making sense. The function ``fibonacci()`` is
wrapped in an :term:`action` ``fibonacci_action``, which was run synchronously
but created asynchronous work, then returns a ``std::uint64_t`` representing the
result of the function ``fibonacci()``. Now, let's look at the function
``fibonacci()``:

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :language: c++
   :start-after: //[fib_func
   :end-before: //]

This block of code is much more straightforward and should look familiar from
the :ref:`previous example <examples_fibonacci_local>`. First, ``if (n < 2)``,
meaning n is 0 or 1, then we return 0 or 1 (recall the first element of the
Fibonacci sequence is 0 and the second is 1). If n is larger than 1 we spawn two
tasks using :cpp:func:`hpx::async`. Each of these futures represents an
asynchronous, recursive call to ``fibonacci``. As previously we wait for both
futures to finish computing, get the results, add them together, and return that
value as our result. The recursive call tree will continue until n is equal to 0
or 1, at which point the value can be returned because it is implicitly known.
When this termination condition is reached, the futures can then be added up,
producing the n-th value of the Fibonacci sequence.
..
    Copyright (C) 2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _libs_unmodularized:

Main |hpx| library
==================

This lists functionality in the main |hpx| library that has not been moved to
modules yet.

.. doxygenindex::
..
    Copyright (C) 2020 ETH Zurich

    SPDX-License-Identifier: BSL-1.0
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _public_api:

==========
Public API
==========

Our API is semantically conforming; hence, the reader is highly encouraged to refer to the 
corresponding facility in the `C++ Standard <https://en.cppreference.com/w/cpp/header>`_ if 
needed. All names below are also available in the top-level ``hpx`` namespace unless
otherwise noted. The names in ``hpx`` should be preferred. The names in
sub-namespaces will eventually be removed.

Header ``hpx/algorithm.hpp``
============================

This header includes :ref:`public_api_header_hpx_local_algorithm` and contains
overloads of the algorithms for segmented iterators. For more information you can refer to the 
`C++ Standard algorithms library <https://en.cppreference.com/w/cpp/algorithm>`_. 

.. _public_api_header_hpx_local_algorithm:

Header ``hpx/local/algorithm.hpp``
==================================

Corresponds to the C++ standard library header :cppreference-header:`algorithm`.
See :ref:`parallel_algorithms` for more information about the parallel
algorithms.

Classes
-------

- :cpp:class:`hpx::parallel::v2::reduction`
- :cpp:class:`hpx::parallel::v2::induction`

Functions
---------

- :cpp:func:`hpx::adjacent_find`
- :cpp:func:`hpx::all_of`
- :cpp:func:`hpx::any_of`
- :cpp:func:`hpx::copy`
- :cpp:func:`hpx::copy_if`
- :cpp:func:`hpx::copy_n`
- :cpp:func:`hpx::count`
- :cpp:func:`hpx::count_if`
- :cpp:func:`hpx::ends_with`
- :cpp:func:`hpx::equal`
- :cpp:func:`hpx::fill`
- :cpp:func:`hpx::fill_n`
- :cpp:func:`hpx::find`
- :cpp:func:`hpx::find_end`
- :cpp:func:`hpx::find_first_of`
- :cpp:func:`hpx::find_if`
- :cpp:func:`hpx::find_if_not`
- :cpp:func:`hpx::for_each`
- :cpp:func:`hpx::for_each_n`
- :cpp:func:`hpx::generate`
- :cpp:func:`hpx::generate_n`
- :cpp:func:`hpx::includes`
- :cpp:func:`hpx::inplace_merge`
- :cpp:func:`hpx::is_heap`
- :cpp:func:`hpx::is_heap_until`
- :cpp:func:`hpx::is_partitioned`
- :cpp:func:`hpx::is_sorted`
- :cpp:func:`hpx::is_sorted_until`
- :cpp:func:`hpx::lexicographical_compare`
- :cpp:func:`hpx::make_heap`
- :cpp:func:`hpx::max_element`
- :cpp:func:`hpx::merge`
- :cpp:func:`hpx::min_element`
- :cpp:func:`hpx::minmax_element`
- :cpp:func:`hpx::mismatch`
- :cpp:func:`hpx::move`
- :cpp:func:`hpx::none_of`
- :cpp:func:`hpx::nth_element`
- :cpp:func:`hpx::partial_sort`
- :cpp:func:`hpx::partial_sort_copy`
- :cpp:func:`hpx::partition`
- :cpp:func:`hpx::partition_copy`
- :cpp:func:`hpx::remove`
- :cpp:func:`hpx::remove_copy`
- :cpp:func:`hpx::remove_copy_if`
- :cpp:func:`hpx::remove_if`
- :cpp:func:`hpx::replace`
- :cpp:func:`hpx::replace_copy`
- :cpp:func:`hpx::replace_copy_if`
- :cpp:func:`hpx::replace_if`
- :cpp:func:`hpx::reverse`
- :cpp:func:`hpx::reverse_copy`
- :cpp:func:`hpx::rotate`
- :cpp:func:`hpx::rotate_copy`
- :cpp:func:`hpx::search`
- :cpp:func:`hpx::search_n`
- :cpp:func:`hpx::set_difference`
- :cpp:func:`hpx::set_intersection`
- :cpp:func:`hpx::set_symmetric_difference`
- :cpp:func:`hpx::set_union`
- :cpp:func:`hpx::shift_left`
- :cpp:func:`hpx::shift_right`
- :cpp:func:`hpx::sort`
- :cpp:func:`hpx::stable_partition`
- :cpp:func:`hpx::stable_sort`
- :cpp:func:`hpx::starts_with`
- :cpp:func:`hpx::swap_ranges`
- :cpp:func:`hpx::transform`
- :cpp:func:`hpx::unique`
- :cpp:func:`hpx::unique_copy`
- :cpp:func:`hpx::for_loop`
- :cpp:func:`hpx::for_loop_strided`
- :cpp:func:`hpx::for_loop_n`
- :cpp:func:`hpx::for_loop_n_strided`

- :cpp:func:`hpx::ranges::adjacent_find`
- :cpp:func:`hpx::ranges::all_of`
- :cpp:func:`hpx::ranges::any_of`
- :cpp:func:`hpx::ranges::copy`
- :cpp:func:`hpx::ranges::copy_if`
- :cpp:func:`hpx::ranges::copy_n`
- :cpp:func:`hpx::ranges::count`
- :cpp:func:`hpx::ranges::count_if`
- :cpp:func:`hpx::ranges::ends_with`
- :cpp:func:`hpx::ranges::equal`
- :cpp:func:`hpx::ranges::fill`
- :cpp:func:`hpx::ranges::fill_n`
- :cpp:func:`hpx::ranges::find`
- :cpp:func:`hpx::ranges::find_end`
- :cpp:func:`hpx::ranges::find_first_of`
- :cpp:func:`hpx::ranges::find_if`
- :cpp:func:`hpx::ranges::find_if_not`
- :cpp:func:`hpx::ranges::for_each`
- :cpp:func:`hpx::ranges::for_each_n`
- :cpp:func:`hpx::ranges::generate`
- :cpp:func:`hpx::ranges::generate_n`
- :cpp:func:`hpx::ranges::includes`
- :cpp:func:`hpx::ranges::inplace_merge`
- :cpp:func:`hpx::ranges::is_heap`
- :cpp:func:`hpx::ranges::is_heap_until`
- :cpp:func:`hpx::ranges::is_partitioned`
- :cpp:func:`hpx::ranges::is_sorted`
- :cpp:func:`hpx::ranges::is_sorted_until`
- :cpp:func:`hpx::ranges::make_heap`
- :cpp:func:`hpx::ranges::merge`
- :cpp:func:`hpx::ranges::move`
- :cpp:func:`hpx::ranges::none_of`
- :cpp:func:`hpx::ranges::nth_element`
- :cpp:func:`hpx::ranges::partial_sort`
- :cpp:func:`hpx::ranges::partial_sort_copy`
- :cpp:func:`hpx::ranges::partition`
- :cpp:func:`hpx::ranges::partition_copy`
- :cpp:func:`hpx::ranges::set_difference`
- :cpp:func:`hpx::ranges::set_intersection`
- :cpp:func:`hpx::ranges::set_symmetric_difference`
- :cpp:func:`hpx::ranges::set_union`
- :cpp:func:`hpx::ranges::shift_left`
- :cpp:func:`hpx::ranges::shift_right`
- :cpp:func:`hpx::ranges::sort`
- :cpp:func:`hpx::ranges::stable_partition`
- :cpp:func:`hpx::ranges::stable_sort`
- :cpp:func:`hpx::ranges::starts_with`
- :cpp:func:`hpx::ranges::swap_ranges`
- :cpp:func:`hpx::ranges::unique`
- :cpp:func:`hpx::ranges::unique_copy`
- :cpp:func:`hpx::ranges::for_loop`
- :cpp:func:`hpx::ranges::for_loop_strided`

Header ``hpx/any.hpp``
======================

This header includes :ref:`public_api_header_hpx_local_any`.

.. _public_api_header_hpx_local_any:

Header ``hpx/local/any.hpp``
============================

Corresponds to the C++ standard library header :cppreference-header:`any`.
:cpp:type:`hpx::any` is compatible with ``std::any``.

Classes
-------

- :cpp:type:`hpx::any`
- :cpp:type:`hpx::any_nonser`
- :cpp:type:`hpx::bad_any_cast`
- :cpp:type:`hpx::unique_any_nonser`

Functions
---------

- :cpp:func:`hpx::any_cast`
- :cpp:func:`hpx::make_any`
- :cpp:func:`hpx::make_any_nonser`
- :cpp:func:`hpx::make_unique_any_nonser`

Header ``hpx/assert.hpp``
=========================

Corresponds to the C++ standard library header :cppreference-header:`cassert`.
:c:macro:`HPX_ASSERT` is the |hpx| equivalent to ``assert`` in ``cassert``.
:c:macro:`HPX_ASSERT` can also be used in CUDA device code.

Macros
------

- :c:macro:`HPX_ASSERT`
- :c:macro:`HPX_ASSERT_MSG`

Header ``hpx/barrier.hpp``
==========================

This header includes :ref:`public_api_header_hpx_local_barrier` and contains a
distributed barrier implementation. This functionality is also exposed through
the ``hpx::distributed`` namespace. The name in ``hpx::distributed`` should be
preferred.

Classes
-------

- :cpp:class:`hpx::lcos::barrier`

.. _public_api_header_hpx_local_barrier:

Header ``hpx/local/barrier.hpp``
================================

Corresponds to the C++ standard library header :cppreference-header:`barrier`.

Classes
-------

- :cpp:class:`hpx::lcos::local::cpp20_barrier`

Header ``hpx/channel.hpp``
==========================

This header includes :ref:`public_api_header_hpx_local_channel` and contains a
distributed channel implementation. This functionality is also exposed through
the ``hpx::distributed`` namespace. The name in ``hpx::distributed`` should be
preferred.

Classes
-------

- :cpp:class:`hpx::lcos::channel`

.. _public_api_header_hpx_local_channel:

Header ``hpx/local/channel.hpp``
================================

Contains a local channel implementation.

Classes
-------

- :cpp:class:`hpx::lcos::local::channel`

Header ``hpx/chrono.hpp``
=========================

This header includes :ref:`public_api_header_hpx_local_chrono`.

.. _public_api_header_hpx_local_chrono:

Header ``hpx/local/chrono.hpp``
===============================

Corresponds to the C++ standard library header :cppreference-header:`chrono`.
The following replacements and extensions are provided compared to
:cppreference-header:`chrono`. The classes below are also available in the
``hpx::chrono`` namespace, not in the top-level ``hpx`` namespace.

Classes
-------

- :cpp:class:`hpx::chrono::high_resolution_clock`
- :cpp:class:`hpx::chrono::high_resolution_timer`
- :cpp:class:`hpx::chrono::steady_time_point`

Header ``hpx/condition_variable.hpp``
=====================================

This header includes :ref:`public_api_header_hpx_local_condition_variable`.

.. _public_api_header_hpx_local_condition_variable:

Header ``hpx/local/condition_variable.hpp``
===========================================

Corresponds to the C++ standard library header
:cppreference-header:`condition_variable`.

Classes
-------

- :cpp:class:`hpx::lcos::local::condition_variable`
- :cpp:class:`hpx::lcos::local::condition_variable_any`
- :cpp:class:`hpx::lcos::local::cv_status`

Header ``hpx/exception.hpp``
============================

This header includes :ref:`public_api_header_hpx_local_exception`.

.. _public_api_header_hpx_local_exception:

Header ``hpx/local/exception.hpp``
==================================

Corresponds to the C++ standard library header :cppreference-header:`exception`.
:cpp:class:`hpx::exception` extends ``std::exception`` and is the base class for
all exceptions thrown in |hpx|. :c:macro:`HPX_THROW_EXCEPTION` can be used to
throw |hpx| exceptions with file and line information attached to the exception.

Macros
------

- :c:macro:`HPX_THROW_EXCEPTION`

Classes
-------

- :cpp:class:`hpx::exception`

Header ``hpx/execution.hpp``
============================

This header includes :ref:`public_api_header_hpx_local_execution`.

.. _public_api_header_hpx_local_execution:

Header ``hpx/local/execution.hpp``
==================================

Corresponds to the C++ standard library header :cppreference-header:`execution`.
See :ref:`parallel`, :ref:`parallel_algorithms` and :ref:`executor_parameters`
for more information about execution policies and executor parameters.

.. note::

   These names are only available in the ``hpx::execution`` namespace, not in
   the top-level ``hpx`` namespace.

Constants
---------

- :cpp:var:`hpx::execution::seq`
- :cpp:var:`hpx::execution::par`
- :cpp:var:`hpx::execution::par_unseq`
- :cpp:var:`hpx::execution::task`

Classes
-------

- :cpp:class:`hpx::execution::sequenced_policy`
- :cpp:class:`hpx::execution::parallel_policy`
- :cpp:class:`hpx::execution::parallel_unsequenced_policy`
- :cpp:class:`hpx::execution::sequenced_task_policy`
- :cpp:class:`hpx::execution::parallel_task_policy`
- :cpp:class:`hpx::execution::auto_chunk_size`
- :cpp:class:`hpx::execution::dynamic_chunk_size`
- :cpp:class:`hpx::execution::guided_chunk_size`
- :cpp:class:`hpx::execution::persistent_auto_chunk_size`
- :cpp:class:`hpx::execution::static_chunk_size`

Header ``hpx/functional.hpp``
=============================

This header includes :ref:`public_api_header_hpx_local_functional`.

.. _public_api_header_hpx_local_functional:

Header ``hpx/local/functional.hpp``
===================================

Corresponds to the C++ standard library header
:cppreference-header:`functional`. :cpp:class:`hpx::util::function` is a more
efficient and serializable replacement for ``std::function``.

Constants
---------

The following constants are also available in ``hpx::placeholders``, not the
top-level ``hpx`` namespace.

- :cpp:var:`hpx::util::placeholders::_1`
- :cpp:var:`hpx::util::placeholders::_2`
- ...
- :cpp:var:`hpx::util::placeholders::_9`

Classes
-------

- :cpp:class:`hpx::util::function`
- :cpp:class:`hpx::util::function_nonser`
- :cpp:class:`hpx::util::function_ref`
- :cpp:class:`hpx::util::unique_function`
- :cpp:class:`hpx::util::unique_function_nonser`
- :cpp:struct:`hpx::traits::is_bind_expression`
- :cpp:struct:`hpx::traits::is_placeholder`
- :cpp:struct:`hpx::scoped_annotation`

Functions
---------

- :cpp:func:`hpx::annotated_function`
- :cpp:func:`hpx::util::bind`
- :cpp:func:`hpx::util::bind_back`
- :cpp:func:`hpx::util::bind_front`
- :cpp:func:`hpx::util::invoke`
- :cpp:func:`hpx::util::invoke_fused`
- :cpp:func:`hpx::util::mem_fn`

Header ``hpx/future.hpp``
=========================

This header includes :ref:`public_api_header_hpx_local_future` and contains
overloads of :cpp:func:`hpx::async`, :cpp:func:`hpx::apply`,
:cpp:func:`hpx::sync`, and :cpp:func:`hpx::dataflow` that can be used with
actions. See :ref:`action_invocation` for more information about invoking
actions.

.. note::

   The alias from ``hpx::promise`` to :cpp:class:`hpx::lcos::promise` is
   deprecated and will be removed in a future release. The alias
   ``hpx::distributed::promise`` should be used in new applications.

Classes
-------

- :cpp:class:`hpx::lcos::promise`

Functions
---------

- :cpp:func:`hpx::async`
- :cpp:func:`hpx::apply`
- :cpp:func:`hpx::sync`
- :cpp:func:`hpx::dataflow`

.. _public_api_header_hpx_local_future:

Header ``hpx/local/future.hpp``
===============================

Corresponds to the C++ standard library header :cppreference-header:`future`.
See :ref:`extend_futures` for more information about extensions to futures
compared to the C++ standard library.

.. note::

   All names except :cpp:class:`hpx::lcos::local::promise` are also available in
   the top-level ``hpx`` namespace. ``hpx::promise`` refers to
   :cpp:class:`hpx::lcos::promise`, a distributed variant of
   :cpp:class:`hpx::lcos::local::promise`, but will eventually refer to
   :cpp:class:`hpx::lcos::local::promise` after a deprecation period.

Classes
-------

- :cpp:class:`hpx::future`
- :cpp:class:`hpx::shared_future`
- :cpp:class:`hpx::lcos::local::promise`
- :cpp:class:`hpx::launch`

Functions
---------

- :cpp:func:`hpx::make_future`
- :cpp:func:`hpx::make_shared_future`
- :cpp:func:`hpx::make_ready_future`
- :cpp:func:`hpx::make_ready_future_alloc`
- :cpp:func:`hpx::make_ready_future_at`
- :cpp:func:`hpx::make_ready_future_after`
- :cpp:func:`hpx::make_exceptional_future`
- :cpp:func:`hpx::async`
- :cpp:func:`hpx::apply`
- :cpp:func:`hpx::sync`
- :cpp:func:`hpx::dataflow`
- :cpp:func:`hpx::when_all`
- :cpp:func:`hpx::when_any`
- :cpp:func:`hpx::when_some`
- :cpp:func:`hpx::when_each`
- :cpp:func:`hpx::wait_all`
- :cpp:func:`hpx::wait_any`
- :cpp:func:`hpx::wait_some`
- :cpp:func:`hpx::wait_each`

Examples
--------

.. literalinclude:: ../../libs/full/include/tests/unit/api_future.cpp
   :language: c++
   :lines: 7-

Header ``hpx/init.hpp``
=======================

This header contains functionality for starting, stopping, suspending, and
resuming the |hpx| runtime. This is the main way to explicitly start the |hpx|
runtime. See :ref:`starting_hpx` for more details on starting the |hpx| runtime.

Classes
-------

- :cpp:class:`hpx::init_params`
- :cpp:enum:`hpx::runtime_mode`

Functions
---------

- :cpp:func:`hpx::init`
- :cpp:func:`hpx::start`
- :cpp:func:`hpx::finalize`
- :cpp:func:`hpx::disconnect`
- :cpp:func:`hpx::suspend`
- :cpp:func:`hpx::resume`

Header ``hpx/latch.hpp``
========================

This header includes :ref:`public_api_header_hpx_local_latch` and contains a
distributed latch implementation. This functionality is also exposed through the
``hpx::distributed`` namespace. The name in ``hpx::distributed`` should be
preferred.

Classes
-------

- :cpp:class:`hpx::lcos::latch`

.. _public_api_header_hpx_local_latch:

Header ``hpx/local/latch.hpp``
==============================

Corresponds to the C++ standard library header :cppreference-header:`latch`.

Classes
-------

- :cpp:class:`hpx::lcos::local::cpp20_latch`

Header ``hpx/mutex.hpp``
========================

This header includes :ref:`public_api_header_hpx_local_mutex`.

.. _public_api_header_hpx_local_mutex:

Header ``hpx/local/mutex.hpp``
==============================

Corresponds to the C++ standard library header :cppreference-header:`mutex`.

Classes
-------

- :cpp:class:`hpx::lcos::local::mutex`
- :cpp:class:`hpx::lcos::local::no_mutex`
- :cpp:class:`hpx::lcos::local::once_flag`
- :cpp:class:`hpx::lcos::local::recursive_mutex`
- :cpp:class:`hpx::lcos::local::spinlock`
- :cpp:class:`hpx::lcos::local::timed_mutex`
- :cpp:class:`hpx::lcos::local::unlock_guard`

Functions
---------

- :cpp:func:`hpx::lcos::local::call_once`

Header ``hpx/memory.hpp``
=========================

This header includes :ref:`public_api_header_hpx_local_memory`.

.. _public_api_header_hpx_local_memory:

Header ``hpx/local/memory.hpp``
===============================

Corresponds to the C++ standard library header :cppreference-header:`memory`. It
contains parallel versions of the copy, fill, move, and construct helper
functions in :cppreference-header:`memory`. See :ref:`parallel_algorithms` for
more information about the parallel algorithms.

Functions
---------

- :cpp:func:`hpx::uninitialized_copy`
- :cpp:func:`hpx::uninitialized_copy_n`
- :cpp:func:`hpx::uninitialized_default_construct`
- :cpp:func:`hpx::uninitialized_default_construct_n`
- :cpp:func:`hpx::uninitialized_fill`
- :cpp:func:`hpx::uninitialized_fill_n`
- :cpp:func:`hpx::uninitialized_move`
- :cpp:func:`hpx::uninitialized_move_n`
- :cpp:func:`hpx::uninitialized_value_construct`
- :cpp:func:`hpx::uninitialized_value_construct_n`

- :cpp:func:`hpx::ranges::uninitialized_copy`
- :cpp:func:`hpx::ranges::uninitialized_copy_n`
- :cpp:func:`hpx::ranges::uninitialized_default_construct`
- :cpp:func:`hpx::ranges::uninitialized_default_construct_n`
- :cpp:func:`hpx::ranges::uninitialized_fill`
- :cpp:func:`hpx::ranges::uninitialized_fill_n`
- :cpp:func:`hpx::ranges::uninitialized_move`
- :cpp:func:`hpx::ranges::uninitialized_move_n`
- :cpp:func:`hpx::ranges::uninitialized_value_construct`
- :cpp:func:`hpx::ranges::uninitialized_value_construct_n`

Header ``hpx/numeric.hpp``
==========================

This header includes :ref:`public_api_header_hpx_local_numeric`.

.. _public_api_header_hpx_local_numeric:

Header ``hpx/local/numeric.hpp``
================================

Corresponds to the C++ standard library header :cppreference-header:`numeric`.
See :ref:`parallel_algorithms` for more information about the parallel
algorithms.

Functions
---------

- :cpp:func:`hpx::adjacent_difference`
- :cpp:func:`hpx::exclusive_scan`
- :cpp:func:`hpx::inclusive_scan`
- :cpp:func:`hpx::reduce`
- :cpp:func:`hpx::transform_exclusive_scan`
- :cpp:func:`hpx::transform_inclusive_scan`
- :cpp:func:`hpx::transform_reduce`

- :cpp:func:`hpx::ranges::exclusive_scan`
- :cpp:func:`hpx::ranges::inclusive_scan`
- :cpp:func:`hpx::ranges::transform_exclusive_scan`
- :cpp:func:`hpx::ranges::transform_inclusive_scan`

Header ``hpx/optional.hpp``
===========================

This header includes :ref:`public_api_header_hpx_local_optional`.

.. _public_api_header_hpx_local_optional:

Header ``hpx/local/optional.hpp``
=================================

Corresponds to the C++ standard library header :cppreference-header:`optional`.
:cpp:type:`hpx::util::optional` is compatible with ``std::optional``.

Constants
---------

- :cpp:var:`hpx::util::nullopt`

Classes
-------

- :cpp:class:`hpx::util::optional`
- :cpp:class:`hpx::util::nullopt_t`
- :cpp:class:`hpx::util::bad_optional_access`

Functions
---------

- :cpp:func:`hpx::util::make_optional`

Header ``hpx/runtime.hpp``
==========================

This header includes :ref:`public_api_header_hpx_local_runtime` and contains
functions for accessing distributed runtime information.

Functions
---------

- :cpp:func:`hpx::find_root_locality`
- :cpp:func:`hpx::find_all_localities`
- :cpp:func:`hpx::find_remote_localities`
- :cpp:func:`hpx::find_locality`
- :cpp:func:`hpx::get_colocation_id`
- :cpp:func:`hpx::get_locality_id`

.. _public_api_header_hpx_local_runtime:

Header ``hpx/local/runtime.hpp``
================================

This header contains functions for accessing local runtime information.

Typedefs
--------

- :cpp:type:`hpx::startup_function_type`
- :cpp:type:`hpx::shutdown_function_type`

Functions
---------

- :cpp:func:`hpx::get_num_worker_threads`
- :cpp:func:`hpx::get_worker_thread_num`
- :cpp:func:`hpx::get_thread_name`
- :cpp:func:`hpx::register_pre_startup_function`
- :cpp:func:`hpx::register_startup_function`
- :cpp:func:`hpx::register_pre_shutdown_function`
- :cpp:func:`hpx::register_shutdown_function`
- :cpp:func:`hpx::get_num_localities`
- :cpp:func:`hpx::get_locality_name`

Header ``hpx/system_error.hpp``
===============================

This header includes :ref:`public_api_header_hpx_local_system_error`.

.. _public_api_header_hpx_local_system_error:

Header ``hpx/local/system_error.hpp``
=====================================

Corresponds to the C++ standard library header
:cppreference-header:`system_error`.

Classes
-------

- :cpp:class:`hpx::error_code`

Header ``hpx/task_block.hpp``
=============================

This header includes :ref:`public_api_header_hpx_local_task_block`.

.. _public_api_header_hpx_local_task_block:

Header ``hpx/local/task_black.hpp``
===================================

Corresponds to the ``task_block`` feature in |cpp11_n4088|_. See
:ref:`using_task_block` for more details on using task blocks.

Classes
-------

- :cpp:class:`hpx::parallel::v2::task_canceled_exception`
- :cpp:class:`hpx::parallel::v2::task_block`

Functions
---------

- :cpp:func:`hpx::parallel::v2::define_task_block`
- :cpp:func:`hpx::parallel::v2::define_task_block_restore_thread`

Header ``hpx/thread.hpp``
=========================

This header includes :ref:`public_api_header_hpx_local_thread`.

.. _public_api_header_hpx_local_thread:

Header ``hpx/local/thread.hpp``
===============================

Corresponds to the C++ standard library header :cppreference-header:`thread`.
The functionality in this header is equivalent to the standard library thread
functionality, with the exception that the |hpx| equivalents are implemented on
top of lightweight threads and the |hpx| runtime.

Classes
-------

- :cpp:class:`hpx::thread`
- :cpp:class:`hpx::jthread`

Functions
---------

- :cpp:func:`hpx::this_thread::yield`
- :cpp:func:`hpx::this_thread::get_id`
- :cpp:func:`hpx::this_thread::sleep_for`
- :cpp:func:`hpx::this_thread::sleep_until`

Header ``hpx/semaphore.hpp``
============================

This header includes :ref:`public_api_header_hpx_local_semaphore`.

.. _public_api_header_hpx_local_semaphore:

Header ``hpx/local/semaphore.hpp``
==================================

Corresponds to the C++ standard library header
:cppreference-header:`semaphore`.

Classes
-------

- :cpp:class:`hpx::lcos::local::cpp20_binary_semaphore`
- :cpp:class:`hpx::lcos::local::cpp20_counting_semaphore`

Header ``hpx/shared_mutex.hpp``
===============================

This header includes :ref:`public_api_header_hpx_local_shared_mutex`.

.. _public_api_header_hpx_local_shared_mutex:

Header ``hpx/local/shared_mutex.hpp``
=====================================

Corresponds to the C++ standard library header
:cppreference-header:`shared_mutex`.

Classes
-------

- :cpp:class:`hpx::lcos::local::shared_mutex`

Header ``hpx/stop_token.hpp``
=============================

This header includes :ref:`public_api_header_hpx_local_stop_token`.

.. _public_api_header_hpx_local_stop_token:

Header ``hpx/local/stop_token.hpp``
===================================

Corresponds to the C++ standard library header
:cppreference-header:`stop_token`.

Constants
---------

- :cpp:var:`hpx::nostopstate`

Classes
-------

- :cpp:class:`hpx::stop_callback`
- :cpp:class:`hpx::stop_source`
- :cpp:class:`hpx::stop_token`
- :cpp:struct:`hpx::nostopstate_t`

Header ``hpx/tuple.hpp``
========================

This header includes :ref:`public_api_header_hpx_local_tuple`.

.. _public_api_header_hpx_local_tuple:

Header ``hpx/local/tuple.hpp``
==============================

Corresponds to the C++ standard library header :cppreference-header:`tuple`.
:cpp:class:`hpx::tuple` can be used in CUDA device code, unlike ``std::tuple``.

Constants
---------

- :cpp:var:`hpx::ignore`

Classes
-------

- :cpp:struct:`hpx::tuple`
- :cpp:struct:`hpx::tuple_size`
- :cpp:struct:`hpx::tuple_element`

Functions
---------

- :cpp:func:`hpx::make_tuple`
- :cpp:func:`hpx::tie`
- :cpp:func:`hpx::forward_as_tuple`
- :cpp:func:`hpx::tuple_cat`
- :cpp:func:`hpx::get`

Header ``hpx/type_traits.hpp``
==============================

This header includes :ref:`public_api_header_hpx_local_type_traits`.

.. _public_api_header_hpx_local_type_traits:

Header ``hpx/local/type_traits.hpp``
====================================

Corresponds to the C++ standard library header
:cppreference-header:`type_traits`.

Classes
-------

- :cpp:struct:`hpx::is_invocable`
- :cpp:struct:`hpx::is_invocable_r`

Header ``hpx/unwrap.hpp``
=========================

This header includes :ref:`public_api_header_hpx_local_unwrap`.

.. _public_api_header_hpx_local_unwrap:

Header ``hpx/local/unwrap.hpp``
===============================

Contains utilities for unwrapping futures.

Classes
-------

- :cpp:struct:`hpx::functional::unwrap`
- :cpp:struct:`hpx::functional::unwrap_n`
- :cpp:struct:`hpx::functional::unwrap_all`

Functions
---------

- :cpp:func:`hpx::unwrap`
- :cpp:func:`hpx::unwrap_n`
- :cpp:func:`hpx::unwrap_all`
- :cpp:func:`hpx::unwrapping`
- :cpp:func:`hpx::unwrapping_n`
- :cpp:func:`hpx::unwrapping_all`

Header ``hpx/version.hpp``
==========================

This header provides version information about |hpx|.

Macros
------

- :c:macro:`HPX_VERSION_MAJOR`
- :c:macro:`HPX_VERSION_MINOR`
- :c:macro:`HPX_VERSION_SUBMINOR`
- :c:macro:`HPX_VERSION_FULL`
- :c:macro:`HPX_VERSION_DATE`
- :c:macro:`HPX_VERSION_TAG`
- :c:macro:`HPX_AGAS_VERSION`

Functions
---------

- :cpp:func:`hpx::major_version`
- :cpp:func:`hpx::minor_version`
- :cpp:func:`hpx::subminor_version`
- :cpp:func:`hpx::full_version`
- :cpp:func:`hpx::full_version_as_string`
- :cpp:func:`hpx::tag`
- :cpp:func:`hpx::agas_version`
- :cpp:func:`hpx::build_type`
- :cpp:func:`hpx::build_date_time`

Header ``hpx/wrap_main.hpp``
============================

This header does not provide any direct functionality but is used for implicitly
using ``main`` as the runtime entry point. See :ref:`minimal` for more details
on implicitly starting the |hpx| runtime.
