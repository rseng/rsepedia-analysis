# <img src="https://github.com/psi4/psi4media/blob/master/logos-psi4/psi4square.png" height=150>

| **Status** | [![Azure DevOps builds](https://img.shields.io/azure-devops/build/psi4/e80489d7-9619-4512-8e7b-255e355b3ab8/1?logo=azure%20devops)](https://dev.azure.com/psi4/psi4/_build?definitionId=1) [![Codecov coverage](https://img.shields.io/codecov/c/github/psi4/psi4.svg?logo=Codecov&logoColor=white)](https://codecov.io/gh/psi4/psi4) [![LGTM analysis](https://img.shields.io/lgtm/grade/python/g/psi4/psi4.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/psi4/psi4/context:python) [![LGTM analysis](https://img.shields.io/lgtm/grade/cpp/g/psi4/psi4.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/psi4/psi4/context:cpp) |
| :------ | :------- |
| **Latest Release** | [![Last release tag](https://img.shields.io/github/release/psi4/psi4.svg)](https://github.com/psi4/psi4/releases)  [![Commits since release](https://img.shields.io/github/commits-since/psi4/psi4/v1.5.svg)](https://github.com/psi4/psi4/releases/tag/v1.5) [![python](https://img.shields.io/badge/python-3.6%2C%203.7%2C%203.8%2C%203.9-blue.svg)](https://psicode.org/psi4manual/master/introduction.html#supported-systems) |
| **Communication** | [![User site](https://img.shields.io/badge/home-Psi4-5077AB.svg)](https://psicode.org/) [![docs latest](https://img.shields.io/badge/docs-latest-5077AB.svg?logo=read%20the%20docs)](https://psicode.org/psi4manual/master/index.html) [![chat on forum](https://img.shields.io/badge/chat-on_forum-808493.svg?logo=Discourse&logoColor=white)](http://forum.psicode.org/) [![dev chat on slack](https://img.shields.io/badge/dev_chat-on_slack-808493.svg?logo=slack)](https://join.slack.com/t/psi4/shared_invite/zt-5s36s4rb-SQH6_AWyfWOqlKYN3cFs4Q) |
| **Foundation** | [![license](https://img.shields.io/github/license/psi4/psi4.svg)](https://opensource.org/licenses/LGPL-3.0) [![platforms](https://img.shields.io/badge/Platforms-Linux%2C%20MacOS%2C%20Windows%2C%20Windows%20WSL-orange.svg)](https://psicode.org/psi4manual/master/introduction.html#supported-systems) [![python](https://img.shields.io/badge/python-3.8%2C%203.9%2C%203.10-blue.svg)](https://psicode.org/psi4manual/master/introduction.html#supported-systems) |
| **Installation** | [![obtain latest](https://img.shields.io/badge/obtain-latest-green.svg)](https://psicode.netlify.com/installs/latest) [![Conda](https://img.shields.io/conda/v/psi4/psi4.svg)](https://anaconda.org/psi4/psi4) [![Anaconda-Server Badge](https://anaconda.org/psi4/psi4/badges/latest_release_relative_date.svg)](https://anaconda.org/psi4/psi4) |
| **Demo** | [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/psi4/psi4/master?filepath=doc%2Fsphinxman%2Fsource%2Fpsiapi.ipynb) |

<!--  -->
<!-- [![Last release date](https://img.shields.io/github/release-date/psi4/psi4.svg)](https://github.com/psi4/psi4/releases) -->
<!-- [![Anaconda-Server Badge](https://anaconda.org/psi4/psi4/badges/version.svg)](https://anaconda.org/psi4/psi4) -->

<!--<a href="https://psi4.slack.com/messages"> <img src="https://img.shields.io/badge/dev_chat-on_slack-808493.svg" /></a>
<a href="mailto:psi4aiqc+slackinvite@gmail.com?subject=request slack invite (incl. who, where, email)"> <img src="https://img.shields.io/badge/dev_chat-invite-808493.svg" /></a> -->

<!--[![Anaconda-Server Badge](https://anaconda.org/psi4/psi4/badges/installer/conda.svg)](https://anaconda.org/psi4/psi4) 
[![Anaconda-Server Badge](https://anaconda.org/psi4/psi4/badges/platforms.svg)](https://anaconda.org/psi4/psi4) -->

<!--
| **PR Activity** | 
[![commit activity](https://img.shields.io/github/commit-activity/y/psi4/psi4.svg)](https://github.com/psi4/psi4/graphs/contributors) 
[![issues-pr-closed](https://img.shields.io/github/issues-pr-closed-raw/psi4/psi4.svg)](https://github.com/psi4/psi4/pulls)
-->

Psi4 is an open-source suite of *ab initio* quantum chemistry programs
designed for efficient, high-accuracy simulations of
molecular properties. We routinely perform computations with >2500 basis functions on multi-core machines.

With computationally demanding portions written in C++, exports
of many C++ classes into Python via Pybind11, and a flexible Python driver, Psi4
strives to be friendly to both users and developers.

* **Users' Website**  www.psicode.org

* **Downloading and Installing Psi4** https://psicode.org/psi4manual/master/build_faq.html (for the CMake adept, see [CMakeLists.txt](CMakeLists.txt)

* **Manual**  [http://bit.ly/psi4manual](https://psicode.org/psi4manual/master/index.html) (built nightly from master branch) or https://psicode.org/psi4manual/1.4.0/index.html (last release)

* **Tutorial** https://psicode.org/psi4manual/master/tutorial.html for Psithon (``psi4 job.in``), https://psicode.org/psi4manual/master/psiapi.html for PsiAPI (``python job.py``)

* **Forum** http://forum.psicode.org

* **Communication & Support** https://psicode.org/psi4manual/master/introduction.html#technical-support

* **GitHub**  https://github.com/psi4/psi4 (authoritative repository)

* **Continuous Integration Status** [![Azure DevOps builds](https://img.shields.io/azure-devops/build/psi4/e80489d7-9619-4512-8e7b-255e355b3ab8/1/master.svg?logo=azure%20devops)](https://dev.azure.com/psi4/psi4/_build?definitionId=1) on Linux and Windows

* **Anaconda**  https://anaconda.org/psi4 (binary available for Linux, Mac, Windows, and WSL Windows [![Binstar Badge](https://anaconda.org/psi4/psi4/badges/downloads.svg)](https://anaconda.org/psi4/psi4) ) [instructions](https://psicode.org/psi4manual/master/conda.html#how-to-install-a-psi4-binary-with-the-psi4conda-installer-download-site)

* **Coverage** Python and C++ source code lines hit by running most of the test suite. [![codecov](https://img.shields.io/codecov/c/github/psi4/psi4.svg?logo=Codecov&logoColor=white)](https://codecov.io/gh/psi4/psi4)

* **Interested Developers**  https://psicode.org/developers.php (replacement page needed) (welcome to fork psi4/psi4 and follow [GitHub contribution procedure](https://psicode.org/psi4manual/master/build_obtaining.html#faq-githubworkflow)) [![PRs welcome](https://img.shields.io/badge/PRs-welcome-yellow.svg)](http://makeapullrequest.com)

* **Sample Inputs**  http://www.psicode.org/psi4manual/master/testsuite.html (also in [`samples/`](samples))

* **Download Tarball** https://github.com/psi4/psi4/releases 

<!--* **Build Dashboard** https://testboard.org/cdash/index.php?project=Psi

* **YouTube Channel** https://www.youtube.com/psitutorials-->


License [![license](https://img.shields.io/github/license/psi4/psi4.svg)](https://opensource.org/licenses/LGPL-3.0)
=======

Psi4: an open-source quantum chemistry software package

Copyright (c) 2007-2022 The Psi4 Developers.

The copyrights for code used from other parties are included in
the corresponding files.

Psi4 is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, version 3.

Psi4 is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with Psi4; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

The full text of the GNU Lesser General Public License (version 3) is included in the
COPYING.LESSER file of this repository, and can also be found
[here](https://www.gnu.org/licenses/lgpl.txt).


Citation [![doi](https://img.shields.io/badge/doi-10.1063/5.0006002-5077AB.svg)](https://doi.org/10.1063/5.0006002)
========

The journal article reference describing Psi4 is:

D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish,
M. C. Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio,
A. Alenaizan, A. M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer,
R. A. Shaw, J. B. Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni,
J. S. O'Brien, J. M. Waldrop, A. Kumar, E. G. Hohenstein,
B. P. Pritchard, B. R. Brooks, H. F. Schaefer III, A. Yu. Sokolov,
K. Patkowski, A. E. DePrince III, U. Bozkaya, R. A. King,
F. A. Evangelista, J. M. Turney, T. D. Crawford, C. D. Sherrill,
"Psi4 1.4: Open-Source Software for High-Throughput Quantum Chemistry",
J. Chem. Phys. 152(18) 184108 (2020).

* [![doi](https://img.shields.io/badge/doi-10.1021/acs.jctc.7b00174-5077AB.svg)](https://doi.org/10.1021/acs.jctc.7b00174) for Psi4 v1.1
* [![doi](https://img.shields.io/badge/doi-10.1021/acs.jctc.8b00286-5077AB.svg)](https://doi.org/10.1021/acs.jctc.8b00286) for Psi4NumPy
* [![doi](https://img.shields.io/badge/doi-10.1002/wcms.93-5077AB.svg)](https://doi.org/10.1002/wcms.93) for Psi4 alpha releases
* [![doi](https://img.shields.io/badge/doi-10.1002/jcc.20573-5077AB.svg)](https://doi.org/10.1002/jcc.20573) for Psi3
[LAB 10-19-2016]

* Majority of logos detached from main Psi4 repo into https://github.com/psi4/psi4media .

[LAB 9-29-2016]

* See doc/sphinxman/source/psi4doc/themes/psi4doc/theme.conf
  for Psi4 colors and customary icon linking.

[LAB 2-18-2015]

* Text "SI" in "PSI4" changed to 82% size of "P" & "4"; 54 pt for banner
  files. This should avoid the "Public School 14" issue, while not looking
  so lopsided as genuine small-caps font.

[LAB 11-18-2014]

* Text "Ab Initio" changed to "Open-Source"

[LAB 4-20-2012]

* Text "PSI4" is Optima Regular at 66 pt in CMYK = [100, 95, 0, 0]

* Text "Ab Initio Quantum Chemistry" is Optima Bold at 16 pt
  in CMYK = [0, 0, 0, 100] with 100 (AI units) spacing stretch

* The difference between "vector" and other files in this directory is in
  the trimming of self-interference at the tips of the psi graphic. This
  process turns the psi into a raster object, so the color and 3D effects
  are no longer editable.

* All transparencies are set such that these can be placed over any color
  background.

## Description
<!-- Provide a brief description of the PR's purpose here. -->

## Todos
<!-- Notable points (developer or user-interest) that this PR has or will accomplish. -->
- [ ] Feature1
- [ ] Feature2

## Questions
- [ ] Question1

## Checklist
- [ ] Tests added for any new features
- [ ] [All or relevant fraction of full tests run](http://psicode.org/psi4manual/master/build_planning.html#how-to-run-a-subset-of-tests)

## Status
- [ ] Ready for review
- [ ] Ready for merge
The Psi4 package is distributed for free and without any
guarantee of reliability, accuracy, or suitability for any
particular purpose. No obligation to provide technical support is
expressed or implied. As time allows, the developers will attempt
to answer inquiries on the [forum](http://forum.psicode.org>) or
[GitHub](https://github.com/psi4/psi4/issues/new). For bug reports,
specific and detailed information, with example inputs and `psi4
--version`, would be appreciated.

#### Where-to-post summary

* How do I? -- [ask the forum](http://forum.psicode.org)

* I got this error, why? -- [ask the forum](http://forum.psicode.org)

* I got this error and I'm sure it's a bug -- [file a GitHub issue](https://github.com/psi4/psi4/issues/new)

* Can I open a discussion on this bit of code? -- [file a GitHub issue](https://github.com/psi4/psi4/issues/new)

* I have an idea/request and a plan -- [file a GitHub issue](https://github.com/psi4/psi4/issues/new)

* I have an idea/request -- [ask the forum](http://forum.psicode.org)

* Why do you? -- [ask the forum](http://forum.psicode.org)

* When will you? -- [ask the forum](http://forum.psicode.org)

* I have an experience that can improve the documentation -- [inform the forum](http://forum.psicode.org) or [edit the docs via the little pencil](http://psicode.org/psi4manual/master/index.html) or [add to the documentation itself](doc/sphinxman/source)

* Anything you want to share privately -- psi4aiqc+help at gmail.com

# How to contribute

We welcome contributions from external contributors, and this document
describes how to merge code changes into Psi4.  As of February 2016, the
procedure for contributing code is exactly the same for the core development
team and for external contributors.

**Working on your first Pull Request?** You can learn how from
this *free* series [How to Contribute to an Open Source Project on
GitHub](https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github)

## Getting Started

* Make sure you have a [GitHub account](https://github.com/signup/free).
* [Fork](https://help.github.com/articles/fork-a-repo/) the
  [psi4/psi4](https://github.com/psi4/psi4) repository on GitHub.
* On your local machine,
  [clone](https://help.github.com/articles/cloning-a-repository/) your fork of
  the Psi4 repository.
* More detailed instructions for interacting with your Psi4 fork can be found
  [here](http://psicode.org/psi4manual/master/build_obtaining.html#faq-forkpsi4public).
  and [here](http://psicode.org/psi4manual/master/build_obtaining.html#faq-githubworkflow).

## Making Changes

* Add some really awesome code to your local fork.  It's usually a [good
  idea](http://blog.jasonmeridth.com/posts/do-not-issue-pull-requests-from-your-master-branch/)
  to make changes on a
  [branch](https://help.github.com/articles/creating-and-deleting-branches-within-your-repository/)
  with the branch name relating to the feature you are going to add.
* When you are ready for others to examine and comment on your new feature,
  navigate to your fork of Psi4 on GitHub and open a [pull
  request](https://help.github.com/articles/using-pull-requests/) (PR). Note that
  after you launch a PR from one of your fork's branches, all
  subsequent commits to that branch will be added to the open pull request
  automatically.  Each commit added to the PR will be validated for
  mergability, compilation and test suite compliance; the results of these tests
  will be visible on the PR page.
* If you're providing a new feature, you must add test cases and documentation.
* When the code is ready to go, make sure you run the full or relevant portion of the
  [test suite](http://psicode.org/psi4manual/master/build_planning.html#faq-subsettests)
  on your local machine to check that nothing is broken.
* When you're ready to be considered for merging, check the "Ready to go"
  box on the PR page to let the Psi4 team know that the changes are complete.
  The code will not be merged until this box is checked, the continuous
  integration (Travis for Linux and Distelli for Mac) returns checkmarks,
  and multiple core developers give "Approved" reviews.

# Additional Resources

* [General GitHub documentation](https://help.github.com/)
* [PR best practices](http://codeinthehole.com/writing/pull-requests-and-other-good-practices-for-teams-using-github/)
* [A guide to contributing to software packages](http://www.contribution-guide.org)
* [Thinkful PR example](http://www.thinkful.com/learn/github-pull-request-tutorial/#Time-to-Submit-Your-First-PR)

# GHA for Psi4

## [docs.yml](./docs.yml)

* Since: April 2021
* Runs on: push to master
* Goals:
  * get CI warning if doxygen docs compile broken
  * get CI warning if sphinx docs compile broken, or compile with warnings. (Future, after flag can be enabled: ", or compile with unreachable links, or can't compile nit-picky")
  * publish nightly-build docs promptly and automatically
  * get CI warning if psi4 compile broken with conda-forge environment (as opposed to the usual defaults-based environment)
* Results:
  * automated commit of built HTML docs to psi4/psi4docs:master, which in turn is served up by netlify to https://psi4manual.netlify.app/, which in turn is [redirected by psicode](https://github.com/psi4/psicode-hugo-website/blob/master/netlify.toml) into https://psicode.org/psi4manual/master/index.html

----

## [ecosystem.yml](./ecosystem.yml)

* Since: March 2022
* Runs on: PR, push to master
* Goals:
  * get CI warning if PR breaks addons hosted by psi4 channel or by conda-forge chanel
  * show CI model of how to build Psi4 on Linux, macOS, and Windows platforms, including tweaks to the build environment, and emphasizing the minor differences between platforms
  * show how to run with the maximal ecosystem (less proprietary addons, gpu addons, and addons I haven't packaged), as the environment can be tricky
  * show what addon packages to get from what channel, especially during shift from defaults-based to conda-forge-based
* Results:
  * None
Here lie files that were once worthy documentation, but now their contents
or their code has become out-of-date. Also here are files whose content
only needs a once-over for validity but whose format needs conversion
from LaTeX, HTML, manpage, etc. to reStructuredText.


.. include:: /autodoc_abbr_options_c.rst
.. include:: /autodoc_abbr_options_plugins.rst

Theory, Usage, and Notes
------------------------

.. codeauthor:: Psi4 Developer
.. sectionauthor:: Psi4 Developer

Casual documentation for this plugin goes here.
Uncomment the ``.. comment`` for some examples.

.. comment * this plugin solves :math:`H=F_A+W_A+F_B+W_B+V`
.. comment * reference to keyword |globals__docc| and |myplugin1__print|
.. comment * returns :psivar:`CURRENT ENERGY <CURRENTENERGY>` in |kcalpermol|
.. comment * operation depends on :envvar:`OMP_NUM_THREADS`.
.. comment * operation requires external software described in :ref:`sec:interfacing`
.. comment 
.. comment .. caution:: Some features are not yet implemented.
.. comment 
.. comment    - Do not run plugin more than ten feet away from developer.
.. comment 
.. comment    - Do not run plugin on benzene dimer.


.. include:: /autodoc_abbr_options_c.rst
.. include:: /autodoc_abbr_options_plugins.rst

Theory, Usage, and Notes
------------------------

.. codeauthor:: Psi4 Developer
.. sectionauthor:: Psi4 Developer

Casual documentation for this plugin goes here.
Uncomment the ``.. comment`` for some examples.

.. comment * this plugin solves :math:`H=F_A+W_A+F_B+W_B+V`
.. comment * reference to keyword |globals__docc| and |myplugin1__print|
.. comment * returns :psivar:`CURRENT ENERGY <CURRENTENERGY>` in |kcalpermol|
.. comment * operation depends on :envvar:`OMP_NUM_THREADS`.
.. comment * operation requires external software described in :ref:`sec:interfacing`
.. comment 
.. comment .. caution:: Some features are not yet implemented.
.. comment 
.. comment    - Do not run plugin more than ten feet away from developer.
.. comment 
.. comment    - Do not run plugin on benzene dimer.



Where does CMake search math libraries if you specify --blas/lapack=auto?
-------------------------------------------------------------------------

CMake will look in the environment variable MATH_ROOT.

For instance my .bashrc contains::

  source /opt/intel/bin/compilervars.sh intel64
  export MATH_ROOT=/opt/intel/mkl


Order of math libraries
-----------------------

Order is set by MATH_LIB_SEARCH_ORDER in MathLibs.cmake.
You can override this order by setting BLAS_TYPE and/or LAPACK_TYPE
for example to ATLAS or some other library that you prefer.


What to edit if your math library is not found although you have set MATH_ROOT?
-------------------------------------------------------------------------------

Normally you only need to edit MathLibs.cmake to add new libraries
or edit existing ones.

Since a vendor can provide libraries with different "fingerprints"
(example MKL), you can define different combinations (up to 9), for instance::

  set(MKL_BLAS_LIBS  ...)
  set(MKL_BLAS_LIBS2 ...)
  set(MKL_BLAS_LIBS3 ...)
  set(MKL_BLAS_LIBS4 ...)
  set(MKL_BLAS_LIBS5 ...)

Then CMake will first try MKL_BLAS_LIBS, then MKL_BLAS_LIBS2, etc.
The first pattern that will match will be linked against.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:conda`:

Conda Binary Distribution
=========================

.. warning:: As of v1.2rc1, new (conda build 3; updated compilers)
   conda packages are available for Linux but not Mac).
   Psi4conda installers are not ready for either platform.

|PSIfour| is available as a pre-compiled binary for Mac and Linux (and
Windows, through the Ubuntu shell) and native Windows architectures
through `Anaconda (formerly Continuum Analytics
<https://www.anaconda.com/products/individual>`_, the company that produces
`Anaconda Python <http://docs.continuum.io/anaconda/index.html>`_ (a
full-fledged scientific python environment with package manager `conda
<https://conda.io/projects/conda/en/latest/user-guide/getting-started.html>`_) and, more particularly, `Miniconda
<https://docs.conda.io/en/latest/miniconda.html>`_ (a lightweight Python
distribution with same package manager `conda
<https://conda.io/projects/conda/en/latest/user-guide/getting-started.html>`_). Some nice features for us:

* cross-platform

* no root, administrator, or sudo access required

* built with high-performance math libraries

* lightweight software stack (<100 MB w/o |PSIfour|; ~1 GB including |PSIfour|, numpy, and MKL)

* updated nightly so new features accessible

* standardizes python distribution so no need to find/install libpython packages

* add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages

* develop |PSIfour| through plugins without a pre-existing development environment, see :ref:`sec:condaplugins`.

The |PSIfour| binary repository is at `Anaconda (formerly Binstar) <https://anaconda.org/psi4>`_.

For commands to get a default installation, go to :ref:`sec:psi4conda`
or the :psicode:`psicode downloads page <installs/latest/>` .
Users proficient with conda may prefer to consult :ref:`sec:condadetails`.
For more flexibility and a detailed explanation, go to
:ref:`sec:slowconda` and :ref:`sec:slowpsi4`.


.. _`faq:psicodedownload`:

How to install a Psi4 binary with the Psi4conda installer, download site
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Download one of the nine installers
<http://psicode.org/downloads.html>`_ (Linux/Mac/Windows; Py36/37/38/39).
``bash`` it. Follow the prompts and *do* make the adjustments to
:envvar:`PATH` and :envvar:`PSI_SCRATCH` that it suggests at the end. Test
with ``psi4 --test`` (green and yellow good; red bad). Done. Explicit commands at :ref:`sec:psi4conda`.


.. _`sec:psi4conda`:

How to install a Psi4 binary with the Psi4conda installer, command-line
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sequence of commands to get you to a working |PSIfour| on Linux,
Mac, Windows (Ubuntu shell for Windows accepts Linux installers), or native Windows.
Installs Miniconda+Psi4+AddOns into ``$HOME/psi4conda`` and
the |PSIfour| executable into the main conda environment at
``$HOME/psi4conda/bin/psi4``.

.. code-block:: bash

    # Linux or WSL (Windows Subsystem for Linux)
    # py36|py37|py38|py39 for alternate python versions
    >>> curl "http://vergil.chemistry.gatech.edu/psicode-download/Psi4conda-1.4rc1-py38-Linux-x86_64.sh" -o Psi4conda-latest-py38-Linux-x86_64.sh --keepalive-time 2
    >>> bash Psi4conda-latest-py38-Linux-x86_64.sh -b -p $HOME/psi4conda  # agrees to license terms
    >>> (bash) echo $'. $HOME/psi4conda/etc/profile.d/conda.sh\nconda activate' >> ~/.bashrc
    >>> (tcsh) echo "source $HOME/psi4conda/etc/profile.d/conda.csh\nconda activate" >> ~/.tcshrc
    # log out, log back in so conda and psi4 in path
    >>> psi4 --test

.. code-block:: bash

    # Mac
    # py36|py37|py38|py39 for alternate python versions
    >>> curl -O "http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-MacOSX-x86_64.sh" --keepalive-time 2
    >>> curl "http://vergil.chemistry.gatech.edu/psicode-download/Psi4conda-1.4rc1-py38-MacOSX-x86_64.sh" -o Psi4conda-latest-py38-MacOSX-x86_64.sh --keepalive-time 2
    >>> bash Psi4conda-latest-py38-MacOSX-x86_64.sh -b -p $HOME/psi4conda  # agrees to license terms
    >>> (bash) echo $'. $HOME/psi4conda/etc/profile.d/conda.sh\nconda activate' >> ~/.bash_profile
    >>> (tcsh) echo "source $HOME/psi4conda/etc/profile.d/conda.csh\nconda activate" >> ~/.tcshrc
    # log out, log back in so conda and psi4 in path
    >>> psi4 --test

.. code-block:: bash

    # Windows
    # py38 only python version
    # download via button at https://psicode.netlify.app/installs/latest with "Windows", "Installer", and "Stable Release" selected
    >>> # install via GUI by double-clicking downloaded `.exe` file analogous to https://conda.io/projects/conda/en/latest/user-guide/install/windows.html
    >>> # -OR- install via following line
    >>>  start /wait "" Psi4conda-1.4rc1-py38-Windows-x86_64.exe /InstallationType=JustMe /RegisterPython=0 /S /D=%UserProfile%\psi4conda
    >>>  psi4 --test

That last command tested that ``psi4`` is in your path, and it's finding
all the libraries it needs. It works because :envvar:`PSI_SCRATCH`
defaults to ``/tmp``. Now you need only specify a permanent scratch
directory (see :ref:`sec:Scratch`) by replacing the placeholder in the
following:

.. code-block:: bash

    >>> echo "export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files" >> ~/.bashrc
    # log out, log back in so variable takes effect

All done!

Configuration for this set-up is summarized at :ref:`faq:runfrombinary`.

.. note:: |PSIfour| installs a Python distribution alongside, so you should choose an installer based on the Python version you *want*, irrespective of any Python version you *have*.


.. _`faq:psi4pkg`:

How to install a Psi4 binary into an Ana/Miniconda distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Conda command to install the latest nightly build of |PSIfour| + compiled
add-ons + runtime add-ons into an existing Anaconda or Miniconda
distribution.

.. code-block:: bash

    # Linux or Mac or Windows
    # substitute x.x by 3.6|3.7|3.8|3.9 for alternate python versions
    # remove `-c psi4/label/dev` to get stable releases instead of nightly builds
    >>> conda create -n p4env python=x.x psi4 -c psi4/label/dev

Activate environment and make the adjustments to :envvar:`PATH` and
:envvar:`PSI_SCRATCH` that it suggests at the end. Test with ``psi4
--test``. Configuration for this set-up is summarized at
:ref:`faq:runfrombinary`.

**Details:**

* It is advised to place |PSIfour| into a conda
  environment where its libraries can't interfere with other programs
  rather than the main
  Anaconda or Miniconda environment. Hence the creation of the environment
  above, but the environment name (:samp:`{p4env}` above) can be
  substituted.

* The ``psi4-rt`` package can be added to the package list to get the
  QC runtime add-ons; could say any combination of ``v2rdm_casscf snsmp2
  openfermion-psi4 adcc cppe`` etc. instead of ``psi4-rt``.

* Grab a Miniconda through one of the below, selecting OS.

  >>> curl -O "https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-x86_64.sh"
  >>> curl -O "https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-MacOSX-x86_64.sh"
  >>> curl -O "https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Windows-x86_64.exe"


.. _`faq:updatepsi4`:

How to update a Psi4 binary
^^^^^^^^^^^^^^^^^^^^^^^^^^^

A. Conda command to update an existing |PSIfour| conda installation to the
newest stable release (roughly annually). It's often a better idea to create
a new environment rather than updating the old one.

.. code-block:: bash

    >>> # Linux/MacOS
    >>> conda update psi4 -c psi4
    >>> # Windows
    >>> conda update psi4 -c psi4 -c conda-forge

    # if psi4 channel in defaults (true for Psi4conda installers)
    >>> conda update psi4

B. Conda command to update an existing |PSIfour| conda installation to the
latest development head (roughly nightly).

.. code-block:: bash

    >>> # Linux/MacOS
    >>> conda update psi4 -c psi4/label/dev
    >>> # Windows
    >>> conda update psi4 -c psi4/label/dev -c conda-forge

C. Conda command to install a very specific package, including version,
build string, and subchannel. The final `-c psi4` represents any
additional channels or subchannels needed to locate all dependencies.

.. code-block:: bash

    >>> conda install psi4=1.2a1.dev249+623ad64=py36_sse41_0 -c psi4/label/subchannel -c psi4


.. _`faq:psi4deps`:

How to use conda to compile Psi4 faster and easier
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: console

    # Linux # c. v1.2rc1  ###or Mac or Windows
    # substitute x.x by 3.5|3.6|3.7 for alternate python versions
    >>> conda create -n p4dev python=x.x psi4-dev -c psi4/label/dev -c psi4
    >>> conda activate p4dev

    >>> cd {top-level-psi4-dir}
    >>> psi4-path-advisor --help
    usage: psi4-path-advisor [-h] [--psi4-compile] [--disable-addons]
                             [--disable-mkl] [--intel | --intel-multiarch | --gcc]
    
    Build and Run path advisor for Psi4
    
    optional arguments:
      -h, --help         show this help message and exit
      --psi4-compile     (Command Default) Generates a minimal CMake command for building Psi4 against
                             this psi4-dev conda metapackage.
                         >>> git clone https://github.com/psi4/psi4.git
                         >>> cd {top-level-psi4-dir}
                         >>> conda create -n p4dev python={3.6} psi4-dev [-c psi4/label/dev] -c psi4
                         >>> conda activate p4dev
                         >>> psi4-path-advisor
                         # execute or adapt `cmake` commands above; DepsCache handles python & addons;
                         #   DepsMKLCache handles math; further psi4-path-advisor options handle compilers.
                         >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`
                         >>> make install
      --disable-addons   Disengage building against the psi4-dev-provided _optional_ link-time Add-Ons like CheMPS2.
      --disable-mkl      Disengage building against the psi4-dev-provided MKL libraries (`libmkl_rt`).
      --intel            Engage self-provided icc/icpc/ifort compilers backed by conda's psi4-dev-provided gcc/g++.
      --intel-multiarch  Engage self-provided icc/icpc/ifort compilers backed by conda's psi4-dev-provided gcc/g++ PLUS compile for multiple architectures (useful for cluster deployments).
      --gcc              Engage conda's psi4-dev-provided gcc/g++/gfortran compilers.

    # execute or adapt `cmake` commands above; DepsCache handles python & addons;
    #   DepsMKLCache handles math; further psi4-path-advisor options handle compilers.
    >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON
    >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`
    >>> make install

Same for Linux/Mac/WSL. Substitute desired python version: 3.6, 3.7, 3.8, 3.9. Fine
to choose your own env name. Include ``-c psi4/label/dev`` to get dependencies to
build current master, as opposed to latest release.
Activate environment, ``conda activate
p4dev``.  Go to where you've cloned psi4. Execute ``psi4-path-advisor``.
It gives you a basic cmake command covering python, sphinx, link-time qc
addons, and run-time qc addons. There's a help menu -h that gives more
info. There's other options that will also pre-configure compilers. For
example, at GaTech ``psi4-path-advisor --intel`` works. On Macs with
XCode, ``psi4-path-advisor --clang`` works. Just read the help. For users
who want a minimal build, there's a ``--disable-addons``, but it is generally not
encouraged. It gives you a fully
functional cmake command, but those are just setting up CMake cache
|w---w| like the plugins you can always add your own CMake variables to
the command.

For run-time, you may also wish to install the optional runtime add-ons (*e.g.*, adcc)

.. code-block:: bash

    >>> conda install psi4-rt


.. _`sec:condadetails`:

What do the conda packages psi4 & psi4-dev and the installer psi4conda contain
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``psi4`` - has full-featured psi4 itself and necessarily all the link-time qc
addons (e.g., chemps2). It has python, pytest, numpy, and a few more python
modules for specialized functions. Of gcc-ness, it has minimal, run-time
libraries (*e.g.*, libgcc-ng) not compilers.
It doesn't have the run-time qc addons ``psi4-rt`` (*e.g.*, snsmp2) or build tools (*e.g.*, g++, sphinx, cmake).

``psi4-dev`` - does not have psi4 itself or the run-time addons ``psi4-rt`` or numpy (though fine to install them
alongside). Does have all the link-time addons. Does have
cmake and sphinx (and python). Of gcc-ness, has full packages, that is,
compilers as well as runtime packages.

Psi4conda installer - has full-featured ``psi4`` itself, all link-time qc addons, all
run-time qc addons, and minimal gcc runtime libraries. Developers should additionally install ``psi4-dev`` for build tools.

The :ref:`sec:psi4conda` uses a `conda constructor
<https://github.com/conda/constructor>`_ to package up Miniconda,
the |PSIfour| conda package, the |PSIfour| add-on conda packages, dependencies
thereof (possibly from particular channels), and the psi4 channel
as a default. This is very convenient for novice users and robust
against differing channel settings in ``~/.condarc``. But proficient
conda users may prefer to treat ``psi4`` as a normal conda package and
not have another large Miniconda installation (including the hefty MKL)
lying around just for |PSIfour|. Installing just the ``psi4`` package
itself will get you |PSIfour|, whatever add-ons require linking in to
|PSIfour| (*e.g.*, CheMPS2 and PCMSolver), and the correct versions of
packages. However, just the ``psi4`` package won't get you add-ons that
don't need linking (*e.g.*, adcc and v2rdm_casscf).

.. Conda Proficients
.. ^^^^^^^^^^^^^^^^^
..
.. or dependencies
.. from the "right" channels, which can be important for issues of fPIC
.. and libc++ vs. libstdc++. So ``conda create -c psi4 -n p4env psi4 dftd3
.. v2rdm_casscf`` *should* be equivalent to running the psi4conda installer,
.. but I wouldn't count on it. Instead, an `explicit environment spec
.. <http://conda.pydata.org/docs/using/envs.html#build-identical-conda-environments-with-urls>`_
.. will be available for download.
..
.. .. code-block:: bash
..
..     # Linux
..     >>> curl -o explicit-latest.sh "https://repo.continuum.io/miniconda/explicit2-latest-Linux-x86_64.txt"
..     >>> conda create --name p4env --file explicitenv2-latest-Linux-x86_64.txt
..     >>> conda activate p4env
..
.. .. code-block:: bash
..
..     # Mac
..     >>> curl -o explicit-latest.sh "https://repo.continuum.io/miniconda/explicit2-latest-MacOSX-x86_64.txt"
..     >>> conda create --name p4env --file explicitenv2-latest-MacOSX-x86_64.txt
..     >>> conda activate p4env

.. _`sec:quickconda`:

Quick Installation
^^^^^^^^^^^^^^^^^^

Sequence of commands to get you to a working |PSIfour|. Installs
Miniconda into ``$HOME/miniconda`` and the |PSIfour| executable into the
main conda environment at ``$HOME/miniconda/bin/psi4``.

.. code-block:: bash

    # Linux or Mac, Py2 or Py3 for main environment (immaterial to Py for Psi4): select between four lines
    # Windows: in Ubuntu shell, select either Linux line
    >>> curl -o Miniconda-latest.sh "https://repo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh"
    >>> curl -o Miniconda-latest.sh "https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh"
    >>> curl -o Miniconda-latest.sh "https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh"
    >>> curl -o Miniconda-latest.sh "https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh"

.. code-block:: bash

    >>> bash
    >>> bash Miniconda-latest.sh -b -p $HOME/miniconda  # agrees to conda's license terms
    >>> echo "export PATH=$HOME/miniconda/bin:\$PATH" >> ~/.bashrc  # Mac: use ~/.bash_profile
    # log out, log back in so conda in path
    >>> conda update --yes --all
    >>> conda config --add channels http://conda.anaconda.org/psi4
    >>> conda install --yes psi4
    >>> psi4 "$(dirname $(which psi4))"/../share/psi4/samples/sapt1/test.in  # test installation. works b/c PSI_SCRATCH defaults to /tmp

That last command tested that ``psi4`` is in your path, and it's finding
all the libraries it needs. Now you need only specify a scratch directory
(see :ref:`sec:Scratch`) by replacing the placeholder in the following:

.. code-block:: bash

    >>> echo "export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files" >> ~/.bashrc
    # log out, log back in so variable takes effect

All done!

.. note:: Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below.

.. _`sec:slowconda`:

Detailed Installation of Miniconda
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

https://docs.conda.io/en/latest/miniconda.html

.. 0. Sanity check. If you already have Miniconda or Anaconda, skip to step 5. The whole installation takes ~5 min; reading this page takes far longer.
..
.. 1. Get ``bzip2``. You'll need this slightly exotic command so run ``which`` to test for availability, and install from ``yum``, source, *etc.* if unavailable. You'll also need an internet connection for downloading; computers behind a firewall or with restricted login domains are eligible. So long as you can ssh *into* the computer to an account with write permissions and can connect to the internet *from* the computer, all is well.
..
.. .. code-block:: bash
..
..     # check
..     >>> which bzip2
..     /usr/bin/bzip2
..     >>> curl -O "http://psicode.org/psi4manual/master/introduction.html"
..     >>> ls -1
..     introduction.html
..
.. 2. Get Miniconda installer script. Either issue the command below or download from http://conda.pydata.org/miniconda.html by clicking on the appropriate link for your OS. If you already have or would prefer to use Anaconda rather than Miniconda, that's fine. Locate or install Anaconda, check that ``conda`` is in your path, and skip to step 4.
..
.. .. code-block:: bash
..
..     >>> curl -O "http://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh"
..     # check
..     >>> ls -1
..     Miniconda-latest-Linux-x86_64.sh
..
.. 3. Install Miniconda. Execute the script and answer its questions, particularly your choice of installation location. You may need to replace the filename below with the correct filename for the OS/version of installer you downloaded. Execute with ``bash`` regardless of ``csh``/``bash`` shell. If you're a ``bash`` user, it's convenient to agree to its offer to prepend ``conda`` commands to your :envvar:`PATH` in ``~/.bashrc``. If you're a ``csh``/``tcsh`` user, it's convenient to do the same by hand to your ``~/.tcshrc``: ``setenv PATH /path/to/miniconda/bin:${PATH}``. Further directions assume that the ``conda`` command is in your path; you may have to log out and log back in for ``which conda`` to return correctly.
..
.. .. code-block:: bash
..
..     >>> bash Miniconda-latest-Linux-x86_64.sh
..     # check
..     >>> which conda
..     /path/to/miniconda/bin/conda
..
.. 4. Update conda. This updates the package manager itself.
..
.. .. code-block:: bash
..
..     >>> conda update conda

.. _`sec:slowpsi4`:

Detailed Installation of |PSIfour|
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

5. Subscribe to |PSIfour|. Subscribe to our channel at https://anaconda.org/psi4 that contains the |PSIfour| package and several dependency packages. Make sure this shows up in your ``~/.condarc`` file.

.. code-block:: bash

    >>> conda config --add channels http://conda.anaconda.org/psi4
    # check
    >>> cat ~/.condarc
    channels:
      - http://conda.anaconda.org/psi4
      - defaults

6. Install |PSIfour|. You can install into the main conda environment so that whenever commands ``conda`` or (Ana/Miniconda's) ``python`` are available, then ``psi4`` is available, too.

.. code-block:: bash

    >>> conda install psi4
    # check
    >>> which psi4
    /path/to/miniconda/bin/psi4

Or, you can install into a `conda environment <https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#>`_ that places |PSIfour| and its dependencies (including python) into a sandbox unaffected by any other software installed in Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, *etc.*. In practical terms, installing into a conda environment means you can turn |PSIfours| availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, |PSIfour| is installed into an environment called ``p4env``. Then the environment is activated, removing the main Ana/Miniconda ``bin`` and adding ``envs/p4env/bin`` to :envvar:`PATH`. The ``conda activate`` command (conda >=4.4; December 2017) works in all shells, but if you're using old ``source activate`` that only works for ``bash``; adjust as needed for ``csh``/``tcsh``.

.. code-block:: bash

    >>> conda create -n p4env psi4
    >>> conda activate p4env
    # check
    >>> which psi4
    /path/to/miniconda/envs/p4env/bin/psi4

.. The output for either of the installation commands above looks like the following. It checks what packages are needed, gets your approval for downloading them, fetches and installs them, prints out some useful information, and runs a |PSIfour| test case to check that all's well.
..
.. .. code-block:: bash
..
..     >>> conda install psi4
..     Using Anaconda Cloud api site https://api.anaconda.org
..     Fetching package metadata: ......
..     Solving package specifications: .........
..
..     Package plan for installation in environment /theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4:
..
..     The following packages will be downloaded:
..
..         package                    |            build
..         ---------------------------|-----------------
..         psi4-0.4.322               |    py27_g84b3aa1        44.4 MB  http://conda.anaconda.org/psi4/linux-64/
..
..     The following NEW packages will be INSTALLED:
..
..         psi4: 0.4.322-py27_g84b3aa1 http://conda.anaconda.org/psi4/linux-64/
..
..     Proceed ([y]/n)? y
..
..     Fetching packages ...
..     psi4-0.4.322-p 100% |####################################################################################| Time: 0:00:08   5.77 MB/s
..     Extracting packages ...
..     [      COMPLETE      ]|#######################################################################################################| 100%
..     Linking packages ...
..
..
..       Thank you for installing psi4. Additional resources:
..         Website: www.psicode.org
..         Inputs:  /theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/share/psi4/samples
..         Manual:  http://psicode.org/psi4manual/master/index.html
..         GitHub:  https://github.com/psi4/psi4/wiki
..         Binary:  https://anaconda.org/psi4
..         Youtube: https://www.youtube.com/user/psitutorials
..
..       For csh/tcsh command-line use, add to shell or ~/.tcshrc file:
..         unsetenv PSIDATADIR
..         setenv PATH /theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH
..         setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/disk/for/scratch/files
..
..       For sh/bash command-line use, add to shell or ~/.bashrc file:
..         unset PSIDATADIR
..         export PATH=/theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH
..         export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files
..
..       Report problems at http://forum.psicode.org/t/report-conda-update-psi4-oddities-here/32
..
..
..         Nuclear Repulsion Energy..........................................PASSED
..         SAPT0 Eelst.......................................................PASSED
..         SAPT0 Eexch.......................................................PASSED
..         SAPT0 Eind........................................................PASSED
..         SAPT0 Edisp.......................................................PASSED
..         SAPT0 Etotal......................................................PASSED
..
..     [      COMPLETE      ]|#######################################################################################################| 100%

7. Configure environment. Preceding steps have placed ``conda`` and ``psi4`` in your :envvar:`PATH`, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the ``psi4`` executable to be found through any of:

  #. prepending to :envvar:`PATH` in shell, ``~/.bashrc``, ``~/.tcshrc``, or PBS ``cmd`` file
  #. activating the conda environment (p4env above) in shell, ``~/.bashrc``, or PBS ``cmd`` file
  #. supplying full path to executable (shell or PBS ``cmd`` file)

Similarly, the scratch directory (see :ref:`sec:Scratch`) must be specified through:

  #. defining :envvar:`PSI_SCRATCH` in shell, ``~/.bashrc``, ``~/.tcshrc``, or PBS ``cmd`` file

.. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6).

Useful Commands
^^^^^^^^^^^^^^^

* (A) Initially install |PSIfour| stable release

.. code-block:: console

   # equivalent
   >>> conda install psi4 -c psi4
   >>> conda install psi4 --channel psi4

* (B) Initially install |PSIfour| stable release with non-current python

.. code-block:: console

   >>> conda install psi4 python=3.8 -c psi4

* (C) Update to latest |PSIfour| stable release

.. code-block:: console

    >>> conda update psi4 -c psi4

* (D) Initially install stable release into a conda environment "p4env" instead of "root". This creates a sandbox with |PSIfour| and python (loaded as dependency).

.. code-block:: console

    >>> conda create -y -n p4env psi4 -c psi4
    >>> conda activate p4env

* (E) Install a particular |PSIfour| version

.. code-block:: console

    >>> conda install psi4=1.4 -c psi4

* (F) Uninstall |PSIfour| from current environment

.. code-block:: console

    >>> conda remove psi4

* (G) Initially install |PSIfour| nightly build

.. code-block:: console

   # equivalent
   >>> conda install psi4 -c psi4/label/dev
   >>> conda install psi4 --channel psi4/label/dev

* (H) Initially install |PSIfour| nightly build with non-current python

.. code-block:: console

   >>> conda install psi4 python=3.8 -c psi4/label/dev

* (I) Update to latest |PSIfour| nightly build

.. code-block:: console

    >>> conda update psi4 -c psi4/label/dev

* (J) Initially install nightly build into a conda environment "p4env" instead of "root". This creates a sandbox with |PSIfour| and python (loaded as dependency).

.. code-block:: console

    >>> conda create -y -n p4env psi4 -c psi4/label/dev
    >>> conda activate p4env

* (K) Install a particular |PSIfour| version

.. code-block:: console

    >>> conda install psi4=1.4 -c psi4/label/dev

.. Troubleshooting
.. ^^^^^^^^^^^^^^^
..
.. * If the target computer doesn't have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the |PSIfour| conda package won't work. ::
..
..     # unsuitable computer
..     >>> ldd --version
..     ldd (GNU libc) 2.5
..     # suitable computer
..     >>> ldd --version
..     ldd (GNU libc) 2.17
..
.. * It is of greatest importance that the |PSIfour| executable be linked against conda libpython.so *not* against any system libpython.so. This is arranged by setting ``RPATH`` to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda |PSIfour| executable is not vulnerable to interference from your ``LD_LIBRARY_PATH`` settings. Below shows a well-linked executable.
..
..     * no libraries "not found"
..     * fundamental libraries like libc, ld-linux, pthreads found system libraries to link against
..     * libpython linked against conda python *not* system python
..     * libm is linked against conda *or* system
..     * blas, c++, and gcc libraries are absent because statically linked
..
.. .. code-block:: console
..
..       >>> conda install conda-build  # needed for next command
..       >>> conda inspect linkages psi4
..       python-2.7.9-2:
..         libpython2.7.so.1.0 (lib/libpython2.7.so.1.0)
..       system-5.8-1:
..         libm.so.6 (lib/libm.so.6)
..       system:
..         libc.so.6 (/lib64/libc.so.6)
..         libdl.so.2 (/lib64/libdl.so.2)
..         libpthread.so.0 (/lib64/libpthread.so.0)
..         librt.so.1 (/lib64/librt.so.1)
..         libutil.so.1 (/lib64/libutil.so.1)
..         linux-vdso.so.1 ()
..       not found:


.. comment find out about the current environment.
.. comment pythonhome should be empty
.. comment pythonpath should be empty or set to non-interfering packages (*e.g.*, qcdb)
.. comment ld_library_path shouldn't contain anything with a libpython
.. comment >>> conda info -a

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
     single: multireference
     single: Mk-MRCC

.. _`sec:psimrcc`:

PSIMRCC Implementation of Mk-MRCC Theory
========================================

.. codeauthor:: Francesco A. Evangelista and Andrew C. Simmonett 
.. sectionauthor:: Alexander E. Vaughn

*Module:* :ref:`Keywords <apdx:psimrcc>`, :ref:`PSI Variables <apdx:psimrcc_psivar>`, :source:`PSIMRCC <psi4/src/psi4/psimrcc>`

State-specific Multireference coupled cluster theories provide highly
accurate energies and properties of electronic states that require
a multiconfigurational zeroth-order wavefunction.  The PSIMRCC
module contained in |PSIfour| implements the state-specific
multireference coupled-cluster approach of Mukherjee and co-workers
(Mk-MRCC). This method is implemented and shown to be a powerful tool in
[Evangelista:2006:154113]_ and [Evangelista:2008:124104]_. Mk-MRCC is
based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668]_ for the
wavefunction, :math:`\Psi`

.. math:: \left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}

where :math:`\Phi_\mu` are the reference determinants,
:math:`\hat{T}^\mu` are reference-specific excitation operators, and
:math:`c_\mu` are expansion coefficients obtained through diagonalization
of the Mk-MRCC effective Hamiltonian matrix that allows the various
reference determinants to interact. As an example of how this works
the Mk-MRCCSD excitation operators for each reference is contracted
two-body terms

.. math:: \hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2

where

.. math:: \hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i

and

.. math:: \hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i  

The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,
:math:`\textrm{H}^{eff}_{\mu \nu}`

.. math:: \sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu

where 

.. math:: \textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}

|PSIfour| currently implements Mk-MRCC with singles and doubles
[Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]
as formulated in [Evangelista:2010:074107]_. A companion perturbation
method (Mk-MRPT2) has been developed based on the Mukherjee formalisim
as shown in [Evangelista:2009:4728]_.

The current version of the code is limited to reference active spaces
in which all determinants are connected to each other by no more than two
excitations.  In practice, this usually means that the active space can have
at most two particles, or at most two holes.  Examples would include 
CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a
complete-active-space configuration interaction (CAS-CI) reference with n
electrons in m orbitals.  If the user specifies active spaces that do not fit
these limitations, then the code will still run, but some relevant
determinants will be missing, and the answer obtained will be an approximation
to the true Mk-MRCC procedure.

The PSIMRCC code itself does not perform orbital optimization.  Hence, the
references used might be considered CAS-CI references, but not CASSCF
references (CASSCF implies that the orbitals have been optimized specifically
to minimize the energy of the CAS-CI reference).  However, if one wishes to
use two-configuration self-consistent-field (TCSCF) orbitals, those can
be obtained using the multi-configuration self-consistent-field (MCSCF)
component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).
This is suitable for describing diradicals.  Otherwise, one may use RHF or
ROHF orbitals as input to PSIMRCC.  Due to a current limitation in the code,
one must obtain orbitals using PSIMRCC's MCSCF module regardless of what
orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``.  An example of the
MCSCF input is given below.

PSIMRCC is most commonly used for low-spin cases (singlets or open-shell
singlets).  It is capable of performing computations on higher spin states
(*e.g.*, triplets), but in general, not all the required matrix elements have
been coded for high-spin cases, meaning that results will correspond to an
approximate Mk-MRCC computation for high-spin cases.


A Simple Example
________________ 

The |psimrcc__corr_wfn| allows you to select one of three methods
Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].
The |psimrcc__corr_multp| option allows you to select the Slater
determinants with a particular :math:`M_s` value. The |psimrcc__wfn_sym|
keyword is neccesary if you do not want to compute the energy of the
totally-symmetric state. The |psimrcc__follow_root| option may be used
to follow different roots of the effective Hamiltonian. A value of 1
instructs PSIMRCC to follow the solution with the lowest energy given
a certain set of determinants. ::

   molecule o2 {
      0 3
      O
      O 1 2.265122720724
      units au
   }
   set {
      basis cc-pvtz
   }
   set mcscf {
      reference       rohf
      docc            [3,0,0,0,0,2,1,1]      # Doubly occupied MOs
      socc            [0,0,1,1,0,0,0,0]      # Singly occupied MOs
   }
   set psimrcc {
      corr_wfn        ccsd                   # Do Mk-MRCCSD 
      frozen_docc     [1,0,0,0,0,1,0,0]      # Frozen MOs
      restricted_docc [2,0,0,0,0,1,1,1]      # Doubly occupied MOs
      active          [0,0,1,1,0,0,0,0]      # Active MOs
      frozen_uocc     [0,0,0,0,0,0,0,0]      # Frozen virtual MOs
      corr_multp      1                      # Select the Ms = 0 component
      follow_root     1
      wfn_sym         B1g                    # Select the B1g state
   }
   energy('psimrcc')

Note that the oxygen molecule has 16 electrons (including core), while
the ``docc`` array contains only 7 doubly-occupied orbitals (or 14
electrons).  Hence, two more electrons are available to place into
the active space (given by ``active``), which consists of 2 orbitals.
Thus there are two active electrons in two orbitals.  In this particular
example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,
rather than TCSCF orbitals.  Nevertheless, with the present code, 
these orbitals must be provided through the MCSCF module, as specified in the
``set mcscf`` section above.

Orbital ordering and selection of the model space
_________________________________________________

The reference determinants :math:`\Phi_\mu` are specified in PSIMRCC
via occupational numbers. PSIMRCC requires that four arrays be specified
for this purpose.

- Frozen doubly occupied orbitals (|globals__frozen_docc|) are doubly
  occupied in each reference determinant and are not correlated in the
  MRCC procedure.
- Doubly occupied orbitals (|globals__restricted_docc|) are doubly
  occupied in each reference determinant and are correlated in the MRCC
  procedure.
- Active orbitals (|globals__active|) are partially occupied in each
  reference determinant.
- Frozen virtual orbitals (|globals__frozen_uocc|) are unoccupied in
  all reference determinants and are excluded from the correlated wave
  function.

The model space is selected by considering all possible occupations
of the electrons among the orbitals in the active space that result
in determinants with the correct symmetry (|psimrcc__wfn_sym|)
and the correct :math:`\textrm{M}_s` value specified by the keyword
|psimrcc__corr_multp|. Note that this does not consider the multiplicity
of the wavefunction. Thus, in order to obtain the wavefunction
with a set of :math:`\textrm{M}_s = 0` reference determinants for
an open-shell system you should request a |psimrcc__corr_multp| of
1 within the PSIMRCC module, and select the root of the effective
Hamiltonian that corresponds to the state of interest. In addition,
the |psimrcc__wfn_sym| keyword needs to be specified otherwise the
wavefunction belonging to the all-symmetric irrep will be selected. In
addition, it should be noted that for an open-shell singlet based
on two :math:`\textrm{M}_s = 0` determinants the eigenvector is
[:math:`\frac{1}{\sqrt{2}}\text{,}\frac{1}{\sqrt{2}}`], which corresponds
to a wavefunction of the following form:

.. math:: \frac{1}{\sqrt{2}} \left( \chi_1 \alpha (1) \chi_2 \beta (2) + \chi_2 \alpha(1) \chi_1 \beta (2) \right)

See Appendix :ref:`apdx:psimrcc` for a complete list of PSIMRCC options.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   Cube
   cubeprop
   visualization

.. _`sec:cubeprop`:

Generation of Cube Files |w---w| :py:func:`~psi4.cubeprop`
==========================================================

.. codeauthor:: Robert M. Parrish, Francesco A. Evangelista and Peter Kraus
.. sectionauthor:: Francesco A. Evangelista and Peter Kraus

.. autofunction:: psi4.cubeprop(wfn)
   :noindex:

Introduction
------------

|PSIfour| has the ability to export cube files that store information about
basis functions, molecular orbitals, the electron density, and
the electrostatic potential (ESP).  Cube files store the value of a scalar
quantity on a regular Cartesian grid, and can be visualized with several
visualization programs, some of which are free, like VMD
(http://www.ks.uiuc.edu/Research/vmd/).

An example utilization of the code is::

   molecule h2o {
   0 1
   O
   H 1 1.0
   H 1 1.0 2 104.5
   }

   set basis cc-pvdz
   set scf_type df
   set freeze_core True
   set cubeprop_tasks ['orbitals']
   set cubeprop_orbitals [5,6,-5,-6]

   E, wfn = energy('scf', return_wfn=True)
   cubeprop(wfn)

In this example, the :py:func:`~psi4.cubeprop`
call after the ``energy('scf')`` command
executes the cubeprop code.  The array |globals__cubeprop_tasks| specifies which
tasks should be executed.  In this case the task ``'orbitals'`` generates cube
files for orbitals.  The |globals__cubeprop_orbitals| option specifies that cube files
should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and
beta orbitals 5 (indicated as -5) and 6.
If the option |globals__cubeprop_orbitals| is not provided, then cube files are
generated for all orbitals.
After running, the above input will generate four files: ``Psi_a_5_1-B1.cube``,
``Psi_a_6_4-A1.cube``, ``Psi_a_5_1-B1.cube``, and ``Psi_a_6_4-A1.cube``. The subscript ``a`` in
``Psi_a_5_1-B1.cube`` indicates an alpha orbital. The first number (``5``) is the index of the
orbital while ``1-B1`` indicates that this is the first orbital that belongs to the B1 irrep.
The file ``Psi_a_5_1-B1.cube`` begins with two comment lines::

   Psi4 Gaussian Cube File.
   Property: Psi_a_5_1-B1. Isocontour range for 85% of the density: (0.0787495,-0.0787495)

The second line reports the isocontour values that capture 85% of the probability density using
the least amount of grid points. This quantity is determined for orbitals and densities. The
fraction of the density captured by the isocontour values is by default 0.85, but can
be changed via the option |globals__cubeprop_isocontour_threshold|.

.. note:: If your cube plots are too coarse, try to decrease the grid spacing via
    the option |globals__cubic_grid_spacing|.  If the edges of your plot are cut then
    increase the size of the grid via the option |globals__cubic_grid_overage|.

Cubeprop Tasks
--------------

The cubeprop utility can be provided a list of tasks to perform.
Tasks are specified by the |globals__cubeprop_tasks| option, which is a list of strings
that identify the tasks.  Several tasks are available. These include:

ORBITALS [Default if  |globals__cubeprop_tasks| is not specified]
    Produces cube representations of the molecular orbitals
    :math:`\psi_q(\mathbf{r})`.  Orbitals are sorted according to increasing
    orbital energy ignoring symmetry.
FRONTIER_ORBITALS
    Produces cube representations of the frontier molecular orbitals. For closed shell
    species, the highest occupied (HOMO) and the lowest unoccupied (LUMO) alpha orbitals (ie. 
    :math:`\psi_{\alpha}(\mathbf{r})`) are printed, while for open shell species a total 
    of :math:`(4 + M_s)` orbitals are printed (:math:`\alpha` and :math:`\beta` 
    spin for both lowest virtual (LVMO) and highest doubly occupied
    orbitals (DOMO), along with all :math:`\alpha` singly occupied (SOMO) orbitals).
DENSITY
    This task can be used to obtain the alpha and beta electron densities,
    :math:`\rho_\alpha(\mathbf{r})` and :math:`\rho_\beta(\mathbf{r})`, together
    with the total density
    :math:`\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) + \rho_\beta(\mathbf{r})`,
    and the spin density
    :math:`\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) - \rho_\beta(\mathbf{r})`.
BASIS_FUNCTIONS
    This task is useful to produce cube files of the atomic orbital basis
    functions :math:`\chi_\mu(\mathbf{r})`.
ESP
    Calculates the total (nuclear + electronic) electrostatic potential
    :math:`V(\mathbf{r})`.
DUAL_DESCRIPTOR
    Calculates the dual descriptor from frontier orbitals:
    :math:`f^2(\mathbf{r})=\rho_{\mathrm{LUMO}}(\mathbf{r})-\rho_{\mathrm{HOMO}}(\mathbf{r})`.
    The dual descriptor is a good measure of nucleophilicity and electrophilicity,
    containing information essentially equivalent to both Fukui functions combined. 
    More details on the dual descriptor itself can be found in [Morell:2005:205]_, 
    while the current implementation is described in [Martinez-Araya:2015:451]_. 
    This feature is currently only supported for closed shell systems.

.. note:: The ``ESP`` task requires the user to specify a density-fitting basis
    via the |scf__df_basis_scf| keyword.

.. warning:: It is important to specify the |globals__cubeprop_orbitals| option when
   dealing with large molecules to avoid running out of disk space.
   For example, using the default grid spacing of
   0.2 |Angstrom|, the size of a single cube file for a molecule like water
   is of the order of 1.4 MB.  For a molecule with 200 basis functions, the cube
   files for all the orbitals occupy more than half a GB.

Keywords
--------

.. include:: autodir_options_c/globals__cubeprop_tasks.rst
.. include:: autodir_options_c/globals__cubeprop_filepath.rst
.. include:: autodir_options_c/globals__cubeprop_orbitals.rst
.. include:: autodir_options_c/globals__cubeprop_basis_functions.rst
.. include:: autodir_options_c/globals__cubic_grid_spacing.rst
.. include:: autodir_options_c/globals__cubic_grid_overage.rst

Orbital Visualization with VMD
==============================

Included in |PSIfour| is functionality to automatically render specified surfaces, including molecular orbitals,
densities, and basis functions, using VMD. The vmd_cube.py script takes the .cube files generated
in a calculation and generates images aligned with user-input specifications. The script is located
in :source:`psi4/share/psi4/scripts/vmd_cube.py`.

Script Prerequisites
--------------------

1. VMD must be installed, and it can be downloaded for free at (http://www.ks.uiuc.edu/Research/vmd/). Additionally,
   the script needs to know where to find the VMD executable, and this is defined as :envvar:`VMDPATH`. VMDPATH must be defined as
   an environment variable.

2. To generate images with multiple surfaces, ImageMagick must also be installed. ImageMagick is a free program which
   can be installed using homebrew/pip or from http://www.imagemagick.org/script/binary-releases.php .

3. With ImageMagick installed, an environment variable called :envvar:`MONTAGE` needs to be created which points to the montage executable.
   This executable can be found in the /bin/ sub-directory wherever ImageMagick was installed.

.. envvar:: VMDPATH

   Filesystem path to the VMD executable.

.. envvar:: MONTAGE

   Filesystem path to the Montage executable of ImageMagick

Running the Script
------------------

1. Run a |PSIfour| calculation, generating .cube files as detailed in the above documentation.

2. Add vmd_cube.py to your path. Call vmd_cube.py and pass the directory containing
   the .cube files as an argument::
	
	python vmd_cube.py /path/to/cube/files/

   By default the script will search for cube files in the directory in which it is called.
   In addition to individual image files for each orbital, vmd_cube will also generate an image containing all surfaces in an array
   (very useful for hand-picking orbital spaces)

3. As an example, take the cube files generated from the water calculation from the above input file.
   Using vmd_cube the alpha molecular orbitals can be rendered and output in one image with::

    python vmd_cube.py /path/to/cube/files/ --opacity=0.5 --rx=90 --ry=60

The desired image in this case is called "AlphaMOs.tga", and looks like	this:

.. image:: /AlphaMOs.png
    :align: center
    :scale: 100%
    :alt: Alpha MOs	


Script Options
--------------

The help for ``vmd_cube.py`` can be obtained from the console::

    >>> ./vmd_cube.py --help
    usage: vmd_cube.py [-h] [--color1 [<integer>]] [--color2 [<integer>]]
                       [--iso [<isovalue>]] [--rx [<angle>]] [--ry [<angle>]]
                       [--rz [<angle>]] [--tx [<length>]] [--ty [<length>]]
                       [--tz [<length>]] [--opacity [<opacity>]]
                       [--scale [<factor>]] [--no-montage] [--no-labels]
                       [--imagesize [<integer>]] [--imagew [<integer>]]
                       [--imageh [<integer>]] [--fontsize [<integer>]]
                       [--interactive] [--gzip] [--national_scheme]
                       [--silver_scheme] [--bright_scheme] [--electron_scheme]
                       [<cubefile dir>]

    vmd_cube is a script to render cube files with vmd. To generate cube files
    with Psi4 add the command cubeprop() at the end of your input file.

    positional arguments:
      <cubefile dir>        The directory containing the cube files.

    optional arguments:
      -h, --help            show this help message and exit
      --color1 [<integer>]  the color ID of surface 1 (integer, default = 3)
      --color2 [<integer>]  the color ID of surface 2 (integer, default = 23)
      --iso [<isovalue>]    the isosurface value (float, default = 0.05)
      --rx [<angle>]        the x-axis rotation angle (float, default = 30.0)
      --ry [<angle>]        the y-axis rotation angle (float, default = 40.0)
      --rz [<angle>]        the z-axis rotation angle (float, default = 15.0)
      --tx [<length>]       the x-axis translation (float, default = 0.0)
      --ty [<length>]       the y-axis translation (float, default = 0.0)
      --tz [<length>]       the z-axis translation (float, default = 0.0)
      --opacity [<opacity>]
                            opacity of the isosurface (float, default = 1.0)
      --scale [<factor>]    the scaling factor (float, default = 1.0)
      --no-montage          call montage to combine images. (string, default =
                            false)
      --no-labels           do not add labels to images. (string, default = false)
      --imagesize [<integer>]
                            the size of each image (integer, default = 250)
      --imagew [<integer>]  the width of images (integer, default = 250)
      --imageh [<integer>]  the height of images (integer, default = 250)
      --fontsize [<integer>]
                            the font size (integer, default = 20)
      --interactive         run in interactive mode (default = false)
      --gzip                gzip cube files (default = false)
      --national_scheme     use a red/blue color scheme. (string, default = false)
      --silver_scheme       use a gray/white color scheme. (string, default =
                            false)
      --bright_scheme       use a soft yellow/blue color scheme. (string, default
                            = false)
      --electron_scheme     use a purple/green color scheme. (string, default =
                            false)

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

======================================
Installation and Runtime Configuration
======================================

.. toctree::
   :maxdepth: 2

   FAQ <build_faq>
   build_obtaining
   build_planning
   Installing from Binary <conda>


.. index:: scratch files, restart
.. _`sec:Scratch`:

Scratch Files
=============

One very important part of user configuration at the end of the
installation process
is to tell |PSIfour| where to write its temporary
("scratch") files.  Electronic structure packages like |PSIfour| can
create rather large temporary disk files.  It is very important to 
ensure that |PSIfour| is writing its temporary files to a disk drive
physically attached to the computer running the computation.  If it
is not, it will significantly slow down the program and the network.
By default, |PSIfour| will write temporary files to ``/tmp``, but this
directory is often not large enough for typical computations.  Therefore,
you need to (a) make sure there is a sufficiently large directory on a
locally attached disk drive (100GB--1TB or more, depending on the size of
the molecules to be studied) and (b) tell |PSIfour| the path to this
directory. Scratch file location can be specified through the 
:envvar:`PSI_SCRATCH` environment variable or through the |psirc| file
(see section :ref:`sec:psirc`). Most of the time, :envvar:`PSI_SCRATCH`
is preferred, and it overrides any existing |psirc| setting. You can set up 
:envvar:`PSI_SCRATCH` by issuing the following commands in a terminal,
or including them in the appropriate ``rc`` file.

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/disk/for/scratch/files

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files

|PSIfour| has a number of utilities that manage
input and output (I/O) of quantities to and from the hard disk.  Most
quantities, such as molecular integrals, are intermediates that are not of
interest to the user and can be deleted after the computation finishes, but
pertinent details of computations are also written to a checkpoint file and
might be useful in subsequent computations.  All files are written to the
designated scratch :ref:`numbered by content <apdx:psiFiles>` and labeled
with the process id, then are deleted at the end of the computation,
unless otherwise instructed by the user.

A Python callable handle to the |PSIfour| I/O management routines is available,
and is called ``psi4_io``.  To instruct the I/O manager to send all files to
another location, say ``/scratch/user``, add the following command to your input
file: ::

    psi4_io.set_default_path('/scratch/user')

For batch jobs running through a queue, it might be more convenient to use an
environmental variable (in this case ``$MYSCRATCH``) to set the scratch directory;
the following code will do that::

    import os
    scratch_dir = os.environ.get('MYSCRATCH')
    if scratch_dir:
        psi4_io.set_default_path(scratch_dir + '/')

Individual files can be sent to specific locations.  For example, file 12
contains information about the internal coordiantes of a geometry optimization.
The user may want to retain this in the working directory
(*i.e.*, where |PSIfour| was launched from) to analyze the optimization.  This is
accomplished by the commands below::

    psi4_io.set_specific_path(12, './')
    psi4_io.set_specific_retention(12, True)

    # equivalent to above
    psi4_io.set_specific_path(PSIF_INTCO, './')
    psi4_io.set_specific_retention(PSIF_INTCO, True)

A guide to the contents of individual scratch files may be found at :ref:`apdx:psiFiles`.
To circumvent difficulties with running multiple jobs in the same scratch, the
process ID (PID) of the |PSIfour| instance is incorporated into the full file
name; therefore, it is safe to use the same scratch directory for calculations
running simultaneously.

Elementary Restart
==================

The |PSIfour| intermediate files use the following naming scheme ::

  psi.PID.name.filenumber

where by default, PID is the process number, name the name of the molecule,
and filenumber is listed in :ref:`content <apdx:psiFiles>`.

For those modules providing restart capabilities, the previous file can
be provided through the``restart_file`` option ::

  energy('scf',restart_file='./psi.PID.name.filenumber')

Only the filenumber is necessary for the driver to appropriately rename the
file and copy it to the scratch directory where |PSIfour| will expect it.
The restart capabilities of a specific method (if any) are found in that method's documentation.

To provide multiple files, pass them as arguments of a Python list ::

  energy('scf',restart_file=['./file1.filenumber','./file2.filenumber'])

Note that the ``restart_file`` options is only available for energy procedures as of now.

Executing |PSIfour| with the :option:`psi4 -m` (for
messy) flag will prevent files being deleted at the end of the run::

    psi4 -m

The mechanism for restarting HF/DFT calculations is described in details :ref:`here <sec:scfrestart>`.


.. _`sec:save_wfn`:

Saving the Wavefunction
=======================

A core object of |PSIfour| is the Wavefunction (short ``wfn``) object ::

  energy, wfn = energy('scf',return_wfn=True)

This C++/Python object (:py:class:`psi4.core.Wavefunction`) contains orbital
data, basis set information, result variables and more.
It can be saved either to a numpy file or converted to a python dictionary ::

  # write the wavefunction to file
  wfn.to_file('my_wfn')

  # alternatively store the dict representation of the wavefunction in memory
  wfn_dict = wfn.to_file()

In either form, its attributes can be set and edited.
This is an expert-level feature, though.
In general, let |PSIfour| create the Wavefunction, then treat it as read-only.
The back conversion to a Wavefunction object uses the ``.from_file()`` functionality ::

  # read wavefunction from file
  wfn_from_file = psi4.core.Wavefunction.from_file('my_wfn')

  # make a wavefunction from the dict
  wfn_from_dict = psi4.core.Wavefunction.from_file(wfn_dict)

.. index:: psirc, psi4rc
.. _`sec:psirc`:

|psirc| File
============

.. caution:: The |psirc| file is only read for Psithon input, not PsiAPI.
   It does nothing that can't be done in other more transparent ways.
   It should be avoided.
   It is very easy to forget about the |psirc| file you once
   created, leading to great confusion over why all your jobs are using
   the wrong memory or are suddenly not density-fit. Also be aware that
   |psirc| contents count as part of your input file (invoked after
   e.g. ``from psi4 import *`` and before your Psithon-->Python parsed
   input commands), so these settings take priority over command-line
   arguments to the ``psi4`` executable.
   Please use the |psirc| file sparingly.

If using the environment variable :envvar:`PSI_SCRATCH` is inconvenient,
or if some ``psi4_io`` commands must be present in all input files,
the |psirc| resource file can be used (example :source:`samples/example_psi4rc_file`). 

All the commands mentioned in section :ref:`sec:Scratch` can be used in this file.

To set up the scratch path::

    psi4_io.set_default_path('/scratch/user')

To set up the scratch path from a variable ``$MYSCRATCH``::

    import os
    scratch_dir = os.environ.get('MYSCRATCH')
    if scratch_dir:
        psi4_io.set_default_path(scratch_dir + '/')

To set up a specific path for the internal coordinate file and instruct |PSIfour| not to delete it::

    psi4_io.set_specific_path(12, './')
    psi4_io.set_specific_retention(12, True)

    # equivalent to above
    psi4_io.set_specific_path(PSIF_INTCO, './')
    psi4_io.set_specific_retention(PSIF_INTCO, True)

The Python interpreter will execute the contents of the
|psirc| file in the current user's home area (if present) before performing any
tasks in the input file. As a consequence, the commands in the input files supersede
any instructions in the |psirc| file. During
execution, the |psirc| defaults will be loaded in first, but then the commands
in the input file will be executed.  

The |psirc| file can also be used to define constants that are accessible
in input files or to place any Python statements that should be executed
with every |PSIfour| instance.

.. index:: parallel operation, threading
.. _`sec:threading`:

Threading
=========

Most new modules in |PSIfour| are designed to run efficiently on SMP architectures
via application of several thread models. The de facto standard for |PSIfour|
involves using threaded BLAS/LAPACK (particularly Intel's excellent MKL package)
for most tensor-like operations, OpenMP for more general operations, and C++
``std::thread`` for some special-case operations. Note: Using OpenMP alone is a really
bad idea. The developers make little to no effort to explicitly parallelize
operations which are already easily threaded by MKL or other threaded BLAS. Less
than 20% of the threaded code in |PSIfour| uses OpenMP, the rest is handled by
parallel DGEMM and other library routines. From this point forward, it is
assumed that you have compiled |PSIfour| with OpenMP and MKL (Note that it is
possible to use g++ or another compiler and yet still link against MKL).

Control of threading in |PSIfour| can be accomplished at a variety of levels,
ranging from global environment variables to direct control of thread count in
the input file, to even directives specific to each model. This hierarchy is
explained below. Note that each deeper level trumps all previous levels.

.. rubric:: (1) OpenMP/MKL Environment Variables

.. deprecated:: 1.1
   Environment variables :envvar:`OMP_NUM_THREADS` and :envvar:`MKL_NUM_THREADS`
   do not affect threading in |PSIfour|.

.. The easiest/least visible way to thread |PSIfour| is to set the standard OpenMP/MKL
.. environment variables :envvar:`OMP_NUM_THREADS` and :envvar:`MKL_NUM_THREADS`.
..
.. .. code-block:: tcsh
..
..     # csh, tcsh: add to shell or ~/.tcshrc file
..     setenv OMP_NUM_THREADS 4
..     setenv MKL_NUM_THREADS 4
..
.. .. code-block:: bash
..
..     # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
..     export OMP_NUM_THREADS=4
..     export MKL_NUM_THREADS=4
..
.. Psi4 then detects these value via the API routines in ``<omp.h>`` and
.. ``<mkl.h>``, and runs all applicable code with 4 threads.

.. rubric:: (2) The -n Command Line Flag

To change the number of threads at runtime, the :option:`psi4 -n` flag may be used. An
example is:

.. code-block:: bash

    psi4 -i input.dat -o output.dat -n 4

which will run on four threads. Note that is is not available for PsiAPI mode of operation.

.. rubric:: (3) Setting Thread Numbers in an Input

For more explicit control, the Process::environment class in |PSIfour| can
override the number of threads set by environment variables. This functionality
is accessed via the :py:func:`~psi4.core.set_num_threads` function, which controls
both MKL and OpenMP thread numbers. The number of threads may be changed
multiple times in a |PSIfour| input file. An example input for this feature is::

    # A bit small-ish, but you get the idea
    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 90.0
    }

    # Run from 1 to 4 threads, for instance, to record timings
    for nthread in range(1, 5):
        set_num_threads(nthread)
        energy("scf/cc-pvdz")

In PsiAPI mode of operation, this syntax, ``psi4.set_num_threads(nthread)``, is
the primary way to control threading.

.. rubric:: (4) Method-Specific Control

Even more control is possible in certain circumstances. For instance, the
threaded generation of AO density-fitted integrals involves a memory requirement
proportional to the number of threads. This requirement may exceed the total
memory of a small-memory node if all threads are involved in the generation of
these integrals. For general DF algorithms, the user may specify::

    set MODULE_NAME df_ints_num_threads n

to explicitly control the number of threads used for integral formation. Setting
this variable to 0 (the default) uses the number of threads specified by the
:py:func:`~psi4.core.set_num_threads` Psithon method or the default environmental variables.

.. index:: PBS queueing system, threading
.. _`sec:PBS`:

PBS job file
============

To run a |PSIfour| job on a PBS queueing system, you need to properly set up
all necessary variables in the PBS job file. Below is a minimal example of
a PBS job file for a threaded job, and a short explanation for each section.

.. code-block:: bash

    #!/bin/tcsh
    #PBS -j oe
    #PBS -l pmem=2120mb
    #PBS -N jobname
    #PBS -V

    cd $PBS_O_WORKDIR
    setenv myscratch /scratch/user/psi4.$PBS_JOBID

    foreach i (`sort $PBS_NODEFILE | uniq`)
        echo "Creating scratch directory " $myscratch " on " $i
        ssh $i rm -rf $myscratch
        ssh $i mkdir -p $myscratch
    end

    unsetenv PSIDATADIR
    setenv PSI_SCRATCH $myscratch
    if ! ( $?PSIPATH ) setenv PSIPATH ""
    setenv PSIPATH /path/to/external/modules:${PSIPATH}
    setenv PSIPATH /path/to/python/modules:${PSIPATH}
    /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4

    foreach i (`sort $PBS_NODEFILE | uniq`)
        echo "Removing scratch directory " $myscratch " on " $i
        ssh $i rm -rf $myscratch
    end

The top section features PBS-specific commands. These depend on the 
specific characteristics of your PBS queuing system but they may include: ::

    #!/bin/tcsh
    #PBS -j oe 
    #PBS -l pmem=2120mb
    #PBS -N jobname
    #PBS -V
    
The ``PBS -j oe`` option instructs PBS to write any output or error message
from the queuing system in dedicated files. ``PBS -l pmem=2120mb`` requests 
2120 MB of memory for each thread on the node. The total memory requested for 
the job by PBS should generally be slightly greater than what indicated 
in the input file (see :ref:`memory setting <sec:memory>`).

.. In the next section, we define :envvar:`OMP_NUM_THREADS` and :envvar:`MKL_NUM_THREADS`
.. to use 4 threads for OpenMP parallelization and in threaded BLAS (see section :ref:`sec:threading`). ::
.. 
..     setenv OMP_NUM_THREADS 4
..     setenv MKL_NUM_THREADS 4

Then, we move to the working directory using PBS variable ``$PBS_O_WORKDIR`` and 
we create scratch directories on every node, using the ``$PBS_NODEFILE`` which 
points to a file containing a list of the nodes attributed to the job.

.. code-block:: bash

    cd $PBS_O_WORKDIR
    setenv myscratch /scratch/user/psi4.$PBS_JOBID
    
    foreach i (`sort $PBS_NODEFILE | uniq`)
        echo "Creating scratch directory " $myscratch " on " $i
        ssh $i rm -rf $myscratch
        ssh $i mkdir -p $myscratch
    end

The next section is *very important* as it sets the environment variables needed
by |PSIfour|:

.. code-block:: bash

    unsetenv PSIDATADIR
    setenv PSI_SCRATCH $myscratch
    if ! ( $?PSIPATH ) setenv PSIPATH ""
    setenv PSIPATH /path/to/external/modules:${PSIPATH}
    setenv PSIPATH /path/to/python/modules:${PSIPATH}

:envvar:`PSIDATADIR` does *not* need to be set.
In the present example we unset it to make sure it does not interfere with the internal location-finding.
:envvar:`PSIPATH` is needed only if you are using external modules or 
plugins in |PSIfour| and should point to the directories where they can be found. In the
present example, we make sure the variable is set with ``if ! ( $?PSIPATH ) setenv PSIPATH ""``
before adding more paths to it. Finally, :envvar:`PSI_SCRATCH` should point to a fast, existing
local disk for temporary file storage. To use 4 threads for OpenMP parallelization
and threaded BLAS (see section :ref:`sec:threading`), we set ``-n4`` below.
The next step is then to actually run the computation: ::

    /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4

And then to clean up the scratch directories previously created:

.. code-block:: bash

    foreach i (`sort $PBS_NODEFILE | uniq`)
        echo "Removing scratch directory " $myscratch " on " $i
        ssh $i rm -rf $myscratch
    end

Note again that the specific commands for your PBS system may differ. Refer
to your system administrator.

.. _`sec:commandLineOptions`:

Command Line Options
====================

|PSIfour| can be invoked with no command line arguments, as it takes as input
by default the file "input.dat" and directs output by default to "output.dat".
Each set of three commands below is completely equivalent, while the second set,
perhaps, is the most common usage. ::

   >>> psi4
   >>> psi4 -i input.dat -o output.dat
   >>> psi4 input.dat output.dat

   >>> psi4 descriptive_filename.in
   >>> psi4 -i descriptive_filename.in -o descriptive_filename.out
   >>> psi4 descriptive_filename.in descriptive_filename.out

Command-line arguments to |PSIfour| can be accessed through :option:`psi4 --help`.

.. program:: psi4

.. option:: -a, --append

   Append results to output file. Default: Truncate first

.. option:: -h, --help

   Display the command-line options and usage information.

.. option:: -i <filename>, --input <filename>

   Input file name. Default: input.dat

.. option:: --inplace

   Runs |PSIfour| with compiled code from <objdir> but driver code from source,
   so no need to ``make`` between Python edits. Expert mode.

.. option:: -k, --skip-preprocessor

   Skips input preprocessing. Expert mode.

.. option:: -l <name>, --psidatadir <name>

   Overrides the value of
   :envvar:`PSIDATADIR` and specifies the path to the Psi data
   library (ends in ``share/psi4``). Expert mode.

.. option:: --loglevel <int>

   Sets logging level: WARN=30, INFO=20, DEBUG=10.

.. option:: -m, --messy

   Leave temporary files after the run is completed.

.. option:: --memory <memory>

   The amount of memory to use. Can be specified with units (e.g., '10MB') otherwise bytes is assumed.

 .. option:: -n <threads>, --nthread <threads>

   Number of threads to use (overrides :envvar:`OMP_NUM_THREADS`).
   Also controls the testing parallelism with pytest.

.. option:: -o <filename>, --output <filename>

   Output file name. Use ``stdout`` as <filename> to redirect
   to the screen. Default: when the input filename is "input.dat",
   then the output filename defaults to "output.dat".  Otherwise, the
   output filename defaults to the the input filename with
   ".out" extension.

.. option:: --psiapi-path

   Generates a bash command to source correct Python interpreter and path for ``python -c "import psi4"``

.. option:: --qcschema

   Runs input files as QCSchema. Can either be JSON or MessagePack input.

.. option:: -s <name>, --scratch <name>

   This overrides the value of :envvar:`PSI_SCRATCH` and provides
   a path to the location of scratch files

.. option:: -t <subset>, --test <subset>

   Runs pytest tests. If ``pytest-xdist`` installed, parallel with :option:`-n`.

.. .. option:: --new-plugin <name>
..
..    Creates a new directory <name> with files for writing a
..    new plugin. An additional argument specifies a template
..    to use, for example: ``--new-plugin name +mointegrals``.
..    See :ref:`plugins <sec:plugins>` for available templates.

.. option:: -v, --verbose

   Print the Psithon to Python translation of the input file

.. option:: -V, --version

   Print version information. ::

     # stable release
     >>> psi4 --version
     1.3.2

     # development snapshot between 1.3 and 1.4
     >>> psi4 --version
     1.4a2.dev525

.. .. option:: -w, --wipe

..    Clean out scratch area.


.. _`sec:environmentVariables`:

Environment Variables
=====================

These environment variables will influence |PSIfours| behavior.

.. envvar:: CONDA_PREFIX

   Set when a conda environment is activated. Note that if |PSIfour| has been
   built against any library in CONDA_PREFIX, the path has been baked into the
   program, so any available dependencies are liable to been loaded from the environment.

.. envvar:: HOST

   Set when a conda environment with conda compilers is activated. Used
   when compatibly building |PSIfour| from source against conda
   dependencies.

.. envvar:: MKL_NUM_THREADS

   Number of threads to use by operations with Intel threaded BLAS libraries.

   .. deprecated: 1.1
      See :ref:`sec:threading` for alternatives.

.. envvar:: OMP_NESTED

   Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket
   platforms. This is very low-level access to OpenMP functions for
   experienced programmers. Users should leave this variable unset or set
   to ``False``.

.. envvar:: OMP_NUM_THREADS

   Number of threads to use by modules with OpenMP threading.

   .. deprecated: 1.1
      See :ref:`sec:threading` for alternatives.

.. envvar:: PATH

   Path for interfaced executables.

   .. note:: While once configuring |PSIfour| through :envvar:`PSIPATH` was preferred
      to modifying this environment variable, now `PATH` is preferred for
      executables to accommodate QCEngine.

   To run K\ |a_acute|\ llay's MRCC program 
   (see :ref:`MRCC <sec:mrcc>`), the ``dmrcc`` executable must be in :envvar:`PATH`.
   Likewise to run Grimme's dftd3 program (see :ref:`dftd3 <sec:dftd3>`), the 
   ``dftd3`` executable must be in :envvar:`PATH`.

.. envvar:: PSI_SCRATCH

   Directory where scratch files are written. Overrides settings in |psirc|.
   It is very important to ensure that |PSIfour| is writing its scratch files 
   to a disk drive physically attached to the computer running the computation. 
   If it is not, it will significantly slow down the program and the network. 

   Modify :envvar:`PSI_SCRATCH` through normal Linux shell commands before invoking :command:`psi4`

   .. code-block:: tcsh

       # csh, tcsh: add to shell or ~/.tcshrc file
       setenv PSI_SCRATCH /scratch/user

   .. code-block:: bash

       # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
       export PSI_SCRATCH=/scratch/user

.. envvar:: PSIPATH

   Path in which |PSIfour| looks for user extensions to the built-in
   libraries. Specifically, directories containing 
   :ref:`user basis sets <sec:basisUserDefined>`,
   :ref:`EFP fragments <sec:findingEFPFragments>`,
   :ref:`databases <sec:createDatabase>`, 
   :ref:`plugins <sec:plugins>`, and 
   interfaced executables (
   ``dmrcc`` for :ref:`MRCC <sec:mrcc>` and 
   ``dftd3`` for :ref:`DFTD3 <sec:dftd3>`
   ) should be placed in this colon-separated list.

   |PSIfour| is designed so that user extensions that are findable through
   :envvar:`PSIPATH` can be used in input files entirely like their
   built-in counterparts, without additional tagging as non-standard.

   The typical search path is first the built-in libraries, next each
   :envvar:`PSIPATH` directory in order, and finally the execution
   directory (I won't swear everything tacks on the execution directory).

   Path in which the Python interpreter looks for modules to import. For 
   |PSIfour|, these are generally :ref:`plugins <sec:plugins>` or databases.

   Modify :envvar:`PSIPATH` through normal Linux shell commands before invoking :command:`psi4`

   .. code-block:: tcsh

       # csh, tcsh: add to shell or ~/.tcshrc file
       setenv PSIPATH /home/user/psiadditions:/home/user/gbs

   .. code-block:: bash

       # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
       export PSIPATH=/home/user/psiadditions:/home/user/gbs

.. envvar:: PYTHONPATH

   Path in which the Python interpreter looks for modules to import. For 
   |PSIfour|, these are generally :ref:`plugins <sec:plugins>` or databases.

   .. note:: While once configuring |PSIfour| through :envvar:`PSIPATH` was preferred
      to modifying this environment variable, now `PYTHONPATH` is preferred for
      Python moduels to accommodate QCEngine.

   Modification of :envvar:`PYTHONPATH` can be done in three ways, equivalently.

   * Normal Linux shell commands.

     .. code-block:: tcsh

         # csh, tcsh: add to shell or ~/.tcshrc file
         setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH

     .. code-block:: bash

         # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
         export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH

   * Place the path in the |psirc| file so that it is available for 
     every |PSIfour| instance. ::

        sys.path.insert(0, '/home/user/psiadditions')

   * Place the path in the input file, either absolute or relative. ::

        sys.path.insert(0, '../../psiadditions')
        sys.path.insert(0, '/home/user/psiadditions')

.. envvar:: PSIDATADIR

   Path in which the |PSIfour| executable looks for its non-compiled
   dependencies (*i.e.*, basis sets, databases, quadratures, *etc.*).
   This path is always known by the |PSIfour| program or shared library,
   so this variable is relevant primarily to developers wanting a
   non-standard location. Value should be set
   to directory containing driver, basis, *etc.* directories, generally
   ending in ``share/psi4``.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: basis set; available by family
.. _`apdx:basisTables`:

====================
Basis Sets by Family
====================

Tables :ref:`Pople <table:basisPopleOrbital>`,
:ref:`Dunning <table:basisDunningOrbital>`, 
:ref:`Dunning (Douglas-Kroll) <table:basisDunningDK>`, 
:ref:`Dunning (F12) <table:basisDunningF12>`, 
:ref:`Karlsruhe <table:basisKarlsruhe>`,
:ref:`Jensen <table:basisJensen>`,
:ref:`Petersson <table:basisPetersson>`,
and :ref:`Other <table:basisOther>` summarize the orbital basis sets available in
|PSIfour|.  These tables are arranged so that columns indicate degree of
augmentation by diffuse functions (generally necessary for anions, excited
states, and noncovalent interactions) and DTQ56 indicate the :math:`X\;=\zeta` levels
available.  Several intermediate levels of diffuse space between the customary
non-augmented and augmented versions have been supplied for each basis set,
including heavy-augmented and Truhlar's [Papajak:2011:10]_ calendar
truncations described in Table :ref:`Months Bases <table:basisMonths>`.  Fitting bases 
in Tables :ref:`JKFIT <table:basisDunningJKFIT>`,
:ref:`RI <table:basisDunningMP2FIT>`, and :ref:`DUAL <table:basisDunningDUAL>`
are available for methods incorporating density-fitting or dual-basis
approximations. JKFIT sets are appropriate for fitting :math:`(oo|`\ -type products,
such as encountered in SCF theory and the electrostatics/exchange terms of SAPT.
RI sets are appropriate for fitting :math:`(ov|`\ -type products, such as encountered in
MP2 and most SAPT terms.  Citations for basis sets can be found in their
definition files at :source:`psi4/share/psi4/basis` in the source.  For basis set availability by
element and the default value for keyword |globals__puream|, consult
Appendix :ref:`apdx:basisElement`.

|
|

.. _`table:basisPopleOrbital`:

.. table:: Summary of Pople-style orbital basis sets available in |PSIfour| [#f1]_

    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | no diffuse                     | heavy-augmented                  | augmented                          |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | basis set       | alias        | basis set        | alias         | basis set         | alias          |
    +=================+==============+==================+===============+===================+================+
    | STO-3G          |              |                  |               |                   |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 3-21G           |              |                  |               |                   |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-31G           |              | 6-31+G           |               | 6-31++G           |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-31G(d)        | 6-31G\*      | 6-31+G(d)        | 6-31+G\*      | 6-31++G(d)        | 6-31++G\*      |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-31G(d,p)      | 6-31G\*\*    | 6-31+G(d,p)      | 6-31+G\*\*    | 6-31++G(d,p)      | 6-31++G\*\*    |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G          |              | 6-311+G          |               | 6-311++G          |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(d)       | 6-311G\*     | 6-311+G(d)       | 6-311+G\*     | 6-311++G(d)       | 6-311++G\*     |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(d,p)     | 6-311G\*\*   | 6-311+G(d,p)     | 6-311+G\*\*   | 6-311++G(d,p)     | 6-311++G\*\*   |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2d)      |              | 6-311+G(2d)      |               | 6-311++G(2d)      |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2d,p)    |              | 6-311+G(2d,p)    |               | 6-311++G(2d,p)    |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2d,2p)   |              | 6-311+G(2d,2p)   |               | 6-311++G(2d,2p)   |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2df)     |              | 6-311+G(2df)     |               | 6-311++G(2df)     |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2df,p)   |              | 6-311+G(2df,p)   |               | 6-311++G(2df,p)   |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2df,2p)  |              | 6-311+G(2df,2p)  |               | 6-311++G(2df,2p)  |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(2df,2pd) |              | 6-311+G(2df,2pd) |               | 6-311++G(2df,2pd) |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(3df)     |              | 6-311+G(3df)     |               | 6-311++G(3df)     |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(3df,p)   |              | 6-311+G(3df,p)   |               | 6-311++G(3df,p)   |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(3df,2p)  |              | 6-311+G(3df,2p)  |               | 6-311++G(3df,2p)  |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(3df,2pd) |              | 6-311+G(3df,2pd) |               | 6-311++G(3df,2pd) |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+
    | 6-311G(3df,3pd) |              | 6-311+G(3df,3pd) |               | 6-311++G(3df,3pd) |                |
    +-----------------+--------------+------------------+---------------+-------------------+----------------+

|
|

.. _`table:basisMonths`:

.. table:: Levels of truncation for diffuse functions in standard basis sets

    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | augmentation level       | angular momenta in the diffuse space [#f4]_                                                                                       | valid basis sets                                       |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    |                          | Li-Kr main group                                                                     | H & He                                     | D\ :math:`\zeta` | T\ :math:`\zeta` | Q\ :math:`\zeta` |
    +==========================+======================================================================================+============================================+==================+==================+==================+
    | aug-cc-pVXZ              | s, p, :math:`\cdots`, :math:`\ell_{max}-2`, :math:`\ell_{max}-1`, :math:`\ell_{max}` | s, p, :math:`\cdots`, :math:`\ell_{max}-1` |  aDZ             |  aTZ             |  aQZ             |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | heavy-aug-cc-pVXZ [#f2]_ | s, p, :math:`\cdots`, :math:`\ell_{max}-2`, :math:`\ell_{max}-1`, :math:`\ell_{max}` |                                            | haDZ             | haTZ             | haQZ             |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | jun-cc-pVXZ              | s, p, :math:`\cdots`, :math:`\ell_{max}-2`, :math:`\ell_{max}-1`                     |                                            | jaDZ             | jaTZ             | jaQZ             |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | may-cc-pVXZ              | s, p, :math:`\cdots`, :math:`\ell_{max}-2`                                           |                                            |                  | maTZ             | maQZ             |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | :math:`\cdots`           | s, p                                                                                 |                                            |                  |                  | aaQZ             |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+
    | cc-pVXZ                  |                                                                                      |                                            |   DZ             |   TZ             |               QZ |
    +--------------------------+--------------------------------------------------------------------------------------+--------------------------------------------+------------------+------------------+------------------+


|
|

.. _`table:basisDunningOrbital`:

.. table:: Summary of Dunning orbital basis sets available in |PSIfour|

    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | basis set     | no diffuse | feb | mar | apr | may  | jun   | heavy-aug [#f2]_ | aug   | d-aug |
    +===============+============+=====+=====+=====+======+=======+==================+=======+=======+
    | cc-pVXZ       | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 | DTQ56 |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pV(X+d)Z   | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 | DTQ56 |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pCVXZ      | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 | DTQ56 |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pCV(X+d)Z  | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 | DTQ56 |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pwCVXZ     | DTQ5       |     | 5   | Q5  | TQ5  | DTQ5  | DTQ5             | DTQ5  | DTQ5  |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pwCV(X+d)Z | DTQ5       |     | 5   | Q5  | TQ5  | DTQ5  | DTQ5             | DTQ5  | DTQ5  |
    +---------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+

|
|

.. _`table:basisDunningDK`:

.. table:: Summary of Dunning Douglas-Kroll orbital basis sets available in |PSIfour|

    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | basis set        | no diffuse | feb | mar | apr | may | jun | heavy-aug [#f2]_ | aug    | d-aug |
    +==================+============+=====+=====+=====+=====+=====+==================+========+=======+
    | cc-pVXZ-DK       | DTQ5       |     |     |     |     |     | DTQ5             | DTQ5   |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | cc-pV(X+d)Z-DK   |            |     |     |     |     |     |                  |        |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | cc-pCVXZ-DK      | DTQ5       |     |     |     |     |     | DTQ5             | DTQ5   |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | cc-pCV(X+d)Z-DK  |            |     |     |     |     |     |                  |        |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | cc-pwCVXZ-DK     | --TQ5      |     |     |     |     |     | --TQ5            | --TQ5  |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | cc-pwCV(X+d)Z-DK |            |     |     |     |     |     |                  |        |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+

|
|

.. _`table:basisDunningF12`:

.. table:: Summary of Dunning F12 orbital basis sets available in |PSIfour|

    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+
    | basis set        | no diffuse | feb | mar | apr | may | jun | heavy-aug [#f2]_ | aug    | d-aug |
    +==================+============+=====+=====+=====+=====+=====+==================+========+=======+
    | cc-pVXZ-F12      | DTQ        |     |     |     |     |     |                  |        |       |
    +------------------+------------+-----+-----+-----+-----+-----+------------------+--------+-------+

|
|

.. _`table:basisDunningJKFIT`:

.. table:: Summary of Dunning JK-fitting basis sets available in |PSIfour|

    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | basis set              | no diffuse | feb | mar | apr | may | jun | heavy-aug [#f2]_ | aug  | d-aug |
    +========================+============+=====+=====+=====+=====+=====+==================+======+=======+
    | cc-pVXZ-JKFIT [#f3]_   | DTQ5       |     | 5   | Q5  | TQ5 | DTQ5| DTQ5             | DTQ5 |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | cc-pV(X+d)Z-JKFIT      | DTQ5       |     | 5   | Q5  | TQ5 | DTQ5| DTQ5             | DTQ5 |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | cc-pCVXZ-JKFIT [#f3]_  |            |     |     |     |     |     |                  |      |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | cc-pCV(X+d)Z-JKFIT     |            |     |     |     |     |     |                  |      |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | cc-pwCVXZ-JKFIT [#f3]_ |            |     |     |     |     |     |                  |      |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+
    | cc-pwCV(X+d)Z-JKFIT    |            |     |     |     |     |     |                  |      |       |
    +------------------------+------------+-----+-----+-----+-----+-----+------------------+------+-------+

|
|

.. _`table:basisDunningMP2FIT`:

.. table:: Summary of Dunning MP2-fitting basis sets available in |PSIfour|

    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | basis set        | no diffuse | feb | mar | apr | may  | jun   | heavy-aug [#f2]_ | aug   | d-aug |
    +==================+============+=====+=====+=====+======+=======+==================+=======+=======+
    | cc-pVXZ-RI       | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pV(X+d)Z-RI   | DTQ56      | 6   | 56  | Q56 | TQ56 | DTQ56 | DTQ56            | DTQ56 |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pCVXZ-RI      |            |     |     |     |      |       |                  |       |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pCV(X+d)Z-RI  |            |     |     |     |      |       |                  |       |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pwCVXZ-RI     | DTQ5       |     | 5   | Q5  | TQ5  | DTQ5  | DTQ5             | DTQ5  |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+
    | cc-pwCV(X+d)Z-RI | DTQ5       |     | 5   | Q5  | TQ5  | DTQ5  | DTQ5             | DTQ5  |       |
    +------------------+------------+-----+-----+-----+------+-------+------------------+-------+-------+

|
|

.. _`table:basisDunningDUAL`:

.. table:: Summary of Dunning dual-basis helper basis sets available in |PSIfour|

    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | basis set            | no diffuse | feb | mar | apr | may | jun | heavy-aug [#f2]_ | aug | d-aug |
    +======================+============+=====+=====+=====+=====+=====+==================+=====+=======+
    | cc-pVXZ-DUAL         | TQ         |     |     |     |     |     | TQ               | DTQ |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | cc-pV(X+d)Z-DUAL     |            |     |     |     |     |     |                  |     |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | cc-pCVXZ-DUAL        |            |     |     |     |     |     |                  |     |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | cc-pCV(X+d)Z-DUAL    |            |     |     |     |     |     |                  |     |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | cc-pwCVXZ-DUAL       |            |     |     |     |     |     |                  |     |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+
    | cc-pwCV(X+d)Z-DUAL   |            |     |     |     |     |     |                  |     |       |
    +----------------------+------------+-----+-----+-----+-----+-----+------------------+-----+-------+

|
|

.. _`table:basisKarlsruhe`:

.. table:: Summary of Karlsruhe orbital basis sets available in |PSIfour|

    +--------------+-------------+
    | no diffuse   | augmented   |
    +==============+=============+
    | def2-SV(P)   |             |
    +--------------+-------------+
    | def2-SVP     | def2-SVPD   |
    +--------------+-------------+
    | def2-TZVP    | def2-TZVPD  |
    +--------------+-------------+
    | def2-TZVPP   | def2-TZVPPD |
    +--------------+-------------+
    | def2-QZVP    | def2-QZVPD  |
    +--------------+-------------+
    | def2-QZVPP   | def2-QZVPPD |
    +--------------+-------------+

|
|


.. _`table:basisJensen`:

.. table:: Summary of Jensen orbital basis sets available in |PSIfour|

    +---------------+--------------+-----------+-------+------------------+
    | basis set     | no diffuse   | augmented | tight | augmented, tight |
    +===============+==============+===========+=======+==================+
    | pcseg-N       | 01234 [#f5]_ |           |       |                  |
    +---------------+--------------+-----------+-------+------------------+
    | aug-pcseg-N   |              | 01234     |       |                  |
    +---------------+--------------+-----------+-------+------------------+
    | pcSseg-N      |              |           | 01234 |                  |
    +---------------+--------------+-----------+-------+------------------+
    | aug-pcSseg-N  |              |           |       | 01234            |
    +---------------+--------------+-----------+-------+------------------+

|
|

.. _`table:basisPetersson`:

.. table:: Summary of Petersson orbital basis sets available in |PSIfour|

    +---------------+--------------+-----+
    | basis set     |  augmented, tight  |
    +===============+==============+=====+
    | nZaPa-NR      |    234567          |
    +---------------+--------------+-----+

|
|


.. _`table:basisOther`:

.. table:: Summary of other orbital basis sets available in |PSIfour|

    +----------------+
    | DZP            |
    +----------------+
    | TZ2P           |
    +----------------+
    | TZ2PF          |
    +----------------+
    | Sadlej-LPol-ds |
    +----------------+
    | Sadlej-LPol-dl |
    +----------------+
    | Sadlej-LPol-fs |
    +----------------+
    | Sadlej-LPol-fl |
    +----------------+

|
|

.. rubric:: Footnotes

.. [#f1] Corresponding basis set filenames have star replaced by "s", plus replaced by "p", and parenthesis and comma replaced by "_".
.. [#f2] The heavy-aug-cc-\ *stub* and jul-cc-\ *stub* basis sets are identical.
.. [#f3] The JKFIT basis sets are designed in the cc-\ *stub*\ (X+d)Z 
         framework that includes an additional set of
         *d*-functions for second-row *p*-block elements. Identical basis sets
         with the cc-\ *stub*\ XZ-JKFIT label are provided for convenience.
.. [#f4] D\ :math:`\zeta` has :math:`\ell_{max}=2` or d.
         T\ :math:`\zeta` has :math:`\ell_{max}=3` or f.
         Q\ :math:`\zeta` has :math:`\ell_{max}=4` or g, *etc*.
.. [#f5] *N* in Jensen basis sets corresponds to :math:`N+1\zeta` basis set.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: MCSCF

.. index::
   pair: MCSCF; theory

.. index::
   pair: CI; multi-configurational self-consistent-field

.. _`sec:mcscf`:

MCSCF: Multi-Configurational Self-Consistent-Field
==================================================

.. codeauthor:: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger
.. sectionauthor:: Daniel G. A. Smith and C. David Sherrill

*Module:* :ref:`Keywords <apdx:detci>`, :ref:`PSI Variables <apdx:detci_psivar>`, :source:`DETCI <psi4/src/psi4/detci>`

As the cost of Full CI scales exponentially with respect to the number of
active orbitals it is often advantageous to neglect orbitals that do not
exhibit strong correlation. These orbitals are variationally optimized
simultaneously with the CI coefficients and known as Multi-Configurational
Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the
complete-active-space self-consistent-field (CASSCF) approach [Roos:1980]_,
which includes all possible determinants (with the proper symmetry) that can be
formed by distributing a set of active electrons among a set of active
orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals
via a two-step procedure in which the CI coefficients and orbitals are
optimized in an alternating manner. The program uses a fairly simple
approximate orbital Hessian [Chaban:1997:88]_ and a Newton-Raphson update,
accelerated by Pulay's DIIS procedure [Pulay:1980]_. We have also implemented
the RASSCF method [Malmqvist:1990:RASSCF]_, which is another kind of MCSCF
which is typically less complete (and less expensive) than CASSCF.

Inactive orbitals in the MCSCF may be specified by the
|globals__restricted_docc| and |globals__restricted_uocc| keywords. These
orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the
MCSCF wavefunction.  However, the form of these orbitals will be optimized in
the MCSCF procedure.  It is also possible to literally freeze inactive orbitals
in their original (SCF) form using the |globals__frozen_docc| and
|globals__frozen_uocc| keywords.  This is not normally what one wishes to do in
an MCSCF computation (*e.g.*, it complicates the computation of gradients), but
it can make the computations faster and is helpful in some circumstances where
unphysical mixing of inactive and active occupied orbitals might occur.
Presently, it is not possible to mix the use of restricted and frozen orbitals
in |PSIfour|.

An illustrative CASSCF example is as follows::

    molecule {
    O
    H 1 1.00
    H 1 1.00 2 103.1
    }
    
    set {
        basis           6-31G**
        restricted_docc [1, 0, 0, 0]
        active          [3, 0, 1, 2]
    }
    energy('casscf')

This input will compute the CASSCF energy of water where the 1s Oxygen orbital
and several virtual orbitals are not included in the CI expansion, but are
still optimized. The following is a full list of spaces within the various MCSCF
types.

.. _`table:mcscf_spaces`:

.. table:: Orbital spaces for MCSCF computations

    +----------------------------+----------------------------+
    | RASSCF                     | CASSCF                     |
    +============================+============================+
    | |globals__frozen_uocc|     | |globals__frozen_uocc|     |
    +----------------------------+----------------------------+
    | |globals__restricted_uocc| | |globals__restricted_uocc| |
    +----------------------------+----------------------------+
    | |globals__ras4|            | |globals__active|          |
    +----------------------------+                            +
    | |globals__ras3|            |                            |
    +----------------------------+                            +
    | |globals__ras2|            |                            |
    +----------------------------+                            +
    | |globals__ras1|            |                            |
    +----------------------------+----------------------------+
    | |globals__restricted_docc| | |globals__restricted_docc| |
    +----------------------------+----------------------------+
    | |globals__frozen_docc|     | |globals__frozen_docc|     |
    +----------------------------+----------------------------+

Basic MCSCF Keywords
~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/detci__mcscf_e_convergence.rst
.. include:: autodir_options_c/detci__mcscf_r_convergence.rst
.. include:: autodir_options_c/detci__mcscf_type.rst
.. include:: autodir_options_c/detci__mcscf_algorithm.rst
.. include:: autodir_options_c/detci__mcscf_maxiter.rst
.. include:: autodir_options_c/detci__mcscf_rotate.rst
.. include:: autodir_options_c/detci__mcscf_diis_start.rst


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_integrals`:

======================
Integrals in |PSIfour|
======================

Introduction
------------

|PSIfour| has a number of backends available to compute integrals. In order to
accomodate these options, while providing a clean interface to the programmer,
an abstraction layer is implemented within Libmints.  A recent upgrade to the
primary integral engine has seen some important changes to the way this
interface layer is used; this document is designed to aid new developers as
well as those familiar with the older calling conventions to ensure that the
most efficient calling conventions are applied.

The older style
---------------

A very simple loop that does not use permutational symmetry might look
something like this in the old scheme:

.. code-block:: cpp

    auto sieve = std::make_shared<ERISieve>(basisset, cutoff);
    auto factory= std::make_shared<IntegralFactory>(basisset);
    int deriv_level = 0;
    bool use_shell_pairs = true;
    auto eri = factory->eri(deriv_level, use_shell_pairs);
    const double* buffer = eri_->buffer();
    for (int P = 0; P < basisset->nshell(); ++P) {
        const auto& Pshell = basisset->shell(P);
        for (int Q = 0; Q < basisset->nshell(); ++Q) {
            const auto& Qshell = basisset->shell(Q);
            for (int R = 0; R < basisset->nshell(); ++R) {
                const auto& Rshell = basisset->shell(R);
                for (int S = 0; S < basisset->nshell(); ++S) {
                    const auto& Sshell = basisset->shell(S);
                    if(sieve->shell_significant(P, Q, R, S) {
                        eri->compute_shell(P, Q, R, S);
                        // results are in buffer, do something with them..
                    }
                }
            }
        }
    }

An integral factory is used, which can then produce integral object for various
operator types and derivative levels.  A sieve is also constructed; this allows
a quick determination of whether an integral shell quartet will be significant
in magnitude or not, potentially saving a lot of work.  This simple scheme is
clean and easy to understand, and is still supported in the latest version of
|PSIfour| with only a small change to the sieve syntax and handling of buffer
addresses, noted below.

The new syntax
--------------

The newer integral engines being interfaced to |PSIfour| may or may not require
a group of similar integrals to be computed together in a block using
vectorized instructions.  To accomodate this possibility, a new syntax has been
introduced in Libmints:

.. code-block:: cpp

    auto blocksPQ = ints[0]->get_blocks12();
    auto blocksRS = ints[0]->get_blocks34();

    auto factory= std::make_shared<IntegralFactory>(basisset);
    int deriv_level = 0;
    bool use_shell_pairs = true;
    bool needs_exchange = true;
    auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);
    const auto &buffers = eri->buffers();

    eri->update_density(D);
    bool use_batching = eri->maximum_block_size() > 1;

    // loop over all the blocks of (P>=Q|
    for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {
        const auto& blockPQ = blocksPQ[blockPQ_idx];
        // loop over all the blocks of |R>=S)
        size_t start = eri->first_RS_shell_block(blockPQ_idx);
        for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {
            const auto& blockRS = blocksRS[blockRS_idx];

            if (!eri->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;

            eri->compute_shell_blocks(blockPQ_idx, blockRS_idx);
            const auto* block_start = buffers[0];

            // Loop over all of the P,Q,R,S shells within the blocks.  We have P>=Q, R>=S and PQ<=RS.
            for (const auto& pairPQ : blockPQ) {
                const auto &P = pairPQ.first;
                const auto &Q = pairPQ.second;
                const auto& Pshell = basisset->shell(P);
                const auto& Qshell = basisset->shell(Q);
                const auto Pam = Pshell.am();
                const auto Qam = Qshell.am();
                for (const auto& pairRS : blockRS) {
                    const auto &R = pairRS.first;
                    const auto &S = pairRS.second;
                    const auto& Rshell = basisset->shell(R);
                    const auto& Sshell = basisset->shell(S);
                    const auto Ram = Rshell.am();
                    const auto Sam = Sshell.am();

                    size_t block_size = Psize * Qsize * Rsize * Ssize;
                    // When there are chunks of shellpairs in RS, we need to make sure
                    // we filter out redundant combinations.
                    if (use_batching && Pam == Ram && Qam == Sam && ((P > R) || (P == R && Q > S))) {
                        block_start += block_size;
                        continue;
                    }
                    const double* int_ptr = block_start;
                    // Query P,Q,R,S shells for metadata and loop over that quartet
                    // as usual, getting the integrals from the int_ptr buffer.
                    block_start += block_size;
                }
            }
        }
    }

Although this looks more complex, it's essentially doing the same thing.  There
are a number of differences that we'll highlight now.

Sieving
.......

This is one of two breaking changes to the old style syntax.  Instead of
constructing a sieve object, the integral object should be queried directly
using the exact same syntax.  Requests for whether a shell is significant or a
shell block is significant are both supported.  A sieve object is created if
matching basis sets are found in either the bra or the ket.  For a density
fitting integral (PQ|0A) where 0 is the null basis set and A is an auxiliary
basis set the (PQ| pair will be used to construct all of the sieving data.

Buffer address
..............

The old code copied integrals into a buffer owned by the integral object, whose
address remained constant and could be retrieved by the ``buffer()`` member
function.  To avoid unnecessary copies, the new code instead uses the integrals
directly from the underlying integral engine's memory, which may change with
each call to compute integrals.  The integral engine provides a
``std::vector<const double*>`` containing the pointers to the start of each
"chunk" of integrals.  For first derivatives there are 12 such "chunks", which
are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x
derivative with respect to the basis functions in shell P.  Note that all
integral derivatives are provided by the new integral code, unlike the previous
version where only 9 of 12 were provided and the user was responsible for using
translation invariance relationships to fill in the rest.  The addresses for
each chunk are updated in the vector after each call to compute integrals, so
the user should keep a const reference to that object, and query that for the
address of interest.

Density Screening
.................

The old code looked only at the integral to determine whether terms can be
avoided *a priori*.  However, if the integral is to be contracted with a
density or a density-like quantity, the screening can be performed on the
product, which yields more sparsity.  To enable this, simply call the integral
object's ``update_density`` member, passing it a SharedMatrix holding the
current density (remember that it changes during each iteration of the SCF) and
the product will be considered during screening.  If only coulomb-like terms
are to be computed, the ``needs_exchange`` argument to the integral object
constructor should be set to false, otherwise it should be true to correcly
account for products of the density and integrals that contribute to
exchange-like terms.

Shell blocking
..............

Each underlying integral engine knows whether it will use blocks, and will set up
the metadata automatically.  Instead of looping over individual shells, the
user should loop over blocks supplied by the integral object; these blocks will
be just a single shell quartet combination for the case where blocking is not
used. It is simple to loop over pairs within each block using C++11 syntax, as
demonstrated in the code snippet above.  Only shell pairs with significant
overlap are included in the shell block information, making this an efficient
way to loop over non-negligible terms.

Permutational symmetry
......................

The pairs within each block are optimized for efficiency.  First, they are
screened during the integral object's creation to ensure that only terms with
appreciable overlap are stored.  Second, only P,Q combinations that are
permutationally unique are stored, ordered with the higher angular momentum
first.  Therefore care must be taken to ensure that the missing permutations
are correctly accounted for when processing the integrals within the loop.  See
the DirectJK code in libfock for an example of using this scheme for a Fock
matrix build.

Using bra-ket symmetry
......................

In cases where there is no batching performed, bra-ket symmetry can be
trivially enforced by ensuring that one of the block indices is greater than or
equal to the other.  When batching is used, the situation is trickier; some ket
batches may contain a mixture of integrals that are bra-ket unique and those
that are not.  To handle this we must do a coarse check at the top of the loop
to see if *any* integrals in the batch are needed, which is implemented by
asking the integral engine where to start looping in the ket via the call to
``eri->first_RS_shell_block(PQpair_idx)``.  This is followed by a more fine
grained check within the loops to filter individual integrals in the case where
bra and ket have the same angular momentum and there's a possibility of a
handful of integrals coming from the ket that are redundant.  Note that the bra
is not batched in any of our engines currently: only the ket is.  For this
reason, density fitting integrals should be written as (A0|PQ) rather than
(PQ|A0) where possible, because we want the ket to contain more functions than
the bra for efficient blocking.

Instantiating integral objects
..............................

With sieving being introduced in the new integral objects, the cost of their
construction has increased.  Although significantly cheaper than computing
integrals themselves, construction of integral objects can be non-negligible,
especially if many threads are used.  For example, this pattern can be found in
old versions of the code:

.. code-block:: cpp

    std::vector<std::shared_ptr<TwoBodyAOInt>> ints;
    ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));
    for (int thread = 1; thread < num_threads; thread++) {
        ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));
    }

This builds many objects and the cost can add up.  With the new scheme,
integral objects are forced to implement a `clone()` member that can be used as
follows:

.. code-block:: cpp

    std::vector<std::shared_ptr<TwoBodyAOInt>> ints;
    ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));
    for (int thread = 1; thread < num_threads; thread++) {
        ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));
    }

This method only incurs the cost of creating a single integral object, and
performs much cheaper cloning operations to create the other objects for each
thread.  Moreover, if integral objects are created only in the initialization
of each code that uses them, and stored persistently, the cost of integral
object creation is further reduced.


One Electron Integrals in |PSIfour|
-----------------------------------

After version 1.5, we started transitioning the one electron integral code over to
use Libint2 instead of the old handwritten Obara-Saika code.  There are a
number of reasons motivating this switch.  For methods requiring
potentials and fields evaluated at many external sites, such as PCM and
polarizable embedding, the efficiency of the one electron integrals can be rate
limiting.  We also started to introduce integral screening, and it is important
to balance the screening used for one- and two-electron terms carefully, so this
is a good opportunity to re-evaluate the code.  Finally, given the complexity
of the OS recursion code, the switch to an external library leaves a more
compact codebase to maintain.  The one electron integrals which are not provided by Libint2
are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,
leading to removal of the OS code in version 1.6. An overview of the one electron integrals
is shown in table :ref:`table:oei_impl_summary`, together with the implementation they use.
The tips below serve as a guide to what changed,
why it changed, and how to interface with |PSIfour|'s one-electron integral
machinery now.

Calling ``compute_shell(int P, int Q)``
.......................................

The hand-implemented OS recursion code also took care of the Cartesian->pure
transformation (if required by the basis set).  The mechanism for handling this
was to provide a public facing ``compute_shell(int P, int Q)`` method for the
caller; this then looked up the appropriate ``GaussianShell`` objects that were
passed into the corresponding (private) ``compute_pair(GaussianShell &s1,
GaussianShell &s2)`` function that computed the integrals and transformed them
to the spherical harmonic basis, if needed.  The switch to Libint2 integrals
preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks
up the appropriate Libint2-compatible shells and hands them off to the
re-written, private ``compute_pair()`` routines, which call Libint2 directly.
Therefore, any calls to shell-pair level integral computations should look the
same as before the introduction of Libint2, however access to the integrals has
changed, as described below.

Accessing integrals
...................

Before the Libint2 transition, one electron integrals were computed in a flat
array, internally called `buffer_`, which was accessed through the integral
object's ``buffer()`` method.  For integrals with multiple operators, e.g.,
dipole operators that have three distinct components, the buffer was simply
elongated by the appropriate amount and the caller was responsible for striding
through each resulting batch correctly.  The Libint2 engines instead return a
list of pointers into each operator's batch of integrals, the ordering of which
are detailed on the Libint2 wiki.  For this reason, the call to ``buffer()``
that returns a single buffer must be replaced with a call to ``buffer()`` to
get a list of pointers; we recommend that be assigned the type ``const auto
&``.  For simple integrals, such as overlap or kinetic, only the buffer
corresponding to the zeroth element of this array contains integrals.

Derivative Integrals
....................

The old one electron integral code used translational invariance relations to
minimze the number of integrals to be computed, leaving the caller with some
bookkeeping to do to compute all terms.  For example, consider an overlap
integral: its value depends only on the relative separation of the two centers
and not their absolute positions in space.  Therefore, the derivative with
respect to center A is the negative of the same derivative with respect to
center B, so one is trivially gleaned from the other.  Extending this to second
derivatives, the same principle leads to the fact that double derivatives with
respect to center A are equal to double derivatives with respect to center B,
which are also equal to the negative of the mixed double derivatives with
respect to both center A and B.  The old code only provided the double
derivative with respect to center A, leaving the caller to determine the other
values.  The Libint2 engine instead provides all integrals, so the caller
simply needs to loop over all of the buffers provided in the appropriate order.

Changes to External Potential Engines
.....................................

Benchmarking showed that early versions of the old code spent a non-negligible
amount of time performing the Cartesian to spherical harmonic transformation of
the integrals, which is needed for most modern basis sets.  To improve
performance, we instead backtransformed the density to the Cartesian
representation (denoted "CartAO") and computed / contracted all integrals in
this Cartesian basis, eliminating the need to transform to spherical harmonics
as the integrals are computed.  This bottleneck no longer exists, so these
extra transformation steps have been removed as part of the switch to Libint2,
and the affected codes (PCM and CPPE interfaces) now compute the potential and
field integrals in the representation required by the basis set.

Also, note that the way external point charges are specified has changed.
Previously, a set of N external point charges would be specified by passing a
matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z
-- to the ``set_charge_field()`` member of the potential integral class.  The
same information is now passed using the more verbose
``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be
consistent with Libint2's convention.

New Operators Available
.......................

Libint2 provides a range of integrals that were previously not available in
|PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for
Ewald methods.  If new integrals are added to Libint2 but are not yet
interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to
alert the developers, who will be able to add the appropriate code.
Available integrals classes and parameters currently documented at 
`Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_


Shell Pairs
...........

To ensure consistency between one- and two-electron terms when screening, and
for efficiency reasons, shell pair lists should be used to iterate over pairs
of Gaussian shells.  These lists contain integer pair numbers, corresponding to
the pairs of shells that have sufficient overlap to survive the screening
process.  Iterating over these lists is simple:

.. code-block:: cpp

    const auto& shell_pairs = Vint->shellpairs();
    size_t n_pairs = shell_pairs.size();
    for (size_t p = 0; p < n_pairs; ++p) {
         auto P = shell_pairs[p].first;
         auto Q = shell_pairs[p].second;
         // do something with shells P and Q
    }

Note that list considers all P,Q pairs if the two basis sets differ, but only
P>=Q if the basis sets are the same; the caller should account for this
restricted summation in the latter case.


One Electron Integral Algorithm Overview
........................................

The following table summarizes which implementation is used
for each type of one electron integral in |PSIfour|.

.. _`table:oei_impl_summary`:

.. table:: Algorithms used for One Electron Integrals

    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Integral                   | Class                      | Implementation  | Comment                                                            |
    +============================+============================+=================+====================================================================+
    | Three-Center Overlap       | ``ThreeCenterOverlapInt``  | Libint2         | using ``libint2::Operator::delta`` for 4-center integrals          |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Angular Momentum           | ``AngularMomentumInt``     | M-D             |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Dipole                     | ``DipoleInt``              | Libint2         | no derivatives supported                                           |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Electric Field             | ``ElectricFieldInt``       | Libint2         | using first derivative of ``libint2::Operator::nuclear``           |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Coulomb Potential          | ``ElectrostaticInt``       | Libint2         | evaluated for a single origin and unity charge                     |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Kinetic                    | ``KineticInt``             | Libint2         |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Multipole Potential        | ``MultipolePotentialInt``  | M-D             | arbitrary order derivative of 1/R supported                        |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Multipole Moments          | ``MultipoleInt``           | M-D             | arbitrary order multipoles supported, including nuclear gradients  |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Nabla Operator             | ``NablaInt``               | Libint2         | using first derivative of ``libint2::Operator::overlap``           |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Overlap                    | ``OverlapInt``             | Libint2         |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Nuclear Coulomb Potential  | ``PotentialInt``           | Libint2         | assumes nuclear centers/charges as the potential                   |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | PCM Potential              | ``PCMPotentialInt``        | Libint2         | parallelized over charge points                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Quadrupole                 | ``QuadrupoleInt``          | Libint2         |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Traceless Quadrupole       | ``TracelessQuadrupoleInt`` | Libint2         |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+
    | Relativistic Potential     | ``RelPotentialInt``        | Libint2         |                                                                    |
    +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

Notes on Options
================

.. note:: The options referred to in the :ref:`sec:methods` section below
   and indexed in :ref:`apdx:options_c_module` are placed in ``set`` blocks as
   described in :ref:`sec:jobControl`, not as arguments to a Python function
   (like ``energy()``).

.. note:: All |PSIfour| keyword names and values are insensitive to case, both
   those that are placed in ``set`` blocks and as Python function arguments.
   The few exceptions are documented for the :py:func:`~psi4.database` function,
   where case structure must match the database file.

.. _`op_c_bool`:
.. _`op_c_boolean`:
.. note:: Boolean options can be specified by ``yes``, ``on``, ``true``, or ``1``
    for affirmative and ``no``, ``off``, ``false``, or ``0`` for negative,
    all insensitive to case.

.. _`op_c_conv`:
.. note:: Certain convergence and tolerance keywords, of type *double* (real numbers),
   may be specified using either a real number or an integer; and integer *X* is then
   treated as the number of converged decimal digits required. For example, to request
   as energy converged to :math:`10^{-6} E_h`, the user may set the ``e_convergence``
   keyword to ``0.000001``, ``1.0e-6``, or ``6``.

.. _`sec:psivarnotes`:

Notes on Psivars
================

.. note:: Starting in 1.6, there are three standard ways to access an excited state
   property. We give examples below, but the method name and property name may change.
   * ``method ROOT 0 -> ROOT m property`` to get root m.

   * ``method ROOT 0 -> ROOT m property - h TRANSITION`` to get root m and
      independently specify that the total transition symmetry is h, e.g., A2.

   * ``method ROOT 0 (h) -> ROOT m (i) property`` to get the transition
     between two roots, specifying the symmetry of both states and the index of the target
     roots among states of their own symmetry.

   For example, to target the second excited-state, which is also the lowest energy state
   of its irrep, the first two calls will take m = 2, while the last takes m = 0.
   Methods that use this interface are: TD-fctl.
   Note that numberings are associated with the calculation much more strongly than 
   with the molecular system. Changing the number of roots sought, the symmetry 
   subspace or the symmetry apportionment of roots under which the computation is run, 
   or the excited state method are all likely to scramble root numberings.

Alternate Implementations
=========================

Depending on the reference (RHF, UHF, ROHF) and the integral treatment
(conventional CONV, density-fitted DF, and Cholesky-decomposed CD),
computational methods are sometimes implemented by multiple coders or even
multiple times. |PSIfour| transparently selects the most efficient
implementation, so one generally needn't consult this table. However, to
understand the details of what combinations are accessible or what
alternate implementations are available, read on.

Below, "Y" means method available in module, "D" means module is default
for that method, and "" means method not available. HF, DFT, and MP2
default to density-fitted integrals, while all higher methods default to
conventional integrals. Therefore, for a closed-shell molecule:

* runs MP2 with default ``DF`` with default implementation :ref:`DFMP2 <sec:dfmp2>` ::

    energy('mp2')

* runs MP2 with ``CONV`` with default implementation :ref:`OCC <sec:occ_nonoo>` ::

    set mp2_type conv
    energy('mp2')

* runs MP2 with default ``DF`` with implementation :ref:`OCC <sec:occ_nonoo>` ::

    set qc_module occ
    energy('mp2')


.. _`table:managedmethods`:

.. table:: Overlapping capabilities of |PSIfour|. "Y" is available; "D" is default.

    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | name                 | |globals__qc_module| | :py:func:`~psi4.energy()`                                                | :py:func:`~psi4.gradient()`                                  |
    +                      +                      +------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | _                    | |scf__reference|     | RHF                    | UHF                    | ROHF                   | RHF                | UHF                | ROHF               |
    +                      +                      +------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | type select [#f1]_   | _                    | CV   | DF       | CD   | CV   | DF       | CD   | CV       | DF   | CD   | CV   | DF   | CD   | CV   | DF   | CD   | CV   | DF   | CD   |
    +======================+======================+======+==========+======+======+==========+======+==========+======+======+======+======+======+======+======+======+======+======+======+
    | .. _tlmp2:           | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | mp2                  | DETCI                | Y    |          |      |      |          |      | Y        |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__mp2_type|  | DFMP2                |      | D [#f2]_ |      |      | D [#f2]_ |      |          | D    |      |      | D    |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | Y    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  | D    | Y        | D    | D    | Y        | Y    | D        | Y    | D    | D    | Y    |      | D    | D    |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlmp3:           | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | mp3                  | DETCI                | Y    |          |      |      |          |      | Y [#f3]_ |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__mp_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | Y    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  | D    | D        | D    | D    | D        | D    |          |      |      | D    | D    |      | D    | D    |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlmp25:          | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | mp2.5                | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__mp_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  | D    | D        | D    | D    | D        | D    |          |      |      | D    | D    |      | D    | D    |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlmp4:           | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | mp4                  | DETCI                | Y    |          |      |      |          |      | Y [#f3]_ |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__mp_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tllccd:          | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | lccd                 | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__cc_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  | Y    | D        | D    | D    | D        | D    |          |      |      | D    | D    |      | D    | D    |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tllccsd:         | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | lccsd, cepa(0)       | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__cc_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlccsd:          | CCENERGY             | D    |          |      | D    |          |      | D        |      |      | D    |      |      | D    |      |      | D    |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | ccsd                 | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__cc_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | Y    | D        | D    |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      | Y        | Y    |      |          |      |          |      |      |      | D    |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlccsdt:         | CCENERGY             | D    |          |      | D    |          |      | D        |      |      | D    |      |      | D    |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | ccsd(t)              | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__cc_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | Y    | D        | D    |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      | Y        | Y    |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlccsdat:        | CCENERGY             | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | a-ccsd(t) [#f4]_     | DETCI                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__cc_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      | D        | D    |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tlcisd:          | CCENERGY             |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | cisd                 | DETCI                | Y    |          |      |      |          |      | D        |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | |globals__ci_type|   | DFMP2                |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | FNOCC                | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    |                      | OCC                  |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | .. _tladc2:          | ADCC                 | Y    |          |      | D    |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+
    | adc(2)               | BUILTIN              | D    |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +                      +                      +      +          +      +      +          +      +          +      +      +      +      +      +      +      +      +      +      +      +
    | |globals__mp_type|   |                      |      |          |      |      |          |      |          |      |      |      |      |      |      |      |      |      |      |      |
    +----------------------+----------------------+------+----------+------+------+----------+------+----------+------+------+------+------+------+------+------+------+------+------+------+

.. rubric:: Footnotes

.. [#f1] Algorithm type selection keyword below. Values to the right: conventional ``CONV`` (here abbreviated CV), density-fitted ``DF``, and Cholesky-decomposed ``CD``.
.. [#f2] Also available for KS reference.
.. [#f3] Conditions have *no* default module (computationally inefficient) and can only be accessed by specifying |globals__qc_module|.
.. [#f4] Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:prog_psi4numpy`:

================================================
Psi4NumPy
================================================

Rapid initial development using Psi4NumPy
-----------------------------------------

Discuss what Psi4NumPy is, recommend it as a first step, point to repo,
mention paper

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:addAddOns`:

Adding Add-Ons
==============

.. _`faq:addonname`:

How to use an Add-On's name in directory structure, build, and distribution
---------------------------------------------------------------------------

* Select a name. May be mixed case with numerals and underscores
  (*e.g.*, CheMPS2, libefp, PCMSolver, v2rdm_casscf). Shouldn't start with a
  numeral. Needn't start with "lib", even if a library.

* GitHub repository name should be :samp:`{AddOn_name}` or
  :samp:`{AddOn_name}.lower()` (hereafter, :samp:`{addon_name}`. For example: CheMPS2, libefp, pcmsolver,
  v2rdm_casscf.

* CMake project name should be :samp:`{AddOn_name}`. For example:
  ``project(libefp)``, ``project(CheMPS2)``, ``project(PCMSolver)``,
  ``project(v2rdm_casscf)``. Namespacing in the directory structure used
  to detect the addon should have this name (*e.g.*,
  ``share/cmake/CheMPS2``).

* Restricted by the CMake project name, add-ons return CMake variables
  and compile definitions of :samp:`FOUND_{AddOn_name}` and
  :samp:`USING_{AddOn_name}`. For example: ``FOUND_libefp``,
  ``USING_CheMPS2``, ``PCMSolver_LIBRARIES``, ``USING_v2rdm_casscf``.

* The CMake target(s) formed use the full add-on name as the namespace,
  :samp:`{AddOn_name}::{lib_name_without_lib}.lower()`. For example:
  ``libefp::efp``, ``CheMPS2::chemps2``, ``PCMSolver::pcm``,
  ``v2rdm_casscf::v2rdm_casscf``.

* Following the CMake project name (though not restricted to it --
  |PSIfour| managment could change the pattern), the user flag to enable
  an add-on is :samp:`ENABLE_{AddOn_name}`. Note that runtime-only
  add-ons don't go through this enabling process.

* Internally, the ExternalProject_Add and dummy libraries as well as any
  tests/ and external/ subdirectories should all be lowercase,
  :samp:`{addon_name}`.

* The `conda package <https://anaconda.org/psi4/repo>`_ and internal to
  |PSIfour| (that is, the ExternalProject_Add, dummy libraries, and any
  tests/ and external/ subdirectories) should all be lowercase,
  :samp:`{addon_name}`.

* Alternatively, you can do everything mentioned here lowercase and just
  have a different capitalization for an advertising name. After all,
  that's what |PSIfour| does.


.. _`faq:addoncmake`:

How to integrate an Add-On into build, testing, and docs
--------------------------------------------------------

* In all cases, put Add-Ons in alphabetic order, ignoring any "lib" in the name.

* :source:`CMakeLists.txt`

  * Add the :samp:`ENABLE_{AddOn_name}` line

  * Add the :samp:`external_{addon_name}` dependency to the ``psi4-core`` external project

  * Add the :samp:`{AddOn_name}_DIR` variable passing to the ``psi4-core`` external project

* :source:`psi4/CMakeLists.txt`

  * Add a block imitating Libint if Add-On required or CheMPS2 if not
    required

  * If there are shared resources to the external that need
    to be found by |PSIfour| in PSIDATADIR, follow the ``efpfrag``
    pattern of libefp to symlink them in.

* :source:`psi4/src/CMakeLists.txt`

  * No changes should be required unless both (1) code in export_*
    or core.cc needs the :samp:`USING_{AddOn_name}` definition or
    AddOn header includes and (2) no binary |PSIfour| module (as
    opposed to library |PSIfour| module with the AddOn target linked
    is itself a direct dependency of target ``core``. Basically,
    try to leave this file alone, but if there are compile errors,
    add the definitions/headers as needed.

* :source:`psi4/src/psi4/`

  * If a module is needed to interface the AddOn to |PSIfour|, try to
    put "interface" in the name. Follow the pattern of CheMPS2 or gdma.
    If non-required, be sure to conditionalize it with ``if(TARGET
    AddOn::addon)`` in CMake files or ``#ifdef USING_AddOn`` in
    source files.

  * If a separate module is not required, follow the patter of dkh
    or simint with respect to libmints. Again, conditionalize as in
    preceding bullet.

* :source:`external/upstream/`

  * Add a CMakeLists.txt that imitates another AddOn of similar
    language and dependencies. Try to keep the format, messaging,
    and variables passed as similar as possible so that differences
    mean something. If BLAS/LAPACK or other common dependencies in
    :source:`external/common` are needed, be sure to add them to the
    ``DEPENDS`` argument.

  * The usual practice to to get everything cohesive between
    the CMake for the AddOn repository and |PSIfour| and then as a
    last step, mint a tag in the former and add it to two places in
    :samp:`external/upstream/{addon_name}/CMakeLists.txt` and one
    place in :source:`psi4/CMakeLists.txt` so that only that version
    and later are acceptable to |PSIfour| for detecting pre-built.

* :source:`tests/`

  * In :source:`tests/CMakeLists.txt`, add a block adding a tests subdirectory if Add-On enabled

  * Create new subdirectory :samp:`tests/{addon_name}` with a
    CMakeLists.txt. In that add a few tests. Imitate the pattern in
    other subdirs of including the addon prefix to the test name in the
    CMakeLists but not in the test dir name. Make sure the tests get the
    addon CTest label and that at least one of them gets the smoke label.

* :source:`doc/sphinxman/`

  * Create a new `.rst` page, copying one of the Add-Ons with similar
    language and dependency requirements. Edit it
    as appropriate. Add this page to the list in
    :source:`doc/sphinxman/source/interfacing.rst`.

  * Add a bullet to :source:`doc/sphinxman/source/build_planning.rst`

  * Add the new page to the long list in
    :source:`doc/sphinxman/CMakeLists.txt`. If there are any files or
    images referred to, add them to the file, too, following precedent.

else
----

* Build conda packages

  * Recipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes

* |PSIfour| and Add-On Projects Working Together

  * Obligations of the External Project owners are to:

    (1) allow us to contribute some CMake files to your build system
        so that compile flags and dependencies (e.g., BLAS/LAPACK) can be
        consistent with the |PSIfour| build and so the installed project can
        be readily detected by |PSIfour| or any interested party (through a
        CMake imported target).

    (2) provide us a tag at a tested commit/version number so their
        development may be ongoing.

    (3) communicate with us when they've made improvements and minted
        a new tag.

  * In return, for Add-Ons the |PSIfour| project will:

    (1) leave control of their code under your purview.

    (2) maintain any interfacing code needed.

    (3) regularly run integration tests between |PSIfour| and your code.

    (4) build a mostly statically linked conda package so that any
        of your users can obtain a pre-built binary distribution through
        ``conda install addon --channel psi4``.

    (5) provide a development sandbox for your code through |PSIfour| plugins.

    (6) provide conda download counts independent of |PSIfour|.


.. _`faq:readoptions`:

How to name keywords in ``psi4/src/read_options.cc``
----------------------------------------------------

A few guidelines for standardizing option names among modules.

* ``TRIPLES`` (not trip), ``TRIPLETS`` (not trip), ``SINGLES`` (not sing),
  ``SINGLETS`` (not sing)

* ``CONVERGENCE`` (not conv, not converge) and ``TOLERANCE`` (not tol)

* Convergence of a method should be governed by an ``E_CONVERGENCE`` for
  energy and either a ``D_CONVERGENCE`` for density or a ``R_CONVERGENCE``
  for residual/amplitudes. All of these should be doubles- let the input
  parser handle the flexible input format.

* Diis should have a boolean ``DIIS`` (not do_diis, not use_diis) to turn
  on/off diis extrapolation, a ``DIIS_MIN_VECS`` and ``DIIS_MAX_VECS`` for
  minimum and maximum number of diis vectors to use, and a ``DIIS_START``
  which is the iteration at which to start saving vectors for diis. Not all
  modules conform to all these at present, but they're as standardized as
  they can be without changing code.

* ``AMPS`` (not amplitude, not amp) for amplitudes

* ``NUM_`` (not n) for number (e.g., ``NUM_AMPS_PRINT``, ``MAX_NUM_VECS``,
  ``NUM_THREADS``)

* Some names that could be split into multiple words are staying as one.
  Use ``MAXITER``, ``CACHELEVEL``, ``PUREAM``, ``DERTYPE``.

* ``INTS`` (not integrals), also ``OEI`` (not oe_integrals) for
  one-electron integrals and ``TEI`` (not te_integrals) for two-electron
  integrals

* ``PERTURB`` (not pert) for perturbation

* Use ``PRINT`` options to indicate printing to output file. Use ``WRITE``
  options to indicate printing to another file. This probably isn't
  entirely valid now but should be observed in future. The complement to
  ``WRITE`` is ``READ``. ``PRINT``, ``READ``, and ``WRITE`` will usually
  be the last words in an option name.

* Use ``FOLLOW_ROOT`` for the state to be followed in geometry optimizations

* ``WFN`` (not wavefunction)

* You're welcome to use ``WFN`` and ``DERTYPE`` as internal options, but
  plan to have these set by the python driver and mark them as ``!expert``
  options. Really avoid using ``JOBTYPE``.

* You're not welcome to add ``CHARGE`` or ``MULTP`` options. Plan to get
  these quantities from the molecule object. Since we frequently use subsets
  of systems (with their own charge and multiplicity), this is safer.

* Conform. Just grep ``'add' psi4/src/read_options.cc`` to get a list of
  all the option names in |PSIfour| and try to match any conventions you
  find.

* If you have a quantity you'd like to call a cutoff, a threshold, a
  tolerance, or a convergence, consider the following guidelines in naming
  it.

  * If its value is typically greater than ~0.001, give it a name with ``CUTOFF``.

  * If its value is typically less than ~0.001 and quantities being tested
    against the option are more valuable with larger values (e.g.,
    integrals, occupations, eigenvectors), give it a name with ``TOLERANCE``.

  * If its value is typically less than ~0.001 and quantities being tested
    against the option are more valuable with smaller values (e.g., energy
    changes, residual errors, gradients), give it a name with
    ``CONVERGENCE``.

* In deciding how to arrange words in an option name, place the context
  first (e.g., ``MP2_AMPS_PRINT``, ``TRIPLES_DIIS``). This means ``PRINT``
  will generally be at the end of an option name.

* Use ``INTS_TOLERANCE`` (not schwarz_cutoff)

* ``H`` in an option name is reserved for Hamiltonian (or hydrogen).
  Hessian should be ``HESS``.

* All option names should be all caps and separated by underscores.

* If you have an option that instructs your module to do something not too
  computationally intensive and then quit, append ``_EXIT`` to the option
  name.

* Scaling terms (like for scs) should follow the pattern ``MP2_SS_SCALE``
  and ``SAPT_OS_SCALE``.

* ``FRAG`` for fragment.

* ``AVG`` for average.

* For level-shifting, let's try to have it governed by (double)
  ``LEVEL_SHIFT`` only and not a boolean/double combo since the procedure
  can be turned on (role of boolean) if the value (role of double) has
  changed.

* For Tikhonow regularization, use ``TIKONOW_OMEGA``, not regularizer.

* ``SYM`` for symmetry.

* ``OCC`` for occupied/occupation (e.g., ``DOCC``, ``LOCK_OCC``, ``OCC_TOLERANCE``).

* ``COND`` for condition and ``CONDITIONER`` for conditioner.

* ``LOCAL`` (not localize).

* Use ``AO`` and ``MO`` for atomic and molecular orbitals. When 'O' for
  orbitals is too obsure or would make for too short a keyword, as in
  "bool NO" for "Do use natural orbitals", use ``ORBS`` for orbitals. So
  natural orbitals are ``NAT_ORBS`` and Brueckner orbitals are
  ``BRUECKNER_ORBS``.

* ``LEVEL`` (not ``LVL``, not ``LEV``).

* ``EX`` for excitation.

* ``VAL`` for valence.

* ``GEOM`` (not geo, not geometry).

* ``SYM`` (not symm, not symmetry).

* ``FILE`` (unless truly multiple FILES).

* ``WRITE``/``READ`` for info transfer across jobs. ``SAVE``/``RESTART``
  for same in context of restart.

* Damping should interface through option (double) ``DAMPING_PERCENTAGE``,
  where a value of 0.0 indicates no damping.

* Try to avoid ``COMPUTE`` or ``CALC`` in an option name. If it's a
  boolean like "opdm_compute" for "Do compute the one-particle density
  matrix", just use ``OPDM``.

* Properties should be governed by a ``PROPERTIES`` array for the root of
  interest or by a ``PROPERTIES_ALL`` array for all roots in a multi-root
  calc.  Since no module conforms to this right now, use ``PROPERTY``
  alone and ``PROP`` in multi-part option as ``PROP_ROOT``, ``PROP_ALL``,
  ``PROP_SYM`` to conform.

* Use ``DF`` (not ri) for density-fitting and resolution-of-the-identity
  option names. Only the basis sets are staying as -RI since that's what
  EMSL uses.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

Notes on Options
================

.. comment warning:: Python naming practices of file_that_includes_function.function_name()
   are followed below. In psi4 input files, it is only necessary to call the
   function name alone. That is, use ``energy('scf')``, not ``driver.energy('scf')``.

.. note:: The Python options referred to in the :ref:`sec:psithonFunc` section below
   are placed as arguments to a Python
   function (like ``energy()``), not in ``set`` blocks or commands.
.. comment and indexed in :ref:`apdx:options_py`

.. note:: All |PSIfour| keyword names and values are insensitive to case, both
   those that are placed in ``set`` blocks and as Python function arguments.
   The one exception is documented for the *subset* option in the :py:func:`~psi4.driver.wrapper_database.database`
   function, where case structure must match the database file.

.. _`op_py_bool`:

.. _`op_py_boolean`:

.. note:: Boolean options can be specified by ``yes``, ``on``, ``true``, or ``1``
    for affirmative and ``no``, ``off``, ``false``, or ``0`` for negative,
    all insensitive to case.

.. _`op_py_dertype`:

.. note:: The derivative level type for :py:func:`~psi4.optimize` and :py:func:`~psi4.frequency` functions can be specified by ``energy``, ``none``, or ``0`` for 0th derivative, ``gradient``, ``first``, or ``1`` for 1st derivative, and ``hessian``, ``second``, or ``2`` for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the :term:`POINTS <POINTS (FINDIF)>` option can be increased to ``5`` for greater accuracy at increased cost.

.. _`op_py_function`:

.. note:: Function option for the Psithon function called by the current function;
   the default is usually :py:func:`~psi4.energy`. See Sec. :ref:`sec:intercalls`
   for a fuller description. Note that the value of the keyword is a Python object
   and so is not wrapped in quotes like a string.

.. _`op_py_molecule`:

.. note:: The molecule to be acted upon by the current function; the default is the
   "active" molecule, which is the nearest preceeding molecule declared in a
   ``molecule mymol {...}`` block or in an ``activate(mymol)`` statement. Note
   that the value of this keyword (``mymol`` in the example) is a Python object
   and so is not wrapped in quotes like a string. Technically, this is a
   :py:class:`~psi4.core.Molecule` object.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:documentation`:

Updating the |PSIfour| Users' and Programmers' Manual
=====================================================

|PSIfours| documentation is generated by `Sphinx <https://www.sphinx-doc.org/>`_
and lives in :source:`doc/sphinxman`. It is available online at
`<http://psicode.org/psi4manual/master/index.html>`_
for the latest development branch.

Installing Sphinx
^^^^^^^^^^^^^^^^^

Installing Sphinx is only necessary to build the documentation 
yourself, locally. The docs are served from
from psicode, so most users and developers won't need Sphinx
installed. Nevertheless, installation is easy.
Math is rendered through MathJax, so LaTeX and dvipng are no longer needed.
The sphinx executable should be in your path at CMake configure time for
documentation targets to be available.

* Binary: ``conda install sphinx``
* Binary: ``conda env create -f devtools/conda-envs/docs-cf.yaml``
* Binary: ``pip install -U Sphinx``
* Source: https://pypi.org/project/Sphinx/

* Check:

   >>> which sphinx-build
   //anaconda/bin/sphinx-build
   >>> sphinx-build --version  # needs >= 3.5
   Sphinx (sphinx-build) 3.5.3
   >>> cmake
   ...
    -- Documentation targets available: sphinxman (html), sphinxmini (quick html), sphinxpdf (LaTeX --> PDF)
   ...

Documentation Structure
^^^^^^^^^^^^^^^^^^^^^^^

Sphinx has nice capabilities for extracting docstrings from python files,
presenting both auto-generated and narrative documentation in the same
format, hyperlinking within and to external websites, and generating
documentation in different formats from the same source. |PSIfours|
documentation is a unified document covering information for both users
and programmers in separate sections. From the top-level object directory,
build the following target (note that a working version of the |PSIfour|
executable is a requirement for building the
documentation). Only GNU Makefiles, not Ninja, works for the docs:

.. code-block:: console

    >>> make sphinxman
    # -OR-
    >>> cmake --build . --target sphinxman

This will build a full set of documentation in the ``html`` directory that can be viewed offline through any browser. ::

    doc/sphinxman/html/index.html
    
Much of the documentation is auto-generated from the source. At present,
this covers:

* Physical Constants: :source:`psi4/include/psi4/physconst.h`
* Python Driver: docstrings from \*.py files in :source:`psi4/driver`
* Databases: docstrings from \*.py files in :source:`psi4/share/psi4/databases`
* Basis Sets: \*.gbs files in :source:`psi4/share/psi4/basis`
* C++ Keywords: :source:`psi4/src/read_options.cc`
* Sample Inputs: input.dat files in :source:`samples`
* PSI Variables: variables and associated modules extracted from code and comments in the Python and C++ source
  * Modules scraped are the sections of :source:`psi4/src/read_options.cc`
  * Variables should be all-caps, except where representing substitutions, e.g., ``ROOT n -> ROOT m`` and double-quote ``"`` delimited, even in Python
  * Scraper looks for ``Process::environment.globals``, ``set_array_variable``, ``variables_``, etc. lines and comments in the C++ code
  * C-side, the module for the variable is determined by the directory where it's found.
  * Scraper looks for ``set_variable`` together with ``# P::e MODULE`` lines and comments in the Python code
  * Py-side, the module for the variable is specified by ``MODULE`` in the comment
  * When a variable is set by code in either language, e.g., ``variables_[varname.str()]`` rather than plain string, ``variables_["FCI TOTAL ENERGY"]``, add a plain string line as a single-line comment, so the scraper can find it.
  * Add new places to scrape for variables to :source:`doc/sphinxman/document_psivariables.pl`
  * For now, we're scraping both global and Wfn variables
  * All of these show up in referenceable appendices like ``apdx:detci_psivar``
* Plugins: ``doc.rst`` text, \*.py modules, and C++ keywords in ``psi4/tests/plugin_*`` plugin directories (disabled at the moment)
* PSI Files: scratch file names and numbers in :source:`psi4/include/psi4/psifiles.h`

Some documentation is even extracted from |PSIfour| objects at runtime.

* psi4: docstrings for the C++ submodule ``psi4.core`` and the Python submodule ``psi4.driver`` that comprise |PSIfour|. C++ docstrings from "core" and "export" files in :source:`psi4/src/`, and Py docstrings from :source:`psi4/driver/`.
* DFT: functional availability and characteristics as encoded in :source:`psi4/driver/procrouting/dft`
* BasisFamily: fitting basis sets for each orbital basis as encoded in :source:`psi4/driver/qcdb/basislistdunning.py` and :source:`psi4/driver/qcdb/basislistother.py`

Building all the documentation takes ~10 minutes. There is now good
dependency structure built into the :source:`doc/sphinxman/CMakeLists.txt`
, so very long builds should be infrequent (unless you're touching
:source:`psi4/src/read_options.cc` or the driver. Note that not all dependencies are
encoded (PSI variables, for instance, depend on every .cc file in the
source tree), so for a definitive doc build, remove (in the object
directory) ``doc/sphinxman`` and start from scratch.

Even ~10 minutes of build time can be annoying when developing
documentation and testing ``rst`` files. In that situation, use the target
below which builds only the written docs (not autodocs) in
``psi4/doc/sphinxman/source`` quickly, though with a lot of warnings for
unresolved links::

    >>> make sphinxmini

reStructuredText
^^^^^^^^^^^^^^^^

Sphinx files are written in reStructuredText (\*.rst). In the html
documentation, source code is available from the sidebar. Here are a
few resources on Sphinx formatting.

* `reStructuredText <http://docutils.sourceforge.net/docs/user/rst/quickref.html>`_
* `links example <https://github.com/sphinx-doc/sphinx/issues/5208#issuecomment-736259355>`_
* `rendered test document <http://docutils.sourceforge.net/test/functional/expected/standalone_rst_html4css1.html>`_
  *vs.* `source test document <http://svn.python.org/projects/external/docutils-0.5/docs/user/rst/demo.txt>`_
* `A third reStructuredText and Sphinx <http://openalea.gforge.inria.fr/doc/openalea/doc/_build/html/source/sphinx/rest_syntax.html>`_
* `Sphinx Docs <https://www.sphinx-doc.org/en/master/contents.html>`_

.. * `Another reStructuredText <http://people.ee.ethz.ch/~creller/web/tricks/reST.html>`_
.. * `LaTeX that Sphinx can handle <ftp://ftp.ams.org/ams/doc/amsmath/short-math-guide.pdf>`_

Math in the Codebase
^^^^^^^^^^^^^^^^^^^^

It is often useful to have mathematical expressions in docstrings or
comments in the code that are auto-documented into the manual. Such
locations include the ``#! comment`` comments at the top of test case
input files, the ``/*- comment -*/`` comments in
:source:`psi4/src/read_options.cc`, and the ``r""" comment """``
docstrings in python modules. (That ``r"""`` makes the string read
literally, so your LaTeX symbols aren't confused with escape characters.)
For the two former, math has traditionally
been written in LaTeX (with the special substitution ``@@`` for
subscripting underscore). The autodoc script has been trained to convert
inline LaTeX math to reST math, provided the expression within dollar
signs is offset from other text. That is, expressions of the form
:regexp:`^ $latex math$[., ]$` (pseudo-regex) are good, while ``H$_2$O`` and LaTeX tables
are not translated correctly. Python docstrings are absorbed as-is, so
please use reST math formatting (essentially ``$latex math$`` :math:`\Rightarrow`
``:math:`latex math```).
Starting around |PSIfour| 1.1, MathJax is used for in-browser LaTeX
rendering in place of offline PNG generation of math images. Check the
online rendering, as occasionally there will be errors even when the LaTeX
looked sound.

The Map of the Sphinx
^^^^^^^^^^^^^^^^^^^^^

* Adding a new Appendix or First-TOC-Level page

  Create your reST file and fill it with information. Add the name of your
  file to :source:`doc/sphinxman/source/appendices.rst` for an appendix or
  to :source:`doc/sphinxman/source/index.rst` for a first-TOC-level.
  Finally, add your file to the ``STATICDOC`` variable in
  :source:`doc/sphinxman/CMakeLists.txt`. Sphinx will now build with your
  new page.

* Adding a new module to "Theoretical Methods"

  Copy the file of a well-established module, like
  :source:`doc/sphinxman/source/sapt.rst`. Change the title, author, sec
  label, ref, and source labels at the top of the file to point instead to
  your code. Edit :source:`doc/sphinxman/source/methods.rst` to add the
  name of your file so that it will appear in the TOC tree. Add your file
  to the ``STATICDOC`` variable in
  :source:`doc/sphinxman/CMakeLists.txt`. Sphinx will now build with your new
  file.  Follow the models in existing methods pages to write your
  documentation. If you don't get all the keyword links, bibliography
  links, sample inputs, math, tables, etc. working in Sphinx, don't worry
  about it. A genie will probably come through and tidy up all your
  source.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #


.. index:: prerequisites, compiling, installing
.. _`sec:installFile`:

====================================
Compiling and Installing from Source
====================================

This section fulfills the duty of every Linux project to have an INSTALL
file detailing how to build it from source. Few (mostly packagers and
sysadmins) are expected to read this file as it is a broad guide to the
many choices in building this project. For a specific, well-tested,
and performance-tuned build path, see :psicode:`installs/latest`
(select "source"). For pre-built binaries again well-tested,
performance-tuned, and available for all common operating systems,
see :psicode:`installs/latest` (select "conda").


.. _`faq:cmakeviasetup`:

Planning: how to configure Psi4 and invoke CMake
------------------------------------------------

|PSIfour| is built through CMake. An abbreviated build guide can be found
:source:`within the source itself <CMakeLists.txt#L22>` .

CMake does a good job scanning your computer to locate libraries, header
files, and executables needed for compilation. So it's very possible that
from :samp:`{top-level-psi4-dir}` source directory, you can call :samp:`cmake -S.
-B{objdir}` without any further arguments, and it will invoke ``cmake``,
detect some appropriate defaults, configure the build, create a build
directory :samp:`{objdir}`, and complete, leaving you to only invoke
``make`` or Ninja in the new build directory.

Should this happy scenario not come to pass, or if the default build
options are not to your taste, use the links within :ref:`core
dependencies <faq:coredepend>` and :ref:`add-on dependencies
<faq:addondepend>` to plan a set of arguments to ``cmake`` tailored to
your computer. Proceed to :ref:`quick build <faq:buildquick>` or
:ref:`detailed build <faq:builddetailed>`.

.. The following topics may also be helpful.

.. * :ref:`faq:setuphelp`
.. * :ref:`faq:chooseobjdir`
.. * :ref:`faq:setupprefix`
.. * :ref:`faq:setuptype`
.. * :ref:`faq:setupmaxameri`


.. _`faq:buildquick`:

How to build and install Psi4, the compact version
--------------------------------------------------

This section outlines the main steps of configuring, compiling, and
installing |PSIfour|. More detail is given :ref:`here
<faq:builddetailed>`.

.. code-block:: console

    >>> cd {top-level-psi4-dir}
    >>> cmake -S. -Bobjdir [your configuration options]
    >>> cd objdir
    >>> make -j`getconf _NPROCESSORS_ONLN`
    >>> make install


.. _`faq:builddetailed`:

How to build, test, and install Psi4, in detail
-----------------------------------------------

**1. Plan Directories**

   Get ahold of the |PSIfour| codebase, and navigate to the top level source
   directory, hereafter :samp:`{top-level-psi4-dir}`.

   * :ref:`faq:obtainpsi4`

   ::

    >>> cd {top-level-psi4-dir}

   Choose a compilation directory, hereafter :samp:`{objdir}`

   * :ref:`faq:chooseobjdir`

   Choose an installation directory, hereafter :samp:`{prefix}`

   * :ref:`faq:setupprefix`

**2. Plan Configuration**

   Examine the strict and optional software requirements to make sure the
   target computer has all the necessary dependencies installed.

   * :ref:`faq:coredepend`
   * :ref:`faq:addondepend`

   Prepare any necessary or desired configuration options for ``cmake``,
   hereafter ``[your configuration options]``

   * :ref:`faq:setuphelp`
   * :ref:`faq:cmakeviasetup`

**3. Configure**

   Run CMake with planned options and directories, as below. It reports on
   software found or unfound as it scans the computer, then (upon success)
   creates :samp:`{objdir}` ready for compilation.

   ::

    >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]

**4. Compile**

   Compile the code (optional ``-j`` triggers parallel compilation).

.. code-block:: console

    >>> cd {objdir}
    >>> make -j`getconf _NPROCESSORS_ONLN`

**5. Test**

   Optionally, use CTest and Pytest to test the build.

   * :ref:`faq:minutetests`
   * :ref:`faq:subsettests`
   * :ref:`faq:testsoutput`
   * :ref:`faq:pytest`

.. code-block:: console

   >>> ctest -j`getconf _NPROCESSORS_ONLN`

   >>> make pytest

**6. Install**

   If tests pass, install the code.

   ::

   >>> make install

**7. Configure Runtime**

   To run |PSIfour| after installation, you need to configure a few variables:

   * :ref:`faq:runordinaryexe`
   * :ref:`faq:runordinarymodule`


.. _`faq:coredepend`:

What are the tools and dependencies strictly required for building Psi4
-----------------------------------------------------------------------

The core |PSIfour| build requires the software below. Note that
practically everything (including Python, CMake, NumPy, BLAS/LAPACK,
Libint, and even C++ compilers on Linux and Mac) can be
satisfied through conda. The links below give examples of how to configure
that software for |PSIfour| and any notes and warnings pertaining to it.

* :ref:`C++ and C Compilers <cmake:cxx>` (C++17 compliant)

* :ref:`Optimized BLAS and LAPACK libraries <cmake:lapack>` (preferably NOT one supplied by a standard
  Linux distribution)

* :ref:`Python interpreter and headers <cmake:python>` (3.8+) https://www.python.org/

* CMake (3.15+) https://cmake.org/download/

* NumPy (needed at runtime *and* buildtime) https://numpy.org/

* System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library

The following are also required for |PSIfour|, but if not detected, the
build system will automatically download and build.

* :ref:`gau2grid <cmake:gau2grid>` |w---w| :ref:`[what is gau2grid?] <sec:gau2grid>` :source:`[gau2grid min version] <external/upstream/gau2grid/CMakeLists.txt#L1>`

* :ref:`Libint <cmake:libint>` |w---w| :ref:`[what is Libint?] <sec:libint>` :source:`[Libint min version] <external/upstream/libint/CMakeLists.txt#L1>` (Libint2 as of Nov 2020; added by v1.4)

  * Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page

* :ref:`Libxc <cmake:libxc>` |w---w| :ref:`[what is Libxc?] <sec:libxc>` :source:`[Libxc min version] <external/upstream/libxc/CMakeLists.txt#L1>`
* pybind11 |w---w| `[what is Pybind11?] <https://pybind11.readthedocs.io/en/stable/>`_ :source:`[Pybind11 min version] <external/upstream/pybind11/CMakeLists.txt#L1>`
* QCElemental |w---w| `[what is QCElemental?] <https://qcelemental.readthedocs.io/en/latest/>`_

* QCEngine |w---w| `[what is QCEngine?] <https://qcengine.readthedocs.io/en/latest/>`_ (March 2019; added by v1.4)

Additionally, there are runtime-only dependencies:

* msgpack-python for MessagePack https://msgpack.org/ (transitive dependency of QCElemental; optional for QCElemental but required for |PSIfour|)

* NumPy https://numpy.org/

* networkx https://github.com/networkx/networkx (transitive dependency of QCElemental; optional for QCElemental but required for |PSIfour|)

* pint https://pint.readthedocs.io/en/latest/ (transitive dependency of QCElemental)

* pydantic https://pydantic-docs.helpmanual.io/# (transitive dependency of QCElemental)

* SciPy https://scipy.org/ (avoidable if necessary by following directions in runtime error message)

Dropped Dependencies:

* Boost (September 2016; dropped by v1.1)

* deepdiff https://github.com/seperman/deepdiff (May 2019; dropped by v1.4)

* MPFR https://www.mpfr.org/ (Mar 2022; dropped by v1.6) no longer needed to compile against Libint2


.. _`faq:addondepend`:

What are the add-on capabilities for Psi4 and what are their dependencies
-------------------------------------------------------------------------

Each of the items below is an independent additional capability that can
be built with |PSIfour|. Sub-items below are the respective additional
dependencies of the add-on. Select which, if any, you want, and examine
the links for appropriate enabling arguments to ``cmake``. Note that many
are available pre-built from conda.

* |PSIfour| Testing

  * CTest https://cmake.org/download/
  * Perl (for some coupled-cluster CTest tests) https://www.perl.org/
  * pytest (for installed testing) http://doc.pytest.org/en/latest/
  * pytest-xdist (for installed testing many tests at once) https://github.com/pytest-dev/pytest-xdist

* |PSIfour| Documentation (available pre-built at :psicode:`psi4manual/master/index.html`)

  * Sphinx (3.5+) http://sphinx-doc.org
  * Perl (for some auto-documentation scripts) https://www.perl.org/
  * nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/
  * sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme
  * See `["message" lines] :source:`doc/sphinxman/CMakeLists.txt` for advice on obtaining docs dependencies
  * See :source:`.github/workflows/docs.yml` for full docs building procedure to follow

* Ambit |w---w| https://github.com/jturney/ambit

* :ref:`CheMPS2 <cmake:chemps2>` |w---w| :ref:`[what is CheMPS2?] <sec:chemps2>` :source:`[CheMPS2 min version] <external/upstream/chemps2/CMakeLists.txt#L2>`

  * HDF5 https://support.hdfgroup.org/HDF5/
  * zlib http://www.zlib.net/

.. * :ref:`erd <cmake:erd>` |w---w| :ref:`[what is this?] <sec:erd>` `[min version] <https://github.com/psi4/psi4/blob/master/external/upstream/erd/CMakeLists.txt#L2>`_

  * :ref:`Fortran Compiler <cmake:fortran>`

* :ref:`dkh <cmake:dkh>` |w---w| :ref:`[what is dkh?] <sec:dkh>` :source:`[dkh min version] <external/upstream/dkh/CMakeLists.txt#L2>`

  * :ref:`Fortran Compiler <cmake:fortran>`

* :ref:`gdma <cmake:gdma>` |w---w| :ref:`[what is gdma?] <sec:gdma>` :source:`[gdma min version] <external/upstream/gdma/CMakeLists.txt#L2>`

  * :ref:`Fortran Compiler <cmake:fortran>`

* :ref:`PCMSolver <cmake:pcmsolver>` |w---w| :ref:`[what is PCMSolver?] <sec:pcmsolver>`

  * :ref:`Fortran Compiler <cmake:fortran>`
  * zlib http://www.zlib.net/

* :ref:`simint <cmake:simint>` |w---w| :ref:`[what is simint?] <sec:simint>` :source:`[simint min version] <external/upstream/simint/CMakeLists.txt#L2>`

Additionally, there are runtime-loaded capabilities:

* :ref:`PylibEFP & libefp <cmake:libefp>` |w---w| :ref:`[what is LibEFP?] <sec:libefp>` :source:`[LibEFP min version] <external/upstream/libefp/CMakeLists.txt#L1>`

* cfour |w---w| :ref:`[what is CFOUR?] <sec:cfour>`

* dftd3 |w---w| :ref:`[what is DFTD3?] <sec:dftd3>`

* gcp |w---w| :ref:`[what is gCP?] <sec:gcp>`

* mrcc |w---w| :ref:`[what is MPCC?] <sec:mrcc>`

* v2rdm_casscf |w---w| :ref:`[what is v2rdm_casscf?] <sec:v2rdm_casscf>`

* :ref:`sns-mp2 <sec:snsmp2>` |w---w| https://github.com/DEShawResearch/sns-mp2/commits/master

* resp |w---w| https://github.com/cdsgroup/resp

* gpu_dfcc |w---w| https://github.com/edeprince3/gpu_dfcc/commits/master

* OpenFermion-Psi4 |w---w| https://github.com/quantumlib/OpenFermion

* :ref:`cppe <sec:cppe>` |w---w| https://github.com/maxscheurer/cppe

* mp2d |w---w| https://github.com/Chandemonium/MP2D

* :ref:`FockCI <sec:fockci>` |w---w| https://github.com/shannonhouck/psi4fockci

* cct3 |w---w| https://github.com/piecuch-group/cct3

* :ref:`adcc <sec:adcc>` |w---w| https://github.com/adc-connect/adcc

* :ref:`BrianQC <sec:brianqc>` |w---w| https://www.brianqc.com/

* i-PI |w---w| http://ipi-code.org/

* psixas |w---w| https://github.com/Masterluke87/psixas

* MDI |w---w| https://github.com/MolSSI-MDI/MDI_Library


.. _`faq:condapsi4dev`:

How to use conda to get a Psi4 development environment
------------------------------------------------------

|PSIfour| has a lot of dependencies, some of which are complicated
to build. Fortunately, conda can supply them all. A conda
package ``psi4-dev`` is available to gather the dependencies
and build tools needed to compiler |PSIfour| from source. Go to
:psicode:`installs/latest`, select "source" and "nightly build" along
with Linux/Mac and a Python version. Follow its instructions to create
a conda environment that has a script ``psi4-path-advisor``. Running
``psi4-path-advisor --help`` shows more options. Running the script
without arguments gives a cmake command that supplies paths to dependency
conda packages to CMake's cache. You can add further cmake options to
this command when you execute it. Once the cmake command has built your
:samp:`{objdir}`, you can build |PSIfour|. Remember to activate this
conda environment during |PSIfour| running or development. There are a
few extra options to ``psi4-path-advisor`` to set up using conda's GNU
compilers (on Linux), conda's Clang compilers (on Mac; less reliably),
or your own Intel compilers backed by conda's GNU compilers (on Linux).

.. code-block:: console

   >>> git clone https://github.com/psi4/psi4.git && cd psi4
   >>> conda create -n p4dev psi4-dev python=3.8 -c psi4/label/dev
   >>> conda activate p4dev
   >>> `psi4-path-advisor --gcc`
   >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`


.. _`faq:setupmaxameri`:

How to configure code to use high angular momentum basis sets
-------------------------------------------------------------

The :ref:`Libint <sec:libint>` integral code handles
arbitrary order angular momentum (AM), but compiling that is
prohibitive. The build process for Libint2 takes longer than
for Libint1, so it's recommended to :ref:`use the conda packages
<faq:condamaxameri>`. The AM controlling keyword ``MAX_AM_ERI``
has definition changed a little from Libint1. It is used to ensure
that conventional energies can use at least ``MAX_AM_ERI`` zeta. See
:source:`/external/upstream/libint2/CMakeLists.txt` for a fuller
discussion of AM capabilities. Unless :makevar:`BUILD_Libint2_GENERATOR`
is set to ``ON``, an internal build of Libint2 will download a
pregenerated tarball of at least :makevar:`MAX_AM_ERI` AM. If you
want to build completely from generator source, turn on the keyword,
but parts can only run in serial and parts benefit from parallel, so
it's not recommended. All the AM generation settings would need to be
edited in the above ``CMakeLists.txt`` rather than passing them into
the |PSIfour| build directly.

* Build with Higher Angular Momentum

  .. code-block:: bash

   >>> cmake -DMAX_AM_ERI=6

* Relevant CMake Options:

  .. code-block:: bash

   MAX_AM_ERI=N        # The maximum angular momentum level (1=p, 2=d, 3=f,
                       # etc.) for the libint integrals and derivative
                       # integrals. A value of N implies a maximum first
                       # derivative of N-1, and maximum second derivative of
                       # N-2, so for an atom such as Neon, the default 5 gets
                       # you conventional cc-pV5Z for energies, cc-pVQZ for
                       # gradients, cc-pVTZ for frequencies and density-fitted
                       # cc-pVQZ for energies, cc-pVTZ for gradients, cc-pVDZ
                       # for frequencies. [default: 5]

Note that since |PSIfour| 1.1, it is possible to build Libint
independently (or install just the libint conda package), then have
any/all |PSIfour| builds detect that installation at compile-time.

To switch a finished build to a larger Libint, enter ``<objdir>``,
remove the result of ``make install`` (if ever invoked), remove
``external/upstream/libint/``. If earlier Libint was built
internally (as opposed to detecting an external installation),
remove ``stage/include/libint/``, ``stage/share/cmake/Libint/``,
``stage/lib/libint2.so.2``. Edit MAX_AM_ERI
value in ``CMakeCache.txt``. Reinvoke ``make`` and check the number
beside ``Found Libint`` in the CMake output.

Note that the same keyword MAX_AM_ERI controls Libint and simint. simint
can't compile above AM7, so you'll have to turn off simint to get an
internal compile of AM>=8 Libint. The keyword is only a lower bound for
detection, so you can set it at 7, have both Libint and simint enabled,
and point CMake toward a pre-built Libint AM8 just fine.

* :ref:`cmake:libint`


.. _`faq:condamaxameri`:

How to get high angular momentum integrals from conda
-----------------------------------------------------

Libint2 conda packages are available from conda for Linux, Mac, and Windows.

The Linux package has base ``MAX_AM_ERI=7`` and can run 7z energies
and gradients conventional, 6z energies and gradients density-fitted,
and qz Hessians both conventional and density fitted.

The Mac and Windows packages have base ``MAX_AM_ERI=5`` and can run
5z energies, qz gradients, and tz Hessians, both conventional and
density-fitted.

Details about angular momentum settings are available here
:source:`external/upstream/libint2/CMakeLists.txt`
.

.. Since February 2019, the |PSIfour| conda package on Linux has been the
.. large AM8. Likewise, this is the package you get upon ::
..
..     conda install libint -c psi4
..
.. There is no need for the extra ``am8`` argument previously documented here.
..
.. On Mac, the Libint conda package itself and the Libint compiled into
.. the |PSIfour| conda package remain AM6.
..
.. Beware this issue: https://github.com/psi4/psi4/issues/1533


.. _`faq:setuphelp`:

How to see what build configuration options are available
---------------------------------------------------------

CMake doesn't provide a summary for this (unless you want to try the CMake
GUI, which the developers have never looked at). However, the top half of
the main CMakeLists.txt is a passable summary:

.. literalinclude:: @SFNX_INCLUDE@CMakeLists.txt
   :lines: 14-142
   :language: none

Note that external projects will have their own sets of build
configuration options. Only the most-common user knobs of those are
mentioned above.

.. .. _`faq:setupd`:
.. ###<a name="setupd"></a> How to set CMake and Preprocessor options through the ``setup`` script
.. 
.. CMake can always be invoked directly to build Psi4 [](see active cmake). But more often you have a working ``setup`` configuration and just need to convey a couple CMake or Preprocessor variables.
.. 
.. * ###### Build with Hint Variable to CMake
.. 
..     ```
..     setup -DGSL_ROOT_DIR=$CONDA/envs/boostenv
..     ```
.. 
.. * ###### Relevant ``setup`` Options:
.. 
..     ```
..     -D STRING             forward directly to cmake (example: -D ENABLE_THIS=1
..                           -D ENABLE_THAT=1); you can also forward CPP definitions
..                           all the way to the program (example: -D CPP="-DDEBUG");
..                           also handle multi-word arguments
..                           (example: -D MORELIBS="-L/path/to/lib /path/to/lib2")
..                           (default: [])
..     ```
.. 
.. * ###### Relevant ``cmake`` Options:
.. 
..     ```
..     -DSTRING              -express to cmake
..     ```


.. _`faq:setupprefix`:

How to install elsewhere than :samp:`/usr/local/psi4`
-----------------------------------------------------

The installation directory is the filesystem location for the executable
script, the Python module, basis set data, and other administrative files.
Unless using the conda package, which is relocatable, the installation
directory must be specified with CMake variable ``CMAKE_INSTALL_PREFIX``
before compiling.

* Build with Specific Install Directory

  .. code-block:: bash

   cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4

* Relevant CMake Options:

  .. code-block:: bash

   CMAKE_INSTALL_PREFIX=PATH  # Location to which Psi4 and internally built
                              # add-ons are installed (default: /usr/local/psi4)

.. note:: It's not guaranteed, but if, in a pinch, you need to install a
   built Psi4 to a location *not* configured by ``CMAKE_INSTALL_PREFIX``,
   recursively copy the folders under :samp:`{objdir}/stage/{prefix}` to
   the desired location, ``chown`` them if needed, edit the shebang in
   ``bin/psi4`` if needed, and recursively delete all the ".pyc" files. It
   may just run.

.. ###<a name="profiling"></a>
.. 
.. How to set up a profiling build
.. ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. 
.. Specifying build type ``setup --type profile`` prepares a release build
.. type with the addition of extra flags for linking against the profiler
.. `gprof`.


.. _`faq:setuptype`:

How to compile for debugging
----------------------------

Flags to turn optimizations off and debugging on can be set across the
project and plugins with CMake variable ``CMAKE_BUILD_TYPE`` before
compiling. Note that these flags *will not* propagate to any add-ons that
are detected pre-built rather than built.

* Build without optimization

  .. code-block:: bash

    cmake -DCMAKE_BUILD_TYPE=debug

                                  set the CMake build type [default: release]

* Relevant CMake Options:

  .. code-block:: bash

    CMAKE_BUILD_TYPE=[debug|release]  # Build type (Release or Debug)" [default: release]



.. .. _`faq:setupobjdir`:
.. 
.. How to compile elsewhere than ``{top-level-psi4-dir}/objdir``
.. -------------------------------------------------------------
.. 
.. [How to choose the compilation directory, ``$objdir``](2_Planning#chooseobjdir)
.. 
.. * Build in Specific Directory
.. 
..   .. code-block:: bash
.. 
..    cd $top-level-psi4-dir
..    cmake -S. -Bobj-gcc
..    cd obj-gcc


.. .. _`faq:erroreriam`:
..
.. How to fix error "``RuntimeError: value for ERI``"
.. --------------------------------------------------
..
.. You will need to rebuild Libint. Reissue ``cmake`` or edit
.. ``CMakeCache.txt`` with larger ``MAX_AM_ERI`` and rebuild.
..
.. * :ref:`faq:setupmaxameri`
.. * :ref:`faq:condamaxameri`

.. _`faq:chooseobjdir`:

How to choose the compilation directory, ``{objdir}``
-----------------------------------------------------

* there is no default
* common choices are ``objdir`` or ``build`` under :samp:`{top-level-psi4-dir}`

  * ``cd {top-level-psi4-dir} && cmake -S. -Bobjdir``
  * ``cd {top-level-psi4-dir} && cmake -S. -Bbuild``

* in-source builds (``*.cc`` and ``*.o`` in same directory) are disallowed
* builds *outside* :samp:`{top-level-psi4-dir}` are permitted


.. _`faq:doconfigure`:

How to save configuration settings for a future compilation
-----------------------------------------------------------

Create a file like ``do-configure`` with the ``cmake`` command and options
*on one line*. ::

 >>> cd {top-level-psi4-dir}
 >>> cat do-configure
     cmake -S. -B{objdir} \
         -DCMAKE_INSTALL_PATH="/Users/me/psi4" \
         -DCMAKE_PREFIX_PATH="/Users/me/externals/install-libint" \
         -DMAX_AM_ERI=6 \
         -DENABLE_gdma=ON \
         -DBUILD_SHARED_LIBS=ON
 >>> chmod u+x do-configure
 >>> ./do-configure


.. _`faq:dirlayoutinstall`:

What is the directory layout of the installed or staged Psi4
------------------------------------------------------------

After compilation (:samp:`cd {objdir} && make`), a directory structure like the
below will exist at :samp:`{objdir}/stage`. This may be tested and used
just like a full installation.

After installation (:samp:`cd {objdir} && make && make install`), a directory
structure like the below will exist at :samp:`/{prefix}`. This is a full
installation.

.. code-block:: bash

 /
 bin/                                                   (executables for psi4 + any external proj)
 bin/psi4                                             (psi4 executable, actually just a py script)
 include/                                         (installed headers for psi4 + any external proj)
 include/psi4/                                                     (header files for #include-ing)
 include/psi4/psi4-dec.h                                                     (primary psi4 header)
 include/psi4/masses.h                                                (a project-wide psi4 header)
 include/psi4/libmints/                                                     (psi4 library headers)
 include/psi4/libfock/                                                                     (ditto)
 share/                                  (read-only arch-indep files for psi4 + any external proj)
 share/cmake/psi4/                                         (files for detecting installed targets)
 share/cmake/psi4/psi4Config.cmake                                       (psi4 build/install info)
 share/cmake/psi4/psi4ConfigVersion.cmake                                (psi4 cmake version info)
 share/doc/psi4/html/                                                  (sphinx html documentation)
 share/psi4/                                                           (text files needed by psi4)
 share/psi4/basis                                                                     (basis sets)
 share/psi4/plugins                                                        (plugin template files)
 share/psi4/fsapt                                                                  (fsapt scripts)
 share/psi4/samples/                                                          (sample input files)
 lib/                               (shared libraries and py modules for psi4 + any external proj)
 # ordinary
 lib/psi4/                                                                          (object files)
 lib/psi4/driver/                                                            (py-side, uncompiled)
 lib/psi4/header.py                                                           (prints file header)
 lib/psi4/metadata.py                                                          (psi4 version info)
 lib/psi4/__init__.py                                         (module marker/loader for psi4.core)
 lib/psi4/core.cpython-*.so                               (c-side, compiled and bound by pybind11)
 # conda
 lib/pythonX.X/site-packages/psi4/

The following environment variables point to certain places in the above
directory structure. None to few need to be set; see for details:
:ref:`running compiled executable <faq:runordinaryexe>`,
:ref:`running compiled Python module <faq:runordinarymodule>`,
:ref:`running conda binary <faq:runfrombinary>`.

* :envvar:`PATH` pointing to ``bin``
* :envvar:`PYTHONPATH` pointing to ``lib`` (ordinary) or ``lib/pythonX.X/site-packages`` (conda)
* :envvar:`PSIDATADIR` pointing to ``share/psi4``


.. _`faq:runordinaryexe`:

How to run Psi4 as executable after compilation
-----------------------------------------------

Substituting the full installation directory :samp:`{prefix}` and a
suitable scratch directory, issue the following commands directly in your
terminal or place them into your "rc" file and open a new terminal. (To
use a staged installation directory, substitute
:samp:`{objdir}/stage` for :samp:`{prefix}`.)

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    setenv PATH {prefix}/bin:$PATH
    setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    export PATH={prefix}/bin:$PATH
    export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files

Run |PSIfour|. ::

    >>> cat sample.in
    molecule {
    He
    }
    energy('hf/cc-pvdz')
    compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E')
    >>> psi4 sample.in
    SCF E.............................................................PASSED


.. _`faq:modulenotfounderror`:

How to solve ``ModuleNotFoundError: No module named 'psi4'``
------------------------------------------------------------

You're using |PSIfour| in PsiAPI mode (``python input.py`` where
``input.py`` contains ``import psi4``) but the Python interpreter
can't find the |PSIfour| Python module. Follow the directions at
:ref:`faq:psi4psiapipath`.


.. _`faq:psi4psiapipath`:

How to configure paths for PsiAPI
---------------------------------

If you know the location of the |PSIfour| executable (``bin/psi4``)
for Psithon mode and want to know the corresponding location to add to
:envvar:`PYTHONPATH` for PsiAPI mode, execute ``psi4 --psiapi``. It
will return bash commands to set :envvar:`PATH` (for correct python
interpreter) and :envvar:`PYTHONPATH` (to find psi4 module) correctly,
after which ``import psi4`` will work.

.. code-block:: bash

    >>> psi4 --psiapi-path
    export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH
    export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH

    >>> export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH
    >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH

    >>> python -c "import psi4"

    >>> python -c "import psi4;print(psi4.__file__, psi4.__version__)"


.. _`faq:runordinarymodule`:

How to run Psi4 as Python module after compilation
--------------------------------------------------

Substituting the full installation directory :samp:`{prefix}` and a
suitable scratch directory, issue the following commands directly in your
terminal or place them into your "rc" file and open a new terminal. (To
use a staged installation directory, substitute
:samp:`{objdir}/stage` for :samp:`{prefix}`.)

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    setenv PYTHONPATH {prefix}/lib:$PYTHONPATH
    setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    export PYTHONPATH={prefix}/lib:$PYTHONPATH
    export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files

* :ref:`faq:psi4psiapipath`

Run |PSIfour|. ::

    >>> cat sample.py
    import psi4
    mol = psi4.geometry("""
    He
    """)
    psi4.energy('hf/cc-pvdz')
    psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E')
    >>> python sample.py
    SCF E.............................................................PASSED


.. _`faq:runfrombinary`:

How to run Psi4 as executable or Python module from conda installation
----------------------------------------------------------------------

The configuration commands below are generic versions of the ones printed
to your screen as advice upon installing |PSIfour| into a Anaconda,
Miniconda, or Psi4conda distribution, :samp:`{condadist} =
{ana|mini|psi4}conda`. To see the message again after initial installation,
with the conda environment active, run ``.psi4-post-link.sh``.
If ``which conda python psi4`` points to your
:samp:`{condadist}` and ``echo $PSI_SCRATCH`` is set, skip ahead to the
"Run |PSIfour|\" commands below. Otherwise, issue the following
commands directly in your terminal or place them into your "rc" file and
open a new terminal.

If you installed the Psi4conda distribution or installed the |PSIfour|
conda package into the main environment of an Anaconda or Miniconda
distribution and added that to your :envvar:`PATH`, as prompted, then
``which psi4`` likely yields :samp:`{condadist}/bin/psi4` and the ``PATH``
setting lines below are redundant.

If you installed into a conda environment :samp:`{p4env}` and performed
:samp:`conda activate {p4env}`, then ``which psi4`` likely yields
:samp:`{condadist}/envs/{p4env}/bin/psi4` and the ``PATH`` setting lines
below are redundant.

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    unsetenv PSIDATADIR
    setenv PATH {prefix}/bin:$PATH
    setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    unset PSIDATADIR
    export PATH={prefix}/bin:$PATH
    export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files

.. If you installed the Psi4conda distribution or installed the |PSIfour|
.. conda package into the main environment of an Anaconda or Miniconda
.. distribution and added that to your :envvar:`PATH`, as prompted, then
.. :samp:`{condadist} = $HOME/{ana|mini|psi4}conda` and ``which psi4`` likely
.. yields :samp:`{condadist}/bin/psi4` and the ``PATH`` setting lines above
.. are redundant.

Run |PSIfour| as executable. ::

    >>> cat sample.in
    molecule {
    He
    }
    energy('hf/cc-pvdz')
    compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E')
    >>> psi4 sample.in
    SCF E.............................................................PASSED

*or* Run |PSIfour| as Python module. ::

    >>> cat sample.py
    import psi4
    mol = psi4.geometry("""
    He
    """)
    psi4.energy('hf/cc-pvdz')
    psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E')
    >>> python sample.py
    SCF E.............................................................PASSED


.. _`faq:inplace`:

How to run Psi4 as executable after compilation using driver from source
------------------------------------------------------------------------

When developing python driver code, it can be annoying to keep `make`\
ing to test the code. |PSIfour| can be run "inplace" through the
following procedure. To be clear, this is running compiled C++ from the
build directory and python from the source directory. This is an expert
option for development, and not all functionality will be available. ::

    >>> cd {objdir}
    >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so
    >>> python ../psi4/run_psi4.py --inplace input.dat


.. _`faq:psidatadir`:

Why not to set :envvar:`PSIDATADIR`
-----------------------------------

:envvar:`PSIDATADIR` is an environment variable containing the location of the
text resource parts of the |PSIfour| codebase (*e.g.*, basis sets,
databases, EFP fragments). It is for developer use only. In |PSIfour| 1.1
and beyond, the program *always* knows where its resources are, and the
only reason to set this variable is to point to another location.
Previously in |PSIfour| 1.0 and previous, only installed executables knew
the location, so it always needed to be explicitly set when run from the
compilation directory.

At runtime

.. code-block:: bash

   >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4

Or in the shell

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4




.. _`cmake:cxx`:

How to configure C++ and C compilers for building Psi4
------------------------------------------------------

**Role and Dependencies**

* Role |w---w| In |PSIfour|, a C++ compiler is vital for building the code.

* Downstream Dependencies |w---w| |PSIfour| |dr| C++ Compiler

**CMake Variables**

* :makevar:`CMAKE_CXX_COMPILER` |w---w| CMake variable to specify name or full path to C++ compiler.
* :makevar:`CMAKE_C_COMPILER` |w---w| CMake variable to specify name or full path to C compiler.
* :makevar:`CMAKE_CXX_FLAGS` |w---w| CMake variable to specify any additional custom compiler flags for C++ source.
* :makevar:`CMAKE_C_FLAGS` |w---w| CMake variable to specify any additional custom compiler flags for C source.

**Examples**

A. Build with detected compilers from :envvar:`PATH`

  .. code-block:: bash

    >>> cmake

B. Build with specific (Intel) compilers from :envvar:`PATH`

  .. code-block:: bash

    >>> cmake -DCMAKE_CXX_COMPILER=icpc -DCMAKE_C_COMPILER=icc

C. Build with specific (GNU) compilers *not* in :envvar:`PATH`

  .. code-block:: bash

    >>> cmake -DCMAKE_CXX_COMPILER=/path/to/gcc6.2/bin/g++ -DCMAKE_C_COMPILER=/path/to/gcc6.2/bin/gcc

D. Build with specific (Intel) compilers from :envvar:`PATH` based on GCC *not* in :envvar:`PATH`

  .. code-block:: bash

    >>> cmake -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_C_FLAGS="-gcc-name=${GCC5}/bin/gcc" \
              -DCMAKE_CXX_FLAGS="-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"

E. Build with specific (Intel) compilers from :envvar:`PATH` based on GCC *not* in :envvar:`PATH` and also building Fortran Add-Ons

  .. code-block:: bash

    >>> cmake -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_Fortran_COMPILER=ifort \
              -DCMAKE_C_FLAGS="-gcc-name=${GCC5}/bin/gcc" \
              -DCMAKE_CXX_FLAGS="-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++" \
              -DCMAKE_Fortran_FLAGS="-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"

F. Build with specific (Intel) compilers from :envvar:`PATH` based on GCC
   with prefix and *not* in :envvar:`PATH`
   (``GCCPFX=/full/path/to/bin/prefix-`` compiler is ``$GCCPFX-gcc``)

  .. code-block:: bash

    >>> cmake -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_C_FLAGS="-gnu-prefix=${GCCPFX}" \
              -DCMAKE_CXX_FLAGS="-gnu-prefix=${GCCPFX}"

G. Build on Linux with specific (Intel) compilers from :envvar:`PATH`
   based on GCC from conda in **activated** environment
   (:envvar:`CONDA_PREFIX` and :envvar:`HOST` are defined upon
   activation)

  .. code-block:: bash

    >>> cmake -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_C_FLAGS="-gnu-prefix=${CONDA_PREFIX}/bin/${HOST} --sysroot=${CONDA_PREFIX}/${HOST}/sysroot" \
              -DCMAKE_CXX_FLAGS="-gnu-prefix=${CONDA_PREFIX}/bin/${HOST} --sysroot=${CONDA_PREFIX}/${HOST}/sysroot"

H. Build on Linux with specific (GCC) compilers from
   from conda in **activated** environment
   (:envvar:`CONDA_PREFIX` and :envvar:`HOST` are defined upon
   activation)

  .. code-block:: bash

    >>> cmake -DCMAKE_C_COMPILER=${GCC} \
              -DCMAKE_CXX_COMPILER=${GXX} \
              -DCMAKE_Fortran_COMPILER=${GFORTRAN}


.. _`faq:approvedcxx`:

What C and C++ compilers and versions are approved
--------------------------------------------------

On Linux, the following work nicely.

  * GNU: ``gcc``, ``g++``
  * Intel: ``icc``, ``icpc``
  * Clang: ``clang``, ``clang++``

On Mac, the following work nicely.

  * Apple Clang: ``clang``, ``clang++``
  * Intel: ``icc``, ``icpc``

|PSIfour| requires *full* C++11 compliance, meaning, most importantly, GCC
>= 4.9. This compliance is checked for at build-time with file
:source:`cmake/custom_cxxstandard.cmake`, so either consult that file or
try a test build to ensure your compiler is approved. Note that Intel
compilers on Linux also rely on GCC, so both ``icpc`` and ``gcc`` versions are checked.
Intel OneAPI Classic compilers work fine. OneAPI beta compilers build but have
been only minimally tested.

* :ref:`faq:modgcc`


.. _`faq:macxcode`:

How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew
-----------------------------------------------------------------------------

The easiest compiler to obtain is ``clang`` which is a drop-in replacement
for ``gcc`` and ``g++``. Just install `XCode
<https://apps.apple.com/us/app/xcode/id497799835>`_. Some old versions
of XCode can't handle some of the advanced C++ language features, but this
is a *software* not *hardware* limitation. Checks for version compliance
performed at build-time. Note that this "AppleClang" will not be compatible
with conda Mac packages using C++11, nor can it make use of OpenMP directives.

Another route to obtaining ``clang`` compilers without the above limitations
is through conda.

.. code-block:: bash

   # Install Clang 4.0.1 into a non-primary conda environment
   >>> conda create -n clang401 clangxx_osx-64 clang_osx-64 llvm-openmp intel-openmp

   # To Build, activate environment (prepends PATH and defines environment variables CLANG, CLANGXX, HOST, etc):
   >>> conda activate clang401
   >>> echo ${CLANGXX}
   /path/to/miniconda/envs/clang401/bin/x86_64-apple-darwin13.4.0-clang++
   >>> echo ${HOST}
   x86_64-apple-darwin13.4.0

   # build with Clang
   >>> cmake -S. -Bbuild \
        -DCMAKE_C_COMPILER=${CLANG} \
        -DCMAKE_CXX_COMPILER=${CLANGXX} \
        -DCMAKE_CXX_FLAGS="-stdlib=libc++" \
        -DOpenMP_CXX_FLAG="-fopenmp=libiomp5"

   # build with Intel
   >>> cmake -S. -Bbuild \
        -DCMAKE_C_COMPILER=icc \
        -DCMAKE_CXX_COMPILER=icpc \
        -DCMAKE_C_FLAGS="-clang-name=${CLANG}" \
        -DCMAKE_CXX_FLAGS="-clang-name=${CLANG} -clangxx-name=${CLANGXX} -stdlib=libc++ -I${CONDA_PREFIX}/include/c++/v1"

   # Configure and build

.. _`faq:modgcc`:

How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS
--------------------------------------------------------------------------

.. code-block:: bash

   # See if GCC too old (in this case, yes)
   >>> gcc --version
   gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)

Even if you're not using GCC as a compiler, your Intel compiler seeks
`gcc` to generate code compatible with your current GCC version. If your
GCC is too old (like above), you can update your system GCC through your
package manager *or* install an acceptable version elsewhere on your
system. The latter route, tested on Linux with Intel compilers, is below.

.. code-block:: bash

   # Install GCC 7.2 into a non-primary conda environment
   >>> conda create -n gcc72 gxx_linux-64 gcc_linux-64

   # To Build, either:

   # (A) activate environment (prepends PATH and defines environment variables CC, CXX, HOST, etc)
         >>> conda activate gcc72
         >>> echo ${CXX}
         /path/to/miniconda/envs/gcc72/bin/x86_64-conda_cos6-linux-gnu-g++
         >>> echo ${HOST}
         x86_64-conda_cos6-linux-gnu

         # build with GNU
         >>> cmake -S. -Bbuild \
              -DCMAKE_C_COMPILER=${CC} \
              -DCMAKE_CXX_COMPILER=${CXX} \

         # build with Intel
         >>> cmake -S. -Bbuild \
              -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_C_FLAGS="-gnu-prefix=${HOST}-" \
              -DCMAKE_CXX_FLAGS="-gnu-prefix=${HOST}-" \

   # (B) tell CMake to tell the compiler which GCC to use
         >>> GCC7=/path/to/miniconda/envs/gcc72
         >>> cmake -S. -Bbuild \
              -DCMAKE_C_COMPILER=icc \
              -DCMAKE_CXX_COMPILER=icpc \
              -DCMAKE_C_FLAGS="-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-" \
              -DCMAKE_CXX_FLAGS="-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-" \
              ...
              # if Fortran active ...
              -DCMAKE_Fortran_COMPILER=ifort \
              -DCMAKE_Fortran_FLAGS="-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-" \

   # Configure and build

   # To Run:
   >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH


.. _`faq:cray`:

How to configure a Psi4 build on Cray
-------------------------------------

Cray systems strongly prefer to build static libraries, but |PSIfour|
needs to be dynamic to function as a Python module. Courtesy of @misha
at the forum and various supercomputer guides, building |PSIfour| on
Cray requires setting environment variables before running `cmake`. ::

    CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ...

.. envvar:: CRAYPE_LINK_TYPE

   Set to allow |PSIfour| to build as shared library on Cray supercomputers.

.. envvar:: CRAY_ADD_RPATH

   Set to true to allow |PSIfour| to build on Cray supercomputers.


.. _`cmake:fortran`:

How to configure Fortran compilers for building Psi4
----------------------------------------------------

**Role and Dependencies**

* Role |w---w| In |PSIfour|, a Fortran compiler in unneeded for core
  features but may be required for add-ons.

* Downstream Dependencies

  * |PSIfour| (\ |dr| optional) Fortran Compiler
  * erd, dkh, gdma, PCMSolver |dr| Fortran Compiler

**CMake Variables**

* :makevar:`CMAKE_Fortran_COMPILER` |w---w| CMake variable to specify name or full path to Fortran compiler.
* :makevar:`CMAKE_Fortran_FLAGS` |w---w| CMake variable to specify any additional custom compiler flags for Fortran source.

**Examples**

A. Build with detected compiler from :envvar:`PATH`

  .. code-block:: bash

    >>> cmake

B. Build with specific (Intel) compiler from :envvar:`PATH`

  .. code-block:: bash

    >>> cmake -DCMAKE_Fortran_COMPILER=ifort


.. _`faq:approvedfc`:

What Fortran compilers are approved
-----------------------------------

On Linux and Mac, the following work nicely.

  * GNU: ``gfortran``
  * Intel: ``ifort``

* Packages to install for specific OS or package managers:

  * Ubuntu ``gfortran``
  * conda ``gfortran_linux-64`` or ``gfortran_osx-64`` to get ``gfortran``


.. _`faq:macgfortran`:

How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew
----------------------------------------------------------------------------

Xcode does not provide a Fortran compiler. A way to get one is to download
the ``gfortran_osx-64`` conda package. This provides
``gfortran`` compilers for Mac. The version is 4.8.5, which is quite old,
but the Fortran compiler will work.

.. Xcode does not provide a Fortran compiler. Although a Fortran compiler is
.. not required for Psi4, a broken one can prevent correct configuration. Do
.. not download the latest version of GFortran from the HPC website; this is
.. unlikely to be compatible with your version of GCC. Instead, you should
.. run ``gcc -v`` to find out what version of GCC you're using, and then
.. download the corresponding GFortran from
.. <http://r.research.att.com/tools/>.  If you configure Psi on a Mac without
.. any Fortran compiler it will set itself up correctly, so this is only
.. necessary if you want a Fortran compiler for other purposes.


.. _`cmake:lapack`:

How to configure BLAS/LAPACK for building Psi4
----------------------------------------------

**Role and Dependencies**

* Role |w---w| In |PSIfour|, BLAS and LAPACK control much of the speed
  and efficiency of the code since computational chemistry is essentially
  linear algebra on molecular systems.

* Downstream Dependencies |w---w| |PSIfour| |dr| LAPACK Libraries

**CMake Variables**

* :makevar:`BLAS_TYPE` |w---w| CMake variable to specify which BLAS libraries to look for among ``MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE``.
* :makevar:`LAPACK_TYPE` |w---w| CMake variable to specify which LAPACK libraries to look for among ``MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE``.
* :makevar:`LAPACK_LIBRARIES` |w---w| CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be ";"-separated list of full paths.
* :makevar:`LAPACK_INCLUDE_DIRS` |w---w| CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.
* :makevar:`OpenMP_LIBRARY_DIRS` |w---w| CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be ";"-separated list of full directory paths. Usually the solution to error ``Could NOT find MathOpenMP``.

.. envvar:: MKL_ROOT

  Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.

.. envvar:: MATH_ROOT

   Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (*e.g.*, ``${MATH_ROOT}/lib64/libblas.so`` and ``${MATH_ROOT}/lib64/liblapack.so``).

**Examples**

A. Build with any LAPACK in standard location

  .. code-block:: bash

    >>> cmake

B. Build with native Accelerate LAPACK on Mac (MKL *not* also present).
   If NumPy *not* using native Accelerate LAPACK, then directing Psi4
   to use it is Bad Idea!

  .. code-block:: bash

    >>> cmake

C. Build with native Accelerate LAPACK on Mac (MKL also present)
   If NumPy *not* using native Accelerate LAPACK, then directing Psi4
   to use it is Bad Idea!

  .. code-block:: bash

    >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE

D. Build with Intel MKL

  .. code-block:: bash

    >>> source /path/to/intel/vers/linux/mkl/bin/mklvars.sh intel64  # adjust sh/csh and arch as needed
    >>> cmake

  .. code-block:: bash

    >>> MATH_ROOT=/path/to/intel/vers/linux/mkl/ cmake

E. Build with Intel MKL from conda (install ``mkl-devel`` package from defaults channel)

  .. code-block:: bash

    >>> cmake -DLAPACK_LIBRARIES="${CONDA_PREFIX}/lib/libmkl_rt.so" -DLAPACK_INCLUDE_DIRS="${CONDA_PREFIX}/include"

F. OpenBLAS - see note below.

  .. code-block:: bash

    >>> MATH_ROOT=/path/to/openblas/0.2.13_seq/x86_64/gcc_5.2.0/lib cmake

G. Build with explicit MKL LAPACK

  .. code-block:: bash

    >>> cmake -DLAPACK_LIBRARIES="/path/to/lib/intel64/libmkl_lapack95_lp64.a;/path/to/lib/intel64/libmkl_rt.so" -DLAPACK_INCLUDE_DIRS="/path/to/mkl-h-include/"

H. Build with explicit non-MKL LAPACK

  .. code-block:: bash

    >>> cmake -DLAPACK_LIBRARIES="/path/to/lib/liblapack.so;/path/to/lib/libblas.a"

I. Build with MKL and GCC (iomp5 needed instead of gomp for threading. use OpenMP_LIBRARY_DIRS to hint location.)

  .. code-block:: bash

    >>> cmake -DLAPACK_LIBRARIES=/opt/intel/mkl/lib/intel64/libmkl_rt.so -DLAPACK_INCLUDE_DIRS=/opt/intel/mkl/include -DOpenMP_LIBRARY_DIRS=/opt/intel/compiler/lib/intel64/

**Notes**

* Much of |PSIfours| speed and efficiency depends on the corresponding
  speed and efficiency of the linked BLAS and LAPACK libraries
  (especially the former). Consider the following recommendations:

  * It is NOT wise to use the stock BLAS library provided with many
    Linux distributions like RedHat, as it is usually just the completely
    unoptimized netlib distribution. The choice of LAPACK is less
    critical, and so the unoptimized netlib distribution is acceptable.

  * Perhaps the best choice, if available, is Intel's MKL library,
    which includes efficient threaded BLAS and LAPACK (as of |PSIfour|
    v1.1, earliest known working version is MKL 2013; as of v1.4,
    should use at leat MKL 2019). MKL, which is
    freely available through conda, is the only threaded BLAS/LAPACK
    distribution fully supported by |PSIfour|.

  * On Mac, the native Accelerate libraries are very nice and would
    be recommended but for the potential conflict between |PSIfour|
    BLAS and NumPy BLAS. Unless you've a special NumPy, avoid!

  * The open-source LAPACK distributions OpenBLAS (formerly GotoBLAS)
    mostly works. Use it at your own risk and after testing your
    particular distribution, including tests run multithreaded,
    if you intend to run |PSIfour| so. Use at least 0.2.15, and
    pay attention to how it was compiled - unthreaded seems safe,
    openmp-threaded is mostly safe, default pthreaded is *not* safe. See
    https://github.com/psi4/psi4/issues/1009 for recent analysis.

  * Another open-source LAPACK distribution, ATLAS had
    stability issues with the DFOCC module at last testing,
    https://github.com/psi4/psi4/issues/391.

  * ACML libraries are known to work with |PSIfour| v1.1 at ACML 6.

* Because of how link loaders work, at runtime, the BLAS of |PSIfour|
  and the BLAS of NumPy are not independent. There can be unpredictable
  but reproducible numerical and thread-scaling errors if |PSIfour|
  and NumPy BLAS don't match down to the library name (that is,
  ``libmkl_rt``, ``libmkl_core.so``, ``libmkl_core.a`` are *not*
  interchangeable). See https://github.com/psi4/psi4/issues/1007,
  https://github.com/psi4/psi4/issues/748,
  https://github.com/psi4/psi4/issues/755 for gory discussions.
  Choose your NumPy and |PSIfour| compile conditions to use the same
  BLAS distribution.

* The BLAS/LAPACK detected for |PSIfour| are also linked into any
  Add-Ons (*e.g.*, libefp) that require them, rather than relying on
  those packages' native math detection.

* The separation between BLAS and LAPACK seen in detection printing
  and CMake variables is purely formal. In practice, they get run
  together and linked as ``${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}``.

* Sometimes the CMake's library search capabilites falter at SONAMEs
  (*e.g.*, ``libblas.so.3`` *vs.* ``libblas.so``), extensions (static
  *vs.* dynamic), or suffixes (*e.g.*, ``libacml_mp.so`` *vs.*
  ``libacml.so``). The developers would be interested in hearing
  of such problems to expand the math detection capabilities. The
  immediate solution, however, is to form symlinks between the
  library names that exist and the names expected. Consult file
  :source:`cmake/math/MathLibs.cmake` for the library patterns being
  sought.

* The BLAS/LAPACK interface is standardized, so only libraries, not
  headers, need to be detected. The exception is MKL, where the ``mkl.h``
  header defines additional functionality; it must be located to use
  BLAS threading.

.. _`cmake:python`:

How to configure Python for building Psi4
-----------------------------------------

**Role and Dependencies**

* Role |w---w| In |PSIfour|, Python allows the core compiled C++ code to
  be flexibly accessed for manipulation and extension in an interpreted
  language.

* Downstream Dependencies |w---w| |PSIfour| |dr| Python Interpreter

**CMake Variables**

Note that in v1.4, |PSIfour| switched from Numpy-written CMake Python
detection to new CMake-written CMake Python detection. Usually only
:makevar:`Python_EXECUTABLE` is now needed to hint Python's location. See
https://cmake.org/cmake/help/latest/module/FindPython.html for full
guidance.

* :makevar:`Python_EXECUTABLE` |w---w| specify name or full path to Python interpreter.
* :makevar:`Python_LIBRARY` |w---w| specify path to Python library.
* :makevar:`Python_INCLUDE_DIR` |w---w| specify directory of Python headers. Contains ``Python.h``.

**Examples**

A. Build with detected Python from :envvar:`PATH`

  .. code-block:: bash

    >>> cmake

B. Build with specific Python

  .. code-block:: bash

    >>> cmake -DPython_EXECUTABLE=/path/to/interp/python3.9

C. Build with full Python specification to root directory ``${PFXC}``

  .. code-block:: bash

    >>> cmake -DPython_EXECUTABLE="${PFXC}/bin/python" \
              -DPython_LIBRARY="${PFXC}/lib/libpython3.9.so" \
              -DPython_INCLUDE_DIR="${PFXC}/include/python3.9"


.. _`faq:runtimepython`:

What Python is Psi4 running
---------------------------

The Python detected at build-time is embedded into the |PSIfour|
executable. That is, the top line of ``bin/psi4`` is something like
``#!/path/to/miniconda/envs/p4deps/bin/python3.5``, and that's the Python
through which |PSIfour| is running, rather than the Python of ``which python``.
To use a different Python with |PSIfour| in the short term, just
``path/to/desired/python psi4`` on the command line to override the
shebang line. To use a different Python with |PSIfour| in the long term,
edit the shebang line.

If you're using |PSIfour| as a Python module, then |PSIfour| *is* running
the Python of ``which python``.


.. _`faq:wrongpyfalse`:

How to fix "``undefined symbol: _Py_FalseStruct``"
--------------------------------------------------

You're probably loading a Py3-compiled Psi4 in Py2. Switch interpreters
and re-run. A python of proper Py2 or Py3-ness is baked into the |PSIfour|
"executable", so you'll see this error only for Psi4 as Python module.


.. _`faq:gdblldb`:

How to use ``gdb`` and ``lldb`` with Psi4
-----------------------------------------

Debugging |PSIfour| has gotten a little confusing now that it's running through Python. Here's the syntax ::

  >>> cd {objdir}
  >>> lldb -- python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat
  >>> (lldb) run

::

  >>> cd {objdir}
  >>> gdb --args python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat
  >>> (gdb) run


.. .. _`faq:valgrindpsi`:
.. 
.. How to use ``valgrind`` with Psi4
.. ---------------------------------
.. 
.. When you naively use Valgrind with Psi4, you're likely to get incomprehensible mess of garbage or it may just crash with a boost overflow error. This happens because the boost python layer looks really really bad as far as Valgrind is concerned, i.e. it looks like a ton of memory leaks.  It really isn't, so we want to ignore all such errors/warnings. Valgrind has a mechanism for this in the way of suppression files.  Calling Valgrind as:
.. 
.. ```bash
.. valgrind --suppressions=<file_name>
.. ```
.. 
.. will run valgrind with the suppression file located on disk at "file_name". Lucky for you, Psi4 comes with such a suppression file at [``$top-level-psi4-dir/psi4/share/psi4/scripts/valgrind-python.supp``](../blob/master/psi4/share/psi4/scripts/valgrind-python.supp). This should remove all the python errors.
..  
.. The other error, boost overflow error arises from ``src/lib/libmints/sieve.cc`` where the inverse
.. of the complementary error function is being called.  The internet seems to claim that this is a
.. bug the arises only in debugging mode and has something to do with the exponent boost chooses for
.. the default zero tolerance.  Anyways, commenting out lines 47 to 49, for valgrind purposes, should
.. allow you to run valgrind.  The consequence of commenting out these lines are you get no integeral
.. screening, so make sure you uncomment them when you actually run.


.. _`faq:cmakeverbose`:

How to see the actual compiling commands (or errors) with ``cmake``
-------------------------------------------------------------------

CMake by default hides a lot of useful debugging information to make the
compilation cleaner. Issue ``make VERBOSE=1`` to display the full
compilation commands and errors.


.. _`faq:vigitmerge`:

How to highlight git merge conflicts in ``vi``
----------------------------------------------

Edit your ``~/.vimrc`` file to include the lines below. Hitting the ``F7``
key will toggle highlighting of git's conflict markers.

.. code-block:: bash

   >>> cat ~/.vimrc
   set hlsearch
   map <F7> :/\(<<<<<<<\\|=======\\|>>>>>>>\)<CR>


.. _`faq:libmwcondapy`:

How to handle "runtime library may be hidden" when building with Anaconda Python
--------------------------------------------------------------------------------

When building against Ana/Miniconda python (e.g., ``cmake
-DPython_EXECUTABLE=/path/to/conda/bin/python``), the warning below often
appears. It is harmless, proceed.

.. code-block:: bash

   CMake Warning at src/bin/psi4/CMakeLists.txt:58 (add_executable):
     Cannot generate a safe runtime search path for target psi4 because files in
     some directories may conflict with libraries in implicit directories:

       runtime library [libm.so.6] in /usr/lib64 may be hidden by files in:
         /theoryfs2/common/software/anaconda/lib

   Some of these libraries may not be found correctly.


.. _`faq:psi4scratch`:

How to set up the scratch directory
-----------------------------------

The scratch directory is where Psi4 stores potentially large files during
computation. It should thus be on a local, fast disk to minimize any
computational inefficiencies caused by I/O. The scratch directory is
commonly set up through the :envvar:`PSI_SCRATCH` environment variable:

.. code-block:: tcsh

    # csh, tcsh: add to shell or ~/.tcshrc file
    setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files

.. code-block:: bash

    # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file
    export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files

See also the more general :ref:`scratch documentation <sec:Scratch>`.


.. _`faq:psi4fileretention`:

How do I retain specific Psi4 scratch files
-------------------------------------------

You can set up a specific path for |PSIfour| scratch file and keep them
for later use through the :ref:`psi4_io <sec:Scratch>` handler.


.. _`faq:psi4PBS`:

How to use Psi4 within a PBS queue
----------------------------------

You will usually need to set up a PBS job script that is setting all
necessary environment variables, making sure the scratch directories are
set up, and invoking the executable. An :ref:`example <sec:PBS>` PBS script
is provided in the manual, but make sure to also consult your own PBS
documentation for appropriate setup.


.. _`faq:recompile`:

How to update and rebuild Psi4
------------------------------

Obtain code updates as appropriate from :ref:`faq:binary`,
:ref:`faq:clonepsi4public`, or :ref:`faq:forkpsi4public`.  Move into
:samp:`{objdir}` and reissue ``make`` or ``cmake --build .``, whereupon CMake may reconfigure but
will only rebuild objects and libraries depending on changed files. It is
scarcely ever necessary for the user to reinvoke ``cmake`` to update
:samp:`{objdir}` based on changes to the |PSIfour| repository.
Upon switching conda environments, though, one should
make a new objdir since there are many full paths baked into
:samp:`{objdir}/CMakeCache.txt`.


.. _`faq:minutetests`:

How to run a minute's worth of tests
------------------------------------

When you want to do a very minimal test of the build and have
CTest installed, the following command can be useful.

.. code-block:: console

    >>> ctest -L smoke -j`getconf _NPROCESSORS_ONLN`

If you have pytest installed, very similar coverage is obtained through::

    >>> make pytest

.. _`faq:subsettests`:

How to run a subset of tests
----------------------------

CTest allows flexibly partitioned running of the test suite. In
the examples below, *testname* are regex of :source:`test names <tests>`,
and *testlabel* are regex of labels (*e.g.*, ``cc``, ``mints``,
``libefp`` defined :source:`[here, for example] <tests/ci-property/CMakeLists.txt#L3>` .

* Run tests in parallel with ``-j`` flag. For maximum parallelism (not Windows): :samp:`ctest -j\`getconf _NPROCESSORS_ONLN\`\ `
* Run full test suite: ``ctest``
* Run about a third of the tests in 5 minutes, the so-called *quicktests*: ``ctest -L quick``
* Run the same subset of tests that continuous integration checks (not the full test suite): ``ctest -L quick``
* Run the minimal number of tests to ensure Psi4 and any add-ons in working order: ``ctest -L smoke``
* Run tests matching by name: ``ctest -R testname``
* Run tests excluding those by name: ``ctest -E testname``
* Run tests matching by label: ``ctest -L testlabel``
* Run tests excluding those by label: ``ctest -LE testlabel``

Pytest has similar commands:

* Run tests in parallel with ``-n`` flag (if Python package ``pytest-xdist`` installed). For maximum parallelism: :samp:`pytest -n auto`
* Run full test suite: ``pytest``
* Run the quick tests: ``pytest -m quick``
* Run the minimal number of tests to ensure Psi4 and any add-ons in working order: ``pytest -m smoke``
* Run tests matching by name: ``pytest -k testname``
* Run tests excluding those by name: ``pytest -k "not testname"``
* Run tests matching by label: ``pytest -m testlabel``
* Run tests excluding those by label: ``pytest -m "not testlabel"``
* Run tests with complicated filtering by name: ``pytest -k "cc and not cc4 and not stdsuite"``
* Run tests and see test names: ``pytest -v``
* Run tests and see test names and sometimes more verbose errors: ``pytest -vv``

.. _`faq:testsoutput`:

How to see CTest testing errors
-------------------------------

::

 >>> ctest
 Test project /your/path/2/psi4/build/directory/tests
     Start 248: tu1-h2o-energy
 1/2 Test #248: tu1-h2o-energy ...................   Passed    1.73 sec
      Start  6: cc1
 2/2  Test  #6: cc1 ..............................***Failed    0.07 sec
 ...

When ``ctest`` reports that some (or all) tests have failed, look in your
build directory for file
:samp:`{objdir}/Testing/Temporary/LastTest.log`. It may have a
``.tmp`` extension, depending on whether the last test was interrupted and
a few other factors. Either way, this file should contain CMake's testing
output, as well as everything that was printed to the screen.


.. _`faq:pytest`:

How to test a Psi4 installation
-------------------------------

``ctest`` requires a connection to source files and ``cmake``
machinery and so can only be performed from :samp:`{objdir}`
(staged installation). To test an installed |PSIfour| (full or staged
installation), a supplementary test suite is available to be
run via pytest. Running a limited number of "smoke" tests is
generally sufficient to verify an installation.

  * From the executable

    .. code-block:: bash

     # smoke tests only in serial
     psi4 --test
     # smoke tests only in parallel
     psi4 --test -n`getconf _NPROCESSORS_ONLN`
     # most tests
     psi4 --test full

  * From the library (|PSIfour| must be detectable as a Python
    module. See setup at :ref:`faq:psi4psiapipath`
    if needed.)

    .. code-block:: bash

     # smoke tests only
     python -c "import psi4; psi4.test('smoke')"
     # most tests
     python -c "import psi4; psi4.test()"

  * From pytest directly. If package ``pytest-xdist`` is installed, can run in parallel.

    .. code-block:: bash

     # smoke tests only
     pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -m smoke -n auto
     # all tests
     pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n auto

Output looks something like the below. ``PASSED`` in green is good
(means test ran correctly); ``SKIPPED`` in yellow is good (means that
not all software required for test is available); ``XPASS`` or ``XFAIL``
in yellow is fine (unexpected pass or expected fail happens when we
include tests that need particular conditions (*e.g.*, multiple cores)
to run correctly); ``FAILED`` in red is bad. ::

    test_addons.py::test_gdma PASSED
    test_addons.py::test_mrcc SKIPPED
    test_addons.py::test_chemps2 PASSED
    test_addons.py::test_dftd3 PASSED
    test_addons.py::test_libefp PASSED
    test_addons.py::test_pcmsolver PASSED
    test_addons.py::test_erd PASSED
    test_addons.py::test_simint PASSED
    test_addons.py::test_json PASSED
    test_addons.py::test_cfour SKIPPED
    test_addons.py::test_v2rdm_casscf PASSED
    test_addons.py::test_grimme_3c PASSED
    test_addons.py::test_dkh PASSED
    test_psi4.py::test_psi4_basic PASSED
    test_psi4.py::test_psi4_cc PASSED
    test_psi4.py::test_psi4_cas PASSED
    test_psi4.py::test_psi4_dfmp2 PASSED
    test_psi4.py::test_psi4_sapt PASSED
    test_psi4.py::test_psi4_scfproperty PASSED


.. _`faq:writepsi4`:

How to refer to Psi4
--------------------

Ways to refer to |PSIfour| in text, in order of decreasing goodness:

  * as ``Psi4`` in Optima regular font with "si" in custom (82%) small caps
    according to :source:`media/README.md`.

    * html: ``<span style="font-family: Optima, sans-serif; color: #273896;">P<span style="font-size: 82%;">SI</span>4</span>``

  * as ``Psi4`` with "si" in generated small caps

    * html: ``<span style="font-variant: small-caps;">Psi4</span>``

  * as ``Psi4`` with "si" in lowercase

  * as ``psi4`` in code

  * **NOT** ``PSI4`` or ``PSI``


.. _`faq:psi4logos`:

How to get a Psi4 logo file
---------------------------

All image files are stored in https://github.com/psi4/psi4media


.. _`faq:localaddon`:

How to use a local Add-On repository in the Psi4 build
------------------------------------------------------

For each Add-On, |PSIfour| pulls source from a specific online Git
repository and a specific tag/branch/commit in it. This ensures success
of the |PSIfour| build, reproducibility of the runtime results, and
freedom for continued upstream development. Sometimes, you're the one
doing that development, and you need the CMake superbuild to pull source
from a local path rather than the approved codeset.

Find the ``CMakeLists.txt`` governing the target Add-On in
:source:`external` and make changes analogous to the below::

    #GIT_REPOSITORY https://github.com/jturney/ambit
    #GIT_TAG 1.0
    DOWNLOAD_COMMAND ""
    SOURCE_DIR "/path/to/ambit-directclone"

If you're changing the |PSIfour| repo codebase between compiles, there's
nothing more to do as CMake will handle the code rebuild deps for you.

If you're changing the local Add-On repo codebase between compiles,
CMake *does not* know when ``libaddon.[a|so|dylib]`` needs rebuilding. It
is recommended that the |PSIfour| build be initially configured with
``-DBUILD_SHARED_LIBS=ON`` (easier to notice changes). And to trigger
Add-On library rebuild, ``rm -rf {objdir}/external/upstream/addon/``
and ``rm -rf {objdir}/stage/share/cmake/AddOn``. This should
re-clone the Add-On, rebuild and install it, rebuild any parts of
|PSIfour| that interface to it, and relink the main ``core.so``.
If you're modifying the Add-On's file or directory structure, be
smart and ``rm`` all traces of it within ``{objdir}/stage/``,
especially any ``*.pyc`` files.

Alternatively and preferentially to the above, you can instead build and install the
Add-On library yourself, external to the |PSIfour| repository. This
is especially useful if you want to avoid full recompiles of the
Add-On at each change to the Add-On's source. Build the Add-On
library dynamically (``-DBUILD_SHARED_LIBS=ON``) and mind any
"Psi4 wants" in the Add-On's top-level CMakeLists.txt. Install the
Add-On and note the full path to ``AddOnConfig.cmake``. Pass
the path containing that file to |PSIfours| CMake as
``-DAddon_DIR=/path/to/config/usually/ending/in/share/cmake/AddON``
and build |PSIfour|. The main ``core.so`` should be dynamically linked
to your dev AddOn dynamic lib and update automatically when you rebuild
the AddOn lib. Naturally, you may need to delete ``core.so`` and remake
as needed.


.. _`faq:logging`:

How to use logging in Psi4
--------------------------

A log file is generated alongside the output file and has extension
``.log``. Selected key information is sent to it. The log file contents
are provisional and haphazard, so don't start relying upon them. It is
tentatively envisioned that log files will have much of the same results as output
files but more as structured data than narrative, nicely formatted data.
In some cases where external calls are involved, the most detailed
information may only be collectable in the log file. It is
worthwhile to check the log file if expected results are missing from
the usual output file. If the log file is empty, the logging level may
be set too low.

To change the logging level to DEBUG from the command-line::

  >>> psi4 --logging 10

To change the logging level to DEBUG in PsiAPI::

  >>> psi4.set_output_file(<filebase>, loglevel=10)

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

..  * NOTES (LAB 3-26-2012)
    * Any PSI variable added to the codebase should be added to this list
      (variables in the psi variable by module list will show up black
      and un-clickable if an entry isn't present here).
    * INCLUDE UNITS!
    * ALPHABETIZE!

.. include:: autodoc_abbr_options_c.rst

.. _`apdx:psivariables_alpha`:

PSI Variables by Alpha
======================

.. note:: Lowercase letters in PSI variable names represent portions of
   the variable name that vary by root number, calculation order, etc.
   See text for fuller description.

.. psivar:: [T] CORRECTION ENERGY

   The coupled-cluster bracket perturbative triples correction [Eh].

.. psivar:: (T) CORRECTION ENERGY

   The coupled-cluster perturbative triples correction [Eh].

.. psivar:: (AT) CORRECTION ENERGY
   A-(T) CORRECTION ENERGY

   The coupled-cluster asymmetric perturbative triples correction [Eh].

.. psivar:: AAA (T) CORRECTION ENERGY
   AAB (T) CORRECTION ENERGY
   ABB (T) CORRECTION ENERGY
   BBB (T) CORRECTION ENERGY

   Spin components of the UHF-based coupled-cluster perturbative triples correction [Eh].

.. psivar:: ACPF DIPOLE

   Dipole array [e a0] for the averaged coupled-pair functional level of theory, (3,).

.. psivar:: ACPF QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the averaged coupled-pair functional level of theory, (3, 3).

.. psivar:: ACPF TOTAL ENERGY
   ACPF CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the averaged coupled-pair functional level of theory.

.. psivar:: ADC ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY

   The excitation energy of given method from ground state to root m
   in h symmetry (if available).
   
.. psivar:: ADC ROOT n TOTAL ENERGY - h SYMMETRY

   The total energy of given method from ground state to root m in h symmetry.

.. psivar:: ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY

   The correlation energy of given method from ground state reference energy to root m in h symmetry.

.. psivar:: AQCC DIPOLE

   Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,).

.. psivar:: AQCC QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3).

.. psivar:: AQCC TOTAL ENERGY
   AQCC CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the averaged quadratic coupled-cluster level of theory.
.. psivar:: BRUECKNER CONVERGED

   Value 1 (0) when the Brueckner orbitals have (have not) converged.

.. psivar:: CBS TOTAL ENERGY
   CBS CORRELATION ENERGY
   CBS REFERENCE ENERGY

   The total electronic energy [Eh] and its breakdown into reference total
   energy [Eh] and correlation correction components [Eh] for the compound
   method requested through cbs().

.. psivar:: CC ROOT n DIPOLE

   Dipole array [e a0] for the requested coupled cluster level of theory and root *n* (number starts at GS = 0), (3,).

.. psivar:: CC ROOT n QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the requested coupled cluster level of theory and root *n* (number starts at GS = 0), (3, 3).

.. psivar:: CC ROOT n TOTAL ENERGY
   CC ROOT n CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested coupled cluster level of theory and root
   *n* (numbering starts at GS = 0).

.. psivar:: CC TOTAL ENERGY
   CC CORRELATION ENERGY

.. psivar:: CC T1 DIAGNOSTIC
   CC D1 DIAGNOSTIC
   CC NEW D1 DIAGNOSTIC
   CC D2 DIAGNOSTIC

   Diagnostic of multireference character.

.. psivar:: CC2 TOTAL ENERGY
   CC2 CORRELATION ENERGY
   CC3 TOTAL ENERGY
   CC3 CORRELATION ENERGY
   CC4 TOTAL ENERGY
   CC4 CORRELATION ENERGY
   CCnn TOTAL ENERGY
   CCnn CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested approximate coupled-cluster (CC2, CC3, up to CC\ *nn*)
   level of theory.

.. psivar:: CC DIPOLE

   Dipole array [e a0] for the requested coupled cluster level of theory and root, (3,).

.. psivar:: CC2 DIPOLE POLARIZABILITY @ xNM

   The dipole polarizability in atomic units [(e^2 a0^2)/E_h] calculated at
   the CC2 level for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CC2 QUADRUPOLE POLARIZABILITY @ xNM

   The quadrupole polarizability in atomic units [(e^2 a0^3)/E_h] calculated at
   the CC2 level for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CC2 SPECIFIC ROTATION (LEN) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the
   length gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CC2 SPECIFIC ROTATION (VEL) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the
   velocity gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CC2 SPECIFIC ROTATION (MVG) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CC2 level in the
   modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CC2 ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM

   The origin-dependence of the CC2 specific rotation in deg/[dm (g/cm^3)]/bohr and the
   length gauge, computed at (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCD TOTAL ENERGY
   CCD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the coupled-cluster doubles level of theory.

.. psivar:: CCSD PAIR ENERGIES

   The restricted-reference pair energies for coupled-cluster singles and doubles
   level of theory. Size number of active doubly occupied orbitals, square.

.. psivar:: CCSD TOTAL ENERGY
   CCSD CORRELATION ENERGY
   CCSDT TOTAL ENERGY
   CCSDT CORRELATION ENERGY
   CCSDTQ TOTAL ENERGY
   CCSDTQ CORRELATION ENERGY
   CCn TOTAL ENERGY
   CCn CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested full coupled-cluster (CCSD, CCSDT, up to CC\ *n*)
   level of theory.

.. psivar:: CCSD(T) TOTAL ENERGY
   CCSD(T) CORRELATION ENERGY
   CCSD(AT) TOTAL ENERGY
   CCSD(AT) CORRELATION ENERGY
   A-CCSD(T) TOTAL ENERGY
   A-CCSD(T) CORRELATION ENERGY
   CCSDT(Q) TOTAL ENERGY
   CCSDT(Q) CORRELATION ENERGY
   CC(n-1)(n) TOTAL ENERGY
   CC(n-1)(n) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the perturbatively corrected coupled-cluster (CCSD(T), A-CCSD(T) = CCSD(AT), CCSDT(Q),
   up to CC(\ *n*\ -1)(\ *n*\ ) level of theory.

.. psivar:: CCSDT-1a TOTAL ENERGY
   CCSDT-1a CORRELATION ENERGY
   CCSDTQ-1a TOTAL ENERGY
   CCSDTQ-1a CORRELATION ENERGY
   CCn-1a TOTAL ENERGY
   CCn-1a CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,
   up to CC\ *n*\ -1a) level of theory.

.. psivar:: CCSDT-1b TOTAL ENERGY
   CCSDT-1b CORRELATION ENERGY
   CCSDTQ-1b TOTAL ENERGY
   CCSDTQ-1b CORRELATION ENERGY
   CCn-1b TOTAL ENERGY
   CCn-1b CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,
   up to CC\ *n*\ -1b) level of theory.

.. psivar:: CCSDT-3 TOTAL ENERGY
   CCSDT-3 CORRELATION ENERGY
   CCSDTQ-3 TOTAL ENERGY
   CCSDTQ-3 CORRELATION ENERGY
   CCn-3 TOTAL ENERGY
   CCn-3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,
   up to CC\ *n*\ -3) level of theory.

.. psivar:: CCSD(T)_L TOTAL ENERGY
   CCSD(T)_L CORRELATION ENERGY
   CCSDT(Q)_L TOTAL ENERGY
   CCSDT(Q)_L CORRELATION ENERGY
   CC(n-1)(n)_L TOTAL ENERGY
   CC(n-1)(n)_L CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,
   up to CC(\ *n*\ -1)(\ *n*\ )L level of theory.

.. psivar:: CCSDT(Q)/A TOTAL ENERGY
   CCSDT(Q)/A CORRELATION ENERGY
   CCSDT(Q)/B TOTAL ENERGY
   CCSDT(Q)/B CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the modified CCSDT(Q) level of theory.

.. psivar:: CCSD DIPOLE POLARIZABILITY @ xNM

   The dipole polarizability in atomic units [(e^2 a0^2)/E_h] calculated at
   the CCSD level for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCSD QUADRUPOLE POLARIZABILITY @ xNM

   The quadrupole polarizability in atomic units [(e^2 a0^3)/E_h] calculated at
   the CCSD level for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCSD SPECIFIC ROTATION (LEN) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the
   length gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCSD SPECIFIC ROTATION (VEL) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the
   velocity gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCSD SPECIFIC ROTATION (MVG) @ xNM

   The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the
   modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCSD ROTATION (LEN) ORIGIN-DEPENDENCE @ xNM

   The origin-dependence of the CCSD specific rotation in deg/[dm (g/cm^3)]/bohr and the
   length gauge, computed at (x) wavelength, (x) rounded to nearest integer.

.. psivar:: CCname ROOT m CORRELATION ENERGY
   CCname ROOT m (h) CORRELATION ENERGY
   CCname ROOT m CORRELATION ENERGY - h TRANSITION

   The correlation energy of given method from ground state to root m in h symmetry.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: CCname ROOT m TOTAL ENERGY
   CCname ROOT m (h) TOTAL ENERGY
   CCname ROOT m TOTAL ENERGY - h TRANSITION
   TD-fctl ROOT m TOTAL ENERGY
   TD-fctl ROOT m (h) TOTAL ENERGY
   TD-fctl ROOT m TOTAL ENERGY - h TRANSITION

   The total energy of given method from ground state to root m in h symmetry.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: CCname ROOT n (h) -> ROOT m (i) EINSTEIN A (LEN)

   The Einstein A coefficient, the spontaneous emission 'probability.'
   Units are in [1/s].

.. psivar:: CCname ROOT n (h) -> ROOT m (i) EINSTEIN B (LEN)

   The Einstein B coefficient, the stimulated emission 'probability'
   in terms of energy density. Units are in [m^3 / J / s^2].

.. psivar:: CEPA(0) DIPOLE

   Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,).

.. psivar:: CEPA(0) QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3).

.. psivar:: CEPA(0) TOTAL ENERGY
   CEPA(0) CORRELATION ENERGY
   CEPA(1) TOTAL ENERGY
   CEPA(1) CORRELATION ENERGY
   CEPA(2) TOTAL ENERGY
   CEPA(2) CORRELATION ENERGY
   CEPA(3) TOTAL ENERGY
   CEPA(3) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested variant of coupled electron pair approximation level of theory.

.. psivar:: CFOUR ERROR CODE

   The non-zero return value from a Cfour execution.

.. psivar:: CI DIPOLE

   Dipole array [e a0] for the requested configuration interaction level of theory, (3,).

.. psivar:: CI QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3).

.. psivar:: CI ROOT n -> ROOT m DIPOLE

   Transition dipole array [e a0] between roots *n* and *m* for the requested configuration interaction level of theory, (3,).

.. psivar:: CI ROOT n -> ROOT m QUADRUPOLE

   Redundant transition quadrupole array [e a0^2] between roots *n* and *m* for the requested configuration interaction level of theory, (3, 3).

.. psivar:: CI ROOT n DIPOLE

   Dipole array [e a0] for the requested configuration interaction level of theory and root *n*, (3,).

.. psivar:: CI ROOT n QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root *n*, (3, 3).

.. psivar:: CI ROOT n TOTAL ENERGY
   CI ROOT n CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested configuration interaction level of theory and root
   *n* (numbering starts at 0).

.. psivar:: CI STATE-AVERAGED TOTAL ENERGY
   CI STATE-AVERAGED CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for state-averaged CI/CASSCF levels of theory.

.. psivar:: CI TOTAL ENERGY
   CI CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the requested configuration interaction level of theory and root.

.. psivar:: CISD DIPOLE

   Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,).

.. psivar:: CISD QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3).

.. psivar:: CISD TOTAL ENERGY
   CISD CORRELATION ENERGY
   CISDT TOTAL ENERGY
   CISDT CORRELATION ENERGY
   CISDTQ CORRELATION ENERGY
   CISDTQ TOTAL ENERGY
   CIn CORRELATION ENERGY
   CIn TOTAL ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the labeled configuration interaction level of theory and root.
   *n* is CI order for *n* > 4.

.. psivar:: CP-CORRECTED 2-BODY INTERACTION ENERGY

   The interaction energy [Eh] considering only two-body interactions,
   computed with counterpoise correction.
   Related variable :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY`.

   .. math:: E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}

.. psivar:: CURRENT CORRELATION ENERGY

   The correlation energy [Eh] corresponding to the :psivar:`CURRENT ENERGY` variable.

.. psivar:: CURRENT ENERGY

   The total electronic energy [Eh] of the most recent stage of a
   calculation (frequently overwritten). This is the quantity tracked by
   the geometry optimizer.

.. psivar:: CURRENT REFERENCE ENERGY

   The total electronic energy [Eh] of the reference stage corresponding to
   the :psivar:`CURRENT ENERGY` variable.

.. psivar:: CURRENT DIPOLE

   The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,).

.. psivar:: CURRENT GRADIENT

   The total electronic gradient [E_h/a0] of the most recent stage of a
   calculation (frequently overwritten). This is the quantity tracked by
   the geometry optimizer, ({nat}, 3).

.. psivar:: CURRENT DIPOLE GRADIENT

   The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]
   as a degree-of-freedom by dipole component array, (3 * {nat}, 3).

.. psivar:: CURRENT HESSIAN

   The total electronic Hessian [E_h/a0/a0] of the most recent stage of a
   calculation, (3 * {nat}, 3 * {nat}).

.. psivar:: CUSTOM SCS-MP2 TOTAL ENERGY
   CUSTOM SCS-MP2 CORRELATION ENERGY

   Changeable quantities based on options.
   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by any reweighting of :psivar:`MP2 DOUBLES ENERGY`
   for opposite-spin and same-spin contributions, with
   any singles carried along.
   Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.
   Contrast with :psivar:`SCS-MP2 TOTAL ENERGY`.

.. psivar:: CUSTOM SCS-MP2.5 TOTAL ENERGY
   CUSTOM SCS-MP2.5 CORRELATION ENERGY
   CUSTOM SCS-MP3 TOTAL ENERGY
   CUSTOM SCS-MP3 CORRELATION ENERGY
   CUSTOM SCS-LCCD TOTAL ENERGY
   CUSTOM SCS-LCCD CORRELATION ENERGY
   CUSTOM SCS-OMP2 TOTAL ENERGY
   CUSTOM SCS-OMP2 CORRELATION ENERGY
   CUSTOM SCS-OMP2.5 TOTAL ENERGY
   CUSTOM SCS-OMP2.5 CORRELATION ENERGY
   CUSTOM SCS-OMP3 TOTAL ENERGY
   CUSTOM SCS-OMP3 CORRELATION ENERGY
   CUSTOM SCS-OLCCD TOTAL ENERGY
   CUSTOM SCS-OLCCD CORRELATION ENERGY

   Changeable quantities based on options.
   The total electronic energy [Eh] and correlation energy component [Eh]
   for the method formed by any reweighting of the named :samp:`{method} DOUBLES ENERGY`
   for opposite-spin and same-spin contributions, with
   any singles carried along.
   Contrast with :samp`SCS-{method} TOTAL ENERGY`.

.. psivar:: db_name DATABASE MEAN ABSOLUTE DEVIATION

   The mean absolute deviation [\ |kcalpermol|\ ] of the requested method
   *name* from the stored reference values for the requested reactions in
   database *db_name*. If no reference is available, this will be a large
   and nonsensical value.

   .. math:: \frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }

.. psivar:: db_name DATABASE MEAN SIGNED DEVIATION

   The mean deviation [\ |kcalpermol|\ ] of the requested method *name*
   from the stored reference values for the requested reactions in
   database *db_name*. If no reference is available, this will be a large
   and nonsensical value.

   .. math:: \frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}

.. psivar:: db_name DATABASE ROOT-MEAN-SQUARE DEVIATION

   The rms deviation [\ |kcalpermol|\ ] of the requested method *name*
   from the stored reference values for the requested reactions in
   database *db_name*. If no reference is available, this will be a large
   and nonsensical value.

   .. math:: \sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}

.. psivar:: DCT LAMBDA ENERGY

   An energy term in density cumulant theory [Eh]. This term is the
   2-electron cumulant's contribution contribution to the reduced
   density matrix energy expression. Not recommended for interpretative
   use except by reduced density matrix specialists.

.. psivar:: DCT SCF ENERGY

   An energy term in density cumulant theory [Eh]. This term is the
   1-electron reduced density matrix (1RDM) contribution to the reduced
   density matrix energy expression, plus the contribution of the
   antisymmetrized product of 1RDMs. Not recommended for interpretative
   use except by reduced density matrix specialists.

.. psivar:: DCT THREE-PARTICLE ENERGY

   The three-particle correlation energy correction [Eh] in density cumulant
   theory, akin to :psivar:`(T) CORRECTION ENERGY` in coupled-cluster.

.. psivar:: DCT TOTAL ENERGY

   Total energy [Eh] in density cumulant theory. Sum of :psivar:`DCT SCF ENERGY`,
   :psivar:`DCT LAMBDA ENERGY`, and :psivar:`DCT THREE-PARTICLE ENERGY` when present.

.. psivar:: DETCI AVG DVEC NORM

   A measure of configuration interaction convergence.

.. psivar:: DFT FUNCTIONAL TOTAL ENERGY

   The total electronic energy [Eh] for the underlying functional of the
   requested DFT method, without any dispersion correction; the first four
   terms in Eq. :eq:`SCFterms` or :eq:`DFTterms`. Quantity
   :math:`E_{\text{FCTL}}` in Eqs.  :eq:`SCFterms` and :eq:`DFTterms`.
   Unless the method includes a dispersion correction, this quantity is
   equal to :psivar:`SCF TOTAL ENERGY`.

.. psivar:: DFT TOTAL ENERGY

   The total electronic energy [Eh] for the requested DFT method,
   :math:`E_{\text{DFT}}` in Eq. :eq:`DFTterms`.

   .. math::
      :nowrap:
      :label: DFTterms

         \begin{align*}
            E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\
                           & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\
                           & = E_{\text{SCF}} + E_{\text{DH}}
         \end{align*}

   Unless the method is a DFT double-hybrid, this quantity is equal to
   :psivar:`SCF TOTAL ENERGY`. If the method is neither a
   double-hybrid, nor dispersion corrected, this quantity is equal to
   :psivar:`DFT FUNCTIONAL TOTAL ENERGY`.

.. psivar:: DFT TOTAL GRADIENT

   The total electronic gradient [E_h/a0] of the requested DFT method, ({nat}, 3).

.. psivar:: DFT DIPOLE GRADIENT

   The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations
   as a degree-of-freedom by dipole component array, (3 * {nat}, 3).

.. psivar:: DFT TOTAL HESSIAN

   The total electronic second derivative [Eh/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}).

.. psivar:: DFT XC ENERGY

   The functional energy contribution [Eh] to the total SCF energy (DFT only).
   Quantity :math:`E_{xc}` in Eqs. :eq:`SCFterms` and :eq:`DFTterms`.

.. psivar:: DFT VV10 ENERGY

   The VV10 nonlocal contribution [Eh] to the total SCF energy (DFT only).
   Included in :psivar:`DFT FUNCTIONAL TOTAL ENERGY`.

.. psivar:: DISPERSION CORRECTION ENERGY
   fctl DISPERSION CORRECTION ENERGY

   The dispersion correction [Eh] appended to an underlying functional
   when a DFT-D method is requested. Quantity :math:`E_{\text{-D}}`
   in Eqs. :eq:`SCFterms` and :eq:`DFTterms`.
   When dispersion parameters are untweaked for a functional and dispersion
   level, labeled QCVariable also defined.

.. psivar:: DOUBLE-HYBRID CORRECTION ENERGY

   The scaled MP2 correlation energy correction [Eh] appended to an
   underlying functional when a DH-DFT method is requested.
   Quantity :math:`E_{\text{DH}}` in Eq. :eq:`DFTterms`.

.. psivar:: DMA DISTRIBUTED MULTIPOLES

   Distributed multipoles in units given by |gdma__gdma_multipole_units|
   with the row index corresponding to the site and the column index
   referencing the multipole component. Both indices are zero based,
   and the Qlm components of the multipoles are ordered as Q00, Q10,
   Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc.

.. psivar:: DMA TOTAL MULTIPOLES

   Distributed multipoles as a single row, whose columns are the total
   multipoles, translated to |gdma__gdma_origin|, and summed.

.. psivar:: DMRG-SCF TOTAL ENERGY

   The total DMRG total electonic energy [Eh]. Not unique because oribital spaces vary.

.. psivar:: DMRG-CASPT2 TOTAL ENERGY

   The total DMRG plus CASPT2 total electonic energy [Eh] . Not unique because orbital spaces vary.

.. psivar:: EFP DISP ENERGY
   EFP ELST ENERGY
   EFP EXCH ENERGY
   EFP IND ENERGY

   Respectively, the dispersion, electrostatics, exchange, and induction
   components of the total electronic interaction energy [Eh] for EFP/EFP
   computations. The sum of these four components yields
   :psivar:`EFP TOTAL ENERGY`.

.. psivar:: EFP TOTAL ENERGY

   The total electronic interaction energy [Eh] for EFP/EFP computations.

.. psivar:: EFP TORQUE

   The torque, not gradient for EFP/EFP computations.

.. psivar:: ENTHALPY

   Total enthalpy H [Eh] at given temperature.

.. psivar:: ENTHALPY CORRECTION

   Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the enthalpy at given temperature.

.. psivar:: ESP AT CENTER n

   Property of electrostatic potential [Eh / e] at location, usually atom center, n.

.. psivar:: FCI TOTAL ENERGY
   FCI CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the full configuration interaction level of theory.

.. psivar:: GIBBS FREE ENERGY

   Total Gibbs free energy [Eh], free enthalpy at given temperature.

.. psivar:: GIBBS FREE ENERGY CORRECTION

   Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the free enthalpy at given temperature.

.. psivar:: GRID ELECTRONS TOTAL
   GRID ELECTRONS ALPHA
   GRID ELECTRONS BETA

   The number of electrons integrated by the xc quadrature grid.

.. psivar:: HF TOTAL ENERGY

   The total electronic energy [Eh] for the Hartree--Fock method, without
   any dispersion correction; the first three (or four, since
   :math:`E_{xc} = 0`) terms in Eq. :eq:`SCFterms`. Quantity :math:`E_{\text{HF}}`
   in Eq. :eq:`SCFterms`.

.. psivar:: HF TOTAL GRADIENT

   The total electronic gradient [E_h/a0] of the Hartree--Fock method, ({nat}, 3).

.. psivar:: HF DIPOLE GRADIENT

   The derivative of the Hartree--Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations
   as a degree-of-freedom by dipole component array, (3 * {nat}, 3).

.. psivar:: HF TOTAL HESSIAN

   The total electronic second derivative [Eh/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}).

.. psivar:: LCCD TOTAL ENERGY
   LCCD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the linearized coupled cluster doubles level of theory.

.. psivar:: LCCSD TOTAL ENERGY
   LCCSD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the linearized coupled cluster singles and doubles level of theory.

.. psivar:: LCC2 (+LMP2) TOTAL ENERGY

   The total electronic energy [Eh] for the local CC2 level of theory.

.. psivar:: LCCSD (+LMP2) TOTAL ENERGY

   The total electronic energy [Eh] for the local CCSD level of theory.

.. psivar:: LEFT-RIGHT CC2 EIGENVECTOR OVERLAP
   LEFT-RIGHT CC3 EIGENVECTOR OVERLAP
   LEFT-RIGHT CCSD EIGENVECTOR OVERLAP
   LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP

   The overlap between the right-hand coupled coupled cluster eigenvector and the
   left-hand eigenvector from the coupled cluster lambda (response) equations.

.. psivar:: LOWDIN CHARGES

   Property of partial atomic charges [e] by the method of L\ |o_dots|\ wdin, (nat,).

.. psivar:: MAYER INDICES

   Property of Mayer bond indices, (nat, nat).

.. psivar:: MBIS CHARGES
   MBIS DIPOLES
   MBIS OCTUPOLES
   MBIS QUADRUPOLES

   Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]
   resulting from partitioning the total electron density through the Minimal Basis
   Iterative Stockholder (MBIS) Charge Partitioning Scheme.

.. psivar:: MBIS FREE ATOM n VOLUME

   Free-atom volume [a0^3] for atom n, computed using the MBIS charge
   partitioning scheme. Free atom densities are computed at the same
   level of theory as the parent MBIS calculation, with UHF turned on
   as needed.

.. psivar:: MBIS RADIAL MOMENTS <R^3>

   Per-atom expectation value of r^3 [a0^3], equivalent to the volume
   of the MBIS-partitioned density.

.. psivar:: MBIS VALENCE WIDTHS

   Per-atom density width [a0] of the associated valence charge computed
   from an MBIS partitioned density. Equivalent to the inverse of the
   linear decay rate of the atomic density.

.. psivar:: MBIS VOLUME RATIOS

   Per-atom ratio between the atomic volume (<R^3>) and the free-atomic
   volume, unitless.

.. psivar:: MCSCF TOTAL ENERGY

   Multiconfigurational self-consistent-field energy [Eh] in the course of
   a configuration interaction computation. May be single-root or state-averaged.

.. psivar:: mtd DIPOLE

   Dipole array [e a0] for the named method, (3,).

.. psivar:: mtd QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the named method, (3, 3).

.. psivar:: mtd OCTUPOLE

   Redundant octupole array [e a0^3] for the named method, (3, 3, 3).

.. psivar:: mtd HEXADECAPOLE

   Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3).

.. psivar:: mtd 32-POLE

   Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3).

.. psivar:: mtd 64-POLE

   Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3).

.. psivar:: mtd 128-POLE

   Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3, 3, 3).

.. psivar:: MP2 TOTAL ENERGY
   MP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2 level of theory.

.. psivar:: MP2 TOTAL GRADIENT
   The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).

.. psivar:: MP2 DIPOLE GRADIENT

   The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations
   as a degree-of-freedom by dipole component array, (3 * {nat}, 3).

.. psivar:: MP2 TOTAL HESSIAN

   The total electronic second derivative [Eh/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}).

.. psivar:: MP2.5 TOTAL ENERGY
   MP2.5 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2.5 level of theory.

.. psivar:: MP3 TOTAL ENERGY
   MP3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP3 level of theory.

.. psivar:: MP4(T) CORRECTION ENERGY

   The MP4 triples component [Eh]. Quantity is second right-hand term in
   Eq. :eq:`MP4terms`.

.. psivar:: MP4(SDQ) TOTAL ENERGY
   MP4(SDQ) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP4 singles, doubles, quadruples level of theory.  Quantity
   :psivar:`MP4(SDQ) CORRELATION ENERGY` is
   first right-hand term in Eq. :eq:`MP4terms`.

.. psivar:: MP4 TOTAL ENERGY
   MP4 CORRELATION ENERGY
   MP4(SDTQ) TOTAL ENERGY
   MP4(SDTQ) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the full MP4 level of theory. Quantity :psivar:`MP4 CORRELATION
   ENERGY` / :psivar:`MP4(SDTQ) CORRELATION ENERGY`
   is left-hand term in Eq. :eq:`MP4terms`.

   .. math:: E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}
      :label: MP4terms

.. psivar:: MPn TOTAL ENERGY
   MPn CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the labeled |MollerPlesset| perturbation theory level.
   *n* is MP perturbation order.

.. psivar:: MP2 DOUBLES ENERGY
   MP2.5 DOUBLES ENERGY
   MP3 DOUBLES ENERGY
   CEPA(0) DOUBLES ENERGY
   CEPA(1) DOUBLES ENERGY
   CEPA(2) DOUBLES ENERGY
   CEPA(3) DOUBLES ENERGY
   CISD DOUBLES ENERGY
   QCISD DOUBLES ENERGY
   LCCD DOUBLES ENERGY
   CCD DOUBLES ENERGY
   LCCSD DOUBLES ENERGY
   CCSD DOUBLES ENERGY
   OMP2 DOUBLES ENERGY
   OMP2.5 DOUBLES ENERGY
   OMP3 DOUBLES ENERGY
   OLCCD DOUBLES ENERGY

   The doubles portion [Eh] of the named correlation energy
   including same-spin and opposite-spin correlations.

.. psivar:: MP2 SINGLES ENERGY
   MP2.5 SINGLES ENERGY
   MP3 SINGLES ENERGY
   CEPA(0) SINGLES ENERGY
   CEPA(1) SINGLES ENERGY
   CEPA(2) SINGLES ENERGY
   CEPA(3) SINGLES ENERGY
   CISD SINGLES ENERGY
   QCISD SINGLES ENERGY
   LCCD SINGLES ENERGY
   CCD SINGLES ENERGY
   LCCSD SINGLES ENERGY
   CCSD SINGLES ENERGY
   OLCCD SINGLES ENERGY

   The singles portion [Eh] of the named correlation energy.
   Zero except in ROHF.

.. psivar:: MP2 SAME-SPIN CORRELATION ENERGY
   MP2.5 SAME-SPIN CORRELATION ENERGY
   MP3 SAME-SPIN CORRELATION ENERGY
   CEPA(0) SAME-SPIN CORRELATION ENERGY
   CEPA(1) SAME-SPIN CORRELATION ENERGY
   CEPA(2) SAME-SPIN CORRELATION ENERGY
   CEPA(3) SAME-SPIN CORRELATION ENERGY
   CISD SAME-SPIN CORRELATION ENERGY
   QCISD SAME-SPIN CORRELATION ENERGY
   ACPF SAME-SPIN CORRELATION ENERGY
   AQCC SAME-SPIN CORRELATION ENERGY
   LCCD SAME-SPIN CORRELATION ENERGY
   CCD SAME-SPIN CORRELATION ENERGY
   LCCSD SAME-SPIN CORRELATION ENERGY
   CCSD SAME-SPIN CORRELATION ENERGY
   OLCCD SAME-SPIN CORRELATION ENERGY

   The unscaled portion [Eh] of the named correlation energy
   from same-spin or triplet doubles correlations.

.. psivar:: MP2 OPPOSITE-SPIN CORRELATION ENERGY
   MP2.5 OPPOSITE-SPIN CORRELATION ENERGY
   MP3 OPPOSITE-SPIN CORRELATION ENERGY
   CEPA(0) OPPOSITE-SPIN CORRELATION ENERGY
   CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY
   CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY
   CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY
   CISD OPPOSITE-SPIN CORRELATION ENERGY
   QCISD OPPOSITE-SPIN CORRELATION ENERGY
   ACPF OPPOSITE-SPIN CORRELATION ENERGY
   AQCC OPPOSITE-SPIN CORRELATION ENERGY
   LCCD OPPOSITE-SPIN CORRELATION ENERGY
   CCD OPPOSITE-SPIN CORRELATION ENERGY
   LCCSD OPPOSITE-SPIN CORRELATION ENERGY
   CCSD OPPOSITE-SPIN CORRELATION ENERGY
   OLCCD OPPOSITE-SPIN CORRELATION ENERGY

   The unscaled portion [Eh] of the named correlation energy
   from opposite-spin or singlet doubles correlations.

.. psivar:: MRPT TOTAL ENERGY
   MP2-CCSD TOTAL ENERGY
   MRCC TOTAL ENERGY

   Energies [Eh] from correlated multi-reference theories.

.. psivar:: MULLIKEN CHARGES

   Property of partial atomic charges [e] by the method of Mulliken, (nat,).

.. psivar:: NAUX (SCF)
   NAUX (CC)

   Convenience storage of number of functions [] in the auxiliary basis
   set for named stage of the calculation.

.. psivar:: NBODY (i, j, ..., k)@(a, b, ..., c) TOTAL ENERGY

   The total energy [Eh] of a component of the requested N-Body energy.
   The first parenthetical list over *i*, *j*, ..., *k* enumerates
   molecular fragments included in the computation in 1-indexed,
   input-file order, while the second enumerates list over *a*, *b*,
   ..., *c* enumerates which fragments contribute basis functions to the
   computation.  For example, ``(1, 2)@(1, 2, 3, 4)`` indicates that the
   fragments 1 and 2 are explicitly included in the energy computation,
   with basis functions from each of fragments 1, 2, 3, & 4 included in
   the basis set.  Therefore, the basis functions from fragments 3 and 4
   are included as ghost functions within the energy computation.

.. psivar:: NUCLEAR REPULSION ENERGY

   The nuclear repulsion energy contribution [Eh] to the total SCF energy.
   Quantity :math:`E_{NN}` in Eq. :eq:`SCFterms`.

   .. math:: E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}
      :label: ENN

.. psivar:: OCEPA(0) TOTAL ENERGY
   OCEPA(0) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the orbital-optimized CEPA(0) level of theory.

.. psivar:: OLCCD TOTAL ENERGY
   OLCCD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the orbital-optimized linearized coupled cluster doubles level of theory.

.. psivar:: OLCCD REFERENCE CORRECTION ENERGY

   The additional correction to the SCF reference energy [Eh]
   for the orbital-optimized linearized coupled cluster doubles level of theory.

.. psivar:: OMP2 TOTAL ENERGY
   OMP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the orbital-optimized MP2 level of theory.

.. psivar:: OMP2.5 TOTAL ENERGY
   OMP2.5 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the orbital-optimized MP2.5 level of theory.

.. psivar:: OMP3 TOTAL ENERGY
   OMP3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the orbital-optimized MP3 level of theory.

.. psivar:: ONE-ELECTRON ENERGY

   The one-electron energy contribution [Eh] to the total SCF energy.
   Quantity :math:`E_{1e^-}` in Eq. :eq:`SCFterms`.

.. psivar:: PCM POLARIZATION ENERGY

   The energy contribution [Eh] from the polarizable continuum model for solvation.

.. psivar:: PE ENERGY

   The energy contribution [Eh] from the polarizable embedding model for solvation.

.. psivar:: QCISD TOTAL ENERGY
   QCISD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the quadratic configuration interaction singles and doubles level
   of theory.

.. psivar:: QCISD(T) TOTAL ENERGY
   QCISD(T) CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the quadratic configuration interaction singles and doubles with
   perturbative triples correction level of theory.

.. psivar:: SAPT DISP ENERGY
   SAPT ELST ENERGY
   SAPT EXCH ENERGY
   SAPT IND ENERGY

   Respectively, the dispersion, electrostatics, exchange, and induction
   components of the total electronic interaction energy [Eh] for the
   requested SAPT level of theory. The sum of these four components yields
   :psivar:`SAPT TOTAL ENERGY`.

.. psivar:: SAPT TOTAL ENERGY
   SAPT ENERGY

   The total electronic interaction energy [Eh] for the requested SAPT
   level of theory.

.. psivar:: SAPT ELST10,R ENERGY

   An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0.

.. psivar:: SAPT ELST EXTERN-EXTERN ENERGY

   Electrostatic interaction [Eh] between the point charges in fragments
   A and B in F/I-SAPT.

.. psivar:: SAPT EXCH10 ENERGY

   An exchange-classified SAPT term energy [Eh] implemented for SAPT0.

.. psivar:: SAPT EXCH10(S^2) ENERGY

   An exchange-classified SAPT term energy [Eh] implemented for SAPT0.

.. psivar:: SAPT IND20,R ENERGY
   SAPT EXCH-IND20,R ENERGY
   SAPT IND20,U ENERGY
   SAPT EXCH-IND20,U ENERGY

   An induction-classified SAPT term energy [Eh] implemented for SAPT0.

.. psivar:: SAPT DISP20 ENERGY
   SAPT EXCH-DISP20 ENERGY

   A dispersion-classified SAPT term energy [Eh] implemented for SAPT0.

.. psivar:: SAPT EXCH-DISP20(S^INF) ENERGY

   A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See :ref:`sec:saptinf`.

.. psivar:: SAPT SAME-SPIN DISP20 ENERGY
   SAPT SAME-SPIN EXCH-DISP20 ENERGY

   The portion of :psivar:`SAPT DISP20 ENERGY` or
   :psivar:`SAPT EXCH-DISP20 ENERGY` resulting from
   from same-spin or triplet doubles correlations.

.. psivar:: SAPT HF(2) ENERGY ABC(HF)

   The total Hartree--Fock energy [Eh] of the supersystem implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY AC(0)

   The Hartree--Fock energy [Eh] of subsystems A and C implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY BC(0)

   The Hartree--Fock energy [Eh] of subsystems B and C implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY A(0)

   The Hartree--Fock energy [Eh] of subsystem A implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY B(0)

   The Hartree--Fock energy [Eh] of subsystem B implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY AC(HF)

   The Hartree--Fock localized energy [Eh] of subsystems A and C implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY BC(HF)

   The Hartree--Fock localized energy [Eh] of subsystems B and C implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY AB(HF)

   The Hartree--Fock localized energy [Eh] of subsystems A and B implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY A(HF)

   The Hartree--Fock localized energy [Eh] of subsystem A implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY B(HF)

   The Hartree--Fock localized energy [Eh] of subsystem B implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY C

   The Hartree--Fock energy [Eh] of subsystem C implemented for F/I-SAPT.

.. psivar:: SAPT HF(2) ENERGY HF

   The FI-SAPT Hartree--Fock interaction energy [Eh] implemented for F/I-SAPT.

.. psivar:: SAPT ELST12,R ENERGY

   An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2.

.. psivar:: SAPT EXCH11(S^2) ENERGY
   SAPT EXCH12(S^2) ENERGY

   An exchange-classified SAPT term energy [Eh] implemented for SAPT2.

.. psivar:: SAPT IND22 ENERGY
   SAPT EXCH-IND22 ENERGY

   An induction-classified SAPT term energy [Eh] implemented for SAPT2.

.. .. psivar:: SAPT HF TOTAL ENERGY
.. .. psivar:: SAPT CT ENERGY

.. psivar:: SAPT DISP21 ENERGY

   A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+.

.. psivar:: SAPT DISP22(SDQ) ENERGY
   SAPT DISP22(T) ENERGY
   SAPT EST.DISP22(T) ENERGY

   Dispersion-classified MBPT-based SAPT term energy [Eh] implemented for SAPT2+.

.. psivar:: SAPT DISP2(CCD) ENERGY
   SAPT DISP22(S)(CCD) ENERGY
   SAPT DISP22(T)(CCD) ENERGY
   SAPT EST.DISP22(T)(CCD) ENERGY

   Dispersion-classified coupled-cluster-based SAPT term energy [Eh] implemented for SAPT2+.

.. psivar:: SAPT ELST13,R ENERGY

   An electrostatics-classified SAPT term energy [Eh] implemented for SAPT2+(3).

.. psivar:: SAPT IND30,R ENERGY
   SAPT IND-DISP30 ENERGY
   SAPT EXCH-IND30,R ENERGY

   A induction-classified SAPT term energy [Eh] implemented for SAPT2+3.

.. psivar:: SAPT DISP30 ENERGY
   SAPT EXCH-DISP30 ENERGY
   SAPT EXCH-IND-DISP30 ENERGY

   A dispersion-classified SAPT term energy [Eh] implemented for SAPT2+3.

.. psivar:: SAPT ALPHA

   SAPT exchange-scaling alpha.

.. psivar:: SAPT CT ENERGY

   SAPT charge-transfer energy.

.. psivar:: SAPT HF TOTAL ENERGY

   An induction-classified correction from HF implemented for SAPT0.
   Value varies by SAPT level.

.. psivar:: SAPT MP2 CORRELATION ENERGY

   An induction-classified correction from MP2 implemented for SAPT2.
   Value varies by SAPT level.

.. psivar:: SAPT0 DISP ENERGY
   SAPT0 ELST ENERGY
   SAPT0 EXCH ENERGY
   SAPT0 IND ENERGY
   SSAPT0 DISP ENERGY
   SSAPT0 ELST ENERGY
   SSAPT0 EXCH ENERGY
   SSAPT0 IND ENERGY
   SAPT2 DISP ENERGY
   SAPT2 ELST ENERGY
   SAPT2 EXCH ENERGY
   SAPT2 IND ENERGY
   SAPT2+ DISP ENERGY
   SAPT2+ ELST ENERGY
   SAPT2+ EXCH ENERGY
   SAPT2+ IND ENERGY
   SAPT2+(3) DISP ENERGY
   SAPT2+(3) ELST ENERGY
   SAPT2+(3) EXCH ENERGY
   SAPT2+(3) IND ENERGY
   SAPT2+3 DISP ENERGY
   SAPT2+3 ELST ENERGY
   SAPT2+3 EXCH ENERGY
   SAPT2+3 IND ENERGY

   Respectively, the dispersion, electrostatics, exchange, and induction
   components of the total electronic interaction energy [Eh] for the
   given SAPT level of theory. The sum of these four components yields
   the :samp:`{SAPT Level} TOTAL ENERGY`

.. psivar:: SAPT0 TOTAL ENERGY
   SSAPT0 TOTAL ENERGY
   SAPT2 TOTAL ENERGY
   SAPT2+ TOTAL ENERGY
   SAPT2+(3) TOTAL ENERGY
   SAPT2+3 TOTAL ENERGY

   The total electronic interaction energy [Eh] for the labeled SAPT level
   of theory.

.. psivar:: SAPT2+(CCD) DISP ENERGY
   SAPT2+(CCD) ELST ENERGY
   SAPT2+(CCD) EXCH ENERGY
   SAPT2+(CCD) IND ENERGY
   SAPT2+(3)(CCD) DISP ENERGY
   SAPT2+(3)(CCD) ELST ENERGY
   SAPT2+(3)(CCD) EXCH ENERGY
   SAPT2+(3)(CCD) IND ENERGY
   SAPT2+3(CCD) DISP ENERGY
   SAPT2+3(CCD) ELST ENERGY
   SAPT2+3(CCD) EXCH ENERGY
   SAPT2+3(CCD) IND ENERGY

   Respectively, the dispersion, electrostatics, exchange, and induction
   components of the total electronic interaction energy [Eh] for the
   given SAPT level of theory that incorporates coupled-cluster dispersion.
   The sum of these four components yields the :samp:`{SAPT Level} TOTAL ENERGY`

.. psivar:: SAPT2+(CCD) TOTAL ENERGY
   SAPT2+(3)(CCD) TOTAL ENERGY
   SAPT2+3(CCD) TOTAL ENERGY

   The total electronic interaction energy [Eh] for the labeled SAPT level
   of theory that incorporates coupled-cluster dispersion.

.. psivar:: SAPT2+DMP2 DISP ENERGY
   SAPT2+DMP2 ELST ENERGY
   SAPT2+DMP2 EXCH ENERGY
   SAPT2+DMP2 IND ENERGY
   SAPT2+(3)DMP2 DISP ENERGY
   SAPT2+(3)DMP2 ELST ENERGY
   SAPT2+(3)DMP2 EXCH ENERGY
   SAPT2+(3)DMP2 IND ENERGY
   SAPT2+3DMP2 DISP ENERGY
   SAPT2+3DMP2 ELST ENERGY
   SAPT2+3DMP2 EXCH ENERGY
   SAPT2+3DMP2 IND ENERGY
   SAPT2+(CCD)DMP2 DISP ENERGY
   SAPT2+(CCD)DMP2 ELST ENERGY
   SAPT2+(CCD)DMP2 EXCH ENERGY
   SAPT2+(CCD)DMP2 IND ENERGY
   SAPT2+(3)(CCD)DMP2 DISP ENERGY
   SAPT2+(3)(CCD)DMP2 ELST ENERGY
   SAPT2+(3)(CCD)DMP2 EXCH ENERGY
   SAPT2+(3)(CCD)DMP2 IND ENERGY
   SAPT2+3(CCD)DMP2 DISP ENERGY
   SAPT2+3(CCD)DMP2 ELST ENERGY
   SAPT2+3(CCD)DMP2 EXCH ENERGY
   SAPT2+3(CCD)DMP2 IND ENERGY

   Respectively, the dispersion, electrostatics, exchange, and induction
   components of the total electronic interaction energy [Eh] for the
   given SAPT level of theory that incorporates MP2 induction correction.
   The sum of these four components yields the :samp:`{SAPT Level} TOTAL ENERGY`

.. psivar:: SAPT2+DMP2 TOTAL ENERGY
   SAPT2+(3)DMP2 TOTAL ENERGY
   SAPT2+3DMP2 TOTAL ENERGY
   SAPT2+(CCD)DMP2 TOTAL ENERGY
   SAPT2+(3)(CCD)DMP2 TOTAL ENERGY
   SAPT2+3(CCD)DMP2 TOTAL ENERGY

   The total electronic interaction energy [Eh] for the labeled SAPT level
   of theory that incorporates MP2 induction correction.

.. psivar:: SCF ITERATIONS
   ADC ITERATIONS
   CCSD ITERATIONS
   OPTIMIZATION ITERATIONS

   Number of iterations [] in the named iterative method or optimization procedure.

.. psivar:: SCF DIPOLE

   Dipole array [e a0] for the SCF stage, (3,).

.. psivar:: SCF QUADRUPOLE

   Redundant quadrupole array [e a0^2] for the SCF stage, (3, 3).

.. psivar:: SCF TOTAL ENERGY

   The total electronic energy [Eh] of the SCF stage of the calculation.
   The :samp:`{method} CORRELATION ENERGY` variables from subsequent stages of a
   calculation are often the corresponding :samp:`{method} TOTAL ENERGY`
   variables less this quantity. Constructed from Eq. :eq:`SCFterms`,
   where this quantity is :math:`E_{\text{SCF}}`.

   .. math::
      :nowrap:
      :label: SCFterms

         \begin{align*}
            E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\
                           & = E_{\text{FCTL/HF}} + E_{\text{-D}}
         \end{align*}

   Unless the method includes a dispersion correction, this quantity is
   equal to :psivar:`HF TOTAL ENERGY` (for HF) or
   :psivar:`DFT FUNCTIONAL TOTAL ENERGY` (for
   DFT). Unless the method is a DFT double-hybrid, this quantity is equal
   to :psivar:`DFT TOTAL ENERGY`.

.. psivar:: SCF TOTAL GRADIENT

   The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3).

.. psivar:: SCF DIPOLE GRADIENT

   The derivative of the SCF stage dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations
   as a degree-of-freedom by dipole component array, (3 * {nat}, 3).

.. psivar:: SCF TOTAL HESSIAN

   The total electronic second derivative [Eh/a0/a0] for the SCF stage, (3 * {nat}, 3 * {nat}).

.. psivar:: SCF STABILITY EIGENVALUES

   Array of eigenvalues from UHF or ROHF stability analysis.

.. psivar:: SCS-CCSD TOTAL ENERGY
   SCS-CCSD CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the CCSD-like method formed by reweighting :psivar:`CCSD DOUBLES ENERGY`
   by 1.27 opposite-spin and 1.13 same-spin contributions, with
   any singles carried along.

.. psivar:: SCS-MP2 TOTAL ENERGY
   SCS-MP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by reweighting :psivar:`MP2 DOUBLES ENERGY`
   by 6/5 opposite-spin and 1/3 same-spin contributions, with
   any singles carried along.

.. psivar:: SCS-MP2-VDW TOTAL ENERGY
   SCS-MP2-VDW CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by reweighting :psivar:`MP2 DOUBLES ENERGY`
   by 1.28 opposite-spin and 0.50 same-spin contributions, with
   any singles carried along. DOI: 10.1080/00268970802641242

.. psivar:: SCS(N)-MP2 TOTAL ENERGY
   SCS(N)-MP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by reweighting :psivar:`MP2 DOUBLES ENERGY`
   by 0 opposite-spin and 1.76 same-spin contributions, with
   any singles carried along. doi: 10.1021/ct6002737

.. psivar:: SCS(N)-OMP2 CORRELATION ENERGY
   SCS(N)-OMP2 TOTAL ENERGY
   SCSN-OMP2 CORRELATION ENERGY
   SCSN-OMP2 TOTAL ENERGY

   Two spellings of a discontinued QCVariable that may still appear
   because the code is frozen pending an update.

.. psivar:: SCS-OMP2 TOTAL ENERGY
   SCS-OMP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the OMP2-like method formed by reweighting :psivar:`OMP2 DOUBLES ENERGY`
   by 6/5 opposite-spin and 1/3 same-spin contributions, with
   any singles carried along.

.. psivar:: SCS-MP3 TOTAL ENERGY
   SCS-MP3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP3-like method formed by reweighting the difference between
   :psivar:`MP3 DOUBLES ENERGY` and :psivar:`MP2 DOUBLES ENERGY`
   by 0.25, atop the SCS-MP2 energy, with any singles carried along.

.. psivar:: SCS-OMP3 TOTAL ENERGY
   SCS-OMP3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the OMP3-like method formed by reweighting the difference between
   :psivar:`OMP3 DOUBLES ENERGY` and :psivar:`OMP2 DOUBLES ENERGY`
   by 0.25, atop the SCS-OMP2 energy, with any singles carried along.

.. psivar:: SOS-MP2 TOTAL ENERGY
   SOS-MP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by reweighting :psivar:`MP2 DOUBLES ENERGY`
   by 1.3 opposite-spin and 0 same-spin contributions, with
   any singles carried along.

.. psivar:: SOS-OMP2 TOTAL ENERGY
   SOS-OMP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the OMP2-like method formed by reweighting :psivar:`OMP2 DOUBLES ENERGY`
   by 1.2 opposite-spin and 0 same-spin contributions, with
   any singles carried along.

.. psivar:: SOS-OMP3 TOTAL ENERGY
   SOS-OMP3 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the OMP3-like method formed by reweighting the difference between
   :psivar:`OMP3 DOUBLES ENERGY` and :psivar:`OMP2 DOUBLES ENERGY`
   by 0.25, atop the SOS-OMP2
   energy using non-canonical weighting, with any singles carried along.

.. psivar:: SOS-PI-MP2 TOTAL ENERGY
   SOS-PI-MP2 CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the MP2-like method formed by reweighting :psivar:`MP2 DOUBLES ENERGY`
   by 1.4 opposite-spin and 0 same-spin contributions, with
   any singles carried along.

.. psivar:: TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY
   TD-fctl ROOT 0 (h) -> ROOT m (i) EXCITATION ENERGY
   TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY - h TRANSITION

   The excitation energy of a given method from ground state to root m.
   DFT functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.


.. psivar:: TD-fctl ROOT 0 -> ROOT m ELECTRIC TRANSITION DIPOLE MOMENT (LEN)
   TD-fctl ROOT 0 (h) -> ROOT m (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)
   TD-fctl ROOT 0 -> ROOT m ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m ELECTRIC TRANSITION DIPOLE MOMENT (VEL)
   TD-fctl ROOT 0 (h) -> ROOT m (i) ELECTRIC TRANSITION DIPOLE MOMENT (VEL)
   TD-fctl ROOT 0 -> ROOT m ELECTRIC TRANSITION DIPOLE MOMENT (VEL) - h TRANSITION

   The electric transition dipole moment in length or velocity gauge of named method
   from ground state to root m in h symmetry (if available). DFT
   functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: TD-fctl ROOT 0 -> ROOT m LEFT EIGENVECTOR ALPHA
   TD-fctl ROOT 0 (h) -> ROOT m (i) LEFT EIGENVECTOR ALPHA
   TD-fctl ROOT 0 -> ROOT m LEFT EIGENVECTOR ALPHA - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m LEFT EIGENVECTOR BETA
   TD-fctl ROOT 0 (h) -> ROOT m (i) LEFT EIGENVECTOR BETA
   TD-fctl ROOT 0 -> ROOT m LEFT EIGENVECTOR BETA - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m RIGHT EIGENVECTOR ALPHA
   TD-fctl ROOT 0 (h) -> ROOT m (i) RIGHT EIGENVECTOR ALPHA
   TD-fctl ROOT 0 -> ROOT m RIGHT EIGENVECTOR ALPHA - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m RIGHT EIGENVECTOR BETA
   TD-fctl ROOT 0 (h) -> ROOT m (i) RIGHT EIGENVECTOR BETA
   TD-fctl ROOT 0 -> ROOT m RIGHT EIGENVECTOR BETA - h TRANSITION

   The left and right alpha and beta spin eigenvectors of the named method
   from ground state to root m in h symmetry (if available). DFT
   functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: TD-fctl ROOT 0 -> ROOT m MAGNETIC TRANSITION DIPOLE MOMENT
   TD-fctl ROOT 0 (h) -> ROOT m (i) MAGNETIC TRANSITION DIPOLE MOMENT
   TD-fctl ROOT 0 -> ROOT m MAGNETIC TRANSITION DIPOLE MOMENT - h TRANSITION

   The magnetic transition dipole moment in length or velocity gauge of named method
   from ground state to root m in h symmetry (if available). DFT
   functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: CC ROOT n (h) -> ROOT m (i) OSCILLATOR STRENGTH (LEN)
   TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN)
   TD-fctl ROOT 0 (h) -> ROOT m (i) OSCILLATOR STRENGTH (LEN)
   TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL)
   TD-fctl ROOT 0 (h) -> ROOT m (i) OSCILLATOR STRENGTH (VEL)
   TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h TRANSITION

   The oscillator strength in length or velocity gauge of named method
   from ground state to root m in h symmetry (if available). DFT
   functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: CC ROOT n (h) -> ROOT m (i) ROTARY STRENGTH (LEN)
   CC ROOT n (h) -> ROOT m (i) ROTARY STRENGTH (VEL)
   TD-fctl ROOT 0 -> ROOT m ROTARY STRENGTH (LEN)
   TD-fctl ROOT 0 (h) -> ROOT m (i) ROTARY STRENGTH (LEN)
   TD-fctl ROOT 0 -> ROOT m ROTARY STRENGTH (LEN) - h TRANSITION
   TD-fctl ROOT 0 -> ROOT m ROTARY STRENGTH (VEL)
   TD-fctl ROOT 0 (h) -> ROOT m (i) ROTARY STRENGTH (VEL)
   TD-fctl ROOT 0 -> ROOT m ROTARY STRENGTH (VEL) - h TRANSITION

   The rotary strength in length or velocity gauge of named method
   from ground state to root m in h symmetry (if available). DFT
   functional labeled if canonical.
   Conventions for root indexing and whether h refers to transition or root
   irrep are as in :ref:`sec:psivarnotes`.

.. psivar:: THERMAL ENERGY

   Total thermal energy E [Eh] at given temperature.

.. psivar:: THERMAL ENERGY CORRECTION

   Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature.

.. psivar:: TWO-ELECTRON ENERGY

   The two-electron energy contribution [Eh] to the total SCF energy.
   Quantity :math:`E_{2e^-}` in Eq. :eq:`SCFterms`.

.. psivar:: UNCP-CORRECTED 2-BODY INTERACTION ENERGY

   The interaction energy [Eh] considering only two-body interactions,
   computed without counterpoise correction.
   Related variable :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY`.

   .. math:: E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}

.. psivar:: WIBERG LOWDIN INDICES

   Property of Wiberg bond indices using orthogonal L\ |o_dots|\ wdin orbitals, (nat, nat).

.. psivar:: ZAPTn TOTAL ENERGY
   ZAPTn CORRELATION ENERGY

   The total electronic energy [Eh] and correlation energy component [Eh]
   for the labeled Z-averaged perturbation theory level.
   *n* is ZAPT perturbation order.

.. psivar:: ZERO K ENTHALPY

   Total electronic and zero-point energy [Eh] at 0 [K].

.. psivar:: ZPVE

   Vibrational zero-point energy [Eh] at 0 [K].

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. index:: basis set; default auxiliary
.. _`apdx:basisFamily`:

Auxiliary Basis Sets
====================

|
|

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:

   autodoc_basissets_byfamily

.. include:: autodoc_basissets_byfamily.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: SAPT
   pair: SAPT; theory

.. _`sec:sapt`:

SAPT: Symmetry-Adapted Perturbation Theory
==========================================

.. codeauthor:: Edward G. Hohenstein, Rob M. Parrish, J\ |e_acute|\ r\ |o_circumflex|\ me F. Gonthier, and Daniel. G. A. Smith
.. sectionauthor:: Edward G. Hohenstein and J\ |e_acute|\ r\ |o_circumflex|\ me F. Gonthier

*Module:* :ref:`Keywords <apdx:sapt>`, :ref:`PSI Variables <apdx:sapt_psivar>`, :source:`LIBSAPT_SOLVER <psi4/src/psi4/libsapt_solver>`

.. warning:: In rare cases with systems having a high degree of symmetry, 
   |Psifour| gives (very obviously) wrong answers for SAPT computations 
   when the specification is in Z-matrix format. Use a Cartesian representation 
   to avoid this problem.

.. caution:: In early versions (notably |Psifour| alpha circa 2011
   and before), frozen core was implemented incompletely and for
   only selected terms. Comparisons with papers published using early
   |PSIfour| SAPT code may show discrepancies of 0.01-0.10 kcal/mol in
   individual terms, particularly :math:`E_{exch}^{(11)}` and :math:`E_{exch}^{(12)}`.

.. caution:: January 28th 2016, the default for all NAT_ORBS options
   was changed to true. Hence the code now by default uses natural
   orbital truncation to speed up the evaluation of energy terms
   wherever possible, according to literature recommendations.
   In early July 2016, some total SAPT energy psivars were renamed.

.. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing
   possible discrepancies with prior versions of the code on the order of
   0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677

.. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations
   is now standardized. Specifically, we now rigorously enforce that the number of core orbitals 
   frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to
   this, a discrepency between these values was possible when one of the monomers was (exclusively) 
   a charged alkali metal. 

Symmetry-adapted perturbation theory (SAPT) provides a means of directly
computing the noncovalent interaction between two molecules, that is, the
interaction energy is determined without computing the total energy of the
monomers or dimer. In addition, SAPT provides a decomposition of the
interaction energy into physically meaningful components: *i.e.*,
electrostatic, exchange, induction, and dispersion terms. In SAPT, the 
Hamiltonian of the dimer is partitioned into contributions from each 
monomer and the interaction.

.. math:: H=F_A+W_A+F_B+W_B+V

Here, the Hamiltonian is written as a sum of the usual monomer Fock
operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the
interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are
treated as the zeroth-order Hamiltonian and the interaction energy is
evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. 
Through first-order in :math:`V`, electrostatic and exchange interactions are
included; induction and dispersion first appear at second-order in :math:`V`. For
a complete description of SAPT, the reader is referred to the excellent
review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887]_.

Several truncations of the closed-shell SAPT expansion are available in the SAPT
module of |PSIfour|. The simplest truncation of SAPT is denoted SAPT0
and defined in Eq. :eq:`SAPT0`.

.. math:: E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +
   E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}
   :label: SAPT0

In this notation, :math:`E^{(vw)}` defines the order in :math:`V` and in :math:`W_A+W_B`; the
subscript, :math:`resp`, indicates that orbital relaxation effects are included.

.. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +
   E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}
   :label: SAPT2

.. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}
   :label: SAPT2p

.. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}
   :label: SAPT2pparen3

.. math:: E_{SAPT2+3} = E_{SAPT2+(3)}
   + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}
   + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}
   - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}
   :label: SAPT2p3

For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be :math:`K_A+K_B`, the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. 

.. math:: E_{SAPT(DFT)} =  E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +
   E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}
   :label: SAPTDFT
.. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right)

.. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right)


The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}^{(3)}` terms take into
account higher-order induction effects and are included in the definition
of SAPT terms. They are computed from the Hartree--Fock supermolecular interaction energy
:math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT
computations, which is the default (see below for monomer-centered basis 
computations). They are defined by:

.. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} 
          + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)})
          :label: dHF2

.. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} 
          + E_{ind,resp}^{(30)})
          :label: dHF3

Additionally, high-order coupling between induction and dispersion can be 
extracted from the supermolecular MP2 interaction energy:

.. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +
          E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}
          + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)})

.. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})

where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 
interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the 
description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`
can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` 
should be applied to SAPT2+3 energies.

A thorough analysis of the performance of these truncations of closed-shell SAPT can be
found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,
and a systematic study of the accuracy of these truncations (with and 
without an improved CCD treatment of dispersion) using different basis sets
is reported in [Parker:2014:094106]_.

The closed-shell SAPT module relies entirely on the density-fitting approximation
of the two-electron integrals. The factorization of the SAPT energy
expressions, as implemented in |PSIfour|, assumes the use of density-fitted
two-electron integrals, therefore, the closed-shell SAPT module cannot be run with
exact integrals. In practice, we have found that the density-fitting
approximation introduces negligible errors into the SAPT energy 
(often less than 0.01 kcal/mol for small dimers) and greatly
improves efficiency. 

The latest addition to the SAPT code is the SAPT0 method for open-shell 
monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, 
except for the dispersion terms which implementation relies on a density fitting
factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled
induction computations are currently not supported with ``ROHF``. This means that orbital
relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.
If both monomers are open-shell, their coupling is assumed to be high spin, i.e.
two doublets would interact to form a triplet.

The *S*\ :superscript:`2` approximation and scaling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

All exchange terms in SAPT arise from the antisymmetrization
of the wavefunctions of monomers A and B. Taking into account exchange of all possible
electron pairs between the two monomers yields to complicated formulae.
For this reason, exchange terms are often evaluated in the :math:`S^{2}`
approximation, that can be interpreted as the exchange of a single electron 
pair between monomers.

The :math:`S^{2}` approximation is usually pretty good, but may 
break down for short intermolecular distance, particularly in high-order
terms. To compensate these deviations, Parker et al. [Parker:2014:094106]_ 
recommend to scale all :math:`S^{2}` approximated exchange terms by the ratio:

.. math:: p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}

where the recommended exponent is :math:`\alpha = 1`. To obtain SAPT energies with this scaling,
simply set the keyword ``exch_scale_alpha true``. Alternatively, another value for :math:`\alpha`
can be specified by setting |sapt__exch_scale_alpha| to a value. For example, ::

  set exch_scale_alpha 1.0

will set :math:`\alpha = 1.0` and scale exchange energies with :math:`p_{EX}(1.0)`.

Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified 
recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. 
To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_).

.. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +
   p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} 
   + \delta_{HF}^{(2)}
   :label: sSAPT0

where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that 
sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the
scaling is automatically performed by requesting ``energy('ssapt0')``.


A First Example
^^^^^^^^^^^^^^^

The following is the simplest possible input that will perform all
available SAPT computations (normally, you would pick one of these methods,
not all of them). ::

	molecule water_dimer {
	     0 1
	     O  -1.551007  -0.114520   0.000000
	     H  -1.934259   0.762503   0.000000
	     H  -0.599677   0.040712   0.000000
	     --
	     0 1
	     O   1.350625   0.111469   0.000000
	     H   1.680398  -0.373741  -0.758561
	     H   1.680398  -0.373741   0.758561
	
	     units angstrom
	     no_reorient
	     symmetry c1
	}
	
	set basis aug-cc-pvdz
	
	energy('sapt0')
	energy('sapt2')
	energy('sapt2+')
	energy('sapt2+(3)')
	energy('sapt2+3')

The SAPT module uses the standard |PSIfour| partitioning of the dimer
into monomers. SAPT does not use spatial symmetry and needs the geometry
of the system to remain fixed throughout monomer and dimer calculations.
These requirements are imposed whenever a SAPT calculation is requested
but can also be set explicitly with the ``no_reorient`` and ``symmetry
c1`` molecule keywords, as in the example above. As a reminder, only
SAPT0 can handle the interaction of both closed- and open-shell monomers.
Higher-order SAPT and SAPT(DFT) are currently available only 
for computation of interactions between
closed-shell singlets.  The SAPT codes in |PSIfour| have been written
to utilize density fitting, which is much faster than using conventional
4-index electron repulsion integrals.  This happens automatically and
does not require any additional keywords to be specified (both the 
SAPT computations and the underlying Hartree-Fock computations will
utilize density fitting).


For SAPT(DFT), the user will need to manually specify the GRAC shift of 
both monomers, defined by the difference of ionization potential (IP) and
Kohn-Sham HOMO energy. The ionization potential data for many common molecules 
is available in NIST Chemistry Webbook. Alternatively, one can estimate the
ionization potential of molecule by computing the energy difference between
the molecule as given, and the molecule after one electron has been removed
(e.g., the energy difference between a neutral molecule and its cation).

The values of GRAC shifts should be given in Hartree. For the example above,
the GRAC shift value of both molecules are calculated to be 0.1307, and the 
user would specify them using the following keywords::


    set globals {
        sapt_dft_grac_shift_a 0.1307
        sapt_dft_grac_shift_b 0.1307 
    }

A complete, minimal example of a SAPT(DFT) computation is given below. ::

    molecule {
        0 1
        O  -1.551007  -0.114520   0.000000
        H  -1.934259   0.762503   0.000000
        H  -0.599677   0.040712   0.000000
        --
        0 1
        O   1.350625   0.111469   0.000000
        H   1.680398  -0.373741  -0.758561
        H   1.680398  -0.373741   0.758561

        units angstrom
    }
    
    set {
        basis                  aug-cc-pVDZ
        sapt_dft_grac_shift_a  0.1307
        sapt_dft_grac_shift_b  0.1307
    }
    
    energy('sapt(dft)')


As already mentioned above, the SAPT0 module for open-shell cases can also
use exact integrals for all terms except for dispersion. In practice,
density fitting is considerably faster and introduces negligible errors, thus
it is the preferred method for open-shell cases as well.
Below, you can find a minimum example of open-shell SAPT0 computation. ::

    molecule {
        0 1
        O 0.000000  0.000000  6.000000
        H 0.000000  1.431500  4.890600
        H 0.000000 -1.431500  4.890600
        --
        0 2
        O 0.000000  0.000000  0.000000
        O 0.000000  2.503900  0.000000
        H 0.000000 -0.424700 -1.839500
        units bohr
        symmetry c1
        no_reorient
        no_com
    }
    
    set {
        reference    uhf
        scf_type     df
        basis        aug-cc-pVDZ
    }
    
    energy('sapt0')
    
    

|scf__reference| needs to be ``UHF``  or ``ROHF`` for the open-shell computation to proceed.

Advanced example
^^^^^^^^^^^^^^^^

Open-shell computations can be difficult to converge in certain cases, thus you may
want to have more control over the SCF procedure. You have the option of 
doing the driver job in the input file, by performing the dimer and monomer computations
yourself. In the example below, we do a stability analysis for the open-shell monomer only ::

  molecule {
       0 2
       O 0.000000  0.000000  0.000000
       O 0.000000  2.503900  0.000000
       H 0.000000 -0.424700 -1.839500
       --
       0 1
       O 0.000000  0.000000  6.000000
       H 0.000000  1.431500  4.890600
       H 0.000000 -1.431500  4.890600
       units bohr
       symmetry c1
       no_reorient
       no_com
  }
  
  dimer = psi4.get_active_molecule()  
  
  set {
  reference uhf
  scf_type     df
  basis         cc-pVDZ
  df_basis_sapt cc-pVDZ-ri
  guess sad
  }
  
  dimer = psi4.get_active_molecule()
  
  set df_ints_io save
  psi4.IO.set_default_namespace('dimer')
  Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True)
  set df_ints_io load
  
  monomerA = dimer.extract_subsets(1,2)
  psi4.IO.change_file_namespace(97, 'dimer', 'monomerA')
  psi4.IO.set_default_namespace('monomerA')
  set {
  stability_analysis follow
  }
  EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True)
  
  monomerB = dimer.extract_subsets(2,1)
  psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB')
  psi4.IO.set_default_namespace('monomerB')
  set {
  stability_analysis none
  }
  EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True)
  
  psi4.IO.change_file_namespace(97, 'monomerB', 'dimer')
  psi4.IO.set_default_namespace('dimer')
  
  aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), "DF_BASIS_SAPT",
                                psi4.core.get_global_option("DF_BASIS_SAPT"),
                                "RIFIT", psi4.core.get_global_option("BASIS"))
  wfn_dimer.set_basisset("DF_BASIS_SAPT", aux_basis)
  wfn_dimer.set_basisset("DF_BASIS_ELST", aux_basis)
  
  psi4.sapt(wfn_dimer,wfn_monA,wfn_monB)

In this way, any of the SCF options can be tweaked for individual fragments.
For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,
which contains the three-index integrals for density fitting. ``set df_ints_io load``
then instructs the program to read these integrals from disk instead of recomputing
them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely
name scratch files. In the following SCF step, only file 97 is renamed using
``psi4.IO.change_file_namespace`` so that integrals can be read from it.
For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`
documentation.

.. index:: SAPT; SAPT0

SAPT0
^^^^^

Generally speaking, SAPT0 should be applied to large systems or large data
sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which
seems to be optimal with a truncated aug-cc-pVDZ basis, namely,
jun-cc-pVDZ (which we have referred to in previous work as
aug-cc-pVDZ').  We do not recommend using SAPT0 with large basis sets
like aug-cc-pVTZ.  A systematic study of the accuracy of closed-shell SAPT0 and other SAPT 
truncations, using different basis sets, is reported in 
[Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0
can yield improved performance and has been included in the output file as
the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically 
computed when SAPT0 is requested (see above for more details).
The SAPT module has been used to perform SAPT0 computations with over
200 atoms and 2800 basis functions; this code should be scalable to 4000
basis functions. Publications resulting from the use of the SAPT0 code 
should cite the following publications: [Hohenstein:2010:184111]_ and 
[Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,
[Gonthier:2016:134106]_ should be additionally cited.

Basic SAPT0 Keywords
~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__sapt_level.rst
.. include:: autodir_options_c/sapt__basis.rst
.. include:: autodir_options_c/sapt__df_basis_sapt.rst
.. include:: autodir_options_c/sapt__df_basis_elst.rst
.. include:: autodir_options_c/sapt__freeze_core.rst
.. include:: autodir_options_c/sapt__d_convergence.rst
.. include:: autodir_options_c/sapt__e_convergence.rst
.. include:: autodir_options_c/sapt__maxiter.rst
.. include:: autodir_options_c/sapt__print.rst

Advanced SAPT0 Keywords
~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__aio_cphf.rst
.. include:: autodir_options_c/sapt__aio_df_ints.rst
.. include:: autodir_options_c/sapt__coupled_induction.rst
.. include:: autodir_options_c/sapt__exch_scale_alpha.rst
.. include:: autodir_options_c/sapt__ints_tolerance.rst
.. include:: autodir_options_c/sapt__denominator_delta.rst
.. include:: autodir_options_c/sapt__denominator_algorithm.rst
.. include:: autodir_options_c/globals__debug.rst

Specific open-shell SAPT0 keywords
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__sapt_mem_safety.rst
.. include:: autodir_options_c/sapt__coupled_induction.rst

.. index:: SAPT; SAPT(DFT)


SAPT(DFT)
^^^^^^^^^

In general, SAPT(DFT) should provide more accurate interaction energy 
components, and overall interaction energies, than SAPT0. The drawback 
is SAPT(DFT) method is more computationally demanding than SAPT0, 
SAPT(DFT) can still be applied to medium-sized or large systems. The 
SAPT(DFT) module was employed successfully in computations of systems 
with up to 2000 basis functions, and the code should be scalable to 
3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires 
sufficient memory to hold :math:`2ovN_aux` doubles.


SAPT(DFT) requires a few special treatments to obtain accurate
result. The DFT functionals used in SAPT(DFT) need to be asymptotically
corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),
in order to recover the correct long-range asymptotic behavior
(approaching :math:`-1/r` as :math:`r` approaches infinity). The program
requires manual input of GRAC shift parameter for each monomer through
keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,
which should be equal to the difference of the actual ionization
potential and the corresponding Kohn-Sham HOMO energy. The dispersion
term needs to be computed with orbital response for good accuracy,
and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to
``True`` by default). The coupled exchange-dispersion energy is usually
estimated by scaling from the uncoupled value either by a fitted fixed
value as suggested by [Hesselmann:2014:094107]_, or by the ratio of
coupled and uncoupled dispersion energy. This can be controlled by
keyword |sapt__sapt_dft_exch_disp_scale_scheme|, with ``FIXED`` being
the former approach, ``DISP`` being the latter and ``NONE`` for not
scaling and use the uncoupled exchange-dispersion energy directly.


Basic Keywords for SAPT(DFT) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__sapt_dft_grac_shift_a.rst
.. include:: autodir_options_c/sapt__sapt_dft_grac_shift_b.rst
.. include:: autodir_options_c/sapt__sapt_dft_do_dhf.rst
.. include:: autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.rst

Advanced Keywords for SAPT(DFT)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__sapt_dft_functional.rst
.. include:: autodir_options_c/sapt__sapt_dft_do_hybrid.rst
.. include:: autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.rst
.. include:: autodir_options_c/sapt__sapt_dft_mp2_disp_alg.rst
.. include:: autodir_options_c/sapt__sapt_quiet.rst


.. index:: SAPT; higher-order

Higher-Order SAPT
^^^^^^^^^^^^^^^^^

For smaller systems (up to the size of a nucleic acid base pair), more
accurate interaction energies can be obtained through higher-order SAPT
computations. The SAPT module can perform density-fitted evaluations
of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems 
only. Publications resulting from the use of the higher-order SAPT code 
should cite the following: 
[Hohenstein:2010:014101]_.

For methods SAPT2+ and above, one can replace the many-body treatment of
dispersion by an improved method based on coupled-cluster doubles (CCD).
This approach tends to give good improvements when dispersion effects
are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).
As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers
more accurate interaction energies tends to depend on the SAPT truncation
and basis set employed, due to cancellations of errors.  Thanks to
natural orbital methods [Parrish:2013:174102]_, the SAPT code
is able to include CCD dispersion with only a modest additional cost.
Computations employing CCD dispersion should cite [Parrish:2013:174102]_. 
To request CCD dispersion treatment in a SAPT computation, simply append
``(ccd)`` to the name of the method, as in the following examples ::

	energy('sapt2+(ccd)')
	energy('sapt2+(3)(ccd)')
	energy('sapt2+3(ccd)')

The :math:`\delta_{MP2}` corrections can also be computed automatically
by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::

	energy('sapt2+dmp2')
	energy('sapt2+(3)dmp2')
	energy('sapt2+3dmp2')
	energy('sapt2+(ccd)dmp2')
	energy('sapt2+(3)(ccd)dmp2')
	energy('sapt2+3(ccd)dmp2')

A brief note on memory usage: the higher-order SAPT code assumes that
certain quantities can be held in core. This code requires sufficient
memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this
requirement computations on the adenine-thymine complex can be performed
with an aug-cc-pVTZ basis in less than 64GB of memory.

Higher-order SAPT is treated separately from the highly optimized SAPT0
code, therefore, higher-order SAPT uses a separate set of keywords. 
The following keywords are relevant for higher-order SAPT.

Basic Keywords for Higher-order SAPT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__basis.rst
.. include:: autodir_options_c/sapt__df_basis_sapt.rst
.. include:: autodir_options_c/globals__freeze_core.rst
.. include:: autodir_options_c/sapt__print.rst

Advanced Keywords for Higher-order SAPT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__do_ccd_disp.rst
.. include:: autodir_options_c/sapt__do_mbpt_disp.rst
.. include:: autodir_options_c/sapt__do_third_order.rst
.. include:: autodir_options_c/sapt__ints_tolerance.rst
.. include:: autodir_options_c/sapt__sapt_mem_check.rst
.. include:: autodir_options_c/globals__debug.rst

MP2 Natural Orbitals
^^^^^^^^^^^^^^^^^^^^

One of the unique features of the SAPT module is its ability to use
MP2 natural orbitals (NOs) to speed up the evaluation of the triples
contribution to dispersion. By transforming to the MP2 NO basis, we can
throw away virtual orbitals that are expected to contribute little to the
dispersion energy. Speedups in excess of :math:`50 \times` are possible. In
practice, this approximation is very good and should always be applied.
Publications resulting from the use of MP2 NO-based approximations should 
cite the following: [Hohenstein:2010:104107]_.

Basic Keywords Controlling MP2 NO Approximations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__nat_orbs_t2.rst
.. include:: autodir_options_c/sapt__nat_orbs_t3.rst
.. include:: autodir_options_c/sapt__nat_orbs_v4.rst
.. include:: autodir_options_c/sapt__occ_tolerance.rst

.. comment Advanced Keywords Controlling MP2 NO Approximations
.. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst

.. index:: SAPT; charge-transfer

.. _`sec:saptct`:

Charge-Transfer in SAPT
^^^^^^^^^^^^^^^^^^^^^^^

It is possible to obtain the stabilization energy of a complex due to
charge-transfer effects from a SAPT computation. The charge-transfer energy 
can be computed with the SAPT module as described by Stone
and Misquitta [Misquitta:2009:201]_.

Charge-transfer energies can be obtained from the following calls to the
energy function. ::

    energy('sapt0-ct')
    energy('sapt2-ct')
    energy('sapt2+-ct')
    energy('sapt2+(3)-ct')
    energy('sapt2+3-ct')
    energy('sapt2+(ccd)-ct')
    energy('sapt2+(3)(ccd)-ct')
    energy('sapt2+3(ccd)-ct')

For now, charge transfer computations are not available with open-shell SAPT0.

A SAPT charge-transfer analysis will perform 5 HF computations: the dimer
in the dimer basis, monomer A in the dimer basis, monomer B in the dimer
basis, monomer A in the monomer A basis, and monomer B in the monomer B
basis. Next, it performs two SAPT computations, one in the dimer basis and
one in the monomer basis. Finally, it will print a summary of the
charge-transfer results::

      SAPT Charge Transfer Analysis
    ------------------------------------------------------------------------------------------------
      SAPT Induction (Dimer Basis)       -2.0970 [mEh]      -1.3159 [kcal/mol]      -5.5057 [kJ/mol]
      SAPT Induction (Monomer Basis)     -1.1396 [mEh]      -0.7151 [kcal/mol]      -2.9920 [kJ/mol]
      SAPT Charge Transfer               -0.9574 [mEh]      -0.6008 [kcal/mol]      -2.5137 [kJ/mol]

These results are for the water dimer geometry shown above computed with 
SAPT0/aug-cc-pVDZ. 


.. index:: 
   pair: SAPT; output

Monomer-Centered Basis Computations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The charge-transfer analysis above is carried out by taking the
difference between SAPT induction as calculated in the dimer-centered
basis (*i.e.*, each monomer sees the basis functions on both monomers)
vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its
own basis set).  It is also possible to run a closed-shell SAPT computation at any
level using only the monomer-centered basis. To do this, simply add
``sapt_basis='monomer'`` to the energy function, such as ::

    energy('sapt2',sapt_basis='monomer')

This procedure leads to faster compuations, but it converges more slowly
towards the complete basis set limit than the default procedure, which uses
the dimer-centered basis set.  Hence, monomer-centered basis SAPT
computations are not recommended. The open-shell SAPT0 code is not
compatible yet with monomer-centered computations.

Computations with Mid-bonds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SAPT computations with midbonds can be accomplished by adding a third ghost
monomer to the computation.  For example ::

    molecule dimer {
        0 1
        He 0  0  5
        --
        0 1
        He 0  0 -5
        --
        0 1
        @He 0  0  0
    }


Here the functions of the third monomer will be added to the virtual space of
the entire computation. Note that an error will be thrown if each atom in the
third monomer is not a ghost to prevent confusion with three-body SAPT which is
not currently supported by Psi4.


Interpreting SAPT Results
^^^^^^^^^^^^^^^^^^^^^^^^^

We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the
water dimer. This computation can be performed with the following 
input::

    molecule water_dimer {
         0 1
         O  -1.551007  -0.114520   0.000000
         H  -1.934259   0.762503   0.000000
         H  -0.599677   0.040712   0.000000
         --
         0 1
         O   1.350625   0.111469   0.000000
         H   1.680398  -0.373741  -0.758561
         H   1.680398  -0.373741   0.758561
         units angstrom
    }
    
    set globals {
        basis          aug-cc-pvdz
        guess          sad
        scf_type       df
    }
    
    set sapt {
        print          1
        nat_orbs_t2    true
        freeze_core    true
    }
    
    energy('sapt2+3')

To reiterate some of the options mentioned above: the
|sapt__nat_orbs_t2| option will compute MP2 natural orbitals and use
them in the evaluation of the triples correction to dispersion, and the
|sapt__freeze_core| option will freeze the core throughout the SAPT
computation. This SAPT2+3/aug-cc-pVDZ computation produces the following
results::

    SAPT Results
  --------------------------------------------------------------------------------------------------------
    Electrostatics                -13.06509118 [mEh]      -8.19846883 [kcal/mol]     -34.30239689 [kJ/mol]
      Elst10,r                    -13.37542977 [mEh]      -8.39320925 [kcal/mol]     -35.11719087 [kJ/mol]
      Elst12,r                      0.04490350 [mEh]       0.02817737 [kcal/mol]       0.11789413 [kJ/mol]
      Elst13,r                      0.26543510 [mEh]       0.16656305 [kcal/mol]       0.69689985 [kJ/mol]

    Exchange                       13.41768202 [mEh]       8.41972294 [kcal/mol]      35.22812415 [kJ/mol]
      Exch10                       11.21822294 [mEh]       7.03954147 [kcal/mol]      29.45344432 [kJ/mol]
      Exch10(S^2)                  11.13802706 [mEh]       6.98921779 [kcal/mol]      29.24289005 [kJ/mol]
      Exch11(S^2)                   0.04558907 [mEh]       0.02860757 [kcal/mol]       0.11969410 [kJ/mol]
      Exch12(S^2)                   2.15387002 [mEh]       1.35157390 [kcal/mol]       5.65498573 [kJ/mol]

    Induction                      -3.91313050 [mEh]      -2.45552656 [kcal/mol]     -10.27392413 [kJ/mol]
      Ind20,r                      -4.57530818 [mEh]      -2.87104935 [kcal/mol]     -12.01247162 [kJ/mol]
      Ind30,r                      -4.91714746 [mEh]      -3.08555675 [kcal/mol]     -12.90997067 [kJ/mol]
      Ind22                        -0.83718642 [mEh]      -0.52534243 [kcal/mol]      -2.19803293 [kJ/mol]
      Exch-Ind20,r                  2.47828501 [mEh]       1.55514739 [kcal/mol]       6.50673730 [kJ/mol]
      Exch-Ind30,r                  4.33916119 [mEh]       2.72286487 [kcal/mol]      11.39246770 [kJ/mol]
      Exch-Ind22                    0.45347471 [mEh]       0.28455969 [kcal/mol]       1.19059785 [kJ/mol]
      delta HF,r (2)               -1.43239563 [mEh]      -0.89884187 [kcal/mol]      -3.76075473 [kJ/mol]
      delta HF,r (3)               -0.85440936 [mEh]      -0.53614999 [kcal/mol]      -2.24325177 [kJ/mol]

    Dispersion                     -3.62000698 [mEh]      -2.27158877 [kcal/mol]      -9.50432831 [kJ/mol]
      Disp20                       -3.54291925 [mEh]      -2.22321549 [kcal/mol]      -9.30193450 [kJ/mol]
      Disp30                        0.05959979 [mEh]       0.03739944 [kcal/mol]       0.15647926 [kJ/mol]
      Disp21                        0.11216169 [mEh]       0.07038252 [kcal/mol]       0.29448051 [kJ/mol]
      Disp22 (SDQ)                 -0.17892163 [mEh]      -0.11227502 [kcal/mol]      -0.46975875 [kJ/mol]
      Disp22 (T)                   -0.47692534 [mEh]      -0.29927518 [kcal/mol]      -1.25216749 [kJ/mol]
      Est. Disp22 (T)              -0.54385233 [mEh]      -0.34127251 [kcal/mol]      -1.42788430 [kJ/mol]
      Exch-Disp20                   0.64545587 [mEh]       0.40502969 [kcal/mol]       1.69464439 [kJ/mol]
      Exch-Disp30                  -0.01823410 [mEh]      -0.01144207 [kcal/mol]      -0.04787362 [kJ/mol]
      Ind-Disp30                   -0.91816882 [mEh]      -0.57615966 [kcal/mol]      -2.41065224 [kJ/mol]
      Exch-Ind-Disp30               0.76487181 [mEh]       0.47996433 [kcal/mol]       2.00817094 [kJ/mol]

  Total HF                         -5.68662563 [mEh]      -3.56841161 [kcal/mol]     -14.93023559 [kJ/mol]
  Total SAPT0                      -8.58408901 [mEh]      -5.38659740 [kcal/mol]     -22.53752571 [kJ/mol]
  Total SAPT2                      -6.72343814 [mEh]      -4.21902130 [kcal/mol]     -17.65238683 [kJ/mol]
  Total SAPT2+                     -7.33405042 [mEh]      -4.60218631 [kcal/mol]     -19.25554938 [kJ/mol]
  Total SAPT2+(3)                  -7.00901553 [mEh]      -4.39822383 [kcal/mol]     -18.40217026 [kJ/mol]
  Total SAPT2+3                    -7.18054663 [mEh]      -4.50586123 [kcal/mol]     -18.85252518 [kJ/mol]

  Special recipe for scaled SAPT0 (see Manual):
    Electrostatics sSAPT0         -13.37542977 [mEh]      -8.39320925 [kcal/mol]     -35.11719087 [kJ/mol]
    Exchange sSAPT0                11.21822294 [mEh]       7.03954147 [kcal/mol]      29.45344432 [kJ/mol]
    Induction sSAPT0               -3.47550008 [mEh]      -2.18090932 [kcal/mol]      -9.12492546 [kJ/mol]
    Dispersion sSAPT0              -2.88342055 [mEh]      -1.80937379 [kcal/mol]      -7.57042064 [kJ/mol]
  Total sSAPT0                     -8.51612746 [mEh]      -5.34395089 [kcal/mol]     -22.35909265 [kJ/mol]
  --------------------------------------------------------------------------------------------------------

At the bottom of this output are the total SAPT energies (defined above),
they are composed of subsets of the individual terms printed above. The
individual terms are grouped according to the component of the interaction
to which they contribute. The total component energies (*i.e.*,
electrostatics, exchange, induction, and dispersion) represent what we
regard as the best estimate available at a given level of SAPT computed
from a subset of the terms of that grouping. The groupings shown above are
not unique and are certainly not rigorously defined. We regard the groupings 
used in |PSIfour| as a "chemist's grouping" as opposed to a more
mathematically based grouping, which would group all exchange terms 
(*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in
the exchange component. A final note is that both ``Disp22(T)``
and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are 
used to evaluate the triples correction to dispersion. The ``Disp22(T)`` 
result is the triples correction as computed in the truncated NO basis;  
``Est.Disp22(T)`` is a scaled result that attempts to recover
the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``
value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ 
for details). Finally, this part of the output file contains sSAPT0, a special scaling
scheme of the SAPT0 energy that can yield improved results and was described in more details
above. The corresponding scaled total component energies are printed as well.

As mentioned above, SAPT results with scaled exchange are also optionally available
by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are
printed first as reported above, and then repeated with exchange scaling for all 
relevant terms: :: 

    SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==

    Scaling factor (Exch10/Exch10(S^2))^{Alpha} =     1.007200
    with Alpha =     1.000000
  --------------------------------------------------------------------------------------------------------
    Electrostatics                -13.06509118 [mEh]      -8.19846883 [kcal/mol]     -34.30239689 [kJ/mol]
      Elst10,r                    -13.37542977 [mEh]      -8.39320925 [kcal/mol]     -35.11719087 [kJ/mol]
      Elst12,r                      0.04490350 [mEh]       0.02817737 [kcal/mol]       0.11789413 [kJ/mol]
      Elst13,r                      0.26543510 [mEh]       0.16656305 [kcal/mol]       0.69689985 [kJ/mol]

    Exchange sc.                   13.43351854 [mEh]       8.42966050 [kcal/mol]      35.26970292 [kJ/mol]
      Exch10                       11.21822294 [mEh]       7.03954147 [kcal/mol]      29.45344432 [kJ/mol]
      Exch10(S^2)                  11.13802706 [mEh]       6.98921779 [kcal/mol]      29.24289005 [kJ/mol]
      Exch11(S^2) sc.               0.04591732 [mEh]       0.02881355 [kcal/mol]       0.12055592 [kJ/mol]
      Exch12(S^2) sc.               2.16937828 [mEh]       1.36130548 [kcal/mol]       5.69570268 [kJ/mol]

    Induction sc.                  -3.90986540 [mEh]      -2.45347768 [kcal/mol]     -10.26535160 [kJ/mol]
      Ind20,r                      -4.57530818 [mEh]      -2.87104935 [kcal/mol]     -12.01247162 [kJ/mol]
      Ind30,r                      -4.91714746 [mEh]      -3.08555675 [kcal/mol]     -12.90997067 [kJ/mol]
      Ind22                        -0.83718642 [mEh]      -0.52534243 [kcal/mol]      -2.19803293 [kJ/mol]
      Exch-Ind20,r sc.              2.49612913 [mEh]       1.56634474 [kcal/mol]       6.55358703 [kJ/mol]
      Exch-Ind30,r sc.              4.37040396 [mEh]       2.74247000 [kcal/mol]      11.47449560 [kJ/mol]
      Exch-Ind22 sc.                0.45673981 [mEh]       0.28660857 [kcal/mol]       1.19917038 [kJ/mol]
      delta HF,r (2) sc.           -1.45023975 [mEh]      -0.91003922 [kcal/mol]      -3.80760445 [kJ/mol]
      delta HF,r (3) sc.           -0.90349624 [mEh]      -0.56695248 [kcal/mol]      -2.37212939 [kJ/mol]

    Dispersion sc.                 -3.60998364 [mEh]      -2.26529903 [kcal/mol]      -9.47801205 [kJ/mol]
      Disp20                       -3.54291925 [mEh]      -2.22321549 [kcal/mol]      -9.30193450 [kJ/mol]
      Disp30                        0.05959979 [mEh]       0.03739944 [kcal/mol]       0.15647926 [kJ/mol]
      Disp21                        0.11216169 [mEh]       0.07038252 [kcal/mol]       0.29448051 [kJ/mol]
      Disp22 (SDQ)                 -0.17892163 [mEh]      -0.11227502 [kcal/mol]      -0.46975875 [kJ/mol]
      Disp22 (T)                   -0.47692534 [mEh]      -0.29927518 [kcal/mol]      -1.25216749 [kJ/mol]
      Est. Disp22 (T)              -0.54385233 [mEh]      -0.34127251 [kcal/mol]      -1.42788430 [kJ/mol]
      Exch-Disp20 sc.               0.65010327 [mEh]       0.40794598 [kcal/mol]       1.70684615 [kJ/mol]
      Exch-Disp30 sc.              -0.01836538 [mEh]      -0.01152445 [kcal/mol]      -0.04821832 [kJ/mol]
      Ind-Disp30                   -0.91816882 [mEh]      -0.57615966 [kcal/mol]      -2.41065224 [kJ/mol]
      Exch-Ind-Disp30 sc.           0.77037903 [mEh]       0.48342016 [kcal/mol]       2.02263015 [kJ/mol]

  Total HF                         -5.68662563 [mEh]      -3.56841161 [kcal/mol]     -14.93023559 [kJ/mol]
  Total SAPT0 sc.                  -8.57944161 [mEh]      -5.38368112 [kcal/mol]     -22.52532395 [kJ/mol]
  Total SAPT2 sc.                  -6.69968912 [mEh]      -4.20411857 [kcal/mol]     -17.59003378 [kJ/mol]
  Total SAPT2+ sc.                 -7.31030140 [mEh]      -4.58728357 [kcal/mol]     -19.19319632 [kJ/mol]
  Total SAPT2+(3) sc.              -6.98526650 [mEh]      -4.38332109 [kcal/mol]     -18.33981720 [kJ/mol]
  Total SAPT2+3 sc.                -7.15142168 [mEh]      -4.48758504 [kcal/mol]     -18.77605762 [kJ/mol]
  --------------------------------------------------------------------------------------------------------

The scaling factor is reported at the top (here ``1.0072``) together with the 
:math:`\alpha` parameter. All terms that are scaled are indicated by the ``sc.``
label. Note that if Exch10 is less than :math:`10^{-5}`, the scaling factor is
set to :math:`1.0`.

.. caution:: To density fit the dispersion terms in SAPT, the RI auxiliary
   basis set (*e.g.*, aug-cc-pVDZ-RI) controlled through
   |sapt__df_basis_sapt| performs well. For Fock-type terms (*i.e.*,
   electrostatics, exchange, induction, and core Fock matrix elements in
   exchange-dispersion), the density-fitting auxiliary basis in the
   :ref:`SAPT module<sec:sapt>` (both SAPT0 and higher-order) is RI (more
   efficient for the small basis sets at which SAPT0 performs best) while
   the :ref:`FISAPT module<sec:fisapt>` uses the more appropriate JKFIT
   (*e.g.*, aug-cc-pVDZ-JKFIT). For heavier elements (*i.e.*, second-row
   and beyond), the RI auxiliary basis is unsound for this role
   (insufficiently flexible). For SAPT0 in the :ref:`SAPT
   module<sec:sapt>`, a workaround is to set |sapt__df_basis_elst| (which
   controls Elst10 and Exch10 terms) to a JKFIT basis. For higher-order
   methods in :ref:`SAPT module<sec:sapt>`, there is no workaround;
   on-the-fly construction of an auxiliary basis through Cholesky
   decomposition (not implemented) is the long-term solution.

Spin-Flip SAPT
^^^^^^^^^^^^^^

SAPT0 with two open-shell references will always yield a high-spin complex.  In
order to obtain a SAPT-based estimate of the splittings between different spin
states of a complex the first-order exchange energies for all multiplets can be
shown to be a linear combination of two matrix elements: a diagonal exchange
term that determines the spin-averaged effect and a spin-flip term responsible
for the splittings between the states. The numerical factors in this linear
combination are determined solely by the Clebsch-Gordan coefficients:
accordingly, the :math:`S^{2}` approximation implies a Heisenberg Hamiltonian
picture with a single coupling strength parameter determining all the
splittings. This method can be invoked with `energy("SF-SAPT")` and
publications resulting from the use of the SF-SAPT code should cite the
following publications: [Patkowski:2018:164110]_

.. _`sec:saptinf`:

Higher-Order Exchange Terms without Single-Exchange Approximation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recently, several SAPT higher-order exchange terms have been derived without
the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, 
:math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` 
[Waldrop:2021:024103]_. The second-order terms can be computed with the following
settings::

    set SAPT_DFT_FUNCTIONAL HF
    set DO_IND_EXCH_SINF true        # calculate Exch-Ind20 (S^inf) 
    set SAPT_DFT_MP2_DISP_ALG fisapt 
    set DO_DISP_EXCH_SINF true       # calculate Exch-Disp20 (S^inf)
    energy('sapt(dft)')
                       
and the third-order exchange-induction term is computed as follows::

    set DO_IND30_EXCH_SINF true        # calculate Exch-Ind30 (S^inf) 
    energy('sapt2+3')
                       
These calculations are performed with the atomic orbital and 
density-fitting scheme described in the Supplementary Material to
[Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_
for the third-order exchange induction. The coupled (response) version of the
exchange-induction corrections are also calculated, exactly for 
:math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for
:math:`E_{exch-ind,resp}^{(30)}`.

S^inf Keywords
~~~~~~~~~~~~~~

.. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst
.. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst
.. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst

.. _`sec:saptd`:

SAPT0-D
~~~~~~~

In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents
the computational bottleneck. One can avoid this bottleneck by replacing these
dispersion terms with the empirical D3 corrections developed by Grimme.
  
:ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`

The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters
specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D 
variants using default parameters optimized for Hartee--Fock interaction energies, 
we recommend using the refit parameters with Becke-Johnson damping, as described in
[Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than
jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without
refitting the dispersion parameters. 
A simple water dimer computation using SAPT0-D may look like::

	molecule water_dimer {
	     0 1
	     O  -1.551007  -0.114520   0.000000
	     H  -1.934259   0.762503   0.000000
	     H  -0.599677   0.040712   0.000000
	     --
	     0 1
	     O   1.350625   0.111469   0.000000
	     H   1.680398  -0.373741  -0.758561
	     H   1.680398  -0.373741   0.758561
	
	     units angstrom
	     no_reorient
	     symmetry c1
	}
	
	set basis jun-cc-pvdz

	energy('sapt0-d3mbj') # runs the recommended dispersion correction
    energy('sapt0-d3') # tests an alternative damping scheme/parameterization

Given the naturally pairwise-atomic nature of these empirical dispersion corrections,
integration with existing FSAPT functionality is also available simply by calling
`energy("fsapt0-d3mbj")`. See `FSAPT <fisapt>` documentation for more details on using FSAPT
for functional group analyses.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:basisSets`:

==========
Basis Sets
==========

Basis sets in |PSIfour| are Gaussian functions (not Slater-type functions or plane waves),
all-electron [no effective core potentials (ECPs)],
and of Gaussian94 format (for ease of export from `EMSL <https://bse.pnl.gov/bse/portal>`_).
Both spherical harmonic (5D/7F) and Cartesian (6D/10F) Gaussian functions are supported,
but their mixtures are not, neither within a basis set (*e.g.*, 6D/7F) nor within a calculation
(*e.g.*, cartesian for the orbital basis and spherical for the fitting basis).
For built-in basis sets, the correct ``spherical``/``cartesian`` value for |globals__puream|
is set internally from the orbital basis.

* :ref:`sec:basisBuiltIn`
* :ref:`Specifying basis sets <sec:jobControl>`
* :ref:`Built-in basis sets by family <apdx:basisTables>`
* :ref:`Built-in basis sets by element <apdx:basisElement>`
* :ref:`User-Defined basis sets <sec:basisUserDefined>`
* :ref:`Auxiliary bases for built-in orbital basis sets <apdx:basisFamily>`

.. index:: basis set; available by family
.. _`sec:basisBuiltIn`:

Built-In Basis Sets
===================

A wide range of orbital basis sets are built into |PSIfour|. These are
summarized in Tables :ref:`Pople <table:basisPopleOrbital>`,
:ref:`Dunning <table:basisDunningOrbital>`, 
:ref:`Dunning (Douglas-Kroll) <table:basisDunningDK>`, 
:ref:`Karlsruhe <table:basisKarlsruhe>`,
:ref:`Jensen <table:basisJensen>`,
and :ref:`Other <table:basisOther>` in Appendix :ref:`apdx:basisTables`.
These tables are arranged so that columns indicate degree of
augmentation by diffuse functions (generally necessary for anions, excited
states, and noncovalent interactions) and DTQ56 indicate the :math:`X\;=\zeta` levels
available.  Several intermediate levels of diffuse space between the customary
non-augmented and augmented versions have been supplied for each basis set,
including heavy-augmented and Truhlar's [Papajak:2011:10]_ calendar
truncations described in Table :ref:`Months Bases <table:basisMonths>`.  Fitting bases 
in Tables :ref:`JKFIT <table:basisDunningJKFIT>`,
:ref:`RI <table:basisDunningMP2FIT>`, and :ref:`DUAL <table:basisDunningDUAL>`
are available for methods incorporating density-fitting or dual-basis
approximations. JKFIT sets are appropriate for fitting :math:`(oo|`\ -type products,
such as encountered in SCF theory and the electrostatics/exchange terms of SAPT.
RI sets are appropriate for fitting :math:`(ov|`\ -type products, such as encountered in
MP2 and most SAPT terms.  Citations for basis sets can be found in their
definition files at :source:`psi4/share/psi4/basis` in the source.  For basis set availability by
element and the default value for keyword |globals__puream|, consult
Appendix :ref:`apdx:basisElement`.

|PSIfour| uses the angular momentum convention below that
skips the letter ``J``. Note that Gaussian94 convention is
*not* to skip this letter.
|PSIfour| can use either convention for ``.gbs`` import (assuming
angular momentum levels are not skipped), but it will always output
in the ``HIK`` sequence. Another portion of the G94 format, labeling
angular momentum with :samp:`L={l}` syntax is newly (August 2020)
implemented, and this is preferred for ``L=7`` and above to
avoid ambiguity. ::

    L:    0123456789...
    Psi4: SPDFGHIKLM...
    G94:  SPDFGHIJKL...

.. index:: basis set; multiple within molecule
.. _`sec:psithonBasissets`:

Mixing Basis Sets
=================

While the above syntax will suffice for specifying basis sets in most cases,
the user may need to assign basis sets to specific atoms.  To achieve this, a
basis "block" can be used.  We use a snippet from the :srcsample:`mints2` sample
input file, which performs a benzene SCF computation, to demonstrate this
feature. ::

    basis {
       assign DZ
       assign C 3-21G
       assign H1 sto-3g
       assign C1 sto-3g
    }

The first line in this block assigns the DZ basis set to all atoms for the primary/orbital basis. The next
line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ
basis set.  On the third line, the hydrogen atoms which have been specifically
labelled as ``H1`` are given the STO-3G basis set, leaving the unlabelled hydrogen
atoms with the DZ basis set.  Likewise, the fourth line assigns the STO-3G
basis set to just the carbon atoms labelled ``C1``.  This bizarre example was
constructed to demonstrate the syntax, but the flexibility of the basis set
specification is advantageous, for example, when selectively omitting diffuse
functions to make computations more tractable.

In the above example the basis sets have been assigned asymmetrically, reducing
the effective symmetry from :math:`D_{6h}` to :math:`C_{2v}`; |PSIfour| will detect this
automatically and run in the appropriate point group.

Basis blocks can also be named, *e.g.*, :samp:`basis
{optional_basis_name} \\{...\\}` and the basis defined by it later
applied to another molecule. ::

    # sets basis keyword
    basis mybas {
        assign aug-cc-pvtz
        assign f cc-pvtz
    }

    # re-sets basis keyword
    set basis aug-cc-pvtz

    molecule hf {
        H
        F 1 1.0
    }

    molecule h2o {
        O
        H 1 1.0
        H 1 1.0 2 90.0
    }

    # runs HF and H2O with aug-cc-pvtz
    energy('hf', molecule=hf)
    energy('hf', molecule=h2o)

    # re-re-sets basis keyword
    set basis mybas

    # runs HF with cc-pvtz on F and aug-cc-pvtz on H
    energy('hf', molecule=hf)

    # runs H2O with aug-cc-pvtz, effectively
    energy('hf', molecule=h2o)

Finally, we note that the ``basis {...}`` block may also be used
for defining basis sets, as detailed in :ref:`sec:basisUserDefined`.

.. index:: basis set; auxiliary

Calculations requesting density fitting (on by default for many methods)
require auxiliary fitting basis set(s) in addition to the primary
orbital one associated with the |mints__basis| keyword.
When most popular basis sets are being used, including Dunning and
Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate
auxiliary basis set automatically according to :ref:`apdx:basisFamily`,
unless instructed otherwise by setting the auxiliary basis set in the
input.
Should needed elements be missing from the best
auxiliary basis or should the orbital basis be unknown to |PSIfour|,
the auxiliary basis will fall back on `def2 quad-zeta fitting bases
:source:`psi4/driver/qcdb/libmintsbasisset.py#L762`.
Note that if |mints__basis| is known to be larger than quad-zeta,
|PSIfour| *will not* attempt to fall back on the def2 fitting bases.

The same basis "block" syntax can be
used to specify basis sets other than that used to define orbitals.  For
example, ::

    set df_basis_mp2 cc-pvdz-ri

     or

    df_basis_mp2 {
       assign cc-pVDZ-RI
    }

are both equivalent ways to set the auxiliary basis set for density fitted MP2
computations.  To assign the aug-cc-pVDZ-RI to carbon atoms, the following
command is used::

    df_basis_mp2 {
       assign C aug-cc-pVDZ-RI
    }

.. _`sec:basisDecontracted`:

Decontracted Basis Sets
=======================

Decontraction of the basis set can be useful in certain situations. In
order to decontract a given basis set, simply add "-decon" to the name
of the primary basis set (*e.g.* :srcsample:`decontract`). ::


	set basis cc-pvdz-decon

Obviously this will add significantly to the computational cost of any given calculation, however it can
be useful when checking the basis set dependence of a particular calculated property or in certain situations
where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the :ref:`X2C Hamiltonian <sec:relativistic>`.

.. index::
   pair: basis set; adding new

.. _`sec:basisUserDefined`: 

User-Defined Basis Sets
=======================

.. note:: No recompile of the PSI program is necessary for changes made to
    files in ``$PSIDATADIR``, including those described below.

There are three routes by which a basis set in G94 format can be introduced to |PSIfours| notice.


.. rubric:: (1) Install new basis set file into |PSIfour| basis library.

Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.
As the first line of the file, add the word ``spherical`` or ``cartesian`` to indicate
whether the basis set will run in (5D/7F) or (6D/10F). ::

   cartesian
   ****
   H     0
   S   3   1.00
         3.42525091             0.15432897
         0.62391373             0.53532814
         0.16885540             0.44463454
   ****
   O     0
   S   3   1.00
       130.7093200              0.15432897
        23.8088610              0.53532814
         6.4436083              0.44463454
   SP   3   1.00
         5.0331513             -0.09996723             0.15591627
         1.1695961              0.39951283             0.60768372
         0.3803890              0.70011547             0.39195739
   ****

Name the file with the name of the basis set and a ``.gbs`` extension,
after applying the following transformations.

* All letters lowercase
* Replace all ``*`` with ``s``
* Replace all ``+`` with ``p``
* Replace all ``(`` ``)`` ``,`` with ``_`` (underscores replace parentheses and commas)

For example, basis 6-31++G** is stored in :source:`psi4/share/psi4/basis/6-31ppgss.gbs`,
and cc-pV(D+d)Z is stored in :source:`psi4/share/psi4/basis/cc-pv_dpd_z.gbs`.
Only one basis set may be specified per file.
Copy the new basis set file into :source:`psi4/share/psi4/basis`.
Request the new basis set in an input file in the usual manner. ::

   set basis new_basis_name


.. rubric:: (2) Use new basis set file in arbitrary location.

Prepare a basis set file exactly as above. Append the directory
containing the basis set file to the environment variable
:envvar:`PSIPATH`. If the directory is the current working directory,
|PSIfour| will find it automatically, and the directory does not need
to be added to :envvar:`PSIPATH`.

Request the new basis set in an input file in the usual manner. ::

   set basis new_basis_name

.. rubric:: (3) Include new basis set in input file.

Construct for a basis set a section like the one below that includes
``[basis name]``, |globals__puream| value, and element basis set
specifications. Hash signs denote comments.  This format is exactly like
the stand-alone basis file except for the addition of the basis name in
brackets. ::

   [ sto-3g ]
   cartesian
   ****
   H     0
   S   3   1.00
         3.42525091             0.15432897
         0.62391373             0.53532814
         0.16885540             0.44463454
   ****
   O     0
   S   3   1.00
       130.7093200              0.15432897
        23.8088610              0.53532814
         6.4436083              0.44463454
   SP   3   1.00
         5.0331513             -0.09996723             0.15591627
         1.1695961              0.39951283             0.60768372
         0.3803890              0.70011547             0.39195739
   ****

Copy the section into a |PSIfour| input file and surround it with the
command ``basis {...}``, as shown below.  Multiple basis sets can be
specified by adding additional sections within the surrounding brackets.
Use ``assign`` statements to actually request the basis set.  This
``basis {...}`` section replaces the usual ``set basis XXX`` line.
In a more complex input, if the user needs to call the user-defined
basis by name, this can be achieved using the syntax ``basis mybas {...}``,
and then the basis can be recalled later as ``set basis mybas``.
To use a custom basis set as described in this section, it must be 
defined prior to its use in a function that performs a computation. ::

   basis {

   # assign basset to all atoms and addl to hydrogens
   assign basset
   assign H addl

   # basis set section like in snippet above goes here
   [basset]
   ...

   # additional basis set sections follow
   [addl]
   ...
   }

The test case :srcsample:`mints2` provides a complete example of 
user-specified basis sets.

.. _`sec:basissets-ecps`:

Inputting effective core potentials (ECPs)
==========================================

For ECP containing basis sets, all of the above mechanisms may still be used to
input the basis set; simply place the ECP definitions (in G94 format) in the
same file or input section as the orbital basis definition.  Because the ECP
appears in the same section as the orbital basis, it will be parsed
automatically and the number of core electrons the ECP represents will be
detected, so no further input is required to use a core potential. See
:ref:`sec:scf-ecps` for more information about using ECPs and the
:source:`Def2-TZVP <psi4/share/psi4/basis/def2-tzvp.gbs>` basis set definition
for an example of their input syntax.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: /autodoc_abbr_options_c.rst

.. _`sec:psi4api`:

=====================================
|PSIfour| API: Linking C++ and Python
=====================================

.. automodapi:: psi4.core

.. automodapi:: psi4.driver

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: DFTNL
.. _`sec:dftnl`:


DFT-NL
======

.. codeauthor:: Daniel G. A. Smith and Holger Kruse
.. sectionauthor:: Holger Kruse

Non-local (NL), density based correlation energy from the VV10 kernel can be added
to arbitrary functionals.

.. math:: E_{DFT-NL}=E_{DFT}+E_{NL}

For pre-defined functionals (see Functional overview in :ref:`this Table <table:dft_all>` ) it is sufficient to add `-NL` to
the functional name::

    energy('b3lyp-nl')

Modification of the parameters `b` and `C` is done setting |scf__dft_vv10_b| and |scf__dft_vv10_c|. The `C` is usually left unchanged and the originally proposed
value of `C=0.0093` is used.

Adding |scf__dft_vv10_b| to any functional activates the calculation of the VV10 kernel. A BLYP-NL calculation can be set as follows::

    set DFT_VV10_B 4.0
    energy('blyp')

The default `C` parameter will be used.

Similar to |scf__dft_dispersion_parameters| the tuple |scf__nl_dispersion_parameters| can used::

    set NL_DISPERSION_PARAMTERS [4.0]
    energy('blyp')

which is equivalent to the example above.

Further examples can be found in the respective :source:`regression test <tests/dft-vv10/input.dat>`

post-SCF time savings
~~~~~~~~~~~~~~~~~~~~~

Substantial time-savings for energy calculations are available by evaluating the VV10 kernel only at the converged electron density, i.e. in a post-SCF fashion.
The deviations from the fully self-consistent treatment are usually minimal. To activate this set |scf__dft_vv10_postscf| to `true`.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: CheMPS2
.. _`sec:chemps2`:

Interface to CheMPS2 by S. Wouters
==================================

.. codeauthor:: Sebastian Wouters
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Keywords <apdx:dmrg>`, :ref:`PSI Variables <apdx:dmrg_psivar>`, :ref:`Samples <apdx:testSuitechemps2>`

.. comment|PSIfour| contains code to interface to the CheMPS2
.. library of S. Wouters, which is based at `GitHub
.. <https://github.com/SebWouters/CheMPS2>`_. Consult the excellent
.. `documentation <http://sebwouters.github.io/CheMPS2/>`_ for using and
.. `citing <http://sebwouters.github.io/CheMPS2/publications.html>`_ the library.

.. image:: https://img.shields.io/badge/home-CheMPS2-5077AB.svg
   :target: https://github.com/SebWouters/CheMPS2

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://sebwouters.github.io/CheMPS2/index.html

.. note:: As of late June 2016, DMRG keywords in |PSIfour| have been
   realigned with those of the chemps2 executable, plus a
   "dmrg\_" prefix. The only exceptions are the orbital space
   |PSIfour| keywords |globals__restricted_docc| (formerly
   CheMPS2 used |globals__frozen_docc|, contrary to its
   definition) and |globals__active| which are passed along to
   CheMPS2 keywords ``NOCC`` and ``NACT``. A `translation table
   <https://github.com/psi4/psi4/issues/150#issuecomment-228951911>`_
   is available.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://img.shields.io/badge/Anaconda%20Cloud-1.7.1-5077AB.svg
     :target: https://anaconda.org/psi4/chemps2

* CheMPS2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, CheMPS2 has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  CheMPS2 can be obtained through ``conda install chemps2``.
  Then enable it as a feature with :makevar:`ENABLE_CheMPS2`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect CheMPS2 and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   Libint from conda without thinking, consult.

* To remove a conda installation, ``conda remove chemps2``.

**Source**

* .. image:: https://img.shields.io/github/tag/SebWouters/chemps2.svg?maxAge=2592000
     :target: https://github.com/SebWouters/chemps2

* If using |PSIfour| built from source and you want CheMPS2 built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_CheMPS2`,
  and let the build system fetch and build it and activate dependent code.

Methods
~~~~~~~

.. _`table:chemps2_calls`:

.. table:: Density matrix renormalization group capabilities of |PSIfour| through CheMPS2

    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | name                    | calls method                                                 |  Energy              | Gradient             |
    +=========================+==============================================================+======================+======================+
    | dmrg-ci                 | DMRG configuration interaction (CI)                          | RHF/ROHF             | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | dmrg-scf                | DMRG complete active space SCF (CASSCF)                      | RHF/ROHF             | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | dmrg-caspt2             | DMRG CAS with 2nd-order perturbation theory (CASPT2)         | RHF/ROHF             | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+

DMRG Keywords
~~~~~~~~~~~~~

.. include:: /autodir_options_c/dmrg__dmrg_caspt2_calc.rst
.. include:: /autodir_options_c/dmrg__dmrg_caspt2_imag.rst
.. include:: /autodir_options_c/dmrg__dmrg_caspt2_ipea.rst
.. include:: /autodir_options_c/dmrg__dmrg_caspt2_orbs.rst
.. include:: /autodir_options_c/dmrg__dmrg_diis.rst
.. include:: /autodir_options_c/dmrg__dmrg_diis_write.rst
.. include:: /autodir_options_c/dmrg__dmrg_excitation.rst
.. include:: /autodir_options_c/dmrg__dmrg_irrep.rst
.. include:: /autodir_options_c/dmrg__dmrg_local_init.rst
.. include:: /autodir_options_c/dmrg__dmrg_molden_write.rst
.. include:: /autodir_options_c/dmrg__dmrg_mps_write.rst
.. include:: /autodir_options_c/dmrg__dmrg_multiplicity.rst
.. include:: /autodir_options_c/dmrg__dmrg_opdm_ao_print.rst
.. include:: /autodir_options_c/dmrg__dmrg_print_corr.rst
.. include:: /autodir_options_c/dmrg__dmrg_scf_active_space.rst
.. include:: /autodir_options_c/dmrg__dmrg_scf_diis_thr.rst
.. include:: /autodir_options_c/dmrg__dmrg_scf_grad_thr.rst
.. include:: /autodir_options_c/dmrg__dmrg_scf_max_iter.rst
.. include:: /autodir_options_c/dmrg__dmrg_scf_state_avg.rst
.. include:: /autodir_options_c/dmrg__dmrg_sweep_dvdson_rtol.rst
.. include:: /autodir_options_c/dmrg__dmrg_sweep_energy_conv.rst
.. include:: /autodir_options_c/dmrg__dmrg_sweep_max_sweeps.rst
.. include:: /autodir_options_c/dmrg__dmrg_sweep_noise_prefac.rst
.. include:: /autodir_options_c/dmrg__dmrg_sweep_states.rst
.. include:: /autodir_options_c/dmrg__dmrg_unitary_write.rst

.. _`cmake:chemps2`:

How to configure CheMPS2 for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, CheMPS2 is a library that provides additional
  quantum chemical capabilities (DMRG).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) CheMPS2

* Upstream Dependencies |w---w| CheMPS2 |dr| BLAS/LAPACK, HDF5 |dr| zlib

**CMake Variables**

* :makevar:`ENABLE_CheMPS2` |w---w| CMake variable toggling whether Psi4 builds with CheMPS2
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing ``include/chemps2/DMRG.h``
* :makevar:`CheMPS2_DIR` |w---w| CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing ``share/cmake/CheMPS2/CheMPS2Config.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_CheMPS2` |w---w| CMake variable to force internal build of CheMPS2 instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_CheMPS2` |w---w| CMake variable to force detecting pre-built CheMPS2 and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON

B. Build *without* CheMPS2

  .. code-block:: bash

    >>> cmake

C. Build bundled with specific HDF5

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5

D. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir

E. Link against pre-built with specific HDF5

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH="/path/to/chemps2/root;/path/to/hdf5/root"

F. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON


.. _`faq:chemps2gccflto`:

How to fix "``plugin needed to handle lto object``" when building CheMPS2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For building with GCC, errors involving unresolved symbols or a message
"plugin needed to handle lto object" may indicate a failure of the
interprocedural optimization. This can be resolved by passing full
locations to gcc toolchain utilities to ``setup`` or ``cmake``:
``-DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar`` .
Details at https://github.com/psi4/psi4/issues/414.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: BSSE

.. index::
   triple: setting; keywords; cp
   triple: setting; keywords; vmfc
   single: counterpoise correction

.. _`sec:cp()`:

Basis Set Superposition Corrections
===================================

.. codeauthor:: Daniel G. A. Smith

.. autofunction:: psi4.driver.driver_nbody.nbody_gufunc(func, method_string [, molecule, bsse_type, max_nbody, ptype, return_total_data])


The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.


**Examples :** ::

    # Counterpoise corrected CCSD(T) energies for the Helium dimer
    molecule mol {
      He
      --
      He 1 3
    }
    # Calculate interaction energies only (skips monomers in monomer basis):
    energy('CCSD(T)', bsse_type='cp')
    # Calculate interaction and total energies, return interaction energies:
    energy('CCSD(T)', bsse_type=['cp','nocp'])
    # Calculate and return counterpoise-corrected gradient
    # Useful for e.g. CP-corrected geometry optimization
    gradient('CCSD(T)', bsse_type='cp', return_total_data=True)


    # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies
    molecule mol {
      He 0 0 0
      --
      He 0 0 4
      --
      He 0 4 0
      --
      He 4 0 0
    }

    # Returns the nocp energy as its first in the list
    energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3)

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_code_intro`:

================================
General Introduction to the Code
================================

Languages: C++ and Python
-------------------------

Intro to the hybrid code and how the C++/Python interface works.

What Should Go in C++ vs Python
-------------------------------

Code Structure
--------------

Driver, libraries, modules, plugins, ... general tour of what goes where.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_full_integration`:

=======================================
Integrating New Features into |PSIfour|
=======================================

Overview of Required Steps
--------------------------

Explain the different steps that are needed to add a few feature to 
|PSIfour| (where to put the code, how to add user options (w/docs), where
to add targets to CMake files, adding test cases, adding a section
to the Users' manual.  Several of those steps are already documented 
elsewhere, so just point to them in the appropriate places.


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`apdx:testSuite`:

Test Suite and Sample Inputs
============================

|PSIfour| is distributed with an extensive test suite, which can
be found in :source:`tests`. After building the source code, these
can automatically be run by running ``ctest`` in the compilation
directory. More info on ``ctest`` options can be found
:ref:`here <faq:subsettests>`. Sample input files
can be found in the :source:`samples` subdirectory of the top-level Psi
directory. The samples and a brief description are provided below.

Sample inputs accessible through :ref:`interfaced executables
<sec:interfacing>` are bulleted below.

.. toctree::

   autodoc_testsuite_adcc.rst
   autodoc_testsuite_brianqc.rst
   autodoc_testsuite_cfour
   autodoc_testsuite_chemps2
   autodoc_testsuite_cookbook
   autodoc_testsuite_dftd3
   autodoc_testsuite_dkh
   autodoc_testsuite_libefp
   autodoc_testsuite_erd
   autodoc_testsuite_gcp
   autodoc_testsuite_gdma
   autodoc_testsuite_gpu_dfcc
   autodoc_testsuite_json
   autodoc_testsuite_mrcc
   autodoc_testsuite_pcmsolver
   autodoc_testsuite_psi4numpy
   autodoc_testsuite_python
   autodoc_testsuite_simint
   autodoc_testsuite_snsmp2
   autodoc_testsuite_v2rdm_casscf

Sample inputs for |PSIfour| as distributed are below.

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:

   autodoc_testsuite_corepsi4

.. include:: autodoc_testsuite_corepsi4.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:manage`:

========================================
Managing: Git, Conda, CMake and all that
========================================

.. toctree::
   :maxdepth: 2

   manage_addon
   manage_git
   manage_release

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`table:energy_cfour`:

    +-------------------------+---------------------------------------------------------------------------------------+
    | name                    | calls method in Stanton and Gauss's CFOUR program :ref:`[manual] <sec:cfour>`         |
    +=========================+=======================================================================================+
    | c4-scf                  | Hartree--Fock (HF)                                                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp2                  | 2nd-order |MollerPlesset| perturbation theory (non-density-fitting) (MP2)             |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp3                  | 3rd-order |MollerPlesset| perturbation theory (MP3)                                   |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp4(sdq)             | 4th-order MP perturbation theory (MP4) less triples                                   |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp4                  | full MP4                                                                              |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-cc2                  | approximate coupled cluster singles and doubles (CC2)                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsd                 | coupled cluster singles and doubles (CCSD)                                            |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-cc3                  | approximate CC singles, doubles, and triples (CC3)                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsd(t)              | CCSD with perturbative triples (CCSD(T))                                              |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsdt                | coupled cluster singles, doubles, and triples (CCSDT)                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | cfour                   | **expert** full control over cfour program                                            |
    +-------------------------+---------------------------------------------------------------------------------------+

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. .. _`sec:addAddOns`:

Git, Versioning
===============

.. _`faq:versionbump`:

How to bump a version
---------------------

0. **ACT** to check everything in

1. **OBSERVE** current versioning state

  * Be on master of (i) a direct clone or (ii) clone-of-fork with master
    up-to-date with upstream (including tags!!!) and with upstream as
    remote.

  * https://github.com/psi4/psi4/releases says ``v1.1a1`` & ``007a9b6``

  ::

    >>> git tag
    v1.0
    v1.1a1

    >>> cat psi4/metadata.py
    __version__ = '1.1a1'
    __version_long = '1.1a1+007a9b6'
    __version_upcoming_annotated_v_tag = '1.1a2'

    >>> git describe --abbrev=7 --long --always HEAD
    v1.1a1-417-gcbee32b

    >>> git describe --abbrev=7 --long --dirty
    v1.1a1-417-gcbee32b

    >>> ./psi4/versioner.py
    Defining development snapshot version: 1.1a2.dev417+cbee32b (computed)
    1.1a2.dev417 {master} cbee32b 1.0.0.999   1.0 <-- 1.1a2.dev417+cbee32b

    >>> git diff

  * Observe that current latest tag matches metadata scipt and git
    describe, that GitHub releases matches metadata script, that upcoming in
    metadata script matches current versioner version.

  * Note that current tag is ``v1.1a1``. Decide on imminent tag, say ``v1.1rc1``.

2. **ACT** to bump tag in code

  * Edit current & prospective tag in :source:`psi4/metadata.py`. Use your
    decided-upon tag ``v1.1rc1`` and a speculative next tag, say ``v1.1rc2``,
    and use 7 "z"s for the part you can't predict.

  ::

    >>> vi psi4/metadata.py

    >>> git diff
    diff --git a/psi4/metadata.py b/psi4/metadata.py
    index 5d87b55..6cbc05e 100644
    --- a/psi4/metadata.py
    +++ b/psi4/metadata.py
    @@ -1,6 +1,6 @@
    -__version__ = '1.1a1'
    -__version_long = '1.1a1+007a9b6'
    -__version_upcoming_annotated_v_tag = '1.1a2'
    +__version__ = '1.1rc1'
    +__version_long = '1.1rc1+zzzzzzz'
    +__version_upcoming_annotated_v_tag = '1.1rc2'

    >>> git add psi4/metadata.py

    >>> git commit -m "v1.1rc1"

3. **OBSERVE** undefined version state

  ::

    >>> git describe --abbrev=7 --long --always HEAD
    v1.1a1-418-g6100822

    >>>  git describe --abbrev=7 --long --dirty
    v1.1a1-418-g6100822

    >>>  psi4/versioner.py
    Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded)
    undefined {master} 6100822 1.0.0.999   1.0 <-- undefined+6100822

  * Note 7-char git hash for the new commit, here "6100822".

4. **ACT** to bump tag in git, then bump git tag in code.

  * Use the decided-upon tag ``v1.1rc1`` and the observed hash "6100822" to
    mint a new *annotated* tag, minding that "v"s are present here.

  * Use the observed hash to edit :source:`psi4/metadata.py` and commit immediately.

  ::

    >>> git tag -a v1.1rc1 6100822 -m "v1.1rc1"

    >>> vi psi4/metadata.py
    >>> git diff
    diff --git a/psi4/metadata.py b/psi4/metadata.py
    index 6cbc05e..fdc202e 100644
    --- a/psi4/metadata.py
    +++ b/psi4/metadata.py
    @@ -1,5 +1,5 @@
     __version__ = '1.1rc1'
    -__version_long = '1.1rc1+zzzzzzz'
    +__version_long = '1.1rc1+6100822'
     __version_upcoming_annotated_v_tag = '1.1rc2'

    >>> psi4/versioner.py
    Amazing, this can't actually happen that git hash stored at git commit.
    >>> git add psi4/metadata.py
    >>> git commit -m "Records tag for v1.1rc1"

5. **OBSERVE** current versioning state

  * Nothing to make note of, this is just a snapshot.

  ::

    >>> psi4/versioner.py
    Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed)
    1.1rc2.dev1 {master} 4e0596e 1.0.0.999   1.0 <-- 1.1rc2.dev1+4e0596e

    >>> git describe --abbrev=7 --long --always HEAD
    v1.1rc1-1-g4e0596e

    >>> git describe --abbrev=7 --long --dirty
    v1.1rc1-1-g4e0596e

    >>> git tag
    v1.0
    v1.1a1
    v1.1rc1

    >>> cat psi4/metadata.py
    __version__ = '1.1rc1'
    __version_long = '1.1rc1+6100822'
    __version_upcoming_annotated_v_tag = '1.1rc2'

    >>> cat metadata.out.py | head -8
    __version__ = '1.1rc2.dev1'
    __version_branch_name = 'master'
    __version_cmake = '1.0.0.999'
    __version_is_clean = 'True'
    __version_last_release = '1.0'
    __version_long = '1.1rc2.dev1+4e0596e'
    __version_prerelease = 'False'
    __version_release = 'False'

    >>> git log --oneline
    4e0596e Records tag for v1.1rc1
    6100822 v1.1rc1
    cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream.

6. **ACT** to inform remote of bump

  * Temporarily disengage "Include administrators" on protected master branch.

  ::

    >>> git push origin master
    >>> git push origin v1.1rc1

  * Now https://github.com/psi4/psi4/releases says ``v1.1rc1`` & ``6100822``


.. _`faq:remotetag`:

How to create and remove an annotated Git tag on a remote
---------------------------------------------------------

|PSIfour| versioning only works with *annotated* tags, not *lightweight*
tags as are created with the `GitHub interface
<https://github.com/psi4/psi4/releases/new>`_

* Create *annotated* tag::

    >>> git tag -a v1.1a1 <git hash if not current> -m "v1.1a1"
    >>> git push origin v1.1a1

* Delete tag::

    >>> git tag -d v1.1a1
    >>> git push origin :refs/tags/v1.1a1

* Pull tags::

    >>> git fetch <remote> 'refs/tags/*:refs/tags/*'


.. _`faq:psi4version`:

What Psi4 version is running
----------------------------

* Psithon / from the executable::

    >>> psi4 --version
    1.1rc2.dev17

* PsiAPI / from the library::

    >>> python -c "import psi4; print(psi4.__version__)"
    1.1rc2.dev17

* Output file header gives info like the ``print_header()`` below.

* Function ``print_header()`` returns a summary of citation, version, and
  git information about |PSIfour|. Function ``version_formatter()`` can
  return version and git information in any desired format string. ::

    >>> import psi4
    >>> psi4.print_header()

        -----------------------------------------------------------------------
              Psi4: An Open-Source Ab Initio Electronic Structure Package
                                   Psi4 1.1rc2.dev17

                             Git: Rev {condadoc} c852257 dirty


        R. M. Parrish, L. A. Burns, D. G. A. Smith, A. C. Simmonett,
        A. E. DePrince III, E. G. Hohenstein, U. Bozkaya, A. Yu. Sokolov,
        R. Di Remigio, R. M. Richard, J. F. Gonthier, A. M. James,
        H. R. McAlexander, A. Kumar, M. Saitow, X. Wang, B. P. Pritchard,
        P. Verma, H. F. Schaefer III, K. Patkowski, R. A. King, E. F. Valeev,
        F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D. Sherrill,
        submitted.

        -----------------------------------------------------------------------


        Psi4 started on: Friday, 28 April 2017 07:31PM

        Process ID:  95107
        PSIDATADIR: /Users/johndoe/psi4/objdir8/stage/usr/local/psi4/share/psi4
        Memory:     500.0 MiB
        Threads:    1

    >>> psi4.version_formatter()
    '1.1rc2.dev17'
    >>> psi4.version_formatter('all')
    '1.1rc2.dev17 {condadoc} c852257 1.0.0.999 dirty  1.0 <-- 1.1rc2.dev17+c852257'
    >>> psi4.version_formatter("""{{{branch}}} {versionlong}""")
    '{condadoc} 1.1rc2.dev17+c852257'


.. _`faq:grepascii`:

How to locate non-ascii characters in the codebase
--------------------------------------------------

Neither the Python interpreter nor Sphinx like non-ASCII characters one
bit, though the errors may be intermittant. Output files are usually ok,
so Jerome can live, for now. To aid in tracking down offenders, here's
the ``vi`` and ``grep`` search strings. In the docs, you want to use
the substitutions in :source:`doc/sphinxman/source/abbr_accents.rst`
instead of the actual characters. ::

    # vim
    :/[^\x00-\x7F]

    # bash
    grep -r --color='auto' -P -n "[^\x00-\x7F]" psi4/
    
.. _`faq:undefversion`:

How to fix "Psi4 undefined" version
-----------------------------------

When in a git repo, the versioner uses ``git describe`` and psi4/metadata.py
to compute the version. If you don't have all the latest tags, this mechanism
can't work. To solve, pull tags and remake. ::

    # upstream in `git remote -v` points to github.com/psi4/psi4.git
    >>> git fetch upstream 'refs/tags/*:refs/tags/*'
    >>> make
    # version healed
    
.. _`faq:cannotimportcoretlpd`:

How to fix "cannot import name 'core' from {top-level-psi4-dir}
---------------------------------------------------------------

First, what's happening? ``sys.path`` (where modules can be imported from in python) starts with ``''``.  If you `export PYTHONPATH={objdir}/stage/{prefix}/lib/{pymod_lib_dir}:$PYTHONPATH` to make PsiAPI easy, that inserts starting in pos'n 1 (0-indexed), so ``''`` still at the head of ``sys.path``. Now, if you try to run a psiapi/python file from ``{top-level-psi4-dir}`` that contains ``import psi4``, it will find the source tree ``psi4/__init__.py`` and fail because there's no ``core.so`` around. That is, it's finding what looks to be the psi4 module dir structure ``.`` when the one it wants is what you inserted into PYTHONPATH at pos'n 1.

The way around this is to move the python file you're running to any other directory. Or, within the file, do ``sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}``.


.. _`faq:findmissingoutputref`:

How to find tests without output.ref
------------------------------------

Ideally, each new test or much-altered test should add its own
``output.ref``. When that doesn't happen, this command helps. ::

    find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e "{}/output.ref" ";" -print

.. _`faq:githubcodereview`:

How to do GitHub issue management and code review
-------------------------------------------------

a) Anyone, core-dev or not, is encouraged to review PRs. It's actually good practice for interacting with other open-source projects, where you don't have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don't know the maintainers, it doesn't hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .

b) Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.

c) Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn't.

d) All main branches (master and `1.N.x` maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).

e) PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.

f) Unless there's been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.

g) Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won't block merging, but we do usually let it complete before merging unless it's a trivial PR.

h) We don't enforce branches to be up to date before merging since that'd be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn't been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.

i) Ideally a PR consists of atomic, compilable commits. When the PR instead is many successive small changes toward a single goal, consider squashing the PR. For core-dev's PRs, there's implicit permission to squash (unless otherwise noted in PR intro), whereas for new contributors, we often let the commits be messy.

j) When discussion on issue has overcome the original problem and settled on needing long-term work, fine to move the long-term item to Wish List and close issue.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. index:: basis set; available by element
.. _`apdx:basisElement`:

Basis Sets by Element
=====================

|
|

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:

   autodoc_psi4bases

.. include:: autodoc_psi4bases.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:prog_corelibs`:

=====================================
Programming with the Core Libraries
=====================================

.. toctree::
   optionshandling
   prog_blas

..   prog_basissets


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:code_of_conduct`:

===========================
Community Code of Conduct
===========================

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: 
   NumPy

.. _`sec:numpy`:

Interface to NumPy
==================

.. codeauthor:: Daniel G. A. Smith
.. sectionauthor:: Daniel G. A. Smith

*Module:* :source:`psi4/driver/p4util/numpy_helper.py`

Basics
~~~~~~

Converting between the |PSIfour| Data classes and a NumPy array is easy through
various helper functions as detailed in this section.  A quick overview NumPy
functionality can be found `here
<https://numpy.org/doc/stable/user/quickstart.html>`_.  In addition,
numerous example of hybrid NumPy and Psi4 can be found at the `Psi4Numpy
project <https://github.com/psi4/psi4numpy>`_.  Currently only the Matrix
and Vector objects support NumPy interfacing. Let us begin with a simple
conversion from these objects to a NumPy array::

    >>> import psi4
    >>> import numpy as np

    # Build the Psi4 data objects
    >>> mat = psi4.core.Matrix(3, 3) 
    >>> vec = psi4.core.Vector(3)

    # Convert to a NumPy array
    >>> numpy_mat = np.array(mat)
    >>> numpy_vec = np.array(vec)

Here the data is copied into new NumPy arrays. NumPy arrays can be converted
back to |PSIfour| objects using the ``from_array`` interface::

    >>> new_mat = psi4.core.Matrix.from_array(mat)
    >>> new_vec = psi4.core.Vector.from_array(vec)


NumPy Views
~~~~~~~~~~~

Copying the data between NumPy and Psi4 objects can lead to excessive data
movement and convoluted code. Here we introduce the idea of "Views" where the
same data can be viewed by multiple objects. However, this can lead to very
subtle errors if used incorrectly and care needs to be taken when using these
views.  Views can be created in two ways::

    >>> numpy_mat_view = np.asarray(mat)

    # Access the NumPy object and set all values to 1 through broadcasting
    >>> numpy_mat_view[:] = 1
    
    >>> print(np.array(mat))
    [[ 1.  1.  1.]
     [ 1.  1.  1.]
     [ 1.  1.  1.]]


Secondly, these objects have a ``.np`` attribute for easy access to the underlying data::

    >>> mat.np[:] = 1

this operation is identical to the above.


|PSIfour| Data Objects with Irreps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

|PSIfour| data objects natively support multiple :ref:`irreducible representations
<sec:symmetry>`
which is quite useful for Quantum Chemistry. However, this is not fundamental
to NumPy and some work around are required to natively support these
operations. Take the following irreped Matrix::

    >>> dim = psi4.core.Dimension.from_list([1, 2, 3])
    >>> irreped_mat = psi4.core.Matrix("New Matrix", dim, dim)

    # Create a list of Psi4 arrays
    >>> list_of_arrays = irreped_mat.to_array()

    # Or, use the .nph irreped accessor
    >>> irreped_mat.nph[0][:] = 1

Where ``.nph`` is the irreped accessor form. If ``.np`` or ``np.array`` are
called on irreped Matrices or Vectors an error will be thrown; however, the
irreped form is always valid for non-irreped matrices.

Array to Matrix
~~~~~~~~~~~~~~~
A general function that converts |PSIfour| data objects to NumPy arrays.

.. autofunction:: psi4.driver.p4util.numpy_helper.array_to_matrix

Matrix to Array
~~~~~~~~~~~~~~~
A general function that converts NumPy arrays to |PSIfour| data objects.

.. autofunction:: psi4.driver.p4util.numpy_helper._to_array


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`table:energy_mrcc`:

    +-------------------------+---------------------------------------------------------------------------------------+
    | name                    | calls method in Kallay's MRCC program :ref:`[manual] <sec:mrcc>`                      |
    +=========================+=======================================================================================+
    | mrccsd                  | CC through doubles                                                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt                 | CC through triples                                                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq                | CC through quadruples                                                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp               | CC through quintuples                                                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqph              | CC through sextuples                                                                  |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsd(t)               | CC through doubles with perturbative triples                                          |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt(q)              | CC through triples with perturbative quadruples                                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq(p)             | CC through quadruples with pertubative quintuples                                     |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp(h)            | CC through quintuples with pertubative sextuples                                      |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsd(t)_l             |                                                                                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt(q)_l            |                                                                                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq(p)_l           |                                                                                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp(h)_l          |                                                                                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt-1a              | CC through doubles with iterative triples (cheapest terms)                            |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq-1a             | CC through triples with iterative quadruples (cheapest terms)                         |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp-1a            | CC through quadruples with iterative quintuples (cheapest terms)                      |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqph-1a           | CC through quintuples with iterative sextuples (cheapest terms)                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt-1b              | CC through doubles with iterative triples (cheaper terms)                             |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq-1b             | CC through triples with iterative quadruples (cheaper terms)                          |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp-1b            | CC through quadruples with iterative quintuples (cheaper terms)                       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqph-1b           | CC through quintuples with iterative sextuples (cheaper terms)                        |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrcc2                   | approximate CC through doubles                                                        |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrcc3                   | approximate CC through triples                                                        |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrcc4                   | approximate CC through quadruples                                                     |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrcc5                   | approximate CC through quintuples                                                     |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrcc6                   | approximate CC through sextuples                                                      |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdt-3               | CC through doubles with iterative triples (all but the most expensive terms)          |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtq-3              | CC through triples with iterative quadruples (all but the most expensive terms)       |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqp-3             | CC through quadruples with iterative quintuples (all but the most expensive terms)    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | mrccsdtqph-3            | CC through quintuples with iterative sextuples (all but the most expensive terms)     |
    +-------------------------+---------------------------------------------------------------------------------------+

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: DFTD3, DFTD4
.. _`sec:dftd3`:

Interface to DFTD3 by S. Grimme
===============================

.. codeauthor:: Lori A. Burns
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Samples <apdx:testSuitedftd3>`

.. image:: https://img.shields.io/badge/home-DFTD3-5077AB.svg
   :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3/get-the-current-version-of-dft-d3

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3/man.pdf

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/dftd3/badges/version.svg
     :target: https://anaconda.org/psi4/dftd3

* DFTD3 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the Psi4conda installer, DFTD3 has already been installed alongside.

* If using the |PSIfour| conda package, the dftd3 conda package can
  be obtained through ``conda install dftd3 -c psi4`` or ``conda install
  psi4-rt -c psi4``.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  the dftd3 executable can be obtained through ``conda install dftd3 -c psi4``.

* To remove a conda installation, ``conda remove dftd3``.

**Source**

* .. image:: https://img.shields.io/badge/home-DFTD3-5077AB.svg
     :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3/get-the-current-version-of-dft-d3

* If using |PSIfour| built from source and you want to build DFTD3 from
  from source also,
  follow the instructions provided with the source
  (essentially, download the freely available tarball, unpack the source,
  edit the Makefile to select a
  Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can
  be used as-is; for earlier versions, patches are available:
  :source:`psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2`.

To be used by |PSIfour|, the program binary (``dftd3``) must be
found in your :envvar:`PSIPATH` or :envvar:`PATH` (in that order). If
|PSIfour| is unable to execute the binary, an error will be reported.
To preferentially use a particular dftd3 compilation, simply adjust its
position in the path environment variables.

..    >>> cd dftd3
..    >>> ls
..    dftd3.tar
..    patch_grimme_dftd3.3.0.2
..    >>> tar -xvf dftd3.tar
..    copyc6.f
..    dftd3.f
..    Makefile
..    man.pdf
..    pars.f
..    param
..    >>> patch < patch_grimme_dftd3.3.0.2
..    patching file dftd3.f
..    >>> make
..    making dftd3.o from dftd3.f
..    ifort -O  -c dftd3.f -o dftd3.o
..    making copyc6.o from copyc6.f
..    ifort -O  -c copyc6.f -o copyc6.o
..    ifort dftd3.o copyc6.o    -o ./dftd3
..    >>> ls
..    Makefile           copyc6.o           dftd3.f            dftd3.tar          param              patch_grimme_dftd3.3.0.2
..    copyc6.f           dftd3              dftd3.o            man.pdf            pars.f

Theory
~~~~~~

The local or semilocal character of conventional density functionals
necessarily leads to neglect of the long-range correlation interactions
which capture attractive van der Waals forces. Initially proposed by Yang
[Wu:2002:515]_ and assiduously developed by Grimme, [Grimme:2004:1463]_
[Grimme:2006:1787]_ [Grimme:2010:154104]_ the DFT+Dispersion method
appends to the base functional a scaled, damped, and fitted leading term
to the well-known dispersion energy series, :math:`E_{disp} = -C_6/R^6
-C_8/R^8 -C_{10}/R^{10}-\cdots`. The DFT-D2 [Grimme:2006:1787]_ variant
takes the explicit form below. Here, dispersion coefficients,
:math:`C_6^{ij}`, obtained from the geometric mean of tabulated elemental
values, are summed over interatomic distances, :math:`R_{ij}`, modulated
by a damping function, :math:`f_{damp}(R_{ij})`, that gradually activates
the dispersion correction (at a rate characterized by :math:`\alpha_6`)
over a distance characterized by the sum of the two atomic vdW radii,
:math:`R_{vdW}`, while an overall scaling term, :math:`s_6`, is optimized
to be unique to each :math:`E_{xc}` functional. (:math:`\alpha_6` is
sometimes allowed to vary as well.)

.. math:: E_{disp}^{\text{D2}}=-s_6 \sum_{i,j>i}^{N_{at}} \frac{C_6^{ij}}{(R_{ij})^6} f_{damp}(R_{ij})
   :label: DFTD2

.. math:: f_{damp}(R_{ij}) = \frac{1}{1 + e^{- \alpha_6 (R_{ij}/R_{vdW} - 1)}}

Grimme recently presented a refined method, DFT-D3, [Grimme:2010:154104]_
which incorporates an additional :math:`R^{-8}` term in the dispersion
series and adjusts the :math:`C_{6}^{ij}` combination formula and damping
function. The individual atomic :math:`C_6^i` are interpolated from
several reference values based upon coordination numbers extracted from
the molecular structure, rather than assigned solely by atomic identity as
in DFT-D2, and thereby incorporate some awareness of the chemical
environment into an otherwise largely heuristic correction.  The -D3
dispersion has the following form, where :math:`s_{r,6}` and :math:`s_8`
are the customary nonunity parameters fitted for individual functionals.

.. math:: E_{disp}^{\text{D3ZERO}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}} 
   \frac{C_n^{ij}}{(R_{ij})^n} f_{damp}(R_{ij})
   :label: DFTD3ZERO

.. math:: f_{damp}(R_{ij}) = \frac{1}{1 + 6 (R_{ij}/(s_{r,n} R_0^{ij}))^{- \alpha_n}}


A modified damping scheme for DFT-D3 using the rational damping form of
Becke and Johnson was introduced in [Grimme:2011:1456]_.  The parameters
fit for individual functionals are now :math:`s_6`, :math:`s_8`,
:math:`a_1`, and :math:`a_2`.

.. math:: E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}} 
   \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}

.. math:: f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2

All parameters characterizing the dispersion correction are taken from
`Grimme's website <https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3/get-the-current-version-of-dft-d3>`_
or else from the literature.

Running DFTD3 or DFTD4
~~~~~~~~~~~~~~~~~~~~~~

A number of *a posteriori* dispersion corrections are available in
|PSIfour|.  While some are computed within |PSIfours| codebase (-D1, -D2,
-CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are
available only through the ``DFTD3`` or ``DFTD4`` programs. Once installed, the
``dftd3``/|PSIfour| and ``dftd4``/|PSIfour| interfaces are transparent, and all corrections are
interfaced exactly alike.

Dispersion corrections are built into DFT functionals, so appending an *a
posteriori* correction to a computation is as simple as
``energy('b2plyp-d')`` *vs.* ``energy('b2plyp')``. For example, the
following input file computes (with much redundant work) for water a
B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy. ::

   molecule h2o {
        O
        H 1 1.0
        H 1 1.0 2 104.5
    }
    set {
        basis cc-pVDZ
    }
    energy('b3lyp')
    energy('b3lyp-d')
    energy('b3lyp-d3')
    energy('b3lyp-d4')

Consult the table :ref:`-D Functionals <table:dft_disp>` to see for each
functional what corrections are available and what default parameters
define them. The dispersion correction is available after a calculation in
the PSI variable :psivar:`DISPERSION CORRECTION ENERGY`.
By default, the output from the ``dftd3``
program is suppressed; to see it in the output file, set print > 2.
No text output is available from the ``dftd4`` program.


.. _`table:dashd`:

.. table:: Variants of dispersion corrections

   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | Extension [#f0]_                    | Variant                                                               | Computing Program (engine)      | |scf__dft_dispersion_parameters| [#f10]_                                       |
   +=====================================+=======================================================================+=================================+================================================================================+
   | -D                                  | alias to -D2                                                          |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D1                                 | -D1 [#f1]_                                                            | |PSIfours| libdisp              | [:math:`s_6`]                                                                  |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D2                                 | -D2 [#f2]_                                                            | |PSIfours| libdisp OR ``dftd3`` | [:math:`s_6`, :math:`\alpha_6`, :math:`s_{r,6}`]                               |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3                                 | alias to -D3ZERO                                                      |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3ZERO                             | -D3 [#f3]_ w/ original zero-damping                                   | ``dftd3``                       | [:math:`s_6`, :math:`s_8`, :math:`s_{r,6}`, :math:`\alpha_6`, :math:`s_{r,8}`] |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3BJ                               | -D3 [#f4]_ w/ newer Becke-Johnson rational damping                    | ``dftd3``                       | [:math:`s_6`, :math:`s_8`, :math:`a_1`, :math:`a_2`]                           |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3(BJ)                             | alias to -D3BJ                                                        |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3M                                | alias to -D3MZERO                                                     |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3MZERO                            | -D3 [#f5]_ w/ reparameterized and more flexible original zero-damping | ``dftd3``                       | [:math:`s_6`, :math:`s_8`, :math:`s_{r,6}`, :math:`\beta`]                     |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3MBJ                              | -D3 [#f5]_ w/ reparameterized newer Becke-Johnson rational damping    | ``dftd3``                       | [:math:`s_6`, :math:`s_8`, :math:`a_1`, :math:`a_2`]                           |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D3M(BJ)                            | alias to -D3MBJ                                                       |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -NL                                 | Grimme's -NL (DFT plus VV10 correlation) [#f6]_                       | |PSIfours| nl                   | [:math:`b`, :math:`c`] via |scf__nl_dispersion_parameters|                     |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -CHG                                | Chai & Head-Gordon dispersion formula [#f7]_                          | |PSIfours| libdisp              | [:math:`s_6`]                                                                  |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -DAS2009                            | Podeszwa & Szalewicz dispersion formula [#f8]_                        | |PSIfours| libdisp              | [:math:`s_6`]                                                                  |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -DAS2010                            | Podeszwa & Szalewicz dispersion formula [#f9]_                        | |PSIfours| libdisp              | [:math:`s_6`]                                                                  |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D4                                 | alias to -D4BJEEQATM                                                  |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D4BJ                               | alias to -D4BJEEQATM                                                  |                                 |                                                                                |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+
   | -D4BJEEQATM                         | -D4 [#f11]_                                                           | ``dftd4``                       | [:math:`a_1`, :math:`a_2`, :math:`alp`, :math:`s_6`, :math:`s_8`, :math:`s_9`] |
   +-------------------------------------+-----------------------------------------------------------------------+---------------------------------+--------------------------------------------------------------------------------+


Three-Body Dispersion Corrections
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to the previously discussed two-body dispersion corrections, 
the ``dftd3``/|PSIfour| interface enables computations of three-body dispersion
corrections. In ``DFT-D3``, three-body dispersion is approximated with the
Axilrod-Teller-Muto model:

.. math:: E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})
 
where :math:`\theta_a` is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,
and :math:`\bar{r}_{ABC}` is the geometric mean of the corresponding atomic-pair distances.
The dispersion coefficients are defined as

.. math:: C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}

See the `DFT-D3 documentation <https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3/man.pdf>`_ 
for more details.

For now, the three-body correction can be called by using the :py:func:`~qcdb.Molecule.run_dftd3`
function with `d3-atmgr` as the passed functional string. 
For example, the three-body ATM dispersion correction for a neon trimer could
be computed with::

   molecule ne3 {
   Ne 0.0 0.0 0.0
   Ne 0.0 0.0 1.0
   Ne 0.0 1.0 1.0
   }
   ne.update_geometry()
   energy = m.run_dftd3('d3-atmgr', dertype=0)
   print(energy)


.. rubric:: Footnotes

.. [#f0] Note that there are functionals with these extensions (*e.g.*, wB97X-D) that, 
   not being Grimme corrections, won't follow this table exactly.
   
.. [#f1] [Grimme:2004:1463]_
.. [#f2] [Grimme:2006:1787]_
.. [#f3] [Grimme:2010:154104]_
.. [#f4] [Grimme:2011:1456]_
.. [#f5] [Smith:2016:2197]_
.. [#f6] [Hujo:2011:3866]_
.. [#f7] [Chai:2010:6615]_
.. [#f8] [Pernal:2009:263201]_
.. [#f9] [Podeszwa:2010:550]_

.. [#f10] Keyword not used for user-defined functionals where the ``dft_dict["dispersion"]["params"]``
   is easily editable for this purpose. See :ref:`sec:dftdictbuilder`

.. [#f11] [Caldeweyher:2019:154122]_

A few practical examples:

* DFT-D2 single point with default parameters (``dftd3`` not called) ::

   energy('bp86-d')

* DFT-D3BJ optimization with default parameters ::

   optimize('pbe-d3bj')

* DFT-D2 optimization with custom s6 parameter ::

   set dft_dispersion_parameters [1.20]
   optimize('b3lyp-d2')

* DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values) ::

   set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]
   energy('b3lyp-d3')

* DFT-D2 single point with ``dftd3`` instead of |PSIfours| libdisp ::

   energy('pbe-d2', engine='dftd3')

If only dispersion corrections (rather than total energies) are of
interest, the dispersion programs can be run independently of the scf
through the python function :py:func:`~qcdb.Molecule.run_dftd3` or :py:func:`~qcdb.Molecule.run_dftd4`. (These functions
call QCEngine, which is the same |PSIfour| + ``dftd3``/``dftd4`` interface that is called during an scf job.)
This "D-only" route is much faster than running a DFT-D energy.

Note that in a DFT+D energy or gradient calculation, user-specified
dispersion parameters override any information provided about the
functional. The same holds true for a ``dftd3`` "D-only" calculation. But
in a ``dftd4`` "D-only" calculation, functional information overrides
any user-specified dispersion parameters.

* Some set-up::

   molecule nene {
   Ne
   Ne 1 2.0
   }
   
   nene.update_geometry()

* The same four dispersion corrections/gradients as the section above::

   >>> print nene.run_dftd3('bp86', 'd', dertype=0)
   -7.735e-05
   
   >>> E, G = nene.run_dftd3('pbe', 'd3bj')
   >>> print G
   [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]
   
   >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20})
   >>> print E
   -8.84e-05
   
   >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0})
   >>> print E
   -0.00024762

.. autofunction:: qcdb.Molecule.run_dftd3

.. autoclass:: psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion

.. comment print_stdout('  -D correction from Py-side')
.. comment eneyne.update_geometry()
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd2gr')
.. comment compare_values(ref_d2[0], E, 7, 'Ethene-Ethyne -D2')
.. comment mA = eneyne.extract_subsets(1)
.. comment E, G = mA.run_dftd3('b3lyp', 'd2gr')
.. comment compare_values(ref_d2[1], E, 7, 'Ethene -D2')
.. comment mB = eneyne.extract_subsets(2)
.. comment E, G = mB.run_dftd3('b3lyp', 'd2gr')
.. comment compare_values(ref_d2[2], E, 7, 'Ethyne -D2')
.. comment #mBcp = eneyne.extract_subsets(2,1)
.. comment #E, G = mBcp.run_dftd3('b3lyp', 'd2gr')
.. comment #compare_values(ref_d2[2], E, 7, 'Ethyne(CP) -D2')
.. comment 
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd3zero')
.. comment compare_values(ref_d3zero[0], E, 7, 'Ethene-Ethyne -D3 (zero)')
.. comment mA = eneyne.extract_subsets(1)
.. comment E, G = mA.run_dftd3('b3lyp', 'd3zero')
.. comment compare_values(ref_d3zero[1], E, 7, 'Ethene -D3 (zero)')
.. comment mB = eneyne.extract_subsets(2)
.. comment E, G = mB.run_dftd3('b3lyp', 'd3zero')
.. comment compare_values(ref_d3zero[2], E, 7, 'Ethyne -D3 (zero)')
.. comment 
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd3bj')
.. comment compare_values(ref_d3bj[0], E, 7, 'Ethene-Ethyne -D3 (bj)')
.. comment mA = eneyne.extract_subsets(1)
.. comment E, G = mA.run_dftd3('b3lyp', 'd3bj')
.. comment compare_values(ref_d3bj[1], E, 7, 'Ethene -D3 (bj)')
.. comment mB = eneyne.extract_subsets(2)
.. comment E, G = mB.run_dftd3('b3lyp', 'd3bj')
.. comment compare_values(ref_d3bj[2], E, 7, 'Ethyne -D3 (bj)')
.. comment 
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd3')
.. comment compare_values(ref_d3zero[0], E, 7, 'Ethene-Ethyne -D3 (alias)')
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd')
.. comment compare_values(ref_d2[0], E, 7, 'Ethene-Ethyne -D (alias)')
.. comment E, G = eneyne.run_dftd3('b3lyp', 'd2')
.. comment compare_values(ref_d2[0], E, 7, 'Ethene-Ethyne -D2 (alias)')
.. comment 
.. comment set basis sto-3g
.. comment set scf_type df
.. comment set dft_radial_points 50  # use really bad grid for speed since all we want is the -D value
.. comment set dft_spherical_points 110
.. comment #set scf print 3  # will print dftd3 program output to psi4 output file
.. comment 
.. comment 
.. comment print_stdout('  -D correction from C-side')
.. comment activate(mA)
.. comment energy('b3lyp-d2p4')
.. comment compare_values(ref_d2[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (calling psi4 Disp class)')
.. comment energy('b3lyp-d2gr')
.. comment compare_values(ref_d2[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (calling dftd3 -old)')
.. comment energy('b3lyp-d3zero')
.. comment compare_values(ref_d3zero[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (calling dftd3 -zero)')
.. comment energy('b3lyp-d3bj')
.. comment compare_values(ref_d3bj[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (calling dftd3 -bj)')
.. comment 
.. comment energy('b3lyp-d2')
.. comment compare_values(ref_d2[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (alias)')
.. comment energy('b3lyp-d3')
.. comment compare_values(ref_d3zero[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (alias)')
.. comment energy('b3lyp-d')
.. comment compare_values(ref_d2[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D (alias)')
.. comment energy('wb97x-d')
.. comment compare_values(-0.000834247063, get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene wb97x-d (chg)')
.. comment 
.. comment print_stdout('  non-default -D correction from C-side')
.. comment activate(mB)
.. comment set dft_dispersion_parameters [0.75]
.. comment energy('b3lyp-d2p4')
.. comment compare_values(ref_pbe_d2[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (calling psi4 Disp class)')
.. comment set dft_dispersion_parameters [0.75, 20.0]
.. comment energy('b3lyp-d2gr')
.. comment compare_values(ref_pbe_d2[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (calling dftd3 -old)')
.. comment set dft_dispersion_parameters [1.0,  0.722, 1.217, 14.0]
.. comment energy('b3lyp-d3zero')
.. comment compare_values(ref_pbe_d3zero[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (calling dftd3 -zero)')
.. comment set dft_dispersion_parameters [1.000, 0.7875, 0.4289, 4.4407]
.. comment energy('b3lyp-d3bj')
.. comment compare_values(ref_pbe_d3bj[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (calling dftd3 -bj)')
.. comment 
.. comment set dft_dispersion_parameters [0.75]
.. comment energy('b3lyp-d2')
.. comment compare_values(ref_pbe_d2[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2 (alias)')
.. comment set dft_dispersion_parameters [1.0,  0.722, 1.217, 14.0]
.. comment energy('b3lyp-d3')
.. comment compare_values(ref_pbe_d3zero[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (alias)')
.. comment set dft_dispersion_parameters [0.75]
.. comment energy('b3lyp-d')
.. comment compare_values(ref_pbe_d2[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D (alias)')
.. comment activate(mA)
.. comment set dft_dispersion_parameters [1.0]
.. comment energy('wb97x-d')
.. comment compare_values(-0.000834247063, get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene wb97x-d (chg)')
.. comment 
.. comment print_stdout('  non-default -D correction from Py-side')
.. comment eneyne.update_geometry()
.. comment eneyne.run_dftd3('b3lyp', 'd2gr', {'s6': 0.75})
.. comment compare_values(ref_pbe_d2[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D2')
.. comment mA = eneyne.extract_subsets(1)
.. comment mA.run_dftd3('b3lyp', 'd2gr', {'s6': 0.75})
.. comment compare_values(ref_pbe_d2[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D2')
.. comment mB = eneyne.extract_subsets(2)
.. comment mB.run_dftd3('b3lyp', 'd2gr', {'s6': 0.75})
.. comment compare_values(ref_pbe_d2[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethyne -D2')
.. comment 
.. comment eneyne.run_dftd3('b3lyp', 'd3zero', {'s6': 1.0,  's8': 0.722, 'sr6': 1.217, 'alpha6': 14.0})
.. comment compare_values(ref_pbe_d3zero[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D3 (zero)')
.. comment mA = eneyne.extract_subsets(1)
.. comment mA.run_dftd3('b3lyp', 'd3zero', {'s6': 1.0,  's8': 0.722, 'sr6': 1.217, 'alpha6': 14.0})
.. comment compare_values(ref_pbe_d3zero[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (zero)')
.. comment mB = eneyne.extract_subsets(2)
.. comment mB.run_dftd3('b3lyp', 'd3zero', {'s6': 1.0,  's8': 0.722, 'sr6': 1.217, 'alpha6': 14.0})
.. comment compare_values(ref_pbe_d3zero[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethyne -D3 (zero)')
.. comment 
.. comment eneyne.run_dftd3('b3lyp', 'd3bj', {'s6': 1.000, 's8':  0.7875, 'a1':  0.4289, 'a2': 4.4407})
.. comment compare_values(ref_pbe_d3bj[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D3 (bj)')
.. comment mA = eneyne.extract_subsets(1)
.. comment mA.run_dftd3('b3lyp', 'd3bj', {'s6': 1.000, 's8':  0.7875, 'a1':  0.4289, 'a2': 4.4407})
.. comment compare_values(ref_pbe_d3bj[1], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene -D3 (bj)')
.. comment mB = eneyne.extract_subsets(2)
.. comment mB.run_dftd3('b3lyp', 'd3bj', {'s6': 1.000, 's8':  0.7875, 'a1':  0.4289, 'a2': 4.4407})
.. comment compare_values(ref_pbe_d3bj[2], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethyne -D3 (bj)')
.. comment 
.. comment eneyne.run_dftd3('b3lyp', 'd3', {'s6': 1.0,  's8': 0.722, 'sr6': 1.217, 'alpha6': 14.0})
.. comment compare_values(ref_pbe_d3zero[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D3 (alias)')
.. comment eneyne.run_dftd3('b3lyp', 'd', {'s6': 0.75})
.. comment compare_values(ref_pbe_d2[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D (alias)')
.. comment eneyne.run_dftd3('b3lyp', 'd2', {'s6': 0.75})
.. comment compare_values(ref_pbe_d2[0], get_variable('DISPERSION CORRECTION ENERGY'), 7, 'Ethene-Ethyne -D2 (alias)')

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`faq:add_tests`:

==========
Test Suite
==========

A test suite plays a vital role in open-source software use and development.

* For a |PSIfour| user, tests provide models of inputs that should work
  "as-is" and a searchable collection of syntax and capabilities.
  The test suite also allows high-quality development snapshots of the
  codebase to be built automatically for users.

* For a user who has |PSIfour| as part of a complex computational molecular software environment, a test suite alongside installed |PSIfour| can be used to show that the |PSIfour| piece is working.

* For a feature developer, adding tests provides confidence that you
  can leave your code untouched and still advertise that the feature works
  years later. With tests, proposed changes to |PSIfour| that break your
  code fall upon the change proposer to fix, rather than being merged
  silently and lying in wait for a concientious user to detect and report
  and then likely falling upon *you* to fix.

* For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading.


CTest and pytest, PSIthon and PsiAPI
====================================

In designing a test, sometimes you want it to be a model input for the user in a single file or you don't want a lot of ``psi4.`` or Python syntax cluttering the input.
In this case, follow :ref:`faq:add_psithon_tests` to prepare as PSIthon (``psi4 input.dat``) for, roughly speaking, running through :program:`ctest`.
The PSIthon/CTest test suite occupies the whole of :source:`tests` *except* :source:`tests/pytests`.

At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.
In this case, follow :ref:`faq:add_psiapi_tests` to prepare as PsiAPI (``import psi4``) for, roughly speaking, running through :program:`pytest`.
The PsiAPI/pytest test suite occupies :source:`tests/pytests`.

The above description sounds as if there are two disjoint test suites, and you have to run both ``ctest`` and ``pytest`` to fully test |PSIfour|.
This has indeed been the case until March 2022.
The difficulty has been that (1) two test suites is unexpected so some developers don't know to run both; and (2) there are important tests in the PSIthon suite that can't be run on a |PSIfour| installation since CTest only works in a build directory.
Now, by adding an extra file to the test directory (:ref:`faq:psithon_through_pytest`), PSIthon tests can also be run through :program:`pytest`.
This hasn't rolled out to all ~500 PSIthon tests (help wanted), but eventually |PSIfour| can be tested with a single command from a build or from an installation.
Therefore, in designing a test, choose its mode based on whether PSIthon or PsiAPI suits it better and whether it's a simple model for users (probably PSIthon) or for expert users (probably PsiAPI).
Both will continue to work in future, and neither have limitations.


Test Contents
=============

* Most |PSIfour| tests will be integration tests focusing on non-regression of user input to answers, and we insist on having these.
  But if you find unit tests helpful, by all means add them to the test suite.

* Most tests should store reference results (from literature or another implementation or a carefully run |PSIfour| calculation),
  run quantum chemistry, then apply one or more of the :ref:`faq:comparison_functions` so that the test will fail if the answer is unexpected.
  The functions are the same in CTest and pytest, but in the former they are, for example, ``compare_matrices(refmat, mat, ...)`` while in the latter it's asserted, like ``assert compare_matrices(refmat, mat, ...)``.
  The main advantage of the testing functions is that they provide helpful error printing upon failure. Deep down, they're NumPy functions.

* In preparing the test case reference values, aim for the converged value rather than many digits from your computer under default convergence conditions.
  This will make the test more robust for different OS, different BLAS libraries, and variations in SCF cycles.
  Turn energy, density, amplitude, and geometry convergence criteria to very tight levels, and use these results for reference energies, reference geometries, reference cube files, *etc.*.
  Then, either remove or relax the convergence settings, if these are not a vital part of the test.
  In choosing the number of digits for :py:func:`~psi4.compare_values` and other compare_* functions, select a number looser than the convergence set in the test
  or the default convergence for the calculation type (energy, gradient, *etc.*).

* Keep tests as short as possible without sacrificing coverage and variety. Under 30 seconds is a good aim.


.. _`faq:add_psithon_tests`:

Adding PSIthon Test Cases
=========================

To create a new test case, first make a folder in :source:`tests` or, for an addon, a subfolder under the addon folder.
Use hyphens, not spaces or underscores, in the directory name.
Add the directory name to the list of tests in :source:`tests/CMakeLists.txt` or, for an addon, ``tests/<addon>/CMakeLists.txt``.
The test directory will need at least two files, ``CMakeLists.txt`` and ``input.dat``.

``CMakeLists.txt``
------------------

This file adds the test case to the suite. It should have at least the following two uncommented lines::

    include(TestingMacros)

    # if extra files needed
    # file(COPY grid.dat DESTINATION ${CMAKE_CURRENT_BINARY_DIR})

    add_regression_test(directory_name "psi;semicolon_separated-list-of-applicable-test-labels")

    # if minutes long
    # set_tests_properties(isapt1 PROPERTIES COST 300)

The labels specify which groups of tests include the test case for ``ctest -L label`` purposes. The ``psi`` label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.
Labels have been added as developers needed, so they are not systematic or thorough. If you see labels to add or rename, please do.

A test requiring over 15 minutes should be labeled ``longtests``. A short test under 30 seconds used for general bug checking should be labeled ``quicktests``. A test that confirms |PSIfour| is operational should be labeled ``smoketests``.

If a test needs extra input files like ``grid.dat`` or extra reference files for checking against, like ``fchk``, specify these in the ``CMakeLists.txt`` as shown above. Such tests must be run through ``ctest`` and don't usually work when run "by hand" from the objdir via ``stage/bin/psi4 ../tests/directory_name/input.dat``.

If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the ``COST`` line as shown above to set a weighting to about the number of seconds the test takes.

``input.dat``
-------------

The other necessary file is the input file itself, ``input.dat``. The input file should be just a simple input file to run the test, with small additions. ::

    #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.
    #! Also a bit more to force a second line.

    nucenergy = 8.801466202085710  #TEST
    refenergy = -76.05098402733282  #TEST

    molecule h2o {
       symmetry c1
       O
       H 1 1.0
       H 1 1.0 2 104.5
    }

    set {
       basis cc-pVTZ
       scf_type df
       df_basis_scf cc-pVTZ-RI
       e_convergence 10
    }

    thisenergy = energy("hf")

    compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, "Nuclear repulsion energy")  #TEST
    compare_values(refenergy, thisenergy, 9, "Reference energy")  #TEST
    compare_values(refenergy, variable('scf total energy'), 9, "Reference energy")  #TEST

Of those small modifications, first, note the special comment at the top (starting with the ``#!`` comment marker). This should be descriptive since it is inlined into the manual (unless ``!nosample`` in the comment) as a sample input.

Reference values are often assigned to variables for later use.
The compare_values function (along with several relatives in :source:`psi4/driver/p4util/testing.py` for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don't match. Any lines of the input associated with the validation process should be flagged with ``#TEST`` at the end of each line, so that they can be removed when copying from the tests to the samples directory.

``output.ref``
--------------

When your test case is in final form, run it locally, rename the output to ``output.ref``, and check it into the repository alongside ``input.dat``.
While this isn't used for any testing machinery (except for the nearly decommissioned :source:`tests/psitest.pl` for CC tests; full decommission expected by v1.6), it can be handy for users or developers to consult.

.. _`faq:psithon_through_pytest`:

``test_input.py``
-----------------

Starting March 2022, one can also run tests designed as above for CTest through pytest.
To bring the test to pytest's notice, add a file to the directory named ``test_input.py``.
Below is an example for the :source:`tests/ci-property/test_input.py` ::

    from addons import *

    @ctest_labeler("quick;ci;cas;properties;cart;noc1")
    def test_ci_property():
        ctest_runner(__file__, ["grid.dat"])

This file contains much the same information as the ``CMakeLists.txt``.
The ``def test_ci_property`` contains the name of the test, now with underscores rather than hyphens.
``def test_`` identifies it to pytest as a test.
That part of the function name and the name of the file, ``test_input.py`` are required, but no further registration with CMake is necessary.
Most tests need only the simple form of the runner line ``ctest_runner(__file__)``.
This uses QCEngine machinery to execute ``python psi4 input.dat``.
If additional input files are needed from the test directory, their names can be added to the the second argument list as shown above.
Those additional input files *do* need to be registered in :source:`psi4/CMakeLists.txt`.

Finally, the label string passed to CTest is here handed to pytest, with a few changes:

* ``psi`` added automatically, so exclude it when copying from CTest ``CMakeLists.txt``
* ``cli`` added automatically to distinguish CTest origin from deliberate pytest origin, which have ``api`` added
* ``smoke`` used instead of CTest ``smoketests``
* ``quick`` used instead of CTest ``quicktests``
* ``long`` used instead of CTest ``longtests``
* ``addon`` and ``<name-of-addon>`` added automatically when ``@uusing("<name-of-addon>")`` decorates the test or ``marks=using("<name-of-addon>")`` marks the test

CTest "labels" are called "marks" in pytest.
Any new marks should be added to :source:`pytest.ini`.

Running for Debugging
---------------------

* PSIthon tests that don't need extra files to run are easily run from ``<objdir>`` via ``stage/bin/psi4 ../tests/<test-name>/input.dat, with the output appearing in ``../tests/<test-name>/input.out``.
* All PSIthon tests are runable through CTest, and output files appear in ``<objdir>/tests/<test-name>/output.dat`` and stdout results appear in ``<objdir>/Testing/Temporary/LastTest.log*``.


.. _`faq:add_psiapi_tests`:

Adding PsiAPI Test Cases
========================

To create a new test case, either create a new file or add to an existing file under :source:`tests/pytests`.

* Test must be in the :source:`tests/pytests/` directory.
* Test file name must start with ``test_``. This is how pytest knows to collect it.
* A test file may contain many tests, each of which is an ordinary Python function with name starting ``test_``. This is how pytest knows to collect it.
* No registration required to bring a test to pytest's attention.
* No registration required to bring a test to CMake's attention. If a test needs additional files, register them in :source:`psi4/CMakeLists.txt`.

A few notes on test contents:

* Import testing functions from ``utils`` and use Python assert: ``assert compare_values(expected, computed, ...)``.
* Don't worry about cleaning up files or resetting options. A function in :source:`tests/pytests/conftest.py` does this automatically between every test.
* Especially if using data or functions from outside a test, run a variety of tests at different ``pytest -n <N>`` levels to mix up test ordering. If tests fail that pass when run alone, you've got a function of the same name changing state or some similar correctable phenomenon.

A few notes on test labels:

* For every new test file, add ``pytestmark = [pytest.mark.psi, pytest.mark.api]`` at the top.
  This ensures that every test has the ``psi`` mark and every PsiAPI test has the ``api`` mark to contrast with PSIthon tests with ``cli`` mark.

* There are individual "marks" that can be added to whole tests or parts
  of parameterized tests so that they can be run by category (``pytest -m <mark>``
  vs. ``ctest -L <mark>``) rather than just by name (``pytest -k <name_fragment>``
  vs. ``ctest -R <name_fragment>``). Far more complicated logic is allowed than for
  CTest: ``pytest -m "dftd3 and not api and not long"``.

* The most important marks are "quick" and "long" that opt tests into the quick CI suite or out of
  the normal full suite. Mark with a decorator for the full test or the
  marks argument in a parameterized test. Search "mark" in the test suite
  for examples. Use "quick" freely for tests that cover functionality and
  are under 15s. Use "long" sparingly to winnow out the longest examples,
  particularly those over a minute.

Running for Debugging
---------------------

There are many ways to run pytest, :ref:`faq:pytest`, and three different copies of the test file
(i.e., :source:`tests/pytests/test_mp2.py`, ``<objdir>/stage/lib/PYMOD_INSTALL_LIBDIR/psi4/tests/test_mp2.py``,
``CMAKE_INSTALL_PREFIX/lib/PYMOD_INSTALL_LIBDIR/psi4/tests/test_mp2.py``).
But for developing a pytest test, you probably want to use the first so you can edit it in place rather than running ``cmake --build`` after each change.

* Easiest is from <objdir>, run ``pytest ../tests``. Add any filters (``-k
  test_name_fragment``) or parallelism (``-n <N>``  or ``-n auto`` if ``pytest-xdist``
  installed) or print test names (``-v``) or print warnings (``-rws``).
* An important point is that because they're PsiAPI, ``import psi4`` is happening,
  so the <objdir> |PSIfour| module must be in :envvar:`PYTHONPATH`. Also, any call
  to QCEngine is using ``which psi4``, so the <objdir> |PSIfour| executable must be in
  :envvar:`PATH`. The easiest way to prepare your local environment is to
  execute the printout of ``<objdir>/stage/bin/psi4 --psiapi``.
* To see stdout output from an otherwise passing test, easiest to add ``assert 0``
  at its end to trigger failure.
* If stdout printing is insufficient, and you really need to see ``output.dat`` or other files,
  comment out their deletion in :source:`tests/pytests/conftest.py` and run the single test, deleting
  the file each time (since it appends).


.. _`faq:comparison_functions`:

Comparison Functions
====================

Plain Old Data
--------------

.. function:: psi4.compare_values(expected, computed, atol_exponent, label [, *, **kwargs])
   :noindex:

.. autofunction:: psi4.compare_values(expected, computed [, label, *, **kwargs])

.. comment compare_arrays covered by compare_values

.. autofunction:: qcelemental.testing.compare_values

.. autofunction:: psi4.compare_integers(expected, computed [, label, *, **kwargs])

.. autofunction:: qcelemental.testing.compare


Objects
-------

.. function:: psi4.compare_matrices(expected, computed, atol_exponent, label [, *, check_name=False, **kwargs])
   :noindex:

.. autofunction:: psi4.compare_matrices(expected, computed [, label, *, check_name=False, **kwargs])

.. autofunction:: qcelemental.testing.compare_recursive

.. function:: psi4.compare_vectors(expected, computed, atol_exponent, label [, *, check_name=False, **kwargs])
   :noindex:

.. autofunction:: psi4.compare_vectors(expected, computed [, label, *, check_name=False, **kwargs])

.. function:: psi4.compare_wavefunctions(expected, computed, atol_exponent, label [, *, check_name=False, **kwargs])
   :noindex:

.. autofunction:: psi4.compare_wavefunctions(expected, computed [, label, *, check_name=False, **kwargs])

.. autofunction:: psi4.compare_molrecs(expected, computed [, label, *, check_name=False, **kwargs])

.. autofunction:: qcelemental.testing.compare_molrecs


File Formats
------------

.. autofunction:: psi4.compare_cubes(expected, computed[, label, *, check_name=False, **kwargs])

.. autofunction:: psi4.compare_fchkfiles

.. autofunction:: psi4.compare_fcidumps

.. autofunction:: psi4.compare_moldenfiles

.. autofunction:: qcdb.compare_vibinfos


Extra QCA Functions
-------------------

.. autofunction:: psi4.compare

.. autofunction:: psi4.compare_recursive

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: gau2grid, collocation

.. _`sec:gau2grid`:

Interface to gau2grid by D. G. A. Smith
=======================================

.. codeauthor:: D. G. A. Smith
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <src/lib/libefp_solver>`

.. image:: https://img.shields.io/badge/home-gau2grid-5077AB.svg
   :target: https://github.com/dgasmith/gau2grid

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://github.com/dgasmith/gau2grid/blob/master/README.md

|PSIfour|, relies upon the gau2grid library for Gaussian collocations for DFT. gau2grid
requires no
additional licence, downloads, or configuration. Conversely, |Psifour|
cannot build *without* gau2grid.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/gau2grid/badges/version.svg
     :target: https://anaconda.org/psi4/gau2grid

* gau2grid is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, gau2grid has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  gau2grid can be obtained through ``conda install gau2grid -c psi4``.
  Then, hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect gau2grid and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   gau2grid from conda without thinking, consult.

* To remove a conda installation, ``conda remove gau2grid``.

**Source**

* .. image:: https://img.shields.io/github/tag/dgasmith/gau2grid.svg?maxAge=2592000
     :target: https://github.com/dgasmith/gau2grid/tree/master

* If using |PSIfour| built from source and you want gau2grid built from
  from source also, let the build system fetch and build it and activate
  dependent code.


.. _`cmake:gau2grid`:

How to configure gau2gridfor building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, gau2grid is a library that provides essential
  grid operations for DFT.

* Downstream Dependencies |w---w| |PSIfour| |dr| gau2grid

* Upstream Dependencies |w---w| gau2grid |dr| None

**CMake Variables**

* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing ``include/gau2grid/gau2grid.h``
* :makevar:`gau2grid_DIR` |w---w| CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing ``share/cmake/gau2grid/gau2gridConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_gau2grid` |w---w| CMake variable to force internal build of gau2grid instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_gau2grid` |w---w| CMake variable to force detecting pre-built gau2grid and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake

B. Link against pre-built

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root

  .. code-block:: bash

    >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir

C. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:intercalls`:

Function Intercalls
===================

This topic is in transition. As of 1.0, the functionality provided by
``cp()`` and ``cbs()`` should not be accessed directly. Instead, use the
``cp`` kwarg and/or the extended method syntax like
``'mp3/aug-cc-pv[dt]z'`` to ``energy()``, ``opt()``, *etc.*, respectively.

For many of the |PSIfour| Python functions described above, it makes scientific
sense that they could be called in combination. For instance, one could
optimize all the reagents in a database or compute a
counterpoise-corrected interaction energy with an extrapolated method. The
table below outlines permitted intercalls between functions, showing that
db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This
table is not yet validated for calls with cp().

.. _`table:intercalls`:

.. table:: Permitted nesting of Psithon functions

    +-------------------------+-----+-----+-----+-----+--------+
    | Caller                  | Callee                         |
    +-------------------------+-----+-----+-----+-----+--------+
    |                         | cp  | db  | opt | cbs | energy |
    +=========================+=====+=====+=====+=====+========+
    | :ref:`sec:cp()`         |     | --- |  Y  |  Y  |   Y    |
    +-------------------------+-----+-----+-----+-----+--------+
    | :ref:`sec:db()`         | --- |     |  Y  |  Y  |   Y    |
    +-------------------------+-----+-----+-----+-----+--------+
    | :ref:`sec:opt()`        | --- | --- |     |  Y  |   Y    |
    +-------------------------+-----+-----+-----+-----+--------+
    | :ref:`sec:cbs()`        | --- | --- | --- |     |   Y    |
    +-------------------------+-----+-----+-----+-----+--------+
    | :ref:`sec:energy()`     | --- | --- | --- | --- |        |
    +-------------------------+-----+-----+-----+-----+--------+

- The command db(opt(cbs(energy()))) is actually expressed as ``db(...,
  db_func=opt, opt_func=cbs)``. The perhaps expected final argument of
  ``cbs_func=energy`` is not necessary since energy() is always the function
  called by default. Also, the outermost internal function call (``db_func``
  above can be called as just ``func``. Several examples of intercalls
  between Python functions can be found in sample input :srcsample:`pywrap-all`.

- All keyword arguments are passed along to each function traversed in the
  Python driver, so there should be no concern for separating them, grouping
  them, or designating them for a particular function when undertaking a
  nested calculation. Where the same keyword is used by multiple functions,
  prefixes are added, *e.g.*, **db_mode** and **opt_mode**.

- Function intercalls should not be used in sow/reap mode.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: geometry optimization, optimization

.. _`sec:optking`:

Geometry Optimization
=====================

.. codeauthor:: Rollin A. King
.. sectionauthor:: Rollin A. King and Lori A. Burns

*Module:* :ref:`Keywords <apdx:optking>`, :ref:`PSI Variables <apdx:optking_psivar>`, :source:`OPTKING <psi4/src/psi4/optking>`

|PSIfour| carries out molecular optimizations using a module called
optking.  The optking program takes as input nuclear gradients and,
optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.
The default minimization algorithm employs an empirical model Hessian,
redundant internal coordinates, an RFO step, and the BFGS Hessian update.

The principal literature references include the introduction of redundant
internal coordinates by Peng et al. [Peng:1996:49]_.
The general approach employed in this code
is similar to the "model Hessian plus RF method" described and tested by Bakken and
Helgaker [Bakken:2002:9160]_. (However, for separated
fragments, we have chosen not to employ by default their "extra-redundant"
coordinates defined by their "auxiliary interfragment" bonds.  These can be
included via the option |optking__add_auxiliary_bonds|).

The internal coordinates are generated automatically based on an assumed bond
connectivity.  The connectivity is determined by testing if the interatomic
distance is less than the sum of atomic radii times the value of
|optking__covalent_connect|. If the user finds that some
connectivity is lacking by default, then this value may be increased.
Otherwise, the internal coordinate definitions may be modified directly.  If one
desires to see or modify the internal coordinates being used, then one can set
|optking__intcos_generate_exit| to true.  The internal coordinate
definitions are provided in the file with extension ".intco".  See the :ref:`sec:optkingExamples`
section for more detail.

.. warning:: The selection of a Z-matrix input, and in particular the inclusion
   of dummy atoms, has no effect on the behavior of the optimizer, which begins
   from a Cartesian representation of the system.

The ongoing development of optking is providing for unique treatment of
coordinates which connect distinct molecular fragments.  Thus, several keywords
relate to "interfragment modes", though many of these capabilities are
still under development.  Presently by default, separate fragments are bonded by
nearest atoms, and the whole system is treated as if it were part of one
molecule.  However, with the option |optking__frag_mode|, fragments
may instead be related by a unique set of interfragment coordinates defined by
reference points within each fragment.  The reference points can be atomic
positions (current default), linear combinations of
atomic positions, or located on the principal axes (not yet working).

Basic Keywords
^^^^^^^^^^^^^^

.. include:: autodir_options_c/optking__opt_type.rst
.. include:: autodir_options_c/optking__step_type.rst
.. include:: autodir_options_c/optking__geom_maxiter.rst
.. include:: autodir_options_c/optking__g_convergence.rst
.. include:: autodir_options_c/optking__full_hess_every.rst
.. include:: autodir_options_c/optking__intcos_generate_exit.rst

.. index:: geometry optimization; minima
.. _`sec:optkingExamples`:

Optimizing Minima
^^^^^^^^^^^^^^^^^

First, define the molecule and basis in the input. ::

   molecule h2o {
     O
     H 1 1.0
     H 1 1.0 2 105.0
   }
    
   set basis dz

Then the following are examples of various types of calculations that can be completed.

* Optimize a geometry using default methods (RFO step)::

   optimize('scf')

* Optimize using Newton-Raphson steps instead of RFO steps::

   set step_type nr
   optimize('scf')

* Optimize using energy points instead of gradients::

   optimize('scf', dertype='energy')

* Optimize while limiting the initial step size to 0.1 au::

   set intrafrag_step_limit 0.1
   optimize('scf')

* Optimize while always limiting the step size to 0.1 au:

.. code-block:: none

   set {
     intrafrag_step_limit     0.1
     intrafrag_step_limit_min 0.1
     intrafrag_step_limit_max 0.1
   }

   optimize('scf')

* Optimize while calculating the Hessian at every step:

.. code-block:: none

   set full_hess_every 1
   optimize('scf')

Hessian
^^^^^^^

If Cartesian second derivatives are available, optking can read them
and transform them into internal coordinates to make an initial Hessian in
internal coordinates.  Otherwise, several empirical Hessians are available,
including those of Schlegel [Schlegel:1984:333]_ and Fischer and Almlof
[Fischer:1992:9770]_.
Either of these or a simple diagonal Hessian may be selected using the 
|optking__intrafrag_hess| keyword.

All the common Hessian update schemes are available.  For formulas, see
Schlegel [Schlegel:1987:AIMQC]_ and Bofill [Bofill:1994:1]_.

The Hessian may be computed during an optimization using the 
|optking__full_hess_every| keyword.

.. index:: 
   pair: geometry optimization; transition state
   pair: geometry optimization; IRC
   single: geometry optimization; constrained

Transition States, Reaction Paths, and Constrained Optimizations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Calculate a starting Hessian and optimize the "transition state" of
  linear water (note that without a reasonable starting geometry and
  Hessian, such a straightforward search often fails)::

   molecule h2o {
      O
      H 1 1.0
      H 1 1.0 2 160.0
   }

   set {
      basis dz
      full_hess_every 0
      opt_type ts
   }

   optimize('scf')

* At a transition state (planar HOOH), compute the second derivative, and
  then follow the intrinsic reaction path to the minimum::

   molecule hooh {
      symmetry c1
      H
      O 1 0.946347
      O 2 1.397780 1  107.243777
      H 3 0.946347 2  107.243777   1 0.0
   }

   set {
      basis dzp
      opt_type irc
      geom_maxiter 50
   }

   frequencies('scf')
   optimize('scf')

* Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees. ::

   molecule {
     H
     O 1 0.90
     O 2 1.40 1 100.0
     H 3 0.90 2 100.0 1 90.0
   }

   set optking {
     frozen_dihedral = ("
       1 2 3 4
     ")
   }
   optimize('scf')

* To instead freeze the two O-H bond distances ::

   set optking {
     frozen_distance = ("
       1  2
       3  4
     ")
   }

For bends, the corresponding keyword is "frozen_bend".

* To freeze the cartesian coordinates of atom 2

.. code-block:: none

   freeze_list = """
     2 xyz
   """
   set optking frozen_cartesian $freeze_list

* To freeze only the y coordinates of atoms 2 and 3

.. code-block:: none

   freeze_list = """
     2 y
     3 y
   """
   set optking frozen_cartesian $freeze_list

* To optimize toward a value of 0.95 Angstroms for the distance between 
  atoms 1 and 3, as well as that between 2 and 4

.. code-block:: none

   set optking {
     fixed_distance = ("
       1  3 0.95
       2  4 0.95
     ")
   }

Note that the effect of the frozen and fixed keywords is independent of
how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.)..

* To scan the potential energy surface by optimizing at several fixed values
  of the dihedral angle of HOOH.

.. code-block:: none

   molecule hooh {
    0 1
    H  0.850718   0.772960    0.563468
    O  0.120432   0.684669   -0.035503
    O -0.120432  -0.684669   -0.035503
    H -0.850718  -0.772960    0.563468
   }
   
   set {
     basis cc-pvdz
     intrafrag_step_limit 0.1
   }
   
   dihedrals = [100,110,120,130,140,150]
   PES = []
   
   for phi in dihedrals:
     my_string = "1 2 3 4 " + str(phi)
     set optking fixed_dihedral = $my_string
     E = optimize('scf')
     PES.append((phi, E))
   
   print "\n\tcc-pVDZ SCF energy as a function of phi\n"
   for point in PES:
     print "\t%5.1f%20.10f" % (point[0], point[1])


Dealing with problematic optimizations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Although optking is continuously improved with robustness in mind, some
attempted optimizations will inevitably fail to converge to the desired minima.
For difficult cases, the following suggestions are made.

* As for any optimizer, computing the Hessian and limiting the step size will
  successfully converge a higher percentage of cases.  The default settings have
  been chosen because they perform efficiently for common, representative test sets.
  More restrictive, cautious steps are sometimes necessary.

* |optking__dynamic_level| allows optking to change the method of optimization
  toward algorithms that, while often less efficient, may help to converge difficult
  cases.  If this is initially set to 1, then optking, as poor steps are detected,
  will increase the level through several forms of more robust and cautious algorithms.
  The changes will reduce the trust radius, allow backward steps (partial line
  searching), add cartesian coordinates, switch to cartesian coordinates, and take
  steepest-descent steps.

* The developers have found the |optking__opt_coordinates| set to "BOTH" which
  includes both the redundant internal coordinate set, as well as cartesian coordinates,
  works well for systems with long 'arms' or floppy portions of a molecule poorly
  described by local internals.

Direct manipulation of the optmization coordinates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* Generate the internal coordinates and then stop::

   set intcos_generate_exit true
   optimize('scf')

  The coordinates may then be found in the "intco" file.  In this case, the file contains::
  
     F 1 3
     R      1     2
     R      1     3
     B      2     1     3
     C      1
            1    1.000000
     C      1
            2    1.000000
     C      1
            3    1.000000

  The first line indicates a fragment containing atoms 1-3.  The following lines define
  two distance coordinates (bonds) and one bend coordinate.  This file can be modified, and if present,
  is used in subsequent optimizations.  The lines below the simple internal coordinates
  specify linear combinations of coordinates.  In the simplest default case, the lines
  above simply define combination coordinates which are identical to the simple internals.
  If |optking__opt_coordinates| specifies delocalized coordinates, then the combinations
  will be more complex.
 
  Since the multiple-fragment coordinates are still under
  development, they are not documented here.  However, if desired, one can change the value
  of |optking__frag_mode|, generate the internal coordinates, and see how multiple
  fragment systems are defined.
  
  Coordinates may be frozen by adding an asterisk after the letter of the coordinate.  The
  asterisk results in that internal coordinate being frozen at its initial value.  The
  "intco" file below for water specifies an optimization with both O-H bonds frozen.::
  
     F 1 3
     R*     1     2
     R*     1     3
     B      2     1     3

  If one instead wishes to optimize toward ("fix") a value that is not satisfied by the
  initial structure, then the value is added to the end of the line.  The following
  corresponds to an optimization that will add additional forces to move the O-H bonds
  to 1.70 au. ::

     F 1 3
     R      1     2     1.70
     R      1     3     1.70
     B      2     1     3

.. index:: 
   pair: geometry optimization; convergence criteria

Convergence Criteria
^^^^^^^^^^^^^^^^^^^^

Optking monitors five quantities to evaluate the progress of a geometry 
optimization. These are (with their keywords) the change in energy 
(|optking__max_energy_g_convergence|), the maximum element of 
the gradient (|optking__max_force_g_convergence|), the root-mean-square 
of the gradient (|optking__rms_force_g_convergence|), the maximum element
of displacement (|optking__max_disp_g_convergence|), and the 
root-mean-square of displacement (|optking__rms_disp_g_convergence|), 
all in internal coordinates and atomic units. Usually, these options will not 
be set directly. Primary control for geometry convergence lies with the keyword 
|optking__g_convergence| which sets the aforementioned in accordance 
with Table :ref:`Geometry Convergence <table:optkingconv>`.

|
|

.. _`table:optkingconv`:

.. table:: Summary of sets of geometry optimization criteria available in |PSIfour|

    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | |optking__g_convergence|    | Max Energy                 | Max Force                  | RMS Force                  | Max Disp                   | RMS Disp                   |
    +=============================+============================+============================+============================+============================+============================+
    | NWCHEM_LOOSE [#fd]_         |                            | :math:`4.5 \times 10^{-3}` | :math:`3.0 \times 10^{-3}` | :math:`5.4 \times 10^{-3}` | :math:`3.6 \times 10^{-3}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | GAU_LOOSE [#ff]_            |                            | :math:`2.5 \times 10^{-3}` | :math:`1.7 \times 10^{-3}` | :math:`1.0 \times 10^{-2}` | :math:`6.7 \times 10^{-3}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | TURBOMOLE [#fd]_            | :math:`1.0 \times 10^{-6}` | :math:`1.0 \times 10^{-3}` | :math:`5.0 \times 10^{-4}` | :math:`1.0 \times 10^{-3}` | :math:`5.0 \times 10^{-4}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | GAU [#fc]_ [#ff]_           |                            | :math:`4.5 \times 10^{-4}` | :math:`3.0 \times 10^{-4}` | :math:`1.8 \times 10^{-3}` | :math:`1.2 \times 10^{-3}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | CFOUR [#fd]_                |                            |                            | :math:`1.0 \times 10^{-4}` |                            |                            |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | QCHEM [#fa]_ [#fe]_         | :math:`1.0 \times 10^{-6}` | :math:`3.0 \times 10^{-4}` |                            | :math:`1.2 \times 10^{-3}` |                            |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | MOLPRO [#fb]_ [#fe]_        | :math:`1.0 \times 10^{-6}` | :math:`3.0 \times 10^{-4}` |                            | :math:`3.0 \times 10^{-4}` |                            |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | INTERFRAG_TIGHT [#fg]_      | :math:`1.0 \times 10^{-6}` | :math:`1.5 \times 10^{-5}` | :math:`1.0 \times 10^{-5}` | :math:`6.0 \times 10^{-4}` | :math:`4.0 \times 10^{-4}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | GAU_TIGHT [#fc]_ [#ff]_     |                            | :math:`1.5 \times 10^{-5}` | :math:`1.0 \times 10^{-5}` | :math:`6.0 \times 10^{-5}` | :math:`4.0 \times 10^{-5}` |
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+
    | GAU_VERYTIGHT [#ff]_        |                            | :math:`2.0 \times 10^{-6}` | :math:`1.0 \times 10^{-6}` | :math:`6.0 \times 10^{-6}` | :math:`4.0 \times 10^{-6}` | 
    +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+

.. rubric:: Footnotes

.. [#fa] Default
.. [#fb] Baker convergence criteria are the same.
.. [#fc] Counterpart NWCHEM convergence criteria are the same.
.. [#fd] Convergence achieved when all active criteria are fulfilled.
.. [#fe] Convergence achieved when **Max Force** and one of **Max Energy** or **Max Disp** are fulfilled.
.. [#ff] Normal convergence achieved when all four criteria (**Max Force**, **RMS Force**,
         **Max Disp**, and **RMS Disp**) are fulfilled. To help with flat 
         potential surfaces, alternate convergence achieved when 100\ :math:`\times`\ *rms force* is less 
         than **RMS Force** criterion.
.. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes 
         tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when
         *max force* and/or *rms force* are small.

For ultimate control, specifying a value for any of the five monitored options activates that
criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.
Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ 
and instead requires all active criteria to be fulfilled to 
achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|.

.. index::
   pair: geometry optimization; output

Interface to GeomeTRIC
^^^^^^^^^^^^^^^^^^^^^^

The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of
Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC)
system that works well for optimizing geometries of systems containing noncovalent interactions.

Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to
:py:func:`~psi4.optimize`. The optimization will respect the keywords |optking__g_convergence|
and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints)
may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.optimize`. 
Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be
used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github
<https://github.com/leeping/geomeTRIC>`_ 
for more information on keywords and JSON specification of constraints.

* Optimize the water molecule using GeomeTRIC::

   molecule h2o {
      O
      H 1 1.0
      H 1 1.0 2 160.0
   }

   set {
      maxiter 100
      g_convergence gau
   }

   optimize('hf/cc-pvdz', engine='geometric')

* Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au
  and the HOH angle constrained to 104.5 degrees::

   molecule h2o {
      O
      H 1 1.0
      H 1 1.0 2 160.0
   }

   set {
      maxiter 100
      g_convergence gau
   }

   geometric_keywords = { 
     'coordsys' : 'tric',
     'constraints' : { 
     'set' : [{'type'    : 'distance',
               'indices' : [0, 1], 
               'value'   : 2.0 },
              {'type'    : 'angle',
               'indices' : [1, 0, 2], 
               'value'   : 104.5 }]
      }   
   }   

   optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords)

* Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in 
  place::

   molecule h2o {
     C            0.833     1.221    -0.504
     H            1.482     2.086    -0.518
     C            1.379    -0.055    -0.486
     H            2.453    -0.184    -0.483
     C            0.546    -1.167    -0.474
     H            0.971    -2.162    -0.466
     C           -0.833    -1.001    -0.475
     H           -1.482    -1.867    -0.468
     C           -1.379     0.275    -0.490
     H           -2.453     0.404    -0.491
     C           -0.546     1.386    -0.506
     H           -0.971     2.381    -0.524
     --
     O            0.000     0.147     3.265
     H            0.000    -0.505     2.581
     H            0.000     0.965     2.790
     no_com
     no_reorient
   }

   set {
      maxiter 100
      g_convergence gau
   }

   geometric_keywords = { 
     'coordsys' : 'tric',
     'constraints' : { 
     'freeze' : [{'type'    : 'xyz',
                  'indices' : [0, 2, 4, 6, 8, 10]}]
      }   
   }   

   optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords)


Output
^^^^^^

The progress of a geometry optimization can be monitored by grepping the output file for the
tilde character (``~``). This produces a table like the one below that shows
for each iteration the value for each of the five quantities and whether the criterion
is active and fulfilled (``*``), active and unfulfilled ( ),  or inactive (``o``). ::

   --------------------------------------------------------------------------------------------- ~
    Step     Total Energy     Delta E     MAX Force     RMS Force      MAX Disp      RMS Disp    ~
   --------------------------------------------------------------------------------------------- ~
     Convergence Criteria    1.00e-06 *    3.00e-04 *             o    1.20e-03 *             o  ~
   --------------------------------------------------------------------------------------------- ~
       1     -38.91591820   -3.89e+01      6.91e-02      5.72e-02 o    1.42e-01      1.19e-01 o  ~
       2     -38.92529543   -9.38e-03      6.21e-03      3.91e-03 o    2.00e-02      1.18e-02 o  ~
       3     -38.92540669   -1.11e-04      4.04e-03      2.46e-03 o    3.63e-02      2.12e-02 o  ~
       4     -38.92548668   -8.00e-05      2.30e-04 *    1.92e-04 o    1.99e-03      1.17e-03 o  ~
       5     -38.92548698   -2.98e-07 *    3.95e-05 *    3.35e-05 o    1.37e-04 *    1.05e-04 o  ~

The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`.

Information on the Psithon function that drives geometry optimizations is provided
at :py:func:`~psi4.optimize`.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: Libxc, DFT, functionals

.. _`sec:libxc`:

Interface to Libxc by M. A. L. Marques
======================================

.. codeauthor:: M. A. L. Marques and Micael Oliveira
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <src/lib/libefp_solver>`

.. image:: https://img.shields.io/badge/home-libxc-5077AB.svg
   :target: https://gitlab.com/libxc/libxc

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://www.tddft.org/programs/libxc/manual/

|PSIfour|, relies upon the Libxc library for density functionals. Libxc
requires no
additional licence, downloads, or configuration. Conversely, |Psifour|
cannot build *without* Libxc.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/libxc/badges/version.svg
     :target: https://anaconda.org/psi4/libxc

* Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, Libxc has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  Libxc can be obtained through ``conda install libxc -c psi4``.
  Then, hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect Libxc and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   Libxc from conda without thinking, consult.

* To remove a conda installation, ``conda remove libxc``.

**Source**

* .. image:: https://img.shields.io/github/tag/loriab/libxc.svg?maxAge=2592000
     :target: https://github.com/loriab/libxc/tree/libxc4retweaked

  Note that |PSIfour| has forked and slightly modified upstream Libxc from
  https://gitlab.com/libxc/libxc to regain functionality.

* If using |PSIfour| built from source and you want Libxc built from
  from source also,
  let the build system fetch and build it and activate dependent code.


.. _`cmake:libxc`:

How to configure Libxc for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, Libxc is a library that provides essential
  density functional definitions and compositions.

* Downstream Dependencies |w---w| |PSIfour| |dr| Libxc

* Upstream Dependencies |w---w| Libxc |dr| None

**CMake Variables**

* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing ``include/libxc/xc.h``
* :makevar:`Libxc_DIR` |w---w| CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing ``share/cmake/Libxc/LibxcConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_Libxc` |w---w| CMake variable to force internal build of Libxc instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_Libxc` |w---w| CMake variable to force detecting pre-built Libxc and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake

B. Link against pre-built

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root

  .. code-block:: bash

    >>> cmake -DLibxc_DIR=/path/to/libxc/configdir

C. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: Frozen natural orbital coupled cluster, FNO-CC

.. index::
   single: QCISD(T)
   single: MP4
   single: CEPA
   single: LCCSD
   single: Frozen Natural Orbitals
   single: FNO-QCISD(T)
   single: FNO-MP4
   single: FNO-CCSD(T)
   single: DF-CCSD(T)
   pair: CCSD(T); density-fitting

.. _`sec:fnocc`:

FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4
===================================================================

.. codeauthor:: A. Eugene DePrince
.. sectionauthor:: A. Eugene DePrince

*Module:* :ref:`Keywords <apdx:fnocc>`, :ref:`PSI Variables <apdx:fnocc_psivar>`, :source:`FNOCC <psi4/src/psi4/fnocc>`

.. warning:: There is a known bug concerning the i7-5930 series combined
   with the Intel 15 compilers and MKL 11.2.3. When |PsiFour| is compiled
   under these conditions, parallel runs of the FNOCC code have experienced
   nonsensical CCSD correlation energies (often several Hartrees lower
   than the starting guess). At the moment, the only confirmed solutions
   are running serially, using a different BLAS implementation, or upgrading
   to Intel 16.0.2 and MKL 11.3.2.

Frozen natural orbitals (FNO)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The computational cost of the CCSD [Purvis:1982]_, CCSD(T)
[Raghavachari:1989]_, and related methods be reduced by constructing a
compact representation of the virtual space based on the natural orbitals
of second-order perturbation theory [Sosa:1989:148]_.  The most demanding
steps in the CCSD and (T) algorithms scale as :math:`{\cal{O}}(o^2v^4)`
and :math:`{\cal{O}}(o^3v^4)`, where :math:`o` and :math:`v` represent the
number of oribitals that are occupied and unoccupied (virtual) in the
reference function, respectively.  By reducing the the size of the virtual
space, the cost of evaluating these terms reduces by a factor of :math:`(v
/ v_{FNO})^4`, where :math:`v_{FNO}` represents the number of virtual
orbitals retained after the FNO truncation.

The general outline for the FNO procedure in |Psifour| is:

    (i)   construct the virtual-virtual block of the unrelaxed MP2 one-particle density matrix (OPDM) 
    (ii)  diagonalize this block of the OPDM to obtain a set of natural virtual orbitals
    (iii) based on some occupancy threshold, determine which orbitals are unimportant and may be discarded
    (iv)  project the virtual-virtual block of the Fock matrix onto the truncated space
    (v)   construct semicanonical orbitals by diagonalizing the virtual-virtual block of the Fock matrix
    (vi)  proceed with the QCISD(T) / CCSD(T) / MP4 computation in the reduced virtual space

A second-order correction based upon the MP2 energies in the full and
truncated spaces captures much of the missing correlation effects.  More
details on the implementation and numerical accuracy of FNO methods in
|Psifour| can be found in [DePrince:2013:293]_\.  FNO computations
are controlled through the keywords |fnocc__nat_orbs| and
|fnocc__occ_tolerance|, or by prepending a valid method name with "fno" in
the energy call as ::

    energy('fno-ccsd(t)')

If you wish to specify the number of active natural orbitals manually, use
the keyword |fnocc__active_nat_orbs|.  This keyword will override the 
keyword |fnocc__occ_tolerance|.

QCISD(T), CCSD(T), MP4, and CEPA
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The FNOCC module in |Psifour| supports several related many-body quantum
chemistry methods, including the CCSD(T) and QCISD(T) methods, several
orders of many-body perturbation theory (MP2-MP4), and a family methods
related to the coupled electron pair approximation (CEPA).

Quadratic configuration interaction and coupled cluster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The quadratic configuration interaction singles doubles (QCISD) method of
Pople, Head-Gordon, and Raghavachari [Pople:1987:5968]_\  was originally
presented as a size-consistent extension of configuration interaction
singles doubles (CISD). The method can also be obtained as a
simplified version of the coupled cluster singles doubles (CCSD)
method [Purvis:1982]_\.  Consider the set of equations defining CCSD:

.. math::
    :label: CCSD

    \langle \Psi_0  | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2)|\Psi_0\rangle = 0, \\
    \langle \Psi_i^a  | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2+T_1T_2+\frac{1}{3!}T_1^3)|\Psi_0\rangle = 0, \\
    \langle \Psi_{ij}^{ab}  | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2 + T_1T_2+\frac{1}{3!}T_1^3+\frac{1}{2}T_2^2+\frac{1}{2}T_1^2T_2+\frac{1}{4!}T_1^4)|\Psi_0\rangle = 0, \\


where we have chosen the intermediate normalization, 
:math:`\langle \Psi_0| \Psi \rangle = 1`, and the symbols :math:`T_1` 
and :math:`T_2` represent single and double excitation operators.  The 
QCISD equations can be obtained by omitting all but two terms that 
are nonlinear in :math:`T_1` and :math:`T_2`:

.. math::
    :label: QCISD

    \langle \Psi_0  | (H - E) (1 + T_1 + T_2)|\Psi_0\rangle = 0, \\
    \langle \Psi_i^a  | (H - E) (1 + T_1 + T_2 + T_1T_2)|\Psi_0\rangle = 0, \\
    \langle \Psi_{ij}^{ab}  | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_2^2)|\Psi_0\rangle = 0. \\

QCISD is slightly cheaper that CCSD computationally, but it retains the
:math:`{\cal{O}}(o^2v^4)` complexity of the original equations. Just as in
the familiar CCSD(T) method, the effects of connected triple excitations
may be included noniteratively to yield the QCISD(T) method.  Both the
QCISD(T) and CCSD(T) methods are implemented for closed-shell references
in the FNOCC module.

.. _`sec:fnompn`:

Many-body perturbation theory 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

QCI and CC methods are closely related to perturbation theory, and the
MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free
by-product of a CCSD or QCISD computation.  The following is an 
example of the results for a computation run with the call
``energy('fno-qcisd')`` to :py:func:`~psi4.energy`:

.. code-block:: none

  QCISD iterations converged!

        OS MP2 FNO correction:                -0.000819116338
        SS MP2 FNO correction:                -0.000092278158
        MP2 FNO correction:                   -0.000911394496

        OS MP2 correlation energy:            -0.166478414245
        SS MP2 correlation energy:            -0.056669079827
        MP2 correlation energy:               -0.223147494072
      * MP2 total energy:                    -76.258836941658

        OS MP2.5 correlation energy:          -0.171225850256
        SS MP2.5 correlation energy:          -0.054028401038
        MP2.5 correlation energy:             -0.225254251294
      * MP2.5 total energy:                  -76.260943698880

        OS MP3 correlation energy:            -0.175973286267
        SS MP3 correlation energy:            -0.051387722248
        MP3 correlation energy:               -0.227361008515
      * MP3 total energy:                    -76.263050456101

        OS MP4(SDQ) correlation energy:       -0.180324322304
        SS MP4(SDQ) correlation energy:       -0.048798468084
        MP4(SDQ) correlation energy:          -0.230995119324
      * MP4(SDQ) total energy:               -76.266684566910

        OS QCISD correlation energy:          -0.181578117924
        SS QCISD correlation energy:          -0.049853548145
        QCISD correlation energy:             -0.231431666069
      * QCISD total energy:                  -76.267121113654

The first set of energies printed corresponds to the second-order FNO 
correction mentioned previously.  Results for many-body perturbation 
theory through partial fourth order are then provided.
The notation MP4(SDQ) indicates that we have included all contributions to
the correlation energy through fourth order, with the exception of that
from connected triple excitations.  

One need not run a full QCISD or CCSD computation to obtain these
perturbation theory results.  The keywords for invoking perturbation
theory computations are given below in
Table :ref:`FNOCC Methods <table:fnocc_methods>`.  Full MP4 correlation
energies are also available.

.. _`sec:fnocepa`:

Coupled electron pair approximation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Coupled-pair methods can be viewed as approximations to CCSD or as
size-extensive modifications of CISD.  The methods have the same
complexity as CISD, and solving the CISD or coupled-pair equations
requires fewer floating point operations than solving the CCSD.  CISD,
CCSD, and the coupled-pair methods discussed below all scale formally with
the sixth power of system size, and, as with the QCISD method, CEPA
methods retain :math:`{\cal{O}}(o^2v^4)` complexity of the CCSD equations.
For a detailed discussion of the properties of various coupled-pair
methods, see [Wennmohs:2008:217]_\.

What follows is a very basic description of the practical differences in
the equations that define each of the coupled-pair methods implemented in
|Psifour|.  We begin with the CISD wave function

.. math::
    :label: CIwfn

    | \Psi \rangle = | \Psi_0 \rangle + \sum_i^{occ} \sum_a^{vir} t_i^a | \Psi_i^a\rangle + \frac{1}{4}\sum_{ij}^{occ} \sum_{ab}^{vir} t_{ij}^{ab} | \Psi_{ij}^{ab}\rangle,

where we have chosen the intermediate normalization, :math:`\langle \Psi_0
| \Psi \rangle = 1`.  The CISD correlation energy is given by

.. math::
    :label: CIenergy
    
    E_c = \langle \Psi_0 | \hat{H} - E_0 | \Psi \rangle,

and the amplitudes can be determined by the solution to the coupled set of
equations:

.. math::
    :label: CIeqns
    
    0   &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - E_c | \Psi \rangle, \\
    0   &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - E_c | \Psi \rangle.

The CISD method is not size-extensive, but this problem can be overcome by
making very simple modifications to the amplitude equations.  We replace
the correlation energy, :math:`E_c`, with generalized shifts for the
doubles and singles equations, :math:`\Delta_{ij}` and :math:`\Delta_i`:

.. math::
    :label: CEPAeqns
    
    0   &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - \Delta_{ij} | \Psi \rangle, \\
    0   &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - \Delta_i | \Psi \rangle.

These shifts approximate the effects of triple and quadruple excitations.
The values for :math:`\Delta_{ij}` and :math:`\Delta_i`  used in several
coupled-pair methods are given in Table :ref:`CEPA Shifts
<table:cepa_shifts>`.  Note that these shifts are defined in a spin-free
formalism for closed-shell references only.

    .. _`table:cepa_shifts`:

    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | method                  | :math:`\Delta_{ij}`                                        |  :math:`\Delta_i`                            |
    +=========================+============================================================+==============================================+
    | cisd                    | :math:`E_c`                                                |  :math:`E_c`                                 |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | cepa(0)                 | 0                                                          |  0                                           |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | cepa(1)                 | :math:`\frac{1}{2}\sum_k(\epsilon_{ik}+\epsilon_{jk})`     | :math:`\sum_k \epsilon_{ik}`                 |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | cepa(3)                 | :math:`-\epsilon_{ij}+\sum_k(\epsilon_{ik}+\epsilon_{jk})` | :math:`-\epsilon_{ii}+2\sum_k \epsilon_{ik}` |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | acpf                    | :math:`\frac{2}{N} E_c`                                    | :math:`\frac{2}{N} E_c`                      |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+
    | aqcc                    | :math:`[1-\frac{(N-3)(N-2)}{N(N-1)}]E_c`                   | :math:`[1-\frac{(N-3)(N-2)}{N(N-1)}]E_c`     |
    +-------------------------+------------------------------------------------------------+----------------------------------------------+

.. comment    | dci                     | :math:`E_c`                                                |  NA                                          |
.. comment    +-------------------------+------------------------------------------------------------+----------------------------------------------+

The pair correlation energy, :math:`\epsilon_{ij}`, is simply a partial
sum of the correlation energy.  In a spin-free formalism, the pair energy
is given by

.. math::
   :label: pair_energy

   \epsilon_{ij} = \sum_{ab} v_{ij}^{ab} (2 t_{ij}^{ab} - t_{ij}^{ba})

Methods whose shifts (:math:`\Delta_{ij}` and :math:`\Delta_i`) do not
explicitly depend on orbitals :math:`i` or :math:`j` (CISD, CEPA(0), ACPF,
and AQCC) have solutions that render the energy stationary with respect
variations in the amplitudes.  This convenient property allows density
matrices and 1-electron properties to be evaluated without any additional
effort.  Note, however, that 1-electron properties are currently
unavailable when coupling these stationary CEPA-like methods with frozen
natural orbitals.

Density-fitted coupled cluster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky
decomposition (CD) techniques are popular in quantum chemistry to avoid
the computation and storage of the 4-index electron repulsion integral
(ERI) tensor and even to reduce the computational scaling of some terms.
DF/CD-CCSD(T) computations are available in |Psifour|, with or without the
use of FNOs, through the FNOCC module.  The implementation and accuracy of
the DF/CD-CCSD(T) method are described in [DePrince:2013:2687]_\.

The DF-CCSD(T) procedure uses two auxiliary basis sets.  The first set is
that used in the SCF procedure, defined by the |scf__df_basis_scf|
keyword.  If this keyword is not specified, an appropriate -JKFIT set is
automatically selected.  This auxiliary set defines the ERIs used to
build the Fock matrix used in the DF-CCSD(T) procedure.  The second
auxiliary set is used to approximate all other ERIs in the DF-CCSD(T)
procedure. The choice of auxiliary basis is controlled by the keyword
|fnocc__df_basis_cc|.  By default, |fnocc__df_basis_cc| is the RI set
(optimized for DFMP2) most appropriate for use with the primary basis.
For example, if the primary basis is aug-cc-pVDZ, the default
|fnocc__df_basis_cc| will be aug-cc-pVDZ-RI.

Alternatively, the user can request that the DF-CCSD(T) procedure use a
set of vectors defined by the Cholesky decomposition of the ERI tensor as
the auxiliary basis. This feature is enabled by specifying |globals__cc_type| ``CD``.
CD methods can be enabled in the SCF
procedure as well, by specifying the |globals__scf_type| as ``CD``.  The
accuracy of the decomposition can be controlled through the keyword
|fnocc__cholesky_tolerance|.

.. comment This feature is enabled by specifying |fnocc__df_basis_cc| as "CHOLESKY".  

The following input file sets up a DF-CCSD(T)
computation using CD integrals ::

    molecule h2o {
        0 1
        O
        H 1 1.0
        H 1 1.0 2 104.5
    }
    
    set {
        scf_type cd
        cc_type cd
        basis aug-cc-pvdz
        freeze_core true
    }
    energy('ccsd(t)')

The resulting CCSD(T) correlation energy will be equivalent to that
obtained from a conventional computation if |fnocc__cholesky_tolerance| is
sufficiently small (*e.g.* ``1e-9``).

.. _`sec:fnogn`:

Gn theory
~~~~~~~~~

The FNOCC module contains all the components that comprise the Gn family
of composite methods.  Currently, only the G2 method is supported
[Curtiss:1991:7221]_\.  The G2 procedure may be called through the
:py:func:`~psi4.energy` wrapper: ::

    energy('gaussian-2')

Supported methods
~~~~~~~~~~~~~~~~~

The various methods supported by the FNOCC module in |Psifour| are detailed
in Table :ref:`FNOCC Methods <table:fnocc_methods>`.  Note that these methods
are implemented for closed-shell references only.  For open-shell references,
the calls ``energy('mp2.5')``, ``energy('mp3')``, and ``energy('mp4')`` will
default to implementations of these methods in :ref:`other modules <table:managedmethods>`.

    .. _`table:fnocc_methods`:

    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | name                    | calls method                                                | type select                               |
    +=========================+=============================================================+===========================================+
    | qcisd                   | quadratic configuration interaction singles doubles         | |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | qcisd(t)                | qcisd with perturbative triples                             | |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | mp2.5                   | average of second- and third-order perturbation theories    | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | mp3                     | third-order perturbation theory                             | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | mp4(sdq)                | fourth-order perturbation theory, minus triples contribution| |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | mp4                     | full fourth-order perturbation theory                       | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | lccd                    | linear ccd                                                  | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | cepa(0), lccsd          | coupled electron pair approximation, variant 0              | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | cepa(1)                 | coupled electron pair approximation, variant 1              | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | cepa(3)                 | coupled electron pair approximation, variant 3              | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | acpf                    | averaged coupled-pair functional                            | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | aqcc                    | averaged quadratic coupled-cluster                          | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | cisd                    | configuration interaction with single and double excitations| |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-qcisd               | qcisd with frozen natural orbitals                          | |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-qcisd(t)            | qcisd(t) with frozen natural orbitals                       | |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-ccsd                | coupled cluster singles doubles with frozen natural orbitals| |globals__cc_type| CONV, DF, CD           |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-ccsd(t)             | ccsd with perturbative triples and frozen natural orbitals  | |globals__cc_type| CONV, DF, CD           |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-mp3                 | mp3 with frozen natural orbitals                            | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-mp4(sdq)            | mp4(sdq) with frozen natural orbitals                       | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-mp4                 | mp4 with frozen natural orbitals                            | |globals__mp_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-lccd                | linear ccd with frozen natural orbitals                     | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-cepa(0), fno-lccsd  | cepa(0) with frozen natural orbitals                        | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-cepa(1)             | cepa(1) with frozen natural orbitals                        | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-cepa(3)             | cepa(3) with frozen natural orbitals                        | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-acpf                | acpf with frozen natural orbitals                           | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-aqcc                | aqcc with frozen natural orbitals                           | |globals__cc_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+
    | fno-cisd                | cisd with frozen natural orbitals                           | |globals__ci_type| CONV                   |
    +-------------------------+-------------------------------------------------------------+-------------------------------------------+

.. comment    | df-ccsd                 | ccsd with density fitting                                   |
.. comment    +-------------------------+-------------------------------------------------------------+
.. comment    | df-ccsd(t)              | ccsd(t) with density fitting                                |
.. comment    +-------------------------+-------------------------------------------------------------+
.. comment    | fno-df-ccsd             | ccsd with density fitting and frozen natural orbitals       |
.. comment    +-------------------------+-------------------------------------------------------------+
.. comment    | fno-df-ccsd(t)          | ccsd(t) with density fitting and frozen natural orbitals    |
.. comment    +-------------------------+-------------------------------------------------------------+
.. comment    | dci                     | configuration interaction with double excitations           |
.. comment    +-------------------------+-------------------------------------------------------------+
.. comment    | fno-dci                 | dci with frozen natural orbitals                            |
.. comment    +-------------------------+-------------------------------------------------------------+

.. index:: FNOCC; basic-keywords

Basic FNOCC Keywords
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: /autodir_options_c/mints__basis.rst
.. include:: /autodir_options_c/globals__freeze_core.rst
.. include:: /autodir_options_c/fnocc__r_convergence.rst
.. include:: /autodir_options_c/fnocc__e_convergence.rst
.. include:: /autodir_options_c/fnocc__maxiter.rst
.. include:: /autodir_options_c/fnocc__diis_max_vecs.rst
.. include:: /autodir_options_c/fnocc__nat_orbs.rst
.. include:: /autodir_options_c/fnocc__occ_tolerance.rst
.. include:: /autodir_options_c/fnocc__triples_low_memory.rst
.. include:: /autodir_options_c/fnocc__cc_timings.rst
.. include:: /autodir_options_c/fnocc__df_basis_cc.rst
.. include:: /autodir_options_c/fnocc__cholesky_tolerance.rst
.. include:: /autodir_options_c/fnocc__cepa_no_singles.rst
.. include:: /autodir_options_c/fnocc__dipmom.rst

.. index:: FNOCC; advanced-keywords

Advanced FNOCC Keywords
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. include:: /autodir_options_c/fnocc__scs_mp2.rst
.. include:: /autodir_options_c/fnocc__mp2_scale_os.rst
.. include:: /autodir_options_c/fnocc__mp2_scale_ss.rst
.. include:: /autodir_options_c/fnocc__scs_ccsd.rst
.. include:: /autodir_options_c/fnocc__cc_scale_os.rst
.. include:: /autodir_options_c/fnocc__cc_scale_ss.rst
.. include:: /autodir_options_c/fnocc__run_mp2.rst
.. include:: /autodir_options_c/fnocc__run_mp3.rst
.. include:: /autodir_options_c/fnocc__run_mp4.rst
.. include:: /autodir_options_c/fnocc__run_ccsd.rst
.. include:: /autodir_options_c/fnocc__run_cepa.rst
.. include:: /autodir_options_c/fnocc__compute_triples.rst
.. include:: /autodir_options_c/fnocc__compute_mp4_triples.rst
.. include:: /autodir_options_c/fnocc__dfcc.rst
.. include:: /autodir_options_c/fnocc__cepa_level.rst
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: harmonic vibrational analysis, vibrational analysis, thermochemical analysis

.. _`sec:thermo`:

Vibrational and Thermochemical Analysis
=======================================

.. codeauthor:: Rollin A. King and Lori A. Burns
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Keywords <apdx:thermo>`, :ref:`PSI Variables <apdx:thermo_psivar>`, :source:`THERMO <psi4/driver/qcdb/vib.py>`


.. caution:: It is important to know that |PSIfour|, like any other
   quantum chemistry program, does *not* compute the usual enthalpies,
   entropies, or Gibbs free energies *of formation* provided by most
   reference books.  Instead, quantum chemistry programs compute "absolute"
   thermodynamic properties relative to infinitely separated nuclei and
   electrons, not "formation" values relative to elements in their standard
   states.  If you are computing thermodynamic differences, like a reaction
   enthalpy computed as the enthalpy of the products minus the enthalpy
   of the reactants, then these "absolute" enthalpies are perfectly valid
   and usable.  However, they cannot be mixed and matched with enthalpies of
   formation from reference books, since the zero of energy is not the same.
   Additionally, the "thermal energies" reported in kcal/mol are the 
   finite-temperature *corrections* to the electronic total energy, and 
   not the overall thermal energies themselves.  If in doubt, use the
   reported Total Energies in Hartree/particle.

Keywords
^^^^^^^^

.. include:: autodir_options_c/thermo__t.rst
.. include:: autodir_options_c/thermo__p.rst
.. include:: autodir_options_c/thermo__rotational_symmetry_number.rst

.. _`sec:thermoExamples`:

Examples
^^^^^^^^

A thermochemical analysis is performed after any full (not just specific
symmetry subgroups). If the wavefunction is retained, it may be reused
at a different temperature, pressure, rotational symmetry number, or
isotopic substitution through the function :py:func:`psi4.driver.qcdb.vib.thermo`
as is shown in :srcsample:`freq-isotope2`.

A few summary psivars are set: "ZPVE", "THERMAL ENERGY CORRECTION",
"ENTHALPY CORRECTION", "GIBBS FREE ENERGY CORRECTION", "ZERO K
ENTHALPHY", "THERMAL ENERGY", "ENTHALPY", "GIBBS FREE ENERGY".
But additionally, every valid combination of {S, Cv, Cp, ZPE, E, H, G}
with {elec, trans, rot, vib, corr, tot} (e.g., vibrational entropy,
S_vib, and enthalpy correction, H_corr) is returned by dictionary
from the ``thermo`` function. See :source:`tests/pytests/test_vibanalysis.py`
(near the end) for an example.


.. index::
   pair: vibrational analysis; output

Output
^^^^^^

The full list of keywords for thermo is provided in Appendix :ref:`apdx:thermo`.

Information on the Psithon function that drives frequency analyses is provided
at :py:func:`~psi4.frequency`.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:psithonInput`:

==================================
Psithon: Structuring an Input File
==================================

To allow arbitrarily complex computations to be performed, |PSIfour| was built
upon the Python interpreter. However, to make the input syntax simpler, some
pre-processing of the input file is performed before it is interpreted,
resulting in Python syntax that is customized for PSI, termed Psithon.  In
this section we will describe the essential features of the Psithon language.
|PSIfour| is distributed with an extensive test suite, described in section
:ref:`apdx:testSuite`; the input files for these test cases can be found in the
samples subdirectory of the top-level |PSIfour| source directory and should
serve as useful examples.

.. index:: physical constants
.. _`sec:physicalConstants`:

Physical Constants
==================

For convenience, the Python interpreter will execute the contents of the
|psirc| file in the current user's home area (if present) before performing any
tasks in the input file.  This allows frequently used python variables to be
automatically defined in all input files.  For example, if we repeatedly make
use of the universal gravitational constant, the following line could be placed
in the |psirc| file ::

    UGC = 6.67384E-11  # m^3 / kg^-1 s^-2

which would make the variable ``UGC`` available in all |PSIfour| input files.
For convenience, the physical constants used within the |PSIfour| code (which
are obtained from `NIST CODATA 2014
<https://physics.nist.gov/cuu/Constants/archive2014.html>`_
are also automatically loaded as Psithon
variables (before |psirc| is loaded, so that the user's |psirc| values can
override the builtins (in the input file, not in the C++ code).

The physical constants used within |PSIfour|, which are automatically
made available within all |PSIfour| input files are in :ref:`table:physconst`.

.. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py
..    :lines: 28-

In Psithon input files, prepend physical constants with ``psi_`` to
prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In
PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``.

.. index:: memory
.. _`sec:memory`:

Memory Specification
====================

By default, |PSIfour| assumes that 500 MiB of memory are available. While this is
enough for many computations, many of the algorithms will perform better if
more is available. To specify memory, the ``memory`` keyword should be used. The following
lines are all equivalent methods for specifying that 2 GB of RAM is available
to |PSIfour|::

    # all equivalent

    memory 2 GB
    
    memory 2000 MB
    
    memory 2000000 kB

Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).

By default, |PSIfour| performs a "sanity check" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::

    # setting available memory to 2 MB
    set_memory_bytes(2000000)

Please note that this memory setting only governs the maximal memory
usage of the major data structures, and actual total memory usage
is slightly higher. This is usually a negligible amount, except when
setting tiny memory allowances.

One convenient way to override the |PSIfour| default memory is to place a
memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,
the following makes the default memory 2 GB. ::

    set_memory(2000000000)

However, unless you're assured of having only one job running on a node at
a time (and all nodes on the filesystem with |psirc| have similar memory
capacities), it is advised to set memory in the input file on a
per-calculation basis.

That same command can be used for PsiAPI mode::

    psi4.set_memory(int(5e8))

.. note:: For parallel jobs, the ``memory`` keyword represents the total memory
   available to the job, *not* the memory per thread.

Molecule and Geometry Specification
===================================

.. toctree::
   :maxdepth: 2

   psithonmol

.. comment To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`.

To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`.

.. index::
   triple: setting; keywords; general
.. _`sec:jobControl`:

Job Control Keywords
====================

|PSIfour| comprises a number of C++ modules that each perform
specific tasks and are callable directly from the Python front end. Each module
recognizes specific keywords in the input file which control its function.
These keywords are detailed in Appendix :ref:`apdx:options_c_module`.
The keywords can be made global, or scoped to apply to
certain specific modules. The following examples demonstrate some of the ways
that global keywords can be specified::

    # all equivalent

    set globals basis cc-pVDZ

    set basis cc-pVDZ

    set globals basis = cc-pVDZ

    set basis = cc-pVDZ

    set globals{
      basis cc-pVDZ
    }
    
    set {
      basis cc-pVDZ
    }
    
    set {
      basis = cc-pVDZ
    }

Note the lack of quotes around ``cc-pVDZ``, even though it is a string. The
Psithon preprocessor automatically wraps any string values in ``set`` commands in
strings. The last three examples provide a more convenient way for specifying
multiple keywords::

    set {
      basis = cc-pVDZ
      print = 1
      reference = rhf
    }

For arguments that require an array input, standard Python list syntax should
be used, *viz.*::

    set {
      docc = [3, 0, 1, 1]
    }

List/matrix inputs may span multiple lines, as long as the opening ``[`` is
on the same line as the name of the keyword.

Any of the above keyword specifications can be scoped to individual modules,
by adding the name of the module after the ``set`` keyword. Omitting the module
name, or using the name ``global`` or ``globals`` will result in the keyword being
applied to all modules. For example, in the following input ::

    molecule{
      o
      h 1 roh
      h 1 roh 2 ahoh
    
      roh = 0.957
      ahoh = 104.5
    }
    
    set basis cc-pVDZ
    set ccenergy print 3
    set scf print 1
    energy('ccsd')

the basis set is set to cc-pVDZ throughout, the SCF code will have a print
level of 1 and the ccenergy code, which performs coupled cluster computations,
will use a print level of 3. In this example a full CCSD computation is
performed by running the SCF code first, then the coupled cluster modules;
the :py:func:`~psi4.energy` Python helper function ensures that this is performed correctly.
Note that the Python interpreter executes commands in the order they appear in
the input file, so if the last four commands in the above example were to read ::

    set basis cc-pVDZ
    energy('ccsd')
    set ccenergy print 3
    set scf print 1

the commands that set the print level would be ineffective, as they would be
processed after the CCSD computation completes.

In PsiAPI mode, one can use the command :py:func:`~psi4.set_options`
like below for general and module-specific options. Note that these values
should be of correct type, strings for strings, floats for floats like
convergences. The function `~psi4.core.clean_options` that reinitializes
all options may also be useful to separate calculations in a PsiAPI
session. ::

   psi4.set_options({
       'scf_type': 'pk',
       'e_convergence': 1.e-5,
       'soscf': True,
       'optking__geom_maxiter': 50
   })

Basis Sets
==========

.. toctree::
   :maxdepth: 2

   basissets

.. _`sec:psiVariables`:

PSI Variables
=============

To harness the power of Python, |PSIfour| makes the most pertinent results
of each computation available to the Python interpreter for
post-processing. To demonstrate, we can embellish the previous example of
H\ :sub:`2` and H atom::

    molecule h2 {
      H
      H 1 0.9
    }
    
    set basis cc-pvdz
    set reference rhf
    h2_energy = energy('scf')
    
    molecule h {
      H
    }
    
    set basis cc-pvdz
    set reference uhf
    h_energy = energy('scf')
    
    D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy)
    print "De=%f" % D_e

The :py:func:`~psi4.energy` function returns the final result of the
computation, the requested total energy in Hartrees, which we assign to a
Python variable. The two energies are then converted to a dissociation
energy and printed to the output file using standard Python notation.

Generally, there are multiple quantities of interest. Appendix
:ref:`apdx:psivariables_module` lists PSI variables variables set by each
module, and :ref:`apdx:psivariables_alpha` defines them.  These can be
accessed through the :py:func:`~psi4.core.get_variable` function. For example, after
performing a density fitted MP2 computation, both the spin component
scaled energy and the unscaled MP2 energy are made available::

    e_mp2 = get_variable('MP2 TOTAL ENERGY')
    e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY')

Each module and the Python driver set PSI variables over the course of a
calculation.  The values for all can be printed in the output file with
the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables
are cleared at the start of each :py:func:`~psi4.energy`, etc. in an input
file by :py:func:`~psi4.core.clean_variables()`.
So if you run in a single input file a STO-3G FCI followed by a
aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the
last will include :psivar:`SCF TOTAL ENERGY` but not
:psivar:`FCI TOTAL ENERGY`.
The entire dictionary of PSI variables can be obtained through
:py:func:`~psi4.core.get_variables`.

.. _`sec:returnvals`:

Return Values
=============

Most of the usual user computation functions (*i.e.*,
:py:func:`~psi4.energy`, :py:func:`~psi4.optimize`, and
:py:func:`~psi4.frequency`) return simply the current total energy.
Consult the descriptions of other functions in :ref:`sec:psithonFunc` for
what quantities they return and for what data structures they make
available for post-processing. Many users need only deal with the simple return
form for the computation functions. ::

    # E is total energy float
    # G is gradient array
    # H is hessian array
    # wfn is class instance with many computational details

    # simple returns
    E = energy(...)
    E = optimize(...)
    E = frequency(...)
    G = gradient(...)  # used by optimize()
    H = hessian(...)  # used by frequency()

For more elaborate post-processing of computations, adding
``return_wfn=True`` keyword argument additionally returns
:py:class:`~psi4.core.Wavefunction`. ::

    # power user returns
    E, wfn = energy(..., return_wfn=True)
    E, wfn = optimize(..., return_wfn=True)
    E, wfn = frequency(..., return_wfn=True)
    G, wfn = gradient(..., return_wfn=True)  # used by optimize()
    H, wfn = hessian(..., return_wfn=True)  # used by frequency()

    # print gradient array and its rms
    wfn.gradient.print_out()
    print wfn.gradient().rms()

    # format output for other programs
    molden(wfn, 'mycalc.molden')

    # access array in another format
    np.array(wfn.hessian())

.. _`sec:loops`:

Loops
=====

Python provides many control structures, any of which can be used within |PSIfour|
input files. For example, to loop over three basis sets, the following code can
be used:

.. code-block:: none

    basis_sets = ["cc-pVDZ", "cc-pVTZ", "cc-pVQZ"]
    for basis_set in basis_sets:
        set basis = $basis_set
        energy('scf')

The declaration of ``basis_sets`` is completely standard Python, as is the next
line, which iterates over the list. However, because the Psithon preprocessor
wraps strings in quotes by default, we have to tell it that ``basis_set`` is a
Python variable, not a string, by prefixing it with a dollar sign. 

The geometry specification supports delayed initialization of variable,
which permits potential energy scans. As an example, we can scan both the
angle and bond length in water::

    molecule h2o{
      O
      H 1 R
      H 1 R 2 A
    }
    
    Rvals = [0.9, 1.0, 1.1]
    Avals = range(102, 106, 2)
    
    set basis cc-pvdz
    set scf e_convergence=11
    for R in Rvals:
        h2o.R = R
        for A in Avals:
            h2o.A = A
            energy('scf')

The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.
Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within
the loops. Note that we do not need the dollar sign to access the Python
variable in this example; that is required only when using Python variables
with the ``set`` keyword.

Cartesian geometries, because of details of the geometry update process,
need to be specified within the loop(s) along with their basis set when
geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix
and Cartiesian scans.

.. _`sec:resultsTables`:

Tables of Results
=================

The results of computations can be compactly tabulated with the :py:func:`~psi4.driver.p4util.Table` Psithon
function. For example, in the following potential energy surface scan for water ::

    molecule h2o {
      O
      H 1 R
      H 1 R 2 A
    }
    
    Rvals=[0.9,1.0,1.1]
    Avals=range(100,102,2)
    
    table=Table(rows=["R","A"], cols=["E(SCF)","E(SCS)","E(DFMP2)"])
    
    set basis cc-pvdz
    
    for R in Rvals:
        h2o.R = R
        for A in Avals:
            h2o.A = A
            energy('mp2')
            escf = get_variable('SCF TOTAL ENERGY')
            edfmp2 = get_variable('MP2 TOTAL ENERGY')
            escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY')
            table[R][A] = [escf, escsmp2, edfmp2]
    
    print table
    relative=table.copy()
    relative.absolute_to_relative()
    print relative

we first define a table (on line 10) with two row indices and three column
indices. As the potential energy scan is performed, the results are stored
(line 22) and the final table is printed to the output file (line 24). The
table is converted from absolute energies to relative energies (in |kcalpermol|)
on line 26, before being printed again. The relative energies are reported with
respect to the lowest value in each column. More examples of how to control the
formatting of the tables can be found in the sample input files provided; see
Appendix :ref:`apdx:testSuite` for a complete listing.

.. _`sec:wrappers`:

Python Wrappers
===============

The Python foundations of the |PSIfour| driver and Psithon syntax permit
many commonly performed post-processing procedures to be integrated into
the |PSIfour| suite.  

As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,
the :py:func:`~psi4.driver.driver_nbody.nbody_gufunc` wrapper provides automatic computation of 
counterpoise-corrected interaction energies between two molecules.  For
example, ::

  energy('mp2', bsse_type='cp')

will compute the counterpoise-corrected density-fitted MP2 interaction energy
between two molecules.

|PSIfour| also provides the :py:func:`~psi4.cbs` wrapper,
which automatically computes a complete-basis-set extrapolation (and
automatically sets up the computations with different basis sets required to
do the extrapolation).  For example,::

  # all equivalent

  cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2)

  energy('mp2/cc-pv[dt]z')

will compute a 2-point Helgaker extrapolation of the correlation energy
using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this
extrapolated correlation energy to the Hartree--Fock energy in the
largest basis (cc-pVTZ). :py:func:`~psi4.cbs` can
either be called directly, as in the first example, or the convenience
syntax of the equivalent second example can be used.

Another very useful and powerful feature of |PSIfour| is the ability
to compute results on entire databases of molecules at a time,
as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper.  For example,::

  database('mp2', 'S22', cp=1, benchmark='S22B')

will perform DF-MP2 counterpoise-corrected interaction energies
(``cp=1``) on all members of Hobza's S22 database set of van der Waals
dimers, and then compare the results against the S22B benchmark energies.
Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,
NCB31, S66by8, and NBC10, among others.

These wrapper functions are discussed separately in
:ref:`sec:psithonFunc`.  Note that the options documented for Python
functions are placed as arguments in the command that calls the function,
not in the ``set {...}`` block or with any other ``set`` command.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: FISAPT
   pair: FISAPT; theory

.. _`sec:fisapt`:

F/I-SAPT: Functional Group and/or Intramolecular SAPT
=====================================================

.. codeauthor:: Robert M. Parrish
.. sectionauthor:: Robert M. Parrish

*Module:* :ref:`Keywords <apdx:fisapt>`, :ref:`PSI Variables
<apdx:fisapt_psivar>`, :source:`FISAPT <psi4/src/psi4/fisapt>`

The FISAPT module provides two extensions to standard SAPT theory to allow for
(1) an effective two-body partition of the various SAPT terms to localized
chemical functional groups (F-SAPT) and (2) a means to compute the SAPT
interaction between two moieties within the embedding field of a third body
(I-SAPT). F-SAPT is designed to provide additional insight into the chemical
origins of a noncovalent interaction, while I-SAPT allows for one to perform
a SAPT analysis for intramolecular interactions. F-SAPT and I-SAPT can be
deployed together in this module, yielding "F/I-SAPT." All F/I-SAPT computations
in |PSIfour| use density-fitted SAPT0 as the underlying SAPT methodology. Interested
users should consult the manual page for Ed Hohenstein's :ref:`SAPT0 <sec:sapt>` code
and the SAPT literature to understand the specifics of SAPT0 before beginning
with F/I-SAPT0.

F-SAPT is detailed over two papers: [Parrish:2014:044115]_ on our much-earlier
"atomic" SAPT (A-SAPT) and [Parrish:2014:4417]_ on the finished "functional
group" SAPT (F-SAPT). An additional paper describes how to use F-SAPT to analyze
differences under functional group substitutions [Parrish:2014:17386]_.  I-SAPT
is explained in [Parrish:2015:051103]_. There is also a reasonably-detailed
review of the aims of A/F/I-SAPT and the existing state-of-the-art in the field
in the introduction chapter on partitioned SAPT methods in `Parrish's thesis
<https://smartech.gatech.edu/handle/1853/53850>`_.

A video tutorial series for the use of the FISAPT module is available `here
<https://www.youtube.com/playlist?list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
Specific videos in the series include:

- `F-SAPT#1
  <https://www.youtube.com/watch?v=J22J0wh4mVo&index=1&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
  Describes the use of F-SAPT to analyze the
  distribution of the intermolecular interaction energy components between the
  various hydroxyl and phenyl moieties of the phenol dimer.
- `F-SAPT#2
  <https://www.youtube.com/watch?v=fqlzXsayec0&index=2&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
  Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a
  "difference F-SAPT" analysis
- `I-SAPT#1
  <https://www.youtube.com/watch?v=fD6mu_tTG_c&index=3&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
  Describes the use of I-SAPT to analyze the interaction between the two phenol
  groups in a 2,4-pentanediol molecule.
- `I-SAPT#2
  <https://www.youtube.com/watch?v=hDbonAOD5dY&index=4&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
  Discusses how to plot the density fields and ESPs of the various moieties of
  the I-SAPT embedding scheme with PyMol
- `F/I-SAPT Options
  <https://www.youtube.com/watch?v=KFkPKSUZVfI&index=5&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_.
  Details all of the more-advanced options in the F/I-SAPT code (rarely needed).

The scripts discussed below are located in :source:`psi4/share/psi4/fsapt`.

F-SAPT: A Representative Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the
distribution of the intermolecular interaction energy components between the
various hydroxyl and phenyl moieties of the phenol dimer. This example is
explicitly included in :srcsample:`fsapt1`. A video
lecture explaining this example is available `F-SAPT#1
<https://www.youtube.com/watch?v=J22J0wh4mVo&index=1&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_,
while an additional video describing how to plot the order-1 F-SAPT analysis
with PyMol and perform a "difference F-SAPT"
analysis is available `F-SAPT#2
<https://www.youtube.com/watch?v=fqlzXsayec0&index=2&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_::

    memory 1 GB
    
    molecule mol {
    0 1
    O    -1.3885044    1.9298523   -0.4431206
    H    -0.5238121    1.9646519   -0.0064609
    C    -2.0071056    0.7638459   -0.1083509
    C    -1.4630807   -0.1519120    0.7949930
    C    -2.1475789   -1.3295094    1.0883677
    C    -3.3743208   -1.6031427    0.4895864
    C    -3.9143727   -0.6838545   -0.4091028
    C    -3.2370496    0.4929609   -0.7096126
    H    -0.5106510    0.0566569    1.2642563
    H    -1.7151135   -2.0321452    1.7878417
    H    -3.9024664   -2.5173865    0.7197947
    H    -4.8670730   -0.8822939   -0.8811319
    H    -3.6431662    1.2134345   -1.4057590
    --
    0 1
    O     1.3531168    1.9382724    0.4723133
    H     1.7842846    2.3487495    1.2297110
    C     2.0369747    0.7865043    0.1495491
    C     1.5904026    0.0696860   -0.9574153
    C     2.2417367   -1.1069765   -1.3128110
    C     3.3315674   -1.5665603   -0.5748636
    C     3.7696838   -0.8396901    0.5286439
    C     3.1224836    0.3383498    0.8960491
    H     0.7445512    0.4367983   -1.5218583
    H     1.8921463   -1.6649726   -2.1701843
    H     3.8330227   -2.4811537   -0.8566666
    H     4.6137632   -1.1850101    1.1092635
    H     3.4598854    0.9030376    1.7569489
    symmetry c1
    no_reorient
    no_com
    }
    
    set {
    basis         jun-cc-pvdz
    scf_type df
    guess sad
    freeze_core true
    }
    
    energy('fisapt0')

This file runs a DF-HF computation on the full dimer using |PSIfours| existing
SCF code. The monomer SCF computations are performed inside the FISAPT module,
following which a complete DF-SAPT0 computation is performed. Additional bits of
analysis are performed to generate the order-2 partition of the SAPT terms to
the level of nuclei and localized occupied orbitals |w--w| this generally does not
incur much additional overhead beyond a standard SAPT0 computations. The
nuclear/orbital partition data is written to the folder :file:`fsapt/` in the same
directory as the input file (this can be changed by |fisapt__fisapt_fsapt_filepath|).

One obtains the desired F-SAPT partition by post-processing the data in
:file:`fsapt/`. Within this dir, the user is expected to provide the ASCII files
:file:`fA.dat` and :file:`fB.dat`, which describe the assignment of atoms to chemical
functional groups using 1-based ordering. *E.g.*, for the problem at hand,
:file:`fA.dat` contains::

    OH 1 2
    PH 3 4 5 6 7 8 9 10 11 12 13

while :file:`fB.dat` contains::
    
    OH 14 15
    PH 16 17 18 19 20 21 22 23 24 25 26

At this point, the user should run the ``fsapt.py`` post-processing script in
the ``fsapt`` directory as::

    >>> fsapt.py

This will generate, among other files, the desired functional-group partition in
``fsapt.dat``. For our problem, the bottom of this file contains the finished
partition::

    Frag1     Frag2          Elst      Exch     IndAB     IndBA      Disp     Total
    OH        OH           -8.425     6.216    -0.583    -1.512    -1.249    -5.553
    OH        PH            1.392     0.716     0.222    -0.348    -0.792     1.189
    PH        OH           -2.742     0.749    -0.147    -0.227    -0.674    -3.040
    PH        PH            0.680     2.187     0.007    -0.208    -2.400     0.266
    OH        All          -7.033     6.931    -0.362    -1.860    -2.040    -4.364
    PH        All          -2.062     2.936    -0.140    -0.435    -3.074    -2.774
    All       OH          -11.167     6.965    -0.730    -1.739    -1.923    -8.594
    All       PH            2.072     2.903     0.229    -0.556    -3.191     1.456
    All       All          -9.095     9.867    -0.501    -2.295    -5.114    -7.138

Note that the assignment of linking sigma bond contributions is a small point of
ambiguity in F-SAPT. The ``fsapt.dat`` file presents the "links-by-charge"
assignment at the top and the "links by 50-50" assignment at the bottom. We
generally prefer the latter, but both generally give qualitatively identical
energetic partitions.

Users should check the files ``fragA.dat`` and ``fragB.dat`` to ensure that
there is not too much charge delocalization from one fragment to another. This
is presented in the "Orbital Check" section in these files |w--w| a value larger than
0.1 docc is an indication that the picture of localizable functional groups may
be breaking down. We also *strongly discourage* the cutting of double,
triple, or aromatic bonding motifs when partitioning the molecule into fragments
|w--w| cuts across only simple sigma bonds are encouraged.

Order-1 Visualization with PyMol
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``fsapt.py`` script above also generates a number of order-1 ``.pdb`` files
that can be used to get a quick qualitative picture of the F-SAPT partition. The
preferred way to do this is to use PyMol to make plots of the molecular geometry
with the atoms colored according to their order-1 F-SAPT contributions. We have
a set of template ``.pymol`` scripts to help with this process. These can be
obtained by running::

    >>> copy_pymol.py

and then in PyMol::

    >>> @run.pymol

This last command runs all of the individual ``.pymol`` files (*e.g.*,
``Elst.pymol``), which in turn load in the molecule and order-1 analysis
(contained in the ``.pdb`` file), set up the visualization, and render a
``.png`` image of the scene. Generally the view orientation and some specific
details of the ``.pymol`` files require some small tweaks to permit
publication-quality renderings.

.. image:: /Total.png
    :align: center
    :scale: 30%
    :alt: Total Order-1 F-SAPT0

Difference F-SAPT Analysis
^^^^^^^^^^^^^^^^^^^^^^^^^^

For those interested in taking the differences between two F-SAPT partitions
(*e.g.*, to see how a substituent modulates a noncovalent interaction), we have
the ``fsapt-diff.py`` script to help with this. This is invoked as::

    >>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir

Where the use has already performed ``fsapt.py`` analysis using the same
functional group names in ``source-fsapt-dir-1`` and ``source-fsapt-dir-2``. The
difference F-SAPT partition entries are computed as :math:`E^{\Delta} = E^{1} -
E^{2}`, and the geometries for order-1 ``.pdb`` visualization files are taken
from system 1.

I-SAPT: A Representative Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. caution:: As of April 2018, you can't specify molecule fragments
   with an unphysical multiplicity like the singlet OH fragments in
   the molecule below, especially as (again in the example below) the
   overall molecule needs to be a singlet, which |PSIfour| doesn't at
   present let be set independently. For situations like this, use the
   temporary input pattern in :srcsample:`isapt1` .

Below, we show an example of using I-SAPT0/jun-cc-pVDZ to analyze the
interaction between the two phenol groups in a 2,4-pentanediol molecule.
This example is
explicitly included in :srcsample:`isapt1`. A video
lecture explaining this example is available
`I-SAPT#1 <https://www.youtube.com/watch?v=fD6mu_tTG_c&index=3&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_,
while an additional video describing how to plot the density and ESP fields from
the I-SAPT embedding procedure is available `I-SAPT#2 <https://www.youtube.com/watch?v=hDbonAOD5dY&index=4&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_::

    memory 1 GB
    
    molecule mol {
    0 1
    O          0.39987        2.94222       -0.26535
    H          0.05893        2.05436       -0.50962
    --
    0 1
    O          0.48122        0.30277       -0.77763
    H          0.26106       -0.50005       -1.28451
    --
    0 1
    C          2.33048       -1.00269        0.03771
    C          1.89725        0.31533       -0.59009
    C          2.28232        1.50669        0.29709
    C          1.82204        2.84608       -0.29432
    C          2.37905        4.02099        0.49639
    H          3.41246       -1.03030        0.19825
    H          2.05362       -1.84372       -0.60709
    H          1.82714       -1.16382        0.99734
    H          2.36243        0.42333       -1.57636
    H          3.36962        1.51414        0.43813
    H          1.81251        1.38060        1.28140
    H          2.14344        2.92967       -1.33843
    H          3.47320        4.02400        0.48819
    H          2.03535        3.99216        1.53635
    H          2.02481        4.96785        0.07455
    symmetry c1
    no_reorient
    no_com
    }
    
    # => Standard Options <= #
    
    set {
    basis jun-cc-pvdz
    scf_type df
    guess sad
    freeze_core true
    fisapt_do_plot true  # For extra analysis
    }
    
    energy('fisapt0')

This is essentially the same input as for F-SAPT, except that the molecular
system is now divided into *three* moieties |w--w| subsystems A and B whose
intramolecular interaction we wish to compute, and a linking unit C.  This file
runs a DF-HF computation on the full system using |PSIfours| existing SCF code.
At the start of the FISAPT code, the occupied orbitals are localized and divided
by charge considerations into A, B, C, and link sets. By default, linking sigma
bonds are assigned to C (this can be changed by the |fisapt__fisapt_link_assignment|
options). Then, non-interacting Hartree--Fock solutions for A and B are optimized
in the embedding field of the linking moiety C. At this point, A and B are not
interacting with each other, but have any potential covalent links or other
interactions with C built in by the embedding.  A standard F-SAPT0 computation
is then performed between A and B, yielding the I-SAPT interaction energy. Any
F-SAPT considerations are also possible when I-SAPT is performed |w--w| F and I are
completely direct-product-separable considerations. 

Cube File Visualization with PyMol
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Setting |fisapt__fisapt_do_plot| ``true`` above generates a set of ``.cube`` files
containing the densities and ESPs of the various subsystems in the I-SAPT
embedding procedure. These can be used to gain a detailed understanding of the
intermolecular partition and the polarization between non-interacting and
Hartree--Fock-interacting moieties. We have developed a set of template
``.pymol`` scripts to help with this process. These can be obtained by running::

    >>> copy_pymol2.py

and then in PyMol::

    >>> @run.pymol

This last command runs all of the individual ``.pymol`` files (*e.g.*,
``DA.pymol``), which in turn load in the molecule and cube file data
(contained in the ``.cube`` file), set up the visualization, and render a
``.png`` image of the scene. Generally the view orientation and some specific
details of the ``.pymol`` files require some small tweaks to permit
publication-quality renderings.

.. image:: /VA.png
    :align: center
    :scale: 50%
    :alt: ESP of monomer A


Adding Point Charges to F/I-SAPT Computations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. Citation: Alenaizan, A; Cheney, D. L.; Sherrill, C. D. Electrostatatically embedded
.. symmetry adapted pertubration theory. In preparation.

Point charges can be added to the interacting subsystems A and B as well
as to the ``linking`` fragment C. Briefly, the interaction between the point charges in A(B)
and fragment B(A) enters the SAPT0 interction energy. It explicitly affects in the electrostatics
and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.
If point charges are present in both subsystems A and B, an additional charge-charge interaction
term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point
charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not
directly contribute to the SAPT0 interaction energy.

Examples :srcsample:`fsapt-ext-abc` and :srcsample:`fsapt-ext-abc2`
illustrate the use of point charges in F/I-SAPT procedure.


F/I-SAPT Keywords
^^^^^^^^^^^^^^^^^

The input files described above cover roughly 90% of all F/I-SAPT analyses. For
more delicate or involved problems, there are a large number of user options
that permit the customization of the I-SAPT subsystem partition, the convergence
of the IBO localization procedure, numerical thresholds, etc. We have an entire
`video tutorial devoted to F/I-SAPT Options <https://www.youtube.com/watch?v=KFkPKSUZVfI&index=5&list=PLg_zUQpVYlA1Tc1X_HgAbqnFcHNydqN7W>`_ .
Direct source-code documentation on these options is available :ref:`here <apdx:fisapt>`.

Additional Notes
^^^^^^^^^^^^^^^^

.. caution:: In constrast to Ed Hohenstein's SAPT0 code, FISAPT uses the -JKFIT
  auxiliary basis sets for all Fock-type terms (*e.g.*, electrostatics, exchange,
  induction, and core Fock matrix elements in exchange-dispersion), and the -RI
  auxiliary basis sets *only* for the dispersion term. Ed's code uses the -RI
  basis sets for all SAPT terms, which can be problematic for heavy elements.
  As such, Ed's SAPT0 code will yield slightly different results than FISAPT. The
  differences should be very minor for up to and including second-row elements,
  after which point one needs to use the |sapt__df_basis_elst| option in Ed's code to
  provide an accurate result. 

====================
External API Objects
====================

.. autoclass:: psi4.driver.qcdb.Molecule

.. autoclass:: qcelemental.datum.Datum

.. autoclass:: qcelemental.models.types.Array

.. autofunction:: qcelemental.molutil.B787

.. autofunction:: qcelemental.molparse.from_arrays

.. autoclass:: qcelemental.ValidationError
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:prog_ways_to_add`:

======================================================
Ways to Add Code: Psi4NumPy, Plugins, Full Integration 
======================================================

Easier and more rapid development
---------------------------------

Fully-featured electronic structure programs are large and complex.  However,
the |PSIfour| ecosystem provides a path for easier and more rapid development
of new features.  The earliest versions of |PSIfour| were written by merging
individual executables that performed specific tasks into a unified C++
executable.  By linking this C++ executable against the Python interpreter, the
individual modules could be called in any sequence, enabling a very diverse
range of tasks to be accomplished within a given input.  Although Python-driven
model allowed for great flexibility from a user's perspective, programming was
still relatively difficult because it required modifications to be made in C++
code.

Since those early days, the code has undergone some important structural
changes that have greatly simplified the development workflow.  These changes
were motivated by the realization that only a few bottlenecks exist in a typical
calculation; by focusing on optimized C++ implementations of these bottlenecks
and making these C++ functions available in Python, most of the code to implement
the overall calculation can be written in simpler Python code.  Python is far
better suited to management tasks such as directory navigation and retrieval,
making it a natural choice for overall calculation layout than C++.  With the
emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any
mathematical technique efficiently in Python, the transitioning of code from
C++ to Python has facilitated a much simpler work flow for prototyping and
developing methods: this is detailed in the next section.

.. _`sec:prog_psi4numpy`:

Rapid initial development using Psi4NumPy
-----------------------------------------

The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended
mechanism for developing and prototyping new methods in Psi4.  Because
`NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear
algebra, Fourier transforms, and general tensor manipulations, a massive number
of methods can be easily implemented very easily using that library.  To
facilitate this workflow, |PSIfour| exports key quantities such as integrals,
densities and molecular orbitals in NumPy format.  From this point, the
programmer can simply call the appropriate |PSIfour| functions to compute the
desired input quantities, retrieve them in NumPy format, and then write the
remaining code using standard Python and/or NumPy syntax.  This approach does
not require any recompilation of code, resulting in a particularly facile
development workflow.  Detailed examples and tutorials are available in the
`Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository.

.. _`sec:prog_plugins`:

Avoiding the need to modify Psi4, using plugins
-----------------------------------------------

In the early days when |PSIfour| was still primarily a C++ code, development
was very cumbersome due to a lengthy build process.  To expedite development, a
plugin system was developed.  This plugin machinery allows developers to access
the classes defined in the innards of |PSIfour|, with only the small plugin
code requiring recompilation during development.  The resulting lightweight
code can be maintained and distributed independently of |PSIfour|, making this
a good strategy for development, especially in cases where tighter integration
of the new code with existing |PSIfour| machinery is required than that
afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`
section.  For details about how to write these plugins, see the
:ref:`sec:plugins` section.

.. _`sec:prog_fullintegration`:

Incorporating code into |PSIfour|
---------------------------------

For features to be incorporated fully into the |PSIfour| ecosystem, changes to
the core routines are inevitable.  However, the programmer should think very
carefully about the most appropriate language for the task in hand.  Let's
consider a new feature that downloads some data from an external source and
then performs some kind of expensive matrix operation on those data.  Because
Python has a rich set of tools for obtaining data from external sources,
writing this tool in the Python layer is a natural choice.  If we know that the
matrix will always be small enough to fit in memory, we can simply rely on the
routines present in NumPy to do the heavy lifting and the code is easy to
implement entirely in the Python layer.  In the case where the matrix operation
is non-standard and requires some specialized code to handle disk-based
storage, the decision to write in Python is less clear cut.  It is certainly
possible to write these out-of-core routines using Numpy primitives, but there
are a number of tools in |PSIfour| already to perform tasks like these that are
required, *e.g.*, for cluster.  In this case, a good design would be to write a
simple piece of code in the C++ layer that performs the matrix operation on a
given input, using the I/O routines available in |PSIfour| and the parallelism
afforded by OpenMP, and to make that code available to the front end as
described in :ref:`sec:prog_tour-exposing`.  The Python layer could then be
responsible for obtaining the input data and calling this C++ code to do the
manipulations, allowing each language layer to handle the subset of the work
that caters to their individual strengths.

A number of concrete examples of this workflow exist in the code already.  For
finite difference computations of energy derivatives, the logic to determine
the type of stencil and which displacements are needed is not going to be rate
limiting for any reasonable quantum mechanical energy function.  Therefore,
doing that work in the Python layer is a good idea, as it allows the many
Python tools for farming out *embarrassingly parallel* workloads to be used,
while the C++ layer can be used to implement the energy function to be
differentiated.

In SCF, we have a number of sources of external embedding potentials that could
enter the calculation.  Allowing Python to handle only the details of driving
the SCF iterations, such as external potentials and convergence acceleration
methods, but deferring to C++ to do the heavy lifting for building and
diagonalizing the Fock matrix also takes advantage of the two languages'
strengths and improves maintainability of the code.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. comment Replace all XXX

.. index:: PEPXXX
.. _`sec:PEPXXX`:

=================================================
PEPXXX: XXX
=================================================

:PEP: XXX
:Title: XXX
:Last-Modified: XX-XXX-201X
:Author: XXX
:Content-Type: text/x-rst
:Created: XX-XXX-201X

.. comment :Version: <version string>
.. comment * BDFL-Delegate: <PEP czar's real name>
.. comment * Discussions-To: <email address>
.. comment   Status: <Draft | Active | Accepted | Deferred | Rejected |
.. comment            Withdrawn | Final | Superseded>
.. comment   Type: <Standards Track | Informational | Process>
.. comment * Requires: <pep numbers>
.. comment * Python-Version: <version number>
.. comment   Post-History: <dates of postings to python-list and python-dev>
.. comment * Replaces: <pep number>
.. comment * Superseded-By: <pep number>
.. comment * Resolution: <url>

XXX

Section
-------

XXX

Comments
--------

04-Jul-2012, LAB

This is an example comment that refers to :ref:`sec:pep1` and a trac ticket :trac:`#221`. 

----

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:customizing`:

=======================================
Customization: Adding Simple Extensions
=======================================

|PSIfour| has been designed to be easily extensible. There are several
customizations accessible to any user, no programming experience or
recompilation required.

* :ref:`sec:basisUserDefined`

.. toctree::
   :maxdepth: 2

   quickaddalias
   quickadddatabase

* https://github.com/dgasmith/psi4numpy

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: single-point, energy()
   triple: setting; keywords; energy()

.. _`sec:energy()`:

Single-Point Energy |w---w| :py:func:`~psi4.energy`
===================================================

* :ref:`Psi4 Native Energy Methods <table:energy_gen>`
* :ref:`Psi4 Native DFT Energy Methods <table:energy_dft>`
* :ref:`MRCC Interfaced Energy Methods <table:energy_mrcc>`
* :ref:`CFOUR Interfaced Energy Methods <table:energy_cfour>`

.. autofunction:: psi4.energy(name [, molecule, return_wfn, restart_file])
   :noindex:

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: DFT
   pair: DFT; theory

.. _`sec:dft`:

DFT: Density Functional Theory
==============================

.. codeauthor:: Robert M. Parrish, Justin M. Turney, and Daniel G. A. Smith
.. sectionauthor:: Robert M. Parrish

*Module:* :ref:`Keywords <apdx:scfdft>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBFUNCTIONAL <psi4/src/psi4/libfunctional>`, :source:`LIBFOCK <psi4/src/psi4/libfock>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`

Both density functional theory and Hartree--Fock theory are controlled
through the SCF module, and the :ref:`SCF Introduction <sec:scfintro>`
section is also relevant here.

.. note:: Starting version 1.5, the |scf__wcombine| option is temporarily disabled.

.. note:: Starting version 1.4 (tag v1.4a1 in the development repository), |PSIfour| uses an updated and extended (to 104 elements) set
          of Bragg-Slater radii. This leads to minimal deviations in absolute energies (1E-06 au) and
          relative energies (below 0.002 kcal/mol for S22), depending also on the applied grid, compared
          to older versions. We advise not to mix absolute energies absolute energies from before and after this change for the
          calculation of relative energies.

.. note:: After May 2017 (anytime after the v1.1 release), |PSIfour|
   switched from hand- (+Matlab) coded functionals to Libxc. Thus
   many DFT results will be slightly different. Functionals more than
   slightly different are B97-D, wB97X (note, *not* wB97X-D), SOGGA,
   DFDL, and M05.

Theory
~~~~~~

Generalized Kohn--Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133]_ [Parr:1989]_ is one of the primary
workhorses of modern computational chemistry due to its phenomenal accuracy/cost
ratio.

Pure Kohn--Sham DFT is built on the Hohenberg--Kohn theorems [Hohenberg:1964:136]_ which states: A) the energy is a universal
functional of the one-particle electronic density and B) there exists a set of
noninteracting quasiparticles with the same density as the true set of
electrons, with the quasiparticle states determined as eigenvectors of an
effective one-body potential encapsulating the true :math:`N`\ -body quantum
effects. The former idea allows the electronic density to be dealt with instead
of the much more complicated wavefunction, while the latter allows for the
treatment of the troublesome kinetic energy term via the implicit one-body
Kohn--Sham orbitals.  KS-DFT borrows much of the machinery of Hartree--Fock, as is
evident by looking at the energy expression,

.. math::

    E_{\mathrm{KS}}
    &= \sum_{i} \langle i | \hat h | i \rangle
    + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\
    &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +
    V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}
    D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]

Here, :math:`T` is the noninteracting quasiparticle kinetic energy operator,
:math:`V` is the nucleus-electron attraction potential, :math:`D^{\mathrm{T}}`
is the total electron density matrix, and :math:`E_{\mathrm{xc}} [\rho_\alpha,
\rho_\beta]` is the (potentially nonlocal) exchange, correlation, and residual
kinetic energy functional. The residual kinetic energy term is usually quite
small, and is often ignored, hence :math:`E_{\mathrm{xc}}` is often referred to
as simply the exchange-correlation functional (exchange *and* correlation, not
just exchange-type correlation).

In practice, the first few generations of KS-DFT functionals were chosen to be
local, meaning that the form of the exchange correlation energy is an integral
over all of space of a function depending only on local information in the
density, such as the density value or derivatives. The simplest variants are
Local Spin-Density Approximations (LSDA), which depend only on the spin density
:math:`\rho_\alpha` or :math:`\rho_\beta`\ ,

.. math:: \rho_\sigma (\vec r_1) = D_{\mu\nu}^{\sigma} \phi_{\mu} (\vec r_1)
    \phi_\nu (\vec r_1)

The most popular variants are Generalized Gradient Approximation (GGA)
functionals which use the norm of the density gradient
:math:`\gamma_{\alpha\alpha}`, :math:`\gamma_{\alpha\beta}` or
:math:`\gamma_{\beta\beta}`  to build an inhomogeneity
parameter.

.. math:: \gamma_{\alpha\alpha} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla
    \rho_{\alpha} (\vec r_1)

.. math:: \gamma_{\alpha\beta} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla
    \rho_{\beta} (\vec r_1)

where,

.. math:: \nabla \rho_{\sigma} (\vec r_1) = 2 D_{\mu\nu}^{\sigma} \phi_{\mu}
    (\vec r_1) \nabla \phi_{\nu} (\vec r_1)

GGA functionals are essentially the same cost as LSDA functionals and are often
considerably more accurate.

Another local variant  which has gained some popularity (though perhaps not as
much as GGA functionals) is the meta approximation, in which information about
the second derivative of the density is incorporated. The most canonical variant
of these functionals rely on the spin kinetic energy density :math:`\tau_\alpha`
and :math:`\tau_\beta`,

.. math:: \tau_\sigma(\vec r_1)  = \sum_{i} \left | \nabla \psi_i^{\sigma} (\vec r_1) \right | ^2
    = \sum_{i} \left | C_{\mu i}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \right |
    ^2 = D_{\mu\nu}^{\sigma} \nabla \phi_{\mu} (\vec r_1) \cdot \nabla
    \phi_{\nu} (\vec r_1)

A generic local meta-GGA functional may then be written as,

.. math:: E_{\mathrm{xc}}^{\mathrm{DFA}} = \int_{\mathbb{R}^3} f_{\mathrm{xc}}
    \left(
    \rho_{\alpha} (\vec r_1),
    \rho_{\beta} (\vec r_1),
    \gamma_{\alpha\alpha} (\vec r_1),
    \gamma_{\alpha\beta} (\vec r_1),
    \gamma_{\beta\beta} (\vec r_1),
    \tau_{\alpha} (\vec r_1),
    \tau_{\beta} (\vec r_1)
    \right) \ \mathrm{d} ^3 r_1

The potential corresponding to this energy functional is,

.. math:: V_{\mu\nu}^{\mathrm{xc},\alpha} =

    \int_{\mathbb{R}^3}
    \left(\frac{\partial f}{\rho_\alpha}\right)
    \phi_{\mu}
    \phi_{\nu}
    \ \mathrm{d} ^3 r_1

.. math:: +
    \int_{\mathbb{R}^3}
    \left(2 \frac{\partial f}{\gamma_{\alpha\alpha}} \nabla \rho_\alpha + \frac{\partial
    f}{\gamma_{\alpha\beta}}\nabla \rho_\beta \right)
    \nabla\left(\phi_{\mu}
    \phi_{\nu}\right)
    \ \mathrm{d} ^3 r_1

.. math:: +
    \int_{\mathbb{R}^3}
    \left(\frac{\partial f}{\tau_\alpha}\right)
    \nabla \phi_{\mu}
    \nabla \phi_{\nu}
    \ \mathrm{d} ^3 r_1

This potential is used to build the Kohn--Sham matrix,

.. math:: F_{\mu\mu}^{\alpha} = H_{\mu\nu} + J_{\mu\nu} +
    V_{\mu\nu}^{\mathrm{xc},\alpha}

which is diagonalized to form the Kohn--Sham orbitals in the same manner as in
Hartree--Fock.

In practice the local functional kernel :math:`f_{\mathrm{xc}}` and its required
partial derivatives are exceedingly complex and are not analytically
integrable. In this case, atom-centered numerical quadratures are used to
evaluate the Kohn--Sham potentials and energies to a high degree of accuracy. The
evaluation of these numerical integrals can be made to be linear scaling with a
reasonable amount of cleverness (mostly related to the fact that the basis
functions decay exponentially), meaning that the Coulomb and diagonalization
steps become rate limiting. This enormous potential speed gain over Hartree--Fock
with potentially exact treatment of electron correlation for "free" was one of
the primary motivations for KS-DFT's adoption by chemists in the late 1980s and
early 1990s.

Unfortunately, local KS-DFT exhibits several spectacular failures, most of which
stem from the exponential decay of the local Kohn--Sham potential, which cannot
encapsulate long-range information in the exchange and correlation holes. In the
exchange hole, this manifests as the problem of Many-Electron Self-Interaction
Error (MSIE), which presents as spurious low-lying charge transfer states in
excited-state calculations, eventual metallic breakdown in extended insulators,
poor thermochemistry, and complete lack of a derivative discontinuity in the
chemical potential as integer particle numbers are crossed. On the correlation
side, this is primarily observed in the inability of KS-DFT to treat dispersion
interactions.

Generalized Kohn--Sham (GKS) functionals incorporate long-range information into
the functional through orbital-dependent contributions, and are designed to
combat the failures of local KS-DFT, particularly the MSIE on the exchange side.
Note that these functionals are often referred to as "implicit" density
functionals, as the orbitals are themselves functionals of the Kohn--Sham
potential.

The simplest form of an exchange-side GKS is the global hybrid ansatz, in which
some fraction of the exact Hartree--Fock exchange of the noninteracting
quasiparticles is added to the functional, with the local part of the exchange
functional decreased by the corresponding amount. Note that the term
"exact-exchange" refers to the Hartree--Fock being the exact exchange energy of
the noninteracting quasiparticles, not the true electrons. Therefore, adding
100% exact exchange is not physically reasonable, and will often lead to
extremely poor results. The fraction of exact-exchange, denoted :math:`\alpha`,
is often determined by adiabatic or heuristic arguments and is typically around
25%. The addition of exact exchange borrows another piece from an existing
Hartree--Fock code, with the caveat that Hartree--Fock exchange is often much more
costly to obtain than the Coulomb matrix. The global hybrid ansatz has become
exceedingly popular, with functionals such as the ubiquitous B3LYP often
producing absurdly accurate results.

A more advanced GKS functional technology which has developed enormous
popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC
recognizes that the local DFA is potentially exact at short range in the
exchange hole, and that the hybrid-exchange energy of the noninteracting
quasiparticles is also exact for true electrons at long range in the exchange
hole. Therefore LRC switches from DFA at short range to hybrid exchange at long
range, typically using the function :math:`\mathrm{erf}(\omega r_{12})` as a
partition function.

Tying all these pieces together, a full LRC-hybrid GKS functional has the
generic form,

.. math::
    E_{\mathrm{xc}} = (1-\alpha) \int_{\mathrm{R}^3}
    f_{\mathrm{xc}}
    \left(
    \rho_{\alpha} (\vec r_1),
    \rho_{\beta} (\vec r_1),
    \gamma_{\alpha\alpha} (\vec r_1),
    \gamma_{\alpha\beta} (\vec r_1),
    \gamma_{\beta\beta} (\vec r_1),
    \tau_{\alpha} (\vec r_1),
    \tau_{\beta} (\vec r_1)
    ; \omega \right) \ \mathrm{d} ^3 r_1

.. math::
    -\frac{1}{2} \sum_{i,j}
    \delta_{\sigma_{i} \sigma_{j}} \alpha \iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1
    \frac{1}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2

.. math::
    -\frac{1}{2} \sum_{i,j}
    \delta_{\sigma_{i} \sigma_{j}} (1-\alpha)\iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1
    \frac{\mathrm{erf}(\omega r_{12})}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2

For LRC functionals, the choice of range-separation parameter :math:`\omega` has
been the subject of considerable activity since the inception of LRC
functionals. Some authors advocate a static range-separation parameter
determined by optimization over a test set of chemical systems. However, a more
physically-motivated and often more accurate approach is the idea of "gap
fitting" or "optimal tuning" or simply "tuning." The most popular tuned-LRC
approach is IP-fitting, in which the :math:`\omega` is varied until the
Koopman's IP (the opposite of the HOMO energy) matches the true IP (the
difference between :math:`N-1`\ -electron and :math:`N`\ -electron total
energies), within the LRC functional ansatz. This guarantees the asymptotics of
the exchange potential,

.. math:: \lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -
    \frac{1}{r} + I_{\mathrm{IP}} +
    \epsilon_{\mathrm{HOMO}}

Note that LRC functionals with default :math:`\omega` only capture the
:math:`-1/r` dependence,

.. math:: \lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -
    \frac{1}{r},

hybrid functionals only capture part of the :math:`-1/r` dependence,

.. math:: \lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -
    \frac{\alpha}{r},

and local functionals decay exponentially, resulting in completely incorrect
asymptotics,

.. math:: \lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0

IP-tuned LRC functionals effectively pin the chemical potential at :math:`N`
electrons to the correct value determined by the ionization potential. This
often cleans up the MSIE problem for a surprisingly large number of high-lying
occupied orbitals, as determined by fractional particle curves. Other gap
fitting techniques involving the electron affinity or band gap are sometimes
also used. IP-fitting is found to be particularly critical for the qualitative
determination of excited state ordering in many low band-gap systems.

For dispersion-bound complexes, a very simple additive empirical dispersion
potential, based on a damped Lennard-Jones potential can often produce
remarkably accurate results with KS-DFT. This approach was championed by Grimme,
whose "-D2" and more modern "-D3" approaches are a de facto industry standards.

Minimal Input
~~~~~~~~~~~~~

Minimal input for a KS-DFT computation is a molecule block, basis set
option, and a call to ``energy('b3lyp')`` (or other valid functional name)::

    molecule {
    He
    }

    set basis sto-3g

    energy('b3lyp')

This will run a B3LYP Restricted Kohn--Sham (RKS) on neutral singlet Helium in
:math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6 energy
and density convergence criteria, a DF ERI algorithm, symmetric
orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on
any of these options, see the relevant section below, or in the preceding
:ref:`Hartree--Fock section <sec:scf>`.

Spin/Symmetry Treatment
~~~~~~~~~~~~~~~~~~~~~~~

|PSIfour| implements the most popular spin specializations of KS-DFT, including:

Restricted Kohn--Sham (RKS) [Default]
  Appropriate only for closed-shell singlet systems, but twice as efficient
  as the other flavors, as the alpha and beta densities are constrained to be
  identical.
Unrestricted Kohn--Sham (UKS)
  Appropriate for most open-shell systems and fairly easy to converge.
  The spatial parts of the alpha and beta orbitals are fully independent of each
  other, which allows a considerable amount of flexibility in the wavefunction.
  However, this flexibility comes at the cost of spin symmetry; the resultant
  wavefunction may not be an eigenfunction of the :math:`\hat S^2` operator.
  However, spin contamination is usually less of a problem with UKS than with
  UHF, as the spin contamination of the noninteracting quasiparticles (the
  :math:`S^2` metric printed in the output) is usually a severe overestimation
  of the spin contamination of the true electrons.

These are set in the |scf__reference| option.

Note that there are not equivalents to ROHF or CUHF, *e.g.*, no ROKS or CUKS. This
is because ROHF is implicitly assumed to be followed by a correlated method
which can break the positive definiteness of the spin polarization. KS-DFT with
the true functional is expected to be the final step, thus restricting the
solution to positive definite spin polarization is  not physical. See the
section in [Szabo:1982]_ on methyl radical for an example.

Functional Selection
~~~~~~~~~~~~~~~~~~~~

|PSIfour| features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D
functionals. These can be specified by a variety of means. Perhaps the simplest
is to use the functional name as the energy procedure call::

    energy('b3lyp')

Note that if you are running an unrestricted computation, you should set the
|scf__reference| option before the call to ``energy``::

    set reference uks
    energy('b3lyp')

The functional may also be manually specified by calling ``energy`` (or any driver function)
with a ``dft_functional`` argument::

    energy('scf', dft_functional = 'b3lyp')

Another alternative is providing a specially crafted `dict`-ionary to the ``dft_functional``
argument::

    custom_functional = { "name": "my_unique_name", ... }
    energy('scf', dft_functional = custom_functional)

For further details about this so called `dict_func` syntax, see
:ref:`sec:dftdictbuilder`.

For hybrid functionals, the fraction of exact exchange is controlled by the
|scf__dft_alpha| option. For the LRC functionals, the fraction of long-range
Hartree--Fock and short-range DFA is controlled by the |scf__dft_omega| option.
Changing these will override the default behavior of the requested functional.

A brief summary of some of the more notable functionals in |PSIfour|, and links
to the complete listing of all functionals of each class are presented below:

:ref:`All Functionals <table:dft_all>`
    All functionals, including LSDA-only functionals. Note that here and
    throughout, functionals which end in `_X` or `_C` are exchange or
    correlation only, and should not be used for most production-level
    computations. Examples include `PBE_X` and `PBE_C`, which contain the
    separate definitions of the PBE exchange and correlation holes. In most cases,
    the united `PBE` functional should be used instead.

:ref:`GGA Functionals <table:dft_gga>`
    Many common GGA functionals. BLYP and PBE are probably among the best pure
    GGAs. Please do not use FT97 at the moment, as there
    are problems with the stability of the correlation hole. Don't worry, it
    will definitely NaN on you if you try to use it.

:ref:`Meta Functionals <table:dft_meta>`
    We have recently implemented the M05 classes of meta functionals in
    |PSIfour|. Note that these functionals are not appropriate for modeling
    dispersion interactions, as they lack dispersion physics. A -D functional (Such
    as the much cheaper B97-D) should be used instead.

:ref:`Hybrid Functionals <table:dft_hybrid>`
    Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the
    B97 series are also quite good for many thermochemical problems.

:ref:`LRC Functionals <table:dft_lrc>`
    LRC functionals are a particular area of interest of the |PSIfour| DFT team.
    LRC functionals are all denoted by a lower-case "w" in front of the standard DFA
    functional, such as wPBE.  We offer a stable implementation of the Gill
    association function for wS and Head-Gordon's wB97/wB97X functionals.
    Additionally, we are pleased to have recently completed a heavily conditioned
    implementation of the HJS exchange-hole model, which provides an analytical form
    for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a
    physics perspective, this implementation of wPBE is extremely useful for
    theoretical investigations, as it is parameter free, and properly integrated
    against the partition function in the exchange hole. We would like to thank Dr.
    Scuseria for providing helpful advice and a reference implementations of the
    older HSE exchange-hole model which led to the successful implementation of the
    HJS model.

:ref:`Double-Hybrid Functionals <table:dft_dhybrid>`
    Double hybrids are percolating into |PSIfour|. Note that these are
    only available with density-fitted, not conventional, MP2 algorithms.

:ref:`-D Functionals <table:dft_disp>`
    We have several -D2 functionals implemented. -D3 functionls are available
    with the installation of Grimme's :ref:`DFTD3 program <sec:dftd3>`.
    For now, the pure-GGA B97-D
    functional of Grimme is remarkably accurate, and the hybrid B3LYP-D
    functional is also quite reliable.

Note: we have made a sincere effort to rigorously test all functionals
implemented in |PSIfour| for correctness. If you find an error in a DFT
functional or have a request for a new functional, please let us know on our
forum or GitHub page.

Grid Selection
~~~~~~~~~~~~~~

|PSIfour| uses the standard Lebedev-Laikov spherical quadratures in concert with a
number of radial quadratures and atomic partitioning schemes. 
The default grid in |PSIfour| is a Lebedev-Treutler (75,302) grid with a Treutler
partition of the atomic weights.

Spherical grids are all of the extremely efficient Lebedev-Laikov type.
Spherical grid resolution is controlled by the |scf__dft_spherical_points|
option, which may take one of the following values:

.. _`table:lebedevorder`:

    +-----------------------------+-------+
    | |scf__dft_spherical_points| | Order |
    +=============================+=======+
    | 6                           | 3     |
    +-----------------------------+-------+
    | 14                          | 5     |
    +-----------------------------+-------+
    | 26                          | 7     |
    +-----------------------------+-------+
    | 38                          | 9     |
    +-----------------------------+-------+
    | 50                          | 11    |
    +-----------------------------+-------+
    | 74                          | 13    |
    +-----------------------------+-------+
    | 86                          | 15    |
    +-----------------------------+-------+
    | 110                         | 17    |
    +-----------------------------+-------+
    | 146                         | 19    |
    +-----------------------------+-------+
    | 170                         | 21    |
    +-----------------------------+-------+
    | 194                         | 23    |
    +-----------------------------+-------+
    | 230                         | 25    |
    +-----------------------------+-------+
    | 266                         | 27    |
    +-----------------------------+-------+
    | 302                         | 29    |
    +-----------------------------+-------+
    | 350                         | 31    |
    +-----------------------------+-------+
    | 434                         | 35    |
    +-----------------------------+-------+
    | 590                         | 41    |
    +-----------------------------+-------+
    | 770                         | 47    |
    +-----------------------------+-------+
    | 974                         | 53    |
    +-----------------------------+-------+
    | 1202                        | 59    |
    +-----------------------------+-------+
    | 1454                        | 65    |
    +-----------------------------+-------+
    | 1730                        | 71    |
    +-----------------------------+-------+
    | 2030                        | 77    |
    +-----------------------------+-------+
    | 2354                        | 83    |
    +-----------------------------+-------+
    | 2702                        | 89    |
    +-----------------------------+-------+
    | 3074                        | 95    |
    +-----------------------------+-------+
    | 3470                        | 101   |
    +-----------------------------+-------+
    | 3890                        | 107   |
    +-----------------------------+-------+
    | 4334                        | 113   |
    +-----------------------------+-------+
    | 4802                        | 119   |
    +-----------------------------+-------+
    | 5294                        | 125   |
    +-----------------------------+-------+
    | 5810                        | 131   |
    +-----------------------------+-------+

The spherical grids are rotated according to a common set of rules developed
during the implementation of SG1. At the moment, the rules for tetrahedral,
octohedral, and icosohedral systems are not complete, so there may be some
ambiguity in the grid orientation for these systems.

Radial grid types are controlled by the |scf__dft_radial_scheme| option, which
at the moment may be either ``TREUTLER`` or ``BECKE``, while the number of radial
points are controlled by the |scf__dft_radial_points| option, which is any positive
integer (typically 50-100). The radial grids are "centered" on the Bragg-Slater
radius of each atom, as described in Becke's 1988 paper. If inaccurate
integration is suspected in systems with anions or very diffuse basis functions,
the |scf__dft_bs_radius_alpha| option may be increased from 1.0 to a larger value to force the radial grid to span a larger extent in space.

The atomic weighting scheme is controlled by the |scf__dft_nuclear_scheme|
option, which may be one of ``TREUTLER``, ``BECKE``, ``STRATMANN``, ``NAIVE``,
or ``SBECKE``. The last is a smoother variant of the BECKE scheme recently introduced 
by Laqua [Laqua:2018:204111]_ that should behave better for weak interactions.

Pruning of the quadrature grid is controlled by the |scf__dft_pruning_scheme|
option. The options ``ROBUST`` and ``TREUTLER`` divide the grid into spherical regions
based on the Bragg-Slater radius of each atom and apply different orders to them.
The ``ROBUST`` scheme is a less aggressive variant of the ``TREUTLER`` approach and
suitable for benchmark-level quality (MAD < 0.002 kcal/mol for the S22 with PBE/aug-cc-pVTZ
for pruned versus unpruned grid). Our implementation of the ``TREUTLER`` scheme shows an 
error of 0.02 kcal/mol for the same benchmark. Both also reduce the grid order by 1 for H 
and He atoms and avoid any pruning of heavy atoms (Z >= 36) Other schemes mentioned in 
the keyword documentation (e.g. P_SLATER) are experimental and should be considered expert-only.

Once the molecular quadrature grid is built, the points are partitioned into
blocks of points which are spatially close to each other. We use an octree
algorithm for this procedure, which produces a good balance between spatial
compactness of each block (which helps achieve linear scaling due to the
exponential decay of the basis functions), and retaining a large number of
points in each block (which helps keep the FLOP rate up by allowing for a
reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials
in each block). For each block, a united set of significant basis functions is
determined by the cutoff radius of each shell of basis functions. The size of
this cutoff radius (and thereby the accuracy of the density/potential
evaluation) can be varied by setting the |scf__dft_basis_tolerance|, which
defaults to 1E-12. We are still exploring optimizations of the octree algorithm
and the basis cutoffs, but it is likely that significant speed gains may be
realized by relaxing the basis cutoff tolerance, with negligible decrease in
accuracy.

Small density values can introduce numerical instabilities with some functionals that
can result in trailing SCF convergence issues or even numerical failures (NaNs).
If the default settings of the LibXC library are insufficient, a custom value can be 
request by setting |scf__dft_density_tolerance|. For notorious cases a value of 1E-10
is sensible.

An example of a fully specified grid is as follows::

    molecule {
    H
    H 1 0.7
    }

    set {
    basis cc-pvdz
    scf_type df
    dft_spherical_points 590      # Often needed
    dft_radial_points 99          # Often needed
    dft_radial_scheme treutler    # Rarely needed
    dft_nuclear_scheme treutler   # Rarely needed
    dft_density_tolerance 1.0E-10 # Rarely needed
    dft_basis_tolerance 1.0E-11   # Can speed things up, but benchmark the error
    dft_pruning_scheme robust     # Generally safe and will speed things up
    }

    energy('b3lyp')

ERI Algorithms
~~~~~~~~~~~~~~

The ERI algorithms for the Coulomb and hybrid exchange are identical to
:ref:`those for Hartree--Fock <sec:scferi>`. However, for LRC functionals, the long-range
exchange contributions to the Kohn--Sham matrix have only been implemented in the
DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the
errors incurred by the density fitting approximation (in a proper -JKFIT
auxiliary basis) are orders of magnitude smaller than the accuracy of any known
functional.

IP Fitting
~~~~~~~~~~

In collaboration with the Bredas group, we have developed an automatic procedure
for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To
perform IP fitting, one simply calls the :py:func:`~psi4.ip_fitting` Python macro, after
setting up a standard LRC UKS computation. A representative example is::

    memory 512 MB

    molecule h2o {
    0 1  # must be neutral
    O
    H 1 1.0
    H 1 1.0 2 104.5
    # IP fitting runs in C1 symmetry
    }

    set {
    reference uks  # UKS, as we need to do neutral/cation
    basis cc-pvdz
    scf_type df
    }

    # Optional arguments are minimum omega, maximum omega, molecule object
    omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o)

This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A
number of neutral and cation single-point computations are run at various values
of :math:`\omega`, though the later iterations are much faster due to reuse of
the DF tensors, and starting from the neutral/cation orbitals of the previous
:math:`\omega`. The procedure can also be assisted by providing a tighter guess
for the bounds of :math:`\omega`. This small test case has a tuned
:math:`\omega` of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,
particularly conjugated systems, will typically have an optimized :math:`\omega`
between 0.1 and 0.5.

Fractional Particle Curves
~~~~~~~~~~~~~~~~~~~~~~~~~~

The behavior of the electronic energy and HOMO energy across fractional numbers
of electrons is extremely useful for elucidating the MSIE behavior of various
functional technologies. |PSIfour| features an efficient fractional-particle DFT
code, written into the UKS spin specialization. Due to a combination of DIIS and
reuse of integrals/guess orbitals across a range of fractional occupations, this
code is able to perform fractional occupation curves for systems with up to 60
atoms, across a wide range of the particle number :math:`N`.

Two python macros exist for this code. The first is :py:func:`~psi4.frac_traverse`, which is
used to investigate the fractional occupation behavior within one electron above
and below the neutral. An example is::

    molecule h2o {
    0 1  # must be neutral
    O
    H 1 1.0
    H 1 1.0 2 104.5
    # FRAC jobs will be be run in C1 symmetry
    }

    set {
    reference uks  # UKS, as we need to do all kinds of weird stuff
    basis aug-cc-pvdz  # Augmented functions are very important on the anion side
    scf_type df
    }

    # Argument is functional.
    # Many optional arguments are available, see the python file
    frac_traverse('wb97', molecule=h2o)

The other macro is :py:func:`~psi4.frac_nuke`, which strips several electrons out of the
system to gather information on the MSIE over a range of orbitals. The input is
identical to the above, except that the :py:func:`~psi4.frac_traverse` call is substituted
for something like::

    # Argument is the functional.
    # A useful optional argument is nmax, the total number of electrons to
    # strip out of the molecule, in this case, 2.
    # Many optional arguments are available, see the python file
    frac.frac_nuke('wb97', molecule=h2o, nmax = 2)

Dispersion Corrections
~~~~~~~~~~~~~~~~~~~~~~

:ref:`DFT-D dispersion corrections are discussed here. <sec:dftd3>`

:ref:`HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here. <sec:gcp>`

:ref:`DFT-NL dispersion corrections are discussed here. <sec:dftnl>`

Recommendations
~~~~~~~~~~~~~~~

The KS-DFT code is quite new, but relatively complete. During code development,
emphasis was placed on flexibility of functional technology, efficiency for
medium to large systems in difficult electronic environments (*e.g.*, compact
spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS
functionals), and time to code completion. We are very interested in optimizing
and extending the code, so expect performance gains and extensions to
gradients/hessians and TDDFT in future releases.

Some rough guidelines for using the KS-DFT code are as follows,

* Use DF for the ERI algorithm wherever possible.
* |PSIfour| is a "tight" code, meaning we've set the default numerical cutoffs
  for integrals, grids, and convergence criteria in such a way that you will often
  get many more digits of precision than needed. You may be able to realize
  additional speed gains by loosening some of these thresholds. See
  :ref:`SCF Convergence <table:conv_scf>` for default convergence criteria.
* Read the literature to determine which functional technology to use. The world
  contains far too many papers using B3LYP on noncovalent interactions without a -D.

The "best-practice" input file for KS-DFT is::

    memory 1 GB  # As much as you've got, the DF algorithm can use

    molecule {
    H
    H 1 0.7
    }

    set {
    basis cc-pvdz
    scf_type df
    guess sad
    }

    energy('b3lyp')


.. _`sec:dftdictbuilder`:

Advanced Functional Use and Manipulation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

New DFT functionals can be created from scratch from within the input
file and accessed using the ``dft_functional`` keyword argument in the
energy call::

    # DFT Custom Functional

    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 104.5
    }

    set {
    basis sto-3g
    dft_spherical_points 302
    dft_radial_points 99
    reference rks
    }

    pbe0 = {
        "name": "my_PBE0",
        "x_functionals": {"GGA_X_PBE": {"alpha": 0.75}},
        "x_hf": {"alpha": 0.25},
        "c_functionals": {"GGA_C_PBE": {}}
    }

    func_call = energy('SCF', dft_functional=pbe0)

    # as PBE0 is a pre-defined functional, the call above is equivalent to both below:
    func_call = energy('SCF', dft_functional="PBE0")
    func_call = energy('PBE0')

Supported keywords include:

 - `name`: string, name of the functional. for custom defined functionals used for printing only.
 - `xc_functionals`: dict, definition of a complete (X + C) functional based in LibXC name
 - `x_functionals`: dict, definition of exchange functionals using LibXC names
 - `c_functionals`: dict, definition of correlation functionals using LibXC names
 - `x_hf`: dict, parameters dealing with exact (HF) exchange settings for hybrid DFT
 - `c_mp2`: dict, parameters dealing with MP2 correlation for double hybrid DFT
 - `dispersion`: dict, definition of dispersion corrections
 - `citation`: string, citation for the method, for printing purposes
 - `description`: string, description of the method, for printing purposes

The full interface is defined in
:source:`psi4/driver/procrouting/dft/dft_builder.py`. All
standard functionals provided in |PSIfour| are implemented in the
``*_functionals.py`` files in the same folder.

.. literalinclude:: @SFNX_INCLUDE@psi4/driver/procrouting/dft/dft_builder.py
   :lines: 29-77
   :language: none

One can also use the ``dft_functional`` keyword argument to use the
orbitals generated by DFT for correlated wavefunction methods::

    # MP2 with a PBE0 reference computation

    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 104.5
    }

    set {
    basis 6-31G
    dft_spherical_points 302
    dft_radial_points 99
    reference rks
    }

    mp2_dft = energy("MP2", dft_functional="PBE0")


Note that this would only update the generic Psi variables (e.g., "CURRENT ENERGY") and not the MP2 or DFT variables.
Psi4 also supports easy customization and manipulation of DFT functionals.  The values of `\alpha` and `\omega` can be adjusted with the |scf__dft_alpha|
and |scf__dft_omega| keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing |scf__dft_omega|::

    molecule ch2 {
      0 3
      C
      H 1 R
      H 1 R 2 A

      R = 1.075
      A = 133.93
    }

    set reference uhf
    set guess gwh
    set basis cc-pvdz
    set e_convergence 8

    # Override the default value of omega
    set dft_omega 2.0

    E = energy('wb97x')

    # Revoke the change for later computations if needed
    revoke_global_option_changed('DFT_OMEGA')

This feature would be useful after finishing the IP fitting procedure, for example.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: adcc, ADC

.. _`sec:adcc`:

Interface to adcc by M. F. Herbst and M. Scheurer
=================================================

.. codeauthor:: Michael F. Herbst
.. sectionauthor:: Michael F. Herbst

*Module:* :ref:`Keywords <apdx:adc>`, :ref:`PSI Variables <apdx:adc_psivar>`

.. image:: https://img.shields.io/badge/home-adcc-informational.svg
   :target: https://code.adc-connect.org

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://adc-connect.org/latest

|PSIfour| contains code to interface to the adcc python module developed
by M. F. Herbst *et. al.*. No additional licence or configuration
is required to use adcc. The module serves as the backend for
most algebraic-diagrammatic construction methods for correlated
excited states in |PSIfour|. For more details on ADC methods,
see :ref:`sec:adc`.

Installation
~~~~~~~~~~~~

For up to date information and more details,
see the `adcc installation documentation <https://adc-connect.org/latest/installation.html>`_.

**Binary**

* .. image:: https://anaconda.org/adcc/adcc/badges/version.svg
     :target: https://anaconda.org/adcc/adcc

* .. image:: https://img.shields.io/pypi/v/adcc
     :target: https://pypi.org/project/adcc

* adcc is available as a conda package for Linux and macOS
  and on pypi.

.. * If using the |PSIfour| binary, adcc has already been installed alongside.
..
.. * If using |PSIfour| built from source, and anaconda or miniconda has
..   already been installed (instructions at :ref:`sec:quickconda`),
..   adcc can be obtained through ``conda install adcc -c adcc``.
..   Then enable it as a feature with :makevar:`ENABLE_adcc`
..   and rebuild |PSIfour| to detect adcc and activate dependent code.
..
.. * Previous bullet had details. To build |PSIfour| from source and use
..   adcc from conda without thinking, consult :ref:`sec:condapsi4dev`.

* To remove a conda installation, ``conda remove adcc``.

**Source**

* .. image:: https://img.shields.io/github/tag-date/adc-connect/adcc.svg?maxAge=2592000
     :target: https://github.com/adc-connect/adcc

* If using |PSIfour| built from source and you want adcc installed as well,
  enable it as a feature with :makevar:`ENABLE_adcc`,
  and let the build system fetch and install it.


Keywords for adcc
~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/adc__cutoff_amps_print.rst
.. include:: autodir_options_c/adc__kind.rst
.. include:: autodir_options_c/adc__max_num_vecs.rst
.. include:: autodir_options_c/adc__maxiter.rst
.. include:: autodir_options_c/adc__num_core_orbitals.rst
.. include:: autodir_options_c/adc__num_guesses.rst
.. include:: autodir_options_c/adc__r_convergence.rst
.. include:: autodir_options_c/adc__reference.rst
.. include:: autodir_options_c/adc__roots_per_irrep.rst


.. _`cmake:adcc`:

How to configure adcc for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, adcc provides additional quantum-chemical methods
  (a wide range of ADC methods). In turn adcc can use |PSIfour| as the backend for
  self-consistent field calculations and required integrals.

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) adcc

* Upstream Dependencies |w---w| adcc (\ |dr| optional) |PSIfour|

**CMake Variables**

* :makevar:`ENABLE_adcc` |w---w| CMake variable toggling whether Psi4 automatically installs adcc

**Examples**

A. Build and install adcc if needed

  .. code-block:: bash

    >>> cmake -DENABLE_adcc=ON

B. Build *without* adcc

  .. code-block:: bash

    >>> cmake

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_debug_and_profile`:

=======================
Debugging and Profiling
=======================

Debugging
---------

Instructions on running Psi4 with a debugger.

Profiling
---------

Instructions on using Psi4 with a profiler, or/and discuss how timers work
in Psi4... they are hierarchical.... I think we have special timers for
parallel blocks.


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:plugins`:

Creating New Plugins
====================

Modular Approach to Development
-------------------------------

It is slightly cumbersome to the development cycle to recompile |PSIfour|
every time a change is made to the C++ code.
It's also daunting to new developers if they're required to
learn the structure of the source tree, executable initialization code,
and makefile systems in the existing code in order to add new features,
which was never a problem with Psi3 due to the independent
nature of the modules. To overcome these problems, |PSIfour| now has a
useful plugin feature. This allows codes to be developed as standalone
entities, which are compiled independently of the Psi source, but can
still link against Psi's vast library. The plugins can be loaded at
run-time from any location.

.. _`sec:newplugins`:

Creating a New Plugin
---------------------

|PSIfour| can create basic plugins for you and automatically tailor them
to your compilation environment. To create a basic plugin, run the
following while replacing ``myplugin`` with the name of your great code.
If the name you provide is not valid, |PSIfour| will complain.

   >>> psi4 --plugin-name myplugin

|PSIfour| will create a new directory with the name you specify for the
plugin. In this example, a directory named myplugin will be created.
All you need to do is ``cd`` into the directory, use |PSIfour| to generate
a Makefile, and type make. Then execute ``psi4`` in the directory on the
default input file.

.. code-block:: bash

   >>> cd myplugin
   >>> `psi4 --plugin-compile`
   >>> make
   >>> psi4

|PSIfour| comes with a few templates that provide an excellent starting
point. These include code that demonstrates AO, MO, and SO integrals. Use
one of the following commands that meets your needs::

   >>> psi4 --plugin-name myplugin --plugin-template aointegrals
   >>> psi4 --plugin-name myplugin --plugin-template mointegrals
   >>> psi4 --plugin-name myplugin --plugin-template sointegrals
   >>> psi4 --plugin-name myplugin --plugin-template wavefunction
   >>> psi4 --plugin-name myplugin --plugin-template scf
   >>> psi4 --plugin-name myplugin --plugin-template dfmp2

..   >>> psi4 --plugin-name myplugin --plugin-template ambit

.. Several stable sample plugin directories are available to consult in the
.. :source:`plugins` directory. Other plugin directories can be used as models
.. but are in active development. For documentation on plugin modules, see
.. :ref:`Available Plugins <sec:availablePlugins>`.
.. 
.. * :source:`plugins/aointegrals/aointegrals.cc` 
..   An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.
.. 
.. * :source:`plugins/backtrans/backtrans.cc` 
..   A test of the one- and two-particle density matrix backtransformation code.
.. 
.. * :source:`plugins/mointegrals/mointegrals.cc` 
..   An example that uses the LibTrans library to generate and print MO basis integrals.
.. 
.. * :source:`plugins/mollerplesset2/mp2.cc` 
..   A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.
.. 
.. * :source:`plugins/sointegrals/sointegrals.cc` 
..   An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals.

.. _`sec:condaplugins`:

Creating a New Plugin Using a Conda Pre-compiled Binary
-------------------------------------------------------

..     # prepare
..     >>> bash
..     >>> export PATH=$PSI4CONDA/bin:$PATH  # usually already done from psi4 installation
..     >>> cd "$(dirname $(which psi4))"/..  # move into distribution/environment directory, $PSI4CONDA
..     >>> conda install gcc                 # install compilers into expected place

|PSIfour| plugins can also be created using Conda for both |PSIfour|
binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``
compiler installed alongside ``psi4`` itself in the Conda distribution
or environment (below, ``$PSI4CONDA``). On Mac, one must use
``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by
installing XCode from the App Store that provides ``clang`` and
``clang++`` compilers.

* Check environment:

.. code-block:: bash

    # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant
    >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR

    >>> which python psi4 g++ gfortran  # Linux
    $PSI4CONDA/bin/python
    $PSI4CONDA/bin/psi4
    $PSI4CONDA/bin/gcc++
    $PSI4CONDA/bin/gfortran
    >>> which python psi4 g++ gfortran clang++  # Mac
    $PSI4CONDA/bin/python
    $PSI4CONDA/bin/psi4
    $PSI4CONDA/bin/g++
    $PSI4CONDA/bin/gfortran
    /usr/bin/clang++

    >>> which cmake
    $PSI4CONDA/bin/cmake
    # if above empty, ``conda install cmake``

* Create and compile plugin:

.. code-block:: bash

    >>> psi4 --plugin-name testplugin
    -- Creating "testplugin" with "basic" template. -----------------
    ==> Created plugin files (in testplugin as basic):
      __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py

    # move into plugin directory
    >>> cd testplugin

    # configure using build info from parent psi4
    >>> `psi4 --plugin-compile`  # Linux
    loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake
    -- The CXX compiler identification is GNU 5.2.0
    -- Check for working CXX compiler: $PSI4CONDA/bin/g++
    -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works
    ...
    -- Generating done
    -- Build files have been written to: testplugin
    >>> `psi4 --plugin-compile`  # Mac
    loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake
    -- The CXX compiler identification is AppleClang 7.0.0.7000176
    -- Check for working CXX compiler: /usr/bin/clang++
    -- Check for working CXX compiler: /usr/bin/clang++ -- works
    ...
    -- Generating done
    -- Build files have been written to: testplugin

    # compile the plugin to produce testplugin.so
    >>> make
    Scanning dependencies of target testplugin
    [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o
    [100%] Linking CXX shared module testplugin.so
    [100%] Built target testplugin

    # run sample input.dat
    >>> psi4
    Attention! This SCF may be density-fitted.

Please note that the conda distribution must be in ``$PATH`` or the
conda enviroment must be activated before compilation and execution of
plugins created using this procedure.

Files in a Plugin Directory
---------------------------

In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files

* **CMakeLists.txt** |w---w| CMake file governing project *plugin*.
  The plugin source and CMakeLists.txt is independent of platform
  and |PSIfour| installation. You use CMake (version 3.1 or later)
  to generate a Makefile for the plugin by pointing it to a specific
  |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command
  to execute to generate the Makefile. What that command is doing is
  loading the compilers and options used to build the parent |PSIfour|
  (the ``-C psi4PluginCache`` part) which in turn can be overridden
  by passing ``-Doption=value`` commands to ``cmake`` *and* pointing
  toward a particular |PSIfour| (and probably pybind11) library to
  link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to
  do an in-source build (the ``.`` part). Then just run ``make`` in
  your plugin directory. After any change to the plugin C++ code,
  ``make`` must be run in the plugin directory to recompile the
  ``myplugin.so`` executable, but recompiling the main |PSIfour| code
  is not necessary. Should you add additional (non-header) files to
  the plugin or need to link to additional external libraries, add that
  information here.

* **input.dat** |w---w| Sample input file for the plugin.
  Since the ``__init__.py`` file makes the plugin directory look like a
  Python module, the plugin can be treated as such in an input file. The
  location of the plugin directory must be included in :envvar:`PYTHONPATH`,
  either externally in the calling shell or defined in the input file.
  This is usually done by manipulating :envvar:`PSIPATH`. Then,
  the plugin can be loaded as ``import myplugin`` and executed as
  ``energy('myplugin')``. Any other Python functions are also available from
  the input file, *e.g.* ``myplugin.testfunction()``, note the namespace
  protection.

* **pymodule.py** |w---w| Python component of the plugin.
  By encoding the sequence of |PSIfour| module
  calls needed to run the plugin in the ``run_myplugin()`` function in this
  file, the plugin is hooked into the main |PSIfour| driver function
  :py:func:`~psi4.energy` and so can be accessed through
  ``energy('myplugin')`` in an input file. Any other Python functions can
  also be placed in this file.

* **__init__.py** |w---w| Init script for the plugin (in the sense that
  the whole plugin directory is a Python module). This file generally won't
  need editing unless additional Python files are added to the plugin
  directory (add additional lines to the ``# Load Python modules`` section)
  or the plugin depends on .so codes in other plugin directories (add
  additional plugin_load lines relative to the current plugin directory to
  the ``# Load C++ plugin`` section).

.. comment  as modeled in :source:`tests/plugin_libcim/__init__.py`).

  .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template

* **doc.rst** |w---w| Documentation file. Place in this file any notes,
  equations, warnings to users, todo lists, *etc.*. Plain text is fine,
  though reStructuredText is the ultimate goal. Remove the ``.. comment``
  text and build Sphinx documentation for samples of linking keywords,
  sections, and math. This file is absorbed into the |PSIfour|
  documentation, along with any docstrings to Python functions, and the C++
  keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`
  for building documentation.

.. and :ref:`Available Plugins <sec:availablePlugins>`
..  for this file's final destination.

Please note that pure virtual functions in a plugin may cause undefined symbols errors when
the plugin is loaded.

To create a purely Python plugin, create a new plugin directory, then
remove the ``Makefile`` and ``myplugin.cc`` files and
erase the shared object loading portion of ``__init__.py``. Create as many .py
files as necessary (registering each one in ``__init__.py``), use
``input.dat`` as a model for loading the plugin, no recompile ever
necessary.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   pair: method alias; adding new

.. _`sec:methodAlias`:

Defining a Method Alias
=======================

.. note:: No recompile of the |PSIfour| program is necessary for changes made to
    files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below.

.. caution:: As of 1.0, the below, while essentially still correct, is so aged
   as to be difficult to follow.

Since quantum chemical methods in |PSIfour| are accessed through Python functions, and
most important quantities are available as PSI variables, it is straightforward
to create aliases to commonly run calculations or to define hybrid methods. The
:source:`psi4/driver/aliases.py` file is intended for editing by the user for
this purpose.

As an example, the MP2.5 method
(which admittedly is already built in to |PSIfour|)
is the average of MP2 and MP3. The latter is
available through the arbitrary order MPn code and returns all lower energies
along with it in PSI variables. The following is basic code that will compute
and return the MP2.5 energy. ::

    def run_mp2_5(name, **kwargs):
    
        energy('mp3', **kwargs)
        e_scf = psi4.get_variable('SCF TOTAL ENERGY')
        ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY')
        ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY')
    
        ce_mp25 = 0.5 * (ce_mp2 + ce_mp3)
        e_mp25 = e_scf + ce_mp25
    
        print """  MP2.5 total energy:                      %16.8f\n""" % (e_mp25)
        print """  MP2.5 correlation energy:                %16.8f\n""" % (ce_mp25)
    
        return e_mp25

Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.
The rationale for the changes is indicated in the comments below. ::

    def run_mp2_5(name, **kwargs):
        lowername = name.lower()  # handy variable with name keyword in lowercase
        kwargs = kwargs_lower(kwargs)  # removes case sensitivity in keyword names
    
        # Run detci calculation and collect conventional quantities
        energy('mp3', **kwargs)
        e_scf = psi4.get_variable('SCF TOTAL ENERGY')
        ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY')
        ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY')
        e_mp2 = e_scf + ce_mp2  # reform mp2 and mp3 total energies for printing
        e_mp3 = e_scf + ce_mp3
    
        # Compute quantities particular to MP2.5
        ce_mp25 = 0.5 * (ce_mp2 + ce_mp3)
        e_mp25 = e_scf + ce_mp25
        psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25)  # add new method's important results
        psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25)         #     to PSI variable repository
        psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25)
        psi4.set_variable('CURRENT ENERGY', e_mp25)  # geometry optimizer tracks this variable, permits
                                                       #     MP2.5 finite difference optimizations 
        # build string of title banner and print results
        banners = ''
        banners += """psi4.print_out('\\n')\n"""
        banners += """banner(' MP2.5 ')\n"""
        banners += """psi4.print_out('\\n')\n\n"""
        exec banners
    
        tables  = ''
        tables += """  SCF total energy:                        %16.8f\n""" % (e_scf)
        tables += """  MP2 total energy:                        %16.8f\n""" % (e_mp2)
        tables += """  MP2.5 total energy:                      %16.8f\n""" % (e_mp25)
        tables += """  MP3 total energy:                        %16.8f\n\n""" % (e_mp3)
        tables += """  MP2 correlation energy:                  %16.8f\n""" % (ce_mp2)
        tables += """  MP2.5 correlation energy:                %16.8f\n""" % (ce_mp25)
        tables += """  MP3 correlation energy:                  %16.8f\n""" % (ce_mp3)
        psi4.print_out(tables)  # prints nice header and table of all involved quantities to output file
    
        return e_mp25 

One final step is necessary. At the end of the ``aliases.py`` file, add 
the following line. ::

    procedures['energy']['mp2.5'] = run_mp2_5

This permits the newly defined MP2.5 method to be called in the input file
with the following command. ::

    energy('mp2.5')

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:psiPEP`:

=================================================
PsiPEP: Plans and Practices to Organize |PSIfour|
=================================================

.. toctree::
   :maxdepth: 1
   :glob:

   pep*

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:buildrunfaq`:

===============
Build & Run FAQ
===============

Obtaining and Updating |PSIfour|
--------------------------------

#. :ref:`faq:obtainpsi4`
#. :ref:`faq:quiz`
#. :ref:`faq:binary`
#. :ref:`faq:clonepsi4public`
#. :ref:`faq:forkpsi4public`
#. :ref:`faq:tarballpsi4public`
#. :ref:`faq:recompile`

.. #. :ref:`faq:psi3sourceforge`

Configuring and Installing |PSIfour| via Binary
-----------------------------------------------

#. :ref:`faq:psicodedownload`
#. :ref:`sec:psi4conda`
#. :ref:`faq:psi4pkg`
#. :ref:`faq:updatepsi4`
#. :ref:`faq:psi4deps`
#. :ref:`sec:condadetails`
#. :ref:`faq:condamaxameri`

Configuring, Building, and Installing |PSIfour| via Source
----------------------------------------------------------

#. :ref:`faq:cmakeviasetup`
#. :ref:`faq:buildquick`
#. :ref:`faq:builddetailed`

#. :ref:`faq:setuphelp`
#. :ref:`faq:chooseobjdir`
#. :ref:`faq:setupprefix`
#. :ref:`faq:condapsi4dev`
#. :ref:`faq:setupmaxameri`
#. :ref:`faq:cmakeverbose`
#. :ref:`faq:doconfigure`
#. :ref:`faq:cray`

Non-QC Dependencies
-------------------

#. :ref:`faq:coredepend`
#. :ref:`cmake:python`
#. :ref:`faq:libmwcondapy`
#. :ref:`cmake:lapack`
#. :ref:`cmake:cxx`
#. :ref:`faq:approvedcxx`
#. :ref:`faq:modgcc`
#. :ref:`faq:macxcode`
#. :ref:`cmake:fortran`
#. :ref:`faq:approvedfc`
#. :ref:`faq:macgfortran`

QC Dependencies and Extensions
------------------------------

#. :ref:`faq:addondepend`
#. :ref:`faq:localaddon`
#. :ref:`cmake:chemps2`
#. :ref:`faq:chemps2gccflto`
#. :ref:`cmake:dkh`
#. :ref:`cmake:libefp`
#. :ref:`cmake:erd`
#. :ref:`cmake:gdma`
#. :ref:`cmake:libint`
#. :ref:`cmake:pcmsolver`

Testing 
-------

#. :ref:`faq:testsoutput`
#. :ref:`faq:subsettests`
#. :ref:`faq:minutetests`
#. :ref:`faq:pytest`

Runtime Setup
-------------

#. :ref:`faq:runordinaryexe`
#. :ref:`faq:runordinarymodule`
#. :ref:`faq:runfrombinary`
#. :ref:`faq:inplace`
#. :ref:`faq:psi4scratch`
#. :ref:`faq:psidatadir`
#. :ref:`faq:psi4psiapipath`
#. :ref:`faq:modulenotfounderror`

Running |PSIfour|
-----------------

#. :ref:`What command line options does Psi4 have <sec:commandLineOptions>`
#. :ref:`What environment variables affect Psi4 <sec:environmentVariables>`
#. :ref:`faq:runtimepython`
#. :ref:`faq:psi4version`
#. :ref:`faq:psi4PBS`
#. :ref:`faq:psi4fileretention`
#. :ref:`faq:logging`

Runtime Errors and Debugging
----------------------------

#. :ref:`faq:gdblldb`
#. :ref:`faq:setuptype`
#. :ref:`faq:wrongpyfalse`

Managing Code
-------------

#. :ref:`faq:dirlayoutinstall`
#. :ref:`faq:githubworkflow`
#. :ref:`faq:vigitmerge`

Miscellaneous
-------------

#. :ref:`faq:writepsi4`
#. :ref:`faq:psi4logos`


.. #. :ref:`faq:getversion`
.. #. :ref:`faq:binarypackage`
.. #. :ref:`faq:getting-and-using-the-psi4dependencies-package`
.. #. :ref:`faq:erroreriam`

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. index:: DFT; available functionals
.. _`apdx:dftFunctionals`:

DFT Functionals
===============

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:
   :glob:

   autodoc_dft_*


.. _`table:dft_all`:

All Available
-------------

.. include:: autodoc_dft_all.rst


.. _`table:dft_gga`:

GGA
---

.. include:: autodoc_dft_gga.rst


.. _`table:dft_meta`:

Meta
----

.. include:: autodoc_dft_meta.rst


.. _`table:dft_lrc`:

Long-Range Corrected
--------------------

.. include:: autodoc_dft_lrc.rst


.. _`table:dft_hybrid`:

Hybrid
------

.. include:: autodoc_dft_hybrid.rst


.. _`table:dft_dhybrid`:

Double-Hybrid
-------------

.. include:: autodoc_dft_dhybrid.rst


.. _`table:dft_scsdhybrid`:

SCS Double-Hybrid
-----------------

.. comment .. include:: autodoc_dft_scsdhybrid.rst  # commented until populated again to appease Sphinx


.. _`table:dft_disp`:

Dispersion-Corrected
--------------------

.. include:: autodoc_dft_disp.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: Cfour
.. _`sec:cfour`:

Interface to CFOUR by J. Stanton & J. Gauss
===========================================

.. codeauthor:: Lori A. Burns
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Keywords <apdx:cfour>`, :ref:`PSI Variables <apdx:cfour_psivar>`, :ref:`Samples <apdx:testSuitecfour>`

|PSIfour| contains code to interface to the Cfour quantum chemistry suite of
John F. Stanton (U. Texas, Austin) and J\ |u_dots|\ rgen Gauss (U. Mainz),
which is available after a license agreement from 
`http://www.cfour.de/ <http://www.cfour.de/>`_.

Installation
~~~~~~~~~~~~

Follow the instructions provided with the Cfour download to install the
executable or to build the source. To by used by |PSIfour|, the program
binary (:program:`xcfour`) must be found in your :envvar:`PATH` or
:envvar:`PSIPATH`.  The ``GENBAS`` file containing basis sets in Cfour
format is not necessary for this interface, but if you prefer to access
basis sets the "Cfour way" using a custom ``GENBAS`` file (the distributed
one is included with the interface), it, too, must be in :envvar:`PATH` or
:envvar:`PSIPATH`. If |PSIfour| is unable to execute the binary, an error
will be reported.

.. .. caution:: The p4c4 interface isn't in the master branch nor will it be in
..    the near future. To run this code, (1) build the ``c4`` branch of psi4,
..    (2) find a copy of cfour and put it in :envvar:`PATH` or
..    :envvar:`PSIPATH`, and (3) clone https://github.com/loriab/qcdb.git
..    python module and prepend :envvar:`PYTHONPATH` with the top qcdb
..    directory (the path added to PYTHONPATH should have one "qcdb" in it;
..    the cloned qcdb is what needs to be imported in preference to the one
..    already in psi4). Execute psi4 as usual.

.. caution:: The p4c4 interface hasn't been fully adapted for the new March 2014 version.

Cfour for |PSIfour| Users
~~~~~~~~~~~~~~~~~~~~~~~~~

* Set memory as usual

* Set molecule as usual

* Set basis set as usual (Cfour only cares about orbital basis, no fitting
  bases)

* Set the task as usual, indicating Cfour as the intended code by
  prepending "c4-" to the method argument. So ``energy('scf')`` becomes
  ``energy('c4-scf')`` and ``optimize('ccsd(t)')`` becomes
  ``optimize('c4-ccsd(t)')``. Find available methods for
  :py:func:`~psi4.energy` at :ref:`Energy (CFOUR) <table:energy_cfour>`
  and for :py:func:`~psi4.optimize` at :ref:`Gradient (CFOUR)
  <table:grad_cfour>`.

* Generally, the p4c4 interface will handle best practices for path of
  execution: ``vcc``/``ecc``, derivative type, *etc.* The user is still
  responsible for setting convergence, frozen core, guess, diis, *etc.*
  For the moment, so-called "best-practices" keywords are summarized at
  :ref:`Best Practices <table:cfour_cc_program>`.

* For the type of computation intended, find appropriate options at
  :ref:`Keywords <apdx:cfour>`. These keyword summaries contain the same
  information as the `proper CFOUR options list
  <http://slater.chemie.uni-mainz.de/cfour/index.php?n=Main.ListOfKeywordsInAlphabeticalOrder>`_
  plus notes on keyword relevance when run through |PSIfour|.  Information
  at the `CFOUR manual
  <http://slater.chemie.uni-mainz.de/cfour/index.php?n=Main.Manual>`_ may
  also be useful, as may the many samples at :source:`samples/cfour`.

* Set Cfour keywords just like |PSIfour| keywords. The names of keywords
  are unchanged beyond a prepended "cfour\_". (Though be aware that common
  abbreviations like CALC and REF must be fully spelled out as
  |cfour__cfour_calc_level| and |cfour__cfour_reference| when used in
  |PSIfour|.)

* In limited trial cases, keywords nominally directed at non-Cfour modules
  are translated into their Cfour counterparts. For example, setting
  |scf__reference| will appropriately set |cfour__cfour_reference|. For a
  list of applicable keywords, see source of
  muster_psi4options.

* Consult :ref:`sec:cfourFunctionality` for information on what Cfour
  functionality is accessible through |PSIfour|.

|PSIfour| for Cfour Users
~~~~~~~~~~~~~~~~~~~~~~~~~

In the simplest use of the Psi4/Cfour interface, a |PSIfour| input file
can simply "wrap" a ``ZMAT`` file and execute :program:`xcfour`. This is
illustrated in the following example::

    cfour {
    UHF-SCF energy calculation 
    N
    H 1 R
    H 1 R 2 A
    
    R=1.008
    A=105.0
    
    *ACES2(CALC=HF,BASIS=qz2p
    MULT=2,REF=UHF
    OCCUPATION=3-1-1-0/3-0-1-0
    SCF_CONV=12
    MEMORY=20000000)
    }
    
    energy('cfour')

Here, the contents of the ``cfour {...}`` block are written directly to a
``ZMAT`` file. This is joined by a default ``GENBAS`` file
(:source:`psi4/share/psi4/basis/GENBAS`).  To preferentially use your own ``GENBAS``,
place it in :envvar:`PATH` or :envvar:`PSIPATH`. The line calling
:py:func:`~psi4.energy` with argument ``'cfour'`` invokes
:program:`xcfour`.

After execution of the ``energy('cfour')`` line completes, Cfour results
are read back into |PSIfour| format and are thereafter accessible for
further processing in the input file. See :ref:`sec:cfourOutput` for
details. This storage of results in variables and arrays *in memory* for
the duration of the |PSIfour| instance (as opposed to solely *in files*)
is the only advantage thus far incurred by the P4C4 interface. We'll call
this mode of basic utility the "sandwich" mode.

Molecule specification in |PSIfour| allows Cartesians, Z-matrices, mixed
Cartesian/Z-matrix, negation of variables, delayed specification of
variables, specification of fragments, etc., all in a whitespace-tolerant
format. See :ref:`sec:moleculeSpecification` for details and
:srcsample:`cfour/mints5` for examples. When a |PSIfour|-style molecule is
supplied, its geometry is written to ``ZMAT`` in Cartesian form and the
|cfour__cfour_coordinates|\ =CARTESIAN, |cfour__cfour_units|\ =ANGSTROM,
|cfour__cfour_charge|, and |cfour__cfour_multiplicity| keywords are set
appropriately in the ``*CFOUR(...)`` directive.

.. warning:: There exist molecules (*e.g.*, allene) where the
   inertial frame is not unique (planes along atoms or between
   atoms). The orientation reconciling machinery currently does not
   handle these cases and will fail with "Axis unreconcilable between
   QC programs". I will get to this soon.

Whenever the molecule is supplied in |PSIfour| format, the job control
keywords must be too. All :ref:`Cfour keywords <apdx:cfour>` are the usual
ones, prepended by ``cfour_`` to avoid any possible name conflicts.  As
detailed in :ref:`sec:jobControl`, setting keywords is flexible in
format. The previous example translates to::

    # UHF-SCF energy calculation 

    molecule {
    0 2                                          # multiplicity from the MULT keyword
    N
    H 1 R
    H 1 R 2 A
    
    R=1.008
    A=105.0
    }
    
    set {
    cfour_CALC_level=HF                          # only full keyword names allowed
    cfour_BASIS=qz2p
    #MULT=2                                      # now in molecule {...} block
    cfour_REFerence=UHF
    cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ]  # arrays in python notation
    cfour_SCF_CONV=12
    cfour_MEMORY=20000000
    }
    
    energy('cfour')

Here, note that none of capitalization, equals sign, or whitespace matter
for the keyword commands. Specification of strings and integers requires no
translation; :ref:`booleans <op_c_boolean>` have extended freedom of
format; arrays must be translated into Python-style (square-bracket
bounded and comma delimited) of appropriate dimension. There are many
sample inputs in :source:`tests/cfour/` starting with ``sp-`` that take
examples from the Cfour manual and first run them in sandwich mode and
then run them as translated into |PSIfour| format.

.. note:: |PSIfour| only recognizes keywords by their full name, so the common
   Cfour keyword abbreviations CALC, REF, etc. must be replaced by their
   proper names of |cfour__cfour_calc_level|, |cfour__cfour_reference|, etc.

Whenever the molecule is supplied in |PSIfour| format, it is possible to
perform geometry optimizations where Cfour supplies the gradient and the
|PSIfour| module :ref:`optking <sec:optking>` drives the structural
changes. Because of the limitations on geometry specification for
optimizations in Cfour, optking-driven optimizations are the *only*
optimizations allowed in the P4C4 interface. (The exception is sandwich
mode, which, of course, permits optimizations with the Cfour optimizer.)
Below is an example of a geometry optimization::

    memory 200 mb
    
    molecule {
    O
    H 1 R
    H 1 R 2 A
    
    R=0.958
    A=104.5
    }
    
    set {
    
    cfour_CALC_level CCSD(T)
    cfour_BASIS      DZP
    cfour_CC_CONV    12
    cfour_LINEQ_CONV 12
    cfour_SCF_CONV   12
    g_convergence    cfour
    }

    optimize('cfour')

Note that the primary change is the exchange of :py:func:`~psi4.energy`
for :py:func:`~psi4.optimize` to trigger an optimization.  Setting
|optking__g_convergence|\ =CFOUR provides a good imitation of Cfour
default convergence criteria. Although Cfour produces gradients only in
its standard orientation and atom ordering, these are transformed back to
input orientation by the P4C4 interface. Several sample inputs in
:source:`tests/cfour/` starting with ``opt-`` show basic geometry
optimizations. :srcsample:`cfour/mints5-grad` shows optimizations from a
variety of molecule input formats, and :srcsample:`cfour/psi-ghost-grad`
shows an optimization with ghosted atoms. To obtain a single gradient
*sans* optimization, call instead :py:func:`~psi4.gradient`.

Note that it can be convenient to monitor the progress of a geometry
optimization by grepping the tilde ``~`` character. ::
 
   Measures of convergence in internal coordinates in au.
   Criteria marked as inactive (o), active & met (*), and active & unmet ( ).
   --------------------------------------------------------------------------------------------- ~
    Step     Total Energy     Delta E     MAX Force     RMS Force      MAX Disp      RMS Disp    ~
   --------------------------------------------------------------------------------------------- ~
     Convergence Criteria    1.00e-06 *    3.00e-04 *    1.00e-06 *    1.20e-03 *             o  ~
   --------------------------------------------------------------------------------------------- ~
       1     -76.33224285   -7.63e+01      2.41e-03      1.60e-03      1.51e-02      8.82e-03 o  ~
       2     -76.33226097   -1.81e-05      4.84e-04      4.03e-04      7.71e-04 *    7.04e-04 o  ~
       3     -76.33226140   -4.39e-07 *    4.31e-05 *    3.58e-05      9.89e-05 *    8.93e-05 o  ~
       4     -76.33226141   -4.26e-09 *    9.76e-07 *    6.58e-07 *    6.22e-06 *    3.71e-06 o  ~
   --------------------------------------------------------------------------------------------------------------- ~
    Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~
   --------------------------------------------------------------------------------------------------------------- ~
       1     -76.332242848098    -76.332242848098      0.00241281      0.00160359      0.01507630      0.00881949  ~
       2     -76.332260965382     -0.000018117284      0.00048446      0.00040256      0.00077146      0.00070447  ~
       3     -76.332261404452     -0.000000439070      0.00004307      0.00003577      0.00009889      0.00008926  ~
       4     -76.332261408714     -0.000000004262      0.00000098      0.00000066      0.00000622      0.00000371  ~
   --------------------------------------------------------------------------------------------------------------- ~

The above example also shows the total memory for the computation being
set in |PSIfour| format. See :ref:`sec:memory` for details. When
specified, the memory value is passed on to Cfour by setting keywords
|cfour__cfour_memory_size| and |cfour__cfour_mem_unit|\ =MB.

|PSIfour| has an extensive :ref:`basis set library <apdx:basisElement>` in
Gaussian94 format. See :ref:`sec:basisSets` for details.  Contrasts to
Cfour basis handling include identifying basis sets by standard name
(aug-cc-pVDZ instead of AUG-PVDZ), direct handles for
diffuse-function-pruned sets (*e.g.*, jun-cc-pVDZ), case insensitivity,
appropriate setting of spherical/Cartesian depending on basis set design,
and syntax to set different basis sets to different classes of atoms
without listing each atom. All of these features are available to Cfour by
using the |mints__basis| keyword instead of |cfour__cfour_basis|
(accompanied, of course, by specifying the molecule |PSIfour|-style).
Internally, |PSIfour| processes the basis set as usual, then translates
the basis set format and writes out a ``GENBAS`` file with an entry for
each atom. The P4C4 interface sets keyword |cfour__cfour_basis|\ =SPECIAL
and |cfour__cfour_spherical| as appropriate, then writes the basis section
necessary for SPECIAL below the ``*CFOUR(...)`` block. (I'm sorry that the
name of the basis doesn't appear in ``ZMAT``, but the combination of the
~14 character basis name limit and the absence of a comment line marker
rather precludes that helpful label.)

The input below employs a |PSIfour| library basis set and also introduces
the final stage of conversion toward |PSIfour| format. Instead of the
generic ``'cfour'``, the computational method is specified as the first
argument to the :py:func:`~psi4.optimize` call. In the computational
command below, the string argument ``'c4-ccsd(t)'`` directs that a CCSD(T)
computation be run using Cfour (as opposed to ``'ccsd(t)'`` which would
call |PSIfour| CC code). Specifying computational method in this manner
sets |cfour__cfour_calc_level| from the argument and
|cfour__cfour_deriv_level| as appropriate from the function call:
:py:func:`~psi4.energy`, :py:func:`~psi4.gradient`, or
:py:func:`~psi4.optimize`. If those keywords are also set explicitly to
contradictory values, the interface will complain. ::

   memory 2 gb

   molecule CH2F2  {
     units au
     C     0.0000000000  -0.0000000000   1.0890958457
     F     0.0000000000  -2.1223155812  -0.4598161475
     F    -0.0000000000   2.1223155812  -0.4598161475
     H     1.7084139850   0.0000000000   2.1841068002
     H    -1.7084139850  -0.0000000000   2.1841068002
   }

   set basis aug-cc-pvdz
   set rms_force_g_convergence 6
   set cfour_abcdtype aobasis
   set cfour_scf_conv 12
   set cfour_cc_conv 12
   set cfour_lineq_conv 12

   optimize('c4-ccsd(t)')

The utility of this method specification is that examination can be made
of the reference, the derivative level, the excitation level, *etc.* and
some options can be set according to best practices. Practically speaking,
|cfour__cfour_cc_program| (and eventually |cfour__cfour_abcdtype|) will
always be set to the :ref:`fastest safe value <table:cfour_cc_program>`.
For example, the input above will run with |cfour__cfour_cc_program|\ =ECC
unless explicitly set to VCC.

An advantage of |PSIfours| Python driver is that any number of common
work-up procedures can be automated and wrapped around the
conventional single-point and optimization procedures at the heart of all
quantum chemistry codes. Three core "wrappers" available in |PSIfour| are
:py:func:`~psi4.driver.driver_nbody.nbody_gufunc`,
:py:func:`~psi4.database`, and
:py:func:`~psi4.driver.cbs`; read their respective sections
for details, but an overview is provided here. :py:func:`~psi4.driver.driver_nbody.nbody_gufunc`
computes the interaction energy of a bimolecular complex (counterpoise-corrected,
not, or both). ::

   molecule dimer {
     Ne
   --
     Ne 1 R
     symmetry c1
   }
   
   Rvals=[2.5, 3.0, 4.0]
   set basis aug-cc-pVDZ
   
   for R in Rvals:
     dimer.R = R
     ecp = cp('c4-mp2')
     print_stdout('R [A] = %.1f  IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp))
   
yields ::

   R [A] = 2.5  IE [kcal/mol] = 0.804
   R [A] = 3.0  IE [kcal/mol] = 0.030
   R [A] = 4.0  IE [kcal/mol] = -0.014

Next, the :py:func:`~psi4.driver.wrapper_database.database` wrapper allows any computational
model chemistry to be applied a predefined collection of molecules. Thus
an input ::

   set {
       basis jun-cc-pvdz
       d_convergence 9
   }
   
   database('c4-mp2','nbc10',cp='on',subset='MeMe')

yields the counterpoise-corrected interaction energy for several points
along the dissociation curve of methane dimer, which is a member of the
:srcdb:`NBC10` database::

   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//
   //       Database nbc10 Results      //
   //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//
 
   For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from
   'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.
   Depending on the nature of the variable, this may or may not make any physical sense.
 
   ==> Requested Energy <==
 
   ----------------------------------------------------------------------------------------------
               Reaction     Reaction Energy      Error           Reagent 1           Reagent 2
                               Ref     Calc [kcal/mol]              [H] Wt              [H] Wt
   ----------------------------------------------------------------------------------------------
          NBC1-MeMe-3.2     0.0690   1.1639     1.0949     -80.72700202  1     -40.36442840 -2
          NBC1-MeMe-3.3    -0.2390   0.6709     0.9099     -80.72764911  1     -40.36435916 -2
          NBC1-MeMe-3.4    -0.4170   0.3407     0.7577     -80.72806043  1     -40.36430165 -2
          NBC1-MeMe-3.5    -0.5080   0.1244     0.6324     -80.72831099  1     -40.36425461 -2
          NBC1-MeMe-3.6    -0.5410  -0.0129     0.5281     -80.72845373  1     -40.36421659 -2
          NBC1-MeMe-3.7    -0.5390  -0.0961     0.4429     -80.72852567  1     -40.36418623 -2
          NBC1-MeMe-3.8    -0.5150  -0.1430     0.3720     -80.72855247  1     -40.36416227 -2
          NBC1-MeMe-3.9    -0.4800  -0.1659     0.3141     -80.72855167  1     -40.36414365 -2
          NBC1-MeMe-4.0    -0.4390  -0.1733     0.2657     -80.72853498  1     -40.36412938 -2
          NBC1-MeMe-4.1    -0.3960  -0.1712     0.2248     -80.72850993  1     -40.36411859 -2
          NBC1-MeMe-4.2    -0.3540  -0.1633     0.1907     -80.72848118  1     -40.36411044 -2
          NBC1-MeMe-4.3    -0.3150  -0.1525     0.1625     -80.72845143  1     -40.36410422 -2
          NBC1-MeMe-4.4    -0.2790  -0.1403     0.1387     -80.72842215  1     -40.36409932 -2
          NBC1-MeMe-4.6    -0.2170  -0.1155     0.1015     -80.72836761  1     -40.36409177 -2
          NBC1-MeMe-4.8    -0.1680  -0.0933     0.0747     -80.72831991  1     -40.36408563 -2
          NBC1-MeMe-5.0    -0.1300  -0.0747     0.0553     -80.72827951  1     -40.36408021 -2
          NBC1-MeMe-5.4    -0.0800  -0.0479     0.0321     -80.72821875  1     -40.36407122 -2
          NBC1-MeMe-5.8    -0.0500  -0.0312     0.0188     -80.72817678  1     -40.36406353 -2
   ----------------------------------------------------------------------------------------------
            Minimal Dev                         0.0188
            Maximal Dev                         1.0949
        Mean Signed Dev                         0.3509
      Mean Absolute Dev                         0.3509
                RMS Dev                         0.4676
   ----------------------------------------------------------------------------------------------

Thirdly, the :py:func:`~psi4.driver.cbs` wrapper allows any
compound computational method that can be expressed through :ref:`CBS
<eq:cbs>` to be applied to a molecule while employing the minimum number
of calculations. For example, the job below computes a
triple-quadruple-zeta Helgaker extrapolation of the mp2 correlation energy
atop a quadruple zeta reference to which is appended a double-triple-zeta
Helgaker extrapolated ccsd(t) - mp2 delta correction. Since the mp2 has
been requested through |PSIfour| and the ccsd(t) through Cfour, the
wrapper runs only MP2/cc-pVQZ (P4), CCSD(T)/cc-pVDZ (C4), and
CCSD(T)/cc-pVTZ (C4) single-points. ::

   molecule {
   H 0.0 0.0 0.0
   H 1.0 0.0 0.0
   }
   
   set mp2_type conv

   cbs('mp2', corl_basis='cc-pV[TQ]Z', delta_wfn='c4-ccsd(t)', delta_basis='cc-pV[DT]Z')

This yields::

   ==> CBS <==

   ---------------------------------------------------------------------------------------------------------
       Stage               Method / Basis                                Energy [H]   Scheme
   ---------------------------------------------------------------------------------------------------------
         scf                  scf / cc-pvqz                             -1.10245974   highest_1
        corl                  mp2 / cc-pv[tq]z                          -0.03561890   corl_xtpl_helgaker_2
       delta     c4-ccsd(t) - mp2 / cc-pv[dt]z                           0.03507767   corl_xtpl_helgaker_2
       total                  CBS                                       -1.10300098
   ---------------------------------------------------------------------------------------------------------

Note that especially for :py:func:`~psi4.driver.cbs`, the
basis set needs to be specified through |mints__basis|, not
|cfour__cfour_basis|.  Many of the wrappers can be used in combination to,
for example, apply a compound method to every molecule in a database or to
optimize a molecule with an extrapolated basis set (findif only for the
moment- analytics coming).

Finally, any number and combination of jobs can be run from a single
|PSIfour| input file.  Depending on the nature of preceding or following
jobs, it is prudent to separate them with the following::

    clean()            # removes Psi4 scratch files
    clean_variables()  # empties the PSI variables list
    cfour {}           # empties the cfour block

.. warning:: Because p4c4 does not inspect the contents of the ``cfour {...}``
   block, once the user specifies a |PSIfour|-style molecule, the
   interface cannot judge whether a sandwich mode (drop the |PSIfour| molecule
   and use the cfour block as the entirety of the ``ZMAT``) or a standard mode
   (translate the |PSIfour| molecule and append additional input from the
   cfour block) is intended. The latter is what actually occurs. If
   there is both a |PSIfour| molecule and a molecule in the cfour block,
   ``ZMAT`` *will* end up with multiple molecules and multiple ``*CFOUR(...)``
   blocks, and it *will not* run.  Therefore, if mixing sandwich and
   standard or pure-\ |PSIfour| computations in an input file, place all
   the sandwich jobs at the beginning before declaring |PSIfour|
   molecules. If necessary, clear the cfour block with ``cfour {}`` before
   commencing standard P4C4 jobs.

.. _`sec:cfourOutput`:

Output
~~~~~~

The output of :program:`xcfour` invoked from a |PSIfour| input file is
written to the |PSIfour| output file as the computation progresses.  If a
Cfour module terminates with a non-zero error code, the value will show up
in :psivar:`CFOUR ERROR CODE`.

.. rubric:: Energies & Scalars

After execution of :program:`xcfour` has completed, the output string is
extensively parsed and appropriate results are stored in :ref:`PSI
Variables <apdx:cfour_psivar>`. All gleaned variables are printed in the
Cfour output section of the |PSIfour| output file, as shown below. ::

  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//
  //  Cfour c4-ccsd(t) Energy Results  //
  //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//


  Variable Map:
  ----------------------------------------------------------------------------
  "(T) CORRECTION ENERGY"      =>      -0.007263598030
  "CCSD CORRELATION ENERGY"    =>      -0.275705492359
  "CCSD TOTAL ENERGY"          =>     -76.338453952539
  "CCSD(T) CORRELATION ENERGY" =>      -0.007263598030
  "CCSD(T) TOTAL ENERGY"       =>     -76.345717550569
  "CFOUR ERROR CODE"           =>       0.000000000000
  "CURRENT CORRELATION ENERGY" =>      -0.007263598030
  "CURRENT ENERGY"             =>     -76.345717550569
  "CURRENT REFERENCE ENERGY"   =>     -76.062748460180
  "MP2 CORRELATION ENERGY"     =>      -0.270191667755
  "MP2 OPPOSITE-SPIN ENERGY"   =>      -0.204890356651
  "MP2 SAME-SPIN ENERGY"       =>      -0.065301311104
  "MP2 TOTAL ENERGY"           =>     -76.332940127935
  "NUCLEAR REPULSION ENERGY"   =>       9.187331653300
  "SCF TOTAL ENERGY"           =>     -76.062748460180

The PSI Variables are also available from the input file for manipulation.
For instance, to compute the MBPT 2 3/4 energy from MBPT 3 results, the
following could be used. ::

   energy('c4-mp3')
   mp2p75_corl = 0.75 * get_variable('mp3 correlation energy') + \
                 0.25 * get_variable('MP2 correlation energy')
   print mp2p75_corl + get_variable('scf total energy')

.. caution:: Some features are not yet implemented. Buy a developer a coffee.

   - No PSI Variables for properties: *e.g.*, :psivar:`SCF DIPOLE`

   - No PSI Variables for excited state energies

   The formation of further regexes for properties, excited states, etc.
   is one of the primary areas in which this interface requires further
   work.

.. rubric:: Gradients and Arrays

In addition to parsing the output stream, results are collected from files
written to the scratch directory. Presently, the ``GRD`` file is parsed
and printed to the output file, as shown below. Also printed is the Cfour
gradient after manipulation by the P4C4 interface and used by |PSIfour|
going forward. Manipulation is necessary because Cfour determinedly uses
its own internal orientation and atom ordering while |PSIfour| naturally
expects the gradient to be aligned with the active molecule. The geometry
in ``GRD`` and the geometry of |PSIfours| active molecule are shifted,
rotated, flipped, and otherwise badgered into coincidence, then the same
manipulations are applied to the gradient in ``GRD``, the result of which
is printed below and passed on to Optking. ::

  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//
  //   Cfour c4-scf Gradient Results   //
  //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//

  ...

  Irrep: 1 Size: 4 x 3 

                 1            2            3     

    1    0.0000000   -0.0122978    0.0000000
    2   -0.0051192    0.0040993   -0.0088667
    3   -0.0051192    0.0040993    0.0088667
    4    0.0102384    0.0040993    0.0000000


  CFOUR scratch file GRD has been read
    4        0.0000000000
        7.0000000000       -0.0880964705        0.0000000000        0.0000000000
        1.0000000000        0.4080144050       -0.9178691296       -1.5897959670
        1.0000000000        0.4080144050       -0.9178691296        1.5897959670
        1.0000000000        0.4080144050        1.8357382590        0.0000000001
        7.0000000000       -0.0122978407        0.0000000000        0.0000000000
        1.0000000000        0.0040992802       -0.0051191833       -0.0088666856
        1.0000000000        0.0040992802       -0.0051191833        0.0088666856
        1.0000000000        0.0040992802        0.0102383666        0.0000000000

The gradient can also be accessed from the input file as a
:py:class:`~psi4.core.Matrix` object through
:py:func:`psi4.core.get_gradient`.

.. rubric:: Cfour Files

The contents of all files associated with Cfour are accessible from the
input file through the Python dictionary ``P4C4_INFO``. That is,
``P4C4_INFO['zmat']`` returns a string of the input file sent to Cfour.
Accessible arguments are ``zmat``, ``output``, and any that have been
produced of ``grd``. For example, to print to the screen if CC convergence
is reached, the following could be placed in the |PSIfour| input file. ::

   energy('c4-ccsd')
   print 'miracle?', 'miracle' in P4C4_INFO['output']

.. rubric:: Scratch Files

By default, a separate subdirectory for each Cfour call is created within
the job's scratch directory. To explicitly specify the location of the
Cfour scratch, execute with, for example, ``energy('cfour',
path='/full/path/to/cfour/scratch')``. Regardless of whether the location
is specified or default, whether to preserve the scratch directory after
the computation can be specified with ``energy('cfour', keep=True)`` or
(the default) ``energy('cfour', keep=False)``. *path* and *keep* are
keyword arguments that get interpreted by the
:py:func:`~psi4.driver.procrouting.interface_cfour.run_cfour` function documented below.

.. autofunction:: psi4.driver.procrouting.interface_cfour.run_cfour(name [, keep, path])

.. _`sec:cfourFunctionality`:

Functionality
~~~~~~~~~~~~~

Through clever use of the ``cfour {...}`` block, one could run most any
Cfour computation through the P4C4 interface.  In contrast, enumerated
below are tested functionalities where results from Cfour are collected
into |PSIfour| data objects.

.. rubric:: Implemented

* Single-point :py:func:`~psi4.energy` commands for :ref:`ground state
  methods <table:energy_cfour>`. Examples:
  :srcsample:`cfour/sp-rhf-ccsd_t_-ao-ecc`, :srcsample:`cfour/scf4`,
  :srcsample:`cfour/mints5`.

* Analytic :py:func:`~psi4.gradient` and :py:func:`~psi4.optimize`
  commands for :ref:`ground state methods <table:grad_cfour>`. Real and
  Ghost atoms permitted (though the latter will naturally collapse after
  several cycles). Examples: :srcsample:`cfour/opt-rhf-ccsd_t_`,
  :srcsample:`cfour/mp2-1`, and :srcsample:`cfour/mints5-grad`.

.. warning:: There exist molecules (*e.g.*, allene) where the
   inertial frame is not unique (planes along atoms or between
   atoms). The orientation reconciling machinery currently does not
   handle these cases and will fail with "Axis unreconcilable between
   QC programs". I will get to this soon.

* Finite difference of energy :py:func:`~psi4.gradient` and
  :py:func:`~psi4.optimize` for :ref:`methods <table:energy_cfour>`.
  Force with ``gradient('name', dertype=0)``, *etc.*.

* :py:func:`~psi4.driver.driver_nbody.nbody_gufunc` for computation of interaction energies with or
  without counterpoise correction. Example: :srcsample:`cfour/dfmp2-1`.

* :py:func:`~psi4.database` for computation of a collection of molecules in a
  single input, with summarization of results. Examples:
  :srcsample:`cfour/pywrap-db1` and :srcsample:`cfour/psi-a24-grad`.

* :py:func:`~psi4.driver.cbs` for computation of compound methods involving
  basis set extrapolations and/or delta corrections with any combination
  of |PSIfour| and Cfour computational methods and |PSIfour| basis sets.
  Example: :srcsample:`cfour/pywrap-cbs1`.

.. rubric:: Not Yet Implemented

* Ground state CI energies and optimizations

* Excited state energies and optimizations

* Properties are not yet regex-ed, transformed into input frame, and
  stowed in PSI Variables.

* Property calls that required extra computation not yet translated into
  :py:func:`~psi4.properties` computation command

* Frequencies

Energy methods available through P4C4 interface

.. include:: cfour_table_energy.rst

Gradient methods available through P4C4 interface

.. include:: cfour_table_grad.rst

.. _`table:cfour_cc_program`:

.. notes on preferred modules from JFS
.. comment always abcdtype = aobasis (but sometimes 
.. comment ncc does rhf ccsdt(q)
.. comment reccommended code to do with, not only code (b/c mrcc can do much of this)
.. comment .. table:: Cfour coupled-cluster program defaults by calculation type
.. comment 
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         |                                 |                       | RHF    | UHF    | ROHF    |
.. comment     |                                         |                                 |                       +--------+--------+---------+
.. comment     | Driver Call, |cfour__cfour_deriv_level| | name, |cfour__cfour_calc_level| | |cfour__cfour_excite| | |cfour__cfour_cc_program| |
.. comment     +=========================================+=================================+=======================+========+========+=========+
.. comment     | :py:func:`~psi4.energy`, zero           | cc2                             | none                  | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | _cc     |
.. comment     |                                         |vcc for everything               +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd                            | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | vcc    | vcc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd(t)                         | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 |        |        |         |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           |        |        |         |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | cc3                             | none                  | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | vcc    | vcc    |         |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           |        |        |         |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsdt (no aobasis sp or opt, also prob for cc3, or for eomea grad) 
.. comment ecc / vcc / vcc
.. comment | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | ecc    | mrcc   | mr_cc   |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomeano/eomipyes      | ecc    |        |         |
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment     | :py:func:`~psi4.optimize`, first        | cc2                             | none                  | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip not sure ask  | vcc  | vcc  | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd                            | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | vcc    | vcc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd(t)                         | none                  | ecc    | ecc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 |        |        |         |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           |        |        |         |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | cc3                             | none                  | vcc    |        |         |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | vcc    |        |         |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | vcc    |        |         |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsdt                           | none                  | ecc    | mrcc   | mrc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | mrcc   | mrcc   | mrcc    |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | mrcc   | mrcc   | mrcc    |
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment properties same as grad
.. comment 2nd deriv ecc only for ccsd(t)

Specification Details
~~~~~~~~~~~~~~~~~~~~~

The above narrative introduction to the P4C4 interface should be
sufficient to get started. Issues of competition between |PSIfour| and
Cfour specification format are generally resolved behind the scenes:
not according to a *simple* rule but according to sensible, sometimes
intricate, rules governed by user intent (and integration of Cfour to
behave like a |PSIfour| module). Much can be gleaned by just running
inputs and inspecting the ``ZMAT`` passed to Cfour, but when questions
arise, here are the specifics, the governing laws.

* Specifying a piece of input in |PSIfour| format is entering into
  a contract that you mean it. In particular this applies to
  molecule (including charge/multiplicity through :samp:`molecule
  {optional_molecule_name} \\{...\\}`), memory (through :samp:`memory
  {value} {unit}`), computational method (through . If Cfour keywords
  are specified with values that contradict the |PSIfour| input,
  execution is halted.

  As an example, the input below is set up to fail in four ways:
  contradictory specification of memory, multiplicity, computational
  method, and derivative level. Note, though, that the ``cfour_units
  angstrom`` setting is permissible, since it concurs with the value
  implied in the molecule block. ::

    memory 300 mb

    molecule {
    H
    H 1 0.7
    }

    set basis 6-31g
    set cfour_multiplicity 3         # clash with implicit singlet in molecule {} above
    set cfour_units angstrom         # no problem, consistent with molecule {} above
    set cfour_memory_size 100000000  # clash with 300 mb above
    set cfour_calc_level ccsd        # clash with 'c4-scf' below
    set cfour_deriv_level first      # clash with energy() below (use gradient('c4-scf') to achieve this)

    energy('c4-scf')

* Specifying anything in |PSIfour| format (molecule, basis, options,
  method call) starts building a ``*CFOUR(...)`` directive for the
  ``ZMAT`` file. Since the contents of the ``cfour {...}`` block are
  blindly appended to any input interpreted from |PSIfour| format, mixing
  of |PSIfour| and Cfour input formats likely *will* give rise to multiple
  ``*CFOUR(...)`` directives in the prospective ``ZMAT``, execution of
  which *will* be trapped and halted.  Proper uses for the ``cfour {...}``
  block are for the sandwich mode, where the entire ``ZMAT`` is enclosed,
  or for extra directives like ``%excite*``, which presently have no other
  specification route.

* Specifying the basis is perhaps the regulated piece of input. Since
  basis set names differ between |PSIfour| and Cfour and it's not
  practical to compare exponent-to-exponent, any input file with both
  |mints__basis| and |cfour__cfour_basis| keywords present will halt. Once
  a basis set has been requested through |mints__basis|, overriding the
  default spherical/Cartesian setting must be done through
  |globals__puream| (as opposed to |cfour__cfour_spherical|).

* Specifying keywords that control geometry optimization is
  straightforward. Unless the optimization is invoked in sandwich mode,
  all Cfour optimization keywords (*e.g.*, |cfour__cfour_geo_maxcyc|) are
  ineffective, as the Cfour optimizer is never invoked. |PSIfour|
  optimization keywords (*e.g.*, |optking__geom_maxiter|) instead fill
  these roles.

* Specifying the computational method (through, for instance,
  ``energy('c4-ccsd')`` instead of ``energy('cfour')``) often
  sets additional keywords consistent with best practices (*e.g.*,
  |cfour__cfour_cc_program|). Since those settings are implicit, any
  explicit setting of those those keywords, whether contradicting or
  concurring, takes priority (halts never generated). The following are
  some concrete examples. For the moment, click the source button at
  muster_modelchem for details of what keywords
  get set.

  * runs in vcc since that's Cfour's default for cc_program ::

      set cfour_calc_level ccsd
      energy('cfour')

  * runs in ecc since Cfour's default overwritten by keyword ::

      set cfour_calc_level ccsd
      set cfour_cc_program ecc
      energy('cfour')

  * runs in ecc since that's best practice for the requested ccsd ::

      energy('c4-ccsd')

  * runs in vcc since *hidden* default overwritten by keyword ::

      set cfour_cc_program vcc
      energy('c4-ccsd')

* Specifying certain keywords that are nominally applicable for pure-\
  |PSIfour| modules directs them to fulfil analogous roles
  in the Cfour program (*e.g.*, |scf__maxiter| is used to set
  |cfour__cfour_scf_maxcyc|). This keyword translation only takes place
  if the keywords are explicitly set in the input file (part of that
  contract that you mean it), meaning that |PSIfours| defaults don't
  get imposed on Cfour. Also, in the case where a translatable pure-\
  |PSIfour| keyword and its translation Cfour keyword are both set,
  the value attached to the latter is always used. Below are a few
  clarifying examples.

  * uses :math:`10^{-7}` SCF conv crit since that's Cfour's default
    for |cfour__cfour_scf_conv| ::

      energy('c4-scf')

  * uses :math:`10^{-6}` SCF conv crit since default overwritten by
    keyword ::

      set cfour_scf_conv 6
      energy('c4-scf')

  * uses :math:`10^{-5}` SCF conv crit since default overwritten by
    :ref:`SCF module<apdx:scf>` keyword ::

      set d_convergence 5
      energy('c4-scf')

  * uses :math:`10^{-6}` SCF conv crit since default overwritten by
    :ref:`SCF module<apdx:scf>` keyword (local scope works, too) where
    the |PSIfours| more flexible float input has been rounded down to
    the integer required by Cfour ::

      set scf d_convergence 5e-6
      energy('c4-scf')

  * uses :math:`10^{-6}` SCF conv crit since default overwritten
    and Cfour module keyword trumps |PSIfour| SCF module keyword ::

      set cfour_scf_conv 6
      set d_convergence 8
      energy('c4-scf')

  The keyword translation feature is still in the proof-of-principle
  stage, so only a handful (found here) of keywords participate.

.. note:: Longtime Cfour users who may consider this keyword
   translation a flaw rather than a feature can avoid it entirely by
   confining keywords to the :ref:`Cfour module<apdx:cfour>` along with
   |mints__basis| and |globals__puream| (opt, too?)

Misc. Running
~~~~~~~~~~~~~

Naturally, in |PSIfour| multiple jobs can be run in succession from the input file.

Control optimizations with optking keywords HERE. Cfour ``GRD`` file is
written to |PSIfour| output file. Gradient transformed back into the frame
in which it was shipped off to Cfour is also written to the |PSIfour|
output file and is available from input as :py:func:`~psi4.core.get_gradient`.

sandwich mode := molecule and cfour list within
Naturally, additional jobs can follow in the input file.
Depending on the nature of preceding or following jobs, it is prudent to
separate them with the following::

    clean()            # removes Psi4 scratch files
    clean_variables()  # empties the PSI variables list
    cfour {}           # empties

In this scheme, the contents of the ``cfour {...}`` block are tacked onto
the end of the ``ZMAT`` file that is otherwise written from psi style
format. It is by this route that, for example ``%excite*`` sections can at
present be specified.

The execution of :program:`xcfour` can be modified by a few parameters.  Setting
the option |cfour__cfour_omp_num_threads| sets the environment variable
:envvar:`OMP_NUM_THREADS` for only the duration of the Cfour computation.
That is, portions of an input file that run |PSIfour| modules are
unaffected.  Additionally, there are a few arguments to the function
:py:func:`~psi4.driver.procrouting.interface_cfour.run_cfour` that control the Cfour scratch
directory. 

.. comment Notes to Self
.. comment ~~~~~~~~~~~~~
.. comment 
.. comment Test checked-in GENBAS on installed copy
.. comment 
.. comment Reference still not factored into cc_program!
.. comment 
.. comment optimize on a sandwich calc? errors out
.. comment 
.. comment 
.. comment .. _`table:cfour_cc_program`:
.. comment 
.. comment .. table:: Cfour coupled-cluster program defaults by calculation type
.. comment 
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         |                                 |                       | RHF    | UHF    | ROHF    |
.. comment     |                                         |                                 |                       +--------+--------+---------+
.. comment     | Driver Call, |cfour__cfour_deriv_level| | name, |cfour__cfour_calc_level| | |cfour__cfour_excite| | |cfour__cfour_cc_program| |
.. comment     +=========================================+=================================+=======================+========+========+=========+
.. comment     | :py:func:`~psi4.energy`, zero           | cc2                             | none                  | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | _cc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd                            | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | ecc    | _cc    | _cc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd(t)                         | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | _cc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | cc3                             | none                  | vcc    | vcc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | _cc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsdt                           | none                  | ecc    | ecc    | ecc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | _cc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | _cc     |
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment     | :py:func:`~psi4.optimize`, first        | cc2                             | none                  | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd                            | none                  | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsd(t)                         | none                  | ecc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | cc3                             | none                  | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | vcc     |
.. comment     |                                         +---------------------------------+-----------------------+--------+--------+---------+
.. comment     |                                         | ccsdt                           | none                  | ecc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomee                 | _cc    | _cc    | vcc     |
.. comment     |                                         |                                 +-----------------------+--------+--------+---------+
.. comment     |                                         |                                 | eomea/eomip           | _cc    | _cc    | vcc     |
.. comment     +-----------------------------------------+---------------------------------+-----------------------+--------+--------+---------+
.. comment 
.. comment 
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:appendices`:

==========
Appendices
==========

Keywords
========

.. toctree::
   :maxdepth: 2

   autodoc_glossary_options_c
   autodoc_options_c_bymodule

Basis Sets
==========

.. toctree::
   :maxdepth: 2

   basissets_tables
   basissets_byelement
   basissets_byfamily

PSI Variables
=============

.. toctree::
   :maxdepth: 2

   glossary_psivariables
   autodoc_psivariables_bymodule

Miscellaneous
=============

.. toctree::
   :maxdepth: 2

   testsuite
   dft_byfunctional
   autodoc_psifiles
   autodoc_physconst
   bibliography

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: DLPNO-MP2

.. _`sec:dlpnomp2`:

DLPNO-MP2: Domain-Based Local Pair Natural Orbital MP2
======================================================

.. codeauthor:: Zach Glick 
.. sectionauthor:: Zach Glick

*Module:* :ref:`Keywords <apdx:dlpno>`, :ref:`PSI Variables <apdx:dlpno_psivar>`, :source:`DLPNOMP2 <psi4/src/psi4/dlpno>`

Introduction
------------

The steep polynomial scaling (in both time and memory) of post-HF dynamic
correlation methods prohibits calculations on large systems, even for efficient
codes like |PSIfours| :ref:`DF-MP2 <sec:dfmp2>`. This poor scaling is in part
due to the use of canonical HF orbitals, which are entirely delocalized across
the molecule. Canonical orbitals are commonly used because of mathematical
convenience. Another possible choice is localized orbitals. Any two orbitals
localized to separate regions of a molecule can be treated as non-interacting
to a good approximation. Thus, when working with localized orbitals, the number
of interacting orbital pairs (and triples, quadruples, etc.) scales linearly
with system size. If carefully implemented, programs that exploit this sparsity
can be made to scale linearly (or else with lower order than their canonical
counterparts) at the cost of of modest, controllable errors. This is the
defining insight of DLPNO-MP2 and all related "local correlation" methods.

The DLPNO-MP2 code is a linear-scaling alternative to the :ref:`DF-MP2 <sec:dfmp2>`
code, and is intended for use with large systems for which DF-MP2 is intractable.
When running DLPNO-MP2 with default settings, approximately 99.9% of the DF-MP2 
correlation energy is recovered. The general outline of the method is as follows:

    (1) Localize the active occupied MOs (with the Foster-Boys method)
    (2) Construct projected AOs (PAOs) from the virtual MOs
    (3) Calculate three-index integrals in the (sparse) LMO/PAO basis
    (4) Perform local density fitting to construct (sparse) exchange integrals
    (5) Transform local virtuals from PAOs to pair natural orbitals (PNOs), and truncate
    (6) Solve the iterative local MP2 equations in the LMO/PNO basis

An example input file is::

   molecule h2o {
   0 1
   O
   H 1 1.0
   H 1 1.0 2 104.5
   symmetry c1
   }
   
   set basis cc-pvdz
   set scf_type df
   set freeze_core True
   set pno_convergence normal
   
   energy('dlpno-mp2')

The main difference between this input and a DF-MP2 input is the ``energy('dlpno-mp2')``
call to :py:func:`~psi4.energy`. The only other addition is the |dlpno__pno_convergence|
keyword, which determines the accuracy of the local approximations underlying 
the DLPNO-MP2 method. Note that the water molecule in this example is not large
enough for DLPNO-MP2 to be of any benefit relative to DF-MP2.

The theory of the DLPNO-MP2 method and practical recommendations for using the
code are presented below. 

.. index::
   pair: DLPNO-MP2; theory

Theory
------

See :ref:`DF-MP2 <sec:dfmp2>` for background on the theory of (non-local)
density-fitted MP2. |PSIfours| DLPNO-MP2 implementation is based on the 
manuscript by Pinski et al. [Pinski:2015:034108]_.

In DLPNO-MP2, as in all local MP2 methods, the second-order MBPT energy is determined 
variationally via the Hylleraas functional [Hylleraas:1930:209]_:

.. math::
   :label: Hylleraas

   E^{(2)} = 2 \langle \Psi_{0}^{(0)} | \hat{H} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle - \langle \Psi_{0}^{(1)} | \hat{H}^{(0)} - E_{0}^{(0)} | \Psi_{0}^{(1)} \rangle = \min_{| \Psi_{0}^{(1)} \rangle}.

Determining the optimal :math:`| \Psi_{0}^{(1)} \rangle` entails iteratively
minimizing the following residual [Pulay:1986:357]_:

.. math::
   :label: Residual

   R_{ij}^{ab} = (ia|jb) + (\epsilon_a + \epsilon_b - f_{ii} - f_{jj})t_{ij}^{ab} - \sum_{k \ne j} f_{ik} \sum_{c,d} S_{ac}t_{kj}^{c,d}S_{db} - \sum_{k \ne i} f_{kj} \sum_{cd} S_{ac}t_{ik}^{cd}S_{db} 

where ``i``, ``j``, and ``k`` are (not necessarily canonical) occupied orbitals, ``a``,
``b``, ``c``, and ``d`` are virtual orbitals, :math:`f_{ij}` are fock matrix elements,
:math:`S_{ab}` are orbital overlaps, and finally :math:`t_{ij}^{ab}` are the MP2
amplitudes to be solved for. Virtual orbitals may be different for each pair
of occupied orbitals. For a given occupied orbital pair ``ij``, all virtuals are
orthogonal and canonical, but virtuals belonging to different pair domains
may not be orthogonal.

The following expression is used to evaluate the energy of a given set of amplitudes:

.. math::
   :label: Energy

   E^{(2)} &= \sum_{i,j} e_{ij}, \\
   e_{ij} &= \sum_{a, b}((ia|jb) + R_{ij}^{ab})(2t_{ij}^{ab} - t_{ij}^{ba}).

The error in :math:`E^{(2)}` scales quadratically with the error in the amplitudes.

No local approximations have been made so far, and this iterative approach can
be used to exactly determine :math:`E^{(2)}` with :math:`{\cal O}(N^5)` cost.
In DLPNO-MP2, the first local approximation is to screen distant, non-interacting
orbital pairs ``ij``. Orbital pairs are screened if below both an overlap criteria:

.. math::
   :label: Differential Overlap Integral

   DOI_{ij} \equiv \sqrt{\int d\mathbf{r} | \chi_{i}(\mathbf{r}) | ^{2} | \chi_{j}(\mathbf{r}) | ^{2}}, 

and a pair energy estimate: 

.. math::
   :label: Dipole Approximation

   e_{ij}^{approx} = -\frac{4}{R^{6}} \sum_{a_{i} \in [i],b_{j} \in [j]} \frac{ (2 \langle i | \mathbf{r} | a_{i} \rangle \langle j | \mathbf{r} | b_{j} \rangle)^{2}}{\epsilon_{a_{i}} + \epsilon_{b_{j}} - f_{ii} - f_{jj}},

in which small domains of virtual orbitals are used for each local MO. As a
result, an asymptotically linear number of ``ij`` pairs enter the local MP2
equations, and the approximate pair energy of neglected pairs is added to
the final energy.

The second major local approximation in DLPNO-MP2 is the truncation of the virtual
space. Initially, exchange integrals are calculated in the LMO/PAO basis using the
standard density fitting approach:

.. math::
   :label: Exchange

   (ia|jb) = \sum_{K,L \in [ij]} (ia|K)[\mathbf{J}^{-1}]_{KL}(L|jb)

This is done with linear scaling effort by exploiting the locality of the LMOs, PAOs,
and auxiliary basis functions.
Solving the iterative local MP2 equations in the LMO/PAO basis requires large PAO
domains to achieve reasonable accuracy. Instead, the virtual space is transformed
into the much more compact pair natural orbital representation. The (approximate)
PNOs diagonalize the virtual-virtual block of the (approximate) MP2 density matrix:

.. math::
   :label: PNOs

   D_{ij}^{ab} = \frac{1}{1 + \delta_{ij}}[\tilde{t}_{ij}^{\dagger}t_{ij} + \tilde{t}_{ij}t_{ij}^{\dagger}]^{ab}

which is constructed from semicanonical amplitudes:

.. math::
   :label: Amplitudes

   t_{ij}^{ab}         &= - \frac{(iajb)}{\epsilon_{a} + \epsilon_{b} - \epsilon_{i} - \epsilon_{j}}, \\
   \tilde{t}_{ij}^{ab} &= 2t_{ij}^{ab} - t_{ij}^{ba}.

PNOs with small occupation numbers are discarded, and the local MP2 equations are
solved in the LMO/PNO basis.

Recommendations
---------------

Some practical notes on running the code:

* DLPNO-MP2 is not a drop-in replacement for DF-MP2. Instead, it should be used for
  large calculations that cannot reasonably be performed with DF-MP2. The crossover
  point between DF-MP2 and DLPNO-MP2 depends on details of both the calculation and
  the hardware, but can be as low as 2,000 basis functions.

* The accuracy of DLPNO-MP2 (relative to DF-MP2) can be controlled with the
  |dlpno__pno_convergence| keyword according to recommendation by Liakos et al.
  [Liakos:2015:1525]_. For non-covalent interactions ``TIGHT`` is highly recommended. 
  
* The greater the spatial sparsity of a molecular system, the smaller the pair
  domains and consequently the faster the calculation. DLPNO-MP2 is much faster
  for linear alkanes than for globular proteins, all else constant.

* Similar to molecular sparsity, the sparsity of the orbital basis affects runtime.
  Diffuse functions increase the size of the pair domains and therefore lead to 
  longer calculations.

* All aspects of DLPNO-MP2 run in core; no disk is required. As a result, the
  code exhibits very good intra-node parallelism, and benefits from many threads.
  The amount of memory needed scales linearly with system size.

* DLPNO-MP2 is not symmetry aware. This should not be a concern for large systems in
  which symmetry is seldom present.

* As with DF-MP2, freezing core orbitals (by setting |globals__freeze_core|
  to ``True``) is recommended for efficiency. In DLPNO methods, this is also
  recommended for accuracy, since core excitations are known to exhibit
  greater errors relative to valence excitations.

* At the moment, the DLPNO-MP2 code is only compatible with with RHF references.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: CI

.. index::
   pair: CI; theory

.. _`sec:ci`:

CI: Configuration Interaction
=============================

.. codeauthor:: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger
.. sectionauthor:: Daniel G. A. Smith and C. David Sherrill

*Module:* :ref:`Keywords <apdx:detci>`, :ref:`PSI Variables <apdx:detci_psivar>`, :source:`DETCI <psi4/src/psi4/detci>`

Configuration interaction (CI) is one of the most general ways to
improve upon Hartree--Fock theory by adding a description of the
correlated motions of electrons.  Simply put, a CI wavefunction
is a linear combination of Slater determinants (or spin-adapted
configuration state functions), with the linear coefficients being
determined variationally via diagonalization of the Hamiltonian in the
given subspace of determinants.  For a "single-reference" CI based
on reference function :math:`| \Phi_0 \rangle`, we can write the CI expansion as
follows:

.. math:: | \Psi \rangle = c_0 | \Phi_0 \rangle
   + \sum_i^{\rm occ} \sum_a^{\rm vir} c_i^a | \Phi_i^a \rangle
   + \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} c_{ij}^{ab} 
   | \Phi_{ij}^{ab} \rangle
   + \sum_{i<j<k}^{\rm occ} \sum_{a<b<c}^{\rm vir} c_{ijk}^{abc}
   | \Phi_{ijk}^{abc} \rangle + \cdots
   :label: CIexpansion

The simplest standard CI method that improves upon Hartree--Fock is a CI
that adds all singly :math:`| \Phi_i^a \rangle` and doubly 
:math:`| \Phi_{ij}^{ab} \rangle`
substituted determinants (CISD) to the reference determinant
:math:`| \Phi_0 \rangle`.  The CISD wavefunction has fallen out of favor
because truncated CI wavefunctions are not size-extensive, meaning
that their quality degrades for larger molecules.  MP2 is a less
expensive alternative giving results similar to those of CISD for small
molecules, but the quality of MP2 does not degrade for larger molecules.
Coupled-cluster singles and doubles (CCSD) is another size-extensive
alternative; it is only slightly more costly computationally than CISD,
but it typically provides significantly more accurate results.

The CI code in |PSIfour| is described in detail in 
[Sherrill:1999:CI]_.  For the reasons stated above, the CI code in
|PSIfour| is not optimized for CISD computations, and it uses data structures
that are particularly inefficient for CISD and may result in the program
running out of memory and crashing for CISD except on very small molecules.
Instead, DETCI was designed to be efficient
in handling more highly correlated CI wavefunctions that can be helpful in more 
challenging cases such as highly strained molecules or bond breaking reactions.  The CI
code is based on the fast, determinant-based string formalism
of Handy [Handy:1980]_.  It can solve for restricted active space
configuration interaction (RAS CI) wavefunctions as described by Olsen,
Roos, Jorgensen, and Aa. Jensen [Olsen:1988]_.  Excitation-class
selected multi-reference CI wavefunctions, such as second-order CI,
can be formulated as RAS CI's.  A RAS CI selects determinants for the
model space as those which have no more than :math:`n` holes in the lowest set
of orbitals (called RAS I) and no more than :math:`m` electrons in the highest
set of orbitals (called RAS III).  An intermediate set of orbitals, if
present (RAS II), has no restrictions placed upon it.  All determinants
satisfying these rules are included in the RAS CI.

The DETCI module is also very efficient at computing full configuration
interaction
wavefunctions, and it is used in this capacity in the complete-active-space
self-consistent-field (CASSCF) code.  It can also perform approximate
CASSCF computations in which one uses RAS restrictions on the CI excitations,
rather than doing a full CI in the active space.  This is called a 
RASSCF.  CASSCF and RASSCF computations are types of multi-configurational
self-consistent-field procedures, and are described in :ref:`sec:mcscf`.

As mentioned above, the DETCI module is designed for challenging
chemical systems for which simple CISD is not suitable.  Because
CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,
typically the DETCI code will be used in cases where the
tradeoffs between computational expense and completeness of the
model space are nontrivial.  Hence, the user is advised to develop
a good working knowledge of multi-reference and RAS CI methods before
attempting to use the program for a production-level project.  This user's
manual will provide only an elementary introduction to the most
important keywords.  Additional information is available in the complete
list of keywords for DETCI provided in Appendix :ref:`apdx:detci`.

For single-reference CI computations, the easiest way to invoke a CI
computation with DETCI is simply to call :py:func:`~psi4.energy`, :py:func:`~psi4.optimize`, *etc.*,
with the common name for that CI wavefunction, like ``energy('cisd')`` 
for a CISD single-point energy.  The Python driver
recognizes ``cisd``, ``cisdt``, and ``cisdtq``.  As mentioned above, codes
written specifically for CISD will be more efficient than DETCI for a 
CISD computation, and ``energy('cisd')`` by default will call other,
more efficient modules.  To force a CISD computation with DETCI,
set |globals__qc_module| = DETCI.  

Higher order single-reference CI wavefunctions, like those including singles through
6-fold excitations, can be invoked using numbers, like ``ci6``.  A full
CI can be specified by ``fci``.  More complicated CI computations, like
RASCI, can be performed by setting the appropriate keywords and calling the
module generically like ``energy('detci')``.  The latter approach
will also work for any of the previously-mentioned CI wavefunctions for
which the driver has built-in shortcuts, so long as the relevant options
(especially |detci__ex_level|) are set appropriately.  Some
examples of single-refence CI, RASCI, and full CI computations are provided
in :source:`samples`.

.. _`table:ci_spaces`:

.. table:: Orbital spaces for CI computations

    +----------------------------+----------------------------+-------------------------------+
    | CI (e.g., CISD, FCI)       | RASCI                      | CASCI                         |
    +============================+============================+===============================+
    | |globals__frozen_uocc|     | |globals__frozen_uocc|     | |globals__frozen_uocc| [#f1]_ |
    +----------------------------+----------------------------+-------------------------------+
    | (all orbitals not in       | |globals__ras4|            |                               |
    + |globals__frozen_uocc|     +----------------------------+                               +
    | or |globals__frozen_docc|  | |globals__ras3|            |                               |
    + are included in CI)        +----------------------------+                               +
    |                            | |globals__ras2|            |                               |
    +                            +----------------------------+                               +
    |                            | |globals__ras1|            | |globals__active|             |
    +----------------------------+----------------------------+-------------------------------+
    | |globals__frozen_docc|     | |globals__frozen_docc|     | |globals__frozen_docc|        |
    +----------------------------+----------------------------+-------------------------------+

.. [#f1] |globals__frozen_uocc| is not required and will be inferred if 
   |globals__active| is provided.  However, if it is easier to specify
   |globals__frozen_uocc|, then this may be provided and |globals__active| can
   be inferred.

The table above shows the relevant orbitals spaces for CI computations (an
analogous :ref:`table <table:mcscf_spaces>` for MCSCF is also available).  
The third column of the
table refers to CASCI, in which a full CI is performed in some smaller
set of ``active`` orbitals; it is equivalent to CASSCF except without
any orbital optimization.  It can be invoked via ``energy('fci')``
with appropriate values selected for |globals__frozen_docc| and
|globals__active|.  For CI computations, there is no difference between
|globals__frozen_docc| and |globals__restricted_docc|, or between
|globals__frozen_uocc| and |globals__restricted_uocc|.  There are
differences between these keywords for :ref:`sec:mcscf`.

.. index:: CI; basic-keywords

Basic DETCI Keywords
~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/detci__reference.rst
.. include:: autodir_options_c/detci__r_convergence.rst
.. include:: autodir_options_c/detci__ex_level.rst
.. include:: autodir_options_c/detci__fci.rst
.. include:: autodir_options_c/globals__frozen_docc.rst
.. include:: autodir_options_c/globals__restricted_docc.rst
.. include:: autodir_options_c/globals__restricted_uocc.rst
.. include:: autodir_options_c/globals__frozen_uocc.rst
.. include:: autodir_options_c/detci__ci_maxiter.rst
.. include:: autodir_options_c/detci__num_roots.rst
.. include:: autodir_options_c/detci__icore.rst
.. include:: autodir_options_c/detci__diag_method.rst
.. include:: autodir_options_c/detci__opdm.rst
.. include:: autodir_options_c/detci__tdm.rst
.. include:: autodir_options_c/detci__dipmom.rst
.. include:: autodir_options_c/detci__mpn.rst

For larger computations, additional keywords may be required, as
described in the DETCI section of the Appendix :ref:`apdx:detci`.

.. index:: 
   pair: CI; spin multiplicities of higher roots

Spin Multiplicities of Higher Roots
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As mentioned above, DETCI works in a basis of Slater determinants, rather than
configuration state functions.  The correct value of :math:`M_s` is easily enforced
by fixing the number of alpha and beta electrons to be constant across all determinants 
selected for the CI computation.  However, determinant-based codes like DETCI do
not necessarily enforce the correct spin :math:`S`.  For example, diagonalizing the
Hamiltonian in a space spanned by determinants with :math:`M_s = 0` can yield 
both singlet and triplet solutions, because triplets (:math:`S = 1`) also have an
:math:`M_s = 0` component.  (Indeed, even higher spin multiplicities may be encountered
if the excitation level is high enough).  For closed-shell references with :math:`M_s = 0`,
the program will assume by default that a singlet (:math:`S = 0`) computation is desired,
and will utilize alpha/beta interchange symmetries to speed up the computation 
(this is controlled by the advanced keyword |detci__ms0|, which defaults to ``TRUE``).
Thus, if a user requests multiple roots (|detci__num_roots| = :math:`n`), the program
will typically return singlets and not triplets.  However, if enough roots are sought,
higher-multiplicities may enter in.  This can be avoided by ensuring that all the guess
vectors have the correct spin multiplicity, by setting |detci__calc_s_squared| to ``TRUE``).
It is also possible to ask DETCI to compute roots of higher multiplicities.  The desired value of spin may be
provided by setting |detci__S| = :math:`S`.  Typically, it would be a good idea in this context to also set
|detci__calc_s_squared| to ``TRUE`` to ensure the guess roots have the right spin.  However, be advised that
seeking these higher roots may cause convergence problems, because roundoff may allow the lower-lying
roots of lower multiplicities to re-enter the computation (reducing convergence criteria may help).

For open-shell systems, the |detci__ms0| keyword is typically not relevant, and there
is no control over spin multiplicities of higher roots unless|detci__calc_s_squared| is
used.

.. index:: 
   pair: CI; arbitrary-order perturbation theory

.. _`sec:arbpt`:

Arbitrary Order Perturbation Theory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The DETCI module is capable of computing energies for arbitrary
order |MollerPlesset| perturbation theory (MPn, for closed-shell
systems with an RHF reference) and for Z-averaged perturbation theory
(ZAPTn, open-shell systems with a ROHF reference). However, please
note that these computations are essentially doing high-order CI (up to
full CI) computations to obtain these results, and hence they will only
be possible for very small systems (generally a dozen electrons or less).

The simplest way to run high-order perturbation theory computations is to
call, *e.g.*, ``energy('mp10')`` to invoke a MP10 computation or
``energy('zapt25')`` to invoke a ZAPT25 computation.  This will
automatically set several additional user options to their appropriate
values.  The program uses the Wigner (2n+1) rule to obtain higher-order
energies from lower-order wavefunctions.

For the interested reader, the additional user options that are
automatically set up by the calls above are as follows.  A call like
``energy('mp10')`` sets |detci__mpn| to TRUE.
The program uses the Wigner (2n+1) rule by default
(|detci__mpn_wigner| = TRUE)
and figures out what order of wavefunction is
necessary to reach the desired order in the energy.  The program then
sets |detci__max_num_vecs| to the required order in the
wavefunction.
By default, the requested n-th order energy is saved as the current
energy to the process environment.   ZAPTN works essentially the same
way for an ROHF reference.

.. index:: 
   pair: CI; arbitrary-order coupled-cluster theory

Arbitrary Order Coupled-Cluster Theory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*This DETCI-based version of this feature is not yet released.  However,
the current version of the code does include an interface to*
:ref:`Kallay's MRCC <sec:mrcc>` *code.*

The DETCI module is also capable of computing arbitrary-order
coupled-cluster energies, using an approach similar to that of Hirata
and Bartlett [Hirata:2000:216]_, or of Olsen [Olsen:2000:7140]_.
Notably, the approach in DETCI also allows arbitrary-order 
*active space* coupled-cluster procedures.  The general algorithm
for doing this in DETCI is inefficient compared to optimized
lower-order coupled-cluster codes and should not be used for CCSD,
where the CCENERGY module is much more efficient.  For higher-order
CC (like CCSDT and beyond), the code is also not as efficient as the
MRCC code by K\ |a_acute|\ llay, to which |PSIfour| can interface (see Section
:ref:`sec:mrcc`); however, it may allow certain truncations of the model
space that might not be available presently in MRCC.  For very small
systems, the code can be useful for testing of, for example, CCSDTQ or
its active-space CCSDtq analog [Piecuch:1999:6103]_.

To perform arbitrary-order coupled-cluster, set the DETCI
option |detci__cc| to TRUE, and set
|detci__cc_ex_level| (note: not |detci__ex_level|)
to the desired coupled-cluster excitation level, and invoke 
``energy('detci')``.  Various other DETCI options have a similar
option for coupled-cluster, usually named beginning with CC.  The full
list of options is given in Appendix :ref:`apdx:detci`.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_tour`:

==========================================================
General layout of the core: where new C++ code should live
==========================================================

New integral operators
----------------------

Most of the heavy lifting in |PSIfour| is handled by libmints, which can be
found in the :source:`psi4/src/psi4/libmints` directory.  New types of one- and
two-electron integral operators should be added here.  The Wavefunction class
:source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key
part of the infrastructure.  Every energy calculation is performed by a class
that derives from Wavefunction and is accessible as a return value in the
Python layer.  The Wavefunction class contains all pertinent calculation
results, such as one-particle densities, molecular orbitals and gradients.

Completely new methods
----------------------

A new method that is not a modification of existing code belongs in its own
folder in :source:`psi4/src/psi4`; see other folders in that exist in that
location for examples of setting up CMake, and make sure that the new folder is
added to :source:`psi4/src/psi4/CMakeLists.txt`.  There are also a number of
variables that can be exported to be available to the user, as detailed in
:ref:`sec:psiVariables`.  To set these variables, the following member of
Wavefunction should be called::

    set_variable("Variable Name", variable_value);

The new variable should also be documented in
:source:`doc/sphinxman/source/glossary_psivariables.rst`.  There are a
number of different helpers to export various quantities from the wavefunction
to external formats such as FCHK and MOLDEN.  Because the Wavefunction makes
its members available to the Python layer, any other similar export functions
should be written in python.

Integral consuming technologies
-------------------------------

The general philosophy in |PSIfour| is to try write two-electron integral
driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized
Fock-like matrices.  From here, a single class can be used to construct these
generalized Fock matrices, which is what libFock
(:source:`psi4/src/psi4/libfock`) accomplishes.  A number of integral
technologies -- such as integral-direct, disk-based and density fitting -- are
supported in libFock, making them generally available to all elements of the
code that use the generalized Fock matrix strategy.

.. _`sec:prog_tour-exposing`:

Exposing C++ code to Python
---------------------------

The recent push to move sections of the code that are not a bottleneck into the
Python layer requires that the C++ code is callable from Python and that its
results are accessible.  The result accessibility is addressed by populating
the appropriate variables in the Wavefunction object.  To make the code
callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library
to create the bindings.  Existing code to export various |PSIfour| classes can
be found in :source:`psi4/src` in the files whose name begins with `export_`.
The code to export functions that run entire calculations is usually found in
:source:`psi4/src/core.cc`.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:psithonFunc`:

=========================================
Psithon Functions: Invoking a Calculation
=========================================

To allow arbitrarily complex computations to be performed, |PSIfour| is built
upon the Python interpreter, with modifications termed Psithon. Sec. 
:ref:`sec:psithonInput` describes the non-standard Python associated with
clean molecule, basis, and option specification in the |PSIfour| input file.
This documentation addresses the pure Python side- what functions allow
the efficient compiled code to be run, what functions post-process and
interact with that output, and how the ordinary (or ambitious) user can
extent |PSIfours| functionality.

.. toctree::
   :maxdepth: 2

   notes_py
   energy
   prop
   nbody
   opt
   freq
   db
   cbs
   diatomic
   intercalls
   sowreap
   cubeprop

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: 
   DMA
   GDMA
   Distributed Multipole Analysis

.. _`sec:gdma`:

Interface to GDMA Distributed Multipole Analysis by A. J. Stone |w---w| :py:func:`~psi4.gdma`
=============================================================================================

.. codeauthor:: Anthony J. Stone, Andrew C. Simmonett
.. sectionauthor:: Andrew C. Simmonett

*Module:* :ref:`Keywords <apdx:gdma>`, :ref:`PSI Variables <apdx:gdma_psivar>`, :source:`GDMA_INTERFACE<psi4/src/psi4/gdma_interface>`

.. image:: https://img.shields.io/badge/home-gdma-5077AB.svg
   :target: https://github.com/psi4/gdma

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://www-stone.ch.cam.ac.uk/documentation/gdma/manual.pdf

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/gdma/badges/version.svg
     :target: https://anaconda.org/psi4/gdma

* GDMA is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, gdma has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  gdma can be obtained through ``conda install gdma -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_gdma`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect gdma and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   gdma from conda without thinking, consult.

* To remove a conda installation, ``conda remove gdma``.

**Source**

* .. image:: https://img.shields.io/github/tag/psi4/gdma.svg?maxAge=2592000
     :target: https://github.com/psi4/gdma

* If using |PSIfour| built from source and you want gdma built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_gdma`,
  and let the build system fetch and build it and activate dependent code.

Input
~~~~~

The distributed multipole analysis (DMA) technique, developed by Anthony J.
Stone and implemented by him into the `GDMA package
<http://www-stone.ch.cam.ac.uk/programs.html>`_, is available in |PSIfour|.
The current implementation simply embeds Stone's GDMA code into the main
executable, and generates the appropriate input files automatically.  The
program takes as input a data file, and a Gaussian formatted checkpoint (see
Section :ref:`FCHK <sec:fchk>`) file.  The simplest usage of the GDMA code is
demonstrated below, along with a listing of the options supported; these
options correspond to the options described in the 
:download:`GDMA manual <gdma-2.2.06.pdf>`.

If more advanced usage is desired, which is not is permitted by the options
listed below, the user may provide their own data file containing keywords to
control the GDMA code.  Simply place the data file in the directory |PSIfour|
is called from, and provide the file name as the datafile argument to the
:py:func:`~psi4.gdma` routine.  For example, if GDMA data file is called
*control.dma*, the GDMA code is called as follows::

    grad, wfn = gradient('mp2', return_wfn=True)
    gdma(wfn, datafile='control.dma')

An FCHK file will be generated for the GDMA code to read; this file will have
the prefix given by |globals__writer_file_label| (if set), or else by the name
of the output file plus the name of the current molecule, and the suffix will
be '.fchk'.  This FCHK file name should be passed to the 'File' keyword in the
DGMA data file, to ensure that the GDMA code reads the correct wavefunction
information.

After running, two matrices of results can be accessed::

    dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES')
    tot_results = get_array_variable('DMA TOTAL MULTIPOLES')

The first contains distributed multipoles, in units given by
|gdma__gdma_multipole_units|, with the row index corresponding to the site and
the column index referencing the multipole component.  Both indices are zero
based, and the :math:`Q^l_m` components of the multipoles are ordered as
:math:`Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},
Q^2_{2s}, \ldots`  The second matrix returned has a single row, whose columns
are the total multipoles, translated to |gdma__gdma_origin|, and summed.


.. autofunction:: psi4.gdma(wfn)
   :noindex:

Options
~~~~~~~

.. include:: autodir_options_c/gdma__gdma_limit.rst
.. include:: autodir_options_c/gdma__gdma_origin.rst
.. include:: autodir_options_c/gdma__gdma_multipole_units.rst
.. include:: autodir_options_c/gdma__gdma_radius.rst
.. include:: autodir_options_c/gdma__gdma_switch.rst

.. _`cmake:gdma`:

How to configure gdma for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, GDMA is a library that provides additional
  quantum chemical capabilities (multipole analysis).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) gdma

* Upstream Dependencies |w---w| gdma |dr| Fortran

**CMake Variables**

* :makevar:`ENABLE_gdma` |w---w| CMake variable toggling whether Psi4 builds with gdma
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing ``include/GDMA/GDMA_MANGLE.h``
* :makevar:`gdma_DIR` |w---w| CMake variable to specify where pre-built gdma can be found. Set to installation directory containing ``share/cmake/gdma/gdmaConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_gdma` |w---w| CMake variable to force internal build of gdma instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_gdma` |w---w| CMake variable to force detecting pre-built gdma and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_gdma=ON

B. Build *without* gdma

  .. code-block:: bash

    >>> cmake

C. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root

  .. code-block:: bash

    >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir

D. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; optimize()
   pair: geometry optimization; function call
   pair: gradient; function call
   see: opt(); optimize()

.. _`sec:opt()`:

Geometry Optimization |w---w| :py:func:`~psi4.optimize` and :py:func:`~psi4.gradient`
=====================================================================================

* :ref:`Psi4 Native Gradient Methods <table:grad_gen>`
* :ref:`Psi4 Native DFT Gradient Methods (excepting double-hybrids) <table:grad_gen>`
* :ref:`CFOUR Interfaced Gradient Methods <table:grad_cfour>`

For further discussion of geometry optimization, see
Sec. :ref:`sec:optking`.

:py:func:`~psi4.optimize` is the only command most users will ever
need to access directly to perform geometry optimizations. Behind
the scenes, :py:func:`~psi4.optimize` is a wrapper that repeatedly
calls :py:func:`~psi4.gradient` that computes the gradient then adds a
call to the :ref:`geometry optimization module <sec:optking>`.

.. autofunction:: psi4.optimize(name [, molecule, return_wfn, func, mode, dertype, hessian_with])
   :noindex:

.. autofunction:: psi4.gradient(name [, molecule, return_wfn, func, dertype])
   :noindex:

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. Psithon documentation master file, created by
   sphinx-quickstart on Sun Feb 12 04:25:25 2012.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

==========================================
|PSIfour|\ : Open-Source Quantum Chemistry
==========================================

.. toctree::
   :maxdepth: 2
   
   introduction
   external
   index_tutorials
   psithoninput
   methods
   interfacing
   psithonfunc
   customizing

.. toctree::
   :maxdepth: 3

   appendices

===================
Programmers' Manual
===================

.. toctree::
   :maxdepth: 2

   prog_intro
   prog_newcode
   prog_corelibs
   prog_integrals
   add_tests
   prog_debug_profile
   documentation
   code_style
   psipep
   manage_index
   psi4api
   external_apis

* Indices

 - :ref:`genindex`
 - :ref:`modindex`
 - :ref:`search`

.. comment  autodoc_available_plugins
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: PSI4FOCKCI

.. _`sec:fockci`:

Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA
===========================================================

.. codeauthor:: Shannon E. Houck
.. sectionauthor:: Shannon E. Houck

.. image:: https://img.shields.io/badge/home-psi4fockci-5077AB.svg
   :target: https://github.com/shannonhouck/psi4fockci

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://shannonhouck.github.io/psi4fockci/build/index.html

This plugin is an implementation of the RAS-nSF-IP/EA approach detailed 
in the paper by Houck et. al. [Houck:2019:2278]_. 
This approach handles systems with both spin and spatial degeneracies 
by combining the spin-flip (SF) [Krylov:2001:522]_
and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ 
approaches. 

The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization 
potential (IP), and electron affinity (EA) calculations, as well as 
combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module.

Installation
~~~~~~~~~~~~

* Download the plugin from the GitHub repository:

  .. code-block:: bash

     >>> git clone https://github.com/shannonhouck/psi4fockci.git

* Once downloaded, the plugin can be installed as follows:

  .. code-block:: bash

     >>> cd {top-level-psi4fockci-directory}
     >>> python -m pip install .

Sample Input
~~~~~~~~~~~~

To run a CAS-nSF-IP/EA calculation, start with a molecule with the 
correct charge and multiplicity for the reference state (i.e. some 
state well-represented by a single reference). Then, run an energy 
calculation, passing in the charge and multiplicity of the 
desired state; the number of spin-flips and IP/EA will be automatically 
determined based on this input. If additional excitations outside of the 
RAS II space are desired, one can set the level of external 
excitations using the ``conf_space`` keyword.

A sample input file for a RAS(h)-2SF-IP calculation is shown below:

.. code-block:: python

    molecule {
    0 7
    N 0.0 0.0 0.0
    N 0.0 0.0 1.3
    symmetry c1
    }

    set {
      basis cc-pVDZ
    }

    energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space="h")
    
Note that for calculations involving IP/EA, inclusion of hole (for IP) and 
particle (for EA) excitations is strongly recommended. Additional keywords 
can be found in the documentation.

This input file can be run with Psi4:

.. code-block:: bash

   >>> psi4 input.dat


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; frequency()
   pair: vibrational analysis; function call
   pair: hessian; function call
   see: freq(); frequency();
   see: frequencies(); frequency();

.. _`sec:freq()`:

Harmonic Vibrational Analysis and Visualization of Normal Modes |w---w| :py:func:`~psi4.frequency` and :py:func:`~psi4.hessian`
===============================================================================================================================

* :ref:`Psi4 Native Hessian Methods <table:freq_gen>`

For further discussion of vibrational and thermochemical analysis,
see Sec. :ref:`sec:thermo`.

:py:func:`~psi4.frequency` is the only command most users will ever
need to access directly to perform frequency calculations. Behind
the scenes, :py:func:`~psi4.frequency` is a light wrapper over
:py:func:`~psi4.hessian` that computes the Hessian then adds a
thermochemical analysis.

.. autofunction:: psi4.frequency(name [, molecule, return_wfn, func, mode, dertype, irrep])
   :noindex:

.. autofunction:: psi4.hessian(name [, molecule, return_wfn, func, dertype, irrep])
   :noindex:

It's handy to collect the wavefunction after a frequency
calculation through ``e, wfn = psi4.frequency(...,
return_wfn=True)`` as the frequencies can be accessed through
:py:func:`psi4.core.Wavefunction.frequencies()`, the Hessian through
:py:func:`psi4.core.Wavefunction.hessian()`, and much other computation
info through ``psi4.core.Wavefunction.frequency_analysis``
(note no parentheses). Examples of using this data
structure can be found :srcsample:`fd-freq-gradient` and
:source:`tests/pytests/test_vibanalysis.py`. Formatted printing of vibrational
results is available through :py:func:`psi4.driver.qcdb.vib.print_vibs`.

.. _`table:frequency_analysis`:

.. table:: Results accessible through ``psi4.core.Wavefunction.frequency_analysis``

    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | key           | description (lbl & comment)                | units     | data (real/imaginary modes)                          |
    +===============+============================================+===========+======================================================+
    | omega         | frequency                                  | cm^-1     | ndarray(ndof) complex (real/imag)                    |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | q             | normal mode, normalized mass-weighted      | a0 u^1/2  | ndarray(ndof, ndof) float                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | w             | normal mode, un-mass-weighted              | a0        | ndarray(ndof, ndof) float                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | x             | normal mode, normalized un-mass-weighted   | a0        | ndarray(ndof, ndof) float                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | degeneracy    | degree of degeneracy                       |           | ndarray(ndof) int                                    |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | TRV           | translation/rotation/vibration             |           | ndarray(ndof) str 'TR' or 'V' or '-' for partial     |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | gamma         | irreducible representation                 |           | ndarray(ndof) str irrep or None if unclassifiable    |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | mu            | reduced mass                               | u         | ndarray(ndof) float (+/+)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | k             | force constant                             | mDyne/A   | ndarray(ndof) float (+/-)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | DQ0           | RMS deviation v=0                          | a0 u^1/2  | ndarray(ndof) float (+/0)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | Qtp0          | Turning point v=0                          | a0 u^1/2  | ndarray(ndof) float (+/0)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | Xtp0          | Turning point v=0                          | a0        | ndarray(ndof) float (+/0)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+
    | theta_vib     | char temp                                  | K         | ndarray(ndof) float (+/0)                            |
    +---------------+--------------------------------------------+-----------+------------------------------------------------------+


Visualization of Normal Modes
-----------------------------

|PSIfour| has the ability to export a Molden file that stores information about
the harmonic frequencies and normal modes computed via :py:func:`~psi4.frequency`.
This feature can be enabled by setting the option |findif__normal_modes_write| to true.
The filename of the Molden file ends in ``.molden_normal_modes``, and the prefix is
determined by |globals__writer_file_label| (if set), or else by the name of the
output file plus the name of the current molecule.
The normal coordinates saved in the Molden file are normalized and are not
mass weighted.

Molden Interface Keywords
~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/findif__normal_modes_write.rst

.. include:: autodir_options_c/globals__writer_file_label.rst


.. automodapi:: psi4.driver.qcdb.vib
   :headings: -~

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   relativistic

.. _`sec:relativistic`:

Scalar relativistic Hamiltonians
================================

.. codeauthor:: Prakash Verma and Francesco A. Evangelista
.. sectionauthor:: Prakash Verma, Wallace D. Derricotte, and Francesco A. Evangelista

The exact-two-component (X2C) approach is a convenient way to introduce scalar
relativistic effects in DFT and wave function-based methods.
|PSIfour| implements the spin-free one-electron version of X2C, which produces
a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:

.. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}

that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy
(:math:`V_{\rm X2C}`) operator.
Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.
X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic
calculations.  Common choices include the Dunning Douglass--Kroll basis sets
(cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets.

.. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian.

.. _`sec:ScalarRelativistic`:

A First Example
^^^^^^^^^^^^^^^

The following is a simple input that will perform a Hartree--Fock calculation
using the X2C Hamiltonian. ::

    molecule {
      H
      F 1 0.92
    }

    set {
        scf_type pk
        basis cc-pvdz
        relativistic x2c
    }

    energy('hf')

This computation yields the following result::

  @RHF Final Energy:  -100.10007984692388

   => Energetics <=

    Nuclear Repulsion Energy =              5.1767335622934780
    One-Electron Energy =                -150.7611816259664579
    Two-Electron Energy =                  45.4843682167491039
    Total Energy =                       -100.1000798469238902

while a non-relativistic calculation yields the following energy::

  @RHF Final Energy:  -100.01928891411315

   => Energetics <=

    Nuclear Repulsion Energy =              5.1767335622934780
    One-Electron Energy =                -150.6645256529074572
    Two-Electron Energy =                  45.4685031765008461
    Total Energy =                       -100.0192889141131474

Basis sets options
^^^^^^^^^^^^^^^^^^

The X2C module in |PSIfour| supports different combinations of basis set.
By default, if the input file specifies only |mints__basis|, then the X2C
module will solve the modified Dirac equation in an uncontracted basis and then
recontract the X2C Hamiltonian in the original basis.
Alternatively, the user can use |globals__basis_relativistic| to specify a different
basis set to solve the modified Dirac equation. ::

    set {
        basis cc-pvdz-dk
        basis_relativistic cc-pvtz-dk
        relativistic x2c
    }

It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully
decontracted basis set. This can be done simply in the input by adding "-decon" to the 
name of the primary basis you want to use for the calculation as detailed in 
:ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use 
of X2C should cite the following publication: [Verma:2015]_


Theory
^^^^^^

X2C is based on exact decoupling of 
positive-energy ( :math:`h^{FW}_{\rm ++}`
) and negative-energy (:math:`h^{FW}_{\rm --}` )
blocks of the Dirac Hamiltonian (:math:`h^{D}`). 

.. math:: 
   U^\dagger h^{\rm D} U = 
   U^\dagger
   \begin{pmatrix}
   h_{LL} & h_{LS} \\
   h_{SL} & h_{SS}
   \end{pmatrix}
   U
   =
  \begin{pmatrix}
  h^{\rm FW}_{++} & 0 \\
  0 & h^{\rm FW}_{--}
  \end{pmatrix}

The transformation ( :math:`U` ) is  obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. 
In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` )
is given by the sum
of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.
Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`).  

.. math::
  T_{\rm X2C} = R^{\dagger} (TX +  {X}^{\dagger}T - {X}^{\dagger}TX ) R 

.. math::
  V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R

The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.
The renormalization matrix 
:math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,
depends on the modified overlap matrix
:math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.
Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects
treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding
X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis.

Keywords
~~~~~~~~

.. include:: autodir_options_c/globals__relativistic.rst
.. include:: autodir_options_c/globals__basis_relativistic.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: 
   FCHK
   Gaussian Formatted Checkpoint

.. _`sec:fchk`:

Interface to programs through FCHK files |w---w| :py:func:`~psi4.fchk()`
========================================================================

.. codeauthor:: Andrew C. Simmonett
.. sectionauthor:: Andrew C. Simmonett

Many post-processing tools can read information from `Gaussian's formatted
checkpoint (FCHK) files <https://gaussian.com/formchk/>`_.
To allow interoperability with such tools, |PSIfour| includes a utility to
generate FCHK files.  Wavefunction information, such as orbitals, densities,
orbital energies and basis set information is currently supported, but geometry
optimization and vibrational frequency information are not supported at this
time.  To generate a FCHK file, simply store the wavefunction from the energy
calculation, and hand it to the fchk driver function::

    energy, wfn = energy('scf', return_wfn=True)
    fchk(wfn,'output.fchk')

The file will be written to the name passed to the fchk function.
Note that for MP2 and CCSD methods, the energy can be computed without
the expensive steps required to compute the density, so energy calls for these
methods will return a wavefunction that has the Hartree--Fock density.  If a
density is required for these methods, the user should instead request a
gradient computation, to ensure that the density is updated appropriately::

    grad, wfn = gradient('mp2', return_wfn=True)
    fchk(wfn,'output.fchk')


.. autofunction:: psi4.fchk(wfn, filename)
   :noindex:

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   pair: database(); adding new

.. _`sec:createDatabase`:

Creating a Database
===================

.. note:: No recompile of the PSI program is necessary for changes made to
    files in ``$PSIDATADIR``, including those described below.

A necessary consideration in constructing a database is the distinction
between reagents and reactions. A reagent is a single molecular system
(may be a dimer) whose geometry you are possession of and whose electronic
energy may be of interest. A reaction is a combination of one or more
reagent energies whose value you are interested in and a reference value
for which you may or may not be in possession of. A few examples follow.
In a database of interaction energies, the reagents are dimers and their
component monomers (usually derived from the dimer geometry), and the
reactions are the dimer less monomers energies. In a database of barrier
heights, the reagents are reactants, products, and transition-state
structures, and the reactions are the transition-states less
minimum-energy structures. Possibly you may have a collection of
structures to simply be acted upon in parallel, in which case the
structures are both the reagents and the reactions. The role of the
database.py file is to collect arrays and dictionaries that define the
geometries of reagents (GEOS), their combination into reactions (RXNM &
ACTV), available reference values for reactions (BIND), and brief comments
for reagents and reactions (TAGL). The journey from reagent geometries to
functional database.py file is largely automated, in a process described
below.

* Prepare geometry files
    Assemble xyz files for all intended reagent systems in a directory.
    Follow the rules below for best results. The filename for each xyz
    file should be the name of the system. lowercase or MixedCase is
    preferable (according to Sherrill lab convention). Avoid dashes and
    dots in the name as python won't allow them. If you're determined to
    have dashes and dots, they must be replaced by other characters in the
    process_input line, then translated back in the GEOS section; see
    NBC10.py for an example.

    - The first line for each xyz file should be the number of atoms in the system.

    - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).

    - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form).  For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step.

* Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`

    Move into the directory where all your xyz files are located. Run the
    script. It will ask a number of
    questions about your intended database and generate a python file
    named for your database. Uppercase is preferable for database names
    (according to Sherrill lab convention). Note your choice for the route
    variable for the next step.

* Edit file database.py

    According to your responses in to questions in the ixyz2database.py script,
    several bullets will be printed of edits you necessarily or optionally
    should make. Copy your new database into :source:`psi4/share/psi4/databases`.
    Alternately, append the directory containing your new database into
    :envvar:`PSIPATH`.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:introduction`:

============
Introduction
============

Overview
========

|PSIfour| provides a wide variety of quantum chemical methods using
state-of-the-art numerical methods and algorithms.  Several parts of
the code feature shared-memory parallelization to run efficiently on
multi-core machines (see Sec. :ref:`sec:threading`).
An advanced parser written in Python allows the user
input to have a very simple style for routine computations, but it can also
automate very complex tasks with ease.

|PSIfour| is, in many ways, a whole new package compared to Psi3.
While some libraries and modules remain the same, the majority of the code has
been rewritten from scratch based on a powerful set of new libraries written
in C++.  A totally new Python front-end makes |PSIfour| incredibly user-friendly
and automates many common tasks such as basis set extrapolation, composite
methods, running the same computation on every molecule in a test set, etc.
Density-functional theory, absent in Psi3, is quite efficient
in |PSIfour|, with many functionals available.  Density fitting is ubiquitous in
|PSIfour|, leading to some of the most efficient MP2 and CCSD(T) code available.
|PSIfour| also introduces extensive,
powerful features for energy component analysis of non-covalent interactions
via symmetry-adapted perturbation theory.  Orbital-optimized versions of
perturbation theory and coupled-cluster methods, and their analytic gradients,
have also been added.  Through external libraries, |PSIfour| gains access to implicit
solvent (PCM) capabilities, density-matrix renormalization group CI, effective
fragment potentials, Grimme dispersion corrections, and high-order
coupled-cluster theory.

In this section, we provide an overview of some of the features of
|PSIfour| along with the prerequisite steps for running calculations.
Sec. :ref:`Tutorial <sec:tutorial>` provides a brief tutorial to help new users
get started.  Section :ref:`Psithon <sec:psithonInput>` offers further details into the
structure of |PSIfour| input files and how Python can be mixed with
quantum chemistry directives in |PSIfour|. Section :ref:`Psithon Functions <sec:psithonFunc>`
provides more detail on the Python functions provided by |PSIfour|
and discusses some of the higher-level functions such as counterpoise
correction, complete-basis-set extrapolation, and running computations
on an entire database of molecules at a time.  Later sections deal with
the different types of computations which can be done using |PSIfour|
(*e.g.*, Hartree |--| Fock, MP2, coupled-cluster) and general procedures
such as geometry optimization and vibrational frequency analysis.
The :ref:`Appendices <sec:appendices>` include a complete description of all possible input
keywords for each module, as well as tables of available basis sets and
a listing of the sample input files available under :source:`samples`.
The user is urged to examine this directory of sample inputs, as
most common types of computations are represented there.
For the latest |PSIfour| documentation, check
`www.psicode.org <http://www.psicode.org>`_.

Citing |PSIfour|
================

Overall |PSIfour| Package
^^^^^^^^^^^^^^^^^^^^^^^^^

The following citation should be used in any publication utilizing the
|PSIfour| program package:

* "Psi4 1.4: Open-Source Software for High-Throughput Quantum Chemistry",
  D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C.
  Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A.
  M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B.
  Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O'Brien, J. M.
  Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, B. R. Brooks, H. F.
  Schaefer III, A. Yu. Sokolov, K. Patkowski, A. E. DePrince III, U.
  Bozkaya, R. A. King, F. A. Evangelista, J. M. Turney, T. D. Crawford, C.
  D. Sherrill, *J. Chem. Phys.* (2020).
  (doi: `10.1063/5.0006002
  <https://doi.org/10.1063/5.0006002>`_).

The following citation covers |PSIfour| early stable releases:

* "Psi4 1.1: An Open-Source Electronic Structure Program Emphasizing
  Automation, Advanced Libraries, and Interoperability", R. M. Parrish, L.
  A. Burns, D. G. A. Smith, A. C. Simmonett, A. E. DePrince III, E. G.
  Hohenstein, U. Bozkaya, A. Yu. Sokolov, R. Di Remigio, R. M. Richard, J.
  F. Gonthier, A. M. James, H. R. McAlexander, A. Kumar, M. Saitow, X. Wang,
  B. P. Pritchard, P. Verma, H. F. Schaefer III, K. Patkowski, R. A. King,
  E. F. Valeev, F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D.
  Sherrill, *J. Chem. Theory Comput.*, **13(7)** 3185--3197 (2017).
  (doi: `10.1021/acs.jctc.7b00174
  <https://doi.org/10.1021/acs.jctc.7b00174>`_).

The following citation covers |PSIfour| alpha and beta versions:

* "Psi4: An open-source *ab initio* electronic structure program,"
  J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.
  Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.
  Abrams, N. J.  Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.
  Allen, H. F.  Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.
  D. Crawford, *WIREs Comput. Mol. Sci.* **2**, 556 (2012).
  (doi: `10.1002/wcms.93 <https://doi.org/10.1002/wcms.93>`_).

Depending on the particular modules used, the user may also wish to
cite some of the following references for theoretical, algorithmic,
or implementation contributions specific to |PSIfour| (in addition to
appropriate references for the underlying theory, which are not necessarily
included in the list below).

Regardless of the type of the calculation, an initial guess is
necessary. |PSIfour| features several initial guesses for the
molecular orbitals. The default guess is the superposition of atomic
densities (SAD), discussed in

* "Principles for a direct SCF approach to LCAO-MO ab-initio
  calculations", J. Alml\ |o_dots|\ f, K. Faegri, and K. Korsell,
  *J. Comput. Chem.* **3**, 385 (1982).
  (doi: `10.1002/jcc.540030314 <https://doi.org/10.1002/jcc.540030314>`_).

* "Starting SCF calculations by superposition of atomic
  densities", J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,
  and M. F. Guest, *J. Comput. Chem.* **27**, 926 (2006).
  (doi: `10.1002/jcc.20393 <https://doi.org/10.1002/jcc.20393>`_).

|PSIfour| also features a SAD natural orbital guess, an extended
H\ |u_dots|\ ckel guess that employs on-the-fly atomic calculations alike the SAD
guess, as well as a superposition of atomic potentials (SAP) guess
that is based on screening of atomic nuclei. The SAD natural orbitals,
H\ |u_dots|\ ckel and SAP guesses have been described in

* "An assessment of initial guesses for self-consistent field
  calculations. Superposition of Atomic Potentials: simple yet
  efficient", S. Lehtola, *J. Chem. Theory Comput.* **15**,
  1593 (2019) (doi: `10.1021/acs.jctc.8b01089
  <https://doi.org/10.1021/acs.jctc.8b01089>`_).


Density Cumulant Theory (DCT)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _`intro:dctcitations`:

|PSIfour| features several formulations of newly-developed density cumulant
theory (DCT), also known as density cumulant functional theory (DCFT).
The theory and benchmark of this theory are discussed in the following papers:

DC-06 (also known as DCT-06):

* "Density Cumulant Functional Theory: First Implementation and
  Benchmark Results for the DCFT-06 Model," A. C. Simmonett,
  J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, *J. Chem. Phys.*
  **133**, 174122 (2010).
  (doi: `10.1063/1.3503657 <https://doi.org/10.1063/1.3503657>`_).

* "Analytic gradients for density cumulant functional theory: The
  DCFT-06 model," A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,
  and H. F. Schaefer, *J. Chem. Phys.* **137**, 054105 (2012).
  (doi: `10.1063/1.4739423 <https://doi.org/10.1063/1.4739423>`_).

DC-12:

* "Density cumulant functional theory: The DC-12 method, an improved
  description of the one-particle density matrix," A. Yu. Sokolov,
  A. C. Simmonett, and H. F. Schaefer, *J. Chem. Phys.*  **138**, 024107
  (2013).
  (doi: `10.1063/1.4773580 <https://doi.org/10.1063/1.4773580>`_).

ODC-06 and ODC-12:

* "Orbital-optimized density cumulant functional theory," A. Yu. Sokolov, and
  H. F. Schaefer, *J. Chem. Phys.*  **139**, 204110 (2013).
  (doi: `10.1063/1.4833138 <https://doi.org/10.1063/1.4833138>`_).

ODC-13:

* "Density cumulant functional theory from a unitary transformation:
  N-representability, three-particle correlation effects, and application
  to O4+," A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,
  *J. Chem. Phys.*  **141**, 074111 (2014).
  (doi: `10.1063/1.4892946 <https://doi.org/10.1063/1.4892946>`_).

Configuration Interaction (CI)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PSI has a highly optimized code for full configuration interaction
and highly correlated configuration interaction, as described in

* "The Configuration Interaction Method: Advances in Highly
  Correlated Approaches," C. D. Sherrill and H. F. Schaefer, in
  *Adv. Quantum Chem.*, vol. 34, P.-O. L\ |o_dots|\ wdin, Ed.
  (Academic Press, New York, 1999), pp. 143-269.
  (doi: `10.1016/S0065-3276(08)60532-8
  <https://doi.org/10.1016/S0065-3276(08)60532-8>`_).

Coupled Cluster (CC)
^^^^^^^^^^^^^^^^^^^^

A general discussion of coupled cluster theory is given in

* "An Introduction to Coupled Cluster Theory for Computational
  Chemists," T. D. Crawford and H. F. Schaefer, *Rev. Comp. Chem.*
  **14**, 33-136 (2000).
  (doi: `10.1002/9780470125915.ch2
  <https://doi.org/10.1002/9780470125915.ch2>`_).

Implementation of frozen natural orbital (FNO) coupled cluster theory
in PSI and its performance for non-covalent interactions is discussed
in

* "Accurate Noncovalent Interaction Energies Using Truncated Basis Sets
  Based on Frozen Natural Orbitals," A. E. DePrince and C. D. Sherrill,
  *J. Chem. Theory Comput.* **9**, 293-299 (2013).
  (doi: `10.1021/ct300780u <https://doi.org/10.1021/ct300780u>`_).

Implementation of density-fitted (DF) and Cholesky decomposition (CD)
coupled cluster in PSI, and its performance for non-covalent interactions
and reaction energies, is discussed in

* "Accuracy and Efficiency of Coupled-Cluster Theory Using
  Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,
  and a T1-Transformed Hamiltonian," A. E. DePrince and C. D. Sherrill,
  *J. Chem. Theory Comput.* **9**, 2687-2696 (2013).
  (doi: `10.1021/ct400250u <https://doi.org/10.1021/ct400250u>`_).

Implementation of the asymmetric triples correction for the density-fitted
and cholesky-decomposed coupled-cluster singles and doubles method

* "A noniterative asymmetric triple excitation correction for the density-fitted
  coupled-cluster singles and doubles method: Preliminary applications,"
  U. Bozkaya,   *J. Chem. Phys.* **144**, 144108 (2016).
  (doi: `10.1063/1.4945706 <https://doi.org/10.1063/1.4945706>`_).

Implementation of analytic gradients for the density-fitted
coupled-cluster singles and doubles method

* "Analytic energy gradients for the coupled-cluster singles and doubles method with
  the density-fitting approximation,"
  U. Bozkaya and C. D. Sherrill,   *J. Chem. Phys.* **144**, 174103 (2016).
  (doi: `10.1063/1.4948318 <https://doi.org/10.1063/1.4948318>`_).

Implementation of analytic gradients for the density-fitted
coupled-cluster singles and doubles with perturbative triples method

* "Analytic energy gradients for the coupled-cluster singles and doubles
  with perturbative triples method with the density-fitting approximation,"
  U. Bozkaya and C. D. Sherrill,   *J. Chem. Phys.* **147**, 044104 (2017).
  (doi: `10.1063/1.4994918 <https://doi.org/10.1063/1.4994918>`_).

Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|PSIfour| features production-level Mukherjee-style state-specific
coupled-cluster theory, including perturbative triples and also associated
multi-reference perturbation theories.  The theory and |PSIfour|
implementation of these methods is discussed in the following papers.

General Mk-MRCC

* "Coupling Term Derivation and General Implementation of
  State-Specific Multireference Coupled-Cluster Theories,"
  F. A. Evangelista, W. D. Allen, and H. F. Schaefer,
  *J. Chem. Phys.* **127**, 024102 (2007).
  (doi: `10.1063/1.2743014 <https://doi.org/10.1063/1.2743014>`_).

Mk-MRCCSD(T)

* "Perturbative Triples Corrections in State-Specific Multireference
  Coupled Cluster Theory,"
  F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer,
  *J. Chem. Phys.* **132**, 074107 (2010).
  (doi: `10.1063/1.3305335 <https://doi.org/10.1063/1.3305335>`_).

Mk-MRCCSDT(-n)

* "Triple Excitations in State-Specific Multireference Coupled
  Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to
  Model Systems," F. A. Evangelista, A. C. Simmonett, W. D. Allen,
  H. F. Schaefer, and J. Gauss, *J. Chem. Phys.* **128**, 124104
  (2008).
  (doi: `10.1063/1.2834927 <https://doi.org/10.1063/1.2834927>`_).

Mk-MRPT2

* "A Companion Perturbation Theory for State-specific
  Multireference Coupled Cluster Methods,"
  F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and
  W. D. Allen,
  *Phys. Chem. Chem. Phys.* **11**, 4728-4741 (2009).
  (doi: `10.1039/b822910d <https://doi.org/10.1039/b822910d>`_).

Symmetry-Adapted Perturbation Theory (SAPT)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

|PSIfour| features an extremely efficient code to perform wavefunction-based
Symmetry Adapted Perturbation Theory (SAPT). A good review article for this
method is as follows:

* "Perturbation Theory Approach to Intermolecular Potential Energy
  Surfaces of van der Waals Complexes," B. Jeziorski, R. Moszynski,
  and K. Szalewicz, *Chem. Rev.* **94**, 1887-1930 (1994).
  (doi: `10.1021/cr00031a008 <https://doi.org/10.1021/cr00031a008>`_).

|PSIfour| benefits enormously from the introduction of density fitting (DF)
into SAPT. There are several SAPT truncations available in |PSIfour|. For
guidance on which one to choose, see the SAPT section of the manual
and refer to the following systematic study:

* "Levels of  Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and
  Performance for Interaction Energies,'' T. M. Parker, L. A. Burns, R. M.
  Parrish, A. G. Ryno, and C. D. Sherrill, *J. Chem. Phys.* **140**,
  094106 (2014).
  (doi: `10.1063/1.4867135 <https://doi.org/10.1063/1.4867135>`_).

The theory and implementation of DF-SAPT is discussed
in the following papers for various levels of SAPT.

DF-SAPT0

* "Large-scale Symmetry-adapted Perturbation Theory Computations via
  Density Fitting and Laplace Transformation Techniques: Investigating the
  Fundamental Forces of DNA-Intercalator Interactions," E. G. Hohenstein,
  R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, *J.
  Chem. Phys.* **135**, 174017 (2011).
  (doi: `10.1063/1.3656681 <https://doi.org/10.1063/1.3656681>`_).

* "Density Fitting and Cholesky Decomposition Approximations
  in Symmetry-Adapted Perturbation Theory: Implementation and Application
  to Probe the Nature of :math:`\pi - \pi` Interactions in Linear Acenes,"
  E. G. Hohenstein and C. D. Sherrill, *J. Chem. Phys.* **132**,
  184111 (2010).
  (doi: `10.1063/1.3426316 <https://doi.org/10.1063/1.3426316>`_).

SAPT2

* "Density Fitting of Intramonomer Correlation Effects in
  Symmetry-Adapted Perturbation Theory,"
  E. G. Hohenstein and C. D. Sherrill, *J. Chem. Phys.* **133**,
  014101 (2010).
  (doi: `10.1063/1.3451077 <https://doi.org/10.1063/1.3451077>`_).

SAPT2+, SAPT2+(3), SAPT2+3

* "Wavefunction Methods for Noncovalent Interactions," E. G.
  Hohenstein and C. D. Sherrill, *WIREs: Comput. Mol. Sci.* **2**,
  304-326 (2012).
  (doi: `10.1002/wcms.84 <https://doi.org/10.1002/wcms.84>`_).

* "Density Fitting of Intramonomer Correlation Effects in
  Symmetry-Adapted Perturbation Theory,"
  E. G. Hohenstein and C. D. Sherrill, *J. Chem. Phys.* **133**,
  014101 (2010).
  (doi: `10.1063/1.3451077 <https://doi.org/10.1063/1.3451077>`_).

* "Efficient Evaluation of Triple Excitations in Symmetry-Adapted
  Perturbation Theory via MP2 Natural Orbitals," E. G. Hohenstein
  and C. D. Sherrill, *J. Chem. Phys.* **133**, 104107 (2010).
  (doi: `10.1063/1.3479400 <https://doi.org/10.1063/1.3479400>`_).


SAPT2+(CCD), SAPT2+(3)(CCD), and SAPT2+3(CCD)

* "Tractability Gains in Symmetry-Adapted Perturbation Theory Including
  Coupled Double Excitations: CCD+ST(CCD) Dispersion with Natural Orbital
  Truncations,'' R. M. Parrish, E. G. Hohenstein, and C. D. Sherrill,
  *J. Chem. Phys.* **139**, 174102 (2013).
  (doi: `10.1063/1.4826520 <https://doi.org/10.1063/1.4826520>`_).

* "Wavefunction Methods for Noncovalent Interactions," E. G.
  Hohenstein and C. D. Sherrill, *WIREs: Comput. Mol. Sci.* **2**,
  304-326 (2012).
  (doi: `10.1002/wcms.84 <https://doi.org/10.1002/wcms.84>`_).

* "Density Fitting of Intramonomer Correlation Effects in
  Symmetry-Adapted Perturbation Theory,"
  E. G. Hohenstein and C. D. Sherrill, *J. Chem. Phys.* **133**,
  014101 (2010).
  (doi: `10.1063/1.3451077 <https://doi.org/10.1063/1.3451077>`_).

F/I-SAPT

* "Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction
  Energy Components: The Functional-Group SAPT Partition,"
  R. M. Parrish, T. M. Parker, and C. D. Sherrill,
  *J. Chem. Theory Comput.* **10**, 4417 (2014).
  (doi: `10.1021/ct500724p <https://doi.org/10.1021/ct500724p>`_).

* "Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory
  via Hartree-Fock Embedding,"
  R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,
  *J. Chem. Phys.* **143**, 051103 (2015).
  (doi: `10.1063/1.4927575 <https://doi.org/10.1063/1.4927575>`_)

The derivation of the second-order exchange terms without the single-exchange
approximation are found in the following two works:

* "Intermolecular exchange-induction energies without the overlap expansion,"
  R. Sch\ |a_dots|\ ffer and G. Jansen, *Theor. Chem. Acc.* **131**, 1235 (2012).
  (doi: `10.1007/s00214-012-1235-6 <https://doi.org/10.1007/s00214-012-1235-6>`_)

* "Single-determinant-based symmetry-adapted perturbation theory without
  single-exchange approximation," 
  R. Sch\ |a_dots|\ ffer and G. Jansen, *Mol. Phys.* **111**, 2570 (2013).
  (doi: `10.1080/00268976.2013.827253 <https://doi.org/10.1080/00268976.2013.827253>`_)

Orbital-Optimized Post-Hartree |--| Fock Methods
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Orbital-optimized second-order perturbation theory (OMP2)

* "Quadratically convergent algorithm for orbital optimization in the
  orbital-optimized coupled-cluster doubles method and in orbital-optimized
  second-order |MollerPlesset| perturbation theory,"
  U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,
  *J. Chem. Phys.* **135**, 104103 (2011).
  (doi: `10.1063/1.3631129 <https://doi.org/10.1063/1.3631129>`_).

* "Analytic energy gradients for the orbital-optimized second-order
  |MollerPlesset| perturbation theory," U. Bozkaya and
  C. D. Sherrill, *J. Chem. Phys.* **138**, 184103 (2013).
  (doi: `10.1063/1.4803662 <https://doi.org/10.1063/1.4803662>`_).

* "Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting
  and Cholesky Decomposition Approximations: An Efficient Implementation,"
  U. Bozkaya,   *J. Chem. Theory Comput.* **10**, 2371 (2014).
  (doi: `10.1021/ct500231c <https://doi.org/10.1021/ct500231c>`_).

Orbital-optimized third-order perturbation theory (OMP3)

* "Orbital-Optimized Third-Order |MollerPlesset| Perturbation
  Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application
  to Symmetry Breaking Problems," U. Bozkaya,
  *J. Chem. Phys.* **135**, 224103 (2011).
  (doi: `10.1063/1.3665134 <https://doi.org/10.1063/1.3665134>`_).

* "Assessment of Orbital-Optimized Third-Order |MollerPlesset|
  Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants
  for Thermochemistry and Kinetics," E. Soydas and U. Bozkaya,
  *J. Chem. Theory Comput.* **9**, 1452 (2013).
  (doi: `10.1021/ct301078q <https://doi.org/10.1021/ct301078q>`_).

* "Analytic energy gradients for the orbital-optimized third-order |MollerPlesset|
  Perturbation Theory," U. Bozkaya,
  *J. Chem. Phys.* **139**, 104116 (2013).
  (doi: `10.1063/1.4820877 <https://doi.org/10.1063/1.4820877>`_).

Orbital-optimized linearized coupled-cluster doubles method (OLCCD)

* "Orbital-optimized coupled-electron pair theory and its analytic gradients:
  Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer
  reactions," U. Bozkaya and C. D. Sherrill,
  *J. Chem. Phys.* **139**, 054104 (2013).
  (doi: `10.1063/1.4816628 <https://doi.org/10.1063/1.4816628>`_).

Orbital-optimized MP2.5 (OMP2.5)

* "Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T)
  quality for noncovalent interactions," U. Bozkaya and C. D. Sherrill,
  *J. Chem. Phys.* **141**, 204105 (2014).
  (doi: `10.1063/1.4902226 <https://doi.org/10.1063/1.4902226>`_).

Extended Koopmans' Theorem

* "The extended Koopmans' theorem for orbital-optimized methods: Accurate
  computation of ionization potentials," U. Bozkaya,  *J. Chem. Phys.*
  **139**, 154105 (2013).
  (doi: `10.1063/1.4825041 <https://doi.org/10.1063/1.4825041>`_).

* "Accurate Electron Affinities from the Extended Koopmans' Theorem Based on Orbital-Optimized Methods,"
  U. Bozkaya,   *J. Chem. Theory Comput.* **10**, 2041 (2014).
  (doi: `10.1021/ct500186j <https://doi.org/10.1021/ct500186j>`_).

Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2)

* "Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting
  and Cholesky Decomposition Approximations: An Efficient Implementation,"
  U. Bozkaya,   *J. Chem. Theory Comput.* **10**, 2371 (2014).
  (doi: `10.1021/ct500231c <https://doi.org/10.1021/ct500231c>`_).

* "Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized
  Second-Order Perturbation Theory with Density-Fitting Approximation: An
  Efficient Implementation," U. Bozkaya, *J. Chem. Theory Comput.* **10**, 4389 (2014).
  (doi: `10.1021/ct500634s <https://doi.org/10.1021/ct500634s>`_).

Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5)

* "Orbital-Optimized MP3 and MP2.5 with Density-Fitting
  and Cholesky Decomposition Approximations,"
  U. Bozkaya,   *J. Chem. Theory Comput.* **12**, 1179 (2016).
  (doi: `10.1021/acs.jctc.5b01128 <https://doi.org/10.1021/acs.jctc.5b01128>`_).

Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD)

* "Orbital-optimized linearized coupled-cluster doubles with density-fitting
  and Cholesky decomposition approximations: an efficient implementation,"
  U. Bozkaya,   *Phys. Chem. Chem. Phys.* **18**, 11362 (2016).
  (doi: `10.1039/c6cp00164e <https://doi.org/10.1039/c6cp00164e>`_).


Algebraic-Diagrammatic Construction methods (ADC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

General ADC theory

* "Intermediate state representation approach to physical properties of
  electronically excited molecules,"
  J. Schirmer, and A. B. Trofimov, *J. Chem. Phys.* **120**,
  11449-11464 (2004).
  (doi: `10.1063/1.1752875 <https://doi.org/10.1063/1.1752875>`_).

Implementation inside `adcc <https://adc-connect.org>`_,
the ADC backend used for most ADC methods available in |PSIfour|

* "adcc: A versatile toolkit for rapid development of
  algebraic-diagrammatic construction methods,"
  M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.
  *WIREs Comput. Mol. Sci.*, (2020).
  (DOI: `10.1002/wcms.1462 <https://doi.org/10.1002/wcms.1462>`_, Preprint https://adc-connect.org/q/publications

"Partially-renormalized" CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]
and the implementation for ADC(2) excitation energies within |PSIfour|

* "Excited State Calculation for Free-Base and Metalloporphyrins with
  the Partially Renormalized Polarization Propagator Approach,"
  M. Saitow and Y. Mochizuki, *Chem. Phys. Lett.* **525**, 144-149
  (2012).
  (doi: `10.1016/j.cplett.2011.12.063
  <https://doi.org/10.1016/j.cplett.2011.12.063>`_).

Density Matrix Renormalization Group (DMRG)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* "CheMPS2: a free open-source spin-adapted implementation of the density
  matrix renormalization group for ab initio quantum chemistry,"
  S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,
  *Comput. Phys. Commun.* **185** (6), 1501-1514 (2014).
  (doi: `10.1016/j.cpc.2014.01.019 <https://doi.org/10.1016/j.cpc.2014.01.019>`_).

* "The density matrix renormalization group for ab initio quantum chemistry,"
  S. Wouters and D. Van Neck, *Eur. Phys. J. D* **68** (9), 272 (2014).
  (doi: `10.1140/epjd/e2014-50500-1 <https://doi.org/10.1140/epjd/e2014-50500-1>`_).

Scalar Relativistic Corrections
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

General theory for the exact two-component approach (X2C)

* "Analytic energy gradients for the spin-free exact two-component theory
  using an exact block diagonalization for the one-electron Dirac
  Hamiltonian,"
  L. Cheng and J. Gauss, *J. Chem. Phys.* **135**, 084114 (2011).
  (doi: `10.1063/1.3624397 <https://doi.org/10.1063/1.3624397>`_).

Implementation within Psi4

* "Predicting Near Edge X-ray Absorption Spectra with the Spin-Free
  Exact-Two-Component Hamiltonian and Orthogonality Constrained Density
  Functional Theory,"
  P. Verma, W. D. Derricotte and F. A. Evangelista,
  *J. Chem. Theory Comput.* (2015).
  (doi: `10.1021/acs.jctc.5b00817 <https://doi.org/10.1021/acs.jctc.5b00817>`_).

.. index:: architectures
.. index:: compilers

Supported Systems
=================

Architectures
    The majority of |PSIfour| was developed on Mac and Linux machines; in
    principle, it should work on any Unix system. The latest version of the
    |PSIfour| program package may be obtained at `psicode.org <http://psicode.org>`_.
    The package is available as a binary (:ref:`Installing from Binary
    <sec:conda>`) for Linux, macOS, or Windows (both native and via Windows Subsystem for
    Linux aka `Bash on Ubuntu on Windows
    <https://docs.microsoft.com/en-us/windows/wsl/about>`_)
    or as source code (git repository or zipped archive from
    https://github.com/psi4/psi4.
Compilers
    |PSIfour| has been successfully compiled using Intel, GCC, and Clang
    compilers. :ref:`Compiler requirements <faq:approvedcxx>` are primarily
    C++14 compliance (now GCC version 6.0 or above).
    For some architectures, a :ref:`precompiled binary
    <sec:conda>` is available. See :ref:`Compiling and Installing
    <sec:installFile>` for details.
Python
    |PSIfour| 1.1 and 1.2 are supported on Python 2.7, 3.5,
    and 3.6. After 1.2, only Python 3 will be supported
    `in accordance with other scientific software projects
    <https://python3statement.org/>`_).
    |PSIfour| 1.3 supports Python 3.6 and 3.7.
    |PSIfour| 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.
    |PSIfour| 1.5 supports Python 3.7, 3.8, and 3.9.
    The future plan is to support the two or three latest Python versions.
    The current master supports 3.8, 3.9, and 3.10.
    
.. index:: license

License
=======

|PSIfour| is distributed under the GNU Lesser General Public License
version 3, `LGPL-3.0 <https://opensource.org/licenses/LGPL-3.0>`_.  Its
required dependencies and add-ons have their own licenses, ranging from
BSD-2-Clause to GPL-2.0+. It is possible to build |PSIfour| without any
GPL dependencies.

Capabilities
============

|PSIfour| can perform *ab initio* computations employing basis
sets of contracted Gaussian-type functions of virtually arbitrary
orbital quantum number. Many parts of |PSIfour| can recognize and
exploit the largest Abelian subgroup of the molecular point group.
Table :ref:`Methods <table:methods>` displays the range of theoretical methods
available in |PSIfour|.
For more details, see Tables :ref:`Energy <table:energy_gen>`,
:ref:`Energy (DFT) <table:energy_dft>`, :ref:`Energy (MRCC) <table:energy_mrcc>`,
:ref:`Energy (CFOUR) <table:energy_cfour>`, :ref:`Gradient <table:grad_gen>`,
:ref:`Gradient (CFOUR) <table:grad_cfour>`, and :ref:`Frequency <table:freq_gen>`.

.. _`table:methods`:

.. table:: Summary of theoretical methods available in |PSIfour|

    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | Method                  | Energy                             | Gradient                      | Parallelism                 | Variants                          |
    +                         +----------------+-------------------+--------------+----------------+                             +-----------+------------+----------+
    |                         | Reference      | Type              | Reference    | Type           |                             | OO [#f9]_ | FNO [#f1]_ | DLPNO    |
    +=========================+================+===================+==============+================+=============================+===========+============+==========+
    | HF, HF-3c               | RHF/UHF/ROHF   | CONV/DF/CD        | RHF/UHF/ROHF | CONV/DF        | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | DFT, PBEh-3c            | RKS/UKS        | CONV/DF/CD [#f7]_ | RKS/UKS      | DF [#f4]_      | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | EFP [#f5]_              | RHF            |                   | ---          | ---            |                             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | DCT                     | RHF/UHF        | CONV/DF           | RHF/UHF      | CONV           | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | MP2 [#f10]_             | RHF/UHF/ROHF   | CONV/DF/CD        | RHF/UHF      | CONV/DF        | threaded [#f3]_             | E/G       |            | E        |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | MP3 [#f10]_             | RHF/UHF        | CONV/DF/CD        | RHF/UHF      | CONV/DF        | threaded [#f3]_             | E/G       | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | MP2.5 [#f10]_           | RHF/UHF        | CONV/DF/CD        | RHF/UHF      | CONV/DF        | threaded [#f3]_             | E/G       |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | MP4 [#f10]_             | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | MP(n)                   | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ZAPT(n)                 | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | LCCD [#f10]_            | RHF/UHF        | CONV/DF/CD        | RHF/UHF      | CONV/DF        | threaded [#f3]_             | E/G       | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | LCCSD, CEPA(0) [#f10]_  | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CEPA(n), n=0,1,3        | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CCD                     | RHF            | DF/CD             | RHF          | DF             | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CC2                     | RHF/UHF/ROHF   | CONV              | RHF          | CONV           | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CCSD [#f10]_            | RHF/UHF/ROHF   | CONV/DF/CD [#f8]_ | RHF/UHF/ROHF | CONV/DF [#f8]_ | threaded [#f3]_             |           | E [#f2]_   |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CCSD(T) [#f10]_         | RHF/UHF/ROHF   | CONV/DF/CD [#f8]_ | RHF/UHF      | CONV/DF [#f8]_ | threaded (pthreads) [#f3]_  |           | E [#f2]_   |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | A-CCSD(T) [#f10]_       | RHF            | CONV/DF/CD        | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CC3                     | RHF/UHF/ROHF   | CONV              | ---          | ---            | threaded (pthreads)         |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ACPF/AQCC               | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CISD [#f10]_            | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | QCISD                   | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | QCISD(T)                | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           | E          |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CI(n)                   | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | FCI                     | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | Mk-MRPT2                | RHF/ROHF/TCSCF | CONV              | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | Mk-MRCCSD               | RHF/ROHF/TCSCF | CONV              | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | Mk-MRCCSD(T)            | RHF/ROHF/TCSCF | CONV              | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | RAS-CI                  | RHF/ROHF       | CONV              | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CASSCF, RASSCF          | RHF/ROHF       | CONV/DF           | ---          | ---            | partially threaded          |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | SAPT                    | RHF            | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ADC(1)                  | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ADC(2)                  | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ADC(2)-x                | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | ADC(3)                  | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CVS-ADC(1)              | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CVS-ADC(2)              | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CVS-ADC(2)-x            | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | CVS-ADC(3)              | RHF/UHF        | CONV              | ---          | ---            | threaded                    |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | EOM-CC2                 | RHF            | CONV              | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | EOM-CCSD                | RHF/UHF/ROHF   | CONV              | RHF/UHF/ROHF | CONV           | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | EOM-CC3                 | RHF/UHF/ROHF   | CONV              | ---          | ---            | threaded [#f3]_             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | DMRG-CI                 | Y              | CONV              | ---          | ---            |                             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+
    | DMRG-SCF                | Y              | CONV              | ---          | ---            |                             |           |            |          |
    +-------------------------+----------------+-------------------+--------------+----------------+-----------------------------+-----------+------------+----------+

Geometry optimization can be performed using either analytic gradients
or energy points. Likewise, vibrational frequencies can be
computed by analytic second derivatives, by finite
differences of analytic gradients, or by finite differences of energies.
|PSIfour| can also compute an extensive list of one-electron properties.

.. index::
   single: contact
   single: bugs

Technical Support
=================

The |PSIfour| package is distributed for free and without any guarantee of
reliability, accuracy, or suitability for any particular purpose. No
obligation to provide technical support is expressed or implied. As time
allows, the developers will attempt to answer inquiries on the `forum
<http://forum.psicode.org>`_ or `GitHub
<https://github.com/psi4/psi4/issues/new>`_. For bug reports,
specific and detailed information, with example inputs, would be
appreciated.

Where-to-post summary:[#f6]_

* How do I? -- `ask the forum <http://forum.psicode.org>`_

* I got this error, why? -- `ask the forum <http://forum.psicode.org>`_

* I got this error and I'm sure it's a bug -- `file a GitHub issue <https://github.com/psi4/psi4/issues/new>`_

* Can I open a discussion on this bit of code? -- `file a GitHub issue <https://github.com/psi4/psi4/issues/new>`_

* I have an idea/request and a plan -- `file a GitHub issue <https://github.com/psi4/psi4/issues/new>`_

* I have an idea/request -- `ask the forum <http://forum.psicode.org>`_

* Why do you? -- `ask the forum <http://forum.psicode.org>`_

* When will you? -- `ask the forum <http://forum.psicode.org>`_

* I have an experience that can improve the build documentation -- `inform the forum <http://forum.psicode.org>`_ or :source:`add to the documentation itself <doc/sphinxman/source>`

* Anything you want to share privately -- `crawdad@vt.edu <mailto:crawdad@vt.edu>`_ or `sherrill@gatech.edu <mailto:sherrill@gatech.edu>`_


.. rubric:: Footnotes

.. [#f1] Frozen natural orbital variant available. In particular, RHF available as CONV.
.. [#f2] Frozen natural orbital variant available. In particular, RHF available as CONV/DF.
.. [#f3] threading through BLAS routines only
.. [#f4] DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented.
.. [#f5] Both EFP/EFP and QM/EFP energies are available.
.. [#f6] Adapted from `here <https://groups.google.com/forum/#!topic/google-collections-users/m8FnCcmtC88>`_.
.. [#f7] DH-DFT only available with DF-MP2.
.. [#f8] Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core.
.. [#f9] Orbital-optimized variant available. In particular, all references available as CONV/DF.
.. [#f10] Capabilities breakdown in great detail can be found :ref:`here <table:managedmethods>`.

.. toctree::
   :hidden:

   mrcc_table_energy
   cfour_table_energy
   cfour_table_grad
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: BrianQC
.. _`sec:brianqc`:

Interface to the BrianQC GPU module by the BrianQC team
=======================================================

.. codeauthor:: Gergely Kis
.. sectionauthor:: Gergely Kis

|PSIfour| contains code to interface to the BrianQC GPU module developed
by the `BrianQC team <https://www.brianqc.com/team>`_, which is available after a license agreement from
`https://brianqc.com/ <https://brianqc.com/>`_.

Installing BrianQC
~~~~~~~~~~~~~~~~~~

Please contact BrianQC at `https://brianqc.com/ <https://brianqc.com/>`_
to download the BrianQC GPU module and obtain a license.

Note that there are several prerequisites for using BrianQC, including
having a supported GPU available in the computing node and having the
proper GPU drivers installed. Please refer to the `BrianQC manual <https://www.brianqc.com/download/>`_
for a full list of prerequisites.

When installing BrianQC, choose the SDK installation by setting the
:envvar:`BRIANQC_SDK_INSTALL` envoronment variable to `1`.

Building BrianQC's user-built components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After the installation, build BrianQC's example and sample programs,
which also creates the wrapper library and CMake configuration files
required to build |PSIfour| with BrianQC.

1. Create a build directory to keep the source tree clean.

.. code-block:: bash

    cd <brianqc_install_path>
    mkdir build
    cd build

2. Configure project and generate makefiles with CMake.
   You will require `Eigen <http://eigen.tuxfamily.org>`_ (tested with version 3.1.2)
   and `boost <https://www.boost.org/>`_ (tested with version 1.62).

.. code-block:: bash

    cmake ..

3. Build the examples and samples.

.. code-block:: bash

    make

4. Test the installation by starting a small calculation.
   Make sure to set the :envvar:`BRIANQC_INSTALL_PATH` environment variable to `<brianqc_install_path>`!

.. code-block:: bash

    export BRIANQC_INSTALL_PATH=<brianqc_install_path>
    bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz

Building |PSIfour| with BrianQC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When CMake-ing |PSIfour|, set the :makevar:`ENABLE_BrianQC` CMake variable to `1`
and set the :makevar:`BrianQC_DIR` CMake variable to the path where BrianQC's
components have been built (usually `<brianqc_install_path>/build`), then build |PSIfour| normally.

Using BrianQC from |PSIfour|
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To use BrianQC, the :envvar:`BRIANQC_INSTALL_PATH` environment variable
must be set to the full path of your BrianQC installation.

There are two ways to enable BrianQC for a specific calculation:

* setting the |globals__brianqc_enable| input option to `True`;

* setting the :envvar:`BRIANQC_ENABLE` environment variable to `1`.

If both the input option and the environment variable are specified,
then the environment variable takes precedence.

When to enable BrianQC
""""""""""""""""""""""

The operation of BrianQC is transparent from a user's point of view; every
internal computation is either performed by |PSIfour| (if unsupported by BrianQC),
or taken over by BrianQC, yielding the same result to within the required
precision. In particular, BrianQC will respect all of |PSIfour|'s usual precision
parameters, like |scf__ints_tolerance| and |scf__e_convergence|.

BrianQC can speed up a number of internal computations, including Fock and
gradient computation. Thus, BrianQC will speed up any calculation involving
those terms, such as

* HF and DFT single point energies

* HF and DFT geometry optimizations

* HF and DFT frequency analysis

Note that not every term of every calculation can be handled by BrianQC, thus,
the actual speedup depends on the specifics of the calculation.

Necessary and recommended option values
"""""""""""""""""""""""""""""""""""""""

To ensure that a calculation works with BrianQC, the following options need to
be set when enabling BrianQC:

* BrianQC currently only handles the C1 molecular symmetry point group. Thus, if
  the molecule has any symmetries (which |PSIfour| would detect by default), the
  input geometry must contain the line ``symmetry c1`` to force |PSIfour| to
  disregard the symmetry.

To achieve peak performance, the following settings are recommended when enabling
BrianQC:

* By default, |PSIfour| uses density-fitted preiterations for SCF, which BrianQC
  doesn't handle yet. To ensure that no non-BrianQC-accelerated iterations are
  performed, disable the preiterations by setting |scf__df_scf_guess| to `False`.
* By default, |PSIfour| uses a disk-based Fock building, but BrianQC currently only
  accelerates direct Fock builds. To ensure that Fock building is accelerated by
  BrianQC, set |globals__scf_type| to `direct`.

Keywords
~~~~~~~~

.. include:: autodir_options_c/globals__brianqc_enable.rst

Environment Variables
~~~~~~~~~~~~~~~~~~~~~

.. envvar:: BRIANQC_SDK_INSTALL

   Toggle for type of BrianQC installation.
   See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details.

.. envvar:: BRIANQC_INSTALL_PATH

   Location of BrianQC installation.
   See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details.

.. envvar:: BRIANQC_ENABLE

   Runtime toggle of whether to use BrianQC.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:interfacing`:

============================================
Interfaces: Enhancing |PSIfour| Capabilities
============================================

|PSIfours| capabilities have been expanded by interfacing with other
software packages. These programs aren't necessary
for |PSIfour| to operate and may require additional licences, special
platform capabilities, *etc*.

.. toctree::
   :maxdepth: 2

   numpy
   adcc
   brianqc
   cfour
   chemps2
   cppe
   dftd3
   dkh
   libefp
   erd
   fchk
   plugin_psi4fockci
   gau2grid
   gcp
   gdma
   libint
   molden
   mrcc
   pcmsolver
   simint
   plugin_snsmp2
   plugin_v2rdm_casscf
   libxc

.. comment * MPI4Py
.. comment * MADNESS
.. comment * MATLAB for new dft functionals

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; cbs()
   see: complete_basis_set(); cbs()
   single: basis set; delta correction

.. _`sec:cbs()`:

Complete Basis Set
==================

.. toctree::
   :hidden:

   cbs_eqn

.. codeauthor:: Lori A. Burns, Daniel G. A. Smith and Peter Kraus
.. sectionauthor:: Lori A. Burns and Peter Kraus

The :py:func:`psi4.cbs` function described below is
powerful but complicated, requiring many options. For most common
calculations, a shorthand can be accessed directly though
:py:func:`psi4.energy`, :py:func:`psi4.gradient`, *etc.* For example,
a MP2 single-point DT extrapolation can be accessed through the first item
below more conveniently than the equivalent second or third items.

* ``energy('mp2/cc-pv[dt]z')``

* ``energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z')``

* ``energy(cbs, cbs_metadata=[{"wfn": "hf", "basis": "cc-pvtz"}, {"wfn": "mp2", "basis": "cc-pv[dt]z"}])``

A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation
geometry optimization can also be accessed through the first item below more
conveniently than the equivalent second and third items.

* ``optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz')``

* ``optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz')``

* ``optimize(cbs, cbs_metadata=[{"wfn": "hf", "basis": "cc-pvqz"}, {"wfn": "mp2", "basis": "cc-pv[tq]z"}, {"wfn": "ccsd(t)", "basis": "cc-pvdz"}])``

Many examples can be found at :srcsample:`cbs-xtpl-energy`,
:srcsample:`cbs-xtpl-gradient`, :srcsample:`cbs-xtpl-opt`,
:srcsample:`cbs-xtpl-freq`, :srcsample:`cbs-xtpl-func`,
:srcsample:`cbs-xtpl-wrapper`, :srcsample:`cbs-xtpl-dict`.


.. autofunction:: psi4.cbs(name [, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])
   :noindex:

.. note:: As of October 2018, only two explicit ```deltaN_[wfn,basis,scheme]``` sets of options are active; if more delta functions are required, use the ```cbs_metadata``` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn't affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations.

.. index::
   pair: cbs(); output

Output
^^^^^^

At the beginning of a cbs() job is printed a listing of the individual
energy calculations which will be performed. The output snippet below is
from the example job [2] above. It shows first each model chemistry needed
to compute the aggregate model chemistry requested through cbs(). Then,
since, for example, an ``energy('ccsd(t)')`` yields CCSD(T), CCSD, MP2,
and SCF energy values, the wrapper condenses this task list into the second
list of minimum number of calculations which will actually be run. ::

    Naive listing of computations required.
            scf / aug-cc-pvqz              for  SCF TOTAL ENERGY
            mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY
            mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
        ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
        ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY
            mp2 / aug-cc-pvdz              for  MP2 CORRELATION ENERGY
            mp2 / aug-cc-pvtz              for  MP2 CORRELATION ENERGY

    Enlightened listing of computations required.
            mp2 / aug-cc-pvqz              for  MP2 CORRELATION ENERGY
        ccsd(t) / aug-cc-pvdz              for  CCSD(T) CORRELATION ENERGY
        ccsd(t) / aug-cc-pvtz              for  CCSD(T) CORRELATION ENERGY

At the end of a cbs() job is printed a summary section like the one below. First,
in the components section, are listed the results for each model chemistry available, whether
required for the cbs job (*) or not. Next, in the stages section, are listed the results for
each extrapolation. The energies of this section must be dotted with the weightings in column Wt
to get the total cbs energy. Finally, in the CBS section, are listed the results for each stage
of the cbs procedure. The stage energies of this section sum outright to the total cbs energy. ::

    ==> Components <==
    
    ----------------------------------------------------------------------------------
                   Method / Basis            Rqd   Energy [H]   Variable
    ----------------------------------------------------------------------------------
                      scf / aug-cc-pvqz        *  -1.11916375   SCF TOTAL ENERGY
                      mp2 / aug-cc-pvqz        *  -0.03407997   MP2 CORRELATION ENERGY
                      scf / aug-cc-pvdz           -1.11662884   SCF TOTAL ENERGY
                      mp2 / aug-cc-pvdz        *  -0.02881480   MP2 CORRELATION ENERGY
                  ccsd(t) / aug-cc-pvdz        *  -0.03893812   CCSD(T) CORRELATION ENERGY
                     ccsd / aug-cc-pvdz           -0.03893812   CCSD CORRELATION ENERGY
                      scf / aug-cc-pvtz           -1.11881134   SCF TOTAL ENERGY
                      mp2 / aug-cc-pvtz        *  -0.03288936   MP2 CORRELATION ENERGY
                  ccsd(t) / aug-cc-pvtz        *  -0.04201004   CCSD(T) CORRELATION ENERGY
                     ccsd / aug-cc-pvtz           -0.04201004   CCSD CORRELATION ENERGY
    ----------------------------------------------------------------------------------
    
    ==> Stages <==
    
    ----------------------------------------------------------------------------------
     Stage         Method / Basis             Wt   Energy [H]   Scheme
    ----------------------------------------------------------------------------------
       scf            scf / aug-cc-pvqz        1  -1.11916375   highest_1
      corl            mp2 / aug-cc-pv[tq]z     1  -0.03494879   corl_xtpl_helgaker_2
     delta        ccsd(t) / aug-cc-pv[dt]z     1  -0.04330347   corl_xtpl_helgaker_2
     delta            mp2 / aug-cc-pv[dt]z    -1  -0.03460497   corl_xtpl_helgaker_2
    ----------------------------------------------------------------------------------
    
    ==> CBS <==
    
    ----------------------------------------------------------------------------------
     Stage         Method / Basis                  Energy [H]   Scheme
    ----------------------------------------------------------------------------------
       scf            scf / aug-cc-pvqz           -1.11916375   highest_1
      corl            mp2 / aug-cc-pv[tq]z        -0.03494879   corl_xtpl_helgaker_2
     delta  ccsd(t) - mp2 / aug-cc-pv[dt]z        -0.00869851   corl_xtpl_helgaker_2
     total            CBS                         -1.16281105
    ----------------------------------------------------------------------------------

.. index::
   single: cbs(); extrapolation schemes
   single: extrapolation schemes
   single: basis set; extrapolation

.. _`sec:cbs_xtpl`:

Extrapolation Schemes
^^^^^^^^^^^^^^^^^^^^^

.. autofunction:: psi4.driver.driver_cbs.xtpl_highest_1

.. autofunction:: psi4.driver.driver_cbs.scf_xtpl_helgaker_2

.. autofunction:: psi4.driver.driver_cbs.scf_xtpl_truhlar_2

.. autofunction:: psi4.driver.driver_cbs.scf_xtpl_karton_2

.. autofunction:: psi4.driver.driver_cbs.scf_xtpl_helgaker_3

.. autofunction:: psi4.driver.driver_cbs.corl_xtpl_helgaker_2

.. autofunction:: psi4.driver.driver_cbs._get_default_xtpl

Aliases
^^^^^^^

When a particular composite method or its functional form is going to be
reused often, it is convenient to define an alias to it. A convenient
place for such Python code to reside is in :source:`psi4/driver/aliases.py`
(source location) or ``psi4/lib/psi4/driver/aliases.py`` (installed
location). No recompilation is necessary after defining an alias. Some
existing examples are below.

.. autofunction:: psi4.driver.aliases.sherrill_gold_standard

.. autofunction:: psi4.driver.aliases.allen_focal_point




.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:handlingOptions_py`:

LibOptions: globals, locals, has_changed and all that
=====================================================

To simplify parsing of options and handling of defaults, the Options class
was created. It functions in the following way:

- Each module (or plugin) declares which options it will look for in the
  input: their name, type (string, int, double, array, etc.), and any
  default value they take.

- The input is parsed for these options, and defaults are assigned for
  those keywords not specified by the user.

- The c-side module or plugin can then query the Options object for the
  values associated with each keyword.

- The options will also be accessible py-side to the procedures that drive
  the modules. Array-type options are not available in python.

Declaring Options
-----------------

Each module needs to make itself known to the Options object, via a
read_options section. For plugins, this routine is provided by the user
in the plugin code. For native |PSIfour| modules, the entries need to
be appended to the read_options code in :source:`psi4/src/read_options.cc`.
An example of such a routine is

.. code-block:: cpp

    if (name == "MYMODULE"|| options.read_globals()) {
        /*- The amount of information printed
        to the output file -*/
        options.add_int("PRINT", 1);
        /*- Do save information to |mymodule__data_file| at the end of the computation? -*/
        options.add_bool("SAVE_INFO", true);
        /*- An array containing the number of doubly occupied orbitals per irrep 
        (in :ref:`Cotton order <table:irrepOrdering>`) -*/
        options.add("DOCC", new ArrayType());
        /*- The factor by which the harmonic vibrational frequencies are multiplied to
        obtain an approximation to the fundamental vibrational frequencies -*/
        options.add_double("FREQUENCY_SCALE_FACTOR", 1.0);
        /*- The filename to which data is dumped. !expert -*/
        options.add_str_i("DATA_FILE", "data.dat");
        /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/
        options.add_str("AO_BASIS", "NONE", "NONE DISK DIRECT");
    }

In the above example, the following options are declared (in order):

- An integer called ``PRINT`` with a default value of 1.
- A boolean called ``SAVE_INFO`` with a default of true.
- An array called ``DOCC``, no default is possible for this type.
- A double called ``FREQUENCY_SCALE_FACTOR`` with a default of 1.0.
- A case-sensitive string called ``DATA_FILE``, with a default of "data.dat" and any possible value.
- A string called ``AO_BASIS`` with a default of "NONE", and possible values of "NONE", "DISK", or "DIRECT".

The purpose of the "if" statement in the above read_options function is
the following. Suppose in an input file the user sets an option through
the construct ``set mymodule print 1`` or through a ``set mymodule {...}``
block. The first thing to happen is a call to read_options with name set
to "MYMODULE". (Note that all user input is converted to upper case unless a
``add_str_i`` which should be used sparingly for files.) This
call to read_options should tell the Options object only about those
options expected by the module called "mymodule"; this prevents overlap of
options between different modules.

Notice also that there's a special comment immediately before the
declaration of each keyword. You must provide these comments for any
options you add as they will be automatically inserted into the user
manual Providing a clear description will also help you to remember what
the keywords do and how they're used. The comments must live between the
special comment delimiters. For options that most users shouldn't need,
add an expert flag to the comment. This will place these options in a
separate section of the user manual.

.. code-block:: cpp

   /*- comment -*/
   options.add_ ...
   /*- comment !expert -*/
   options.add_ ...

As is apparent from the examples above, comments can span multiple lines
(see ``PRINT``), can refer to other options (through hyperlinks; see
``SAVE_INFO``), can refer to sections of the manual (through hyperlinks;
see ``DOCC``), and can contain LaTeX notation (see ``AO_BASIS``). (To get
the LaTeX subscript command, use "@@" instead of "_".)

See :ref:`faq:readoptions`
for guidelines on naming options.

What is *has_changed* ?
-----------------------

There are times when we need to know whether an option was provided by the
user or if the defaults are being used. For this reason, the Options
object stores a boolean *has_changed* value, in addition to the option
value itself.  A clarification of definition:

- [a] has_changed DOESN'T answer "Has option been changed by the user?"
- [b] has_changed DOESN'T answer "Is option now different from the default?"
- [c] has_changed DOES answer "Has option value been touched at all, by user or code?"

The above items notwithstanding, psi4 code should be written so that
*has_changed* DOES effectively mean, "Has option been changed by the
user?". The way to do this is to isolate and nullify any changes to
options made by the code, the difference between [a] and [c]. C-side,
there is no concern since options are essentially read-only
within the modules.

Py-side is another matter since the driver's role is to take terse
instructions from the user and translate those into instructions to the
C++ modules, usually through manipulation of options.

.. comment * Reading options C-side
.. comment 
.. comment   This usually takes place within each module during options parsing,
.. comment   see section [] for details. No option is modified, so this process has
.. comment   no entanglement with the definition of has_changed.
.. comment 
.. comment * Setting options C-side
.. comment 
.. comment   This is very rarely done (what's going on in optking?). This
.. comment   document was written as background to the only case of note: PUREAM.
.. comment   This option has a clearly defined default, but it can't be set in
.. comment   read_options because its default depends on other options. This is a
.. comment   situation common to many options (and most all array options) and is
.. comment   generally handled within the module code and so is never available to
.. comment   the user. Analogously, PUREAM is handled in libmints but it is never
.. comment   reset.

In order to preserve effective definition [a], the strategy for each
python driver function is to query for the value of any option the
function may want to change and for the current has_changed status
(presumably reflecting whether the user has changed the value, as long as
no preceding code has corrupted that definition). The python function
then makes its changes to the option and runs any c-side modules with
those changes. Finally, just before the function returns, the options are
reset to the user's value and has_changed status (which should now again
reflect only whether the user has changed the value).




.. comment options["AO_BASIS"].has_changed()
.. comment will return false if the default value is being used, and true if the user specified this keyword in the input.


.. warning:: |globals__puream| is an exception in that its value and
   ``has_changed()`` value only reflect what the user has explicitly set.
   This keyword should not be queried to find out the current
   |globals__puream| state for the active basis; use instead,
   ``psi4.MintsHelper().basisset().has_puream()``.




Reading Options in Module
-------------------------




Handling Options in Driver
--------------------------

This section is about the scopes of options and how best to handle them in
the python driver. There are four groups of commands available.
Options from the c-side Options object are accessible in the Python driver through four sets of commands.

- get 

  - :py:func:`psi4.core.get_global_option()`
  - :py:func:`psi4.core.get_local_option()`
  - :py:func:`psi4.core.get_option()`

- set 

  - :py:func:`psi4.core.set_global_option()`
  - :py:func:`psi4.core.set_local_option()`

- has_changed 

  - :py:func:`psi4.core.has_global_option_changed()`
  - :py:func:`psi4.core.has_local_option_changed()`
  - :py:func:`psi4.core.has_option_changed()`

- revoke_changed 

  - :py:func:`psi4.core.revoke_global_option_changed()`
  - :py:func:`psi4.core.revoke_local_option_changed()`

There's a pattern here. Setting something, either a value (set) or a
negative changed status (revoke_changed), can only be done for a specific
scope, either global or local to the specified module. Querying, either a
value (get) or a changed status (has_changed), can be done in the global
scope, in a specified local scope, or in the context of "What will the
specified module use?".

.. note:: "Global" in the sense of the discussion has *nothing*
   to do with the globals section at the top of :source:`psi4/src/read_options.cc`. That
   section is just a convenient place for options and associated values
   that are used by most, if not all, modules.

.. comment Those options could be distributed out to
   all the modules below and the globals section dissolved with no change
   to psi's operation.
   :source:`src/bin/psi4/read_options.cc`. That section is just a

There are two primary purposes for interacting with options in the python driver.

- **Preserving User Options** (Enforcing definition [a] of has_changed)

  The first, less-interesting, use of retrieving user option values has
  been to preserve them so that they may be restored at the end after the
  procedure itself has clobbered them. By decoupling global_option and
  local_option commands, this can now be performed neatly by saving at the
  beginning the global and local values and the global and local
  has_changed values, then restoring them at the end.  Below is an example
  of this procedure; don't actually do this. ::

    from psi4 import core

    g_user_scftype = core.get_global_option('SCF_TYPE')
    l_user_scftype_scf = core.get_local_option('SCF', 'SCF_TYPE')
    bg_user_scftype = core.has_global_option_changed('SCF_TYPE')
    bl_user_scftype_scf = core.has_local_option_changed('SCF', 'SCF_TYPE')

    g_user_wfn = core.get_global_option('WFN')
    l_user_wfn = core.get_local_option('MP2', 'WFN')
    bg_user_wfn = core.has_global_option_changed('WFN')
    bl_user_wfn = core.has_local_option_changed('MP2', 'WFN')

    # body of function
    # scf_type and wfn are freely changed, LOCALLY
    # core.scf() and core.mp2() are run

    core.set_global_option('SCF_TYPE', g_user_scftype)
    if not bg_user_scftype:
        core.revoke_global_option_changed('SCF_TYPE')
    core.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf)
    if not bl_user_scftype_scf:
        core.revoke_local_option_changed('SCF', 'SCF_TYPE')

    core.set_global_option('WFN', g_user_wfn)
    if not bg_user_wfn:
        core.revoke_global_option_changed('WFN')
    core.set_local_option('MP2', 'WFN', l_user_wfn_scf)
    if not bl_user_wfn_scf:
        core.revoke_local_option_changed('MP2', 'WFN')

  Instead of cluttering the driver with the above boilerplate, use an
  :py:class:`~psi4.driver.p4util.OptionsState` object that stores values and
  has_changed values for each keyword and module pair given to it as
  arguments. At the end of the python function, these stored user settings
  can be restored. ::

    from psi4.driver import p4util

    optstash = p4util.OptionsState(
        ['SCF', 'SCF_TYPE'],
        ['MP2', 'WFN'],
        ['DF_BASIS_SCF'])

    # body of function
    # scf_type and wfn are freely changed, LOCALLY
    # puream and df_basis_scf are freely changed, GLOBALLY
    # core.scf() and core.mp2() are run

    optstash.restore()


  .. note:: Some options (BASIS, BASIS-like, and PUREAM) should always
     be used globally (no module argument) with the OptionsState objects.
     Similarly, within the body of the function, they should always be
     queried and set globally. Same for FREEZE_CORE.

- **Setting-Up Calculations**

  The other types of options calls in python driver functions are (a)
  those to query what option value an upcoming c++ module is going to use
  (determined by user and defaults) and (b) those to set options to govern
  the course of a procedure. Finding out the intended option value for a
  molecule should employ the :py:func:`~psi4.core.get_option` command
  (and :py:func:`~psi4.core.has_option_changed` for has_changed), which
  requires a module for scope. (Programmer-supplied scope is needed Py-side,
  whereas C-side, commands use the "active module".) ::

    if (psi4.core.get_option("SCF", "REFERENCE") == "RHF"):
        psi4.core.set_local_option("SCF", "REFERENCE", "RKS")

  Setting of options in python should use the
  :py:func:`~psi4.core.set_local_option` command. Using the local, rather
  than global, scope will ensure that the newly set option will be used by
  the module. Otherwise, if the python procedure set in the global scope
  and the user had happened to set that option in local scope, the local
  user option will take precedence against the programmer's intent.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`table:grad_cfour`:

    +-------------------------+---------------------------------------------------------------------------------------+
    | name                    | calls method in Stanton and Gauss's CFOUR program :ref:`[manual] <sec:cfour>`         |
    +=========================+=======================================================================================+
    | c4-scf                  | Hartree--Fock (HF)                                                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp2                  | 2nd-order |MollerPlesset| perturbation theory (non-density-fitting) (MP2)             |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp3                  | 3rd-order |MollerPlesset| perturbation theory (MP3)                                   |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp4(sdq)             | 4th-order MP perturbation theory (MP4) less triples                                   |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-mp4                  | full MP4                                                                              |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-cc2                  | approximate coupled cluster singles and doubles (CC2)                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsd                 | coupled cluster singles and doubles (CCSD)                                            |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-cc3                  | approximate CC singles, doubles, and triples (CC3)                                    |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsd(t)              | CCSD with perturbative triples (CCSD(T))                                              |
    +-------------------------+---------------------------------------------------------------------------------------+
    | c4-ccsdt                | coupled cluster singles, doubles, and triples (CCSDT)                                 |
    +-------------------------+---------------------------------------------------------------------------------------+
    | cfour                   | **expert** full control over cfour program                                            |
    +-------------------------+---------------------------------------------------------------------------------------+

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: TDSCF, TDDFT, RPA, random phase approximation, TDA, Tamm--Dancoff approximation
.. _`sec:tdscf`:

TDSCF: Time-dependent Hartree--Fock and density-functional theory
=================================================================

.. codeauthor:: Andrew M. James, Daniel G. A. Smith, Ruhee Dcuhna, Roberto Di Remigio and Jeff Schriber
.. sectionauthor:: Roberto Di Remigio

*Module:* :ref:`Keywords <apdx:scftdscf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`

.. _`sec:tdscfintro`:

Introduction
~~~~~~~~~~~~

|PSIfour| provides the capability to calculate excitation energies and ground to
excited state transition properties for SCF reference wavefunctions in a linear
response formalism [Dreuw2005-wp]_.

An illustrative example of using the TDSCF functionality is as follows::

    molecule {
    0 1
    O        0.000000    0.695000   -0.092486
    O       -0.000000   -0.695000   -0.092486
    H       -0.388142    0.895249    0.739888
    H        0.388142   -0.895249    0.739888
    symmetry c1
    }

    set {
    tdscf_states 10
    }

    energy('td-scf/cc-pvdz')

This will seek to converge 10 singlet roots from a restricted Hartree--Fock reference. The roots are obtained with an iterative eigensolver and the following is the printout from the calculation::

             ---------------------------------------------------------
                             TDSCF excitation energies
                     by Andrew M. James and Daniel G. A. Smith
             ---------------------------------------------------------

      ==> Options <==

         Residual threshold  : 1.0000e-04
         Initial guess       : denominators
         Reference           : RHF
         Solver type         : RPA (Hamiltonian)


      ==> Requested Excitations <==

          10 singlet states with A symmetry


      ==> Seeking the lowest 10 singlet states with A symmetry

                            Generalized Hamiltonian Solver
                                  By Andrew M. James

      ==> Options <==

        Max number of iterations        = 60
        Eigenvector tolerance           = 1.0000e-04
        Max number of expansion vectors = 2000

      => Iterations <=
                                  Max[D[value]]     Max[|R|]   # vectors
      HamiltonianSolver iter   1:   5.64572e-01  3.65441e-01     40
      HamiltonianSolver iter   2:   1.70649e-02  4.40807e-02     60
      HamiltonianSolver iter   3:   2.42552e-04  6.95387e-03     80
      HamiltonianSolver iter   4:   2.34146e-06  7.75689e-04    100
      HamiltonianSolver iter   5:   1.75483e-08  6.17293e-05    120      Converged

When convergence is reached, |PSIfour| will output a report of excitation energies, oscillator strengths, and rotatory strenghts in atomic units::


                                         Excitation Energy         Total Energy        Oscillator Strength             Rotatory Strength
          #   Sym: GS->ES (Trans)        au              eV              au          au (length)    au (velocity)    au (length)    au (velocity)
         ---- -------------------- --------------- --------------- --------------- --------------- --------------- --------------- ---------------
          1        A->A (1 A)       0.26945         7.33199        -150.50964       0.0017          0.0082         -0.0019         -0.0135
          2        A->A (1 A)       0.31534         8.58073        -150.46375       0.0000          0.0002         -0.0007         -0.0096
          3        A->A (1 A)       0.35760         9.73076        -150.42148       0.0040          0.0097          0.0227          0.0352
          4        A->A (1 A)       0.37522         10.21028       -150.40386       0.0144          0.0442          0.0729          0.1223
          5        A->A (1 A)       0.43252         11.76960       -150.34656       0.0890          0.1189         -0.1942         -0.2491
          6        A->A (1 A)       0.46952         12.77624       -150.30957       0.0640          0.1157          0.0175          0.0235
          7        A->A (1 A)       0.49186         13.38426       -150.28722       0.0016          0.0012         -0.0243         -0.0212
          8        A->A (1 A)       0.50405         13.71581       -150.27504       0.4557          0.4396         -0.0197         -0.0158
          9        A->A (1 A)       0.52971         14.41407       -150.24938       0.0799          0.0948          0.0546          0.0595
          10       A->A (1 A)       0.56083         15.26092       -150.21825       0.0497          0.0567         -0.0587         -0.0650


The solvers can be used to extract the first few roots of interest for the full
time-dependent DFT (TDDFT) equations, also known as the random-phase
approximation (RPA), or its Tamm--Dancoff approximation.
The former is a *generalized* eigenvalue problem and our solver leverages
the Hamiltonian structure of the equations to ensure robust convergence [stratmann:1998]_.
The latter is a Hermitian eigenvalue problem and we employ a Davidson solver.

Known limitations
~~~~~~~~~~~~~~~~~

.. warning:: The implementation cannot currently handle the following cases:
             - Excited states of triplet symmetry from a restricted DFT reference.
             - Excited states from an unrestricted reference other than HF or LDA.

.. warning:: The length-gauge rotatory strengths |PSIfour| computes are
             currently **not** gauge-origin invariant.

.. index::
   pair: TDSCF; theory

Theory
~~~~~~

The excitation energies and corresponding states are obtained from the following generalized
eigenvalue problem, also known as the *response eigenvalue problem*:

.. math::
    \begin{pmatrix}
      \mathbf{A} & \mathbf{B} \\
      \mathbf{B}^{*} & \mathbf{A}^{*}
    \end{pmatrix}
    \begin{pmatrix}
      \mathbf{X}_{n} \\
      \mathbf{Y}_{n}
    \end{pmatrix}
    =
    \omega_{n}
    \begin{pmatrix}
      \mathbf{1} & \mathbf{0} \\
      \mathbf{0} & -\mathbf{1}
    \end{pmatrix}
  \begin{pmatrix}
    \mathbf{X}_{n} \\
    \mathbf{Y}_{n}
  \end{pmatrix}.

This approach has the advantage that there is no need to explicitly parametrize
the wavefunctions of the molecular excited states. Furthermore, the excitation
eigenvectors, :math:`(\mathbf{X}_{n} \mathbf{Y}_{n})^{t}`,
provide information on the nature of the transitions and can be used to form
spectroscopic observables, such as oscillator and rotatory strengths.

The :math:`\mathbf{A}` and :math:`\mathbf{B}` matrices appearing on the left-hand side are
the blocks of the molecular electronic
Hessian, [Norman2018-tn]_
whose dimensionality is :math:`(OV)^{2}`, with :math:`O` and :math:`V` the number of occupied and
virtual molecular orbitals, respectively.
This prevents explicit formation of the full Hessian, and subspace iteration
methods need to be used to extract the first few roots.
In such methods, the eigenvectors are expanded in a subspace of trial vectors,
whose dimensionality is greatly lower than that of the full eigenproblem.
The Hessian is projected down to this subspace where conventional full
diagonalization algorithms can be applied. The subspace is augmented with new
trial vectors, until a suitable convergence criterion is met.
The efficiency of the subspace solver is determined by the first half-projection
of the Hessian in the trial subspace, that is, by the efficiency of the routines
performing the matrix-vector products.

It is essential to note that, despite the hermiticity of the molecular
electronic Hessian, the response eigenvalue equation is not an Hermitian
eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson
solver, the standard subspace iteration method in quantum chemistry,
demonstrates very poor convergence, sometimes manifesting as spurious complex
eigenvalues.
The eigenproblem however has Hamiltonian symmetry: the
roots appear in pairs :math:`(\omega_{n}, -\omega_{n})`, as do the eigenvectors.
A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing
the paired structure on the trial vectors themselves.
Since |PSIfour| employs real orbitals, the response eigenproblem can be brought
to the form:

.. math::
  (\mathbf{A} - \mathbf{B})(\mathbf{A} + \mathbf{B})| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle
  =
  \omega^{2}_{n} | \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle,

and further to the Hermitian form:

.. math::
  (\mathbf{A} - \mathbf{B})^{\frac{1}{2}}(\mathbf{A} + \mathbf{B})(\mathbf{A} - \mathbf{B})^{\frac{1}{2}} \mathbf{T}_{n}
  =
  \omega^{2}_{n} \mathbf{T}_{n},

assuming the SCF reference is stable, *i.e.* :math:`(\mathbf{A}-\mathbf{B})` is positive-definite.
The paired vectors :math:`| \mathbf{X}_{n} - \mathbf{Y}_{n}\rangle` are left
eigenvectors and form a biorthonormal set together
with the right eigenvectors :math:`| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle`.

The algorithm for the subspace iteration Hamiltonian solver implemented in |PSIfour|
was first described by Stratmann *et al.* [stratmann:1998]_.
As already mentioned, the formation and storage of the matrix-vector products
:math:`(\mathbf{A}+\mathbf{B})\mathbf{b}_{i}` and
:math:`(\mathbf{A}-\mathbf{B})\mathbf{b}_{i}` for all trial vectors :math:`\mathbf{b}_{i}`
are the most compute- and memory-intensive operations in the Hamiltonian solver.
These matrix-vector products are equivalent to building generalized Fock
matrices and thus use the efficient :math:`JK` build infrastructure of |PSIfour|.

The excitation energies and eigenvectors can then be used to compute transition moments, such as
electric and magnetic transition dipole moments, and spectroscopic intensities,
such as oscillator strengths and rotatory strengths [Pedersen1995-du]_, [Lestrange2015-xn]_.
For example, |PSIfour| will compute compute oscillator strengths from
the MO basis electric dipole moment integrals, :math:`\mathbf{\mu}_{u}`, and the right
excitation vectors, :math:`|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle`:

.. math::
   f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}.


Psithon keywords
~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/scf__tdscf_states.rst
.. include:: autodir_options_c/scf__tdscf_triplets.rst
.. include:: autodir_options_c/scf__tdscf_tda.rst
.. include:: autodir_options_c/scf__tdscf_r_convergence.rst
.. include:: autodir_options_c/scf__tdscf_maxiter.rst
.. include:: autodir_options_c/scf__tdscf_guess.rst
.. include:: autodir_options_c/scf__tdscf_print.rst
.. include:: autodir_options_c/scf__tdscf_coeff_cutoff.rst
.. include:: autodir_options_c/scf__tdscf_tdm_print.rst


PsiAPI usage
~~~~~~~~~~~~

The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:

.. code-block:: python

   import psi4

   from psi4.driver.procrouting.response.scf_response import tdscf_excitations

   psi4.core.set_output_file("h2o2.out")

   h2o2 = psi4.geometry("""0 1
   O        0.000000    0.695000   -0.092486
   O       -0.000000   -0.695000   -0.092486
   H       -0.388142    0.895249    0.739888
   H        0.388142   -0.895249    0.739888
   symmetry c1
   """, name="H2O2")

   psi4.set_options({
       'save_jk': True,
   })

   e, wfn = psi4.energy("HF/cc-pvdz", return_wfn=True, molecule=h2o2)
   res = tdscf_excitations(wfn, states=10)

Plotting one-photon absorption and electronic circular dichroism spectra
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Excitation energies and corresponding spectroscopic observables can be used to
produce spectra for one-photon absorption (OPA) and electronic circular
dichroism (ECD) with phenomenological line broadening.

|PSIfour| provides the ``spectrum`` function for this purpose implementing the
recommendations of Rizzo *et al.* [Rizzo2011-to]_.
This function will *not* plot the spectrum, but rather return a pair of NumPy
arrays containing the :math:`x` and :math:`y` values resulting from the
convolution with broadening of the computed spectroscopic observables.

.. code-block:: python

   import numpy as np

   import psi4

   from psi4.driver.procrouting.response.scf_response import tdscf_excitations
   from psi4.driver.p4util import spectrum

   psi4.core.set_output_file("moxy.out")

   moxy = psi4.geometry("""0 1
   C  0.152133 -0.035800  0.485797
   C -1.039475  0.615938 -0.061249
   C  1.507144  0.097806 -0.148460
   O -0.828215 -0.788248 -0.239431
   H  0.153725 -0.249258  1.552136
   H -1.863178  0.881921  0.593333
   H -0.949807  1.214210 -0.962771
   H  2.076806 -0.826189 -0.036671
   H  2.074465  0.901788  0.325106
   H  1.414895  0.315852 -1.212218
   """, name="(S)-methyloxirane")

   psi4.set_options({
       'save_jk': True,
   })

   e, wfn = psi4.energy("HF/cc-pvdz", return_wfn=True, molecule=moxy)
   res = tdscf_excitations(wfn, states=8, triplets="also")

   # get poles and residues to plot OPA and ECD spectra
   poles = [r["EXCITATION ENERGY"] for r in res]
   opa_residues = [np.linalg.norm(r["LENGTH-GAUGE ELECTRIC DIPOLE TRANSITION MOMENT"])**2 for r in res]
   ecd_residues = [r["LENGTH-GAUGE ROTATORY STRENGTH"] for r in res]

   opa_spectrum = spectrum(poles=poles, residues=opa_residues, gamma=0.01, out_units="nm")
   ecd_spectrum = spectrum(poles=poles, residues=ecd_residues, kind="ECD", gamma=0.01, out_units="nm")


The data produced by running the above PsiAPI code can, for example, be used
with the Altair plotting library to produce the desired spectra.

.. image:: /moxy.png
    :align: center
    :scale: 100%
    :alt: (S)-methyloxirane one-photon absorption and electronic circular dichroism spectra.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:proc_py`:

Adding Methods to Driver
========================

``proc.py``
-----------

This is concerned at present with normal methods added first to the
procedures table in driver.py that associates method names with functions
to run them located in proc.py .

The function should start with a declaration, as below. ``methodname`` is
never seen by users, so it's good to be specific; if there's lots of
modules that can run mp2, call methodname modulenamemethodname, perhaps.
The function must always take as arguments ``(name, **kwargs)``. ::

    # energy method
    def run_methodname(name, **kwargs):

    # gradient method
    def run_methodname_gradient(name, **kwargs):

If the function needs to test the identity of ``name`` several times, it
can be convenient to predefine the lowercase version of the variable. The
case of all other py-side options (in kwargs) has already been handled by
:py:func:`~psi4.energy()`, etc. in driver.py and need not be repeated here. ::

    # include if convenient
    lowername = name.lower()

    # never include
    kwargs = kwargs_lower(kwargs)

It's often necessary to The function often needs to set options for the
c-side modules it calls. In order that the state of the options set by the
user remains when control is returned to the user, an
:py:class:`~psi4.driver.p4util.OptionsState` object is set up. See
:ref:`sec:handlingOptions_py` for details. *All* options set by the
function need to be included here, and *only* options set by the function
should be included. Most options should be associated with a particular
module, but a few (see below) are given without module. ::

    # include if any options set
    optstash = OptionsState(
        # these and other basis options should have no associated module
        ['BASIS'],
        ['DF_BASIS_SCF'],
        ['DF_BASIS_MP2'],
        ['PUREAM'],
        ['FREEZE_CORE'],
        # all others should have an associated module
        ['SCF', 'SCF_TYPE'],
        ['SCF', 'GUESS'],
        ['DFMP2', 'MP2_OS_SCALE'],
        )

If options need to be set, set them anywhere here. Options should be set
locally to a module, except for those without a module in
:py:class:`~psi4.driver.p4util.OptionsState`. ::

    # include if necessary as globals
    psi4.set_global_option('BASIS', guessbasis)
    psi4.set_global_option('DF_BASIS_SCF', guessbasisdf)

    # include if necessary as locals
    psi4.set_local_option('TRANSQT2', 'WFN', 'MP2')
    psi4.set_local_option('CCSORT', 'WFN', 'MP2')
    psi4.set_local_option('MP2', 'WFN', 'MP2')

If the regular scf module is to be run, run it through
``psi4.driver.procrouting.proc.scf_helper`` so that cast-up can be used. Also, add
the option to pass the reference wavefunction by pre-running scf,
then running the module with the ``ref_wfn`` kwarg.  Also, if the full
two-electron integrals are necessary for the post-scf, compute them if
only the df integrals were run previously. ::

    # Bypass the scf call if a reference wavefunction is given
    
    ref_wfn = kwargs.get('ref_wfn', None)
    if ref_wfn is None:
        ref_wfn = scf_helper(name, **kwargs)
    
        # If the scf type is DF/CD, then the AO integrals were never written to disk
        if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:
            psi4.MintsHelper(ref_wfn.basisset()).integrals()

Direct any post-scf modules to be run. ::

    # include if further post-scf modules are needed
    psi4.transqt2()
    psi4.ccsort()
    psi4.mp2()

If an :py:class:`~psi4.driver.p4util.OptionsState` object was set up, those options
need to be returned to the original user state with the following. ::

    # include if optstash = OptionsState( was set up previously
    optstash.restore()

No function should return anything. ``CURRENT ENERGY`` will be set by
:py:func:`~psi4.energy`, etc. ::

    # never include
    return returnvalue


Managed Methods
---------------

When functionality overlaps between modules, a pattern is needed to (1)
access each route through the code without contrivances like ``ccsd2``,
``_ccsd``, ``sdci`` and (2) apportion defaulting among the modules, taking
into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).
Managed methods handle both these cases through the addition of a new
keyword |globals__qc_module| and a set of type keywords analogous to
|globals__mp2_type|: |globals__mp_type|,
|globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,
``DF``, and ``CD``. These are all *global* keywords, as their values are
shared among modules rather than (or in addition to) being used internally
by the module). We're sticking with |globals__scf_type| and
|globals__mp2_type| defaulting to ``DF``, while everything higher defaults
to ``CONV``. In :source:`psi4/driver/driver.py`, a managed method calls a
"select" function rather than a "run" function. ::

    procedures = {
        'energy': {
            'scf'           : run_scf,
            'mp3'           : select_mp3,
            'dct'           : run_dct,

Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through
reference (always outer loop) and type (inner loop) to specify the proc
function to call for any able, non-default module (*e.g.*, ``mtd_type ==
'DETCI'`` ) or able, default module (*e.g.*, ``mtd_typd == ['', 'FNOCC']`` ).
Don't worry about 'else' statements as anything that falls through will be
caught and a readable error generated. ::

    def select_mp3(name, **kwargs):
        """Function selecting the algorithm for a MP3 energy call
        and directing to specified or best-performance default modules.

        """
        reference = psi4.get_option('SCF', 'REFERENCE')
        mtd_type = psi4.get_global_option('MP_TYPE')
        module = psi4.get_global_option('QC_MODULE')
        # Considering only [df]occ/fnocc/detci

        func = None
        if reference == 'RHF':
            if mtd_type == 'CONV':
                if module == 'DETCI':
                    func = run_detci
                elif module == 'FNOCC':
                    func = run_fnocc
                elif module in ['', 'OCC']:
                    func = run_occ
            elif mtd_type == 'DF':
                if module in ['', 'OCC']:
                    func = run_dfocc
            elif mtd_type == 'CD':
                if module in ['', 'OCC']:
                    func = run_dfocc
        elif reference == 'UHF':
            if mtd_type == 'CONV':
                if module in ['', 'OCC']:
                    func = run_occ
            elif mtd_type == 'DF':
                if module in ['', 'OCC']:
                    func = run_dfocc
            elif mtd_type == 'CD':
                if module in ['', 'OCC']:
                    func = run_dfocc
        elif reference == 'ROHF':
            if mtd_type == 'CONV':
                if module in ['DETCI']:
                    func = run_detci

        if func is None:
            raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module])

        return func(name, **kwargs)

Naturally, in the run function, you must either use the type keyword for
type switching or translate it into whatever ``DO_CD``-like keywords your
module uses. At run time with a closed-shell molecule, ::

    energy('mp3')

will run OCC, while ::

    set qc_module fnocc
    energy('mp3')

will run FNOCC mp3.

A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::

    set reference rohf
    set qc_module detci
    energy('mp3')

While the below gives an error ::

    set reference rohf
    energy('mp3')


Again, whenever a single method name needs to call multiple proc.py run
functions, it should be managed. In :ref:`table:managedmethods` "Y" means method available in
module, "D" means module is default for that method, "" mean method not
available.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: SIMINT, integrals

.. _`sec:simint`:

Interface to SIMINT by B. Pritchard
===================================

.. codeauthor:: Benjamin P. Pritchard
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <src/lib/libefp_solver>`

.. image:: https://img.shields.io/badge/home-simint-5077AB.svg
   :target: http://www.bennyp.org/research/simint/

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://www.bennyp.org/research/simint/

These are the vectorized implementation of the Obara-Saika (OS) method of
calculating electron repulsion integrals developed by B. Pritchard and
interfaced into libmints. Enabling simint and adding ``set
integral_package simint`` (do this in ``~/.psi4rc`` for universal effect)
runs libderiv from Libint for derivative integrals and simint for
non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``

.. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/simint/badges/version.svg
     :target: https://anaconda.org/psi4/simint

* SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* The conda package is compiled to least-common-denominator, namely SSE instruction set.

* If using the |PSIfour| binary, simint has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  simint can be obtained through ``conda install simint -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_simint`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect simint and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use 
..   simint from conda without thinking, consult.

* To remove a conda installation, ``conda remove simint``.

**Source**

* .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000

..     :target: https://github.com/psi4/simint TODO BPP

* If using |PSIfour| built from source and you want simint built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_simint`,
  and let the build system fetch and build it and activate dependent code.


.. _`cmake:simint`:

How to configure simint for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, simint is a library that provides alternate
  integrals.

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint

* Upstream Dependencies |w---w| simint |dr| None

**CMake Variables**

* :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``
* :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build
* :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details.

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_simint=ON

B. Build *without* simint

  .. code-block:: bash

    >>> cmake

C. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root

  .. code-block:: bash

    >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir

D. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: DKH
.. _`sec:DKH`:

Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess
======================================================

.. codeauthor:: Justin M. Turney
.. sectionauthor:: Justin M. Turney

*Module:* :ref:`Keywords <sec:dkhkeywords>`, :ref:`Samples <apdx:testSuitedkh>`

.. image:: https://img.shields.io/badge/home-dkh-5077AB.svg
   :target: https://github.com/psi4/dkh

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://www.reiher.ethz.ch/software/dkh-x2c.html

.. _`sec:dkhinstall`:

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/dkh/badges/version.svg
     :target: https://anaconda.org/psi4/dkh

* DKH is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, dkh has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  dkh can be obtained through ``conda install dkh -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_dkh`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect dkh and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   dkh from conda without thinking, consult.

* To remove a conda installation, ``conda remove dkh``.

**Source**

* .. image:: https://img.shields.io/github/tag/psi4/dkh.svg?maxAge=2592000
     :target: https://github.com/psi4/dkh

* If using |PSIfour| built from source and you want dkh built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_dkh`,
  and let the build system fetch and build it and activate dependent code.

.. _`sec:dkhinput`:

Input
~~~~~

For all electron calculations one can use the Douglas-Kroll-Hess (DKH)
Hamiltonian to take into account scalar relativistic effects.

Minimal input for DKH single-point computation looks like this::

    molecule {
    Mg
    }

    set basis aug-cc-pvdz-dk
    set relativistic dkh

    energy('scf')

By default a 2nd-order DKH calculation is performed. To change the default
order use the |globals__dkh_order| option. The version of the code found in
|Psifour| is capable of up to 4th-order DKH calculations.

.. _`sec:dkhkeywords`:

Keywords
~~~~~~~~

.. include:: autodir_options_c/globals__relativistic.rst
.. include:: autodir_options_c/globals__dkh_order.rst

Reference
~~~~~~~~~

When using this code please make reference to the appropriate following paper:

* "The Generalized Douglas-Kroll Transformation," A. Wolf,
  M. Reiher, and B. A. Hess, *J. Chem. Phys.* **117**, 9215 (2002).
  (doi: `10.1063/1.1515314 <https://doi.org/10.1063/1.1515314>`_)

.. _`cmake:dkh`:

How to configure dkh for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, DKH is a library that provides additional
  quantum chemical capabilities (relativistic effects).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) dkh

* Upstream Dependencies |w---w| dkh |dr| Fortran

**CMake Variables**

* :makevar:`ENABLE_dkh` |w---w| CMake variable toggling whether Psi4 builds with dkh
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing ``include/DKH/DKH_MANGLE.h``
* :makevar:`dkh_DIR` |w---w| CMake variable to specify where pre-built dkh can be found. Set to installation directory containing ``share/cmake/dkh/dkhConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_dkh` |w---w| CMake variable to force internal build of dkh instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_dkh` |w---w| CMake variable to force detecting pre-built dkh and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_dkh=ON

B. Build *without* dkh

  .. code-block:: bash

    >>> cmake

C. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root

  .. code-block:: bash

    >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir

D. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: 
   single: Orbital-Optimized Methods, OMP2
   single: Orbital-Optimized Methods, OMP3
   single: Orbital-Optimized Methods, OMP2.5
   single: Orbital-Optimized Methods, OLCCD

.. index::
   pair: Orbital-Optimized Methods; theory
   pair: OMP2; theory
   pair: OMP3; theory
   pair: OLCCD; theory

.. _`sec:occ_oo`:

OCC: Orbital-Optimized Coupled-Cluster and |MollerPlesset| Perturbation Theories
================================================================================

.. codeauthor:: Ugur Bozkaya
.. sectionauthor:: Ugur Bozkaya

*Module:* :ref:`Keywords <apdx:occ>`, :ref:`PSI Variables <apdx:occ_psivar>`, :source:`OCC <psi4/src/psi4/occ>`

*Module:* :ref:`Keywords <apdx:dfocc>`, :ref:`PSI Variables <apdx:dfocc_psivar>`, :source:`DFOCC <psi4/src/psi4//dfocc>`

Introduction
~~~~~~~~~~~~

Orbital-optimized methods have several advantages over their non-optimized counterparts. 
Once the orbitals are optimized, the wave function will obey the Hellmann--Feynman theorem
for orbital rotation parameters. Therefore, there is no need for orbital response terms 
in the evaluation of analytic gradients. In other words, it is unnecessary to solve the 
first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations. 
Further, computation of one-electron properties is easier because there are no response contributions to the particle 
density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods 
[Krylov:2000:vod]_. Additionally, orbital-optimized coupled-cluster avoids spurious second-order 
poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od]_.

Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking 
instabilities [Crawford:1997:instability]_, [Sherrill:1998:od]_, [Bozkaya:2011:omp2]_, and [Bozkaya:2011:omp3]_.
Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009]_ demonstrated that first order properties such as 
forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs. 
They also observed that although the energy appears well behaved, the MP2 method can have natural occupation 
numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further 
discussed that the orbital response equations generally have a singularity problem at the unrestriction point 
where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or 
small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical 
molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3)
will solve this N-representability problem by disregarding orbital response contribution of one-particle
density matrix. 

Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized 
CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched 
geometries [Bozkaya:2012:odtl]_. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based 
triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than 
CCSD based triples corrections.  

A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky 
Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory
requirements for typically negligible losses in accuracy.

**NOTE**: As will be discussed later, all methods with orbital-optimization functionality have non-orbital 
optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most
cases, users should prefer the DF-MP2 code described in the :ref:`DF-MP2 <sec:dfmp2>` section because it is
faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter
should be followed.
In general, choose the desired method, reference, and ERI type (*e.g.*,
``set reference uhf``, ``set mp2_type df``, ``opt('mp2')``) and the most
efficient module will be selected automatically, according to
:ref:`Cross-module Redundancies <table:managedmethods>`.

Thus, there arise a few categories of method, each with corresponding input keywords:

* Orbital-optimized MP and CC methods with conventional integrals (:ref:`OMP Methods <sec:occ_oo_mtds>` OCC keywords)
* Orbital-optimized MP and CC methods with DF and CD integrals (:ref:`OMP Methods <sec:occ_oo_mtds>` DFOCC keywords)
* Non-orbital-optimized MP and CC methods with conventional integrals (:ref:`MP/CC Methods <sec:occ_nonoo>` OCC keywords)
* Non-orbital-optimized MP and CC methods with DF and CD integrals (:ref:`MP/CC Methods <sec:occ_nonoo>` DFOCC keywords)

Theory
~~~~~~

What follows is a very basic description of orbital-optimized |MollerPlesset| perturbation
theory as implemented in |Psifour|.  We will follow our previous presentations ([Bozkaya:2011:omp2]_,
[Bozkaya:2011:omp3]_, and [Bozkaya:2012:odtl]_)

The orbital variations may be expressed by means of an exponential unitary operator

.. math::
   \widetilde{\hat{p}}^{\dagger} &= e^{\hat{K}} \hat{p}^{\dagger} e^{-\hat{K}}\\
   \widetilde{\hat{p}} &= e^{\hat{K}} \ \hat{p} \ e^{-\hat{K}} \\
   | \widetilde{p} \rangle &= e^{\hat{K}} \ | p \rangle

where :math:`\hat{K}` is the orbital rotation operator


.. math::
   \hat{K} &= \sum_{p,q}^{} K_{pq} \ \hat{E}_{pq} = \sum_{p>q}^{} \kappa_{pq} \ \hat{E}_{pq}^{-} \\
   \hat{E}_{pq}  &= \hat{p}^{\dagger} \hat{q} \\
   \hat{E}_{pq}^{-} &= \hat{E}_{pq} \ - \ \hat{E}_{qp} \\
   {\bf K} &= Skew({\bf \kappa}) 

The effect of the orbital rotations on the MO coefficients can be written as

.. math::
   {\bf C({\bf \kappa})} = {\bf C^{(0)}} \ e^{{\bf K}}

where :math:`{\bf C^{(0)}}` is the initial MO coefficient matrix and :math:`{\bf C({\bf \kappa})}` is the new
MO coefficient matrix as a function of :math:`{\bf \kappa}`.
Now, let us define a variational energy functional (Lagrangian) as a function of :math:`{\bf \kappa}`

* OMP2

.. math::
   \widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle \\
   &+  \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)}\big)_{c} | 0 \rangle \\
   &+  \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)} 
   \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle
    
* OMP3

.. math::
   \widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle \\
   &+ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)}\big)_{c} | 0 \rangle 
   \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}^{(2)}\big)_{c} | 0 \rangle \\
   &+  \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)} 
   \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle \\
   &+ \langle 0| \{\hat{\Lambda}_{2}^{(1)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(2)} 
   \ + \ \hat{W}_{N}^{\kappa}\hat{T}_{2}^{(1)} \big)_{c}\}_{c} | 0 \rangle \\
   &+ \langle 0| \{\hat{\Lambda}_{2}^{(2)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)} 
   \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle  
    
* OLCCD

.. math::
   \widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle 
   \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\
   &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c}  | 0 \rangle

where subscript c means only connected diagrams are allowed, and 
:math:`\hat{H}^{\kappa}`, :math:`\hat{f}_{N}^{\kappa}`, and :math:`\hat{W}_{N}^{\kappa}` defined as

.. math::
   \hat{H}^{\kappa} &=  e^{-\hat{K}} \hat{H} e^{\hat{K}} \\
   \hat{f}_{N}^{\kappa} &=  e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\
   \hat{W}_{N}^{\kappa} &=  e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}} 

where :math:`\hat{f}_{N}`, and :math:`\hat{W}_{N}` are the one- and two-electron components of normal-ordered Hamiltonian. Then, 
first and second derivatives of the energy with respect to the :math:`{\bf \kappa}` parameter at :math:`{\bf \kappa} = 0`

.. math::
   w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}} 

.. math::
   A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}} 

Then the energy can be expanded up to second-order as follows

.. math::
   \widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w}  + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}

where :math:`{\bf w}` is the MO gradient vector, :math:`{\bf \kappa}` is the MO rotation vector,
and :math:`{\bf A}` is the MO Hessian matrix. Therefore, minimizing the energy with respect to :math:`{\bf \kappa}`
yields

.. math::
   {\bf \kappa} = -{\bf A^{-1}w}

This final equation corresponds to the usual Newton-Raphson step.

Publications resulting from the use of the orbital-optimized code should cite the following publications: 

* **OMP2** [Bozkaya:2011:omp2]_ and [Bozkaya:2013:omp2grad]_

* **OMP3** [Bozkaya:2011:omp3]_ , [Bozkaya:2013:omp3]_, and [Bozkaya:2013:omp3grad]_

* **OMP2.5** [Bozkaya:2011:omp3]_

* **OLCCD** [Bozkaya:2013:ocepa]_

* **LCCD** [Bozkaya:2013:ocepa]_


Convergence Problems
~~~~~~~~~~~~~~~~~~~~

For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and 
DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals. 
In order to use ROHF orbitals, simply ``set reference rohf``. For DFT orbitals, ``set reference uks`` and ``set dft_functional b3lyp``. Of
course users can use any DFT functional available in |PSIfour|.

.. _`sec:occ_oo_mtds`:

Methods
~~~~~~~

The orbital-optimized MPn and OLCCD methods currently supported in
|Psifour| are outlined in Table :ref:`Orbital-Optimzed OCC/DFOCC
Methods <table:occ_oo_calls>`. The following methods are available
and can be controlled through OCC (conventional integrals ``CONV``)
and DFOCC (density-fitted ``DF`` and Cholesky-decomposed ``CD``)
keywords. Switching between the integrals treatments is controlled
through "type select" values in the rightmost Table column.

.. _`table:occ_oo_calls`:

.. table:: Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules

    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | name                    | calls method                                                 |  Energy              | Gradient             | type select               |
    +=========================+==============================================================+======================+======================+===========================+
    | omp2                    | Orbital-Optimized MP2                                        | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp2_type| CONV  |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted Orbital-Optimized MP2                         | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp2_type| DF    |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed Orbital-Optimized MP2                    | RHF/UHF/ROHF/RKS/UKS | ---                  | |globals__mp2_type| CD    |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | omp3                    | Orbital-Optimized MP3                                        | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted Orbital-Optimized MP3                         | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed Orbital-Optimized MP3                    | RHF/UHF/ROHF/RKS/UKS | ---                  | |globals__mp_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | omp2.5                  | Orbital-Optimized MP2.5                                      | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted Orbital-Optimized MP2.5                       | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__mp_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed Orbital-Optimized MP2.5                  | RHF/UHF/ROHF/RKS/UKS | ---                  | |globals__mp_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | olccd                   | Orbital-Optimized Linear CCD                                 | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted Orbital-Optimized LCCD                        | RHF/UHF/ROHF/RKS/UKS | RHF/UHF/ROHF/RKS/UKS | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed Orbital-Optimized LCCD                   | RHF/UHF/ROHF/RKS/UKS | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+

.. _`table:occ_scsoo_calls`:

.. table:: Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules

    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | name                    | calls method                                                 |  Energy              | Gradient             |
    +=========================+==============================================================+======================+======================+
    | scs-omp3                | Spin-Component Scaled Orbital-Optimized MP3                  | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | sos-omp3                | Spin-Opposite Scaled Orbital-Optimized MP3                   | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | scs(n)-omp3             | A special version of SCS-OMP3 for nucleobase interactions    | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | scs-omp3-vdw            | A special version of SCS-OMP3 (from ethene dimers)           | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | sos-pi-omp3             | A special version of SOS-OMP3 for :math:`\pi`-systems        | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | scs-omp2                | Spin-Component Scaled Orbital-Optimized MP2                  | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | sos-omp2                | Spin-Opposite Scaled Orbital-Optimized MP2                   | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | scs(n)-omp2             | A special version of SCS-OMP2 for nucleobase interactions    | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | scs-omp2-vdw            | A special version of SCS-OMP2 (from ethene dimers)           | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+
    | sos-pi-omp2             | A special version of SOS-OMP2 for :math:`\pi`-systems        | RHF/UHF/ROHF/RKS/UKS | ---                  |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+

.. comment    | scs-ocepa               | Spin-Component Scaled Orbital-Optimized CEPA                 | RHF/UHF/ROHF/RKS/UKS | ---                  |
.. comment    | sos-ocepa               | Spin-Opposite Scaled Orbital-Optimized CEPA                  | RHF/UHF/ROHF/RKS/UKS | ---                  |
.. comment    | scs-mi-omp2             | A special version of SCS-OMP2 (from S22 database)            |    Y    |     N    | RHF/ROHF/UHF/RKS/UKS   |
.. comment    | scs-mi-omp3             | A special version of SCS-OMP3 (from S22 database)            |    Y    |     N    | RHF/ROHF/UHF/RKS/UKS   |

.. index:: OMP2; setting keywords
.. index:: OMP3; setting keywords
.. index:: OMP2.5; setting keywords
.. index:: OLCCD; setting keywords

Basic OCC Keywords
~~~~~~~~~~~~~~~~~~

.. include:: /autodir_options_c/occ__e_convergence.rst
.. include:: /autodir_options_c/occ__r_convergence.rst
.. include:: /autodir_options_c/occ__rms_mograd_convergence.rst
.. include:: /autodir_options_c/occ__max_mograd_convergence.rst
.. include:: /autodir_options_c/occ__mo_maxiter.rst
.. include:: /autodir_options_c/occ__wfn_type.rst
.. include:: /autodir_options_c/occ__orb_opt.rst

Advanced OCC Keywords
~~~~~~~~~~~~~~~~~~~~~

.. include:: /autodir_options_c/occ__opt_method.rst
.. include:: /autodir_options_c/occ__lineq_solver.rst
.. include:: /autodir_options_c/occ__orth_type.rst
.. include:: /autodir_options_c/occ__mp2_os_scale.rst
.. include:: /autodir_options_c/occ__mp2_ss_scale.rst
.. include:: /autodir_options_c/occ__mp2_sos_scale.rst
.. include:: /autodir_options_c/occ__mp2_sos_scale2.rst
.. include:: /autodir_options_c/occ__nat_orbs.rst
.. include:: /autodir_options_c/occ__occ_orbs_print.rst
.. include:: /autodir_options_c/occ__tpdm_abcd_type.rst
.. include:: /autodir_options_c/occ__do_diis.rst
.. include:: /autodir_options_c/occ__do_level_shift.rst

Basic DFOCC Keywords
~~~~~~~~~~~~~~~~~~~~

.. include:: /autodir_options_c/dfocc__e_convergence.rst
.. include:: /autodir_options_c/dfocc__r_convergence.rst
.. include:: /autodir_options_c/dfocc__rms_mograd_convergence.rst
.. include:: /autodir_options_c/dfocc__max_mograd_convergence.rst
.. include:: /autodir_options_c/dfocc__mo_maxiter.rst
.. include:: /autodir_options_c/dfocc__orb_opt.rst

Advanced DFOCC Keywords
~~~~~~~~~~~~~~~~~~~~~~~

.. include:: /autodir_options_c/dfocc__opt_method.rst
.. include:: /autodir_options_c/dfocc__hess_type.rst
.. include:: /autodir_options_c/dfocc__mo_diis_num_vecs.rst
.. include:: /autodir_options_c/dfocc__orth_type.rst
.. include:: /autodir_options_c/dfocc__do_diis.rst
.. include:: /autodir_options_c/dfocc__do_level_shift.rst



.. _`sec:occ_nonoo`:

Conventional (Non-OO) Coupled-Cluster and |MollerPlesset| Perturbation Theories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Non-orbital-optimized counterparts to higher order MPn methods are also
available. The following methods are available and can be controlled
through OCC (conventional integrals ``CONV``) and DFOCC (density-fitted
``DF`` and Cholesky-decomposed ``CD``) keywords. Switching between
the integrals treatments is controlled through 'type select' values;
see rightmost column in Table :ref:`Conventional OCC/DFOCC Methods
<table:occ_nonoo_calls>`.

Depending on efficiency considerations, the OCC & DFOCC modules may
or may not be the default in |PSIfour| for available methods. (See
:ref:`Cross-module Redundancies <table:managedmethods>` for gory
details.) To call the OCC/DFOCC implementation of any method below in
preference to the default module, issue ``set qc_module occ``.

Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set |globals__mp_type| to ``CONV`` to get previous behavior.

.. _`table:occ_nonoo_calls`:

.. table:: Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules

    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | name                    | calls method                                                 |  Energy              | Gradient             | type select               |
    +=========================+==============================================================+======================+======================+===========================+
    | mp2                     | MP2                                                          | RHF/UHF/ROHF         | RHF/UHF              | |globals__mp2_type| CONV  |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted MP2                                           | RHF/UHF/ROHF         | RHF/UHF              | |globals__mp2_type| DF    |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed MP2                                      | RHF/UHF/ROHF         | ---                  | |globals__mp2_type| CD    |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | mp3                     | MP3                                                          | RHF/UHF              | RHF/UHF              | |globals__mp_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted MP3                                           | RHF/UHF              | RHF/UHF              | |globals__mp_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed MP3                                      | RHF/UHF              | ---                  | |globals__mp_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | mp2.5                   | MP2.5                                                        | RHF/UHF              | RHF/UHF              | |globals__mp_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted MP2.5                                         | RHF/UHF              | RHF/UHF              | |globals__mp_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed MP2.5                                    | RHF/UHF              | ---                  | |globals__mp_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | lccd                    | Linearized CCD                                               | RHF/UHF              | RHF/UHF              | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted LCCD                                          | RHF/UHF              | RHF/UHF              | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed LCCD                                     | RHF/UHF              | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | ccd                     | CCD                                                          | ---                  | ---                  | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted CCD                                           | RHF                  | RHF                  | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed CCD                                      | RHF                  | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | ccsd                    | CCSD                                                         | ---                  | ---                  | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted CCSD                                          | RHF                  | RHF                  | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed CCSD                                     | RHF                  | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | ccsd(t)                 | CCSD(T)                                                      | ---                  | ---                  | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted CCSD(T)                                       | RHF                  | RHF                  | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed CCSD(T)                                  | RHF                  | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    | a-ccsd(t)               | Lambda-CCSD(T)                                               | ---                  | ---                  | |globals__cc_type| CONV   |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Density-Fitted Lambda-CCSD(T)                                | RHF                  | ---                  | |globals__cc_type| DF     |
    +                         +--------------------------------------------------------------+----------------------+----------------------+---------------------------+
    |                         | Cholesky-Decomposed Lambda-CCSD(T)                           | RHF                  | ---                  | |globals__cc_type| CD     |
    +-------------------------+--------------------------------------------------------------+----------------------+----------------------+---------------------------+


PsiAPI Tutorial: Using |PSIfour| as a Python Module
===================================================

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: MRCC
.. _`sec:mrcc`:

Interface to MRCC by M. K\ |a_acute|\ llay
==========================================

.. codeauthor:: Justin M. Turney and Andrew C. Simmonett
.. sectionauthor:: Justin M. Turney


*Module:* :ref:`Keywords <apdx:mrcc>`, :ref:`PSI Variables <apdx:mrcc_psivar>`, :source:`MRCC <psi4/src/psi4/mrcc>`, :ref:`Samples <apdx:testSuitemrcc>`

|PSIfour| contains code to interface to the MRCC program of M. K\ |a_acute|\ llay
and J. Gauss.  The license and source code of the MRCC program must be
obtained from Mih\ |a_acute|\ ly K\ |a_acute|\ llay (`https://www.mrcc.hu/ <https://www.mrcc.hu/>`_).

Installation
~~~~~~~~~~~~

Follow the instructions provided with the source to build the MRCC programs.
To be used by |PSIfour|, ensure that the program binary (``dmrcc``) can be
found in your :envvar:`PATH`. If |PSIfour| is unable to execute the binary, an
error will be reported.

Running MRCC
~~~~~~~~~~~~
MRCC can be invoked in similar fashion as other theories provided in |PSIfour|.
For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using
MRCC simply provide the following::

   molecule h2o {
        O
        H 1 1.0
        H 1 1.0 2 104.5
   }
   set {
        basis cc-pVDZ
   }
   energy('mrccsdt')

``'mrccsdt'`` in the call to :py:func:`~psi4.energy` instructs |PSIfour| to first
perform an RHF calculation and then call MRCC to compute the CCSDT energy.
For a CCSDT(Q) energy, simply use ``'mrccsdt(q)'`` in the call to
:py:func:`~psi4.energy`. MRCC can be used to perform geometry optimization and
frequency calculations for electronic ground states only.

At this time, |PSIfour| is only able to automatically generate the proper
input file for MRCC for the methods listed in table below.
To utilize any method described in the table, you must prefix
the method name with ``MR``. For other methods, you will be required to
use the MRCC keywords described in Appendix :ref:`apdx:mrcc`.
Perturbative methods (``ccsd(t)``, ``ccsdtqp(h)_l``, etc.)
are available with |scf__reference| ROHF in versions of MRCC published
at least after July 1, 2014.

When using ROHF-CCSDT(Q), MRCC will compute and report two variants:
CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101]_ |PSIfour| will save both energies but will use
the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be
more robust by Martin. [Martin:2014:785]_

.. include:: mrcc_table_energy.rst

Frozen-core approximation is also supported in the MRCC interface.
To optimize CH\ :sub:`4` with CCSDT freezing the 1\ *s* on carbon, run::

   molecule H2O {
       O
       H 1 r
       H 1 r 2 104.5
   
       r = 1.0
   }
   
   set {
       basis cc-pVDZ
       freeze_core true
   }
   
   optimize('mrccsdt')

Interface Details
~~~~~~~~~~~~~~~~~

.. _`table:mrcc__mrcc_method`:

.. table:: MRCC methods 

    +---------------------+--------------+-------------------------------------------------------------+
    | |mrcc__mrcc_method| | Method       | Description                                                 | 
    +=====================+==============+=============================================================+ 
    | 1                   | CC           |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+
    | 2                   | CC(n-1)[n]   |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+
    | 3                   | CC(n-1)(n)   | (CC(n-1)[n] energy is also calculated)                      | 
    +---------------------+--------------+-------------------------------------------------------------+
    | 4                   | CC(n-1)(n)_L | (CC(n-1)[n] and CC(n-1)(n) energies are also calculated)    | 
    +---------------------+--------------+-------------------------------------------------------------+
    | 5                   | CC(n)-1a     |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+
    | 6                   | CC(n)-1b     |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+
    | 7                   | CCn          |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+
    | 8                   | CC(n)-3      |                                                             |
    +---------------------+--------------+-------------------------------------------------------------+

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: 
   Molden
   WebMO
   visualization

.. _`sec:molden`:

Interface to Molden |w---w| :py:func:`~psi4.molden`
===================================================

.. codeauthor:: Justin M. Turney
.. sectionauthor:: C. David Sherrill

|PSIfour| contains an interface to the Molden program.  Molden is a 
visualization program for electronic structure developed by Gijs Schaftenaar
at the University of of Nijmegen, Netherlands.  It is available at 
https://www3.cmbi.umcn.nl/molden/ . Molden can
plot atomic orbitals, densities, electrostatic potentials (ESPs), etc.
|PSIfour| can create a file containing
atomic coordinates, basis set, and SCF orbital coefficients in the 
so-called Molden format.  This file is
written by the SCF module (see Section :ref:`SCF <sec:scf>`) 
if the user sets the |scf__molden_write| keyword to true.  This Molden file is 
also used to pass information between |PSIfour| and WebMO, if |PSIfour| 
computations are invoked using the WebMO GUI.  The filename of the 
Molden file ends in ".molden", and the prefix is determined by 
|globals__writer_file_label| (if set), or else by the name of the output
file plus the name of the current molecule. If |globals__molden_with_virtual|
is set to false, the unoccupied orbitals are not written to the Molden
file.

.. autofunction:: psi4.molden(wfn, filename)
   :noindex:

Options
~~~~~~~

.. include:: autodir_options_c/scf__molden_write.rst
.. include:: autodir_options_c/globals__writer_file_label.rst
.. include:: autodir_options_c/globals__molden_with_virtual.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`apdx:bib`:

Bibliography
============
|
|

.. [Gonthier:2016:134106]
   J. F. Gonthier and C.D. Sherrill,
   *J. Chem. Phys.* **145**, 134106 (2016).

.. [Parrish:2015:051103]
   R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C.D. Sherrill,
   *J. Chem. Phys.* **143**, 051103 (2015).

.. [Parrish:2014:17386]
   R. M. Parrish and C.D. Sherrill,
   *J. Am. Chem. Soc.* **136**, 17386 (2014).

.. [Parrish:2014:4417]
   R. M. Parrish, T. M. Parker, and C.D. Sherrill,
   *J. Chem. Theory Comput.* **10**, 4417 (2014).

.. [Parrish:2014:044115]
   R. M. Parrish and C.D. Sherrill,
   *J. Chem. Phys.* **141**, 044115 (2014).

.. [Jeziorski:1994:1887]
   B. Jeziorski, R. Moszynski, and K. Szalewicz,
   *Chem. Rev.* **94**, 1887 (1994).

.. [Parker:2014:094106]
   T. M. Parker, L. A. Burns, R. M. Parrish, A. G. Ryno, and C. D. Sherrill,
   *J. Chem. Phys.* **140**, 094106 (2014).

.. [Hohenstein:2012:WIREs]
   E. G. Hohenstein and C. D. Sherrill,
   *WIREs Comput. Mol. Sci.* **2**, 304-326 (2012).

.. [Hohenstein:2010:184111]
   E. G. Hohenstein and C. D. Sherrill,
   *J. Chem. Phys.* **132**, 184111 (2010).

.. [Hohenstein:2011:174107]
   E. G. Hohenstein, R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F.
   Schaefer III, *J. Chem. Phys.* **135**, 174107 (2011).

.. [Hohenstein:2011:2842]
   E. G. Hohenstein, H. M. Jaeger, E. J. Carrell, G. S. Tschumper, and
   C. D. Sherrill, *J. Chem. Theory Comput.* **7**, 2842-2851 (2011).

.. [Parrish:2013:174102]
   R. M. Parrish and C. D. Sherrill,
   *J. Chem. Phys.* **139**, 174102 (2013).

.. [Hohenstein:2010:014101]
   E. G. Hohenstein and C. D. Sherrill,
   *J. Chem. Phys.* **133**, 014101 (2010).

.. [Hohenstein:2010:104107]
   E. G. Hohenstein and C. D. Sherrill,
   *J. Chem. Phys.* **133**, 104107 (2010).

.. [Misquitta:2009:201]
   A. J. Stone and A. J. Misquitta,
   *Chem. Phys. Lett.* **473**, 201 (2009).

.. [Papajak:2011:10]
   E. Papajak and D. G. Truhlar,
   *J. Chem. Theory Comput.* **7**, 10-18 (2011).

..
   [Cohen:GreenBook:2008]
   E. R. Cohen, T. Cvitas, J. G. Frey, B. Holmstr\ |o_dots|\ om,
   K. Kuchitsu, R. Marquardt, I. Mills, F. Pavese, M. Quack,
   J. Stohner, H. L. Strauss, M. Takami, and A. J. Thor,
   Quantities, Units, and Symbols in Physical chemistry, IUPAC Green
   Book, 3rd. Ed., IUPAC & RSC Publishing (Cambridge, 2008).

.. [PubChem]
   E. Bolton, Y. Wang, P. A. Thiessen, S. H. Bryant.  PubChem:
   Integrated Platform of Small Molecules and Biological Activities,
   Chapter 12 in *Annual Reports in Computational Chemistry*, Volume
   4 (American Chemical Society: Washington, DC, 2008).
   See https://pubchem.ncbi.nlm.nih.gov/.

.. [Sherrill:1999:CI]
   C. D. Sherrill and H. F. Schaefer III,
   *Advances in Quantum Chemistry*, Vol. 34, edited by P.-O. L\ |o_dots|\ wdin
   (Academic Press, New York, 1999), pages 143-269.

.. [Hirata:2000:216]
   S. Hirata and R. J. Bartlett,
   *Chem. Phys. Lett.* **321**, 216 (2000).

.. [Olsen:2000:7140]
   J. Olsen,
   *J. Chem. Phys.* **113**, 7140 (2000).

.. [Peng:1996:49]
   Peng, Ayala, Schlegel, and Frisch,
   *J. Comput. Chem.* **17**, 49 (1996).

.. [Bakken:2002:9160]
   Bakken and Helgaker,
   *J. Chem. Phys.* **117**, 9160 (2002).

.. [Schlegel:1984:333]
   Schlegel,
   *Theor. Chim. Acta* **66**, 333 (1984).

.. [Fischer:1992:9770]
   Fischer and Almlof,
   *J. Phys. Chem.* **96**, 9770 (1992).

.. [Schlegel:1987:AIMQC]
   Schlegel,
   *Ab Initio Methods in Quantum Chemistry*, (1987).

.. [Bofill:1994:1]
   Bofill,
   *J. Comp. Chem.* **15**, 1-11 (1994).

.. [Piecuch:1999:6103]
   P. Piecuch, S. A. Kicharski, and R. J. Bartlett,
   *J. Chem. Phys.* **110**, 6103 (1999).

.. [Handy:1980]
   N. C. Handy,
   *Chem. Phys. Lett.* **74**, 280 (1980).

.. [Olsen:1988]
   J. Olsen, B. O. Roos, P. J\ |o_slash|\ rgensen, and H. J. Aa. Jensen,
   *J. Chem. Phys.* **89** 2185 (1988).

.. [Schirmer:1982]
   J. Schirmer,
   *Phys. Rev. A* **26**, 2395 (1982).

.. [Trofimov:2006]
   A. B. Trofimov, I. L, Krivdina, J. Weller, and J. Schirmer,
   *Chem. Phys.* **329**, 1 (2006).

.. [Haettig:2002]
   C. H\ |a_dots|\ aettig and K. Hald,
   *Phys. Chem. Chem. Phys.* **4**, 2111 (2002).

.. [Saitow:2012]
   M. Saitow and Y. Mochizuki,
   *Chem. Phys. Lett.* **X**, XX (2012).

..
   [Evangelista:2010:4728]
   F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer III,
   *J. Chem. Phys.* **132**, (2010).

.. [Evangelista:2009:4728]
   F. A. Evangelista, A. C. Simmonett, H. F. Schaefer III, D. Mukherjee, and W. D. Allen,
   *Phys. Chem. Chem. Phys.* **11**, 4728 (2009).

.. [Evangelista:2006:154113]
   F. A. Evangelista, W. D. Allen, and H. F. Schaefer III,
   *J. Chem. Phys.* **125**, 154113 (2006).

.. [Evangelista:2008:124104]
   F. A. Evangelista, A. C. Simmonett, W. D. Allen, H. F. Schaefer III, and J. Gauss,
   *J. Chem. Phys.* **128**, 124104 (2008).

.. [Cheng:084114]
   L. Cheng and J. Gauss,
   *J. Chem. Phys.* **135**, 084114 (2011).

.. [Verma:2015]
   P. Verma, W. D. Derricotte, F. A. Evangelista,
   *J. Chem. Theory Comput.* **DOI: 10.1021/acs.jctc.5b00817** (2015).

.. [Jeziorski:1981:1668]
   B. Jeziorski and H. J. Monkhorst,
   *Phys. Rev. A* **24**, 1668 (1981).

.. [Raghavachari:1989]
   K. Raghavachari, G. W. Trucks, J. A. Pople, and M. Head-Gordon,
   *Chem. Phys. Lett.* **157**, 479-483 (1989).

.. [Purvis:1982]
   G. D. Purvis and R. J. Bartlett,
   *J. Chem. Phys.* **76**, 1910-1918 (1982).

.. [Sosa:1989:148]
   C. Sosa, J. Geersten, G. W. Trucks, R. J. Barlett, and J. A. Franz,
   *Chem. Phys. Lett.* **159**, 148--154 (1989).

.. [Roos:1980]
   B. O. Roos,
   *Chem. Phys.* **48**, 157-173 (1980).

.. [Chaban:1997:88]
   G. Chaban, M. W. Schmidt, and M. S. Gordon,
   *Theor. Chem. Acc.* **97**, 88-95 (1997).

.. [Pulay:1980]
   P. Pulay,
   *Chem. Phys. Lett.* **73**, 393-398 (1980).

.. [Malmqvist:1990:RASSCF]
   P.-A. Malmqvist, A. Rendell, and B. O. Roos,
   *J. Phys. Chem.* **94**, 5477-5482 (1990).

..
   [Docken:1972:4928]
   K. K. Docken and J. Hinze,
   *J. Chem. Phys.* **57**, 4928-4936 (1972).

..
   [Ruedenberg:1979:1069]
   K. Ruedenberg, L. M. Cheung, and S. T. Elbert,
   *Int. J. Quantum Chem.* **16**, 1069-1101 (1979).

.. [Evangelista:2010:074107]
   F. A. Evangelista, E. Prochnow, J. Gauss, and H. F. Schaefer III,
   *J. Chem. Phys.* **132**, 074107 (2010).

.. [Wennmohs:2008:217]
   F. Wennmohs and F. Neese,
   *Chem. Phys.* **343**, 217-230 (2008).

.. [DePrince:2013:293]
   A. E. DePrince III and C. D. Sherrill,
   *J. Chem. Theory Comput.* **9**, 293-299 (2013).

.. [DePrince:2013:2687]
   A. E. DePrince III and C. D. Sherrill,
   *J. Chem. Theory Comput.* **9**, 2687-2696 (2013).

.. [Curtiss:1991:7221]
   L. A. Curtiss, K. Raghavachari, G. W. Trucks, and J. A. Pople,
   *J. Chem. Phys.* **94**, 7221-7230 (1991).

.. [Pople:1987:5968]
   J. A. Pople, M. Head-Gordon, and K. J. Raghavachari,
   *Chem. Phys.* **87**, 5968 (1987).

.. [Crawford:1997:instability]
   T. D. Crawford, J. F. Stanton, W. D. Allen, and H. F. Schaefer III,
   *J. Chem. Phys.*, **107**, 10626 (1997).

.. [Sherrill:1998:od]
   C. D. Sherrill, A. I. Krylov, E. F. C. Byrd, and M. Head-Gordon,
   *J. Chem. Phys.* **109**, 4171 (1998).

.. [Krylov:2000:vod]
   A. I. Krylov, C. D. Sherrill, and M. Head-Gordon,
   *J. Chem. Phys.* **113**, 6509 (2000).

.. [Kurlancek:2009]
   W. Kurlancheek and M. Head-Gordon,
   *Mol. Phys.* **107**, 1223 (2009).

.. [Pedersen:1999:od]
   T. B. Pedersen, H. Koch, and C. Hattig,
   *J. Chem. Phys.* **110**, 8318 (1999).

..
   [Pedersen:2001:od]
   T. B. Pedersen, B. Fernandez, and H. Koch,
   *J. Chem. Phys.* **114**, 6983 (2001).

.. [Bozkaya:2011:omp2]
   U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer III, and C. D. Sherrill
   *J. Chem. Phys.* **135**, 104103 (2011).

.. [Bozkaya:2013:omp2grad]
   U. Bozkaya and C. D. Sherrill
   *J. Chem. Phys.* **138**, 184103 (2013).

.. [Bozkaya:2011:omp3]
   U. Bozkaya,
   *J. Chem. Phys.* **135**, 224103 (2011).

.. [Bozkaya:2013:omp3]
   E. Soydas and U. Bozkaya,
   *J. Chem. Theory Comput.* **9**, 1452 (2013).

.. [Bozkaya:2012:odtl]
   U. Bozkaya and H. F. Schaefer III,
   *J. Chem. Phys.* **136**, 204114 (2012).

.. [Bozkaya:2013:ocepa]
   U. Bozkaya and C. D. Sherrill
   *J. Chem. Phys.* **139**, 054104 (2013).

.. [Bozkaya:2013:omp3grad]
   U. Bozkaya,
   *J. Chem. Phys.* **139**, 104116 (2013).

.. [Grimme:2004:1463]
   S. Grimme, *J. Comp. Chem.* **25** 1463-1473 (2004).

.. [Grimme:2006:1787]
   S. Grimme, *J. Comp. Chem.* **27**, 1787-1799 (2006).

.. [Grimme:2010:154104]
   S. Grimme, J. Antony, S. Ehrlich, and H. Krieg,
   *J. Chem. Phys.* **132**, 154104 (2010).

.. [Grimme:2011:1456]
   S. Grimme, S. Ehrlich, and L. Goerigk,
   *J. Comput. Chem.* **32**, 1456 (2011).

.. [Wu:2002:515]
   Q. Wu and W. Yang,
   *J. Chem. Phys.* **116**, 515 (2002).

.. [Hohenberg:1964:136]
   P. Hohenberg and W. Kohn,
   *Phys. Rev.* **136**, B864-B871 (1964).

.. [Kohn:1965:A1133]
   W. Kohn and L.J. Sham,
   *Phys. Rev.* **140**, A1133-A1138 (1965).

.. [Parr:1989]
   R.G. Parr and W. Yang,
   *Density Functional Theory of Atoms and Molecules* **Oxford University Press, USA, 1989** ISBN:0195357736, 9780195357738

.. [FW:1950]
   L. L. Foldy and S. A. Wouthuysen,
   *Phys. Rev.* **78**, 29-36 (1950)

.. [Kutzelnigg:1984]
   W. Kutzelnigg,
   *Int. J. Quantum Chem.* **25**, 107-129 (1984)

.. [Smith:2016:2197]
   D. Smith, L. Burns, K. Patkowski, and D. Sherrill,
   *J. Phys. Chem. Lett.* **7**, 2197-2203 (2016).

.. [Szabo:1982]
   A. Szabo and N. S. Ostlund,
   *Modern Quantum Chemistry: Introduction to Advanced Electronic Structure Theory*
   **1982** ISBN:0486691861

.. [Grimme:2015:054107]
   S. Grimme, J. Brandenburg, C. Bannwarth, and A. Hansen,
   *J. Chem. Phys.* **143**, 054107 (2015).

.. [Sure:2013:1672]
   R. Sure and S. Grimme,
   *J. Comput. Chem.* **15**, 1672 (2013).

.. [Kallay:2008:144101]
   M. Kallay and J. Gauss,
   *J. Chem. Phys.* **129**, 144101 (2008).

.. [Martin:2014:785]
   J. M. L. Martin,
   *Mol. Phys.* **112**, 785 (2014).

.. [Cammi:2009:164104]
   R. Cammi,
   *J. Chem. Phys.* **131**, 164104 (2009).

.. [Tomasi:2005:2999]
   J. Tomasi, B. Mennucci, and R. Cammi
   *Chem. Rev.* **105**, 2999 (2005).

.. [McGibbon:2017:161725]
   R. T. McGibbon, A. G. Taube, A. G. Donchev, K. Siva, F. Hern\ |a_acute|\ andez, C. Hargus, K. H. Law, J. L. Klepeis, D. E. Shaw
   *J. Chem. Phys.* **147**, 161725 (2017).

.. [Patkowski:2018:164110]
   Konrad Patkowski, Piotr S. \.Zuchowski, Daniel G. A. Smith
   *J. Chem. Phys.* **148**, 164110 (2018).

.. [Morell:2005:205]
   Christophe Morell, Andr\ |e_acute|\  Grand, and Alejandro Toro-Labb\ |e_acute|
   *J. Phys. Chem. A* **109**, 205 (2005).

.. [Martinez-Araya:2015:451]
   Jorge Ignacio Mart\ |i_acute|\ nez-Araya
   *J. Math. Chem.* **53**, 451 (2015).

.. [Hujo:2011:3866]
   W. Hujo and S. Grimme
   *J. Chem. Theory Comput.* **7** 3866 (2011).

.. [Chai:2010:6615]
   J. Chai and M. Head-Gordon
   *Phys. Chem. Chem. Phys.* **10** 6615 (2008).

.. [Pernal:2009:263201]
   K. Pernal, R. Podeszwa, K. Patkowski, K. Szalewicz
   *Phys. Rev. Lett.* **103** 263201 (2009).

.. [Podeszwa:2010:550]
   R. Podeszwa, K. Pernal, K. Patkowski, K. Szalewicz
   *J. Phys. Chem. Lett.* **1** 550 (2010).

.. [Schaffer:2012:1235]
   R. Sch\ |a_dots|\ ffer and G. Jansen
   *Theor. Chem. Acc.* **131**, 1235 (2012).

.. [Schaffer:2013:2570]
   R. Sch\ |a_dots|\ ffer and G. Jansen
   *Mol. Phys.* **111**, 2570 (2013).

.. [Laqua:2018:204111]
   H. Laqua, J. Kussmann and C. Ochsenfeld
   *J. Chem. Phys.* **149**, 204111 (2018)

.. [Lehtola:2019:1593]
   S. Lehtola
   *J. Chem. Theory Comput.* **15**, 1593 (2019), doi: 10.1021/acs.jctc.8b01089.

.. [Lehtola:2019:241102]
   S. Lehtola
   *J. Chem. Phys.* **151**, 241102 (2019), doi: 10.1063/1.5139948.

 .. [Lehtola:2019:25945]
   S. Lehtola
   *Int. J. Quantum Chem.* **119**, e25945 (2019), doi: 10.1002/qua.25945.

.. [Lehtola:2020:012516]
   S. Lehtola
   *Phys. Rev. A.* **101**, 012516 (2020), doi: 10.1103/PhysRevA.101.012516.

.. [Lehtola:2020:032504]
   S. Lehtola
   *Phys. Rev. A.* **101**, 032504 (2020), doi: 10.1103/PhysRevA.101.032504.

.. [Lehtola:2020:04224]
   S. Lehtola
   *arXiv* 2001:04224.

.. [Olsen:2010:3721]
   J. M. Olsen, K. Aidas, and J. Kongsted.
   *J. Chem. Theory Comput.* **6**, 3721-3734 (2010).

.. [Dreuw:2014:82]
   A. Dreuw and M. Wormit.
   *WIREs Comput. Mol. Sci.*  **5**, 82-95 (2014).

.. [Herbst2020]
   M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.
   *WIREs Comput. Mol. Sci.*, (2020) **DOI: 10.1002/wcms.1462**, Preprint https://adc-connect.org/q/publications

.. [Houck:2019:2278]
   S. E. Houck and N. J. Mayhall,
   *J. Chem. Theory Comput.* **15**, 2278-2290 (2019).

.. [Krylov:2001:522]
   A. I. Krylov,
   *Chem. Phys. Lett.* **350**, 522-530 (2001).

.. [Nooijen:1995:3629]
   M. Nooijen and R. J. Bartlett,
   *J. Chem. Phys.* **102**, 3629 (1995).

.. [Wang:2016:214108]
   L.-P. Wang and C. Song,
   *J. Chem. Phys.* **144**, 214108 (2016).

.. [stratmann:1998]
   R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch
   *J. Chem. Phys.* **109**, 8218 (1998), doi: 10.1063/1.477483.

.. [Pedersen1995-du]
   T. B. Pedersen, A. E. Hansen
   *Chem. Phys. Lett.* **246**, 1 (1995), doi: 10.1016/0009-2614(95)01036-9.

.. [Lestrange2015-xn]
   P. J. Lestrange, F. Egidi, X. Li
   *J. Chem. Phys.* **143**, 234103 (2015), doi: 10.1063/1.4937410.

.. [Rizzo2011-to]
    A. Rizzo, S. Coriani, K. Ruud, "Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy". In Computational Strategies for Spectroscopy, doi: 10.1002/9781118008720.ch2.

.. [Dreuw2005-wp]
   A. Dreuw, M. Head-Gordon
   *Chem. Rev.* **105**, 4009 (2005), doi: 10.1021/cr0505627.

.. [Norman2018-tn]
   P. Norman, K. Ruud, T. Saue, "Principles and Practices of Molecular Properties: Theory, Modeling, and Simulations". John Wiley & Sons, 2018

.. [Verstraelen:2016]
   T. Verstraelen et al. "Minimal Basis Iterative Stockholder: Atoms in Molecules for Force-Field Development". *J. Chem. Theory and Comput.* doi: 10.1021/acs.jctc.6b00456.

..
   [Misquitta:2005:214103]
   A. J. Misquitta and R. Podeszwa,
   *J. Chem. Phys.* **123**, 214103 (2005).

..
   [Hesselmann:2005:014103]
   A. Hesselmann and G. Jansen,
   *J. Chem. Phys.* **122**, 014103 (2005).

.. [Hesselmann:2014:094107]
   A. Hesselmann and T. Korona,
   *J. Chem. Phys.* **141**, 094107 (2014).

.. [Hylleraas:1930:209]
   E. Hylleraas
   *Z. Phys.* **65**, 209 (1930).

.. [Pulay:1986:357]
   P. Pulay and S. Saeb\ |o_slash|\ ,
   *Theor. Chim. Acta* **69**, 357 (1986).

.. [Pinski:2015:034108]
   P. Pinski, C. Riplinger, E. Valeev, and F. Neese,
   *J. Chem. Phys.* **143**, 034108 (2015).

.. [Liakos:2015:1525]
   D. Liakos, M. Sparta, M. Kesharwani, J. Martin, and F. Neese,
   *J. Chem. Theory Comput.* **11**, 1525 (2015).
   
.. [Smith:2018:3504]
    10.1021/acs.jctc.8b00286,
    "PSI4NUMPY: An Interactive Quantum Chemistry Programming Environment for Reference Implementations and Rapid Development",
    D. G. A. Smith, L. A. Burns, D. A. Sirianni, D. R. Nascimento, A. Kumar, A. M. James, J. B. Schriber, T. Zhang, B. Zhang, A. S. Abbott, E. J. Berquist, M. H. Lechner, L. A. Cunha, A. G. Heide, J. M. Waldrop, T. Y. Takeshita, A. Alenaizan, D. Neuhauser, R. A. King, A. C. Simmonett, J. M. Turney, H. F. Schaefer III, F. A. Evangelista, A. E. DePrince, T. D. Crawford, K. Patkowski, and C. D. Sherrill
    *J. Chem. Theory Comput.* **14**, 3504-3511 (2018).

.. [Schriber:2021:234107]
    J. B. Schriber, D. A. Sirianni, D. G. A. Smith, L. A. Burns, D. Sitkoff, D. L. Cheney, C. D. Sherrill
    *J. Chem. Phys.* **154**, 234107 (2021).

.. [Caldeweyher:2019:154122]
   "A generally applicable atomic-charge dependent London dispersion correction",
   E. Caldeweyher,  S. Ehlert,  A. Hansen, H. Neugebauer, S. Spicher, C. Bannwarth, and S. Grimme,
   *J. Chem. Phys.* **150**, 154122 (2019).
   https://doi.org/10.1063/1.5090222

.. [Haser:1989:104]
   M. Haser and R. Ahlrichs,
   *J. Comp. Chem.* **10(1)**, 104 (1989).
   doi: 10.1002/jcc.540100111
   
.. [Thompson:2017:144101]
   T. H. Thompson and C. Ochsenfeld
   *J. Chem. Phys.* **147**, 144101 (2017).
   doi: 10.1063/1.4994190
   
.. [Smith:2020:184108]
    "PSI4 1.4: Open-source software for high-throughput quantum chemistry",
    D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C. Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A. M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B. Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O'Brien, J. M. Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, B. R. Brooks, H. F. Schaefer III, A. Yu. Sokolov, K. Patkowski, A. E. DePrince III, U. Bozkaya, R. King, F. A. Evangelista, J. M. Turney, T. D. Crawford, and C. D. Sherrill
    *J. Chem. Phys.* **152**, 184108 (2020).
    doi: 10.1063/5.0006002

.. [Waldrop:2021:024103]
   "Nonapproximated third-order exchange induction energy in symmetry-adapted perturbation theory",
   J. M. Waldrop and K. Patkowski
   *J. Chem. Phys.* **154**, 024103 (2021).
   doi: 10.1063/1.4994190
   
.. [Ochsenfeld:1998:1663]
   C. Ochsenfeld, C. A. White, M. Head-Gordon
   *J. Chem. Phys.* **109**, 1663 (1998)
   doi: 10.1063/1.476741.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: PCMSolver, PCM

.. _`sec:pcmsolver`:

Interface to PCMSolver by R. Di Remigio
=======================================

.. codeauthor:: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett
.. sectionauthor:: Roberto Di Remigio

*Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`

.. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg
   :target: https://github.com/PCMSolver/pcmsolver

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://pcmsolver.readthedocs.io/en/latest/

|PSIfour| contains code to interface to the PCMSolver library developed
by R. Di Remigio and L. Frediani.
The PCMSolver library requires no additional licence, downloads, or
configuration. The library allows for calculations in solution with the
polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg
     :target: https://anaconda.org/psi4/pcmsolver

* PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, PCMSolver has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect PCMSolver and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   pcmsolver from conda without thinking, consult.

* To remove a conda installation, ``conda remove pcmsolver``.

**Source**

* .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000
     :target: https://github.com/PCMSolver/pcmsolver

* If using |PSIfour| built from source and you want PCMSolver built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_PCMSolver`,
  and let the build system fetch and build it and activate dependent code.

.. index:: PCM; Using PCM

.. _`sec:usingPCM`:

Using the polarizable continuum model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The inclusion of a PCM description of the solvent into your calculation
is achieved by setting |globals__pcm| ``true`` in your input file.
|Psifour| understands the additional option |pcm__pcm_scf_type| with possible values ``total``
(the default) or ``separate``.
The latter forces the separate handling of nuclear and electronic electrostatic potentials and
polarization charges. It is mainly useful for debugging.

For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::

    pcm = {
       Medium {
       Nonequilibrium = True
       }
    }

.. note:: At present PCM can only be used for energy calculations with SCF
          wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.
          All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported.

.. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available.

.. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry.

.. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.
             For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_

.. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used
             regardless of the ``dertype`` passed to the ``optimize`` function.
             See :srcsample:`pcmsolver/opt-fd` for a sample input.

The PCM model and molecular cavity are specified in a ``pcm`` section that has
to be explicitly typed in by the user. This additional section follows a syntax
that is slightly different from that of |Psifour| and is fully documented
`here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_

A typical input for a Hartree--Fock calculation with PCM would look like the following: ::

    molecule NH3 {
    symmetry c1
    N     -0.0000000001    -0.1040380466      0.0000000000
    H     -0.9015844116     0.4818470201     -1.5615900098
    H     -0.9015844116     0.4818470201      1.5615900098
    H      1.8031688251     0.4818470204      0.0000000000
    units bohr
    no_reorient
    no_com
    }

    set {
      basis STO-3G
      scf_type pk
      pcm true
      pcm_scf_type total
    }

    pcm = {
       Units = Angstrom
       Medium {
       SolverType = IEFPCM
       Solvent = Water
       }

       Cavity {
       RadiiSet = UFF
       Type = GePol
       Scaling = False
       Area = 0.3
       Mode = Implicit
       }
    }

More examples can be found in the directories with PCM tests
:srcsample:`pcmsolver/ccsd-pte`,
:srcsample:`pcmsolver/scf`,
:srcsample:`pcmsolver/opt-fd`,
:srcsample:`pcmsolver/dft`, and
:srcsample:`pcmsolver/dipole`.

Keywords for PCMSolver
~~~~~~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/globals__pcm.rst
.. include:: autodir_options_c/pcm__pcm_scf_type.rst
.. include:: autodir_options_c/pcm__pcm_cc_type.rst

.. _`cmake:pcmsolver`:

How to configure PCMSolver for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional
  quantum chemical capabilities (solvation modeling).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver

* Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib

**CMake Variables**

* :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``
* :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_PCMSolver=ON

B. Build *without* PCMSolver

  .. code-block:: bash

    >>> cmake

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:tutorial`:

==================================================
Psithon Tutorial: Using |PSIfour| as an Executable
==================================================

.. note:: Psithon and PsiAPI refer to two modes of interacting with |PSIfour|. In
   Psithon mode, you write an input file in our domain-specific language
   (not quite Python) where commands don't have ``psi4.`` in front, then
   submit it to the executable ``psi4`` which processes the Psithon into
   pure Python and runs it internally. In PsiAPI mode, you write a pure
   Python script with ``import psi4`` at the top and commands are behind
   the ``psi4.`` namespace, then submit it to the ``python`` interpreter.
   Both modes are equally powerful. This tutorial covers the Psithon
   mode.

.. note:: Some |PSIfour| functions and keywords have aliases.  For example,
          ``frequency()``, ``frequencies()``, and ``freq()`` all work to 
          obtain vibrational frequencies.

Basic Input File Structure
==========================

|PSIfour| reads input from a text file, which can be prepared in any standard
text editor.  The default input file name is ``input.dat`` and the
default output file name is ``output.dat``.  So that you can give your
files meaningful names, these defaults can be changed by specifying
the input file name and output file name on the the command line.
The syntax is:

   >>> psi4 input-name output-name

If you give an input name but no output name, then the output name will
be the same as the input name (replacing any ".in" or ".dat" extension by ".out").

Sample Input Files
==================

Below, we will provide a few simple input files as examples.  A large 
number of sample input files, covering everything from single-point energies
using density-functional theory to response properties from coupled-cluster
theory, can be found in the :source:`samples` directory.


Running a Basic Hartree--Fock Calculation
=========================================

In our first example, we will consider a Hartree--Fock SCF computation
for the water molecule using a cc-pVDZ basis set.  We will specify the
geometry of our water molecule using a standard Z-matrix.

.. literalinclude:: @SFNX_INCLUDE@samples/tu1-h2o-energy/input.dat

.. note:: The memory and basis set specifications are placed *before* the
   energy function is called.  Any user options need to
   be set before the procedure they are meant to affect.

For your convenience, the above example can be found in 
:srcsample:`tu1-h2o-energy`.
You can run it if you wish.
Once |PSIfour| is in your path (see the 
:ref:`User Configuration <faq:runordinaryexe>`
section of the installation instructions), you can run this computation by typing

   >>> psi4 input.dat output.dat

If everything goes well, the computation should complete and should report
a final restricted Hartree--Fock energy in a section like this::

  Energy converged.

  @RHF Final Energy:   -76.02663273410671

By default, the energy should be converged to about :math:`1.0 \times 10^{-6}`, so agreement
is only expected for about the first 6 digits after the decimal.  If the
computation does not complete, there is probably a problem with the
compilation or installation of the program (see the installation
instructions in Sec. :ref:`sec:installFile`).

This very simple input is sufficient to run the requested information.
Notice that we didn't tell the program some otherwise useful information
like the charge on the molecule (0, it's neutral), the spin multiplicity
(1 for a closed-shell molecule with all electrons paired), or the reference
wavefunction to use (restricted Hartree--Fock, or RHF, is usually
appropriate for a closed-shell molecule).  The program correctly guessed
all of these options for us.  We can change the default behavior through
additional keywords.

Let's consider what we would do for an open-shell molecule, where
not all electrons are paired.  For example, let's run a computation
on methylene (CH\ :sub:`2`\ ), whose ground electronic state has two unpaired
electrons (triplet electronic state, or a spin multiplicity :math:`2S+1 = 3`).
In this case, the default spin multiplicity (1) is not correct, so we
need to tell the program the true value (3).  Like many programs, |PSIfour|
can get the charge and multiplicity as the first two integers in the
Z-matrix.  Note the line with ``0 3`` at the beginning of the molecule
specification below.  In this example we will also specify the bond length
and bond angle as variables (:math:`R` and :math:`A`), whose values are given
at the end of the Z-matrix specification.

.. literalinclude:: @SFNX_INCLUDE@samples/tu2-ch2-energy/input.dat

This sample input can be found in 
:srcsample:`tu2-ch2-energy` and as
before it can be run through the command ``psi4 input.dat output.dat``
(actually, because ``psi4`` by default looks for an input file named
``input.dat`` and writes by default to a file called ``output.dat``, in this
case one could also just type ``psi4``).  If it works, it should print
the final energy as ::

  @UHF Final Energy:   -38.92533462456894

Notice we added a new keyword, ``set reference uhf``, to the input.  For
open-shell molecules, we have a choice of unrestricted orbitals
(unrestricted Hartree--Fock, or UHF), or restricted orbitals (restricted
open-shell Hartree--Fock, or ROHF).  Usually, UHF is a little easier to
converge (although it may be more susceptible to spin contamination than
ROHF).

Geometry Optimization and Vibrational Frequency Analysis
========================================================

The above examples were simple single-point energy computations
(as specified by the :py:func:`~psi4.energy` function).  Of course there are other
kinds of computations to perform, such as geometry optimizations and
vibrational frequency computations.  These can be specified by replacing
:py:func:`~psi4.energy` with :py:func:`~psi4.optimize` or :py:func:`~psi4.frequency`, respectively.

Here's an example of optimizing the H\ :sub:`2`\ O molecule using Hartree--Fock with
a cc-pVDZ basis set (located in
:srcsample:`tu3-h2o-opt`).

.. literalinclude:: @SFNX_INCLUDE@samples/tu3-h2o-opt/input.dat

This should perform a series of gradient computations.  The gradient points
which way is downhill in energy, and the optimizer then modifies the
geometry to follow the gradient.  After a few cycles, the geometry should
converge with a message like ``Optimization is complete!``.  As indicated
in the following table (printed by the optimizer at the end of the
computation and grep-able with ``~``), the energy decreases with each step,
and the maximum force on each atom also decreases with each step (in
principle these numbers could increase in some iterations, but here they do
not). ::

   --------------------------------------------------------------------------------------------------------------- ~
    Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~
   --------------------------------------------------------------------------------------------------------------- ~
       1     -76.026632734857    -76.026632734857      0.01523505      0.01245744      0.02742199      0.02277500  ~
       2     -76.027022668419     -0.000389933562      0.00178749      0.00142923      0.01007985      0.00594840  ~
       3     -76.027032729361     -0.000010060942      0.00014016      0.00008485      0.00077279      0.00044621  ~
   --------------------------------------------------------------------------------------------------------------- ~

To get harmonic vibrational frequencies, it's important to keep in mind that
the values of the vibrational frequencies are a function of the molecular
geometry.  Therefore, *it's important to obtain the vibrational frequencies 
at the OPTIMIZED GEOMETRY*.  We could set up a second input file to perform
the vibrational frequency analysis, being very careful to copy over the
optimized geometry from the *bottom* of the output file for the geometry
optimization.  This geometry could be specified in either z-matrix or
Cartesian formats.  However, there's a much easier way to do this.  If we
specify a vibrational frequency analysis in the same input file as the
optimization, after the optimization function has been called, then the
optimized geometry will automatically be carried over.

So, it's easiset to do the optimization and vibrational frequency analysis
together.  This can be specified as follows (see test case
:srcsample:`tu4-h2o-freq`):

.. literalinclude:: @SFNX_INCLUDE@samples/tu4-h2o-freq/input.dat

The program will do the same optimization as in our previous example,
but then it will follow it with some computations to obtain the Hessian
(second derivative matrix) of the electronic energy with respect to
nuclear displacements.  From this, it can obtain the harmonic vibrational
frequencies, given below (roundoff errors of around 0.1 cm\ :sup:`-1`
may exist)::

             Irrep      Harmonic Frequency
                             (cm-1)
           -----------------------------------------------
                A1         1775.6480
                A1         4113.3794
                B2         4212.1826
           -----------------------------------------------

Notice that the symmetry type of the normal modes is specified (A1, A1,
B2).  The program also prints out the normal modes in terms of Cartesian
coordinates of each atom.  For example, the normal mode at 1776 cm\ :sup:`-1` 
is::

      Frequency:       1775.65
      Force constant:   0.1193
                X       Y       Z           mass
     O        0.000   0.000  -0.270      15.994915
     H        0.000   0.417   0.538       1.007825
     H        0.000  -0.417   0.538       1.007825


where the table shows the displacements in the X, Y, and Z dimensions for
each atom along the normal mode coordinate.  (This information could be used
to animate the vibrational frequency using visualization software.)

Because the vibrational frequencies are available, a thermodynamics
analysis is automatically performed at the end of the computation.
You can see this in the next section of the output file.  The vibrational
frequencies are sufficient to obtain vibrational contributions to
enthalpy (H), entropy (S), and Gibbs free energy (G).  Similarly, the
molecular geometry is used to obtain rotational constants, which are
then used to obtain rotational contributions to H, S, and G.

.. _`sec:tutorial_tu5`:

Analysis of Intermolecular Interactions
=======================================

Now let's consider something a little more interesting.  |PSIfour|
contains code to analyze the nature of intermolecular interactions
between two molecules, via symmetry-adapted perturbation theory
(SAPT) [Jeziorski:1994:1887]_.  This kind of analysis gives a lot
of insight into the nature of intermolecular interactions, and |PSIfour|
makes these computations easier than ever.

For a SAPT computation, the input needs to provide information on two
distinct molecules.  This is very easy, we just give a Z-matrix or set of
Cartesian coordinates for each molecule, and separate the two with two
dashes, like this::

   # Example SAPT computation for ethene*ethine (*i.e.*, ethylene*acetylene),
   # test case 16 from the S22 database
   
   molecule dimer {
   0 1
   C   0.000000  -0.667578  -2.124659
   C   0.000000   0.667578  -2.124659
   H   0.923621  -1.232253  -2.126185
   H  -0.923621  -1.232253  -2.126185
   H  -0.923621   1.232253  -2.126185
   H   0.923621   1.232253  -2.126185
   --
   0 1
   C   0.000000   0.000000   2.900503
   C   0.000000   0.000000   1.693240
   H   0.000000   0.000000   0.627352
   H   0.000000   0.000000   3.963929
   units angstrom
   
   }


Here's the second half of the input, where we specify the computation
options::

   set {
       basis jun-cc-pVDZ
       scf_type DF
       freeze_core True
   }
   
   energy('sapt0')

Before, we have been setting keywords individually with commands like
``set basis cc-pVDZ``.  Because we have a few more options now, it's
convenient to place them together into the ``set``
block, bounded by ``{...}``.  This
will set all of these options as "global" options (meaning that they are
visible to all parts of the program).  Most common |PSIfour| options can be
set in a globals section like this. If an option needs to be visible
only to one part of the program (*e.g.*, we only want to increase the
energy convergence in the SCF code, but not the rest of the
code), it can be placed in a section of input visible to that part of the
program (*e.g.*, ``set scf e_convergence 1.0E-8``).

Back to our SAPT example, we have found that for basic-level SAPT
computations (*i.e.*, SAPT0), a good error cancellation is found
[Hohenstein:2012:WIREs]_ with the jun-cc-pVDZ basis (this is the
usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and
without diffuse :math:`d` functions on heavy atoms) [Papajak:2011:10]_. So,
we'll use that as our standard basis set.  The SAPT code is designed to
use density fitting techniques, because they introduce minimal errors
while providing much faster computations [Hohenstein:2010:184111]_ 
[Hohenstein:2010:014101]_. Since we're using density fitting for the SAPT,
we might as well also use it for the Hartree--Fock computations that are
performed as part of the SAPT.  We can specify that with 
``scf_type DF``.

Density fitting procedures require the use of auxiliary basis sets that
pair with the primary basis set.  Fortunately, |PSIfour| is usually smart
enough to figure out what auxiliary basis sets are needed for a given
computation.  In this case, jun-cc-pVDZ is a standard enough basis set
(just a simple truncation of the very popular aug-cc-pVDZ basis set)
that |PSIfour| correctly guesses that we want the jun-cc-pVDZ-JKFIT
auxiliary basis for the Hartree--Fock, and the jun-cc-pVDZ-RI basis set
for the SAPT procedure.

To speed up the computation a little, we also tell the SAPT procedure to
freeze the core electrons with ``freeze_core True``.  The SAPT
procedure is invoked with the simple call, ``energy('sapt0')``.  This
call knows to automatically run two monomer computations and a dimer
computation and then use these results to perform the SAPT analysis.  The
various energy components are printed at the end of the output, in addition
to the total SAPT0 interaction energy.  An explanation of the various
energy components can be found in the review by Jeziorski, Moszynski, and
Szalewicz [Jeziorski:1994:1887]_, and this is discussed in more detail
in the SAPT section later in this manual.  For now, we'll note that most of
the SAPT energy components are negative; this means those are attractive
contributions (the zero of energy in a SAPT computation is defined as
non-interacting monomers).  The exchange contributions are positive
(repulsive).   In this example, the most attractive contribution between
ethylene and acetylene is an electrostatic term of -2.12 |kcalpermol|
(``Elst10,r`` where the 1 indicates the first-order
perturbation theory result with respect to the intermolecular interaction,
and the 0 indicates zeroth-order with respect to intramolecular electron
correlation).  The next most attractive contribution is the ``Disp20``
term (2nd order intermolecular dispersion, which looks like an MP2 in which
one excitation is placed on each monomer), contributing an attraction of
-1.21 |kcalpermol|.  It is not surprising that the electrostatic
contribution is dominant, because the geometry chosen for this example has the
acetylene perpendicular to the ethylene, with the acetylene hydrogen
pointing directly at the double bond in ethylene; this will be attractive
because the H atoms in acetylene bear a partial positive charge, while the
electron-rich double bond in ethylene bears a partial negative charge.  At
the same time, the dispersion interaction should be smaller because the
perpendicular geometry does not allow much overlap between the monomers.
Hence, the SAPT analysis helps clarify (and quantify) our physical
understanding about the interaction between the two monomers.

Potential Surface Scans and Counterpoise Correction Made Easy with Psithon
==========================================================================

Finally, let's consider an example that shows how the Python driver
in |PSIfour| simplifies some routine tasks.  |PSIfour| can interpret
valid Python code in addition to the computational chemistry directives
we've seen in the previous examples; we call this mixture Psithon.
The Python computer language is very easy to pick up, and even users
previously unfamiliar with Python can use it to simplify tasks by
modifying some of the example input files supplied with |PSIfour|
in the :source:`samples` directory.

Suppose you want to do a limited potential energy surface scan, such as
computing the interaction energy between two neon atoms at various
interatomic distances.  One simple but unappealing way to do this is to
create separate input files for each distance to be studied.  Most of
these input files are identical, except that the interatomic distance is
different.  Psithon lets you specify all this in a single input file,
looping over the different distances with an array like this:
``Rvals=[2.5, 3.0, 4.0]``.

Let's also suppose you want to do counterpoise (CP) correction to compute interaction energies.
Counterpoise correction involves computing the dimer energy and then
subtracting out the energies of the two monomers, each evaluated in the
dimer basis.  Again, each of these computations could be run in a separate
input file, but because counterpoise correction is a fairly standard
procedure for intermolecular interactions, |PSIfour| knows about it and has
a built-in routine to perform counterpoise correction.  It only needs to
know what method you want to do the counterpoise correction on (here, let's
consider CCSD(T)), and it needs to know what's monomer A and what's monomer
B.  This last issue of specifying the monomers separately was already dealt
with in the previous SAPT example, where we saw that two dashes in the
``molecule`` block can be used to separate monomers.

So, we're going to do counterpoise-corrected CCSD(T) energies for Ne\ :sub:`2` at
a series of different interatomic distances.  And let's print out a table
of the interatomic distances we've considered, and the CP-corrected CCSD(T)
interaction energies (in |kcalpermol|) at each geometry.  Doing all this
in a single input is surprisingly easy in |PSIfour|.  Here's the input
(available as :srcsample:`tu6-cp-ne2`).

.. literalinclude:: @SFNX_INCLUDE@samples/tu6-cp-ne2/input.dat

First, you can see the ``molecule`` block has a couple dashes to
separate the monomers from each other.  Also note we've used a Z-matrix to
specify the geometry, and we've used a variable (``R``) as the
interatomic distance.  We have *not* specified the value of ``R`` in
the ``molecule`` block like we normally would.  That's because we're
going to vary it during the scan across the potential energy surface.
Below the ``molecule`` block, you can see the ``Rvals`` array
specified.  This is a Python array holding the interatomic distances we
want to consider.  In Python, arrays are surrounded by square brackets, and
elements are separated by commas.

The next lines, ``set basis aug-cc-pVDZ`` and ``set freeze_core True``,
are familiar from previous test cases.  Next comes a slightly
unusual-looking line, ``ecp = {}``.  This is Python's way of initializing
a "dictionary".  We're going to use this dictionary to store the
counterpoise-corrected energies as they become available.  A dictionary is
like an array, but we can index it using strings or floating-point numbers
instead of integers if we want.  Here, we will index it using
floating-point numbers, namely, the ``R`` values.  This winds up being
slightly more elegant than a regular array in later parts of the input
file.

The next section, beginning with ``for R in Rvals:``, loops over the
interatomic distances, ``R``, in our array ``Rvals``.  In Python,
loops need to be indented, and each line in the loop has to be indented
by the same amount.  The first line in the loop, ``dimer.R = R``,
sets the Z-matrix variable ``R`` of the molecule called ``dimer``
to the ``R`` value extracted from the ``Rvals`` array.  The next line,
``ecp[R] = energy('ccsd(t)', bsse_type='cp')``, computes the counterpoise-corrected
CCSD(T) energy and places it in the ``ecp`` dictionary with ``R`` as
the index.  Note we didn't need to specify ghost atoms, and we didn't need
to call the monomer and dimer computations separately.  The built-in
Psithon function :py:func:`~psi4.driver.driver_nbody.nbody_gufunc` does it all for us, automatically.

Near the very end of the output file, the counterpoise correction Python
function will print a nice summary of the results of the counterpoise
computation (the energies of the dimer, of monomer 1 with the ghost functions
of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the
overall counterpoise-corrected interaction energy)::

       N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).
       ...
       N-Body: Complex Energy (fragments = (2,), basis = (1, 2):  -128.70932405488924)
       ...
       N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).
       ...
       N-Body: Complex Energy (fragments = (1,), basis = (1, 2):  -128.70932405488935)
       ...
       N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).
       ...
       N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2):  -257.41867403127321)
       ...
       ==> N-Body: Counterpoise Corrected (CP)  energies <==

       n-Body     Total Energy [Eh]       I.E. [kcal/mol]      Delta [kcal/mol]
            1     -257.418648109779        0.000000000000        0.000000000000
            2     -257.418674031273       -0.016265984132       -0.016265984132

And that's it!  The only remaining part of the example input is a little table
of the different R values and the CP-corrected CCSD(T) energies, converted from
atomic units (Hartree) to |kcalpermol| by multiplying by the
automatically-defined conversion factor ``psi_hartree2kcalmol``.  |PSIfour|
provides several built-in physical constants and conversion factors, as
described in section :ref:`sec:physicalConstants`.
Notice the loop over :math:`R` to create
the table looks just like the loop over ``R`` to run the different
computations, and the CP-corrected energies ``ecp[R]`` are accessed the same
way they were stored.  The ``print`` line at the end just specifies some
formatting for the printed table (first element is a floating point number 3
spaces wide with one digit after the decimal, and the second element is a
floating point number 10 spaces wide with 6 digits after the decimal); the
format strings are the same as in the C programming language.  For tables more
complicated than the simple one used here, Psithon has built-in support for
tables (see the next section).

Our table is printed at the very end of the output file, and looks like
this ::

  CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies
  
          R (Ang)         E_int (kcal/mol)
  -----------------------------------------------------
          2.5              0.757718
          3.0              0.015687
          4.0             -0.016264
  
The following section goes over Psithon in much more detail, but
hopefully this example already makes it clear that many complex tasks
can be done very easily in |PSIfour|.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_setup`:

=======================================
Setting Up Your Development Environment
=======================================

Header
------

Instructions on getting the proper environment set up, cheatsheets for
this, etc.


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

====================
A |PSIfour| Tutorial
====================

.. toctree::
   :maxdepth: 2
   
   tutorial
   psiapi

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. index:: PEP1
.. _`sec:pep1`:

====================================
PEP1: Proposing PsiPEP for |PSIfour|
====================================

:PEP: 1
:Title: Proposing PsiPEP for |PSIfour|
:Last-Modified: 04-Jul-2012
:Author: Lori Burns
:Content-Type: text/x-rst
:Created: 04-Jul-2012

.. comment :Version: <version string>
.. comment * BDFL-Delegate: <PEP czar's real name>
.. comment * Discussions-To: <email address>
.. comment   Status: <Draft | Active | Accepted | Deferred | Rejected |
.. comment            Withdrawn | Final | Superseded>
.. comment   Type: <Standards Track | Informational | Process>
.. comment * Requires: <pep numbers>
.. comment * Python-Version: <version number>
.. comment   Post-History: <dates of postings to python-list and python-dev>
.. comment * Replaces: <pep number>
.. comment * Superseded-By: <pep number>
.. comment * Resolution: <url>


This document proposes using a (much more informal) version of Python's
PEP (Python Enhancement Proposal `PEP1
<https://www.python.org/dev/peps/pep-0001/>`_) protocol to organize
|PSIfour|. Presently, topics are brought up on e-mail threads (where
discussion is very temporally localized and not everyone is aware of it
unless cc'd), are brought up at workshops (where people may be absent, no
record is left, and not everyone may have prepared a position on the
topic), or agreed between a couple people over g-chat (others remain
unaware of plans), or planned by someone (who may not have committed those
plans to a ticket or who wants general approval before restructuring the
code).

Path of a PsiPEP
----------------

* Someone creates a file ``doc/sphinxman/source/pepXXXX.rst`` modeled
  on :source:`doc/sphinxman/source/pep0000model.rst` and adds
  it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file
  should have header fields modeled on another PsiPEP and a discussion of
  the proposed change or practice.

* Anyone can comment by adding sections to the bottom of the reST file.
  Alternatively, e-mail discussions can go out and the (possibly edited)
  results be pasted into the bottom of the reST file once the furor dies
  down.

* Comments can be simple statements of agreement (useful for gauging
  consensus), notation of possible problems, proposed re-writes of the
  proposal, etc.  Only the original author or his designate should change
  the main body of the PsiPEP (to maintain a history).

* Once there's agreement, file can be stamped final and be placed into
  effect. (Yes, this is very vague.)

Roles of a PsiPEP Include
-------------------------

* **Best practices or re-vamped best practices** 

  Practices can be easily linked- or referred-to by number and can be
  tagged as obsolete by a single label change months later.

* **Request/present viewpoint on organization**

  Draw attention to organization needed in code outside one's area of
  expertise. Request interface for some structure (*e.g.*, gradients) or
  viewpoints on how that interface will behave to ensure compatibility.
  Offer philosophy on how processes/definitions should be.

* **Fair Warning: Proposal to change things up**

  Announce plans to re-organize code structure or how something is
  handled. List goals (may be conflicting) and how proposed scheme best
  satisfies them. PsiPEP allows discussion before roll-out in case
  proposal has deleterious side-effects.

The contrast between a PsiPEP and a ticket is that for the latter, there's
no question of whether the task is to be done as described.

Comments
--------

04-Jul-2012, LAB

.. comment This is an example comment that refers to :ref:`sec:pep1` and a trac ticket :trac:`#221`. 

----


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #


.. _`sec:progfaq`:

===============
Programmers FAQ
===============

C++ Style in |PSIfour|
----------------------

#. :ref:`faq:nullptr`
#. :ref:`faq:automakeshared`
#. :ref:`faq:autodecl`
#. :ref:`faq:editorcodestyle`
#. :ref:`faq:githookscodestyle`
#. :ref:`faq:manualcodestyle`

Modules in |PSIfour|
--------------------

#. :ref:`faq:readoptions`
#. :ref:`faq:blaswrappers`
#. :ref:`faq:blasmatrix`
#. :ref:`faq:labas`
#. :ref:`faq:orbdims`
#. :ref:`faq:orbspaces`

Interfacing with |PSIfour|
--------------------------

#. :ref:`faq:addonname`
#. :ref:`faq:addoncmake`

Versioning |PSIfour|
--------------------

#. :ref:`faq:versionbump`
#. :ref:`faq:remotetag`
#. :ref:`faq:githubworkflow`
#. :ref:`faq:psi4version`

Releasing |PSIfour|
-------------------

#. :ref:`faq:annualprocedure`
#. :ref:`faq:prereleaseprocedure`
#. :ref:`faq:releaseprocedure`
#. :ref:`faq:postreleaseprocedure`

Workflow
--------

#. :ref:`faq:localaddon`
#. :ref:`faq:dirlayoutinstall`
#. :ref:`faq:githubworkflow`
#. :ref:`faq:vigitmerge`
#. :ref:`faq:gdblldb`
#. :ref:`faq:grepascii`
#. :ref:`faq:ignoringadvice`

Miscellaneous
-------------

#. :ref:`faq:add_tests`
#. :ref:`faq:add_psithon_tests`
#. :ref:`faq:add_psiapi_tests`
#. :ref:`How to set up PSIthon tests to run through pytest <faq:psithon_through_pytest>`
#. :ref:`faq:findmissingoutputref`
#. :ref:`faq:githubcodereview`

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:blaslapack`:

===========================
Linear Algebra in |PSIfour|
===========================

.. _`faq:blaswrappers`:

How to call BLAS & LAPACK in |PSIfour|
--------------------------------------

Computational chemistry is essentially linear algebra on molecular
systems, so using stable, portable, scalable, and efficient numerical
linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1
(vector-vector operations, like dot products), BLAS2 (matrix-vector
operations, like rank-1 update), BLAS3 (matrix-matrix operations, like
matrix multiplication), and LAPACK (advanced matrix decompositions and
solutions). The methods provided by BLAS and LAPACK are standard, but the
performance of actual implementations differ greatly from one version to
another. Moreover, the standard interfaces to the libraries are Fortran,
so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` .

.. warning:: Although block_matrix, init_array, and print_mat are still
   around, their use is discouraged in favor of operations on
   `psi4.core.Matrix` itself. The advice in these docs will catch up
   shortly.

BLAS Wrappers
^^^^^^^^^^^^^

BLAS wrappers are currently fully supported at double precision.

BLAS commands involving matrices are wrapped so as to be conventional
C-style "row-major" indexing, meaning that the column is the fast index
like normal.

* The calls to BLAS1 routines are wrapped so as to allow for operations on
  vectors with more than 2^{31} elements (~16 GB, getting to be a problem).
  So passing a signed or unsigned long works, though the stride arguments
  must be integers.

* All routines are declared in ``qt.h``. Each routine is prefixed with a
  ``C_``, followed by the standard Fortran name of the routine, in capital
  letters. Input parameters of single primitives (``int``, ``double``,
  ``unsigned long int``, ``char``, ...) are passed by value. Arrays,
  including multidimensional arrays, are required to be in contiguous
  memory (as provided by block_matrix, for example), and are passed by
  providing a pointer to the first double or int element of the data (this
  is array[0] if array is ``double**``). BLAS1 routines occasionally
  return values (DDOT for instance), BLAS2 and BLAS3 always return void.
  For char arguments, case is insensitive. A few examples are provided::

    // BLAS/LAPACK
    #include "psi4/libqt/qt.h"
    // block_matrix, init_array
    #include "psi4/libciomr/libciomr.h"
    
    using namespace psi;
    ...
    
    // Allocate a,b vectors
    int n = 100;
    double* a = init_array(n);
    double* b = init_array(n);
    
    // Allocate A matrix;
    double** A = block_matrix(n,n);
    double** B = block_matrix(n,n);
    double** C = block_matrix(n,n);
    
    // Call the BLAS1 dot product between a and b
    // n can be a ULI with the BLAS1 wrappers,
    // All strides must be ints though
    double dot = C_DDOT(n, a, 1, b, 1);
    
    // Call the BLAS2 GEMV without transposition
    // Note this works in row-major order
    C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);
    
    // Call the BLAS3 GEMM without transposition
    // Note this works in row-major order
    C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);
    
    // Array's init'd with init_array must be free'd, not delete[]'d
    free(a);
    free(b);
    
    // Block matrix should be free_blocked
    free_block(A);
    free_block(B);
    free_block(C);

Important BLAS Routines
^^^^^^^^^^^^^^^^^^^^^^^

* BLAS1

  * DDOT: dot product
  * DCOPY: efficient memory copy (with variable stride)
  * DAXPY: y = y + alpha*x
  * DROT: Givens Rotation
  * DNRM2: Vector norm square

* BLAS2

  * DGEMV: General Matrix-Vector product
  * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet)
  * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV)
  * DGER: Rank-1 update (not wrapped yet)

* BLAS3

  * DGEMM: General Matrix-Matrix product
  * DTRMM: General Triangular Matrix-General Matrix product
  * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM)
  * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).
  * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible.

LAPACK Wrappers
^^^^^^^^^^^^^^^

All standard LAPACK 3.2 double precision routines are provided.

LAPACK commands remain in Fortran's "column-major" indexing, so all the
results will be transposed, and leading dimensions may have to be fiddled
with (using ``lda = n`` in both directions for square matrices is highly
recommended). An example of the former problem is a Cholesky
Decomposition: you expect to get back a lower triangular matrix L such
that ``L L^T = A``, but this is returned in column-major order, so the actual
recovery of the matrix A with the row-major BLAS wrappers effectively
involves ``L^T L = A``. On of the biggest consequences is in linear equations:
The input/output forcing/solution vector must be explicitly formed in
column-major indexing (each vector is placed in a C++ row, with its
entries along the C++ column). This is visualized in C++ as the transpose
of the forcing/solution vector.  All routines are declared in qt.h. Each
routine is prefixed with a ``C_``, followed by the standard Fortran name of
the routine, in capital letters. Input parameters of single primitives
(int, double, unsigned long int, char, ...) are passed by value. Arrays,
including multidimensional arrays, are required to be in contiguous memory
(as provided by block_matrix, for example), and are passed by providing a
pointer to the first double or int element of the data (this is array[0]
if array is ``double**``). All routines return an int INFO with error and
calculation information specific to the routine, In Fortran, this is the
last argument in all LAPACK calls, but should not be provided as an
argument here. For char arguments, case is insensitive. A Cholesky
transform example is shown::

    // BLAS/LAPACK
    #include "psi4/libqt/qt.h"
    // block_matrix, init_array
    #include "psi4/libciomr/libciomr.h"
    
    using namespace psi;
    ...
    int n = 100;
    
    // Allocate A matrix;
    double** A = block_matrix(n,n);
    
    // Call the LAPACK DPOTRF to get the Cholesky factor
    // Note this works in column-major order
    // The result fills like:
    //   * * * *
    //     * * *
    //       * *
    //         *
    // instead of the expected:
    //   *
    //   * *
    //   * * *
    //   * * * *
    //
    int info = C_DPOTRF('L', n, A[0], n);
    
    // A bit painful, see below
    fprintf(outfile, "A:\n");
    print_mat(A,n,n,outfile);

    // Block matrix should be free_blocked
    free_block(A);

Important Lapack Routines
^^^^^^^^^^^^^^^^^^^^^^^^^

* DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.
* DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.
* DGESV: General solver (uses LU decomposition).
* DGESVD: General singular value decomposition.
* DGETRF: LU decomposition.
* DPOTRF: Cholesky decomposition (much more stable/faster)
* DGETRS: Solver, given LU decomposition by DGETRF
* DPOTRS: Solver, given Cholesky decomposition by DPOTRF
* DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it's faster and more stable just to solve with DGETRS)
* DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it's faster and more stable just to solve with DPOTRS)


.. _`faq:blasmatrix`:

How to use low-level BLAS/LAPACK with ``psi4.core.Matrix``
----------------------------------------------------------

Jet's awesome new Matrix object has a lot of simple BLAS/LAPACK built in,
but you can just as easily use the ``double***`` array underneath if you are
careful (the outer index is the submatrix for each irrep). Here's an
example:

.. code-block:: cpp

    // BLAS/LAPACK
    #include "psi4/libqt/qt.h"
    // Matrix
    #include "psi4/libmints/matrix.h"
    
    using namespace psi;
    ...
    int n = 100;
    
    // Allocate A Matrix (new C1 convenience constructor);
    shared_ptr<Matrix> A(new Matrix("Still A, but way cooler", n,n));
    // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index)
    double** A_pointer = A->get_pointer(0);
    
    // Call the LAPACK DPOTRF to get the Cholesky factor
    // Note this works in column-major order
    // The result fills like:
    //   * * * *
    //     * * *
    //       * *
    //         *
    // instead of the expected:
    //   *
    //   * *
    //   * * *
    //   * * * *
    //
    int info = C_DPOTRF('L', n, A_pointer[0], n);
    
    // Wow that's a lot easier
    A->print();
    
    // Don't free, it's shared_ptr!


.. _`faq:labas`:

How to name orbital bases (e.g., AO & SO)
-----------------------------------------

Many different working bases (the internal linear algebraic basis, not the
name of the Gaussian basis) are used within |PSIfour|, each with a unique
and important purpose. It is critical to keep them all distinct to prevent
weird results from occurring.

* ``AO`` (Atomic Orbitals): Cartesian Gaussians (6D, 10F, etc.),
  ``(L + 1)(L + 2)/2`` functions per shell of angular momentum L. The
  ordering of Cartesian exponents for a given L is given by the standard
  ordering below (MATLAB code)::

    ncart = (L + 1) * (L + 2) / 2;
    exps = zeros(ncart,3);
    index = 1;
    for i = 0:L
        for j = 0:i
            lx = L - i;
            ly = i - j;
            lz = j;
            exps(index,:) = [lx ly lz];
          index = index + 1;
        end
    end

* ``SO`` (Spherical Atomic Orbitals): Pure Gaussians (5D, 7F, etc.) or
  Cartesian Gaussians, as determined by the user. This is typically the
  first layer encountered, Libmints handles the transform from AO to SO
  automatically. If Cartesian functions are used, the number of functions
  per shell remains ``(L + 1)(L + 2)/2``, and the ordering remains the same
  as above. Note that the individual functions are not normalized for
  angular momentum as in most codes: the self-overlap of a |PSIfour| Cartesian D
  or higher function with more than one nonzero Cartesian exponent (e.g., lx
  = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are
  used, 2L + 1 real combinations of the spherical harmonics are built from
  the ``(L+1)(L+2)/2`` Cartesian Gaussians, according to H. Schlegel and M.
  Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions
  are all strictly normalized. Note that in |PSIfour|, the real combinations of
  spherical harmonic functions (see the paragraph below Eq. 15 in the
  Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, ....

* ``USO`` (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted
  combinations of SOs, blocked according to irrep. The total number of USOs
  is the same as the number of SOs, but the number of USOs within each irrep
  is usually much smaller, which can lead to significant performance
  improvements. Note that this basis is sometimes unfortunately referred to
  as the SO basis, so it's a bit context specific.

* ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by
  Symmetric or Canonical Orthogonalization. The number of OSOs may be
  slightly smaller than the total number of USOs, due to removal of linear
  dependencies via Canonical Orthogonalization. The OSOs are rarely
  encountered, as usually we go straight from USOs to MOs.

* ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes
  the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham)
  molecular orbital. The number of OSOs and MOs is always the same. MOs are
  orthonormal.

* ``LO`` (Localized Orbitals): Localized occupied orbitals, a different
  combination of the occupied molecular orbitals which enhances spatial
  locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but
  remain orthonormal to each other and the virtual space.


.. _`faq:orbdims`:

How to name orbital dimensions
------------------------------

There are a number of different names used to refer to the basis set size.
These may seem redundant, but they have subtly different meanings, as
detailed below.

A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or
Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set
specification. Also, the basis can be represented in terms of atomic
orbitals (AO) or symmetry-adapted orbitals (SO). Further complications
come from the fact that a nearly linearly-dependent basis set will have
functions removed from it to prevent redundancies. With all of these
factors in mind, here are the conventions used internally:

* nao |w---w| The number of atomic orbitals in Cartesian representation.
* nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.
* nbf |w---w| The number of basis functions, which is the same as nso.
* nmo |w---w| The number of basis functions, after projecting out redundancies in the basis.

When molecular symmetry is utilized, a small array of sizes per irrep is
usually allocated on the stack, and is named by augmenting the name above
with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is
always the singular nirrep, and that the index variable h is always used
in a for-loop traverse of irreps.


.. _`faq:orbspaces`:

How to name orbital spaces (e.g., docc)
---------------------------------------

As with basis sets, a number of names are used to refer to refer to the
quantity of electrons, virtuals, and active sub-quantities of a |PSIfour|
calculation. All of these can be defined per irrep as above. Some common
conventions are:

* nelec |w---w| The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.
* nalpha |w---w| The number of alpha electrons.
* nbeta |w---w| The number of beta electrons
* docc |w---w| The number of doubly-occupied orbitals
* socc |w---w| The number of singly-occupied orbitals (Almost always alpha, we don't like open-shell singlets much).
* nvir |w---w| The number of virtual orbitals

Multireference Dimensions
^^^^^^^^^^^^^^^^^^^^^^^^^

A orbital diagram of the nomenclature used for CI and MCSCF calculations.

Diagrammatically::

    -----------------------------------------------
           CI       |      RAS      |     CAS
    -----------------------------------------------
                    | frozen_uocc   | frozen_uocc
    dropped_uocc    | rstr_uocc     | rstr_uocc
    -----------------------------------------------
                    | RAS IV        |
                    | RAS III       |
    active          |               | active
                    | RAS II        |
                    | RAS I         |
    -----------------------------------------------
    dropped_docc    | rstr_docc     | rstr_docc
                    | frozen_docc   | frozen_dcc
    -----------------------------------------------

Notation:

* uocc |w---w| Unoccupied orbitals.
* active |w---w| Variable occupation orbitals.
* socc |w---w| Singly occupied orbitals.
* docc |w---w| Doubly occupied orbitals.

Orbital spaces:

* frozen_uocc |w---w| Absolutely frozen virtual orbital.
* rstr_uocc |w---w| Can have rotations, no excitations into.
* dropped_uocc |w---w| rstr_uocc + frozen_uocc

----- end CI active -----

* RAS IV |w---w| uocc, limited number of excitations into.
* RAS III |w---w| uocc, limited number of excitations into.
* RAS II |w---w| docc/socc/uocc, equivalent to active in CAS.
* RAS I |w---w| docc/socc/uocc, limited excitations out of.

----- start CI active -----

* dropped_docc |w---w| rstr_docc + frozen_docc
* rstr_docc |w---w| Can have rotations, no excitations from.
* frozen_docc |w---w| Absolutely frozen core orbital.

Orbitals are sorted by space, irrep, eigenvalue.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:prog_newcode`:

================================================
Adding New Code to |PSIfour|
================================================

.. toctree::
   prog_ways_to_add
   plugins
   prog_full_integration 
   proc_py
   prog_style_py
   prog_style_c
   FAQ <prog_faq>

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:sowreap`:

Embarrassing Parallelism
========================

Many of the tasks automated by Python wrappers consist of a number of
independent |PSIfour| calculations and are thus suited to an embarrassingly
parallel mode of operation. In Psithon, these have been dubbed sow/reap
procedures and have the following general structure.

    - Prepare an input file, simply adding ``mode='sow'`` to the
      argument list of an available Python function. Run this quick job to
      produce input files for lengthier calculations.

    - According to the instructions in the output file of the above step,
      run the generated input files in any order on any variety of computers
      and architectures. This is the time-intensive portion of the
      calculation.

    - The 'sow' stage also produces a *master* input file (with a
      ``mode='reap'`` directive). When all the jobs in the above step are
      completed, place their output files in the same location as the
      *master* input, and run this last, quick job to collect the results.

- Sow/reap procedures are governed by the **mode** keyword, choices being
  ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to
  be used by the user, as ``'continuous'`` is always the default, and
  input files with ``'reap'`` are autogenerated.

- Embarrassingly parallel algorithm available at present for:

  - :ref:`sec:db()` 
  - finite difference operation of :ref:`sec:opt()` 
  - finite difference of energies of :ref:`sec:freq()`
  - finite difference of gradients of :ref:`sec:freq()`

.. caution:: Some features are not yet implemented. Buy a developer a coffee.

   - Local options (*e.g.*, ``set scf e_convergence 9``) will not get transmitted to the child jobs.

   - Array options (*e.g.*, ``set states_per_irrep [2, 1]``) will not get transmitted to the child jobs.

   - Function intercalls (*e.g.*, db(opt())) are not tested with sow/reap procedures.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: DCT
   pair: DCT; theory

.. _`sec:dct`:

DCT: Density Cumulant Theory
=============================

.. codeauthor:: Alexander Yu. Sokolov, Andrew C. Simmonett, and Xiao Wang
.. sectionauthor:: Alexander Yu. Sokolov

*Module:* :ref:`Keywords <apdx:dct>`, :ref:`PSI Variables <apdx:dct_psivar>`, :source:`DCT <psi4/src/psi4/dct>`

.. _`sec:dcttheory`:

Theory
~~~~~~

Density cumulant theory (DCT) is a density-based *ab initio* theory
that can compute electronic energies without the use of a wavefunction. The
theory starts by writing the exact energy expression in terms of the one- and
two-particle density matrices (:math:`\boldsymbol{\gamma_1}` and :math:`\boldsymbol{\gamma_2}`):

.. math:: 

    E = h_p^q \gamma_q^p + \frac{1}{2} g_{pq}^{rs} \gamma_{rs}^{pq}

Here we used Einstein convention for the summation over the repeated indices.
:math:`h_p^q` and :math:`g_{pq}^{rs}` are the standard one- and two-electron integrals, and
:math:`\gamma_p^q` and :math:`\gamma_{pq}^{rs}` are the elements of :math:`\boldsymbol{\gamma_1}` and :math:`\boldsymbol{\gamma_2}`,
respectively. Naively, one might expect that it is possible to minimize the
energy functional in the equation above and obtain the exact energy. This is,
however, not trivial, as the density matrix elements :math:`\gamma_p^q` and
:math:`\gamma_{pq}^{rs}` cannot be varied arbitrarily, but must satisfy some
conditions that make sure that the density matrices are N-representable, *i.e.*
correspond to an antisymmetric N-electron wavefunction. Unfortunately, no
simple set of necessary and sufficient N-representability conditions are known,
and some of the known conditions are not easily imposed. In addition, the lack
of separability of the density matrices may result in the loss of
size-consistency and size-extensivity. In DCT, one takes a different route and
replaces :math:`\boldsymbol{\gamma_2}` in favor of its two-particle density cumulant:

.. math:: 

    \lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r

The one-particle density matrix is separated into its idempotent part
:math:`\boldsymbol{\kappa}` and a correction :math:`\boldsymbol{\tau}`:

.. math:: 

    \gamma_p^q = \kappa_p^q + \tau_p^q

The idempotent part of :math:`\boldsymbol{\gamma_1}` corresponds to a mean-field Hartree--Fock-like density,
while the non-idempotent correction :math:`\boldsymbol{\tau}`
depends on the density cumulant and describes the electron correlation effects.
Inserting the above two equations into the energy expression, we obtain:

.. math:: 

    E_{DCT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p  + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}

where the antisymmetrized two-electron integrals and the generalized Fock operator
matrix elements were defined as follows:

.. math:: 

    \bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}

.. math:: 

    f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}

Energy functional :math:`E_{DCT}` has several important properties. First,
the energy is now a function of two sets of independent parameters, the
idempotent part of :math:`\boldsymbol{\gamma_1}` (:math:`\boldsymbol{\kappa}`) and the density cumulant
(:math:`\boldsymbol{\lambda_2}`). As a result, the energy functional is Hermitian,
which is important for the evaluation of the molecular properties. The additive
separability of the density cumulant guarantees that all of the DCT methods
are size-extensive and size-consistent. Furthermore, the N-representability
problem is now greatly simplified, because the idempotent part of :math:`\boldsymbol{\gamma_1}` is
N-representable by construction. One only needs to worry about the
N-representability of the density cumulant, which is a relatively small part of
:math:`\boldsymbol{\gamma_2}`.

In order to obtain the DCT energy, two conditions must be satisfied:

1) The energy must be stationary with respect to a set of orbitals. This can be done by
   diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),
   which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression
   (as in the ODC-06 and ODC-12 methods).

2) The energy must be stationary with respect to the variation of the density
   cumulant :math:`\boldsymbol{\lambda_2}`, constrained to N-representability conditions.

Making the energy stationary requires solution of two sets of coupled
equations for orbitals and density cumulant, respectively (also known as
residual equations). At the present moment, three different algorithms for the
solution of the system of coupled equations are available (see
:ref:`Iterative Algorithms <sec:dctalgorithms>` for details). 

Publications resulting from the use of the DCT code should cite contributions
listed :ref:`here <intro:dctcitations>`.

.. _`sec:dctmethods`:

Methods
~~~~~~~

Currently five DCT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four 
methods use approximate N-representability conditions derived from 
second-order perturbation theory and differ in the description of the
correlated (non-idempotent) part :math:`\boldsymbol{\tau}` of the one-particle density
matrix and orbital optimization. While in the DC-06 and ODC-06 methods :math:`\boldsymbol{\tau}` is derived from the density cumulant
in an approximate way (labelled by '06'), the DC-12 and ODC-12 methods derive this contribution exactly, and
take full advantage of the N-representability conditions (which is denoted by '12'). The corresponding DC and ODC methods
have similar description of the :math:`\boldsymbol{\gamma_1}` N-representability, but differ in describing the orbital relaxation:
the former methods account for the relaxation only partially, while the latter fully relax the orbitals.
Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12. 
Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step
needed for the full orbital optimization. In the ODC-13 method, the third- and
fourth-order N-representability conditions are used for the density cumulant
and the correlated contribution :math:`\boldsymbol{\tau}`, respectively,
and the orbitals are variationally optimized. 
For most of the applications, it is recommended to use the ODC-12 method, which
provides an optimal balance between accuracy and efficiency, especially for
molecules with open-shell character. If highly accurate results are desired, a
combination of the ODC-13 method with a three-particle energy correction
[:math:`\mbox{ODC-13$(\lambda_3)$}`] can be used (see below).
For the detailed comparison of the quality of these methods, we refer
users to our :ref:`publications <intro:dctcitations>`.

The DCT functional can be specified by the |dct__dct_functional| option. The
default choice is the ODC-12 functional. The DCT code can also be used to
compute the :math:`(\lambda_3)` energy correction that perturbatively accounts
for three-particle correlation effects, similarly to the (T) correction in coupled
cluster theory. Computation of the :math:`(\lambda_3)` correction can be
requested by setting the |dct__three_particle| option to PERTURBATIVE. A
combination of the ODC-13 functional with the  :math:`(\lambda_3)` correction
[denoted as :math:`\mbox{ODC-13$(\lambda_3)$}`] has been shown to provide highly
accurate results for open-shell molecules near equilibrium geometries.

At the present moment, all of the DCT methods support unrestricted reference
orbitals (|scf__reference| ``UHF``), which can be used to perform energy and
gradient computations for both closed- and open-shell molecules. In addition,
the ODC-06 and ODC-12 methods support restricted reference orbitals
(|scf__reference| ``RHF``) for the energy and gradient computations of
closed-shell molecules. Note that in this case restricted reference orbitals
are only available for |dct__algorithm| ``SIMULTANEOUS``.

.. _`sec:dctalgorithms`:

Iterative Algorithms
~~~~~~~~~~~~~~~~~~~~

As explained in the :ref:`Theory <sec:dcttheory>` section, in order to obtain the DCT energy one
needs to solve a system of coupled equations for orbitals and density
cumulant. At the present moment three iterative algorithms for the solution of the
equations are available. The choice of the algorithm is controlled using the
|dct__algorithm| option.

SIMULTANEOUS [Default]
    In the simultaneous algorithm the DCT equations are solved in macroiterations.
    Each macroiteration consists of a single iteration of the cumulant update
    followed by a single iteration of the orbital update and orbital transformation
    of the integrals. The macroiterations are repeated until the simultaneous
    convergence of the cumulant and orbitals is achieved.
    Convergence of the simultaneous algorithm is accelerated using the
    DIIS extrapolation technique.

TWOSTEP
    In the two-step algorithm each macroiteration consists of two sets of
    microiterations. In the first set, the density cumulant equations are solved
    iteratively, while the orbitals are kept fixed. After the density cumulant is
    converged, the second set of microiterations is performed for the
    self-consistent update of the orbitals with the fixed density cumulant. Each
    macroiteration is completed by performing the orbital transformation of the
    integrals. As in the simultaneous algorithm, the DIIS
    extrapolation is used to accelerate convergence. Two-step algorithm is
    only available for the DC-06 and DC-12 methods.

QC
    In the quadratically-convergent algorithm, the
    orbital and cumulant update equations are solved using the Newton-Raphson
    method. Each macroiteration of the quadratically-convergent algorithm consists
    of a single Newton-Raphson update followed by the orbital transformation
    of the integrals. The solution of the Newton-Raphson equations is performed
    iteratively using the preconditioned conjugate gradients method, where only the
    product of the electronic Hessian with the step vector is computed for
    efficiency. By default, the electronic Hessian is build for both the cumulant and orbital
    updates and both updates are performed simultaneously. Setting the |dct__qc_type|
    option to ``TWOSTEP`` will perform the Newton-Raphson update only for the orbitals,
    while the equations for the cumulant will be solved using a standard Jacobi update.
    If requested by the user (set |dct__qc_coupling| to TRUE), the electronic Hessian can include
    matrix elements that couple the orbitals and the density cumulant.
    The computation of these coupling elements increases
    the cost of the macroiteration, but usually leads to faster convergence and is
    recommended for open-shell systems.
    It is important to note that the quadratically-convergent algorithm is not yet fully
    optimized and often converges slowly when the RMS of the cumulant or
    the orbital gradient is below :math:`10^{-7}`.

The choice of the iterative algorithm can significantly affect the cost of the
energy computation. While the two-step algorithm requires a small number of
disk-intensive :math:`{\cal O}(N^5)` integral transformations, the simultaneous
algorithm benefits from a smaller number of expensive :math:`{\cal O}(N^6)`
cumulant updates. As a result, for small closed-shell systems the two-step
algorithm is usually preferred, while for larger systems and molecules with
open-shell character it is recommended to use the simultaneous algorithm.
Efficiency of the simultaneous algorithm can be greatly increased by avoiding
the transformation of the four-index virtual two-electron integrals
:math:`(vv|vv)` and computing the terms that involve these integrals in the AO
basis. In order to do that one needs to set the |dct__ao_basis| option to
DISK (currently used by default). For more recommendations on the choice of the algorithm see
:ref:`Recommendations <sec:dctrecommend>`.

.. _`sec:dctgradients`:

Analytic Gradients
~~~~~~~~~~~~~~~~~~

Analytic gradients are available for the DC-06, ODC-06, ODC-12, and ODC-13 methods.
For DC-06, the evaluation of the analytic gradients requires the solution of the
coupled response equations. Two algorithms are available for their iterative
solution: ``TWOSTEP`` (default) and ``SIMULTANEOUS``. These algorithms are similar to those
described for the orbital and cumulant updates in the :ref:`Iterative Algorithms <sec:dctalgorithms>`
section and usually exhibit similar efficiency. The choice of the algorithm can
be made using the |dct__response_algorithm| option. For the DC-12 method the
analytic gradients are not yet available, one has to use numerical gradients to
perform the geometry optimizations. For the ODC-06, ODC-12 and ODC-13 methods no response equations
need to be solved, which makes the computation of the analytic gradients very
efficient. Analytic gradients are not available for the three-particle energy
correction :math:`(\lambda_3)`.

.. _`sec:dctmethodsummary`:

Methods Summary
~~~~~~~~~~~~~~~

The table below summarizes current DCT code features:

    .. _`table:dct_methods_summary`:

    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | Method                              | Available algorithms                                         |  Energy | Gradient | Reference              |
    +=====================================+==============================================================+=========+==========+========================+
    | ODC-06                              | SIMULTANEOUS, QC                                             |    Y    |     Y    | RHF/UHF                |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | ODC-12                              | SIMULTANEOUS, QC                                             |    Y    |     Y    | RHF/UHF                |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | ODC-13                              | SIMULTANEOUS, QC                                             |    Y    |     Y    | UHF                    |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | :math:`\mbox{ODC-12$(\lambda_3)$}`  | SIMULTANEOUS, QC                                             |    Y    |     N    | UHF                    |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | :math:`\mbox{ODC-13$(\lambda_3)$}`  | SIMULTANEOUS, QC                                             |    Y    |     N    | UHF                    |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | DC-06                               | SIMULTANEOUS, QC, TWOSTEP                                    |    Y    |     Y    | UHF                    |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+
    | DC-12                               | SIMULTANEOUS, QC, TWOSTEP                                    |    Y    |     N    | UHF                    |
    +-------------------------------------+--------------------------------------------------------------+---------+----------+------------------------+

Note that for ODC-06 and ODC-12 |scf__reference| ``RHF`` is only available for
|dct__algorithm| ``SIMULTANEOUS``. To compute :math:`(\lambda_3)` correction,
the |dct__three_particle| option needs to be set to PERTURBATIVE.


.. _`sec:dctmininput`:

Minimal Input
~~~~~~~~~~~~~

Minimal input for the DCT single-point computation looks like this::

    molecule { 
    H
    H 1 1.0
    }

    set basis cc-pvdz
    
    energy('dct')

The ``energy('dct')`` call to :py:func:`~psi4.energy` executes the DCT
module, which will first call the SCF module and perform the SCF computation
with RHF reference to obtain a guess for the DCT orbitals. After SCF is
converged, the program will perform the energy computation using the ODC-12
method. By default, simultaneous algorithm will be used for the solution of
the equations. One can also request to perform geometry
optimization following example below::

    molecule { 
    H
    H 1 1.0
    }

    set basis cc-pvdz
    
    optimize('dct')

The ``optimize('dct')`` call will first perform all of the procedures
described above to obtain the ODC-12 energy. After that, the ODC-12 analytic
gradients code will be executed and geometry optimization will be performed. 

.. _`sec:dctrecommend`:

Recommendations
~~~~~~~~~~~~~~~

Here is a list of recommendations for the DCT module:

* Generally, the use of the simultaneous algorithm together with the
  |dct__ao_basis| ``DISK`` option is recommended (set by default).

* In cases when available memory is insufficient, the use of the |dct__ao_basis| ``DISK`` option
  is recommended. This will significantly reduce the memory requirements. However, when
  used together with the two-step algorithm, this option can significantly
  increase the cost of the energy computation.

* In cases when the oscillatory convergence is observed before the DIIS
  extrapolation is initialized, it is recommended to increase the threshold for
  the RMS of the density cumulant or orbital update residual, below which the
  DIIS extrapolation starts. This can be done by setting the
  |dct__diis_start_convergence| option to the value greater than
  :math:`10^{-3}` by one or two orders of magnitude (*e.g.* :math:`10^{-2}` or
  :math:`10^{-1}`). This can be particularly useful for computations using the
  ODC methods, because it can greatly reduce the number of iterations.

* If oscillatory convergence is observed for atoms or molecules with high
  symmetry, it is recommended to use the quadratically-convergent algorithm.

* When using the quadratically-convergent algorithm for the closed-shell molecules, it
  is recommended to set the |dct__qc_coupling| option to FALSE for efficiency
  reasons (set by default).

* For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants
  using the corresponding DC method (set |dct__odc_guess| to TRUE). This can often lead to
  significant computational savings, since the orbital update step in the DC methods is cheap.
  Convergence of the guess orbitals and cumulants can be controlled using the
  |dct__guess_r_convergence| option.



* Making a release or prerelease

  * update all three fields of metadata.py (see below ex)
  * commit
  * on master, make annotated tag starting with v. note the hash.
  * run enough of build to make sure tag formatted properly and "Defining {} version" sane

# MUST update metadata.py on same commit at which make tag

git tag -a v1.0 d2243ef
git push origin v1.0
git push [remote] [tagname]

do NOT use the GitHub tagging interface - it creates lightweight tags

:source:`psi4/metadata.py`

__version__ = '1.0'
__version_long = '1.0+d2243ef'
__version_upcoming_annotated_v_tag = '1.1a1'

# Example current and upcoming tag pairs
# * '1.0', '1.1a1'
# * '1.0.4', '1.0.5' on maintenance branch 1.0.x
# * '1.1a1', '1.1b1'
# * '1.1rc2', '1.1'
# * '1.1', '1.2'


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: SCF, HF, Hartree--Fock
.. _`sec:scf`:

HF: Hartree--Fock Theory
========================

.. codeauthor:: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett
.. sectionauthor:: Robert M. Parrish and Jerome F. Gonthier

*Module:* :ref:`Keywords <apdx:scf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`, :source:`LIBMINTS <psi4/src/psi4/libmints>`, :source:`LIBFOCK <psi4/src/psi4/libfock>`, :source:`LIBDIIS <psi4/src/psi4/libdiis>`

.. _`sec:scfintro`:

Introduction
~~~~~~~~~~~~

Self-Consistent-Field (SCF) theory forms the cornerstone of *ab initio* quantum
chemistry. Here SCF refers both to conventional Hartree--Fock (HF) molecular
orbital theory and also to generalized Kohn--Sham Density Functional Theory
(KS-DFT). |PSIfour| contains a wholly rewritten SCF code, including many of the
most popular spin specializations, several efficient numerical methods for
treating Fock Matrix construction, and a brand new KS-DFT code featuring many of
the most popular DFT functional technologies.

An illustrative example of using the SCF module is as follows::

    molecule {
    0 3
    O
    O 1 1.21
    }

    set {
    basis cc-pvdz
    guess sad
    reference uhf
    scf_type direct
    }

    energy('scf')

This will run a UHF computation for triplet molecular oxygen (the ground state)
using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting
from a Superposition of Atomic Densities (SAD) guess. DF integrals are
automatically used to converge the DF-SCF solution before the Direct algorithm is
activated.  After printing all manner of titles, geometries, sizings, and
algorithm choices, the SCF finally reaches the iterations::

                           Total Energy        Delta E     RMS |[F,P]|

   @DF-UHF iter   0:  -149.80032977420572   -1.49800e+02   1.48808e-01
   @DF-UHF iter   1:  -149.59496320631871    2.05367e-01   2.58009e-02
   @DF-UHF iter   2:  -149.62349901753706   -2.85358e-02   6.68980e-03 DIIS
   @DF-UHF iter   3:  -149.62639942687878   -2.90041e-03   2.19285e-03 DIIS
   @DF-UHF iter   4:  -149.62689561367233   -4.96187e-04   5.99497e-04 DIIS
   @DF-UHF iter   5:  -149.62694151275420   -4.58991e-05   1.27338e-04 DIIS
   @DF-UHF iter   6:  -149.62694337910040   -1.86635e-06   1.65616e-05 DIIS
   @DF-UHF iter   7:  -149.62694340915198   -3.00516e-08   2.68990e-06 DIIS
   @DF-UHF iter   8:  -149.62694340999315   -8.41169e-10   2.61249e-07 DIIS

  DF guess converged.
  ...

   @UHF iter   9:  -149.62730705472407   -3.63645e-04   8.63697e-05 DIIS
   @UHF iter  10:  -149.62730737348096   -3.18757e-07   1.50223e-05 DIIS
   @UHF iter  11:  -149.62730738537113   -1.18902e-08   3.80466e-06 DIIS
   @UHF iter  12:  -149.62730738624032   -8.69193e-10   7.06634e-07 DIIS

The first set of iterations are from the DF portion of the computation, the
second set uses the exact (but much slower) Direct algorithm. Within the DF portion
of the computation, the zeroth-iteration uses a non-idempotent density matrix
obtained from the SAD guess, so the energy is unphysically low. However, the
first true iteration is quite close to the final DF energy, highlighting the
efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate
SCF convergence, with the DF phase reaching convergence in eight true
iterations. When used together, SAD and DIIS are usually sufficient to converge
the SCF for all but the most difficult systems. Additional convergence
techniques are available for more difficult cases, and are detailed below. At
this point, the code switches on the requested Direct integrals technology, which
requires only four full iterations to reach convergence, starting from the DF
guess. This hybrid DF/Direct procedure can significantly accelerate SCF
computations requiring exact integrals.

After the iterations are completed, a number of one-electron properties are
printed, and some bookkeeping is performed to set up possible correlated
computations. Additional one-electron properties are available by increasing the
|globals__print| option. Also printed are the occupied and virtual orbital energies,
which are useful in elucidating the stability and reactivity of the system.

.. index::
   pair: SCF; theory

.. _`sec:scftheory`:

Theory
~~~~~~

The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular
Orbitals (MOs) :math:`\{\psi_i\}`,

.. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1).

Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are
contracted Cartesian Gaussian functions often referred to as Atomic Orbitals
(AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the
constrained variational parameters in Hartree--Fock. The molecular orbitals are
used to build the simplest possible antisymmetric wavefunction, a single Slater
determinant,

.. math:: | \Psi_0 \rangle =
    \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}
    \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\
    \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\
    \vdots & \vdots & \ddots & \vdots \\
    \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\
    \end{array}\right |

This form for the Hartree--Fock wavefunction is actually entirely equivalent to
treating the electron correlation as a mean field repulsion in
:math:`\mathbb{R}^6` instead of a more complicated effect in
:math:`\mathbb{R}^N`\ .

Considering the electronic Hamiltonian,

.. math:: \hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -
    \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},

the Hartree--Fock energy is, by Slater's rules,

.. math:: E_{\mathrm{HF}} =
    \langle \Psi_0 | \hat H | \Psi_0 \rangle
    = \sum_{i} \langle i | \hat h | i \rangle
    + \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]

.. math:: =
    D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right)
    + D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right)

Here :math:`H` is the AO-basis one-electron potential, encapsulating both
electron-nuclear attraction and kinetic energy,

.. math:: H_{\mu\nu} =
    \left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right
    | \nu \right),

:math:`D` is the AO-basis density matrix, build from the occupied orbital
coefficients,

.. math:: D_{\mu\nu}^{\alpha} =
    C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},

and :math:`F` is the Fock matrix, which is the effective one-body potential at
the current value of the density,

.. math:: F_{\mu\nu}^{\alpha} = H_{\mu\nu}
    + \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right)
    (\mu\nu|\lambda\sigma)}_{J}
    + \underbrace{D_{\lambda\sigma}^{\alpha} (\mu\lambda|\sigma\nu)}_{K^{\alpha}}

Here the tensor :math:`(\mu\nu|\lambda\sigma)` is an AO Electron-Repulsion
Integral (ERI) in chemists' notation,

.. math:: (\mu\nu|\lambda\sigma) = \iint_{\mathbb{R}^6}
    \phi_{\mu} (\vec r_1)
    \phi_{\nu} (\vec r_1)
    \frac{1}{r_{12}}
    \phi_{\lambda} (\vec r_2)
    \phi_{\sigma} (\vec r_2)
    \ \mathrm{d}^3 r_1
    \ \mathrm{d}^3 r_2.

The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,

.. math:: F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha

The eigenvalues :math:`\epsilon` are the orbital energies, and the metric matrix
:math:`S` is the AO-basis overlap matrix

.. math:: S_{\mu\nu} = (\mu | \nu )

Note that the Fock Matrix depends on the density (both alpha and beta), and
therefore the orbitals. Because of this, SCF is a nonlinear procedure, which
terminates when the generating orbitals are self-consistent with the Fock matrix
they generate.

The formation of the Coulomb matrix :math:`J` and the exchange matrix
:math:`K^{\alpha}` dominate the computational effort of the SCF procedure. For
very large systems, diagonalization of the Fock matrix can also present a
significant hurdle.

.. _`sec:scfinput`:

Minimal Input
~~~~~~~~~~~~~

Minimal input for a Hartree--Fock computation is a molecule block, basis set
option, and a call to ``energy('scf')``::

    molecule {
    He
    }

    set basis sto-3g

    energy('scf')

This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in
:math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6
energy and density convergence criteria (since single-point, see
:ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric
orthogonalization, DIIS, and a core Hamiltonian guess. For more
information on any of these options, see the relevant section below.

.. _`sec:scfsymm`:

Spin/Symmetry Treatment
~~~~~~~~~~~~~~~~~~~~~~~

|PSIfour| implements the most popular spin specializations of Hartree--Fock
theory, including:

Restricted Hartree--Fock (RHF) [Default]
  Appropriate only for closed-shell singlet systems, but twice as efficient
  as the other flavors, as the alpha and beta densities are constrained to be
  identical.
Unrestricted Hartree--Fock (UHF)
  Appropriate for most open-shell systems and fairly easy to converge.
  The spatial parts of the alpha and beta orbitals are fully independent of each
  other, which allows a considerable amount of flexibility in the wavefunction.
  However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions
  need not be eigenfunctions of the :math:`\hat S^2` operator. The deviation of
  this operator from its expectation value is printed on the output file. If the
  deviation is greater than a few hundredths, it is advisable to switch to a
  ROHF to avoid this "spin-contamination" problem.
Restricted Open-Shell Hartree--Fock (ROHF)
  Appropriate for open-shell systems where spin-contamination is problem.
  Sometimes more difficult to converge, and assumes uniformly positive spin
  polarization (the alpha and beta doubly-occupied orbitals are identical).
Constrained Unrestricted Hartree--Fock (CUHF)
  A variant of ROHF that starts from a UHF ansatz and is therefore often
  easier to converge.

These can be invoked by the |scf__reference| keyword, which defaults to ``RHF``.
The charge and multiplicity may either be specified in the molecule definition::

    molecule h {
    0 2  # Neutral doublet
    H
    }

or, dynamically, by setting the relevant attributes in the Python molecule
object::

    h.set_molecular_charge(0)
    h.set_multiplicity(2)

Abelian spatial symmetry is fully supported in |PSIfour| and can be used to
obtain physical interpretation of the molecular orbitals, to assist in difficult
convergence cases, and, in some methods, to obtain significant performance
gains. The point group of the molecule is inferred when reading the molecule
section, and may be overridden by the :ref:`symmetry <sec:moleculeKeywords>` flag, as in::

    molecule h {
    0 2
    H
    symmetry c1
    }

or by the ``reset_point_group`` Python molecule attribute::

    h.reset_point_group('c2v')

During the SCF procedure, the occupation of orbitals is typically determined by
the Aufbau principal across all spatial symmetries. This may result in the
occupation shifting between iterations. If the occupations are known *a priori*,
they may be clamped throughout the procedure by using the |globals__docc| and
|globals__socc| options. For instance, all good quantum chemists know that
:math:`C_{2v}` water is
actually,::

    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 104.5
    }

    set {
    docc [3, 0, 1, 1]  # 1A1 2A1 1B1 3A1 1B2
    basis cc-pvdz
    }

    energy('scf')

.. _`sec:scfbrokensymm`:

Broken Symmetry
~~~~~~~~~~~~~~~

For certain problems, such diradicals, allowing the spin-up and spin-down
orbitals to differ in closed-shell computations can be advantageous;
this is known as symmetry breaking.  The resulting unrestricted wavefunction
will often provide superior energetics, due to the increased flexibility,
but it will suffer non-physical spin contamination from higher multiplicity states.
A convenient approach to break symmetry is to perform a UHF or UKS calculation
with the guess HOMO and LUMO orbitals mixed.
Mixing of the guess orbitals can be requested by setting the |scf__guess_mix|
keyword to true::

    set reference uhf
    set guess_mix true
    energy('scf')

.. _`sec:scflindep`:

Orthogonalization
~~~~~~~~~~~~~~~~~

One of the first steps in the SCF procedure is the determination of an
orthogonal basis (known as the OSO basis) from the atomic orbital
basis (known as the AO basis). The Molecular Orbital basis (MO basis)
is then built as a particular unitary transformation of the OSO
basis. In |PSIfour|, the determination of the OSO basis is
accomplished via either symmetric, canonical, or partial Cholesky
orthogonalization.

Symmetric orthogonalization uses the symmetric inverse square root of
the overlap matrix for the orthogonalization matrix. Use of symmetric
orthogonalization always yields the same number of OSO functions (and
thereby MOs) as AO functions. However, this may lead to numerical
problems if the overlap matrix has small eigenvalues, which may occur
for large systems or for systems where diffuse basis sets are used.

This problem may be avoided by using canonical orthogonalization, in
which an asymmetric inverse square root of the overlap matrix is
formed, with numerical stability enhanced by the elimination of
eigenvectors corresponding to very small eigenvalues. As a few
combinations of AO basis functions may be discarded, the number of
canonical-orthogonalized OSOs and MOs may be slightly smaller than the
number of AOs.

When the basis set is too overcomplete, the eigendecomposition of the
overlap matrix is no longer numerically stable. In this case the
partial Cholesky decomposition can be used to pick a subset of basis
functions that span a sufficiently complete set, see
[Lehtola:2019:241102]_ and [Lehtola:2020:032504]_. This subset can then
be orthonormalized as usual; the rest of the basis functions are
hidden from the calculation. The Cholesky approach allows reaching
accurate energies even in the presence of significant linear
dependencies [Lehtola:2020:04224]_.

In |PSIfour|, symmetric orthogonalization is used by default, unless
the smallest overlap eigenvalue falls below the user-supplied double
option |scf__s_tolerance|, which defaults to 1E-7. If the smallest
eigenvalue is below this cutoff, canonical orthogonalization is
forced, and all eigenvectors corresponding to eigenvalues below the
cutoff are eliminated.

If the eigendecomposition is detected to be numerically unstable - the
reciprocal condition number of the overlap matrix to be smaller than
the machine epsilon - the partial Cholesky decomposition is undertaken
until |scf__s_cholesky_tolerance|, which defaults to 1E-8.

Use of symmetric, canonical, and partial Cholesky orthogonalization
can be forced by setting the |scf__s_orthogonalization| option to
``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,
respectively.

Note that in practice, the MOs and OSOs are built separately within
each irrep from the symmetry-adapted combinations of AOs known as
Unique Symmetry Orbitals (USOs).  For canonical orthogonalization,
this implies that the number of MOs and OSOs per irrep may be slightly
smaller than the number of USOs per irrep.

A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown
below::

    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 104.5
    symmetry c2  # Two irreps is easier to comprehend
    }

    set {
    s_tolerance 0.0001      # Set an unreasonably tight
                            # tolerance to force canonical
    basis aug-cc-pv5z       # This diffuse basis will have
                            # small-ish eigenvalues for even H2O
    print 3
    }

    energy('scf')

Output::

  ==> Pre-Iterations <==

   -------------------------------------------------------
    Irrep   Nso     Nmo     Nalpha   Nbeta   Ndocc  Nsocc
   -------------------------------------------------------
     A        145     145       0       0       0       0
     B        142     142       0       0       0       0
   -------------------------------------------------------
    Total     287     287       5       5       5       0
   -------------------------------------------------------

  ...

  Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.
  Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.
  Irrep 0, 1 of 145 possible MOs eliminated.
  Irrep 1, 2 of 142 possible MOs eliminated.
  Overall, 3 of 287 possible MOs eliminated.

In this example, there are 287 AO basis functions after spherical harmonics are
applied. These are used to produce 287 symmetry adapted USOs, 145 of which are
assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,
144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall
above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from
287 AOs/USOs.

.. _`sec:scfguess`:

Initial Guess
~~~~~~~~~~~~~

In each step of the SCF procedure, a new Fock or Kohn--Sham potential is built
according to the previous density, following which the potential is diagonalized
to produce new molecular orbitals, from which a new density is computed. This
procedure is continued until either convergence is reached or a preset maximum
number of iterations is exceeded. Convergence is determined by both change in
energy and root-mean-square change in density matrix values, which must be below
the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.
The maximum number of iterations is specified by the |scf__maxiter| option. It
should be noted that SCF is a chaotic process, and, as such, often requires
careful selection of initial orbitals and damping during iterations to ensure
convergence. This is particularly likely for large systems, metallic systems,
multireference systems, open-shell systems, anions, and systems with diffuse
basis sets.

For initial orbital selection, several options are available. These include:

CORE
    Diagonalization of the core Hamiltonian, removing even mean-field electron
    repulsion. Simple, but often too far from the final solution for larger
    systems.   READ becomes the default for the second and later iterations
    of geometry optimizations.
SAD [:term:`Default <GUESS (SCF)>`]
    Superposition of Atomic Densities. Builds the initial density as the
    spin-averaged sum of atomic UHF computations in the current basis. If an
    open-shell system, uniform scaling of the spin-averaged density matrices is
    performed. If orbitals are needed (*e.g.*, in density fitting), a partial
    Cholesky factorization of the density matrices is used. Often extremely
    accurate, particularly for closed-shell systems.
SADNO
    Natural orbitals from Superposition of Atomic Densities. Similar
    to the above, but it forms natural orbitals from the SAD density
    matrix to get proper orbitals which are used to start the
    calculation, see [Lehtola:2019:1593]_.
GWH
    A generalized Wolfsberg-Helmholtz modification of the core
    Hamiltonian matrix. Usually less accurate than the core guess: the
    latter is exact for one-electron systems, GWH is not; see
    [Lehtola:2019:1593]_).
HUCKEL
    An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF
    calculations alike SAD, see [Lehtola:2019:1593]_.
READ
    Read the previous orbitals from a ``wfn`` file, casting from
    one basis to another if needed. Useful for starting anion
    computations from neutral orbitals, or after small geometry
    changes. At present, casting from a different molecular point
    group is not supported.  This becomes the default for the second
    and later iterations of geometry optimizations.
SAP
    Superposition of Atomic Potentials. This is essentially a
    modification of the core Hamiltonian, which includes screening
    effects by using a radially screened effective atomic charge. The
    screening effects have been calculated at the complete basis set
    limit with finite-element calculations, see [Lehtola:2019:25945]_
    and [Lehtola:2020:012516]_. The guess and its implementation have
    been described in [Lehtola:2019:1593]_. The guess is evaluated on a
    DFT quadrature grid, so the guess energy depends slightly on the
    used DFT quadrature. The current implementation is based on
    exchange-only local density calculations that are but nanohartree
    away from the complete basis set limit [Lehtola:2020:012516]_.

These are all set by the |scf__guess| keyword. Also, an automatic Python
procedure has been developed for converging the SCF in a small basis, and then
casting up to the true basis. This can be done by adding
|scf__basis_guess| = SMALL_BASIS to the options list. We recommend the
3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and
compactness. An example of performing an RHF solution of water by SAD guessing
in a 3-21G basis and then casting up to cc-pVTZ is shown below::

    molecule h2o {
    0 1
    O
    H 1 1.0
    H 1 1.0 2 104.5
    }

    set {
    basis cc-pvtz
    basis_guess 3-21G
    guess sad
    }

    energy('scf')

.. _`sec:scfrestart`:

Restarting the SCF
~~~~~~~~~~~~~~~~~~

Reading orbital data from a previous calculations is done via the ``restart_file`` option,
where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`)
By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted
after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically
set to ``READ`` when ``restart_file`` is given a ``wfn`` file.
To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::

  energy('scf', write_orbitals='my_mos'),

which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.
The restart can then be done as follows: ::

  energy('scf', restart_file='my_mos')

Specifying the ``.npy`` suffix when writing and reading restart files is optional.

Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::

  energy, scf_wfn = energy('scf',return_wfn=True)
  scf_wfn.to_file('my_wfn')
  energy('scf', restart_file='my_wfn')


For advanced users manipulating or writing custom wavefunction files, note
that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`.


.. index:: DIIS, MOM, damping

.. _`sec:scfconv`:

Convergence Stabilization
~~~~~~~~~~~~~~~~~~~~~~~~~

A summary of Psi's supported convergence stabilization techniques is presented below:

DIIS [On by Default]
    DIIS uses previous iterates of the Fock matrix together
    with an error criterion based on the orbital gradient to produce an informed
    estimate of the next Fock Matrix. DIIS is almost always necessary to converge
    the SCF procedure and is therefore turned on by default. In rare cases, the
    DIIS algorithm may need to be modified or turned off altogether, which may be
    accomplished via :term:`options <DIIS (SCF)>`.
ADIIS [On by Default]
    ADIIS uses previous iterates of the Fock and density matrices to produce an
    informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing
    an energy estimate rather than zeroing the residual, so this performs best in the early
    iterations. By default, Psi will start using ADIIS before blending the ADIIS step with
    the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure
    may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical
    to ADIIS for HF, but the methods will differ for more general DFT.
MOM [Off by Default]
    MOM was developed to combat a particular class of convergence failure:
    occupation flipping. In some cases, midway though the SCF procedure, a partially
    converged orbital which should be occupied in the fully-optimized SCF solution
    has a slightly higher orbital eigenvalue than some other orbital which should be
    destined to be a virtual orbital. This results in the virtual orbital being
    spuriously occupied for one or more iterations. Sometimes this resolves itself
    without help, other times the occupation flips back and forth between two, four,
    or more orbitals. This is typically visible in the output as a non-converging
    SCF which eventually settles down to steady oscillation between two (or more)
    different total energies. This behavior can be ameliorated by choosing occupied
    orbitals by "shape" instead of by orbital eigenvalue, *i.e.*, by choosing the set
    of new orbitals which looks most like some previously known "good" set.  The
    "good" set is typically the occupied orbitals from one of the oscillating
    iterations with the lowest total energy. For an oscillating system where the
    lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking
    |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can
    be used in concert with DIIS, though care should be taken to not turn MOM on
    until the oscillatory behavior begins.
Damping [Off by Default]
    In some cases, a static mixing of Fock Matrices from adjacent
    iterations can quench oscillations. This mixing, known as
    "damping" can be activated by setting the
    |scf__damping_percentage| keyword to a nonzero percent. Damping is
    turned off when the DIIS error is smaller than
    |scf__damping_convergence|.
Level shifting [Off by default]
    A commonly used alternative to damping is to use level shifting,
    which decreases the mixing of occupied and unoccupied orbitals in
    the SCF update by moving the unoccupied orbitals up in energy. It
    can be shown that the SCF procedure always converges with a
    suitably large level shift; however, the larger the shift is, the
    slower the convergence becomes, and the calculation may end up
    converging onto a higher lying SCF solution. Because of this, in
    practice level shifting is most useful in the initial phase of the
    calculation to reduce the orbital error enough for DIIS to work
    well. The level shift is controlled by the parameter
    |scf__level_shift|, and it is turned off when the DIIS error is
    smaller than |scf__level_shift_cutoff|. Reasonable values for
    the shift and convergence threshold are 5.0 and 1e-2,
    respectively.
SOSCF [Off by Default]
    See :ref:`sec:soscf`

.. _`sec:scferi`:

ERI Algorithms
~~~~~~~~~~~~~~

The key difficulty in the SCF procedure is treatment of the four-index ERI
contributions to the Fock Matrix. A number of algorithms are available in
|PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|
keyword, which may be one of the following

PK [:ref:`Default <table:conv_scf>`]
    An out-of-core, presorted algorithm using exact ERIs. Quite fast for a
    zero-error algorithm if enough memory is available. Integrals are
    generated only once, and symmetry is utilized to reduce number of
    integrals.
OUT_OF_CORE
    An out-of-core, unsorted algorithm using exact ERIs. Overcomes the
    memory bottleneck of the current PK algorithm. Integrals are generated
    only once, and symmetry is utilized to reduce number of integrals.
DIRECT
    A threaded, sieved, integral-direct algorithm, with full permutational
    symmetry. This algorithm is brand new, but seems to be reasonably fast
    up to 1500 basis functions, uses zero disk (if DF pre-iterations are
    turned off), and can obtain significant
    speedups with negligible error loss if |scf__ints_tolerance|
    is set to 1.0E-8 or so.
DF [:ref:`Default <table:conv_scf>`]
    A density-fitted algorithm designed for computations with thousands of
    basis functions. This algorithm is highly optimized, and is threaded
    with a mixture of parallel BLAS and OpenMP. Note that this algorithm
    should use the -JKFIT series of auxiliary bases, *not* the -RI or
    -MP2FIT bases. The default guess for auxiliary basis set should work
    for most bases, otherwise the |scf__df_basis_scf| keyword can
    be used to manually specify the auxiliary basis.  This algorithm is
    preferred unless either absolute accuracy is required
    [:math:`\gtrsim`\ CCSD(T)] or a -JKFIT auxiliary basis is unavailable
    for the orbital basis/atoms involved.
CD
    A threaded algorithm using approximate ERIs obtained by Cholesky
    decomposition of the ERI tensor.  The accuracy of the Cholesky
    decomposition is controlled by the keyword |scf__cholesky_tolerance|.
    This algorithm is similar to the DF algorithm, but it is not suitable
    for gradient computations.  The algorithm to obtain the Cholesky
    vectors is not designed for computations with thousands of basis
    functions.

In some cases the above algorithms have multiple implementations that return
the same result, but are optimal under different molecules sizes and hardware
configurations. Psi4 will automatically detect the correct algorithm to run and
only expert users should manually select the below implementations. The DF
algorithm has the following two implementations

MEM_DF
    A DF algorithm optimized around memory layout and is optimal as long as
    there is sufficient memory to hold the three-index DF tensors in memory. This
    algorithm may be faster for builds that require disk if SSDs are used.
DISK_DF
    A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to
    minimize Disk IO by sacrificing some performance due to memory layout.

Note that these algorithms have both in-memory and on-disk options, but
performance penalties up to a factor of 2.5 can be found if the incorrect
algorithm is chosen. It is therefore highly recommended that the keyword "DF"
be selected in all cases so that the correct implementation can be selected by
|PSIfours| internal routines. Expert users can manually switch between MEM_DF and
DISK_DF; however, they may find documented exceptions during use as several
post SCF algorithms require a specific implementation.

For some of these algorithms, Schwarz and/or density sieving can be used to
identify negligible integral contributions in extended systems. To activate
sieving, set the |scf__ints_tolerance| keyword to your desired cutoff
(1.0E-12 is recommended for most applications). To choose the type of sieving, set 
the |globals__screening| keyword to your desired option. For Schwarz screening, set it
to ``SCHWARZ``, for CSAM, ``CSAM``, and for density matrix-based screening, ``DENSITY``.

SCHWARZ
    Uses the Cauchy-Schwarz inequality to calculate an upper bounded value of a shell quartet,

.. math:: (PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)}

CSAM
    An extension of the Schwarz estimate that also screens over the long range 1/r operator, described in [Thompson:2017:144101]_.

DENSITY
    An extension of the Schwarz estimate that also screens over elements of the density matrix.
    For the RHF case, described in [Haser:1989:104]_

.. math:: CON(PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)} \cdot DCON(PQ, RS)

.. math:: DCON(PQ, RS) = max(4D_{PQ}, 4D_{RS}, D_{PR}, D_{PS}, D_{QR}, D_{QS})

When using density-matrix based integral screening, it is useful to build the J and K matrices
incrementally, also described in [Haser:1989:104]_, using the difference in the density matrix between iterations, rather than the
full density matrix. To turn on this option, set |scf__incfock| to ``true``.

We have added the automatic capability to use the extremely fast DF
code for intermediate convergence of the orbitals, for |globals__scf_type|
``DIRECT``. At the moment, the code defaults to cc-pVDZ-JKFIT as the
auxiliary basis, unless the user specifies |scf__df_basis_scf| manually. For
some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last
resort will be used.
To avoid this, either set |scf__df_basis_scf| to an auxiliary
basis set defined for all atoms in the system, or set |scf__df_scf_guess|
to false, which disables this acceleration entirely.

LinK Exchange
~~~~~~~~~~~~~

.. warning:: The LinK code is currently under development and should not be used.

Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.
LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available with the direct SCF algorithm (|globals__scf_type| set to ``DIRECT``).
LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.
This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.
LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-electron integrals to calculate.

NOTE: Turning on LinK is currently only recommended for research and development purposes, and not for performance,
since a fast J matrix build compatible to use with LinK has not been developed yet.

To turn on and control the LinK algorithm, here are the list of options provided.

  |scf__do_linK|: Defaults to false. If turned on, the K matrix will be built using the algorithm described in [Ochsenfeld:1998:1663]_.

  |scf__linK_ints_tolerance|: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the |scf__ints_tolerance| option.

.. index::
    single: SOSCF

.. _`sec:soscf`:

Second-order Convergence
~~~~~~~~~~~~~~~~~~~~~~~~

Second-order convergence takes into account both the gradient and Hessian to
take a full Newton step with respect to the orbital parameters. This results in
quadratic convergence with respect to density for SCF methods. For cases where
normal acceleration methods either fail or take many iterations to converge,
second-order can reduce the total time to solution.

Solving second-order (SO) methods exactly would require an inversion of the
orbital Hessian (an expensive :math:`\mathbb{N}^6` operation); however, these
equations are normally solved iteratively where each iteration costs the same
as a normal Fock build (:math:`\mathbb{N}^4`). The overall SOSCF operation is
thus broken down into micro- and macroiterations where the microiterations
refer to solving the SOSCF equations and macroiterations are the construction
of a new Fock matrix based on the orbitals from a SOSCF step.

SOSCF requires that all elements of the gradient to be less than one before the
method is valid. To this end, pre-SOSCF SCF iterations use normal
gradient-based extrapolation procedures (*e.g.*, DIIS) until the gradient
conditions are met. Note that while the total number of macroiterations will be
less for SOSCF than gradient-based convergence acceleration, the cost of solving
the microiterations typically results in the overall cost being greater for
SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if
it is difficult to locate a stable minimum.

SOSCF is available for all HF and DFT references with the exception of meta-
GGA functionals. To enable, set the option |scf__soscf| to ``true``.
Additional options to modify the number of microiterations taken are as
follows:

    |scf__soscf_start_convergence|: when to start SOSCF based on the current density RMS

    |scf__soscf_max_iter|: the maximum number of SOSCF microiterations per macroiteration

    |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations

    |scf__soscf_print|: option to print the microiterations or not


.. _`sec:scfstability_doc`:

Stability Analysis
~~~~~~~~~~~~~~~~~~

SCF algorithms attempt to minimize the gradient of the energy with respect
to orbital variation parameters. At convergence, the gradient should be approximately zero
given a convergence criterion. Although this is enough to make sure the SCF converged to a
stationary point, this is not a sufficient condition for a minimal SCF solution. It may be
a saddle point or a maximum.

To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second
derivatives of the energy with respect to orbital variation parameters, must be computed.
If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.
In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.

Orbital variation parameters are usually constrained. For example, in RHF the
spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In
UHF, the orbital coefficients are usually constrained to be real. A stability analysis
can check whether a lower SCF solution exists while respecting the constraints of the original
solution; this is an internal instability. If one or more constraints have to be relaxed to reach
a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability
that can be checked at present is the RHF :math:`\rightarrow` UHF one.

Currently, two algorithms exist in |PSIfour| for stability analysis: the original
Direct Inversion and the newly implemented Davidson algorithms. We will first describe
options common to both algorithms. To request a stability analysis at the end of the SCF,
set the keyword |scf__stability_analysis|. Value ``CHECK`` only computes the electronic
Hessian eigenvalue and checks if an actual SCF minimum has been found, while value ``FOLLOW``
rotates the converged orbitals along the lowest eigenvector, then invokes the SCF
procedure again to lower the energy. In case the minimization does not succeed
or ends up on the same unstable solution, you can tune the scale factor for the orbital
rotation through the keyword |scf__follow_step_scale|.
The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_step_scale|). The default value of
0.5 usually provides a good guess, and modification is only recommended in difficult cases.
The default behavior for the stability code is to stop after trying to reoptimize the orbitals once
if the instability still exists. For more attempts, set |scf__max_attempts|;
the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification
of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|.

.. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using
   RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution
   you should re-run the calculation with |scf__reference| set to ``UHF``.

The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*
work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian
matrix before explicitly inverting it. As such, this algorithm is very slow and it should
be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm
is not available.

The Davidson algorithm for stability analysis was implemented recently.
Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector
products are computed instead of the full Hessian. This algorithm is thus
much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability
analysis. The capabilities of both algorithms are summarized below:

.. _`table:stab_methods`:

.. table:: Stability analysis methods available in |PSIfour|

    +------------------+------------------+----------------------------------------------+---------------------------+---------------------+
    |     Algorithm    | |scf__reference| |     Stability checked                        | |scf__stability_analysis| | |globals__scf_type| |
    +==================+==================+==============================================+===========================+=====================+
    |                  |       RHF        | Internal, External (:math:`\rightarrow` UHF) | ``CHECK``                 |   PK only           |
    +                  +------------------+----------------------------------------------+---------------------------+---------------------+
    | Direct Inversion |       ROHF       | Internal                                     | ``CHECK``                 |   PK only           |
    +------------------+------------------+----------------------------------------------+---------------------------+---------------------+
    |   Davidson       |       UHF        | Internal                                     | ``CHECK`` or ``FOLLOW``   |   Anything          |
    +------------------+------------------+----------------------------------------------+---------------------------+---------------------+

The best algorithm is automatically selected, *i.e.* Davidson for UHF :math:`\rightarrow` UHF and Direct Inversion otherwise.

In addition to the options available for Direct Inversion, the Davidson algorithm can automatically
adapt |scf__follow_step_scale| to find a new SCF minimum. If |scf__max_attempts| > 1, additional attempts
will automatically increment |scf__follow_step_scale| by 0.2 every time the SCF falls back to the previously
found unstable minimum. The increment can be adjusted by setting |scf__follow_step_increment|.
The default value is 0.2; adjust if needed to try different values of |scf__follow_step_scale| in a single computation.

The Davidson solver for the eigenvalues is controlled through several keywords. In the following
we only report the most pertinent for stability analysis, see documentation for the :ref:`CPHF <apdx:cphf>`
module for a complete list.
Some default values were modified for the stability analysis code, in that case they are
explicitly indicated here.

  |cphf__solver_maxiter|: maximum number of iterations

  |cphf__solver_convergence|: eigenvector convergence threshold

  |cphf__solver_n_root|: Solve for N eigenvectors in each irreducible representation

  |cphf__solver_n_guess|: Use N guess vectors, this needs to be larger than the number of roots so that the lowest ones can be captured reliably. Default within this context: 3

  |cphf__solver_min_subspace|: Minimum size of the subspace when collapsing.

  |cphf__solver_max_subspace|: Maximum size of the subspace. Default within this context: 12


In case convergence problems are encountered during the Davidson procedure,
it is recommended to first increase |cphf__solver_max_subspace|, especially if you solve
for a large number of roots. This will result in a higher computational cost of each iteration, but should
make the solver better behaved. However, note that |cphf__solver_max_subspace| should never be larger than
the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.
This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts
|cphf__solver_max_subspace| if it is too large.
If the solver seems to converge on the wrong eigenvalue, try increasing |cphf__solver_n_guess|.
Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing
|cphf__solver_maxiter|.


.. _`sec:scf-ecps`:

Effective core potentials (ECPs)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

|PSIfour| supports the use of effective core potentials to describe the
innermost electrons in heavy elements.  If a basis set is designed to use an
effective core potential, the ECP definition should be simply placed alongside
the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`.  All
information related to the definition and number of core electrons will
automatically be detected and no further input is required to use the
ECP-containing basis set.  See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`
for examples of computations with ECP-containing basis sets.

.. warning:: Analytic derivatives of ECPs are not yet available.  The HF and DFT derivatives are implemented in a semi-numerical scheme, where numerical ECP gradients are added to analytic SCF gradients.  Analytic gradients for (DF)MP2 are not yet available, but the standard numerical gradients will work correctly.  Fully analytic gradients will be implemented soon.

.. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations.  If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_.

.. _`sec:scfqmmm`:

External potentials and QM/MM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM
computations, |PSIfour| can perform more rudimentary QM/MM procedures via the
|scf__extern| keyword.  The following snippet, extracted from the
:srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::

    import numpy as np
    external_potentials = [
        [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],
        [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],
        [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]

    gradient('scf', external_potentials=external_potentials)

The ``external_potentials`` array has three rows for three separate
particles, and it is passed to the SCF code on the last line. The
rows are composed of the atomic charge, x coordinate, y coordinate,
and z coordinate in that order. The atomic charge and coordinates are
specified in atomic units, [e] and [a0]. Add as many particle rows as
needed to describe the full MM region.

.. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an
   external potential like the above looked like ::

    Chrgfield = QMMM()
    Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706)
    Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760)
    Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652)
    psi4.set_global_option_python('EXTERN', Chrgfield.extern)

    gradient('scf')

   The main differences are that (1) the specification of
   charge locations in the old way used the units of the active
   molecule, whereas the new way always uses Bohr and (2) the
   specification of the charge and locations in the old way used the
   :py:class:`psi4.driver.QMMM` class directly and added one charge
   per command, whereas the new way consolidates all into an array and
   passes it by keyword argument to the calculation.

   The successor to the :py:class:`psi4.driver.QMMM` class,
   :py:class:`psi4.driver.QMMMbohr`, is operable, but it is discouraged
   from being used directly.

To run a computation in a constant dipole field, the |scf__perturb_h|,
|scf__perturb_with| and |scf__perturb_dipole| keywords can be used.  As an
example, to add a dipole field of magnitude 0.05 a.u. in the y direction and
0.1 a.u. in the z direction, we can use the following keywords::

    set perturb_h true
    set perturb_with dipole
    set perturb_dipole [ 0, 0.05, 0.1 ]

Note that if any specified fields do not fall along a symmetry axis, the
symmetry of the calculation should be reduced accordingly; if in doubt run the
calculation in C1 symmetry.  For examples of SCF and MP2 calculations in an
external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`.

.. _`sec:scfdefault`:

Convergence and Algorithm Defaults
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _`table:conv_scf`:

.. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_

    +--------------------+--------------------+----------------------+----------------------+---------------------+
    | *Ab Initio* Method | Calculation Type   | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |
    +====================+====================+======================+======================+=====================+
    | SCF of HF or DFT   | energy             | 6                    | 6                    | DF                  |
    +                    +--------------------+----------------------+----------------------+                     +
    |                    | optimization       | 8                    | 8                    |                     |
    +                    +--------------------+----------------------+----------------------+                     +
    |                    | frequency [#f7]_   | 8                    | 8                    |                     |
    +--------------------+--------------------+----------------------+----------------------+---------------------+
    | SCF of post-HF     | energy             | 8                    | 8                    | PK [#f3]_           |
    +                    +--------------------+----------------------+----------------------+                     +
    |                    | optimization       | 10                   | 10                   |                     |
    +                    +--------------------+----------------------+----------------------+                     +
    |                    | frequency [#f7]_   | 10                   | 10                   |                     |
    +                    +--------------------+----------------------+----------------------+                     +
    |                    | CC property [#f2]_ | 10                   | 10                   |                     |
    +--------------------+--------------------+----------------------+----------------------+---------------------+

.. _`table:conv_corl`:

.. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_

    +--------------------+--------------------+----------------------+-------------------------+
    | *Ab Initio* Method | Calculation Type   | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_    |
    +====================+====================+======================+=========================+
    | post-HF of post-HF | energy             | 6                    |                         |
    +                    +--------------------+----------------------+-------------------------+
    |                    | optimization       | 8                    |                         |
    +                    +--------------------+----------------------+-------------------------+
    |                    | frequency [#f7]_   | 8                    |                         |
    +                    +--------------------+----------------------+-------------------------+
    |                    | CC property [#f2]_ | 8                    |                         |
    +--------------------+--------------------+----------------------+-------------------------+

.. rubric:: Footnotes

.. [#f1] Note that this table applies only the SCF module,
   not to the final convergence criteria for post-HF methods or to methods
   that use an alternate starting point, like MCSCF. SAPT computations, too,
   set tighter values.

.. [#f2] This applies to properties computed through the :py:func:`~psi4.properties` function.

.. [#f3] Post-HF methods that do not rely upon the usual 4-index AO integrals use a
   density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default |globals__scf_type| is DF.

.. [#f4] Note that this table applies to the final convergence criteria for
   all the post-SCF modules that define a |ccenergy__e_convergence| keyword.

.. [#f5] The E_CONVERGENCE keyword is implemented for most post-SCF modules.
   See a list beginning at |ccenergy__e_convergence|.

.. [#f6] The R_CONVERGENCE keyword places a convergence check on an internal
   residual error measure and is implemented for several post-SCF
   modules (see list beginning at |ccenergy__r_convergence|). It is defined
   according to the quantum chemical method and so its default value is set
   by each module individually.

.. [#f7] For frequency computations by finite difference of energies,
   convergence criteria are tightened further still to 10 for
   |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11
   for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,
   and 10 for E_CONVERGENCE for post-HF of post-HF.

.. _`sec:scfrec`:

Recommendations
~~~~~~~~~~~~~~~

The SCF code is quite flexible and powerful.
We have tried as much as possible to keep the number of options to
a minimum and to allow all options to be used in the presence of all other
options. Below are some rough words of advice about using the SCF code for
practical calculations:

* For |scf__guess|, the ``SAD`` guess is usually your
  friend, even for open-shell systems (at the very least, it gets the right
  number of electrons, unlike some other programs). For instance, we have found
  that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis
  and then performing a cast-up, at a fraction of the cost.  However, SAD and
  DOCC/SOCC arrays do not play very well together at the moment.
* For wall time, ``DF`` may be a factor of ten or more faster than the exact
  integral technologies available in |PSIfour|.
  Use ``DF`` unless you need absolute accuracy or do not
  have a -JKFIT auxiliary set for your orbital basis/atom type. Then use
  ``DIRECT``.
* Don't mess with the DIIS convergence options unless convergence is a problem.
  We have optimized the parameters for efficiency over a wide array of system
  types.
* Buy a developer a beer!

The "best-practice" input file for HF is::

    memory 1 GB  # As much as you've got, the DF algorithm can use

    molecule {
    O
    H 1 1.0
    H 1 1.0 2 104.5
    }

    set {
    basis cc-pvdz
    scf_type df
    guess sad
    ints_tolerance 1.0E-10  # Even this is epically tight, 1.0E-8 is OK
    }

    energy('scf')
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:prog_intro`:

================================================
Introduction to Programming in |PSIfour|
================================================

.. toctree::
   prog_welcome
   prog_conduct
   prog_setup
   prog_tour
   prog_help 
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: LIBEFP, EFP

.. _`sec:libefp`:

Interface to LIBEFP by I. Kaliman
=================================

.. codeauthor:: Andrew C. Simmonett, A. Eugene DePrince III, Rollin A. King, and Lori A. Burns
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <psi4/driver/procrouting/solvent/efp.py>`

.. image:: https://img.shields.io/badge/home-libefp-5077AB.svg
   :target: https://github.com/libefp2/libefp

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://github.com/libefp2/libefp

|PSIfour| contains code to interface to the LIBEFP library developed
in L. Slipchenko's group by I. Kaliman. LIBEFP
requires no additional licence,
downloads, or configuration. Since February 2017, libefp is not required to build
|Psifour|.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/libefp/badges/version.svg
     :target: https://anaconda.org/psi4/libefp

* libefp is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, libefp has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  libefp can be obtained through ``conda install libefp -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_libefp`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect libefp and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   libefp from conda without thinking, consult.

* To remove a conda installation, ``conda remove libefp``.

**Source**

* .. image:: https://img.shields.io/github/tag/ilyak/libefp.svg?maxAge=2592000
     :target: https://github.com/ilyak/libefp

* If using |PSIfour| built from source and you want libefp built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_libefp`,
  and let the build system fetch and build it and activate dependent code.

.. index:: EFP; library fragments
   pair: EFP; adding new

.. _`sec:findingEFPFragments`:

EFP Fragments
~~~~~~~~~~~~~

LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,
common solvents, etc.) listed :ref:`here <sec:availableEFPFragments>`
with source https://github.com/libefp2/libefp/tree/master/fraglib.  Any of these may be used directly in
a |PSIfour| input file as described :ref:`here <sec:usingEFPFragments>`.

.. comment .. note:: The built-in fragment library distributed with Q-Chem (as of version 4.0.1) is *not*
.. comment    equivalent to that distributed with LIBEFP. Although many of the same
.. comment    molecules are present and should perform similarly in computations,
.. comment    exact matches of fragment geometries or efp energies should not be
.. comment    expected. See files in test case directories :source:`qchem-efp-sp
.. comment    <tests/libefp/qchem-efp-sp>` and :source:`qchem-qmefp-sp
.. comment    <tests/libefp/qchem-qmefp-sp>` for equivalent Q-Chem and |PSIfour|
.. comment    EFP input files.

Creating new efp fragments requires the `GAMESS
<https://www.msg.chem.iastate.edu/gamess/index.html>`_ quantum chemistry package.
Instructions on building new fragments are `here
<https://github.com/libefp2/libefp#how-to-create-custom-efp-fragment-types>`_.
Once your new fragment is ready, make it accessible to |PSIfour| by
including the directory in which the ``.efp`` file is located to the colon
separated environment variable :envvar:`PSIPATH`. Fragments are searched
for first in the current directory, next in the paths of :envvar:`PSIPATH`, and
finally in built-in library. If |PSIfour| is unable to find the
fragment, an error will be reported.

.. note:: When constructing new fragment files, the name of the name of the
   file should be lowercase and have extension ``.efp``. The molecule name
   within the file, *e.g.*, ``$NH3`` must correspond to the name of the
   fragment file.

.. index:: molecule; EFP
   single: EFP; molecule specification

.. _`sec:usingEFPFragments`:

Molecule Specification
~~~~~~~~~~~~~~~~~~~~~~

EFP fragment geometries are specified alongside the quantum mechanical
(QM) molecule and make use of the ``--`` fragment separation scheme
described :ref:`here <sec:fragments>`. Each EFP fragment has its own
fragment section that includes the label ``efp``, the name of the file
*fragname* from which EFP parameters are to be read, and the position
specification for the fragment in one of two ways, XYZABC or POINTS. For
XYZABC, the fragment specification is all on one line: ``efp`` and
*fragname* are followed by two sets of three numbers: the coordinates
of the center of mass of the fragment and the three Euler angles that
specify orientation about the center of mass. This format is compact
but not readily generated from molecule viewing software. ::

    efp  nh3  0.0 0.0 5.0  5 2 8

More convenient is the POINTS fragment specification. This consists of
four lines, the first of which is ``efp`` and *fragname*. The next lines
are the coordinates (without element labels) of the first three atoms
in the fragment. Note that EFP fragment geometries are rigid, so the
first atom will be placed exactly where specified by the first point,
the second atom will be placed along the vector between the first and
second points, and the third atom will be placed in the plane formed
by the three points. ::

    efp ch3oh
    1.275    -2.447    -4.673
    0.709    -3.191    -3.592
    2.213    -1.978    -4.343

.. note:: At present, |PSIfour| has limited support for diatomic
   and monoatomic EFP fragments. Single points are allowed when the
   di-/mono-atomic fragments are specified in XYZABC format. Optimizations
   are not allowed.

:ref:`Just as for QM <sec:moleculeKeywords>`, the center of mass
coordinates in the XYZABC format and all coordinates in the POINTS format are
taken to be in Angstroms by default or in Bohr if ``units au`` is present.
Charge and multiplicity specifications are encoded in the fragment file
and so are not read from input.

Any combination of EFP and QM fragments can be placed in a molecule; even
the oddity below is legitimate. Note that symmetry and reorientation are
automatically turned off when EFP fragments are present (``symmetry c1``
and ``no_com`` and ``no_reorient`` are implied). ::

    molecule qmefp {
      efp nh3 0.0 0.0 5.0 5 2 8
      --
      C  0.0 0.0 0.0
      O  0.0 1.5 0.0
      O  0.0 -1.5 0.0
      --
      efp h2o 5.0 0.0 0.0 5 2 8
      --
      He  -3.0 4.0 4.0
      He  -4.0 5.0 4.0
      --
      efp ch3oh
      1.275    -2.447    -4.673
      0.709    -3.191    -3.592
      2.213    -1.978    -4.343
    }


Running EFP 
~~~~~~~~~~~~

EFP can be invoked in similar fashion as other theories provided in |PSIfour|.
For example, if you want to obtain the EFP interaction energy for benzene and two waters,
simply provide the following::

   molecule {
     efp c6h6  0.0 0.0 0.0   0.0 0.0 0.0
     --
     efp h2o   4.0 0.0 0.0   0.0 0.0 0.0
     --
     efp h2o  -4.0 0.0 0.0   0.0 0.0 0.0
   }
   
   energy('efp')

This computation involves purely EFP/EFP fragment interactions and is
performed entirely by the LIBEFP library.  |PSIfour| can also handle mixed
systems of quantum mechanical (QM) and EFP fragments through the native
:ref:`SCF <sec:scf>` code augmented by calls to the LIBEFP library. For
example, turning one of the waters in the example above into a QM
fragment is shown below. ::

   molecule {
     efp c6h6  0.0 0.0 0.0   0.0 0.0 0.0
     --
     O  4.0   0.0   0.0
     H  4.7   0.7   0.0
     H  3.3  -0.7   0.0 
     --
     efp h2o  -4.0 0.0 0.0   0.0 0.0 0.0
   }
   
   set basis 6-31g
   energy('scf')

Whenever an EFP fragment is present in the active molecule, the SCF energy
will include EFP contributions.

.. warning:: Although the EFP geometry is specified alongside the QM
   geometry in a ``molecule name {...}`` block, internally the handling
   of EFP is not so clean. In straightforward input files that involve
   any number of [molecule block, energy/opt/etc, clean()] portions,
   there should be no problem; the energy/opt computation will always
   be run on the molecule defined in the preceding block. For advanced
   users, unexpected difficulties may arise due to: (1) the EFP fragment
   from the last molecule block executed will always be active (and
   potentially interfering with SCF) and (2) recalling a molecule
   through ``activate(name)`` (where ``name`` was the python handle
   in the molecule block) will not load up any EFP portion of that
   molecule. This divergent treatment is a stopgap while we determine
   how best to handle molecules with different domains.

At this time, |PSIfour| is only able to perform pure-efp single-points and
geometry optimizations and mixed qm/efp SCF single-points.

.. _`table:libefpauto`:

    .. _`table:libefp_methods`:

    +-------------------------+----------------------+--------------------------------------------------------------------------+
    | name                    | molecule composition | calls method                                                             |
    +=========================+======================+==========================================================================+
    | efp                     | pure EFP             | EFP interaction energy (IE) on all frags                                 |
    +                         +----------------------+--------------------------------------------------------------------------+
    | efp                     | mixed QM/EFP         | EFP IE on EFP frags only                                                 |
    +                         +----------------------+--------------------------------------------------------------------------+
    | efp                     | pure QM              | *error*                                                                  |
    +-------------------------+----------------------+--------------------------------------------------------------------------+
    | scf                     | pure EFP             | *error*                                                                  |
    +                         +----------------------+--------------------------------------------------------------------------+
    | scf                     | mixed QM/EFP         | SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags | 
    +                         +----------------------+--------------------------------------------------------------------------+
    | scf                     | pure QM              | SCF energy on all frags (normal |Psifour| operation)                     |
    +-------------------------+----------------------+--------------------------------------------------------------------------+

.. index:: EFP; library fragments

.. _`sec:availableEFPFragments`:

Fragment Library
~~~~~~~~~~~~~~~~

Below are documented the EFP fragments available from the LIBEFP library.
These systems are accessible in ``molecule {...}`` blocks without
additional configuration.

----

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:

   autodoc_available_efpfrag

.. include:: autodoc_available_efpfrag.rst


.. _`cmake:libefp`:

How to configure libefp for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, libefp is a library that provides additional
  molecular modeling capabilities (EFP).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) libefp

* Upstream Dependencies |w---w| libefp |dr| BLAS/LAPACK

**CMake Variables**

* :makevar:`ENABLE_libefp` |w---w| CMake variable toggling whether Psi4 builds with libefp
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing ``include/efp.h``
* :makevar:`libefp_DIR` |w---w| CMake variable to specify where pre-built libefp can be found. Set to installation directory containing ``share/cmake/libefp/libefpConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_libefp` |w---w| CMake variable to force internal build of libefp instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_libefp` |w---w| CMake variable to force detecting pre-built libefp and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_libefp=ON

B. Build *without* libefp

  .. code-block:: bash

    >>> cmake

C. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root

  .. code-block:: bash

    >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir

D. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_help`:

=================
Where to Get Help
=================

Slack
-----

|PSIfour| has an active `Slack channel <https://psi4.slack.com/>`_
for developers, and a friendly community willing to answer your questions.  

Reporting Bugs
--------------

Program bugs should be reported as Issues on GitHub, 
`here <https://github.com/psi4/psi4/issues>`_.

Using |PSIfour|
---------------

Questions about using |PSIfour|, as opposed to programming for |PSIfour|,
should be directed to the 
`Psi4 User Forum <http://forum.psicode.org/t/welcome-to-the-psi4-forum/>`_.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. |AA|           unicode:: U+00C5 .. as in Angstrom

.. |s_sharp|      unicode:: U+00DF .. as in Hesselmann
.. |a_grave|      unicode:: U+00E0
.. |a_acute|      unicode:: U+00E1
.. |a_circumflex| unicode:: U+00E2
.. |a_tidle|      unicode:: U+00E3
.. |a_dots|       unicode:: U+00E4
.. |aa|           unicode:: U+00E5 .. as in angstrom
.. |e_grave|      unicode:: U+00E8
.. |e_acute|      unicode:: U+00E9
.. |e_circumflex| unicode:: U+00EA
.. |e_dots|       unicode:: U+00EB
.. |i_grave|      unicode:: U+00EC
.. |i_acute|      unicode:: U+00ED
.. |i_circumflex| unicode:: U+00EE
.. |i_dots|       unicode:: U+00EF
.. |n_tilde|      unicode:: U+00F1
.. |o_grave|      unicode:: U+00F2
.. |o_acute|      unicode:: U+00F3
.. |o_circumflex| unicode:: U+00F4
.. |o_tilde|      unicode:: U+00F5
.. |o_dots|       unicode:: U+00F6 .. as in L\ |o_dots|\ wdin
.. |o_slash|      unicode:: U+00F8 .. as in M\ |o_slash|\ ller
.. |u_grave|      unicode:: U+00F9
.. |u_acute|      unicode:: U+00FA
.. |u_circumflex| unicode:: U+00FB
.. |u_dots|       unicode:: U+00FC .. as in H\ |u_dots|\ ckel
.. |sigma|        unicode:: U+03C3

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: ADC
.. index:: Ab initio Polarization Propagator

.. index::
   pair: ADC; theory

.. _`sec:adc`:

ADC: Ab Initio Polarization Propagator
======================================
.. sectionauthor:: Michael F. Herbst

*Module:* :ref:`Keywords <apdx:adc>`, :ref:`PSI Variables <apdx:adc_psivar>`, :source:`ADC <psi4/src/psi4/adc>`

Algebraic-diagrammatic construction methods for the polarization propagator (ADC)
determine correlated excitation energies by investigating the pole structure
of said propagator. For this the propagator is expressed in a representation
constructed from so-called intermediate states, which in turn are based
upon a correlated |MollerPlesset| (MP) ground state. The original derivation
of the ADC scheme was purely diagrammatic [Schirmer:1982]_
and the connect to the intermediate states was developed only later [Trofimov:2006]_.
In general :math:`n`-th order ADC theory, ADC(:math:`n`),
is constructed upon an :math:`n`-th order MP ground state.
In this sense one can consider an ADC(:math:`n`) treatment of excited states
consistent to an MP(:math:`n`) perturbation expansion of the ground state.

In ADC methods the residue calculus of the propagator is translated into an eigenvalue
problem with respect to the so-called shifted Hamiltonian or ADC matrix.
Denoting this matrix as :math:`\mathbf{A}`, the eigenproblem can be written
in terms of several blocks

.. math:: \begin{pmatrix}
   \mathbf{A_{SS}} & \mathbf{A_{SD}}\\
   \mathbf{A_{DS}} & \mathbf{A_{DD}}
   \end{pmatrix}
   \begin{pmatrix}
   \mathbf{X_S}\\
   \mathbf{X_D}
   \end{pmatrix}
   =\omega
   \begin{pmatrix}
   \mathbf{X_S}\\
   \mathbf{X_D}
   \end{pmatrix}

where *S* refers to the single and *D* to the double excitation manifolds.
This matrix is typically sparse and thus may be diagonalised iteratively,
for example using Davidson's method [Dreuw:2014:82]_. An alternative viewpoint
has been addressed for example in [Haettig:2002]_, where ADC(2) is related
to other response theories such as CC2-LR, CIS(D) and CIS(D\ :math:`_n`).
In this sense one may consider the ADC matrix the correlated response matrix
to a response problem based on CIS
and apply the simultaneous expansion method (SEM),
in which the |sigma|-vectors (ADC matrix-vector products)
are constructed several times.

The structure and order of the blocks in the equation above
depend on the ADC level employed. With this also the computational cost changes.
The key computational step, namely the formation of the matrix-vector products
scales as :math:`{\cal O}(N^5)` for ADC(2) and :math:`{\cal O}(N^6)`
for ADC(2)-x and ADC(3). Several additional approximations,
such as frozen-core, frozen-virtual
may be applied to reduce the cost of the problem.
Using the core-valence separation (CVS) approximation
one may specifically target core-valence-excitations
at a substantial reduction in cost.
With the spin-flip modification few-reference ground states can
be tackled starting from a triplet reference by simultaneously
exciting an electron and flipping its spin.
A more detailed overview of such modifications gives [Dreuw:2014:82]_
and the `adcc theory documentation <https://adc-connect.org/latest/theory.html>`_.

Available ADC methods
---------------------
.. sectionauthor:: Michael F. Herbst

Several ADC methods are available in |PSIfour| for the computation of excited states,
see :ref:`table:adcsummary`.
The methods are implemented in two distinct codes,
one is part of |PSIfour| itself and will be referred to as the *built-in* implementation,
the other is available via an interface to the `adcc <https://adc-connect.org>`_ python module.
The two backends follow different approaches to compute ADC excited states
and as a result details and supported keywords differ.
After a more general introduction, specific aspects of the two implementations will be highlighted
in section :ref:`sec:interfaceadcc` and :ref:`sec:adcbuiltin`.

.. _`table:adcsummary`:

.. table:: ADC capabilities of Psi4

   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | Method        | Backend   | References | Exc. Energies | Props | Supported values for kind keyword  |
   +===============+===========+============+===============+=======+====================================+
   | ADC(1)        | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet, spin_flip  |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | ADC(2)        | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet, spin_flip  |
   +               +-----------+------------+---------------+-------+------------------------------------+
   |               | built-in  | RHF        | yes           | ---   |  singlet                           |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | ADC(2)-x      | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet, spin_flip  |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | ADC(3)        | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet, spin_flip  |
   +---------------+-----------+------------+---------------+--------------------------------------------+
   | CVS-ADC(1)    | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet             |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | CVS-ADC(2)    | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet             |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | CVS-ADC(2)-x  | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet             |
   +---------------+-----------+------------+---------------+-------+------------------------------------+
   | CVS-ADC(3)    | adcc      | RHF, UHF   | yes           | yes   |  any, singlet, triplet             |
   +---------------+-----------+------------+---------------+-------+------------------------------------+

The leftmost column of table :ref:`table:adcsummary` provides the supported ADC methods.
If only excitation energies are desired, one can simply pass one
of the listed method strings to the function :py:func:`~psi4.energy`.
For example, ``energy('adc(2)-x')`` will compute
excitation energies at ADC(2)-x level.
Properties such as oscillator strengths, transition or state dipole moments
are available by calling the function :py:func:`~psi4.properties`
with appropriate arguments.
Most commonly users will want to compute at least oscillator strengths
along with the excitation energies,
resulting in a call like ``properties('adc(2)', properties=["oscillator_strength"])``.

Running ADC calculations
------------------------
.. sectionauthor:: Michael F. Herbst

Running an ADC calculation with |PSIfour| requires
the call to :py:func:`~psi4.properties` as discussed above
as well as one or more mandatory keyword arguments.

The most important keyword argument is |adc__roots_per_irrep|,
which is an array with the number of excited states desired
for each irreducible representation. Most ADC methods
are only supported at C1 symmetry at the moment, such that
this option should in most cases be set to an array with a single
element only. For example one can run an ADC(2) calculation for 10
(singlet) excited states using::

   set roots_per_irrep [10]
   properties('adc(2)', properties=["oscillator_strength"])

where the ``molecule`` section was dropped for brevity.

**Selecting the excitation manifold.**
To select between the possible excitation manifolds,
use the |adc__kind| keyword. For restricted references
by default only singlet excited states are computed,
corresponding to the keyword value ``'singlet'``.
To compute triplet states, select ``'triplet'``.
To compute both without making a spin distinction, select ``'any'``.
The latter is default for unrestricted references.

The special |adc__kind| value ``'spin_flip'`` selects
a spin-flip computation where a simultaneous flip of spin
and excitation is performed. This is only available
for unrestricted references and not for ``CVS-ADC(n)`` methods,
see table :ref:`table:adcsummary`.

**Using the core-valence separation.**
For tackling core-valence excitations using the ``CVS-ADC(n)``
methods, the keyword argument |adc__num_core_orbitals|
is additionally required. It is used to specify the number of
(spatial) orbitals to put into the core space and thus select
as target orbitals for a core-valence excitation process.
A value of ``2`` indicates, for example,
that the two lowest-energy :math:`\alpha` and the two
lowest-energy :math:`\beta` orbitals are placed in the core space.
Since the implemented ADC procedures tackle the
lowest-energy excitations, the value should be specified
such that the targeted core orbital is just inside the core space.

*Example:* Consider furane, :math:`C_4H_4O`. In order to tackle
the oxygen 1s edge, *i.e* simulate a O 1s XAS spectrum, one may
just set |adc__num_core_orbitals| to ``1``. This will select the
oxygen 1s orbital for the core space as it is energetically the lowest.
For C 1s core excitations the |adc__num_core_orbitals| value needs
to be set to ``5``, such that both the O 1s and all four C 1s orbitals
are part of the core space.

**Other keywords and examples.**
Apart from the mentioned keywords, the following are common:

.. include:: autodir_options_c/adc__reference.rst
.. include:: autodir_options_c/adc__r_convergence.rst
.. include:: autodir_options_c/adc__num_guesses.rst
.. include:: autodir_options_c/adc__cutoff_amps_print.rst

The full list is provided in appendix :ref:`apdx:adc_psivar`
and many more sample input files can be found in the adc and adcc
subfolders of :source:`samples`.
Note, that not all keywords are supported by all backends.

**Switching between ADC backends.**
Psi4 currently defaults to the built-in implementation for all ADC(2) energy calculations.
You can explicitly set the |globals__qc_module| option to ``'adcc'``
enforce using adcc also for this case.

.. _`sec:interfaceadcc`:

Interface to adcc
-----------------
.. codeauthor:: Michael F. Herbst
.. sectionauthor:: Michael F. Herbst

For most implemented ADC methods |PSIfour| relies
on an interface to the `adcc <https://adc-connect.org>`_ python package.
The approach of adcc is to directly diagonalise the
ADC matrix :math:`\mathbf{A}` in an iterative diagonalisation
procedure, usually a Jacobi-preconditioned Davidson. Expensive parts
of the ADC matrix-vector product are precomputed and stored
in memory. This approach is general in the sense
that it can be applied to a large range of ADC methods and variants.
So far levels up to ADC(3) and CVS-ADC(3) are available
and additional approximations such as
|globals__freeze_core| and |globals__num_frozen_uocc|
are supported with all ADC methods using the adcc backend.

Currently adcc is only capable of performing in-core calculations,
for which, however, permutational symmetry and spin symmetry is taken
into account for both tensor computations and tensor storage.
Inside adcc some heuristic checks for overly excessive memory requirements
are implemented, resulting in a warning in case a
successful execution is unlikely. There are no guarantees for the memory
to be sufficient in case such a warning is not displayed.

More detailed documentation about adcc and its features can be found
at `<https://adc-connect.org>`_,
especially the `theory section <https://adc-connect.org/latest/theory.html>`_.
If you are using adcc from |PSIfour| for your calculations,
please cite both |PSIfour| as well as adcc [Herbst2020]_
in your published work.

**The ADC wavefunction object.**
After running the ADC calculation in adcc, the interface code sets
a number of variables in the returned :py:class:`~psi4.core.Wavefunction`
in case they are computed.
In the following the ``<method>`` prefix refers to the ADC method (such as ``adc(1)``,
``adc(3)``, ``cvs-adc(2)-x``). For example excitation energies for ADC(2) are thus
available via the variable ``ADC(2) excitation energies``.


* Ground state energy terms like ``MP2 correlation energy``, ``MP3 correlation energy``,
  ``MP2 total energy``, ``MP3 total energy``, ``current correlation energy`` and ``current energy``.
* ``number of iterations``: The number of iterations the iterative solver required to converge.
* ``number of excited states``: The number of excited states, which were computed.
* ``<method> excitation energies``: The obtained excitation energies as a :py:class:`~psi4.core.Matrix`.
* ``MP2 dipole X`` and the other components: Ground state dipole moments at MP(2) level.
* ``<method> transition dipoles``, ``<method> oscillator strengths``,
  ``<method> rotational strengths`` and ``<method> dipoles``:
  The respective properties as :py:class:`~psi4.core.Matrix`

The following attribute is set on returned wavefunctions:

* ``adcc_state``: The `adcc.ExcitedStates <https://adc-connect.org/q/excitedstates>`_
  object used by adcc to store the ADC(n) excitation energies and all precomputed data
  in the format used by adcc.
  Provides direct access to analysis and plotting capabilities from adcc.
  For example ``adcc_state.plot_spectrum()`` plots a broadened excited states spectrum
  in matplotlib. See the `adcc calculations documentation <https://adc-connect.org/latest/calculations.html>`_
  for details.

**Tips for convergence issues.**
If you encounter convergence issues inside adcc, the following parameters
are worth tweaking:

* |adc__max_num_vecs|: Specifies the maximal number of subspace vectors
  in the Jacobi-Davidson scheme before a restart occurs. The defaults are usually
  good, but do not be shy to increase this value if you encounter convergence problems.
* |adc__num_guesses|: By default adcc uses twice as many guess vectors as
  states to be computed. Sometimes increasing this value by a few vectors can be helpful.
  If you encounter a convergence to zero eigenvalues, than decreasing this parameter might
  solve the problems.

.. _`sec:adcbuiltin`:

Built-in ADC(2) code
--------------------
.. codeauthor:: Masaaki Saitow
.. sectionauthor:: Masaaki Saitow

.. warning:: The built-in ADC(2) method may give incorrect results if
             multiple roots are requested, due to an error in the Davidson solver,
             and is no longer maintained. It is slated for removal in Psi4 1.7.
             Use of the Psi interface to `adcc` instead is strongly recommended.
             To use this code regardless, either do not have `adcc` installed, or
             set `qc_module builtin`.

The ADC code built into |PSIfour| is capable of ADC(2) computations
of singlet excited states only.
It makes use of the libtrans library for efficient and flexible
integral-transformation and also the libdpd library to
utilize molecular symmetry in the tensorial manipulations in framework
of the direct-product decomposition algorithm. By this feature, the Ritz
space and intermediate tensors are blocked according to the irreducible
representations of the point group, and the excited states that belong
to different symmetry are sought separately.

In the output of ADC, the ADC(2) results may look as follows::

    ->  1 B1 state   :  0.2565095 (a.u.),  6.9799824 (eV)
    Non-iterative:  0.2565636 (a.u.),  6.9814532 (eV)
             Occ Vir        Coefficient
    ---------------------------------------------
              3   0        -0.9017047264
              3   2         0.3038332241
              3   1         0.2907567119
              3   5        -0.0790167706
              3   4        -0.0425829926
              
    Converged in   4 iteration.
    Squared norm of the S component:  0.9315336
    The S vector is rotated up to  8.102 (deg.)

in which the ADC(2) excitation energy is indicated with arrow symbol
and the pseudo-perturbative value, which is calculated in very similar
fashion to the CIS(D) energy, is also presented on the following line. In
this implementation, the ADC(2) secular matrix is treated effectively
by renormalization of the double excitation manifold into the single
excitation manifold. So, the effective secular equation is solved for
several times for the specific state due to the eigenvalue dependence of
the effective response matrix. Only the S component of the transition
amplitude is obtained explicitly and the squared norm of the S block
and the rotation angle from the corresponding CIS vector are given
below the element of the amplitude. The difference between the ADC(2)
value and its non-iterative counterpart is mostly negligible if the
mixture among the CIS excited states is small and the quasi-degeneracy
in the excited state is tolerably weak. But if there is a significant
discrepancy in these energies, or the rotation angle is visibly large,
special care may have to be taken for the strong effects caused by the
higher excited states.


**Partial Renormalization Scheme**

The built-in ADC code is capable of performing the partially-renormalized
ADC(2) computation, termed PR-ADC(2). In the perturbative treatment of
the singly-excited state, the doubly and triply excited configurations
are accounted for as in the case of CIS(D). In the language of 
CIS(D), the former is regarded to introduce the orbital relaxation (OR)
effect while the latter is argued to give rise to the differential
correlation (DC) correction to the excited state. In the PR-ADC(2)
scheme, the DC term is corrected according to the ground state
PR-MP2 correlation, in which the correlation between the electron pairs
is accounted for in size-consistent and unitary-invariant fashion by
modulating the MP1 amplitude. By utilizing the |adc__pr| scheme, substantial
resistance against quasi-degeneracy is readily granted as discussed
in Ref. [Saitow:2012]_.

**Theory of the built-in ADC(2) implementation**

For the built-in ADC(2) implementation
some very essential points shall be emphasized. In ADC(2) specifically
one may write the response equation as

.. math:: \begin{pmatrix}
   \mathbf{A_{SS}^{(2)}} & \mathbf{A_{SD}^{(1)}}\\
   \mathbf{A_{DS}^{(1)}} & \mathbf{A_{DD}^{(0)}}
   \end{pmatrix}
   \begin{pmatrix}
   \mathbf{X_S}\\
   \mathbf{X_D}
   \end{pmatrix}
   =\omega
   \begin{pmatrix}
   \mathbf{X_S}\\
   \mathbf{X_D}
   \end{pmatrix}

where the superscript on each matrix block indicates the order of
the fluctuation. Instead of solving the above equation explicitly,
the large D manifold is treated effectively as

.. math:: [\mathbf{A_{SS}^{(2)}}+
   \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega-
   \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=
   \omega\mathbf{X_{S}}.

This form of the ADC(2) equation requires 7--10 iterations for
convergence on only one root. But thanks to Newton-Raphson
acceleration,

.. math:: \omega^{n+1}=\omega^{n}-
   \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}
   [\mathbf{A_{SS}^{(2)}}+
   \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}
   \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}
   (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}
   (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}
   (\omega^n)}

the computational time reduces to shorter than half of the simple iterative
procedure. Construction of the denominator of the second term in the above
equation is less computationally expensive than construction of one :math:`\sigma`\ -vector
with respect to the effective response matrix. The non-iterative excitation energy stated
above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,

.. math:: \omega^{Non-Iterative}=
   \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+
   \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}
   \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}

where :math:`\omega^{CIS}` and :math:`\mathbf{X_{CIS}}` denote the CIS 
excitation energy and wave function, respectively. The explicit form of the 
|sigma|-vector is provided in a note accompanying the source code,
in the file :source:`psi4/src/psi4/adc/sigma.pdf`.
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: molecule; specification
.. _`sec:moleculeSpecification`:

===================================
Molecule and Geometry Specification
===================================

Coordinates
===========

|PSIfour| has a very flexible input parser that allows the user to provide
geometries as Cartesian coordinates, Z-matrix variables, or a combination of
both. The use of fixed values and variables are supported for both. For
example, the geometry for H\ :sub:`2` can be specified a number of ways, using the
:samp:`molecule {optional_molecule_name} \\{...\\}` block. ::

    molecule {
      H
      H 1 0.9
    }
    
or ::
    
    molecule {
      H
      H 1 r
      r = 0.9
    }
    
or ::
    
    molecule {
      H1
      H2 H1 0.9
    }
    
or ::
    
    molecule {
      H 0.0 0.0 0.0
      H 0.0 0.0 0.9
    }
    
or ::
    
    molecule {
      H 0.0 0.0 0.0
      H 0.0 0.0 r
      r = 0.9
    }
    
or ::
    
    molecule {
      H 0.0 0.0 -r
      H 0.0 0.0 r
      r = 0.45
    }

Blank lines are ignored and, unlike regular Python syntax, indentation within
the molecule block does not matter, although the ``molecule`` keyword itself must
be aligned within the input according to standard Python syntax. For more
examples of geometry specification, see the :srcsample:`mints1` input file in the samples
folder. It is also possible to mix Cartesian and Z-matrix geometry
specifications, as demonstrated in the :srcsample:`mints4` and
:srcsample:`mints6` sample input files.  For example, consider the following
geometry specification, taken from the :srcsample:`mints6` input::

    molecule alanine {
        N           -1.527107413251     0.745960643462     0.766603000356
        C           -0.075844098953     0.811790225041     0.711418672248
        C            0.503195220163    -0.247849447550    -0.215671574613
        O           -0.351261319421    -0.748978309671    -1.089590304723
        O            1.639498336738    -0.571249748886    -0.174705953194
        H           -1.207655674855    -0.365913941094    -0.918035522052
        # First, remove the H from the alpha carbon.  This line could be deleted
        # and is only included for completeness
        #H            0.429560656538     0.717651915252     1.673774709694
        # Now patch it, using a Z Matrix specification.  This patch can be applied
        # anywhere in the coord specification, as long as it appears lower than
        # the atoms referenced, as is usual for Z-Matrices
        C  2  rCC   3  aCCC   1  dCCCN
        H  7  rCH1  2  aHCC1  3  dHCCC1
        H  7  rCH2  2  aHCC2  3  dHCCC2
        H  7  rCH3  2  aHCC3  3  dHCCC3
        H            0.221781602033     1.772570540211     0.286988509018
        H           -1.833601608592     0.108401996052     1.481873213172
        H           -1.925572581453     1.640882152784     0.986471814808
    
        aCCC = 108.0
        rCC = 1.4
        dCCCN = 120
        rCH1 = 1.08
        rCH2 = 1.08
        rCH3 = 1.08
        aHCC1 = 109.0
        aHCC2 = 109.0
        aHCC3 = 109.0
        dHCCC1 = 0.0
        dHCCC2 = 120.0
        dHCCC3 = 240.0
    }

Here, we remove the hydrogen from the alpha carbon of glycine and replace it
with a methyl group.  Applying this patch using Cartesian coordinates is
difficult, because it depends on the orientation of the existing glycine unit.
In this example, we use Z-Matrix coordinates to define the methyl group, and
define the orientation in terms of the existing glycine Cartesian coordinates
which is much easier to visualize than the corresponding Cartesian-only
approach.

.. index:: molecule; multiple in input file
.. _`sec:multipleMolecules`:

.. index::
   triple: setting; keywords; molecule
   pair: molecule; charge
   pair: molecule; multiplicity
   pair: molecule; symmetry
   pair: molecule; no_reorient
   pair: molecule; units
.. _`sec:moleculeKeywords`:

Molecule Keywords
=================

In addition to specifying the geometry, additional information can be
provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`.

**Charge & Multiplicity**
   If two integers :samp:`{charge} {multiplicity}` are encountered on any
   line of the molecule block, they are interpreted as the molecular charge
   and multiplicity (:math:`2 M_s + 1`), respectively. For multi-fragment 
   complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.

**Units**
   By default, |Angstrom| units are used; this is changed by adding
   a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one
   of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``.

**Orientation**
   Certain computations require that the molecule is not reoriented. This 
   can be achieved by adding either ``no_reorient`` or ``noreorient``. 
   To prevent even recentering of the molecule, add ``no_com`` or ``nocom``.

**PubChem**
   A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule
   :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either
   the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for
   details.

**Symmetry**
   The symmetry can be specified by a line reading :samp:`symmetry
   {symbol}`, where :samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol
   of the (Abelian) point group to use for the computation, one of one of
   ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.
   This need not be specified, as the molecular symmetry is automatically
   detected by |PSIfour|. See :ref:`sec:symmetry` for details.

**Fragments**
   A line reading ``--`` is interpreted as the separator between two non-covalently 
   bound molecular fragments. See :ref:`sec:fragments` for details.

Multiple Molecules
==================

To facilitate more elaborate computations, it is possible to provide a name for
each molecule and tell |PSIfour| which one should be used in a given
calculation. For example, consider the following input file::

    molecule h2 {
      H
      H 1 0.9
    }
    
    set basis cc-pvdz
    set reference rhf
    energy('scf')  # on H2
    
    clean()

    molecule h {
      H
    }
    
    set basis cc-pvdz
    set reference uhf
    energy('scf')  # on H

Here, two separate jobs are performed on two different molecules; the first is
performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be
specified is the "active" molecule by default. To explicitly activate a named
molecule, the activate command is provided. With it, the above input file can be
equivalently written as follows. Alternatively, the molecule can be specified
directly to the computing function. Below, the third calculation is the same as
the first. ::

    molecule h2 {
      H
      H 1 0.9
    }
    
    molecule h {
      H
    }
    
    activate(h2)
    set basis cc-pvdz
    set reference rhf
    energy('scf')  # on H2
    
    clean()

    activate(h)
    set basis cc-pvdz
    set reference uhf
    energy('scf')  # on H

    # --------------------------------------
    # equivalent to previous input ends here

    clean()

    set reference rhf
    energy('scf', molecule=h2)  # on H2

:ref:`sec:jobControl` provides more details about the job control
and calculation keywords used in the above examples.

.. index:: 
   single: Ghost Atoms
   single: molecule; ghost
.. _`sec:ghosts`:

Ghost Atoms
===========

While many common computations, particularly SAPT and counterpoise corrections, can
be greatly simplified using the notation described in :ref:`sec:fragments`,
manual specification of ghost atoms is sometimes required.  Either ::

    molecule he2 {
        He
        Gh(He) 1 2.0
    }

or ::

    molecule he2 {
        He
        @He 1 2.0
    }

will generate a helium dimer with the second atom ghosted, *i.e.*, possessing
basis functions but no electrons or nuclear charge.  See :srcsample:`dfmp2-1`
and :srcsample:`ghosts` for a demonstration of both mechanisms for specifying
ghost atoms.

.. index:: 
   single: Isotopes
   single: molecule; isotope
.. _`sec:isotope`:

Isotopic Substitution
=====================

.. caution:: Use of isotopic substitution in |PSIfour| is not well
   developed, and the syntax is subject to change.

At present, isotopes can only be specified at creation-time of the molecule

The syntax for a deuterium- and tritium-substituted water is below. Note
that asymmetric isotopic substitution such as this *will* change the
molecule's point group symmetry. ::

    molecule dto {
      units au
      O                   0.00000000    0.00000000    0.00000000
      H@2.014101779       0.00000000    1.93042809   -1.10715266
      H_label@3.01604927  0.00000000   -1.93042809   -1.10715266
    }

The masses used by |PSIfour| can be found at
:source:`psi4/include/psi4/masses.h`. See :srcsample:`freq-isotope2` for about
the only use to which isotopologues can presently be put in |PSIfour|.

.. index:: 
   single: PubChem
   single: molecule; PubChem
.. _`sec:pubchem`:

`PubChem <http://pubchem.ncbi.nlm.nih.gov/>`_ Database
======================================================

Obtaining rough starting guess geometries can be burdensome.  The Z-matrix
coordinate system was designed to provide chemists with an intuitive method for
guessing structures in terms of bond lengths and angles.  While Z-matrix input is
intuitive for small molecules with few degrees of freedom, it quickly becomes
laborious as the system size grows.  To obtain a reasonable starting guess
geometry, |PSIfour| can take a chemical name as input; this is then used
to attempt to retrieve Cartesian coordinates from the [PubChem]_ database.

For example, to run a computation on benzene, we can use the following molecule specification::

    molecule benzene {
        pubchem:benzene
    }

If the computer is connected to the internet, the above code will instruct
|PSIfour| to search PubChem for a starting structure.  The search is actually
performed for compounds whose name *contains* "benzene", so multiple
entries will be returned.  If the name provided ("benzene" in the above
example) exactly matches one of the results, that entry will be used.  If no
exact match is found the results, along with a unique chemical identifier
(CID), are printed to the output file, prompting the user to provide a more
specific name.  For example, if we know that we want to run a computation on a
compound whose name(s) contain "benzene", but we're not sure of the exact IUPAC
name, the following input can be used::

    molecule benzene {
        pubchem:benzene*
    }

Appending the "*" prevents an exact match from being found and, at the time
of writing, the following results are displayed in the output file::

     Chemical ID     IUPAC Name
              241   benzene
             7371   benzenesulfonic acid
            91526   benzenesulfonate
              244   phenylmethanol
              727   1,2,3,4,5,6-hexachlorocyclohexane
              240   benzaldehyde
            65723   benzenesulfonohydrazide
            74296   N-phenylbenzenesulfonamide
              289   benzene-1,2-diol
              243   benzoic acid
             7370   benzenesulfonamide
           636822   1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene
             7369   benzenesulfonyl chloride
            12932   N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide
             7505   benzonitrile
            78438   N-[anilino(phenyl)phosphoryl]aniline
            12581   3-phenylpropanenitrile
           517327   sodium benzenesulfonate
           637563   1-methoxy-4-[(E)-prop-1-enyl]benzene
           252325   [(E)-prop-1-enyl]benzene

Note that some of these results do not contain the string "benzene"; these
compounds have synonyms containing that text.  We can now replace the
"benzene*" in the input file with one of the above compounds using either the
IUPAC name or the CID provided in the list, *viz*::

    molecule benzene {
        pubchem:637563
    }
    
or ::
    
    molecule benzene {
        pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene
    }

Some of the structures in the database are quite loosely optimized and do not
have the correct symmetry.  Before starting the computation, |PSIfour| will
check to see if the molecule is close to having each of the possible
symmetries, and will adjust the structure accordingly so that the maximum
symmetry is utilized.

The standard keywords, described in :ref:`sec:moleculeKeywords`, can be
used in conjunction to specify charge, multiplicity, symmetry to use, *etc.* .

.. index:: symmetry, Cotton-ordering
.. _`sec:symmetry`:

Symmetry
========

For efficiency, |PSIfour| can utilize the largest Abelian subgroup of the full
point group of the molecule. Concomitantly, a number of quantities, such as
|globals__socc| and |globals__docc|, are arrays whose entries pertain to irreducible
representations (irreps) of the molecular point group.  Ordering of irreps
follows the convention used in Cotton's :title:`Chemical Applications of Group
Theory`, as detailed in Table :ref:`Irreps <table:irrepOrdering>`.  We refer to this
convention as "Cotton Ordering" hereafter.

.. _`table:irrepOrdering`:

.. table:: Ordering of irreducible representations (irreps) used in |PSIfour|

    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | Point Group    |      1      |       2        |       3        |      4         |     5       |        6       |       7        |       8        |  
    +================+=============+================+================+================+=============+================+================+================+
    | :math:`C_1`    | :math:`A`   |                |                |                |             |                |                |                |  
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`C_i`    | :math:`A_g` | :math:`A_u`    |                |                |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`C_2`    | :math:`A`   | :math:`B`      |                |                |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`C_s`    | :math:`A'`  | :math:`A''`    |                |                |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`D_2`    | :math:`A`   | :math:`B_1`    | :math:`B_2`    | :math:`B_3`    |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`C_{2v}` | :math:`A_1` | :math:`A_2`    | :math:`B_1`    | :math:`B_2`    |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`C_{2h}` | :math:`A_g` | :math:`B_g`    | :math:`A_u`    | :math:`B_u`    |             |                |                |                |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+
    | :math:`D_{2h}` | :math:`A_g` | :math:`B_{1g}` | :math:`B_{2g}` | :math:`B_{3g}` | :math:`A_u` | :math:`B_{1u}` | :math:`B_{2u}` | :math:`B_{3u}` |
    +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+

For example, water (:math:`C_{2v}` symmetry) has three doubly occupied :math:`A_1`
orbitals, as well as one each of :math:`B_1` and :math:`B_2` symmetry; the
corresponding |globals__docc| array is therefore::

    DOCC = [3, 0, 1, 1]

Although |PSIfour| will detect the symmetry automatically, and use the largest
possible Abelian subgroup, the user might want to run in a lower point group.
To do this the molecule keyword :samp:`symmetry {symbol}` can be used 
(see :ref:`sec:moleculeKeywords`).  In most cases the standard
Sch\ |o_dots|\ nflies symbol (one of ``c1``, ``c2``, ``ci``, ``cs``, ``d2``,
``c2h``, ``c2v``, ``d2h`` will suffice for :samp:`{symbol}`.
For certain computations, the user might want to specify which particular
subgroup is to be used by appending a unique axis specifier.  For example when
running a computation on a molecule with :math:`D_{2h}` symmetry in :math:`C_{2v}`, the
:math:`C_2` axis can be chosen as either the :math:`x`, the :math:`y`, or the :math:`z`; these can
be specified by requesting the symmetry as ``c2vx``, ``c2vy``, or ``c2vz``, respectively.
Likewise the ``c2x``, ``c2y``, ``c2z``, ``c2hx``, ``c2hy``, and ``c2hz``
labels are valid.  For :math:`C_s` symmetry the labels ``csx``, ``csy``, and
``csz`` request the :math:`yz`, :math:`xz`, and :math:`xy` planes be used as the mirror plane,
respectively.  If no unique axis is specified, |PSIfour| will choose an appropriate
subgroup.

Certain types of finite difference computations, such as numerical vibrational
frequencies, might lower the symmetry of the molecule.  When this happens
symmetry-dependent arrays, such as |globals__socc|, are automatically remapped
to the lower symmetry.  For example, if we were to investigate the :math:`^2B_1`
state of water cation, we can specify ::

    SOCC = [0, 0, 1, 0]

in the input file.  If any ensuing computations lower the symmetry, the above
array will be appropriately remapped.  For example, reducing the symmetry to
:math:`C_s` (with the molecular plane defining the mirror plane), the above
array will be automatically interpreted as::

    SOCC = [0, 1]

Some caution is required, however.  The :math:`^2A_1` state can be obtained with
the ::

    SOCC = [1, 0, 0, 0]

specification, which would become ::

    SOCC = [1, 0]

under the above-mentioned reduction in symmetry.  The :math:`^2B_2` state,
whose singly-occupied orbitals are ::

    SOCC = [0, 0, 0, 1]

would be mapped to  ::

    SOCC = [1, 0]

which is the same occupation as the :math:`^2A_1` state.  In this case, the
:math:`^2A_1` state is lower in energy, and is not problematic.  The distorted
geometries for the :math:`^2B_2` state are excited states that are subject to
variational collapse.  One way to obtain reliable energies for these states is
to use a multi-state method; in this case it's easier to run the entire
computation in the lowest symmetry needed during the finite difference
procedure.

.. index:: molecule; multiple fragments
.. _`sec:fragments`:

Non-Covalently Bonded Molecule Fragments
========================================

|PSIfour| has an extensive range of tools for treating non-covalent
intermolecular forces, including counterpoise corrections and symmetry adapted
perturbation theory methods. These require the definition of which fragments
are interacting within the complex. |PSIfour| provides a very simple mechanism
for doing so: simply define the complex's geometry using the standard
Cartesian, Z-matrix, or mixture thereof, specifications and then place two
dashes between nonbonded fragments. For example, to study the interaction
energy of ethane and ethyne molecules, we can use the following molecule
block::

    molecule eneyne {
      0 1
      C  0.000000 -0.667578  -2.124659
      C  0.000000  0.667578  -2.124659
      H  0.923621 -1.232253  -2.126185
      H -0.923621 -1.232253  -2.126185
      H -0.923621  1.232253  -2.126185
      H  0.923621  1.232253  -2.126185
      --
      0 1
      C 0.000000 0.000000 2.900503
      C 0.000000 0.000000 1.693240
      H 0.000000 0.000000 0.627352
      H 0.000000 0.000000 3.963929
    }

In this case, the charge and multiplicity of each interacting fragment is
explicitly specified. If the charge and multiplicity are specified for the
first fragment, it is assumed to be the same for all fragments. When
considering interacting fragments, the overall charge is simply the sum of all
fragment charges, and any unpaired electrons are assumed to be coupled to
yield the highest possible :math:`M_s` value.

Having defined a molecule containing fragments like ``eneyne`` above, it
is a simple matter to perform calculations on only a subset of the
fragments. For instance, the commands below run a scf first on the ethene
fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms
and discards remaining fragments) and next on the ethene fragment with the
ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as
Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular
complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::

   mA = eneyne.extract_subsets(1)
   energy('scf')
   
   clean()
   
   mAcp = eneyne.extract_subsets(1,2)
   energy('scf')

If the molecule contains fragments but is not conveniently ordered for the
``--`` marker, the :py:func:`~psi4.auto_fragments` function can be applied, as shown in
:srcsample:`pywrap-basis`, to return as active molecule the previous
active molecule, only fragmented.

Advanced Python
===============

A named molecule in an input file is a full-fledged instance of the
powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member
functions (that have been exported via pybind11) documented thereat
are accessible through the handle :samp:`{option_molecule_name}` in
:samp:`molecule {optional_molecule_name} \\{...\\}`.

*  The molecular geometry can be got and set and manipulated as a
   :py:class:`~psi4.core.Matrix` object. Below shows how to access
   coordinates in an input file in Python. ::

       molecule formaldehyde {
       C  0.0 0.0 0.0
       O  0.0 1.2 0.0
       H -0.8 -0.3 0.0
       H  0.8 -0.3 0.0                         # set geometry in angstroms
       }

       formaldehyde.update_geometry()          # update the molecule internals since pre-energy()-like call
       formaldehyde.print_out()                # print molecule to output file
       geom1psi = formaldehyde.geometry()      # get coordinates in bohr as a psi4.Matrix

       geom1psi.print_out()                    # print coordinates array to output file
       geom1py = mat2arr(geom1psi)             # get coordinates as a Python array
       print geom1py                           # print coordinates to screen

       geom2py = [[ 0.0,  0.0, 0.0],
                 [ 0.0,  1.5, 0.0],
                 [-0.8, -0.3, 0.0],
                 [ 0.8, -0.3, 0.0]]            # define alternate coordinates in angstroms as Python array

       geom2psi = psi4.Matrix(4, 3)            # initialize psi4.Matrix
       geom2psi.set(geom2py)                   # load Python array into psi4.Matrix
       geom2psi.scale(1.0/psi_bohr2angstroms)  # scale into bohr
       geom2psi.print_out()                    # print alternate coord array to output file

       formaldehyde.set_geometry(geom2psi)     # load alternate coordinates into molecule
       formaldehyde.update_geometry()          # update the molecule internals
       formaldehyde.print_out()                # print new molecule to output file
       compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, "geom2 took")

* Molecules can be initiated from XYZ files and fragmented for SAPT computations. ::

       # >>> cat mol1.xyz
       #7
       #
       #O          0.00000000      -0.05786571      -1.47979303
       #N          0.00000000       0.01436394       1.46454628
       #H          0.00000000       0.82293384      -1.85541474
       #H          0.81348351       0.39876776       1.92934049
       #H          0.00000000       0.07949567      -0.51934253
       #H          0.00000000      -0.98104857       1.65344779
       #H         -0.81348351       0.39876776       1.92934049

       # >>> cat mol2.xyz
       # 6 au
       # stuff
       #     C     0.00000000000000     0.00000000000000     5.26601138679877
       #     C     0.00000000000000     0.00000000000000    -3.15195886530135
       #     H     0.00000000000000     0.00000000000000     7.28558683837122
       #     H     0.00000000000000     0.00000000000000    -1.12178201232889
       #     N     0.00000000000000     0.00000000000000     3.08339310458383
       #     N     0.00000000000000     0.00000000000000    -5.33865984413460

       sapt = {'mol1': -0.0105313323529,
               'mol2': -0.00839486625709}

       nre = {'mol1': 38.8138764635,
              'mol2': 72.3451968428}

       set basis jun-cc-pvdz

       for mol in ['mol1', 'mol2']:
           filen = mol + '.xyz'
           p4mol = Molecule.init_with_xyz(filen)           # create molecule from file above
           fragmentedmol = auto_fragments(molecule=p4mol)  # fragment with BFS algorithm
           activate(fragmentedmol)                         # activate returned molecule (for sapt)

           e = energy('sapt0')                             # run SAPT that requires 2 fragments
           compare_values(sapt[mol], e, 5, '%s sapt ok' % mol)
           compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol)
           clean()                                         # clean scratch between loop calcs

* The essential element, mass and coordinate information of the molecule is accessible ::

           molecule eneyne {
           0 1
           C_ene        0.000000  -0.667578  -2.124659
           C_ene        0.000000   0.667578  -2.124659
           H_ene@2.014  0.923621  -1.232253  -2.126185
           H_ene       -0.923621  -1.232253  -2.126185
           H_ene       -0.923621   1.232253  -2.126185
           Gh(H_ene)    0.923621   1.232253  -2.126185
           --
           0 1
           X            9.0        9.0        9.0
           C_yne        0.000000   0.000000   2.900503
           C_yne        0.000000   0.000000   1.693240
           H_yne        0.000000   0.000000   0.627352
           H_yne        0.000000   0.000000   3.963929
           }


           eneyne.update_geometry()

           for iat in range(eneyne.natom()):
               print """{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f}   {:12.6f}""".format(
                                             eneyne.Z(iat),       # atomic number
                                             eneyne.symbol(iat),  # element symbol
                                             eneyne.label(iat),   # input element label
                                             eneyne.charge(iat),  # element charge
                                             eneyne.x(iat),       # x-coordinate
                                             eneyne.y(iat),       # y-coordinate
                                             eneyne.z(iat),       # z-coordinate
                                             eneyne.mass(iat),    # mass
           )


           # 6.0 C    C_ENE          6.0000    -0.031900    -1.218981    -3.948079      12.000000
           # 6.0 C    C_ENE          6.0000    -0.031900     1.304098    -3.948079      12.000000
           # 1.0 H    H_ENE          1.0000     1.713491    -2.286062    -3.950962       2.014000
           # 1.0 H    H_ENE          1.0000    -1.777290    -2.286062    -3.950962       1.007825
           # 1.0 H    H_ENE          1.0000    -1.777290     2.371180    -3.950962       1.007825
           # 0.0 H    H_ENE          0.0000     1.713491     2.371180    -3.950962       1.007825
           # 6.0 C    C_YNE          6.0000    -0.031900     0.042559     5.548101      12.000000
           # 6.0 C    C_YNE          6.0000    -0.031900     0.042559     3.266705      12.000000
           # 1.0 H    H_YNE          1.0000    -0.031900     0.042559     1.252468       1.007825
           # 1.0 H    H_YNE          1.0000    -0.031900     0.042559     7.557685       1.007825

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:prog_welcome`:

===========================
Welcome to New Programmers
===========================

The |PSIfour| community
-----------------------

|PSIfour| is an open-source project and welcomes contributions from
developers around the world.  etc.  We have annual meetings, we welcome
feedback, slack channel, etc.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. index:: 
   pair: cbs(); theory

.. _`eq:cbs`:

.. math:: E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\textbf{scf_scheme}} \left(E_{\text{total},\; \text{SCF}}^{\textbf{scf_basis}}\right) \; + \mathcal{F}_{\textbf{corl_scheme}} \left(E_{\text{corl},\; \textbf{corl_wfn}}^{\textbf{corl_basis}}\right) \; + \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; + \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; + \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; + \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; + \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}}

Here, :math:`\mathcal{F}` is an energy or energy extrapolation scheme, and the following also hold.

.. math:: \delta_{\textbf{delta_wfn_lesser}}^{\textbf{delta_wfn}} \; = \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn}}^{\textbf{delta_basis}}\right) - \mathcal{F}_{\textbf{delta_scheme}} \left(E_{\text{corl},\; \textbf{delta_wfn_lesser}}^{\textbf{delta_basis}}\right)

.. math:: \delta_{\textbf{delta2_wfn_lesser}}^{\textbf{delta2_wfn}} \; = \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn}}^{\textbf{delta2_basis}}\right) - \mathcal{F}_{\textbf{delta2_scheme}} \left(E_{\text{corl},\; \textbf{delta2_wfn_lesser}}^{\textbf{delta2_basis}}\right)

.. math:: \delta_{\textbf{delta3_wfn_lesser}}^{\textbf{delta3_wfn}} \; = \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)

.. math:: \delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)

.. math:: \delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)

A translation of this ungainly equation to example [5] below is as
follows. In words, this is a double- and triple-zeta 2-point
Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction
appended to a triple- and quadruple-zeta 2-point
Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ
reference energy.

.. math:: E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}

.. math:: \delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #


===================
Obtaining |PSIfour|
===================

.. _`faq:obtainpsi4`:

How to obtain Psi4: start with find-the-code quiz, end in ``{top-level-psi4-dir}``
----------------------------------------------------------------------------------

A better decision tree is available at :psicode:`installs/latest`,
though the below remains valid.

Take a :ref:`quiz <faq:quiz>` to find the best version of the codebase for
your needs, be it binary, tarball, or version-controlled repository. Or,
select outright among:

#. :ref:`faq:binary`
#. :ref:`faq:binarypackage`
#. :ref:`faq:clonepsi4public`
#. :ref:`faq:forkpsi4public` (only path to develop |PSIfour|)
#. :ref:`faq:tarballpsi4public`


.. _`faq:quiz`:

Find-the-code Quiz
------------------

A better decision tree is available at :psicode:`installs/latest`,
though the below remains valid.

* I just want to run the code. I may tweak the Python, but I'm not
  developing anything to contribute back to the code base.

  * Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,
    and optimization for a variety of processor architectures, I'm willing to forgo
    architecture tuning wizardry to avoid compiling it myself.

    * I'm on Linux or Mac or Windows with Ubuntu Bash Shell.

      * I'm familiar with conda and want to manage |PSIfour| as an
        ordinary conda package. |w---w| :ref:`Goto Binary-Package
        <faq:binarypackage>`

      * I just want a |PSIfour| installer. |w---w| :ref:`Goto
        Binary-Installer <faq:binary>`

  * I want to compile it myself to eke out best performance on my
    computer. I accept responsibility for navigating compiler, threading,
    and BLAS/LAPACK compatibility

    * I'm willing to have minimal dealings with git (e.g., commands ``git
      clone`` and ``git pull``) in return for easy access in future to new
      features and bug fixes. |w---w| :ref:`Goto Clone-from-GitHub
      <faq:clonepsi4public>`

    * I don't want to deal with this newfangled git, just give me a
      tarball of the source code |w---w| :ref:`Goto Tarball-from-GitHub
      <faq:tarballpsi4public>`

* I want to run *and* develop in |PSIfour|.

  * In keeping with the open-source philosophy, I don't mind my code being
    as public as Psi4 itself during the development process. |w---w|
    :ref:`Goto Fork-from-GitHub <faq:forkpsi4public>`

  * I want to develop *using* |PSIfour| infrastructure and libraries, not
    *on* them; I think a plugin might do.

    * I've got a |PSIfour| compilation. Use it, then consult :ref:`plugins
      <sec:newplugins>`

    * I'd rather not compile |PSIfour| or I don't have compilers |w---w|
      :ref:`Goto Binary-Package <faq:binarypackage>` then consult
      :ref:`plugins through conda <sec:condaplugins>`

* I really like parentheses and/or DBOC, so I want Psi3. |w---w|
  Psi3 is available from `sourceforge <https://sourceforge.net/projects/psicode/files/psi/3.4.0/>`_, but you're on your own.

.. comment * I am a core |PSIfour| developer, yet I'm still taking this quiz.
.. comment 
.. comment   * I have minions whose Psi4 development work I want to supervise through this repository instance. Preferably, [Goto Fork-from-GitHub](#forkpsi4public); otherwise [Goto Fork-from-GitHub-Private](#forkpsi4private)
.. comment 
.. comment   * Just give me a repository to commit to directly. Preferably, [Goto Clone-from-GitHub](#clonepsi4public); otherwise [Goto Clone-from-GitHub-Private](#clonepsi4private)


.. _`faq:binary`:

Binary Installer
----------------

* **Get Initially**

  Just go to http://www.psicode.org/downloads.html, select "Installer",
  "Stable Release", and your choice of architecture and Python version,
  and follow the instructions there.

* **Build**

  Not applicable as binary is pre-built.

* **Get Updates** :ref:`directions <faq:updatepsi4>`

  .. code-block:: bash

     >>> conda update psi4

* **Contribute Back**

  Not applicable as not under git control.


.. _`faq:binarypackage`:

Conda Binary Package
--------------------

* **Get Initially**

  The pre-compiled conda packages at https://anaconda.org/psi4/psi4
  can be installed into an existing Anaconda or Miniconda distribution
  according to :ref:`directions <faq:psi4pkg>`. Locally, install into
  a conda environment as below.

  .. code-block:: bash

     >>> conda create -n p4env psi4 -c psi4
     >>> conda activate p4env

  .. code-block:: bash

     >>> # nightly build
     >>> conda create -n p4env psi4 -c psi4/label/dev
     >>> # Windows
     >>> conda create -n p4env psi4 -c psi4 -c conda-forge


* **Build**

  Not applicable as binary is pre-built.

* **Get Updates** :ref:`directions <faq:updatepsi4>`

  .. code-block:: bash

     >>> conda update psi4 -c psi4

* **Contribute Back**

  Not applicable as not under git control.


.. _`faq:clonepsi4public`:

Clone from GitHub Repository
----------------------------

* **Get Initially**

  The |PSIfour| repository at https://github.com/psi4/psi4 works like
  `every other GitHub repo
  <https://help.github.com/articles/which-remote-url-should-i-use/>`_.
  Locally, clone as below.

  .. code-block:: bash

     # use https or ssh
     >>> git clone https://github.com/psi4/psi4.git
     >>> cd psi4
     # this is your {top-level-psi4-dir}

* **Build** :ref:`directions <faq:buildquick>`

* **Get Updates**

  .. code-block:: bash

     # on branch master
     >>> git pull origin master

* **Contribute Back**

  Contributions cannot be made directly to the main repository. :ref:`Fork
  instead <faq:forkpsi4public>`.

  To convert clone to fork, go to https://github.com/psi4/psi4, and
  hit the `Fork <https://help.github.com/articles/fork-a-repo/>`_
  button to store a |PSIfour| repository in your GitHub account.

  .. code-block:: bash

     >>> git remote rename origin upstream
     >>> git remote add origin https://github.com/johndoe/psi4.git


.. _`faq:forkpsi4public`:

Fork from GitHub Repository
---------------------------

* **Get Initially**

  Go to https://github.com/psi4/psi4, and hit the `Fork
  <https://help.github.com/articles/fork-a-repo/>`_ button to store a
  |PSIfour| repository in your GitHub account. Locally, proceed to clone:

  .. code-block:: bash

     # replace johndoe
     # use https or ssh
     >>> git clone https://github.com/johndoe/psi4.git
     >>> cd psi4
     # this is your {top-level-psi4-dir}

  `Set up a connection
  <https://help.github.com/articles/configuring-a-remote-for-a-fork/>`_
  between your forked repository and the parent repository.

  .. code-block:: bash

     >>> git remote add upstream https://github.com/psi4/psi4.git

* **Build** :ref:`directions <faq:buildquick>`

* **Get Updates**

  Locally, `update your fork
  <https://help.github.com/articles/syncing-a-fork/>`_ from the parent
  repository and store on GitHub at your fork.

  .. code-block:: bash

     # on branch working_branch
     >>> git pull --rebase upstream master
     >>> git push origin working_branch

  Remember: Working in the master branch of a fork is considered bad practice.

* **Contribute Back**

  |PSIfour| contributions process :ref:`here <faq:githubworkflow>` and
  :source:`here <.github/CONTRIBUTING.md>`.
  Consider `preparing your contribution in a branch
  <http://blog.jasonmeridth.com/posts/do-not-issue-pull-requests-from-your-master-branch/>`_
  then issue a `GitHub pull request
  <https://help.github.com/articles/creating-a-pull-request/>`_.


.. _`faq:tarballpsi4public`:

Tarball from GitHub Repository
------------------------------

* **Get Initially**

  Discouraged! From the |PSIfour| repository at https://github.com/psi4/psi4, hit the
  "Clone or download" then "Download ZIP" button. Locally, unpack as
  below.

  .. code-block:: bash

     >>> unzip psi4-master.zip
     >>> cd psi4-master
     # this is your {top-level-psi4-dir}

* **Build** :ref:`directions <faq:buildquick>`

* **Get Updates**

  Download new tarball and rebuild.

* **Contribute Back**

  Not applicable as source not under git control.

.. _`faq:githubworkflow`:

What is the suggested GitHub workflow
-------------------------------------

.. image:: /prflow.001.jpeg
.. image:: /prflow.002.jpeg
.. image:: /prflow.003.jpeg
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; anharmonicity()

.. _`sec:anharmonicity()`:

Spectroscopic Constants for Diatomics
=====================================

.. codeauthor:: Andrew C. Simmonett

.. autofunction:: psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit)

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: CPPE, PE

.. _`sec:cppe`:

Interface to CPPE by M. Scheurer
=======================================

.. codeauthor:: Maximilian Scheurer
.. sectionauthor:: Maximilian Scheurer

*Module:* :ref:`Keywords <apdx:pe>`, :ref:`PSI Variables <apdx:pe_psivar>`

.. image:: https://img.shields.io/badge/home-cppe-informational.svg
   :target: https://github.com/maxscheurer/cppe

.. .. raw:: html
.. 
..    <br>
.. 
.. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
..    :target: http://pcmsolver.readthedocs.io/en/latest/

|PSIfour| contains code to interface to the CPPE library developed
by M. Scheurer.
The CPPE library requires no additional licence, downloads, or
configuration. The library allows for calculations in solution with the
polarizable embedding model (PE), an explicit, fragment-based solvent model [Olsen:2010:3721]_.

For a general tutorial on how to prepare/perform PE calculations, read the
`tutorial review <https://onlinelibrary.wiley.com/doi/full/10.1002/qua.25717>`_.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/cppe/badges/version.svg
     :target: https://anaconda.org/psi4/cppe

* CPPE is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, CPPE has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  CPPE can be obtained through ``conda install cppe -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_cppe`,
  hint its location with :makevar:`cppe_DIR`,
  and rebuild |PSIfour| to detect CPPE and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   cppe from conda without thinking, consult.

* To remove a conda installation, ``conda remove cppe``.

**Source**

* .. image:: https://img.shields.io/github/tag-date/maxscheurer/cppe.svg?maxAge=2592000
     :target: https://github.com/maxscheurer/cppe

* If using |PSIfour| built from source and you want CPPE built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_cppe`,
  and let the build system fetch and build it and activate dependent code.

.. index:: PE; Using PE

.. _`sec:usingPE`:

Using the polarizable embedding model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The inclusion of a PE description of the solvent into your calculation
is achieved by setting |globals__pe| ``true`` in your input file.

.. note:: At present, PE can only be used for energy calculations with SCF
          wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.
          All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported.

.. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available.

.. warning:: The CPPE library **cannot** exploit molecular point group symmetry.

.. .. warning:: Analytic gradients and Hessians **are not** available with PE. Finite differences will be used
..              regardless of the ``dertype`` passed to the ``optimize`` function.
..              See :srcsample:`pcmsolver/opt-fd` for a sample input.

.. The PCM model and molecular cavity are specified in a ``pcm`` section that has
.. to be explicitly typed in by the user. This additional section follows a syntax
.. that is slightly different from that of |Psifour| and is fully documented
.. `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_

A typical input for a Hartree--Fock calculation with PE would look like the following: ::

    molecule pna {
        C          8.64800        1.07500       -1.71100
        C          9.48200        0.43000       -0.80800
        C          9.39600        0.75000        0.53800
        C          8.48200        1.71200        0.99500
        C          7.65300        2.34500        0.05500
        C          7.73200        2.03100       -1.29200
        H         10.18300       -0.30900       -1.16400
        H         10.04400        0.25200        1.24700
        H          6.94200        3.08900        0.38900
        H          7.09700        2.51500       -2.01800
        N          8.40100        2.02500        2.32500
        N          8.73400        0.74100       -3.12900
        O          7.98000        1.33100       -3.90100
        O          9.55600       -0.11000       -3.46600
        H          7.74900        2.71100        2.65200
        H          8.99100        1.57500        2.99500
        symmetry c1
        no_reorient
        no_com
    }

    set {
     basis sto-3g
     pe true
     e_convergence 10
     d_convergence 10
     scf_type pk
    }

    set pe {
     potfile pna_6w.pot
    }

    scf_energy, wfn = energy('scf', return_wfn=True)


The corresponding potential file `pna_6w.pot` can be downloaded
`here <https://raw.githubusercontent.com/maxscheurer/cppe/master/tests/potfiles/pna_6w.pot>`_.

Keywords for CPPE
~~~~~~~~~~~~~~~~~

.. include:: autodir_options_c/globals__pe.rst
.. include:: autodir_options_c/pe__potfile.rst
.. include:: autodir_options_c/pe__isotropic_pol.rst
.. include:: autodir_options_c/pe__induced_convergence.rst
.. include:: autodir_options_c/pe__maxiter.rst
.. include:: autodir_options_c/pe__border.rst
.. include:: autodir_options_c/pe__border_type.rst
.. include:: autodir_options_c/pe__border_n_redist.rst
.. include:: autodir_options_c/pe__border_redist_order.rst
.. include:: autodir_options_c/pe__border_rmin.rst
.. include:: autodir_options_c/pe__border_rmin_unit.rst
.. include:: autodir_options_c/pe__border_redist_pol.rst


.. _`cmake:cppe`:

How to configure CPPE for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, CPPE is a library that provides additional
  quantum chemical capabilities (explicit solvation modeling).

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) CPPE

* Upstream Dependencies |w---w| CPPE

**CMake Variables**

* :makevar:`ENABLE_cppe` |w---w| CMake variable toggling whether Psi4 builds with CPPE
* :makevar:`cppe_DIR` |w---w| CMake variable to specify where pre-built CPPE can be found. Set to installation directory containing ``share/cmake/cppe/cppeConfig.cmake``

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_cppe=ON

B. Build *without* CPPE

  .. code-block:: bash

    >>> cmake

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:style_c`:

C++ Style
=========


.. _`faq:nullptr`:

Prefer ``nullptr`` to ``0`` or ``NULL``
---------------------------------------

``0`` is an ``int`` not a pointer. Almost the same goes for ``NULL``,
though implementations of the language can differ in the details. If you
want to overload on pointer types and/or use pointer types with templates,
use ``nullptr`` to signal the null pointer. The correct overload/template
parameter will then be deduced. Using ``nullptr`` also makes the code more
readable, especially if ``auto`` is used consistently throughout.

*Reference:* Item 8 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_


.. _`faq:automakeshared`:

Prefer ``std::make_shared`` to direct use of ``new``
----------------------------------------------------

Using ``std::make_shared``:

1. Reduces code verbosity, especially when coupled with ``auto``:

.. code-block:: cpp

    // Type information given 3 TIMES!!!
    std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix("Fock matrix", nso, nso));

    // So much typing...
    std::shared_ptr<Matrix> F = std::make_shared<Matrix>("Fock matrix", nso, nso);

    // Much better!!!!
    auto F = std::make_shared<Matrix>("Fock matrix", nso, nso);

2. Ensures exception safety and prevents resource leaks.

3. Improves efficiency:

.. code-block:: cpp

    // Performs TWO allocations
    std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix("Fock matrix", nso, nso));

    // Performs ONE allocation
    auto F = std::make_shared<Matrix>("Fock matrix", nso, nso);

*Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_


.. _`faq:autodecl`:

Prefer ``auto`` to explicit type declarations
---------------------------------------------

Using ``auto`` reduces and/or avoids:

1. Verbosity in variable declarations:

.. code-block:: cpp

    std::shared_ptr<Matrix> F = std::make_shared<Matrix>("Fock matrix", nso, nso);  // So much typing...
    auto F = std::make_shared<Matrix>("Fock matrix", nso, nso);  // Much better!

2. Problems with uninitialized variables. auto works like template type
   deduction, hence the right-hand side of the declaration needs to have an
   initializer:

.. code-block:: cpp

    int x1;  // fine, but uninitialized :(
    auto x2;  // WON'T COMPILE!!!
    auto x3 = 1;  // fine and initialized

3. Problems with unintended type casts and type mismatches that are hard
   to impossible to catch:

.. code-block:: cpp

    std::vector<int> v;
    // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT
    unsigned sz = v.size();  // might not be correct on some compiler/machines
    auto size = v.size();  // size is ALWAYS of the correct type

*Reference:* Items 2 and 5 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_

Mark virtual functions in derived classes with override
-------------------------------------------------------

The ``override`` keyword introduced in C++11 is used to mark a function in a
derived class and guarantee that it is overloading a function *with the same
signature* in the base class.  This behavior is `checked at compile time
<https://en.cppreference.com/w/cpp/language/override>`_.

.. _`faq:printmem`:

Prefer `GiB` for memory printing
--------------------------------

As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.
As it's what we're computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.
As it's a unit, put it in brackets.
Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing. ::

        outfile->Printf("  DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. ",
                        (required *  8 / (1024 * 1024 * 1024.0)),

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: CC, coupled cluster
   pair: CC; theory

.. _`sec:cc`:

CC: Coupled Cluster Theory
==========================

.. codeauthor:: T. Daniel Crawford
.. sectionauthor:: T. Daniel Crawford

*Module:* :ref:`PSI Variables <apdx:ccenergy_psivar>`

*Module:* :ref:`Keywords <apdx:ccenergy>`, :source:`CCENERGY <psi4/src/psi4/cc/ccenergy>`

*Module:* :ref:`Keywords <apdx:cceom>`, :source:`CCEOM <psi4/src/psi4/cc/cceom>`

*Module:* :ref:`Keywords <apdx:ccresponse>`, :source:`CCRESPONSE <psi4/src/psi4/cc/ccresponse>`

*Module:* :ref:`Keywords <apdx:cctriples>`, :source:`CCTRIPLES <psi4/src/psi4/cc/cctriples>`

*Module:* :ref:`Keywords <apdx:ccdensity>`, :source:`CCDENSITY <psi4/src/psi4/cc/ccdensity>`

*Module:* :ref:`Keywords <apdx:cchbar>`, :source:`CCHBAR <psi4/src/psi4/cc/cchbar>`

*Module:* :ref:`Keywords <apdx:cclambda>`, :source:`CCLAMBDA <psi4/src/psi4/cc/cclambda>`

The coupled cluster approach is one of the most accurate and reliable quantum
chemical techniques for including the effects of electron correlation.
Instead of the linear expansion of the wavefunction used by configuration
interaction, coupled cluster uses an exponential expansion,

.. math::
   :label: CCexpansion

   | \Psi \rangle &= e^{\hat{T}} | \Phi_0 \rangle \\
                  &= \left( 1 + {\hat{T}} + \frac{1}{2} {\hat{T}}^2 + \frac{1}{3!}{\hat{T}}^3 + \cdots \right) | \Phi_0 \rangle,

where the cluster operator :math:`{\hat{T}}` is written as a sum of operators that
generate singly-excited, doubly-excited, *etc.*, determinants:

.. math:: {\hat{T}} = {\hat{T}_1} + {\hat{T}_2} + {\hat{T}_3} + \cdots + {\hat{T}_N},

with

.. math::

   {\hat T}_1 | \Phi_0 \rangle &= \sum_{i}^{\rm occ} \sum_a^{\rm vir} t_i^a | \Phi_i^a \rangle \\
   {\hat T}_2 | \Phi_0 \rangle &= \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} t_{ij}^{ab} | \Phi_{ij}^{ab} \rangle,

*etc.*  The popular coupled cluster singles and doubles (CCSD) model
[Purvis:1982]_ truncates the expansion at :math:`{\hat{T}} = {\hat{T}_1}
+ {\hat{T}_2}`.  This model has the same number of parameters as
configuration interaction singles and doubles (CISD) but improves upon
it by approximately accounting for higher-order terms using products
of lower-order terms (*e.g.*, the term :math:`{\hat{T}_2}^2` approximately
accounts for quadruple excitations).  The inclusion of such products
makes coupled-cluster methods *size extensive*, meaning that the
quality of the computation should not degrade for larger molecules.
The computational cost for CCSD scales as :math:`{\cal{O}}(o^2 v^4)`, where
:math:`o` is the number of occupied orbitals and :math:`v` is the number of virtual
orbitals.

Improving upon CCSD, the CCSD(T) method [Raghavachari:1989]_ includes
a perturbative estimate of the energy contributed by the :math:`{\hat{T}_3}`
operator.  The computational cost of this additional term scales as
:math:`{\cal{O}}(o^3 v^4)`, making it rather expensive for molecules with more than
a dozen heavy atoms or so.  However, when this method is affordable, it
provides very high quality results in most cases.

|PSIfour| is capable of computing energies and analytic gradients for a
number of coupled cluster models.  It can also compute linear response
properties (such as static or frequency-dependent polarizability,
or optical rotation angles) for some models.  Excited states can
also be computed by the CC2 and CC3 models, or by EOM-CCSD.  Table
:ref:`CC Methods <table:ccsummary>` summarizes these capabilities.  This section
describes how to carry out coupled cluster calculations within |PSIfour|.
For higher-order coupled-cluster methods like CCSDT and CCSDTQ, |PSIfour|
can interface to K\ |a_acute|\ llay's MRCC code (see :ref:`MRCC <sec:mrcc>`).

Solvent effects on energies can be taken into account using the polarizable
continuum model (PCM) in the PTE approximation [Cammi:2009:164104]_, see
:ref:`PCM <sec:pcmsolver>`

.. _`table:ccsummary`:

.. table:: Current coupled cluster capabilities of |PSIfour|

   +------------------+------------+-----------+-----------+---------------+-----------+
   | Method           | Reference  | Energy    | Gradient  | Exc. Energies | LR Props  |
   +==================+============+===========+===========+===============+===========+
   | CC2              | RHF        | Y         | Y         | Y             | Y         |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | UHF        | Y         | ---       | N             | ---       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | ROHF       | Y         | ---       | N             | ---       |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | CCSD             | RHF        | Y         | Y         | Y             | Y         |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | UHF        | Y         | Y         | Y             | ---       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | ROHF       | Y         | Y         | Y             | ---       |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | CCSD(T)          | RHF        | Y         | Y         | n/a           | n/a       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | UHF        | Y         | Y         | n/a           | n/a       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | ROHF       | Y         | ---       | n/a           | n/a       |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | A-CCSD(T) [#f1]_ | RHF        | Y         | ---       | n/a           | n/a       |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | CC3              | RHF        | Y         | ---       | Y             | ---       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | UHF        | Y         | ---       | Y             | ---       |
   +                  +------------+-----------+-----------+---------------+-----------+
   |                  | ROHF       | Y         | ---       | Y             | ---       |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | CCD              | Brueckner  | Y         | N         | N             | N         |
   +------------------+------------+-----------+-----------+---------------+-----------+
   | CCD(T)           | Brueckner  | Y         | N         | n/a           | n/a       |
   +------------------+------------+-----------+-----------+---------------+-----------+

.. rubric:: Footnotes

.. [#f1] Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L

The following wavefunctions are currently recognized by |PSIfour| as arguments
to functions like :py:func:`~psi4.energy`: ``'ccsd'``, ``'ccsd(t)'``, ``'a-ccsd(t)'``, ``'cc2'``,
``'cc3'``, ``'bccd'`` (CCD with Brueckner orbitals), ``'bccd(t)'`` (CCD(T) with
Brueckner orbitals), ``'eom-ccsd'``, ``'eom-cc2'`` (CC2 for excited states),
``'eom-cc3'`` (CC3 for excited states).  Response properties can be obtained
by calling the function :py:func:`~psi4.properties` (instead of, for example, :py:func:`~psi4.energy`,
*e.g.*, ``properties('ccsd')``.  There are many sample
coupled cluster inputs provided in :source:`samples`.

Basic Keywords
^^^^^^^^^^^^^^

A complete list of keywords related to coupled-cluster computations is
provided in the appendices, with the majority of the relevant
keywords appearing in Appendix :ref:`apdx:ccenergy`.  For a standard ground-state
CCSD or CCSD(T) computation, the following keywords are common:

.. include:: autodir_options_c/ccenergy__reference.rst
.. include:: autodir_options_c/ccenergy__r_convergence.rst
.. include:: autodir_options_c/ccenergy__maxiter.rst
.. include:: autodir_options_c/ccenergy__brueckner_orbs_r_convergence.rst
.. include:: autodir_options_c/ccenergy__restart.rst
.. include:: autodir_options_c/ccenergy__cachelevel.rst
.. include:: autodir_options_c/ccenergy__cachetype.rst
.. include:: autodir_options_c/ccenergy__num_amps_print.rst
.. include:: autodir_options_c/ccenergy__mp2_amps_print.rst

Larger Calculations
^^^^^^^^^^^^^^^^^^^

Here are a few recommendations for carrying out large-basis-set coupled
cluster calculations with |PSIfour|:

* In most cases it is reasonable to set the ``memory`` keyword to 90% of
  the available physical memory, at most.  There is a small amount of overhead
  associated with the
  coupled cluster modules that is not accounted for by the internal CC memory
  handling routines.  Thus, the user should *not* specify the entire
  physical memory of the system, or swapping is likely.  However, for especially large
  calculations, it is better to set the ``memory`` keyword to a value less than 16 GB.

* Set the |ccenergy__cachelevel| keyword to ``0``.
  This will turn off cacheing, which, for very large calculations, can
  lead to heap fragmentation and memory faults, even when sufficient
  physical memory exists.

* Set the |globals__print| keyword to ``2``.  This
  will help narrow where memory bottlenecks or other errors exist in the
  event of a crash.

.. _`sec:eomcc`:

Excited State Coupled Cluster Calculations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A complete list of keywords related to
coupled cluster linear response is provided in Appendix :ref:`apdx:cceom`.
The most important keywords associated with EOM-CC calculations are:

.. include:: autodir_options_c/cceom__roots_per_irrep.rst
.. include:: autodir_options_c/cceom__e_convergence.rst
.. include:: autodir_options_c/cceom__singles_print.rst
.. include:: autodir_options_c/cceom__schmidt_add_residual_tolerance.rst
.. include:: autodir_options_c/cceom__eom_guess.rst

Linear Response (CCLR) Calculations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Linear response computations are invoked like ``properties('ccsd')``
or ``properties('cc2')``, along with a list of requested properties.
A complete list of keywords related to
coupled cluster linear response is provided in Appendix :ref:`apdx:ccresponse`.

The most important keywords associated with CC-LR calculations are as follows.

.. include:: autodir_options_c/ccresponse__property.rst
.. include:: autodir_options_c/ccresponse__omega.rst
.. include:: autodir_options_c/ccresponse__gauge.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   pair: plugin; v2rdm_casscf

.. _`sec:v2rdm_casscf`:

Plugin v2rdm_casscf by A. E. DePrince
=====================================

.. codeauthor:: A. E. DePrince
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`

.. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg
   :target: https://github.com/edeprince3/v2rdm_casscf

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md

A variational 2-RDM-driven CASSCF plugin to |PSIfour|

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg
     :target: https://anaconda.org/psi4/v2rdm_casscf

* v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the Psi4conda installer, v2rdm_casscf has already been installed alongside.

* If using the |PSIfour| conda package, the v2rdm_casscf conda package can
  be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install
  psi4-rt -c psi4``.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.
  Then, hint its location with :envvar:`PYTHONPATH`.

* To remove a conda installation, ``conda remove v2rdm_casscf``.

**Source**

* .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000
     :target: https://github.com/edeprince3/v2rdm_casscf

* If using |PSIfour| built from source and you want v2rdm_casscf built from
  from source also,
  build it, then hint its location with :envvar:`PYTHONPATH`.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: DF-MP2
   pair: MP2; density-fitting

.. _`sec:dfmp2`:

DF-MP2: Density-Fitted 2nd-Order |MollerPlesset| Perturbation Theory
====================================================================

.. codeauthor:: Robert M. Parrish
.. sectionauthor:: Robert M. Parrish

*Module:* :ref:`Keywords <apdx:dfmp2>`, :ref:`PSI Variables <apdx:dfmp2_psivar>`, :source:`DFMP2 <psi4/src/psi4/dfmp2>`

Introduction
------------

Second-order |MollerPlesset| Perturbation Theory (MP2) occupies a unique role
in quantum chemistry due to its small-prefactor :math:`{\cal O}(N^5)` treatment of
dynamic electron correlation. This unusually cheap
*ab initio* treatment of electron correlation may be made even more
efficient by means of the Density-Fitting (DF) approximation (also known as
Resolution-of-the-Identity or RI), wherein the quadratic :math:`ov` products in the
bra- and ket- of the :math:`(ov|ov)`\ -type Electron Repulsion Integrals (ERIs)
appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares
fitting.  Substitution of the DF factorization into the MP2 equations results in
a formal scaling and prefactor reduction of MP2, and further speed gains are
possible due to heavy utilization of matrix-multiplication kernels and minimal
storage requirements in a DF approach. The method has been found to be quite
robust and accurate, and it should be preferred unless extreme accuracy is required
or a fitting basis is not defined for the primary basis and atom type
encountered. In particular, we have found excellent efficiency and tractability
gains when using DF-MP2 in concert with a DF-SCF reference.  An efficient,
threaded, disk-based DF-MP2 code is available in |PSIfour| for all single
reference types available in the SCF module.
MP2 defaults in |PSIfour| to the density-fitted code. See
|globals__mp2_type| for performing a MP2 with conventional integrals.

An example utilization of the code is::

   molecule h2o {
   0 1
   O
   H 1 1.0
   H 1 1.0 2 104.5
   }
   
   set basis cc-pvdz
   set scf_type df
   set freeze_core True
   
   energy('mp2')

The ``energy('mp2')`` call to :py:func:`~psi4.energy` executes
the predefined DF-MP2 procedure, first calling
the SCF module with a default RHF reference and DF algorithm for the
two-electron integrals. When the orbitals are converged, the DF-MP2 module is
launched, which forms the density-fitted :math:`(Q|ov)` integrals and then builds the
full :math:`(ov|ov)` tensor in blocks, evaluating the contributions to the MP2 energy
as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF
reference. In this example, we freeze the core, both for efficiency and
because split-valence bases like cc-pVDZ do not contain core correlation
functions. The result looks something like::

        -----------------------------------------------------------
         ==================> DF-MP2 Energies <====================
        -----------------------------------------------------------
         Reference Energy          =     -76.0213974638823942 [Eh]
         Singles Energy            =      -0.0000000000000001 [Eh]
         Same-Spin Energy          =      -0.0512503270216563 [Eh]
         Opposite-Spin Energy      =      -0.1534098175176923 [Eh]
         Correlation Energy        =      -0.2046601445393486 [Eh]
         Total Energy              =     -76.2260576084217405 [Eh]
        -----------------------------------------------------------
         ================> DF-SCS-MP2 Energies <==================
        -----------------------------------------------------------
         SCS Same-Spin Scale       =       0.3333333333333333 [-]
         SCS Opposite-Spin Scale   =       1.2000000000000000 [-]
         SCS Same-Spin Energy      =      -0.0170834423405521 [Eh]
         SCS Opposite-Spin Energy  =      -0.1840917810212307 [Eh]
         SCS Correlation Energy    =      -0.2011752233617829 [Eh]
         SCS Total Energy          =     -76.2225726872441811 [Eh]
        -----------------------------------------------------------

The theory, breakdown of results, and common keywords used in DF-MP2 are presented below. 

.. index::
   pair: DF-MP2; theory

Theory
------

|MollerPlesset| Theory (MPn) or Many-Body Perturbation Theory
(MBPT) through second order has the spin-orbital formula:

.. math:: E_{\mathrm{total}}^{(2)} = E_{\mathrm{Reference}} - 
   \frac{f_{ia} f_{ia}}{\epsilon_a - \epsilon_i} - 
   \frac{1}{4} \frac{\langle ij||ab\rangle^2}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}
   :label: MP2

Here :math:`i` and :math:`j` are occupied spin orbitals, :math:`a` and
:math:`b` are virtual spin orbitals, :math:`f_{ia}` are the :math:`ov`
Fock Matrix elements, :math:`\epsilon` are the orbital eigenvalues, and
:math:`\langle ij||ab\rangle` are the antisymmetrized physicist's ERIs.
For converged RHF and UHF references, the singles correction,

.. math:: E_{\mathrm{MBPT}}^{(1)} = - \frac{f_{ia} f_{ia}}{\epsilon_a - \epsilon_i},

is zero due to the Brillioun Condition, and the first contribution to the
perturbation series is at the second order:

.. math:: E_{\mathrm{MBPT}}^{(2)} = - \frac{1}{4} \frac{\langle ij|ab\rangle^2}{\epsilon_a + 
   \epsilon_b - \epsilon_i - \epsilon_j}.

In the DFMP2 module, the first-order contribution, or "singles energy" is
always evaluated. This term is a significant contributor to the total
second-order energy if a ROHF reference is used. In this case, we have chosen
to use the ROHF-MBPT(2) ansatz, in which the ROHF orbitals are
semicanonicalized, the resultant nonzero Fock matrix elements :math:`f_{ia}` are used
to form the singles amplitudes, and then the second-order amplitudes are formed
with the semicanonical spin orbitals via the same machinery as a UHF-MP2. Note
that the singles energy should be very close to zero for RHF and UHF references;
if it is not, there is a good chance your orbitals are not well converged.
Tighten the SCF |scf__e_convergence| and/or |scf__d_convergence| keywords
and try again. 

To increase the efficiency of MP2 energy evaluation, spin integration
and simplification is carried out. This also allows for the identification of
Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme's Spin-Component
Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are
(note that the integrals are now chemist's integrals over spatial orbitals)

.. math:: E_{\mathrm{MBPT,OS}}^{(2)} = 
   - \frac{(ia|jb)(ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}

and 

.. math:: E_{\mathrm{MBPT,SS}}^{(2)} = 
   - \frac{[(ia|jb)-(ib|ja)](ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.

For UHF-MP2 (also labeled as UMP2) and the second-order contribution to
ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are

.. math:: E_{\mathrm{MBPT,OS}}^{(2)} = 
   - \frac{(ia^\alpha|jb^\beta)(ia^\alpha|jb^\beta)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}

and 

.. math:: E_{\mathrm{MBPT,SS}}^{(2)} = 
   - \frac{1}{2}\frac{[(ia^\alpha|jb^\alpha)-(ib^\alpha|ja^\alpha)](ia^\alpha|jb^\alpha)}
   {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}
   - \frac{1}{2}\frac{[(ia^\beta|jb^\beta)-(ib^\beta|ja^\beta)](ia^\beta|jb^\beta)}
   {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.

Note that the UHF-MP2 equations use three classes of integrals, while the
RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or
ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2
energy.

Recommendations
---------------

All-in-all, DFMP2 should be a simple module to use, with few keywords (fully
documented in the Appendix :ref:`apdx:dfmp2`). Some basic recommendations are included below:

* DFMP2 should be run with the :math:`ov`-type RI or MP2FIT auxiliary
  basis sets, *not* the -JKFIT basis sets. The automatic basis selector
  should work fine for most all bases (exceptions are less common elements
  at higher than quadruple-zeta). Generally, it is always better to specify
  only the orbital basis set and let the auxiliary bases be chosen
  automatically. If you want to specify manually, use the
  |dfmp2__df_basis_mp2| keyword.

* DFMP2 likes memory. At a minimum, :math:`2Q^2` doubles are required,
  where :math:`Q` is the size of the auxiliary basis set. However, there is
  one disk transpose of the :math:`(Q|ov)` tensor in the RHF-MP2 algorithm
  [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.
  If you notice DFMP2 using more memory than allowed, it is possible that
  the threaded three-index ERI computers are using too much overhead memory.
  Set the |dfmp2__DF_ints_num_threads| to a smaller number to prevent this
  in this section (does not affect threaded efficiency in the rest of the
  code).

* DFMP2 likes disk. At a minimum, :math:`2Qov` doubles are required for
  RHF-MP2, and :math:`4Qov` doubles are required for UHF-MP2.

* DFMP2 likes threads. Some of the formation of the :math:`(Q|ov)` tensor
  relies on threaded BLAS (such as MKL) for efficiency. The main
  :math:`{\cal O}(N^5)` step is done via small/medium-sized DGEMMs inside of
  OpenMP, so make sure to set the :envvar:`OMP_NESTED` environment variable
  to ``FALSE`` to prevent thread thrash (or just as well, do not define
  :envvar:`OMP_NESTED` at all).

* Freezing core is good for both efficiency and correctness purposes.
  Freezing virtuals is not recommended. The DFMP2 module will remind you how
  many frozen/active orbitals it is using in a section just below the title.

* ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from
  severe spin contamination in some cases.

* MP2 is not suitable for systems with multireference character. The
  orbital energies will come together and an explosion will occur. 

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. _`sec:methods`:

===============================
Theoretical Methods: SCF to FCI
===============================

Several electronic structure methods are available in the |PSIfour|
package, from Hartree--Fock molecular orbital theory to coupled-cluster
theory to full configuration interaction.  This section introduces
the methods available and some of their most common input parameters.
A complete list of standard keywords is provided in Appendix
:ref:`apdx:options_c_module`.

.. toctree::
   :maxdepth: 2

   notes_c
   scf
   dft
   dftnl
   dct
   dfmp2
   dlpnomp2
   cc
   fnocc
   occ
   psimrcc
   detci
   mcscf
   sapt
   fisapt
   adc
   relativistic
   optking
   oeprop
   thermo
   tdscf
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:style_python`:

Python Style
============




.. _`faq:ignoringadvice`:

How to Ignore the Bots
----------------------

Formatting and analysis bots are great because it takes more effort
to defy them than to accept their criticism. Nevertheless, for code
clarity, they can be honestly wrong, so we need a way to specifically
clear their findings.

* Py Formatting (yapf) ``# yapf: disable`` (single line or block)  ``# yapf: enable`` (resume)

* C++ Formatting (clang-format)  ``// clang-format off`` (single line or block) ``// clang-format on`` (resume)

* Py Dynamic Analysis (coverage.py)  ``# pragma: no cover``

* C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested

* Py Static Analysis (lgtm) ``# lgtm[py/not-named-self]`` (click on the "?" to get the "Query ID")

* C++ Static Analysis (lgtm) ``// lgtm[cpp/wrong-type-format-argument]`` (click on the "?" to get the "Query ID")


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: ERD
.. _`sec:erd`:

Interface to ERD by N. Flocke and V. Lotrich
============================================

.. codeauthor:: Andrew C. Simmonett and Benjamin P. Pritchard
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:dkh>`, :ref:`Samples <apdx:testSuitedkh>`

.. image:: https://img.shields.io/badge/home-erd-5077AB.svg
   :target: https://github.com/psi4/erd

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://onlinelibrary.wiley.com/doi/10.1002/jcc.21018/abstract

.. _`sec:erdinstall`:

These are the AcesIII electron repulsion integrals that have
been partially interfaced into libmints. Enabling erd and adding
``set integral_package erd`` (do this in ``~/.psi4rc`` for universal
effect) runs libderiv from Libint for derivative integrals and erd for
non-derivative integrals.

.. warning:: The interface between erd and libderiv is not fully
   debugged. So analytic gradients, particularly density-fitted ones,
   are wrong, as are ESP calculations and some energies for long-range
   corrected ("omega") functionals. Insofar as faulty answers are
   anticipated with |globals__integral_package| ``erd``, |PSIfour| will
   throw an error if you try to execute that class of computation. But
   there may be more, so use with caution.

.. warning:: erd seems to be having some problems with Intel 2018 compilers. presently disabled in conda package.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/erd/badges/version.svg
     :target: https://anaconda.org/psi4/erd

* ERD is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

.. * If using the |PSIfour| binary, erd has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  erd can be obtained through ``conda install erd -c psi4``.
  Then enable it as a feature with :makevar:`ENABLE_erd`,
  hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect erd and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use
..   erd from conda without thinking, consult.

* To remove a conda installation, ``conda remove erd``.

**Source**

* .. image:: https://img.shields.io/github/tag/psi4/erd.svg?maxAge=2592000
     :target: https://github.com/psi4/erd

* If using |PSIfour| built from source and you want erd built from
  from source also,
  enable it as a feature with :makevar:`ENABLE_erd`,
  and let the build system fetch and build it and activate dependent code.

.. .. _`sec:erdinput`:

.. _`cmake:erd`:

How to configure erd for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, ERD is a library that provides alternate
  integrals.

* Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) erd

* Upstream Dependencies |w---w| erd |dr| Fortran

**CMake Variables**

* :makevar:`ENABLE_erd` |w---w| CMake variable toggling whether |PSIfour| builds with erd
* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing ``include/ERD/ERD_MANGLE.h``
* :makevar:`erd_DIR` |w---w| CMake variable to specify where pre-built erd can be found. Set to installation directory containing ``share/cmake/erd/erdConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_erd` |w---w| CMake variable to force internal build of erd instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_erd` |w---w| CMake variable to force detecting pre-built erd and not falling back on internal build

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake -DENABLE_erd=ON

B. Build *without* erd

  .. code-block:: bash

    >>> cmake

C. Link against pre-built

  .. code-block:: bash

    >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root

  .. code-block:: bash

    >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir

D. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: SNS-MP2

.. _`sec:snsmp2`:

Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw
===============================================

.. codeauthor:: D. E. Shaw Research
.. sectionauthor:: Shannon E. Houck

.. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg
   :target: https://github.com/DEShawResearch/sns-mp2

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md

This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon 
et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to 
improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.
The plugin is distributed under the 2-clause BSD license.

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg
     :target: https://anaconda.org/psi4/snsmp2

* snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the Psi4conda installer, snsmp2 has already been installed alongside.

* If using the |PSIfour| conda package, the snsmp2 conda package can
  be obtained through ``conda install snsmp2 -c psi4`` or ``conda install
  psi4-rt -c psi4``.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.
  Then, hint its location with :envvar:`PYTHONPATH`.

* To remove a conda installation, ``conda remove snsmp2``.

**Source**

* .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000
   :target: https://github.com/DEShawResearch/sns-mp2

* Download the plugin from the GitHub repository:

  .. code-block:: bash

     >>> git clone https://github.com/DEShawResearch/sns-mp2

* Once dowloaded, the plugin can be installed as outlined in the documentation:

  .. code-block:: bash

     >>> cd {top-level-sns-mp2-directory}
     >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//')
     >>> $PSI4_PYTHON -m pip install .

Sample Input
~~~~~~~~~~~~

A sample input file, adapted from the documentation, is shown below::

   # Sample SNS-MP2 calculation for two helium atoms

   molecule dimer {
   He 0 0 0
   --
   He 2 0 0
   }

   energy('sns-mp2')
    
Note that the two monomers are separated by double dashes, indicating that
they should be treated as separate molecules. (See 
:ref:`sec:tutorial_tu5` for more details on
setting up dimer molecules.) This input file can be run in the usual fashion:

.. code-block:: bash

   >>> psi4 input.dat


.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst


Release Procedures
==================


.. _`faq:annualprocedure`:

Annual
------

* `Update copyright year`_


.. _`faq:prereleaseprocedure`:

Pre-Release (e.g., ``v1.3rc1``)
-------------------------------

* `Update samples`_
* `Collect new authors`_
* `Anticipate next release`_
* `Build Conda ecosystem stack`_
* `Tag (pre)release`_
* `Build Conda Psi4 stack at specific commit`_
* `Build Psi4conda set`_
* `Generate download page for psicode.org`_
* `Reset psi4meta for nightly operation`_


.. _`faq:releaseprocedure`:

Release (e.g., ``v1.3``)
------------------------

* `Do final pass before release tag`_
* `Tag (pre)release`_
* `Initialize release branch`_
* `Build Conda Psi4 stack at specific commit`_
* `Publish to main conda label`_
* `Build Psi4conda set`_
* `Generate download page for psicode.org`_
* `Collect documentation snapshot`_
* `Publish GitHub release`_
* `Publish psicode release`_
* `Finalize release`_
* `Reset psi4meta for nightly operation`_


.. _`faq:postreleaseprocedure`:

Post-Release (e.g., ``v1.3.1``)
-------------------------------

* `Assemble postrelease changes`_
* `Tweak Conda for postrelease`_
* `Do final pass before release tag`_
* `Tag postrelease`_
* `Build Conda Psi4 stack at specific commit`_
* `Publish to main conda label`_
* `Build Psi4conda set`_
* `Generate download page for psicode.org`_
* `Collect documentation snapshot`_
* `Publish GitHub postrelease`_
* `Publish psicode release`_
* `Finalize release`_
* `Reset psi4meta for nightly operation`_


Update copyright year
---------------------

* ``cd ~/path/to/psi4``
* Primary target is licenses

  - ``grep -rl "(c) 2007-2017" * | xargs sed -i '' "s/(c) 2007-2017/(c) 2007-2018/g"``
  - On Linux, drop the ``''`` in above command
  - Need to do ``psi4/`` and ``docs/`` dirs

* Also, license in these files

  - ``tests/runtest.py``
  - ``README.md``
  - ``tests/psitest.pl``

* Also, in content of :source:`doc/sphinxman/source/conf.py.in#L130`


Update samples
--------------

* Run ``make sphinxman`` at least once by hand
* Check in resulting ``psifiles.py`` and all the updated and new ``samples/`` files and dirs
* Make a lone PR and warn reviewers not to read it, since autogenerated


Collect new authors
-------------------

* Survey contributions to current Milestone. Add new contribs and PR lists to release notes GitHub issue
* Figure out any new "Additional Contributors" authors since last release
* Edit ``psi4/header.py`` accordingly, make PR
* Get permission of new authors and their particulars for ``codemeta.json``
* Invite any contributors with at least 3 PRs to join GitHub Organization


Anticipate next release
-----------------------

* Bump version in ``codemeta.json``, :source:`codemeta.json#L9`
* Add to branch list in ``azure-pipelines.yml``, :source:`azure-pipelines.yml`


Build Conda ecosystem stack
---------------------------

By "ecosystem stack", mean packages that are upstream, downstream, required, and optional for a fully featured Psi4 build and which we can't get from "defaults" or "conda-forge" channels.

* Main directions are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py)
* A couple weeks before the first "rc" is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes
* When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ``ltrtver`` with updated version numbers and/or build numbers (only if code changes)
* Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream
* Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream
* Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes
* Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes
* Results of last should upload to psicode.org (docs) and codecov.io (coverage)
* Changes to targets' "source" and "version" in individual recipes should be edited in psi4 ``external/*/*/CMakeLists.txt`` files
* Once everything's working on Linux, repeat on Mac
* At this point, ready to fine-tune builds of "Psi4 stack"


Assemble postrelease changes
----------------------------

* Collect PRs with "backport" label, and request other backport suggestions on upcoming RN issue
* Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files
* Do the draft parts of `Publish GitHub postrelease`_
* Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds)
* Note that while can't change maintenance branch's history, can push to it directly on upstream
* If want to do trial conda builds, requires ``source/git_tag: 1.3.x`` and fake ``package/version: v1.3.1rc1``


Tweak Conda for postrelease
---------------------------

* In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones

  - comment out any dependencies in master but not yet in postrelease
  - add ``{{ dep_bld }}`` entries if needed to step back build. make sure normal operation is ``''``

* In cbcy,

  - create a postrelease new line and record anything not in continuous order with <> or blanking
  - step back any dependencies versions or build numbers to ones compatible with the postrelease


Do final pass before release tag
--------------------------------

* Check that :source:`external/` repos and commits have been updated to match conda recipes sources. Also check versions with ``conda_build_config.yaml``
* Check :source:`doc/sphinxman/source/introduction.rst` for any compiler and Python minimum requirements to edit.


Tag (pre)release
----------------

* Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version
* Below is tl;dr

  ::

    # be on clean master up-to-date with upstream in both commits and tags
    # * mind which version strings get "v" and which don't
    # * if not fork, replace "upstream" with "origin"

    >>> vi psi4/metadata.py
    >>> git diff
    diff --git a/psi4/metadata.py b/psi4/metadata.py
    ...
    -__version__ = '1.3rc1'
    -__version_long = '1.3rc1+5a7522a'
    -__version_upcoming_annotated_v_tag = '1.3rc2'
    +__version__ = '1.3rc2'
    +__version_long = '1.3rc2+zzzzzzz'
    +__version_upcoming_annotated_v_tag = '1.3rc3'

    >>> git add psi4/metadata.py
    >>> git commit -m "v1.3rc2"
    [master bc8d7f5] v1.3rc2

    >>> git log --oneline | head -1
    bc8d7f5 v1.3rc2
    >>> git tag -a v1.3rc2 bc8d7f5 -m "v1.3rc2"

    # pause here and push to upstream and let Azure complete if want an
    #       on-tag Windows conda package, not just tag+1.dev1
    #       below pushes commit and tag together so only one CI
    #       > git push --atomic upstream master v1.5
    #       also, grab the docs build from GHA artifacts

    >>> vi psi4/metadata.py
    >>> git diff
    diff --git a/psi4/metadata.py b/psi4/metadata.py
    ...
    -__version_long = '1.3rc2+zzzzzzz'
    +__version_long = '1.3rc2+bc8d7f5'

    >>> git add psi4/metadata.py
    >>> git commit -m "Records tag for v1.3rc2"
    [master 16dbd3e] Records tag for v1.3rc2

    # goto GH:psi4/psi4 > Settings > Branches > master > Edit
    #      https://github.com/psi4/psi4/settings/branch_protection_rules/424295
    # uncheck "Include administrators" and Save changes

    >>> git push upstream master
    >>> git push upstream v1.3rc2

    # re-engage "Include administrators" protections


Tag postrelease
---------------

  ::

    # be on clean maintenance branch up-to-date with upstream in both commits and tags
    # * mind which version strings get "v" and which don't
    # * if not fork, replace "upstream" with "origin"

    >>> git checkout 1.3.x
    Switched to branch '1.3.x'

    >>> vi psi4/metadata.py
    >>> git diff
    diff --git a/psi4/metadata.py b/psi4/metadata.py
    ...
    -__version__ = '1.3'
    -__version_long = '1.3+zzzzzzz'
    +__version__ = '1.3.1'
    +__version_long = '1.3.1+zzzzzzz'

    >>> git add psi4/metadata.py
    >>> git commit -m "v1.3.1"
    [1.3.x 2ce1c29] v1.3.1

    >>> git log --oneline | head -1
    786fb2b v1.3.1
    >>> git tag -a v1.3.1 2ce1c29 -m "v1.3.1"

    # skipping the hash recording and "upcoming" step b/c only tags matter on maintenance branch

    # free pushing to maintenance branches at present so GitHub interface steps not needed
    # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit
    #      https://github.com/psi4/psi4/settings/branch_protection_rules/4385008  # !Varies!
    # uncheck "Include administrators" and Save changes

    >>> git push upstream 1.3.x
    >>> git push upstream v1.3.1

    # re-engage "Include administrators" protections


Initialize release branch
-------------------------

* follow tagging procedure
* before re-engaing the "include admin" button, push a branch at the tag commit (not the records commit)

  ::

    >>> git log --online | head -2
    45315cb Records tag for v1.3
    20e5c7e v1.3

    >>> git checkout 20e5c7e
    >>> git checkout -b 1.3.x
    Switched to a new branch '1.3.x'
    >>> git push upstream 1.3.x

* set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule.


Build Conda Psi4 stack at specific commit
-----------------------------------------

By "Psi4 stack", mean packages ``psi4``, ``psi4-rt``, ``psi4-dev``.
Package ``psi4-docs`` used to be in "Psi4 stack", but it's handled by GHA and netlify now, not Conda, so skip directions below.
Other packages, the "ecosystem stack" (e.g., ``libint``, ``v2rdm_casscf``) should be already built.

* Check poodle for stray channels that may have crept in for dependencies (like c-f for ACS season). Copy over new dependencies if needed to psi4 channel
* Particularly before release (not prerelease), consider max pinnings on dependencies, particularly any fast-moving dependencies (e.g., qcel) and whether they need version space to grow compatibly and grow incompatibly.
* Nightly conda-builds work from ``master`` psi4. (Postrelease "practice" works from ``1.N.x`` psi4.)

  - Instead, switch ``source/git_tag`` from ``master`` to tag (e.g., ``v1.3rc1``) in:

    * psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10
    * psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L

  - In cbcy, edit ``psi4ver`` to "v"-less tag

* For releases and postreleases (not prereleases), in ``conda_build_config.yaml``, edit ``ltrtver`` to a new non-dev label (probably a ditto) matching the release (e.g., "1.3")
* Set ``kitandkapoodle.py`` to the normal ``***`` stack. Should be (``psi4``, ``psi4-rt``, ``psi4-dev``) * python_versions for Linux & Mac. Also single ``psi4-docs``     from Linux
* Run ``kitandkapoodle.py`` and allow stack to upload to anaconda.org to ``psi4/label/dev``. Poodle emits with ``--label dev`` so will go to the subchannel. May need to delete packages to clear out space on anaconda.org
* Copy ``meta.yaml`` and ``build.sh`` of at least ``psi4-multiout`` and ``psi4-rt`` to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change.


Publish to main conda label
---------------------------

* Go through each active conda package off https://anaconda.org/psi4/repo

  - Find the most recent build set (Linux/Mac, active py versions) that ``psi4``/``psi4-rt``/``psi4-dev`` is using
  - _add_ (not replace) the ``main`` label.

* This makes a ``conda install psi4 -c psi4`` get everything psi4 needs. For the moment ``conda install psi4 -c psi4/label/dev`` will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in ``conda_build_config.yaml``.
* This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from "main", not "dev")


Build Psi4conda set (pre-Spring 2021)
-------------------------------------

Installers are build using the project ``constructor`` and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they're called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver).

* Need a conda env with ``constructor`` and ``cookiecutter``. This env presently accessed through ``conda activate cookie``.
* Enter "constructor-cutter-unified" in the psi4meta repo. There's a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md
* Edit ``cookiecutter/cookiecutter.json`` for control

  - Edit which python versions, if necessary
  - Edit ``release`` field
  - Edit ``hash`` field. This is the 7-char hash that's on every psi4 conda pkg as part of version
  - Edit ``ltrtver`` field. This matches the current setting in ``conda_build_config.yaml``
  - For prereleases, ``"channel_tag": "/label/dev"``, while for (post)releases, it should be the empty string
  - Leave this file set to a "rc" with Git, as that has more details

* For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX
* Edit ``cookiecutter/{{.../construct.yaml`` for templating. This is rarely needed
* If it's been a while or you need the space, clear out ``~/.conda/constructor``, where the downloaded packages are cached
* Note that installers get written to ``build/`` and this gets regenerated each time. Clear out between runs.
* ``python run.py``
* [Outdated] Watch out for ``py_`` in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can't handle "noarch" packages and will fail at runtime. If see a "noarch" package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.
* [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.
* If fetching times out, may have to run run.py several times. Clear out build/ in between. It's the fetching that takes a long time, not constucting
* In the end, should have several installers

  ::

    >>> ls -l build/psi4conda-1.3-py3.*/*64.sh
    -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh
    -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh
    -rwxr-xr-x. 518M Feb 28 20:30 build/psi4conda-1.3-py3.7-linux-64/psi4conda-1.3-py37-Linux-x86_64.sh
    -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.7-osx-64/psi4conda-1.3-py37-MacOSX-x86_64.sh


* Upload installer files to vergil, ``scp -r build/Psi4*/Psi4*sh root@vergil.chemistry.gatech.edu:/var/www/html/psicode-download/``
* Log in to vergil root and make WindowsWSL symlinks


Build Psi4conda set
-------------------

Installers are build using the project ``constructor`` and build binary bash or exe scripts, one per OS per Python version. In analogy to Miniconda, they're called Psi4Conda. They are built through GHA on the psi4meta repo and get served from vergil (cdsgroup webserver).

* Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml

  - Edit the top matter for Configuration. See snapshots in directory for examples.
  
    - Edit ``release`` fields. (Windows is often ``dev1`` unless separate steps.)
    - Edit ``ltrtver`` field. This matches the current setting in ``conda_build_config.yaml``
    - For prereleases, ``"channel_tag": "/label/dev"``, while for (post)releases, it should be the empty string
  - Edit the packages and channels info if necessary. Probably long-term stable. 

* Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml matrix.cfg
* All conda packages must already have been built and in the right ``channel_tag`` channel.
* Commit ``construct.yaml`` to trigger installer builds.
* When all build successfully, hover over the artifacts, and note the consecutive numbers GH has assigned them. These artifacts only linger for a day.
* Log in to vergil root and move to ``/var/www/html/psicode-download``.
* Use the pull_gha_installers script to download the installers from GH to vergil. First two arguments are first and last of the artifact numbers, and third argument is an auth token. ``bash pull_gha_installers.sh 47226565 47226573 715...4f3``.
* Make WindowsWSL and any other symlinks the script head matter advises.


Generate download page for psicode.org
--------------------------------------

* Be in repo psicode-hugo-website
* Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/content/installs/v13rc2.md. Note the edition string ``v13rc2`` in frontmatter for this and future filenames
* Copy and edit new file akin to https://github.com/psi4/psicode-hugo-website/blob/master/data/installs/v13rc2.yaml for menu and notes content
* Enter ``scripts/`` dir and edit primarily https://github.com/psi4/psicode-hugo-website/blob/master/scripts/install-generator.py#L9 but also any other arrays or messages that should change.
* Run the  ``install-generator.py`` in place. It will dump new files into ``data/installs/`` _subdirs_. Be sure to ``git add`` them.
* Installer page is now ready.
* Shift "latest" alias in frontmatter from whichever page is currently active to the new page. This makes sure "Downloads" on the navigation bar points to new page.
* Conscientiously, one should test

  - installer downloads in Mac and Linux. And actually installing them and ``psi4 --test`` them.
  - that download button and ``curl`` downloading register on the download counters on vergil

* Commit the new files, PR, and deploy psicode site
* Petition on Slack for testers


Collect documentation snapshot
------------------------------

* Documentation is built automatically by GHA from the latest psi4 master commit. It gets pushed to the psi4/psi4docs repository and thence served by netlify to a site independent of psicode.org. The netlify psicode.org site has a redirect so that psicode.org/psi4manual/master presents the psi4docs netlify content.
* GHA controller is :source:`.github/workflows/docs.yml`
* This setup works great for "latest" docs, but it won't build a nice copy on the tag because the tag commit is pushed before the tag itself, so the version shows up "undefined".
* So, anytime after "Tag (pre)release" is over, navigate on psi4 GH to the tag commit (not the record commit) and retrigger the docs GHA. Download the artifact (zipped docs dir) at the end to a local computer.
* In your hugo site clone, create a new directory under ``static/psi4manual``. Copy the zipped docs there, unpack, rearrange so that ``static/psi4manual/<new-tag>/index.html`` is present. Check in.


Publish GitHub release
----------------------

* On GitHub site "Draft a New Release" with newly minted tag
* Fill in frontmatter style and links from previous GitHub release
* Fill in RN from hopefully existing RN issue
* Fill in RN by going through the top posts from all PRs from this milestone
* "publish" release. This establishes release date for GitHub API
* Close the RN issue.
* Close the milestone (should be 100% complete).


Publish GitHub postrelease
--------------------------

* On GitHub site "Draft a New Release" for anticipated or newly minted tag
* Fill in frontmatter style and links from previous GitHub release
* Fill in RN as cherry-pick to or edit on branch
* "publish" release. This establishes release date for GitHub API


Publish psicode release
-----------------------

* Copy a recent release page like https://github.com/psi4/psicode-hugo-website/blob/master/content/posts/v1p2.md
* Edit its filename, title, date, image, and links
* Execute https://api.github.com/repos/psi4/psi4/releases/latest and note the ``id`` field value
* Use the ``id`` value in the shortcode call at the bottom


Finalize release
----------------

* Make new PR with
  * edits to main ``README.md`` badges, python versions, etc.
  * edits to ``CMakeLists.txt`` ``find_package(PythonLibsNew 3.6 REQUIRED)``
* Tweet about release


Reset psi4meta for nightly operation
------------------------------------

On both Linux and Mac:

* After (post)release (not prerelease), in ``conda_build_config.yaml``, edit ``ltrtver`` to a new "release.dev" label
* After postrelease, unpin any dependencies in cbcy that needed older either ver or bld (e.g., v2rdm_casscf_bld)
* Edit ``psi4ver`` back to ``''`` in cbcy
* Edit ``source/git_tag`` back to ``master`` for psi4-multiout, psi4-docs
* Edit build string back to ``0`` if psi4-multiout needed multiple passes
* Edit kitandkapoodle.py back to ``***`` stack
* Check in all release, construct, recipe changes on Linux and Mac. Synchronize both to GitHub psi4meta
* Copy meta.yaml and build.sh files to vMmp-prefixed files for the record.
* Edit crontab back to 2am "norm". Comment out "anom"

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   single: OEProp
   pair: OEProp; theory


.. _`sec:oeprop`:

Evaluation of One-Electron Properties |w---w| :py:func:`~psi4.oeprop`
=====================================================================

.. codeauthor:: Robert M. Parrish and Andrew C. Simmonett
.. sectionauthor:: Andrew C. Simmonett

.. autofunction:: psi4.oeprop(wfn, \*args[, title])
   :noindex:

|PSIfour| is capable of computing a number of one-electron properties
summarized in the table below. 

.. _`table:oe_features`:

.. table:: Current one-electron property capabilities of |PSIfour|

   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Feature                            | Keyword               | Notes                                                                             |
   +====================================+=======================+===================================================================================+
   | Electric dipole moment             | DIPOLE                |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Electric quadrupole moment         | QUADRUPOLE            | Raw (traced) moments and traceless multipoles                                     |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | All moments up order N             | MULTIPOLE(N)          | Only raw (traced) moments. Sets global variables e.g. "DIPOLE", "32-POLE"         |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Electrostatic potential, at nuclei | ESP_AT_NUCLEI         | Sets global variables "ESP AT CENTER n", n = 1 to natoms                          |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Electrostatic potential, on grid   | GRID_ESP              | Generates V at each point in grid_esp.dat. See :ref:`sec:oeprop_grid`             |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Electric field, on grid            | GRID_FIELD            | Generates {Ex,Ey,Ez} at each point grid_field.dat. See :ref:`sec:oeprop_grid`     |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Molecular orbital extents          | MO_EXTENTS            |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Mulliken atomic charges            | MULLIKEN_CHARGES      |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | L\ |o_dots|\ wdin atomic charges   | LOWDIN_CHARGES        |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Wiberg bond indices                | WIBERG_LOWDIN_INDICES | Uses (L\ |o_dots|\ wdin) symmetrically orthogonalized orbitals                    |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Mayer bond indices                 | MAYER_INDICES         |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Natural orbital occupations        | NO_OCCUPATIONS        |                                                                                   |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+
   | Stockholder Atomic Multipoles      | MBIS_CHARGES          | Generates atomic charges, dipoles, etc. See :ref:`sec:oeprop_mbis`                |
   +------------------------------------+-----------------------+-----------------------------------------------------------------------------------+

There are two ways the computation of one-electron properties can be requested. 
Firstly, the properties can be evaluated from the last
computed one-particle density, using the following syntax::

  oeprop("MO_EXTENTS", "MULTIPOLE(4)", title = "hello!")

Note that it is the user's responsibility to ensure that the relaxed density
matrix is computed using the method of interest, which may require setting
additional keywords (see the method's manual section for details). The named
argument, *title*, is completely optional and is prepended to any
globals variables set during the computation.  The unnamed arguments are the
properties to be computed.  These can appear in any order, and multiple
properties may be requested, as in the example above.  Note that, due to Python
syntax restrictions, the title argument must appear after the list of
properties to compute.  The available properties are shown in the table above.

The syntax above works well for computing properties using the SCF
wavefunction, however, may be difficult (or impossible) to use for some of the
correlated levels of theory. Alternatively, one-electron properties can be
computed using the built-in properties() function, e.g.::

  properties('ccsd', properties=['dipole'])

The :py:func:`~psi4.properties` function provides limited functionality, but is a lot easier to
use for correlated methods. For capabilities of :py:func:`~psi4.properties` see the
corresponding section of the manual.


Basic Keywords
^^^^^^^^^^^^^^

Multipole moments may be computed at any origin, which is controlled by the
global |globals__properties_origin| keyword.  The keyword takes an array with
the following possible values:

.. _`table:oe_origin`:

.. table:: Allowed origin specifications

   +-------------------------------+-------------------------------------------------------------------------------+
   | Keyword                       | Interpretation                                                                |
   +===============================+===============================================================================+
   | [x, y, z]                     | Origin is at the coordinates, in the same units as the geometry specification |
   +-------------------------------+-------------------------------------------------------------------------------+
   | ["COM"]                       | Origin is at the center of mass                                               |
   +-------------------------------+-------------------------------------------------------------------------------+
   | ["NUCLEAR_CHARGE"]            | Origin is at the center of nuclear charge                                     |
   +-------------------------------+-------------------------------------------------------------------------------+


.. _`sec:oeprop_grid`:


Properties evaluated on a grid
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Certain properties may be evaluated a user-specified grid points.  The grid
points are completely arbitrary and are specified by providing a file called
grid.dat containing the x,y,z values separated with spaces for each point in order::

    x1 y1 z1
    x2 y2 z2
    ..........
    xn yn zn

The grid.dat file is completely free form; any number of spaces and/or newlines
between entries is permitted.  The units of the coordinates in grid.dat are the
same as those used to specify the molecule's geometry, and the output
quantities are always in atomic units.  The requested properties will be
written out in the same order as the grid point specification in grid.dat; see
the above table for the format and file name of the output.

The grid may be generated in the input file using standard Python loops.  By
capturing the wavefunction used to evaluate the one-electron properties, the
values at each grid point may be captured as Python arrays in the input file::

    E, wfn = prop('scf', properties=["GRID_ESP", "GRID_FIELD"], return_wfn=True)
    Vvals = wfn.oeprop.Vvals()
    Exvals = wfn.oeprop.Exvals()
    Eyvals = wfn.oeprop.Eyvals()
    Ezvals = wfn.oeprop.Ezvals()

In this example, the *Vvals* array contains the electrostatic potential at each
grid point, in the order that the grid was specified, while the *Exvals*,
*Eyvals* and *Ezvals* arrays contain the *x*, *y* and *z* components of the
electric field, respectively; all of these arrays can be iterated and
manipulated using standard Python syntax.  For a complete demonstration of this
utility, see the :srcsample:`props4` test case.


.. index:: ISA; MBIS

.. _`sec:oeprop_mbis`:

Minimal Basis Iterative Stockholder
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Minimal Basis Iterative Stockholder (MBIS) method is one of many procedures
that partitions a molecular one-particle density matrix into atomic electron densities.
Running MBIS in |PSIfour| will calculate atomic valence charge widths, volume ratios,
atomic charges, as well as dipoles, quadrupoles, and octupoles. 
Additionally, all expectation values of radial moments of n-th order (:math:`<r^n>`) 
are computed up to fourth order. Higher moments can be computed by specifying |globals__max_radial_moment|.
The volume ratios are computed as the ratio between the volume of the atomic density
(:math:`<r^3>`) and the volume of the free atom computed using the same level
of theory, but with a potentially unrestricted reference.

The allowed number of iterations and convergence criteria for the stockholder 
algorithm is controlled by |globals__mbis_maxiter| and |globals__mbis_d_convergence|. Note 
that the density is partitioned on a molecular quadrature grid, the details of which can be
controlled with the keywords |globals__mbis_radial_points|, |globals__mbis_spherical_points|, and 
|globals__mbis_pruning_scheme|. (Associated Paper: [Verstraelen:2016]_)
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; database()
   see: db(); database()
   single: database()

.. _`sec:db()`:

Database |w---w| :py:func:`~psi4.driver.wrapper_database.database`
==================================================================

.. codeauthor:: Lori A. Burns
.. sectionauthor:: Lori A. Burns

.. autofunction:: psi4.driver.wrapper_database.database(name, db_name [, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])

.. index:: 
   pair: database(); output

Output
^^^^^^

At the beginning of a database job is printed a listing of the individual system 
calculations which will be performed. The output snippet below is from the example job [1]
above. It shows each reagent required for the subset of database reactions requested.
Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough
to compute only once the monomer whose energy will be subtracted from each of the three dimers. ::

                    RGC1-HeHe-0.85-dimer
                    RGC1-He-mono-unCP
                    RGC1-HeHe-1.0-dimer
                    RGC1-HeHe-1.5-dimer

At the end of the job, the Requested Energy table is printed that gives the total
energies for the requested model chemistry for each reagent and each reaction, as
well as the stoichiometric weights by which the reagent energies are transformed
into the reaction energy. In this case, the dimer is +1 and the monomer is -2,
indicating the interaction energy is computed from dimer less first monomer
less second (identical) monomer. Error statistics are computed with respect to the reference
energies stored in the database. One of these, the mean absolute deviation, is 
returned by the wrapper as an ordinary Python variable. (For databases
without a stored reference energy, *e.g.*, BASIC, large and meaningless numbers are
printed for error.) The other two tables tabulate the PSI variables requested
through keyword ``tabulate``, in this case the total SCF energy and the number
of atoms in each reagent. ::

   ==> Mp2 Total Energy <==

   ------------------------------------------------------------------------------------------------------
               Reaction          Reaction Value                             Reagent 1           Reagent 2
                                                                             Value Wt            Value Wt
   ------------------------------------------------------------------------------------------------------
         RGC1-HeHe-0.85              0.00004802                        -5.69430495  1      -2.84717649 -2
          RGC1-HeHe-1.0             -0.00000064                        -5.69435362  1      -2.84717649 -2
   ------------------------------------------------------------------------------------------------------

   ==> Requested Energy <==

   ------------------------------------------------------------------------------------------------------
               Reaction     Reaction Energy        Reaction Error           Reagent 1           Reagent 2
                               Ref     Calc [kcal/mol]   [kJ/mol]             [Eh] Wt             [Eh] Wt
   ------------------------------------------------------------------------------------------------------
         RGC1-HeHe-0.85     0.0376   0.0301    -0.0075    -0.0312      -5.69430495  1      -2.84717649 -2
          RGC1-HeHe-1.0    -0.0219  -0.0004     0.0215     0.0899      -5.69435362  1      -2.84717649 -2
   ------------------------------------------------------------------------------------------------------
            Minimal Dev                        -0.0075    -0.0312
            Maximal Dev                         0.0215     0.0899
        Mean Signed Dev                         0.0070     0.0293
      Mean Absolute Dev                         0.0145     0.0605
                RMS Dev                         0.0161     0.0673
   ------------------------------------------------------------------------------------------------------

As well as being printed in the output file, database results from the
``tabulate`` option are available in the input file as ordinary Python
dictionaries ``DB_RGT`` and ``DB_RXN``, indexed firstly by reagent or reaction
name and secondly by the requested PSI variable name. See the first
paragraph of :ref:`sec:createDatabase` for the distinction between
reagents and reactions. For example, an input file like the following
requests a couple variables through ``tabulate`` and then makes use of the
resulting data structures, here, only to print. ::
   
   set basis 6-31g*
   db('mp2','s22',subset='small',tabulate=['CURRENT ENERGY','MP2 CORRELATION ENERGY'])

   from pprint import pprint

   print_stdout('\nDB_RGT')
   pprint(DB_RGT)

   print_stdout('\nDB_RXN')
   pprint(DB_RXN)

   print_stdout('\nmp2 interaction energy of water dimer (S22-2)')
   print_stdout(DB_RXN['S22-2']['CURRENT ENERGY'])

The output to the screen is as follows. ::

   DB_RGT
   {'S22-16-dimer': {'CURRENT ENERGY': -155.37373581838636,
                     'DF-MP2 CORRELATION ENERGY': -0.523870772178089},
    'S22-16-monoA-unCP': {'CURRENT ENERGY': -78.29412053242164,
                          'DF-MP2 CORRELATION ENERGY': -0.2629759351596186},
    'S22-16-monoB-unCP': {'CURRENT ENERGY': -77.07606823017188,
                          'DF-MP2 CORRELATION ENERGY': -0.2594122526144091},
    'S22-2-dimer': {'CURRENT ENERGY': -152.40958884746667,
                    'DF-MP2 CORRELATION ENERGY': -0.3797598812113561},
    'S22-2-monoA-unCP': {'CURRENT ENERGY': -76.19905879745446,
                         'DF-MP2 CORRELATION ENERGY': -0.1887118848315123},
    'S22-2-monoB-unCP': {'CURRENT ENERGY': -76.19902978067739,
                         'DF-MP2 CORRELATION ENERGY': -0.18857384937354635},
    'S22-8-dimer': {'CURRENT ENERGY': -80.67416758080654,
                    'DF-MP2 CORRELATION ENERGY': -0.2844102558783027},
    'S22-8-monoA-unCP': {'CURRENT ENERGY': -40.336952636980364,
                         'DF-MP2 CORRELATION ENERGY': -0.14185962536715307},
    'S22-8-monoB-unCP': {'CURRENT ENERGY': -40.336952636980506,
                         'DF-MP2 CORRELATION ENERGY': -0.14185962536715097}}
   
   DB_RXN
   {'S22-16': {'CURRENT ENERGY': -0.0035470557928363178,
               'DF-MP2 CORRELATION ENERGY': -0.0014825844040612934},
    'S22-2': {'CURRENT ENERGY': -0.011500269334817403,
              'DF-MP2 CORRELATION ENERGY': -0.0024741470062974724},
    'S22-8': {'CURRENT ENERGY': -0.0002623068456699684,
              'DF-MP2 CORRELATION ENERGY': -0.0006910051439986686}}
   
   mp2 interaction energy of water dimer (S22-2)
   -0.0115002693348


.. index:: database(); available

.. _`sec:availableDatabases`:

Available Databases
^^^^^^^^^^^^^^^^^^^

Below are documented for particular databases the availability of the generic
database function options **cp**, **rlxd**, **benchmark**, and the string
options for **subset**. The full reagent member list, which can also be used
in conjunction with **subset**, is not included here for consideration of space
and may be found in the database file. The database Python files are very
readable and should be consulted for more particular questions.

----

.. comment This toctree directive only here to suppress warning at build time.
   include line below is doing the work.

.. toctree::
   :hidden:

   autodoc_available_databases

.. include:: autodoc_available_databases.rst

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: Libint, integrals

.. _`sec:libint`:

Interface to Libint by E. Valeev
================================

.. codeauthor:: Edward F. Valeev and Justin T. Fermann
.. sectionauthor:: Lori A. Burns

.. *Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <src/lib/libefp_solver>`

.. image:: https://img.shields.io/badge/home-libint-5077AB.svg
   :target: https://github.com/evaleev/libint

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: http://evaleev.github.io/libint/

|PSIfour|, particularly libmints utterly relies upon the Libint library
developed by E. Valeev from early roots by J. Fermann. Libint requires no
additional licence, downloads, or configuration. Conversely, |Psifour|
cannot build *without* Libint.

.. note:: As of Nov 2020 or release v1.4, |PSIfour| uses Libint2, not Libint1.
   Compared to many other open-source QC codes, |PSIfour| requires a separate
   Libint compilation with a different integrals ordering. See notes at top of
   :source:`external/upstream/libint2/CMakeLists.txt` .

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/libint/badges/version.svg
     :target: https://anaconda.org/psi4/libint

* Libint is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the |PSIfour| binary, Libint has already been installed alongside.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  Libint can be obtained through ``conda install libint -c psi4``.
  Then, hint its location with :makevar:`CMAKE_PREFIX_PATH`,
  and rebuild |PSIfour| to detect Libint and activate dependent code.

.. * Previous bullet had details. To build |PSIfour| from source and use 
..   Libint from conda without thinking, consult.

* To remove a conda installation, ``conda remove libint``.

**Source**

* .. image:: https://img.shields.io/github/tag/evaleev/libint.svg?maxAge=2592000
     :target: https://github.com/evaleev/libint/tree/v1

  Note that |PSIfour| uses v1.

* If using |PSIfour| built from source and you want Libint built from
  from source also,
  let the build system fetch and build it and activate dependent code.


.. _`cmake:libint`:

How to configure Libint for building Psi4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Role and Dependencies**

* Role |w---w| In |PSIfour|, Libint is a library that provides essential
  two-body molecular integrals over Gaussian functions.

* Downstream Dependencies |w---w| |PSIfour| |dr| Libint

* Upstream Dependencies |w---w| Libint |dr| None

**CMake Variables**

* :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing ``include/libint/libint.h``
* :makevar:`Libint_DIR` |w---w| CMake variable to specify where pre-built Libint can be found. Set to installation directory containing ``share/cmake/Libint/LibintConfig.cmake``
* :makevar:`CMAKE_DISABLE_FIND_PACKAGE_Libint` |w---w| CMake variable to force internal build of Libint instead of detecting pre-built
* :makevar:`CMAKE_INSIST_FIND_PACKAGE_Libint` |w---w| CMake variable to force detecting pre-built Libint and not falling back on internal build
* :makevar:`MAX_AM_ERI` |w---w| CMake variable to specify minimum highest angular momentum built or detected

**Examples**

A. Build bundled

  .. code-block:: bash

    >>> cmake

B. Link against pre-built

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root

  .. code-block:: bash

    >>> cmake -DLibint_DIR=/path/to/libint/configdir

C. Build bundled despite pre-built being detectable

  .. code-block:: bash

    >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint=ON

D. Build bundled shared library with AM=6

  .. code-block:: bash

    >>> cmake -DMAX_AM_ERI=6 -DBUILD_SHARED_LIBS=ON

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index:: gCP
.. _`sec:gcp`:

Interface to gCP by S. Grimme
=============================

.. codeauthor:: Lori A. Burns
.. sectionauthor:: Lori A. Burns

*Module:* :ref:`Samples <apdx:testSuitegcp>`

.. image:: https://img.shields.io/badge/home-gCP-5077AB.svg
   :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp

.. raw:: html

   <br>

.. image:: https://img.shields.io/badge/docs-latest-5077AB.svg
   :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/manGCP.pdf

Installation
~~~~~~~~~~~~

**Binary**

* .. image:: https://anaconda.org/psi4/gcp/badges/version.svg
     :target: https://anaconda.org/psi4/gcp

* gCP is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).

* If using the Psi4conda installer, gCP has already been installed alongside.

* If using the |PSIfour| conda package, the gcp conda package can
  be obtained through ``conda install gcp -c psi4`` or ``conda install
  psi4-rt -c psi4``.

* If using |PSIfour| built from source, and anaconda or miniconda has
  already been installed (instructions at :ref:`sec:quickconda`),
  the gcp executable can be obtained through ``conda install gcp -c psi4``.

* To remove a conda installation, ``conda remove gcp``.

**Source**

* .. image:: https://img.shields.io/badge/home-gCP-5077AB.svg
     :target: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/getgcp

* If using |PSIfour| built from source and you want to build gCP from
  from source also, follow the instructions provided with the source
  (essentially, download the freely available tarball, unpack the source,
  edit the Makefile to select a Fortran compiler, and run make).

To be used by |PSIfour|, the program binary (``gcp``) must be
found in your :envvar:`PSIPATH` or :envvar:`PATH` (in that order). If
|PSIfour| is unable to execute the binary, an error will be reported.
To preferentially use a particular gcp compilation, simply adjust its
position in the path environment variables.


Running gCP
~~~~~~~~~~~

At present there is a limited interface to gCP that is used
only to implement the "HF-3c" [Sure:2013:1672]_ and "PBEh-3c"
[Grimme:2015:054107]_ methods (both energy and gradient). The :ref:`DFTD3
<sec:dftd3>` executable must also be available for these methods to
run. Unlike every other method in |PSIfour|, if a basis set has not been
set, these will default to their intended basis sets: MINIX for HF-3c
and def2-mSVP for PBEh-3c. If a basis has previously been set, but you
want to use the default basis, use the slash syntax to "empty" the basis
option for the scope of the current calculation, ``energy("hf3c/")``.

A few practical examples:

* HF-3c single point with default minix basis ::

   energy('hf3c')

* PBEh-3c optimization with default def2-mSVP basis ::

   optimize('pbeh3c')

* HF-3c with non-standard basis ::

   set basis cc-pvdz
   energy('hf3c')

* PBEh-3c with default basis after basis set ::

   set basis cc-pvdz
   energy('pbeh3c/')

If only BSSE/basis set corrections (rather than total energies) are of
interest, the ``gcp`` program can be run independently of the scf
through the python function :py:func:`~qcdb.Molecule.run_gcp`. (This function
is the same |PSIfour|/``gcp`` interface that is called during an scf job.)
This route is much faster than running a HF or DFT energy. ::

   molecule nene {
   Ne
   Ne 1 2.0
   }

   nene.update_geometry()

   >>> E, G = nene.run_gcp('hf3c')

   >>> E, G = nene.run_gcp(func='HF3c', verbose=True)

.. autofunction:: qcdb.Molecule.run_gcp

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. index::
   triple: setting; keywords; properties()
   see: prop(); properties()

.. _`sec:prop()`:

Property
========

.. autofunction:: psi4.properties(name [, properties, molecule])
   :noindex:

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:code_style`:

Code style conventions
======================

It is important to keep a consistent formatting of the C++ and Python code
to avoid hard-to-read diffs and merge conflicts.
`clang-format <https://clang.llvm.org/docs/ClangFormat.html>`_ and `yapf <https://github.com/google/yapf>`_ can be used to format C++ and Python code,
respectively, according to a predefined style file.
|PSIfour| provides the :source:`.clang-format` and :source:`.style.yapf` files in the root
folder of the project.
It is **recommended** that modifications and/or new files checked into the
repository are formatted according to these style files using ``clang-format``
and ``yapf``. It is then helpful if these tools be part of your development toolchain.
Once ``clang-format`` and ``yapf`` are installed, there are three ways in which
formatting of the code can be accomplished, in decreasing order of automation:

1. By integrating the formatters into your editor.
2. By installing Git hooks to run the formatters when committing.
3. By running the formatters manually on the modified files.

.. _`faq:editorcodestyle`:

How to impose code style through your editor
--------------------------------------------

Both ``clang-format`` and ``yapf`` can be integrated into widely used editors.
The `Neoformat <https://github.com/sbdchd/neoformat>`_ plugin can be configured
to format files when saving them to disk.

.. _`faq:githookscodestyle`:

How to impose code style through Git hooks
------------------------------------------

Git hooks are scripts that are run before or after certain Git events.
In this particular case, we want to make sure that all files that have been
added to the staging area with ``git add`` are formatted according to the style
*before* they committing them with ``git commit``.
The hook to be modified is then the *pre-commit* hook.
|PSIfour| uses the `pre-commit <https://pre-commit.com/>`_ framework, with configuration file :source:`.pre-commit-config.yaml`.
To take advantage of pre-commit hooks, you will need to install the ``pre-commit`` utility:

::
  pip install pre-commit

or using Conda:

::
  conda install pre_commit -c conda-forge

Finally, you need to install the actual hooks:

::
  pre-commit install

Pre-commit hooks will be run on every ``git commit``, but the ``--no-verify``
option can be used to skip their execution.

Hooks are powerful, but integrating the formatter into your editor will prove
to be better. Hooks need to be installed anew for every fresh clone of the
repository you are working on.

.. _`faq:manualcodestyle`:

How to run code-style tools `clang-format` and `yapf` manually
--------------------------------------------------------------

The least recommended approach to formatting your code is to run manually the
formatters. The following commands will format only the files that have been
modified:

::
  clang-format -style=file -i `git diff --relative --name-only HEAD -- *.cc *.h`
  yapf -i `git diff --relative --name-only HEAD -- *.py`

How and when to *not* apply code styling to your contributions
--------------------------------------------------------------

TODO

The \PSIfour\ test suite is designed to maximize code reuse and
provide testing in \$prefix before the \PSIfour\
executables have been installed. The configure script in \$PSI4 
will take all the necessary files in \$PSI4/tests
with the .in stub: Makefile.in, MakeRules.in, MakeVars.in,
and runtest.pl.in, replace variables with system specific parameters,
and copy/create the testing files and directories in \$prefix/tests.
The tests should be run in the object directory before installation.

If you have just added a new module for performing, say multireference 
coupled cluster, and you would like to add a test case to the current 
test suite, here is what you should do.  
\begin{enumerate}
\item Copy one of the existing test case directories to an 
      appropriately named directory for the new test case.

\item Create an appropriate input file for running the new module. 
      Then, if your program produced the correct data, rename
      the output files to *.ref. Follow the convention of the 
      existing test cases. Make sure you add a descriptive comment to the
      input file, stating what the calculation type is.  Use the special comment
      marker ``\%!'' to do this, so that the comment is inserted into the user's
      manual.

\item If the test case is small, add the directory name to the list
      in \$PSI4/tests/Makefile.in.  If the test is particularly tricky,
      see the psi\_start or rhf-stab test cases as an example.

\item All the testing functionality is located in the perl library
      \file{runtest.pl.in}. If you are testing for a quantity that
      is not searched for currently, then add a function to the 
      library following the format of the functions already available.
      If you have added functionality to the \PSIfour\ driver,
      make sure to update the appropriate functions in \file{runtest.pl.in}.

\item Add the location of the Makefile for the new test case
      to the configure script in \$PSI4.

\end{enumerate}

Please contact one of the authors of \PSIfour\ before making any
major changes or if you have a problem adding a new test case.
Remember, if all else fails, read the source code.

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:handlingBasisSet`:

BasisSet
========

Circa November 2014, basis set handling in |PSIfour| has been revamped.
Fear not that the beloved libmints BasisSet object has changed- rather,
the user specification of basis sets, programmer's API to BasisSet
constructors, and the construction of BasisSet objects has been changed.

Advantages to New Scheme (aka *Why*)
------------------------------------

- Defaults for fitting basis sets set on a per-atom basis (*e.g.*, DF-SCF
  on metal-organic with cc-pVDZ uses cc-pVDZ-JKFIT for the organic and
  Def2-tzvpp (or something) for the metal) so that the user shouldn't
  experience a failed job on account of incomplete fitting basis sets.

- All default info for auxiliary basis sets in one place. Programmer when
  calling for a new auxiliary BasisSet gives the fitting role if defaults
  need to be computed (e.g., JKFIT) and the orbital basis to compute
  defaults off of (e.g., get_option(BASIS)). This eliminates all the
  "corresponding_jkfit" boilerplate in ``proc.py`` and also means defaults
  can be assigned for non-uniform orbital basis sets.

- Assignment of basis sets to atoms proceeds through "all", "by_symbol"
  (e.g., "Co"), or "by_label" (e.g., H1 or Co_mine). There is *no*
  assignment to atoms by number (except a bit internally where it's safe)
  which can be ambiguous when the Molecule has been fragmented as for SAPT.

- Users don't need to "set basis basisname" after every `molecule {...}`
  definition or activation because basis sets are not attached to the
  molecule at time option is set but at time BasisSet is built. Similarly,
  once can define a `basis basisname {...}` block and use it for multiple
  molecules.



BasisSet gives the option name where any user intentions as to proper
value may be found (DF_BASIS_SCF), the name by which the new basis can be
recalled (get_str('DF_BASIS_SCF')), the fitting role if defaults need to
be computed (JKFIT), the

*How* for Programmers
---------------------

To get a BasisSet object into your module, just call `pyconstruct` where
formerly you called `construct`. There are two flavors, one for orbital
basis sets and one for auxiliary basis sets. There's no difference in the
BasisSet objects they return or even the code used to assemble them- the
two flavors are just for sane argument naming and to establish different
signatures for Boost binding.

Orbital Basis
*************

Give the function a Molecule object for which to build basis, a label for
the basis (generally, BASIS), and a hint for finding the basis. This last
argument gets used to find a python function by that name camoflaged
(that's what ``basis {...}`` blocks in the input file get translated into)
or failing that a string to find a gbs file defining the basis. ::

    // simple
    boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(molecule, 
        "BASIS", "CC-PVDZ");

    // self-contained
    boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(Process::environment.molecule(),
        "BASIS", Process::environment.options.get_str("BASIS"));

Auxiliary Basis
***************

Give the function a Molecule object for which to build basis, a label for
the basis, a hint for finding the basis, a fitting role to apply if
defaults need to be generated, and a hint for finding the orbital basis to
build defaults against. ::

    // simple
    boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(molecule,
        "DF_BASIS_SCF", "", 
        "JKFIT", "CC-PVDZ");

    // self-contained and force Spherical
    boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(Process::environment.molecule(),
        "DF_BASIS_SCF", Process::environment.options.get_str("DF_BASIS_SCF"), 
        "JKFIT", Process:environment.options.get_str("BASIS"), 1);

Adding Basis Option to Code
***************************

- Register new basis keyword with :source:`src/bin/psi4/read_options.cc`
  (of course). The default should be the empty string. ::

    options.add_str("DF_BASIS_ELST", "");

- Register new basis keyword with the input parser
  :source:`share/python/inputparser.py`. In the main function
  `process_input`, add it to the regex below. This ensures that users can
  define ``basis_keyword basis_name {...}`` blocks where the contents of
  the block get associated with basis_name and assigned to your
  basis_keyword. ::

    basis_block = re.compile(r'^(\s*?)(basis|df_basis_scf|df_basis_mp2|df_basis_cc|df_basis_sapt)[=\s]*(\w*?)\s*\{(.*?)\}',
                             re.MULTILINE | re.DOTALL | re.IGNORECASE)

Deprecated Steps: Don't do these anymore!
-----------------------------------------

- Deprecated Step: registering non-basis keywords that contain the word
  BASIS in `check_for_basis` function in :source:`src/bin/psi4/python.cc`.
  Don't do this anymore!

- Deprecated Step: adding `corresponding_rifit` and surrounding
  boilerplate to `run_{method}` function :source:`share/python/proc.py`.
  Don't do this anymore!

- Building a parser object in module code as preparation to building a
  BasisSet. ::

    boost::shared_ptr<BasisSetParser> parser(new Gaussian94BasisSetParser(old_forced_puream));
    boost::shared_ptr<BasisSet> dual_basis = BasisSet::construct(parser, molecule_, "DUAL_BASIS_SCF");





key: label by which basis name gets attached to mol's CoordEntry-s



TODO    check that can just pass stirng instead of options.get_str("BASIS") etc.
        make form fn on the fly. do this in pyconstruct instead of inputparser for ordinary (non-block) basis sets?

//  BasisSet::pyconstruct(mol, key, ?, ?, target)
//  mol, key, target --> smol, targetfunc --> (s O)
//  primary_   = BasisSet::pyconstruct(molecule_, "BASIS", options_.get_str("BASIS"));
//  auxiliary_ = BasisSet::pyconstruct(molecule_, "DF_BASIS_MP2", options.get_str("DF_BASIS_MP2"),
//      "RIFIT", options_get_str("BASIS"));
//  mol, key, target, role, orbital --> smol, orbitalfunc, targetfunc, role --> (s O O s)
//  BasisSet::pyconstruct(mol, key, aux, role, orb)

* Note that the basis set specification in psi4 does not permit the assignment of basis sets to
an atom *number*. This is because multi-fragment methods (e.g., SAPT, efp) can involve the internal
chopping up and reinstantiation of molecules, which coule make the user's instructions ambiguous.
Thus, basis set specifictation is
    molecule mymol {
        # water dimer where
        O  -2  0 0
        H_hb  -1  0 0
        H  -1 -1 0
        --
        O   2  0 0
        H_hb  1  0 0
        H   2  1 0
    }
    * per molecule
        set basis cc-pv(d+d)z
            --or--
        basis mydz {
            assign cc-pv(d+d)z
        }
    
    * per element
        basis mydz {
            assign cc-pv(d+d)z
            
    * per 


<<< Q for Jet/Andy/Rob >>>

* Shouldn't lock_frame_ be reset to False for set_basis_all_atoms/by_symbol/by_label?
    Need to trigger reeval of symm upon geometry_update(). Doing this with set_shell....

* Ok that maybe can't form a basisset name using a key that's not a keyword

* Ok to remove parser from arg list

* since set_basis by number being removed from user domain, switching it to 0-indexing (more natural
    for c-side prog code) and to not indluce dummies (why give a dummy a basis set)

* ok that symm lowering won't show up until basis built?

* order of searching for basissets

* get approval for bas search order: strings, here, PSIPATH, library (I think)

<<< todo >>>

* make sure PSIDATDIR getting searched right, esp for installed copy

* transfer load_basis printing to output file

* check puream handling

* get correct full PT basis aux sets

* empty mol before adding basis sets in basis {} block
* establish that a basis spec must cover the whole molecule

<<    boost::shared_ptr<BasisSetParser> parser(new Gaussian94BasisSetParser());
<<    basisset_ = BasisSet::construct(parser, molecule_, "BASIS");

>>    basisset_ = BasisSet::pyconstruct(molecule_, "BASIS", options_.get_str("BASIS"));


<<    boost::shared_ptr<BasisSet> auxiliary = BasisSet::construct(parser, primary->molecule(), "DF_BASIS_SCF");

>>    boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct(primary->molecule(),
            "DF_BASIS_SCF", options.get_str("DF_BASIS_SCF"), "JKFIT", options.get_str("BASIS"));








     boost::shared_ptr<BasisSetParser> parser(new Gaussian94BasisSetParser(old_forced_puream));
     molecule_->set_basis_all_atoms(basisname, "DUAL_BASIS_SCF");
     boost::shared_ptr<BasisSet> dual_basis = BasisSet::construct(parser, molecule_, "DUAL_BASIS_SCF");
+    // TODO: oh my, forced_puream!
+    // TODO: oh my, a basis for which a fn hasn't been set in the input translation
+    // TODO: oh my, a non-fitting basis to be looked up (in Mol) not under BASIS
+    //boost::shared_ptr<BasisSet> dual_basis = BasisSet::pyconstruct(molecule_, basisname,
+    //            "DUAL_BASIS_SCF");
+    // TODO: I think Rob was planning to rework this projection bit anyways


* check with everyone about order in which directories searched











.. 
.. See `Best Practices <http://sirius.chem.vt.edu/trac/wiki/BestPractices#point1>`_ 
.. 
.. .. comment options["AO_BASIS"].has_changed()
.. .. comment will return false if the default value is being used, and true if the user specified this keyword in the input.
.. 
.. 
.. .. warning:: |globals__puream| is an exception in that its value and
..    ``has_changed()`` value only reflect what the user has explicitly set.
..    This keyword should not be queried to find out the current
..    |globals__puream| state for the active basis; use instead,
..    ``psi4.MintsHelper().basisset().has_puream()``.
.. 
.. - get 
.. 
..   - :py:func:`~psi4.get_global_option()`
..   - :py:func:`~psi4.get_local_option()`
..   - :py:func:`~psi4.get_option()`
.. 
.. 
..   .. note:: Some options (BASIS, BASIS-like, and PUREAM) should always
..      be used globally (no module argument) with the OptionsState objects.
..      Similarly, within the body of the function, they should always be
..      queried and set globally. Same for FREEZE_CORE.
.. 
.. - **Setting-Up Calculations**
.. 
..   The other types of options calls in python driver functions are (a)

%
% PSI Programmer's Manual
%
% SVN Revision Control Section
% (formerly CVS)
%
% TDC, February, 1996
% Modified by TDC, December 2002
% Updated from CVS to SVN, April 2007
%

The subversion control system (SVN) (\htmladdnormallink{{\tt
    subversion.tigris.org}}{http://subversion.tigris.org/}) provides a
convenient means by which programmers may obtain the latest (or any
previous) version of the \PSIfour\ source from the main repository or
a branch version, add new code to the source tree or modify existing
\PSIfour\ modules, and then make changes and additions available to
other programmers by checking the modifications back into the main
repository.  SVN also provides a ``safety net'' in that any erroneous
modifications to the code may be easily removed once they have been
identified.  This section describes how to use SVN to access and
modify the \PSIfour\ source code.  (Note that compilation and
installation instructions are given in a separate document.)

The main repository for the \PSIfour\ Source code is currently
maintained by the Crawford group at Virginia Tech.  To check out the
code, one must first obtain an SVN account by emailing
\htmladdnormallink{{\tt crawdad@vt.edu}}{mailto:crawdad@vt.edu}.
After you have a login-id and password, you are now ready to access
the repository via a secure, SSL-based WebDAV connection, but first
you must decide which version of the code you need.

The \PSIfour\ SVN repository contains three top-level directories:
\begin{itemize}
\item {\tt trunk}: The main development area.
\item {\tt branches}: Release branches and private development
  branches are stored here.
\item {\tt tags:} Snapshots of the repository corresponding to public
  releases are stored here and should {\em never} be modified.
\end{itemize}
If you have a PSI4 SVN account, you can peruse these directories if
you like by pointing web browser to:

\noindent
{\tt https://sirius.chem.vt.edu/svn/psi4/}

\subsection{\PSIfour\ SVN Policies: Which Branch Should I Use?}
\label{section:branches}

The \PSIfour\ repository comprises a main trunk and several
release branches.  The branch you should use depends on the sort of 
work you plan for the codes:
\begin{enumerate}
\item For any piece of code already in the most recent release, bug
  fixes (defined as anything that doesn't add functionality ---
  including documentation updates) should be made {\em only} on the
  most recent stable release branch.
\item The main trunk is reserved for development of new functionality.
  This allows us to keep new, possibly unstable code away from public
  access until the code is ready.
\item Code that you do not want to put into next major release of
  \PSIfour\ should be put onto a separate branch off the main
  trunk. You will be solely responsible for maintenance of the new
  branch, so you should read the SVN manual before attempting this.
\end{enumerate}

\noindent Fig.~\ref{Fig:svn} provides a schematic of the SVN revision-control
structure and branch labeling.  Two release branches are shown, the current
stable branch, named {\tt psi-3-4}, and a planned future release, to be named
{\tt psi-3-5}.  The tags on the branches indicate release shapshots, where
bugs have been fixed and the code has been or will be exported for public
distribution.  The dotted lines in the figure indicate merge points: just
prior to each public release, changes made to the code on the stable release
branch will be merged into the main trunk.

\begin{figure}[h]
\begin{center}
\epsfig{file=svn/svn.eps,height=6.5cm}
\end{center}
\caption{\PSIfour\ SVN branch structure with examples of branch- and
release-tag labelling.}
\label{Fig:svn}
\end{figure}

\noindent A frequently encountered problem is what to do about bug fixes
that are necessary for uninterrupted code development of the code on the
main trunk. As Rule 1 of the above policy states, all bug fixes of the code
already in the recent stable release must go on the corresponding branch,
not on the main trunk. The next step depends on the severity of the bug:
\begin{enumerate}
\item If the bug fix is critical and potentially affects every
  developer of the code on the main trunk, then \PSIfour\
  administrators should be notified of the fix. If deemed necessary,
  appropriate steps to create a new patch release will be made. Once
  the next patch release is created then the bug fixes will be merged
  onto the main trunk.  If the bug fix doesn't warrant an immediate
  new patch release, then you can incorporate the bug fix into your
  local copy of the main trunk code manually or using SVN merge
  features. This will allow you to continue development until next
  patch release is created and the bug fix is incorporated into the
  main trunk code in the repository. However you should {\em never}
  merge such changes into the main trunk yourself.
\item If the bug fix is not critical (e.g. a documentation
  update/fix), then you should wait until next patch release when it
  will be merged into the main trunk automatically.
\end{enumerate}

\noindent
The following are some of the most commonly used SVN commands for checking
out and updating working copies of the \PSIfour\ source code.

\noindent
$\bullet$ To checkout a working copy of the head of the main trunk:

{\tt svn co https://sirius.chem.vt.edu/svn/psi4/trunk/ psi4} 

\noindent
$\bullet$ To check out a working copy of the head of a specific release branch,
e.g., the branch labelled {\tt psi-4-0}:

{\tt svn co https://sirius.chem.vt.edu/svn/PSI4/branches/psi-4-0 psi4}

\noindent Note that subsequent {\tt svn update} commands in this
working copy will provide updates only on the chosen branch.  Note
also that after you have checked out a fresh working copy of the code
you must run the {\tt autoconf} command to generate a {\tt configure}
script for building the code.  (See the installation manual for
configuration, compilation, and testing instructions.)

\noindent For each of the above commands, the working copy of your
code will be placed in the directory \file{psi4}, regardless of your
choice of branch.  In this manual, we will refer to this directory
from now on as {\tt \$PSI4}.  Subsequent SVN commands are usually run
within this top-level directory.

\noindent
$\bullet$ To update your current working copy to include the latest revisions:

{\tt svn update}

\noindent
Notes: (a) This will update only the revisions on your current branch;
(b) The old {\tt -d} and {\tt -P} flags required by CVS are not necessary with SVN. 

\noindent
$\bullet$ To convert your working copy to the head of a specific branch:

{\tt svn switch https://sirius.chem.vt.edu/svn/PSI4/branches/psi-4-0}

\noindent
$\bullet$ To convert your working copy to the head of the main trunk:

{\tt svn switch https://sirius.chem.vt.edu/svn/psi4/trunk/}

\noindent
$\bullet$ To find out what branch your working copy is on, run this in your
top-level \PSIfour\ source directory:

{\tt svn info | grep URL}

\noindent
This will return the SVN directory from which your working copy was
taken, e.g.,

\noindent
{\tt URL: https://sirius.chem.vt.edu/svn/PSI4/branches/psi-4-0}

\noindent
Some words of advice:
\begin{enumerate}
\item Most SVN commands are reasonably safe, 

\item Unlike CVS, you shouldn't use {\tt svn update} to see the status
  of your working copy.  With SVN you should use {\tt svn status} to
  see if you've modified any files or directories.  If you want a
  direct comparison with the repository, you should use {\tt svn status -u}.
\item Read the SVN manual.  Seriously.
\begin{center}
\htmladdnormallink{{\tt
http://svnbook.red-bean.com/}}{http://svnbook.red-bean.com/}
\end{center}
\item If you're about to start some significant development or bug-fixes,
first update your working copy to the latest version on your branch.
In addition, if you do development over a long period of time (say weeks to
months) on a specific module or modules, be sure to run a {\tt svn status -u}
occasionally. In can be {\em very} frustrating to try to check in lots
of changes, only to find out that the \PSIfour\ has changed dramatically
since your last update.
\end{enumerate}

\subsection{Checking in altered \PSIfour\ binaries or libraries}

If you have changes to Psi binaries or libraries which already exist, one
of two series of steps is necessary to check these changes in to the main
repository. The first series may be followed if all changes have been made
only to files which already exist in the current version. The second series
should be followed if new files must be added to the code in the repository.

\begin{itemize}
\item No new files need to be added to the repository. We will use
\library{libciomr} as an example. 
\begin{enumerate}
\item {\tt cd \$PSI4/src/lib/libciomr}
\item {\tt svn ci -m ``Put comments here.''}
\end{enumerate}
\item New files must be added to the repository. Again, we use 
\library{libciomr}
as an example. Suppose the new file is named \file{great\_code.cc} .
\begin{enumerate}
\item {\tt cd \$PSI4/src/lib/libciomr} 
\item {\tt svn add great\_code.cc} 
\item {\tt svn ci -m ``Put comments here.''}
\end{enumerate}
\end{itemize}

The \file{svn ci} command in both of these sequences will examine all
of the code in the current \file{libciomr} directory against the
current version of the code in the main repository. Any files which
have been altered (and for which no conflicts with newer versions
exist!) will be identified and checked in to the main repository (as
well as the new file in the second situation).

SVN requires that you include a comment on your changes.  However,
unlike CVS, SVN prefers that you put your comments on the command-line
rather than editing a text file.  I prefer the CVS way, but this is a
minor pain compared to all the advantages of SVN, in my opinion.

\subsection{Adding entirely new code to the main \PSIfour\ repository} 
\label{checkin_new}

If the programmer is adding a new executable module or library to the
\PSIfour\ repository, a number of important conventions should be followed:

\begin{enumerate}
\item Since such changes almost always involve additional functionality,
new modules or libraries should be added only on the main SVN trunk.
See section \ref{section:branches} for additional information.

\item The directory containing the new code should be given a name
  that matches the name of the installed code (e.g. if the code will
  be installed as \module{newcode}, the directory containing the code
  should be named \file{newcode}). New executable modules must be
  placed in \shellvar{\$PSI4}\file{/src/bin} and libraries in
  \shellvar{\$PSI4}\file{/src/lib} of the user's working copy.

\item The Makefile should be converted to an input file for the
  configure script (\file{Makefile.in} --- see any of the current
  \PSIfour\ binaries for an example) and should follow the
  conventions set up in all of the current \PSIfour\
  \file{Makefiles}. This includes use of \file{MakeVars} and
  \file{MakeRules}.

\item New binaries should be added to the list contained in
  \shellvar{\$PSI4}\file{/src/bin/Makefile.in} so that they will be
  compiled automatically when a full compilation of the \PSIfour\
  distribution occurs. This step is included in the sequence below.

\item A documentation page should be included with the new code (see
  section \ref{Documentation} for more information). As a general
  rule, if the code is not ready to have a documentation page, it is
  not ready to be installed in \PSIfour.

\item The \file{configure.ac} file must be altered so that users may
  check out copies of the new code and so that the \file{configure}
  script will know to create the Makefile for the new code. These
  steps are included in the sequence below.

\end{enumerate}

Assume the new code is an executable module and is named
\module{great\_code}. The directory containing the new code must
contain only those files which are to be checked in to the repository!
Then the following steps will check in a new piece of code to the main
repository:

\begin{enumerate}
\item {\tt cd \$PSI4/src/bin}
\item {\tt svn add great\_code}
\item {\tt svn ci -m ``Put comments here.''}
\item {\tt cd \$PSI4}
\item Edit \file{configure.ac} and add \file{great\_code} to the list. 
\item {\tt svn ci configure.ac -m ``Put comments here.''}
\item {\tt autoconf} 
\item {\tt cd \$PSI4/src/bin} 
\item Edit \file{Makefile.in} and add \file{great\_code} to the list. 
\item {\tt svn ci Makefile.in -m ``Put comments here.''}
\end{enumerate}
At this point, all of the code has been properly checked in, but you
should also test to make sure that the code can be checked out by
other programmers, and that it will compile correctly. The following
steps will store your personal version of the code, check out the new
code, and test-compile it:
\begin{enumerate}
\item {\tt cd \$PSI4/src/bin}
\item {\tt mv great\_code great\_code.bak}
\item {\tt cd \$PSI4/..}
\item {\tt svn update}
\item {\tt cd \$objdir}
\item {\tt \$PSI4/configure -}{\tt -prefix=\$prefix}
\item {\tt cd src/bin/great\_code}
\item {\tt make install}
\end{enumerate}
(Note that \$prefix and \$objdir to the installation and compilation
 directories defined in the \PSIfour\ installation instructions.)
Your original version of the code remains under \file{great\_code.bak},
but should be no longer necessary if the above steps work. Note that it is
necessary to re-run \file{configure} explicitly, instead of just running
\file{config.status}, because the latter contains no information about
the new code.

\subsection{Updating checked out code}

If the code in the main repository has been altered, other users' working
copies will of course not automatically be updated.  In general, it is
only necessary to execute the following steps in order to completely update
your working copy of the code:

\begin{enumerate}
\item {\tt cd \$PSI4}
\item {\tt svn update}
\end{enumerate}

This will examine each entry in your working copy and compare it to
the most recent version in the main repository. When the file in the
main repository is more recent, your version of the code will be
updated. If you have made changes to your version, but the version in
the main repository has not changed, the altered code will be
identified to you with an ``M''. If you have made changes to your
version of the code, and one or more newer versions have been updated
in the main repository, SVN will examine the two versions and attempt
to merge them -- this process often reveals conflicts, however, and is
sometimes unsuccessful. You will be notified of any conflicts that
arise (labelled with a ``C'') and you must resolve them manually.

If new directories have been added to the repository, the update above
will automatically add them to your working copy.  However, you may
need to re-run {\tt autoconf} and configure ({\tt
  \$objdir/config.status --recheck} is a convenient command) to be
able to build the new code.

\subsection{Removing code from the repository}
If alterations of libraries or binaries under Psi involves the deletion of 
source code files from the code, these must be explicitly removed through SVN.

The following steps will remove a source code file named \file{bad\_code.F} 
from a binary module named \module{great\_code}:
\begin{enumerate}
\item {\tt cd \$PSI4/src/bin/great\_code}
\item {\tt svn remove bad\_code.F}
\item {\tt svn ci -m ``Put comments here.''}
\end{enumerate}

\subsection{Checking out older versions of the code}
It is sometimes necessary to check out older versions of a piece of code.
Assume we wish to check out an old version of \PSIdetci. If this
is the case, the following steps will do this:
\begin{enumerate}
\item {\tt cd \$PSI4/src/bin/detci}
\item {\tt svn co --revision \{2002-02-17\}}
\end{enumerate}

This will check the main repository and provide you with the code as
it stood exactly on February 17th, 2002. 

\subsection{Examining the revision history}
It can be very useful to use cvs to see what recent changes have been
made to the code.  Anytime one checks in a new version of a file, SVN
requires the user to provide comments on the changes with the {\tt -m}
flag.  These comments go into a log information that may be easily
accessed through SVN.  To see what changes have been made recently to
the file \file{detci.cc}, one would go into the \file{detci} source
directory and type
\begin{verbatim}
svn log detci.cc
\end{verbatim}
Checking the log files is a very useful way to see what recent changes might 
be causing new problems with the code.

\subsection{The structure of the \PSIfour\ Source Tree}
\label{psitree} 

Your working copy of the \PSIfour\ source code includes a number of
important subdirectories:

\begin{itemize}
\item \shellvar{\$PSI4}\file{/lib} -- Source files for
  OS-independent ``library'' data.  This includes the main basis set
  data file (\file{pbasis.dat}) and the \PSIfour\ program execution
  control file (\file{psi.dat}), among others.  These files are
  installed in \file{\$prefix/share}.

\item \shellvar{\$PSI4}\file{/include} -- Source files for
  OS-independent header files, including \file{physconst.h} (whose
  contents should be obvious from its name), \file{psifiles.h}, and
  \file{ccfiles.h}, among others.  These files are installed in
  \$prefix/include.

\item \shellvar{\$PSI4}\file{/src/util} -- Source code for the utility
  program \module{tocprint}.  (Note that the \module{tmpl} module is
  no longer used and will eventually disappear.)

\item \shellvar{\$PSI4}\file{/src/lib} -- Source code for the
  libraries, including \library{libpsio}, \library{libipv1},
  \library{libchkpt}, etc.  The include files from the library
  source are used directly during the compilation of PSI to 
  avoid problems associated with incomplete installations.  Some
  include files are architecture-dependent and go in an include
  subdirectory of the compilation (object) directory.

\item \shellvar{\$PSI4}\file{/src/bin} -- Source code for the
  executable modules.
\end{itemize}

After compilation and installation, the \file{\$prefix} directory
contains the executable codes and other necessary files.  {\bf NB:}
The files in this area should never be directly modified; rather, the
working copy should be modified and the \PSIfour\ \file{Makefile}
hierarchy should handle installation of any changes.  The structure of
the installation area is:

\begin{itemize}
\item \file{\$prefix/bin} -- The main executable directory.  This
  directory must be in your path in order for the driver program,
  \module{PSI4}, to find the modules.

\item \file{\$prefix/lib} -- The \PSIfour\ code libraries.  (NB: The
  description of \PSIfour\ \file{Makefiles} later in this manual will
  explain how to use the libraries.)

\item \file{\$prefix/include} -- Header files.  These are not actually
  used during the compilation of PSI but are useful for inclusion by
  external programs because they are all in the same directory.

\item \file{\$prefix/share} -- OS-independent data files, including
  basis set information.  (Do not edit this file directly; any changes
  you make can be overwritten by subsequent {\tt make} commands.)

\item \file{\$prefix/doc} -- \PSIfour\ documentation, including
  installation, programmer, and user manuals.
\end{itemize}

.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:casscf`:

Complete-Active-Space Self-Consistent-Field (CASSCF)
====================================================

Multi-configurational self-consistent-field (MCSCF) 
is a general method for obtaining qualitatively correct
wavefunctions for highly strained molecules, diradicals, or bond
breaking reactions.  The most commonly used MCSCF procedure
is the complete-active-space self-consistent-field (CASSCF)
approach [Roos:1980]_, which includes all possible determinants
(with the proper symmetry) that can be formed by distributing 
a set of active electrons among a set of active orbitals.
The detcasman module performs
CASSCF optimization of molecular orbitals via a two-step
procedure in which the CI wavefunction is computed using
detci, and the orbital rotation step is computed using
detcas.  The detcas program is fairly simple
and uses an approximate orbital Hessian [Chaban:1997:88]_
and a Newton-Raphson update,
accelerated by Pulay's DIIS procedure [Pulay:1980]_.
We have also implemented a prototype version of the RASSCF method
[Malmqvist:1990:RASSCF]_, which is another kind of MCSCF which 
is typically less complete (and less expensive) than CASSCF.
However, orbital convergence for RASSCF can be difficult in our
current implementation.

Inactive orbitals in the MCSCF may be specified by the 
|detci__restricted_docc| and |detci__restricted_uocc| keywords. These
orbitals will remain doubly-occupied or doubly-unoccupied, respectively,
in the MCSCF wavefunction.  However, the form of these orbitals will
be optimized in the MCSCF procedure.  It is also possible to 
literally freeze inactive orbitals in their original (SCF) form
using the |globals__frozen_docc| and |globals__frozen_uocc| keywords.
This is not normally what one wishes to do in an MCSCF computation
(*e.g.*, it complicates the computation of gradients),
but it can make the computations faster and is helpful in some
circumstances where unphysical mixing of inactive and active
occupied orbitals might occur.  Presently, it is not possible
to mix the use of restricted and frozen orbitals in |PSIfour|.

The division of the molecular orbitals into various subspaces such as RAS
spaces, or frozen vs active orbitals, etc, needs to be clear not only to
the detci program, but also at least to the transformation program
(and in the case of MCSCF, to other programs as well).  Thus,
orbital subspace keywords such as |detci__ras1|, |detci__ras2|, |detci__ras3|, |detci__ras4|,
|globals__frozen_docc|, |globals__frozen_uocc|, |detci__active|, *etc.*, need to be
in the global ``set {...}`` block section of the input file so they may
be accessed by other modules.

The ability to perform state-averaged 
[Docken:1972:4928]_ [Ruedenberg:1979:1069]_
CASSCF or RASSCF computations has been added.  This is accomplished using the 
|detci__avg_states| keyword.

See the :srcsample:`casscf-sp` and :srcsample:`casscf-sa-sp` examples in the 
samples directory and the example below.

Basic Keywords
--------------

WFN = string
This may be ``casscf`` or ``rasscf``.

REFERENCE = string
Any of the references allowed by detci should work (*i.e.*, not
{\tt uhf}), but there should be no reason not to use {\tt rhf}.

DERTYPE = string
At present, only energies ({\tt none}) are supported; future
releases will implement gradients ({\tt first}).

CONVERGENCE = integer
Convergence desired on the orbital gradient.  Convergence is achieved when
the RMS of the error in the orbital gradient is less than 10**(-n).  The 
default is 4 for energy calculations and 7 for gradients.  Note that
this is a different convergence criterion than for the \PSIdetci\
program itself.  These can be differentiated, if changed by the user,
by placing the {\tt CONVERGENCE} keywords within separate sections of
input, such as {\tt detcas: ( convergence = x )}.

ENERGY\_CONVERGENCE = integer
Convergence desired on the total MCSCF energy.  The default is 7.
\item[RESTRICTED\_DOCC = (integer array)]\mbox{}\\
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The number of lowest energy doubly occupied orbitals in each irreducible
representation from which there will be no excitations.  
These orbitals are optimized in the MCSCF.
The Cotton ordering of the irredicible representations is used.
The default is the zero vector.

RESTRICTED\_UOCC = (integer array)
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The number of highest energy unoccupied orbitals in each irreducible
representation into which there will be no excitations.
These orbitals are optimized in the MCSCF.
The default is the zero vector.

FROZEN\_DOCC = (integer array)]\mbox{}\\
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The number of lowest energy doubly occupied orbitals in each irreducible
representation from which there will be no excitations.  
These orbitals are literally frozen and are not optimized in the MCSCF;
usually one wishes to use {\tt RESTRICTED\_DOCC} instead.
The current version of the program does not allow both
{\tt RESTRICTED\_DOCC} and {\tt FROZEN\_DOCC}.
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The Cotton ordering of the irredicible representations is used.
The default is the zero vector.

FROZEN\_UOCC = (integer array)]\mbox{}\\
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The number of highest energy unoccupied orbitals in each irreducible
representation into which there will be no excitations.
These orbitals are literally frozen and are not optimized in the MCSCF;
usually one wishes to use {\tt RESTRICTED\_UOCC} instead.
The current version of the program does not allow both
{\tt RESTRICTED\_UOCC} and {\tt FROZEN\_UOCC}.
Should be in {\tt psi:()} or {\tt default:()} sections of input.
The default is the zero vector.

NCASITER = integer]\mbox{}\\
Maximum number of iterations to optimize the orbitals.  This option
should be specified in the DEFAULT section of input, because
it needs to be visible to the control program PSI.  Defaults to 20.

AVERAGE\_STATES = (integer array)]\mbox{}\\
This gives a list of what states to average for the orbital 
optimization.  States are numbered starting from 1.

PRINT = integer]\mbox{}\\
This option determines the verbosity of the output.  A value of 1 or
2 specifies minimal printing, a value of 3 specifies verbose printing.
Values of 4 or 5 are used for debugging.  Do not use level 5 unless
the test case is very small (e.g. STO H\ :sub:`2`\ O CISD).

Examples
--------

Example of a CASSCF single-point calculation for H\ :sub:`2`\ O using
a valence active space 3a\ :sub:`1` 1b\ :sub:`1` 2b\ :sub:`2`. ::

    % 6-31G** H2O Test CASSCF Energy Point
                                                                                    
    psi: (
      label = "6-31G** CASSCF H2O"
      jobtype = sp
      wfn = casscf
      reference = rhf
      restricted_docc = (1 0 0 0)
      active          = (3 0 1 2)
      basis = "6-31G**"
      zmat = (
        o
        h 1 1.00
        h 1 1.00 2 103.1
      )
    )

As noted previously, we want to start from a code that's not too tightly
integrated with the \PSIfour\ code itself, so we begin with a \file{Makefile}
that will allow us to write a standalone code that includes all requisite \PSI\
libraries.  We're going to write a small sample code that generates integrals,
which involves two just two source files.  We begin by defining a
\file{Makefile} that will include all of the \PSIfour\ libraries and header
files, so that we can take full advantage of the wide range of features
implemented without having to worry about the details of their implementation.

\includesource{sample-codes/integrals/Makefile}{make}

Only a few lines of this makefile need to be modified to utilize it for other
programming projects; we'll concentrate on them.  On the second line, we define
the name of the executable to be generated, in this example we opt for the
unimaginative title of \module{integrals}.  Line 4 provides the list of source files
that the project comprises; these will be detailed below.  The top source
directory for the \PSIfour\ installation and the top object directory (where
\PSIfour\ was compiled) should be provided on lines 6 and 8, respectively.
Lines 10 and 11 describe the flags needed to link in the \module{BLAS} and
\module{LAPACK} libraries and might need a combination of ``\file{-L
folder\_name}'' and ``\file{-l library\_name}'', depending on your system's
setup.  Finally, the compiler and flags are detailed on lines 12--17.  It's a
good idea to use the flags described on line 16 for development; they speed up
code compilation and provide lots of information for standard debugging tools.
As noted in the \file{Makefile} itself, nothing below line 17 should require
modification for any other \PSIfour\ project.

The \PSIfour\ driver program provides a lot of functionality that we forgo in
writing a standalone code; this is instead emulated in the {\tt main.cc} file,
shown below.

\includesource{sample-codes/integrals/main.cc}{C++}

All modules in \PSIfour\ must have the argument list and return type shown on
line 13.  The possible return types, defined by an enumeratable constant are
documented in \file{psi4-dec.h}, which lives in \$PSI4/include.  Notice that
all of the code must live in it's own namespace within the \module{psi}
namespace, in this case it's in the \module{psi::integrals} namespace.  Without
this nesting, functions belonging to different parts of the code, but having
the same name, would cause conflicts.  The \module{read\_options} function is
responsible for setting up the \module{Options} object, which contains the list
of user-provided options.  Lines 25--32 are important - these provide the list
of keywords expected by the code, their types, and their default values (if
any).  This part of the code will be inserted into the \PSIfour\ driver when
the module is ready for merging with the \PSIfour\ distribution; this process
will be detailed later in the chapter.  Notice the special format of the
comments on lines 27 and 30.  These are still valid \module{C++} comments, but
the extra hyphens inside are essential in this context.  Whenever adding any
options for any module, you must comment them as shown - this will ensure that
the keywords are automatically inserted into the \PSIfour\ users' manual.  The
\module{main} function does a little setting up of the \PSI\ input and output
environments, before calling the module code we're developing (on line 53) and
shutting down the \PSIfour\ I/O systems.

The module we're developing is in the following source file.

\includesource{sample-codes/integrals/integrals.cc}{C++}

Given the extensive documentation within the code, we'll not describe this file
line-by-line; however, some points warrant elaboration.  Notice that the entire
module is encapsulated in the \module{psi::integrals} namespace (lines 6 and
92).  This simple example has only one function body, which lives in a single
source file - if more functions and/or source files were added, these too would
have to live in the \module{psi::integrals} namespace.  On lines 29 and 31 of
\file{main.cc} we told the parser which keywords to expect, and provided
default values in case the user omited them from the input.  This makes
retrieving these options very clean and simple ({\it c.f.} lines 11 and 12 of
\file{integrals.cc}).  Each \PSIfour\ module will have to initialize its own
local \module{PSIO} and \module{Chkpt} objects to perform I/O and to retrieve
information from previously run modules.  Notice that these objects are created
within smart pointers (see section XXX for more information) so that they are
automatically deleted when they go out of scope, thus reducing the burden on
the programmer.  Likewise, the basis sets, matrices and integral objects are
allocated using smart pointers.

The code described above can be built by simply typing ``make'' on the command
line.  To run this code, you must first run the \module{input} module to read
in the basis set information.  A \PSI\ input for this code should look some
thing like the following:

\includeinput{sample-codes/integrals/input.dat}
.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:bestPractices_py`:

Best Practices for Python Functions
===================================

- Thy python functions shall always have final argument \*\*kwargs, that they may take in and pass on keywords meant for other functions. Yea, even the run_mcscf(), and run_ccsd() -type functions that have no use for kwargs. The exceptions are python functions that are only helpers called by a driver function.

- Python functions should read the kwargs dictionary and (possibly) add to it. Functions should not pop or remove keywords from kwargs, even those keywords meaningful only to itself. This will ensure that the complete kwargs is available for pickling and sow/reap procedures. The exception is the molecule argument, which is read by the first function that gets ahold of it. This first function activates the molecule and pops it out of kwargs, effectively setting molecule for all subsequent functions. The code below should suffice. ::

    # Make sure the molecule the user provided is the active one
    if 'molecule' in kwargs:
        activate(kwargs['molecule'])
        del kwargs['molecule']
    molecule = psi4.get_active_molecule()
    molecule.update_geometry()

- Preferrably, the python function signature (for functions intended to be called in input files) is ``function(name, **kwargs)``. For functions that have other positional keywords, please bundle them into kwargs at earliest convenience (see :ref:`sec:db()` argument db_name for example).

- After the docstring, the first two lines of your function should be the ones below. The first provides a case insensitive handle to the name argument value. The second converts all the kwargs dictionary keys to lowercase versions of themselves, so that input files can be case insensitive. ::

    lowername = name.lower()
    kwargs = kwargs_lower(kwargs)

- Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match. ::

    if (kwargs['db_mode'].lower() == 'continuous'):
    if re.match(r'^sapt', name, flags=re.IGNORECASE):

- Match boolean keywords (db_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument's value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd. ::

    if input.yes.match(str(db_cp)):
    elif input.no.match(str(db_cp)):

-   For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp_func, db_func, and opt_func to request what python function, if not energy(), is called by cp(), database(), and optimize().

- Upon checking in a new python file, edit the file ``psi4/doc/userman/source/index.rst`` and follow the instructions therein that your file may be autodocumented here.

- Write docstrings! For a major function intended for use in input files, emulate any docstring in ``psi4/share/python/driver.py``. For a behind-the-scenes function or if you don't want the bother of dealing with `reStructuredText <http://docutils.sourceforge.net/docs/user/rst/quickref.html>`_, just write an ordinary docstring. It will get slurped into the documentation in plain text.

- Your python function should follow `PEP8 <http://www.python.org/dev/peps/pep-0008/>`_ conventions (without the line-length restriction). I'm aiming for files to pass the line below, unless for good reason. The second line is for database Python files.

    >>> pep8.py -r --ignore=E501 pythonfile.py
    >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py

- Your python function should not prevent any test case from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap\_ is suggested.

- Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the 'current energy' variable. This last is needed to communicate with the optimizer. ::

    psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25)
    psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25)
    psi4.set_variable('CURRENT ENERGY', e_mp25)

- Once your python function is fairly stable on its own, it's potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:

    - If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no \*_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function. ::

        # Establish function to call
        if not('xx_func' in kwargs):
            if ('func' in kwargs):
                kwargs['xx_func'] = kwargs['func']
                del kwargs['func']
            else:
                kwargs['xx_func'] = energy
        func = kwargs['xx_func']
        if not func:
            raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__))
        if (func is db):
            raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__))

    - If specific interoperabilities are known, code them in. For example, if xx shouldn't call db, add the last two lines above to the xx function. If db shouldn't call xx, add the following two lines below to the db function. ::

        if (func is xx):
            raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__))

    - Create a multipart test case that runs some intercalls between your function and others (akin to :srcsample:`pywrap_all)`. In trials, permute the order of calls a few times to expose any calls that don't clean up after themselves and need further attention.

    - When all is validated, add your findings to the great :ref:`table:intercalls` table in the documentation.



.. #
.. # @BEGIN LICENSE
.. #
.. # Psi4: an open-source quantum chemistry software package
.. #
.. # Copyright (c) 2007-2022 The Psi4 Developers.
.. #
.. # The copyrights for code used from other parties are included in
.. # the corresponding files.
.. #
.. # This file is part of Psi4.
.. #
.. # Psi4 is free software; you can redistribute it and/or modify
.. # it under the terms of the GNU Lesser General Public License as published by
.. # the Free Software Foundation, version 3.
.. #
.. # Psi4 is distributed in the hope that it will be useful,
.. # but WITHOUT ANY WARRANTY; without even the implied warranty of
.. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. # GNU Lesser General Public License for more details.
.. #
.. # You should have received a copy of the GNU Lesser General Public License along
.. # with Psi4; if not, write to the Free Software Foundation, Inc.,
.. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
.. #
.. # @END LICENSE
.. #

.. include:: autodoc_abbr_options_c.rst

.. _`sec:mp2`:

Second-order |MollerPlesset| Theory: MP2 and MP2-R12 methods
============================================================

Second-order |MollerPlesset| theory is one of the most basic
wavefunction approaches which includes electron correlation
directly.
Due to its simplicity, the MP2 method is often the best
level one can afford for a larger molecular system.
At the other end of the spectrum, the MP2-R12 method
of Kutzelnigg, Klopper, and co-workers is a promising
approach to computing MP2 energies in the complete
basis set limit for smaller systems. |PSIfour| is
one of the very few publicly available programs to
feature a robust implementation of the MP2-R12 method.

|PSIfour| is capable of computing closed-shell
MP2 and MP2-R12/A energies using integral-direct techniques and a
multithreaded algorithm, which lends itself perfectly for execution 
on symmetric multiprocessor (SMP) machines. |PSIfour| is also
capable of computing RHF, UHF, and ROHF (using semicanonical orbitals)
MP2 energies and one-particle density matrices, and RHF MP2 analytic 
gradients.  Occupied and virtual orbitals can be frozen during the 
energy calculation, but not for the calculation of the 
one-particle density matrix or the analytic gradient.

.. table:: Summary of MP2 and MP2-R12 capabilities in |PSIfour|

   +-----------+-----------+---------------+--------------------------+----------+
   | Reference | Method    | Energy (conv) | Energy (integral-direct) | Gradient |
   +===========+===========+===============+==========================+==========+
   | RHF       | MP2       | Y             | Y                        | Y        |
   +-----------+-----------+---------------+--------------------------+----------+
   | UHF       | MP2       | Y             | ---                      | ---      |
   +-----------+-----------+---------------+--------------------------+----------+
   | ROHF      | MP2       | Y             | ---                      | ---      |
   +-----------+-----------+---------------+--------------------------+----------+
   | RHF       | MP2-R12/A | ---           | Y                        | ---      |
   +-----------+-----------+---------------+--------------------------+----------+

Basic Keywords
--------------

To compute a ground-state MP2 or MP2-R12 energy at a fixed geometry,
the following keywords are common:

\item[WFN = string]\mbox{}\\
Acceptable values are {\tt mp2} for MP2, {\tt mp2r12} [for MP2-R12/A]
There is no default.  

\item[REFERENCE = string]\mbox{}\\
The only acceptable value are {\tt rhf, uhf, and rohf}.
There is no default.

\item[JOBTYPE = string]\mbox{}\\
Acceptable values are {\tt sp} and {\tt opt}.  There is no default.

\item[MEMORY = (real MB)]\mbox{}\\
Specified the amount of core memory to be used, in MB.  Defaults to 256.
Other units (*e.g.*, KB or GB) are also allowed.

.. comment include:: autodir_options_c/detci__reference.rst

\item[DIRECT = boolean]\mbox{}\\
Specifies whether to use the conventional ({\tt false}) or
integral-direct ({\tt true}) algorithm. Default is {\tt false}.

\item[NUM\_THREADS = integer]\mbox{}\\
Specified the number of threads to be used in the integral-direct
computation (only valid if {\tt DIRECT} is set to {\tt true}).
Default is 1.

\item[FREEZE\_CORE = boolean]\mbox{}\\
Specifies whether core orbitals (which are determined automatically) are to
be excluded from the correlated calculations.  Default is {\tt false}.

\item[PRINT = integer]\mbox{}\\
The desired print level for detailed output.  Setting this to 2 is a good
idea for larger calculations so that the progress of the calculation may be
easily followed.  Defaults to 0.

\item[OPDM = boolean]\mbox{}\\
If {\tt true}, calculate the one-particle density matrix.  The default is false.

\item[OPDM\_WRITE = boolean]\mbox{}\\
If {\tt true}, write the one-particle density matrix to disk.

\item[OPDM\_PRINT = boolean]\mbox{}\\
If {\tt true}, print the one-particle density matrix to the output file.

Using the MP2-R12 method
------------------------

Although this manual is not a how-to on running
quantum chemistry applications, the MP2-R12 method is
a rather non-standard tool, hence a few comments on its
use are appropriate.

* The version of the MP2-R12 method implemented in |PSIfour|
  is a so-called single-basis MP2-R12 method
  in standard approximation A. This means that a basis set
  rather complete in Hartree--Fock (or one-particle) sense
  is absolutely mandatory for meaningful computations with the MP2-R12
  method. The user is strongly urged to read literature on
  linear R12 methods before using |PSIfour| to compute MP2-R12
  energies.

* More robust, two-basis versions
  of the MP2-R12 method, also known as the auxiliary basis
  MP2-R12 method, have been implemented
  in a publicly available Massively Parallel Quantum Chemistry (MPQC)
  package (see \url{http://aros.ca.sandia.gov/~cljanss/mpqc/}).
  The two-basis version of the MP2-R12 method is a theoretically more
  sound approach, and thus should be preferred to the single-basis method.
  In some situations, however, it may make sense to use
  the single-basis method.

Larger Calculations
-------------------

Here are a few recommendations for carrying out extended integral-direct MP2 and
MP2-R12 calculations with |PSIfour|: 

* While the integral-direct MP2 algorithm doesn't need any
  significant disk storage,
  the integral-direct algorithm for the MP2-R12 energy
  stores the transformed integrals to disk, hence very large
  computations will require a lot of disk space. In general
  the storage requirement is :math:`16 o^2N^2` bytes, where :math:`o`
  is the number of occupied orbitals, and :math:`N` is the size of the basis.

* If there is not enough memory to perform the computation in one pass,
  the program will do multiple passes through the entire set of integrals,
  hence your computation will run that many times longer.
  In such case, find the machine with the most memory and processors available.

* On SMP machines, set the {\tt NUM\_THREADS} to the number of
  processors available for the job, or, if all processors are allocated for
  your job, set {\tt NUM\_THREADS} to {\em twice} the number of processors
  you have. Modern operating systems schedulers are usually very efficient
  at handling multithreaded programs, so the overhead of thread context
  switching is not significant, but using more threads may lead to better
  load balancing, and lower execution times. For example, on a 32-processor
  IBM eServer p690 we found that the optimal number of threads was 128.
  For the optimal performance, do a few runs with different number of threads
  and see which number works best.
  Avoid excessively large
  number of threads, as this descreases the net amount of memory available to
  the computation and thus may increase the number of passes. 

* Set the {\tt MEMORY} keyword to the 90% of the available physical
  memory, at most. There is a small amount of overhead associated with the
  integral-direct algorithms that is not accounted for by the internal memory
  handling routines.

* The implementation of the integral-direct MP2-R12 (and MP2) method
  in |PSIfour| can run efficiently on SMP, or shared-memory, machines,
  by utilizing multiple processors via multithreaded approach.
  However, it cannot utilize distributed memory machines,
  such as commodity (PC) clusters and massively parallel machines,
  to their full potential, since one computation can only take advantage
  of one node of such machine at a time.
  In such environments, the aformentioned MPQC implementation of
  the MP2-R12 method should be preferred
  (see \url{http://aros.ca.sandia.gov/~cljanss/mpqc/}).

%
% History of Psi
%
% Daniel Crawford, 24 January, 1996
%

The PSI suite of {\em ab initio} quantum chemistry programs is the result
of an ongoing attempt by a cadre of graduate students, postdoctoral
associates, and professors to produce code that is efficient but also
easy to extend to new theoretical methods.  Significant effort has been
devoted to the development of libraries which are robust and easy to use.
Some of the earliest contributions to what is now referred to as ``PSI''
include a direct configuration interaction (CI) program (Robert Lucchese,
1976, now at Texas A\&M), the well-known graphical unitary group CI program
(Bernie Brooks, 1977-78, now at N.I.H.), and the original integrals code
(Russ Pitzer, 1978, now at Ohio State).  From 1978-1987, the package was
know as the {\tt BERKELEY} suite, and after the Schaefer group moved to the
Center for Computational Quantum Chemistry at the University of Georgia,
the package was renamed {\tt PSI}.  Thanks primarily to the efforts of Curt
Janssen (Sandia Labs, Livermore) and Ed Seidl (LLNL), the package was
ported to UNIX systems, and substantially improved with new input formats
and a C-based I/O system.

Beginning in 1999, an extensive effort was begun to develop \PSIthree\
--- a {\tt PSI} suite with a completely new face.  As a result of this
effort, all of the legacy Fortran code was removed, and everything was
rewritten in C and C++, including new integral/derivative integral,
coupled cluster, and CI codes.  In addition, new I/O libraries have
been added, as well as an improved checkpoint file structure and greater
automation of typical tasks such as geometry optimization and frequency
analysis.  The package has the capability to determine wavefunctions,
energies, analytic gradients, and various molecular properties based on
a variety of theories, including spin-restricted, spin-unrestricted, and
restricted open-shell Hartree-Fock (RHF, UHF, and ROHF); configuration
interaction (CI) (including a variety of multireference CI's and full
CI); coupled-cluster (CC) including CC with variationaly optimized
orbitals; second-order M{\o}ller-Plesset perturbation theory (MPPT)
including explicitly correlated second-order M{\o}ller-Plesset energy
(MP2-R12); and complete-active-space self-consistent field (CASSCF)
theory.  By January 2008, all of the C code in \PSIthree\ was 
converted to C++ to enable a path toward more object-oriented design
and a single-excecutable framework that will facilitate code reuse and 
ease efforts at parallelization.  At this same time, all of the legacy I/O
routines from {\tt PSI2} were removed, greatly streamlining the
\library{libciomr.a} library.
One of the most significant changes introduced in version 4 was the use of
Python.  The input file is actually a Python script, which interacts with a Psi
Python module to perform computations.  In order for this to happen, the C++
binding must be known to Python; this is all done in the 
{\tt \$PSI4/src/bin/psi4/python.cc} file.  For example, we have an SCF module, with
the C++ signature
{\tt PsiReturnType cscf::cscf(Options \&options);}
To allow Python to use this, we first define a little wrapper function
\begin{verbatim}
double py_psi_scf()
{
    if (scf::scf(Process::environment.options) == Success)
        return Process::environment.globals["CURRENT ENERGY"];
    else
        return 0.0;
}
\end{verbatim}
This does a couple of things to automate things a) it passes the default
options object into SCF automatically, so that the user doesn't have to, and b)
checks the return value, and will return the energy, which is posted to the
globals map, back to Python.  Note that this is C++ code, within \PSIfour\ so
it is aware of all global objects, such as PSIO, Chkpt and Options.  Now we
have this simple function call, we can tell Python about it:
\begin{verbatim}
def("scf",  py_psi_scf);
\end{verbatim}
This binds the keyword ``scf'' to the newly created wrapper function, allowing
the user to type ``scf()'' in their Python input file to fire up the SCF
module.  Similarly, the user might want to be able to call {\tt Molecule}'s
member functions directly from Python.  This can also be done easily:

\begin{verbatim}
class_<Molecule, shared_ptr<Molecule> >("Molecule").
        def("print_to_output", &Molecule::print).
        def("nuclear_repulsion_energy", &Molecule::nuclear_repulsion_energy);
\end{verbatim}

This first defines the keyword {\tt Molecule} to refer to the C++ {\tt
Molecule}; the {\tt shared\_ptr<Molecule>} keyword tells Python to store it as
a shared pointer, which ensures that the object will not be deleted until both
C++ and Python have no more references to it.  The member functions to be bound
are then specified by a chained sequence of {\tt def} calls (note the periods),
terminated by a semicolon.  Then, if the user had defined a molecule called
``water'', they could print its geometry simply with the command {\tt
water.print\_to\_output()}.

Direct interaction with the Psi module from Python requires function calls that
look like {\tt psi4.call\_some\_function()}.  This is not very friendly to
your average user, so a preprocessor checks for known Psi syntax and turns it
into valid Python, before handing it off for excecution.  This preprocessor is
purely Python, and lives in {\tt \$PSI4/lib/python/input.py}.  For example, the
following text \begin{verbatim}
set scf {
    SCF_TYPE DIRECT
    BASIS cc-pVDZ
    RI_BASIS_SCF cc-pVDZ-HF
    guess core
}
\end{verbatim}
is converted to the following text
\begin{verbatim}
psi4.set_default_options_for_module("SCF")
psi4.set_option("SCF_TYPE", "DIRECT")
psi4.set_option("BASIS", "cc-pVDZ")
psi4.set_option("RI_BASIS_SCF", "cc-pVDZ-HF")
psi4.set_option("GUESS", "core")
\end{verbatim}
which can be handled by Python.

There are a number of other utilities, which are entirely Python, located in
{\tt \$PSI4/lib/python}.  These provide convenient functions to the user, such
as {\tt table}.

The purpose of this manual is to provide a reasonably detailed
overview of the source code and programming philosophy of \PSIfour,
such that programmers interested in contributing to the code will have
an easier task.  Section \ref{svn} gives a succint explanation of the
steps required to obtain the source code from the main repository at
Virginia Tech.  (Installation instructions are given separately in the
installation manual or in \$PSI4/INSTALL.) \ref{Style} offers advice on
appropriate programming style for \PSIfour\ code, and section \ref{Makefiles}
describes the structure of the package's \file{Makefile}s.  Section
The appendices provide important reference material,
including the currently accepted \PSIfour\ citation and format
information for some of the most important text files used by
\PSIfour\ modules.

There are many examples included in this document to provide sample input files
and source files; these can be found in ASCII form in the \PSIfour\ source
itself.  Each included file has a path, which is relative to
\$PSI4/doc/progman, as its title and this is where the unformatted file can be
found.  The examples described herein can even be compiled from the directories
in which the source files are found.

Mention the GPL and development policies...

