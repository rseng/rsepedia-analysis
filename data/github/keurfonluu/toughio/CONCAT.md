---
title: "toughio: Pre- and post-processing Python library for TOUGH"
tags:
    - tough2
    - tough3
    - preprocessing
    - postprocessing
    - io
authors:
    - name: Keurfon Luu
      orcid: 0000-0001-7927-0019
      affiliation: 1
affiliations:
    - name: Energy Geosciences Division, Lawrence Berkeley National Laboratory, Berkeley, CA, USA
      index: 1

date: 26 July 2020
bibliography: paper.bib
---

# Statement of Need

TOUGH is a widely used general purpose numerical simulator designed for fluid and heat flows of multiphase, multicomponent fluid mixtures in porous and fractured media, which has been applied to many real-world problems such as underground geological storage, geothermal reservoir engineering or nuclear waste disposal, to name a few.

When setting up a model, the most time-consuming part is preparing the input data required to run a TOUGH simulation due to its error-prone text-based fixed-format input files and the lack of proper built-in meshing tool to model complex geological structures. In addition, a TOUGH mesh is optimally represented by a Voronoi graph as TOUGH uses an integral finite-difference formulation [@narasimhan_integrated_1976] to solve the coupled fluid and heat flow equations. A TOUGH mesh is only represented as a set of elements and connections without any reference to a coordinate system usually required for post-processing with common visualization softwares (e.g. ParaView, Tecplot and VisIt).

# Summary

In the recent years, many softwares have been developed and published to address the lack of pre- and post-processing features of TOUGH family of codes, mostly in the form of Graphical User Interfaces (GUIs) such as (free) TIM [@yeh_tim_2013], TOUGH2Viewer [@bondua_tough2viewer:_2012], (commercial) Leapfrog [@newson_application_2012], mView [@avis_mview_2012] or PetraSim [@yamamoto_petrasim_2008]. While GUIs provide a convenient integrated working environment since they do not require to have any programming knowledge, users are often limited to the features implemented in the softwares and pre- and post-processing outputs are hardly reproducible due to closed or proprietary formats. Besides, automation of runs or coupled simulations (e.g. with a mechanical simulator) cannot be carried out through a GUI. All of the aforementioned issues can be addressed by using a high level scripting language such as Python.

`toughio` is a lightweight, object-oriented and vectorized Python library that aims to provide user-friendly routines to facilitate pre- and post-processing of a TOUGH simulation. Currently, to the best of our knowledge, only PyTOUGH [@croucher_pytough_2011] offers an exhaustive list of features to carry out a complete TOUGH simulation using a scripting language. `toughio` and PyTOUGH share the same objectives, yet with different approaches. On the one hand, a PyTOUGH mesh is represented as a _MULGRAPH_ geometry where elements can be unstructured horizontally but only layered vertically (usually referred to as 2.5D). On the other hand, although it provides basic meshing features, `toughio` mostly relies on common third-party softwares (e.g. Abaqus, FLAC3D, Gmsh [@geuzaine_gmsh:_2009], LaGriT) to generate the mesh by importing and converting it to a TOUGH mesh, which also conveniently facilitates the coupling of TOUGH with any other simulator that also supports the same mesh formats. In addition, `toughio` mainly targets the latest version TOUGH3 [@jung_tough3_2017] and supports most of its new features such as the new input data blocks, the new output formats, and variable length element names. Nevertheless, `toughio` is backward compatible with TOUGH2 [@pruess_tough2_2012] and can read/write TOUGH2 input/output files.

Figure 1 shows the result of a sample CO<sub>2</sub> sequestration simulation where supercritical CO<sub>2</sub> is continuously injected during 3 years in a reservoir near a fault modeled as a finite-thickness element with high permeability. The model has been entirely set up using `toughio` with a mesh generated by Gmsh imported and pre-processed in Python thanks to `meshio` [@nico_schlomer_2020_3888325]. The conversion from a finite-element mesh to its dual-graph representation as required by TOUGH is automatically handled by `toughio` when exporting the mesh for TOUGH. Outputs of the TOUGH simulation have been imported and remapped into the original finite-element grid and directly visualized in Python thanks to `pyvista` [@sullivan_pyvista_2019].

![Example of simulation of CO<sub>2</sub> upward leakage along a fault completely developed with `toughio`. Mesh has been generated with Gmsh and imported in Python by `meshio`. Output figure has been prepared and exported by `pyvista`.](./figures/sample.png)

`toughio` offers a complete set of features to pre- and post-process a TOUGH simulation in Python. Finite-element meshes generated by third-party softwares can be imported and converted to a Voronoi graph for TOUGH, simulation parameters can be defined using a human-readable and jsonable dictionary automatically converted to a fixed-format input file for TOUGH, and simulation results can be imported in Python for post-processing and visualization.

# Acknowledgements

This material is based upon work supported by Lawrence Berkeley National Laboratory under U.S. Department of Energy Award No. DE-AC02-05CH11231.

## References
<!--
Please describe changes proposed and WHY you made them. If fixing an issue,
include the text "Fixes #XXX" (replace XXX by the issue number. GitHub will
automatically close it when this gets merged.
-->

**Reminders**:

-   [ ] Run `invoke format` to make sure the code follows the style guide,
-   [ ] Add tests for new features or tests that would have caught the bug that you're fixing,
-   [ ] Write detailed docstrings for all functions, classes and/or methods,
-   [ ] If adding new functionality, unit test it and add it to the documentation.
---
name: Bug report
about: Report a problem/bug to help us improve

---

**Description of the problem**

<!--
Please be as detailed as you can when describing an issue. The more information
we have, the easier it will be for us to track this down.
-->



**Full code that generated the error**

<!--
Include any data files or inputs required to run the code. It really helps if
we can run the code on our own machines.
-->

```python
PASTE YOUR CODE HERE
```


**Full error message**

```
PASTE ERROR MESSAGE HERE
```



**System information**

* Operating system:
* Python installation (Anaconda, system, ETS):
* Version of Python:
* Version of this package:
---
name: Feature request
about: Request the addition of a new feature/functionality

---

**Description of the desired feature**

<!--
Please be as detailed as you can in your description. If possible, include an
example of how you would like to use this feature (even better if it's a code
example).
-->

**Are you willing to help implement and maintain this feature?** Yes/No

<!--
Every feature we add is code that we will have to maintain and keep updated.
This takes a lot of effort. If you are willing to be involved in the project
and help maintain your feature, it will make it easier for us to accept it.
-->
