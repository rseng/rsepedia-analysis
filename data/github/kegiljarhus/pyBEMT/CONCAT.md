---
title: 'pyBEMT: An implementation of the Blade Element Momentum Theory in Python'
tags:
  - Python
  - BEMT
  - Wind energy
  - Tidal energy
  - Aerodynamics
  - Aerospace
  - Aeronautics
authors:
  - name: Knut Erik T. Giljarhus
    orcid: 0000-0002-4144-0454 
    affiliation: 1
affiliations:
 - name: Department of Mechanical and Structural Engineering and Materials Science, University of Stavanger, Stavanger, Norway
   index: 1
date: 03 July 2020
bibliography: paper.bib
---

# Summary

The use of rotating blades to generate thrust in the form of propellers or
torque in the form of turbines is of great significance for transportation and
energy generation. This has led to extensive research and development of
mathematical models to better understand, predict and optimize the performance
of these machines. The blade element momentum theory (BEMT) is one such method
with a long history dating back to @glauert1935airplane.  

Despite the development of more sophisticated methods, such as vortex
methods [@gohard1978free], the blade element momentum theory is still considered
relevant for the study of rotor design. Its simple formulation lends itself to
use in education and to quickly analyse new ideas. As examples of recent uses
of BEMT, it was used by @kotwicz2019rotor to compare airfoils and blade
shapes for an unmanned rotorcraft and by @borg2020, together with computational
fluid dynamics, to analyze the performance of a high-solidity tidal turbine
design. Several open-source packages include an implementation of BEMT, for
instance the `AeroDyn` [@moriarty2005aerodyn] solver used in the whole-turbine
simulation software `OpenFAST`[@OpenFAST], and the `QBlade` [@marten2013qblade]
software for wind turbine blade design. `QBlade` has later been forked to
develop `JBLADE` [@silvestre2013jblade], a software focusing on propeller
design. 

`pyBEMT` is unique in that it offers a unified implementation of the blade
element momentum theory, supporting both propellers and turbines. This is of
particular interest in education, to demonstrate the similarities between these
two domains. The software is designed as a stand-alone Python implementation
with emphasis on readability and extensibility. Its modular design and
permissive license also makes it suitable for integration into other simulation
tools. Other notable features of the package are a model for coaxial rotors and
optimization of rotor parameters using the differential evolution algorithm in
`SciPy`. The use of coaxial rotor systems has recently seen renewed interest 
with the growth in unmanned aerial vehicles and autonomous systems.

\autoref{fig:example} shows two examples of predictions from the model
for a tidal stream turbine [@bahaj2007power] and an airplane
propeller [@theodorsen1937characteristics], respectively. `pyBEMT` is currently
applied in research projects on rotor design for unmanned aerial vehicles and
turbine design for tidal stream turbines, as well as used in education within
fluid dynamics and computational engineering.  

![`pyBEMT` applied to a tidal stream turbine (left) and an airplane propeller (right).\label{fig:example}](example.png)

# Acknowledgements

J\o rgen Apeland, Vetle B. Ingebretsen and Stian R. Hidle from the University
of Stavanger are acknowledged for their contribution of experimental validation
data. 

# References
pyBEMT
======

Introduction
------------

pyBEMT is an implementation of the Blade Element Momentum Theory in Python.
The model can be used to estimate the thrust generated by a propeller or 
the power generated by a turbine.

Notable features:

- A small and unified implementation for both propellers and turbines
- A model for coaxial rotors
- Optimization of rotor parameters

Installation
------------

To install the package, first ensure that the following required libraries are installed:

- numpy
- scipy
- matplotlib
- pandas
- sphinx (for documentation)

These can be installed using the provided ``requirements.txt``,

.. code-block:: console

        pip install -r requirements.txt

Next, the package can be installed using pythontools:

.. code-block:: console

        python setup.py install

Alternatively, just add the pybemt directory to the PYTHONPATH.

Documentation
-------------

Examples on how to use the package are given in the examples directory.
Documentation is hosted on https://pybemt.readthedocs.io/ 

Contributions
-------------

Contributions are encouraged via pull requests, feature requests and bug reports on GitHub. 

License
-------

This software is released under the MIT license. See the LICENSE file for license rights and limitations.
.. highlight:: python

.. _usage:

Usage
=====


Configuration file (.ini)
-------------------------

The parameters to the solver is given in a configuration file
using the `INI <http://en.wikipedia.org/wiki/INI_file>`_ format. 

Each section and available parameters are described below.

[case]
------

- ``v_inf`` --- The inflow velocity in m/s.
- ``rpm`` --- Rotational speed of the rotor in rotations per minute.
- ``twist`` --- Optional global pitch change in degrees.
- ``coaxial`` --- Whether to add a second rotor. Set to False by default.
- ``rpm2`` --- Rotational speed of the second rotor in rotations per minute.
- ``twist2`` --- Optional global pitch change of the second rotor in degrees.
- ``dz`` --- Distance to second rotor.

[rotor]
-------

- ``nblades`` --- Number of blades.
- ``diameter`` --- Diameter in m.
- ``radius_hub`` --- Radius of hub in m.
- ``section`` --- List of airfoil sections given by airfoil name.
- ``radius`` --- List of distance to each section in m.
- ``chord`` --- List of chord length of each section in m.
- ``pitch`` --- List of pitch of each section in degrees.

[rotor2]
--------

Description of second rotor for coaxial simulations, same parameters as 
first rotor.

[fluid]
-------

- ``rho`` --- Fluid density in kg/m^3.
- ``mu`` --- Fluid dynamic viscosity in Pa s.


[solver]
--------

Optional solver settings.

- ``solver`` --- The default solver is a bisection solver. This can be replaced by a more stable brute force solver using 'brute' here.
- ``Cs`` --- Slipstream coefficient for coaxial solver.


Running a single simulation
---------------------------

To run a single simulation, we create a solver object with the 
configuration file as parameter and then execute the :meth:`solver.Solver.run` method:

.. code-block:: python

        from pybemt.solver import Solver

        s = Solver('rotor.ini')
        T, Q, P, section_df = s.run()

The solver returns the thrust [N], the torque [Nm] and the power [W]. Additionally, a pandas DataFrame with the result for each rotor section is provided.


Running a parameter sweep
-------------------------

A typical use case is to run a sweep of a parameter, for instance the 
rotational speed of the rotor. A utility function is provided for this, called
:meth:`solver.Solver.run_sweep`.

This is used in the following way:

.. code-block:: python

        from pybemt.solver import Solver

        s = Solver('rotor.ini')
        df, section_df = s.run_sweep('rpm', 20, 150, 350)

The `run_sweep` function takes as arguments the parameter to sweep, the number 
of points and the minimum and maximum values. It returns a data frame with 
values for each parameter value, as well as a list of dataframes for each
section.


Running an optimization
-----------------------

Optimizaton of parameters can easily be done using the scipy.optimize
library. Currently, only optimization of pitch is supported directly by
the library:

.. code-block:: python

        from pybemt.solver import Solver

        s = Solver('rotor.ini')
 
        pitches = s.optimize_pitch()

The differential evolution algorithm is used in the current implementation,
as it has been found to give the best results.  Each section is considered as
a separate parameter for the optimization. Using a parameterized function instead can
lead to significant speedups, but this is not currently directly supported
by the package.


Adding a new airfoil
--------------------

pyBEMT uses the same file format as the AeroDyn software. However, note 
that currently only the drag and lift tables are used and only a single 
Reynolds number is supported.

To add a new airfoil, either add the file to the airfoils directory and 
re-install the software or add the airfoil file directly to the installed
airfoils directory. The installation location can be found by running
the following code snippet: ::

        import os
        import pybemt
        print(os.path.dirname(pybemt.__file__))

.. _theory:

Theory
======

The Blade Element Momentum Theory
---------------------------------

This section contains a brief overview of the Blade Element Momentum Theory. The emphasis is on providing
unified expressions that are valid for both turbines and propellers. More thorough derivations can be found
elsewhere, e.g. [HANSEN2008]_ for wind turbines and [LEISHMAN2000]_ for helicopter propellers.

Blade Element Momentum Theory is a combination of two theories; the blade element theory and the momentum theory.
In blade element theory, we assume that each small section of a blade operates independently and calculate 
forces based on tabulated values for lift and drag for the airfoil. In momentum theory, the rotor is treated
as a disk where momentum is lost due to the work done by the rotor.

.. image:: _static/rotor_diagram.png

For a propeller, we apply power to the rotor to generate thrust along the rotation axis. For a turbine, we 
use the incoming flow to extract power generated from the torque of the rotation.  
The above figure shows a force diagram for these two situations, respectively.
A key concept in BEMT
is the induction factors. The velocity that a blade section sees is not the actual incoming flow velocity in
the axial direction or the angular velocity of the rotor in the tangential velocity. For a propeller, the 
axial velocity is increased due to the presence of the rotor and the tangential velocity is reduced due to swirl.
For a turbine, the opposite occurs. This can be expressed in a unified manner by introducing a constant, 
:math:`C`, which is 1 for a propeller and -1 for a turbine. The local velocities can then be expressed as

        .. math::
            v = (1 + Ca)V_\infty \\
            v' = (1 - Ca')\Omega R \\
            U = \sqrt{v^2+v'^2} \\

The forces on the rotor section can be written as

        .. math::
            \Delta T = \sigma\pi\rho U^2C_T r\Delta r \\
            \Delta Q = \sigma\pi\rho U^2C_Q r^2\Delta r \\

where :math:`\sigma=Bc/(2\pi R)` is the rotor solidity. The thrust and torque coefficients are calculated
from the following expressions:

        .. math::
            C_T = C_l\cos{\phi} - CC_d\sin{\phi} \\
            C_Q = C_l\sin{\phi} + CC_d\cos{\phi} \\

:math:`C_l` and :math:`C_d` are drag and lift coefficients that are found from airfoil tables, using the
local angle of attack for the airfoil, 

        .. math::
            \alpha = C(\text{pitch} - \phi)

Similar expressions for the forces can also be found from momentum theory,

        .. math::
            \Delta T = 4\pi\rho r V_\infty^2(1 + Ca)a\Delta r \\
            \Delta Q = 4\pi\rho r^3 V_\infty\Omega(1 + Ca)a'\Delta r \\

Combining these equations, we can find expressions for the induction factors directly as

        .. math::
            a = \frac{1}{\kappa - C} \\
            a' = \frac{1}{\kappa' + C} \\
            \kappa = \frac{4\sin^2{\phi}}{\sigma C_T} \\
            \kappa' = \frac{4\sin{\phi}\cos{\phi}}{\sigma C_Q} \\


Solution method
---------------

From the rotor force diagram, we see that the local inflow angle can be expressed from the local velocities as

        .. math::
            \tan \phi = \frac{(1+Ca)\Omega R}{(1-Ca')V_\infty}

To find the solution of this system of equations, we apply root-finding functions from the SciPy library
to this equation to find :math:`\phi`, where the induction factors are calculated from the above expressoins. 
Finally, the forces are calculated from the blade element equations and integrated along the rotor to find 
the total forces.

Coaxial model
-------------

.. image:: _static/coaxial_diagram.png

For a coaxial rotor setup the lower rotor will be in the slipstream created by the upper rotor, as illustrated
in the above figure. This situation is modelled here by applying an inflow velocity only on the rotor sections 
that are inside the slipstream. The velocity and size of the slipstream is found by momentum theory.

Only the case of a hovering rotor, i.e. zero velocity inflow on the upper rotor, is currently implemented.
It is also assumed that the lower rotor is a sufficient distance below the upper rotor so that the slipstream
is fully develped. For this case, the continuity equation gives

        .. math::
            V_i \pi r^2 = V_s \pi r_s^2 \\

For the momentum, the thrust generated from the upper rotor is equal to the change in momentum from the still
region to the slipstream,

        .. math::
            T = \rho V_i A V_s \\

Finally, the work done by the upper rotor is equal to the kinetic energy in the slipstream

        .. math::
            T V_i = \frac{1}{2}\rho V_i A V_s^2 \\

From these equations the following expressions for the slipstream properties are found:

        .. math::
            r_s = \frac{r}{\sqrt{2}} \\
            v_s = C_s\sqrt{\frac{2 T}{\rho A}} \\

Here, :math:`C_s` is a model constant.

.. [HANSEN2008] Hansen,  M.O.L.  2008. Aerodynamics of Wind Turbines. Earthscan Publications Ltd.
.. [LEISHMAN2000] Leishman,  J.G.  2000.  Principles  of  Helicopter  Aerodynamics.  Cambridge  University  Press. 

Validation
==========

This chapter provides some comparisons of `pyBEMT` with
experimental results on turbines and propellers.
The source code to run these simulations are found in the
examples directory of the repository.


Tidal stream turbine
--------------------

In this example the power and thrust of a tidal stream turbine is compared
against results from the experiments presented in [BAHAJ2007]_. The airfoil
data are obtained from XFOIL using the Viterna extrapolation method to obtain
360 polars.

The figure below shows the simulated power and thrust coefficients compared to
the experimental results, and good agreement can be observed.


.. image:: _static/tidal_results.png

Propeller
---------

In this example the thrust, torque and efficiency of an airplane propeller is
compared against results from the experiments presented in [THEODORSEN1937]_.
The test case used for comparison is propeller C at a pitch angle of 15
degrees. The propeller uses the CLARK Y airfoil, and the airfoil data are
obtained from XFOIL. Note that as pointed out in [MORGADO2015]_, there is a
difference in the definition of pitch angle used in the report compared to
common practice today. Hence, the pitch in the simulations is adjusted by 2
degrees compared to the pitch in the report.

The figure below shows the simulated power and thrust coefficients along with
the propeller efficiency compared to the experimental results, and good
agreement can be observed.


.. image:: _static/propeller_results.png



.. [BAHAJ2007] Bahaj A.S., et al. "Power and thrust measurements of marine current turbines under various hydrodynamic flow conditions in a cavitation tunnel and a towing tank." Renewable Energy 32.3 (2007): 407-426.

.. [THEODORSEN1937] Theodorsen T., Stickle G.W. and Brevoort, M.J. "Characteristics of six propellers including the high-speed range." Report no. 594-National Advisory Committee for Aeronautics (1937). 

.. [MORGADO2015] Morgado J., Silvestre M.A.R. and Páscoa J.C. "Validation of new formulations for propeller analysis." Journal of Propulsion and Power 31.1 (2015): 467-477.

pybemt
======

pybemt.solver module
--------------------

.. automodule:: pybemt.solver
   :members:
   :undoc-members:
   :show-inheritance:

pybemt.airfoil module
---------------------

.. automodule:: pybemt.airfoil
   :members:
   :undoc-members:
   :show-inheritance:

pybemt.rotor module
--------------------

.. automodule:: pybemt.rotor
   :members:
   :undoc-members:
   :show-inheritance:

pybemt.fluid module
--------------------

.. automodule:: pybemt.fluid
   :members:
   :undoc-members:
   :show-inheritance:


pyBEMT documentation
====================

Introduction
------------

pyBEMT is an implementation of the Blade Element Momentum Theory in Python.
The model can be used to estimate the thrust generated by a propeller or 
the power generated by a turbine.

Notable features:

- A small and unified implementation for both propellers and turbines
- A model for coaxial rotors
- Optimization of rotor parameters

Installation
------------

To install the package, first ensure that the following required libraries are installed:

- numpy
- scipy
- matplotlib
- pandas
- sphinx (for documentation)

These can be installed using the provided ``requirements.txt``,

.. code-block:: console

        pip install -r requirements.txt

Next, the package can be installed using pythontools:

.. code-block:: console

        python setup.py install

Alternatively, just add the pybemt directory to the PYTHONPATH.

Tests
-----

Testing is done using the ``unittest`` module. To run the tests, enter the tests
directory after installing the package and run

.. code-block:: console

        python -m unittest

Examples
--------

Examples on how to use the package is given in the examples directory.
For a more in-depth description on usage, refer to the 
:ref:`usage chapter.<Usage>`

Theory
------

For a description of the BEMT method and its implementation in pyBEMT,
see the :ref:`theory chapter.<Theory>`

Contributions
-------------

Contributions are encouraged via pull requests, feature requests and bug reports on GitHub. 

License
-------

This software is released under the MIT license. See the LICENSE file for license rights and limitations.

.. toctree::
   :maxdepth: 1
   :caption: Contents

   theory
   usage
   validation

.. toctree::
   :maxdepth: 1
   :caption: API documentation

   pybemt
   
* :ref:`genindex`
* :ref:`modindex`

