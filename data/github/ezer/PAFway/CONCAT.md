NEWS:

09-12-2019: Made the following changes:
1. Added some statistics explanation in the vignette
2. Changed the title of the network visualisation in the draw_network function.

19-11-2019: Made the following changes:
1. Changed the title to be shorter
2. Increased the margin in the network and heatmap figures so they produced nicer looker outputs
3. Changed T/F to TRUE/FALSE (doesn't change functionality)

11-11-2019: Made the following changes:
1. Previously, there would sometimes be the following warning:
"In 1:firstOne : numerical expression has 2 elements: only the first used"
The code still produced the correct output, but it has not been re-written so that 
the warning doesn't appear.

6-11-2019: New submission

This package includes basic functions to build networks of GO terms.  
It has separate functions for building these networks, with and without edge weights.
It also has two functions to help visualize the results with igraph and heatmaps.
09-12-2019:

I thought that maybe the really long delay in approving this package came from the fact
that it wasn't associated with a doi of a paper?  

Since this isn't possible at the moment, I've added some statistics explanations to the vignette,
which will hopefully improve the utility of the package.

I also removed the 'hello.R' file that is auto-generated by RStudio.

20-11-2020:

Here is my response to the comment:

1. Thanks, we see:

   The Title field should be in title case. Current version is:
   'Pairwise association of functional annotations'
   In title case that is:
   'Pairwise Association of Functional Annotations'

DONE

2. Is there some reference about the method you can add in the Description
field in the form Authors (year) <doi:.....>?

As I stated in point #3 in 11-11-2019: we do not have a doi to include.  This will be updated as soon as we do have one.  In fact, we wanted to get it on CRAN before submitting it to a journal, so the reviewers could test the package.  

19-11-2020:

We have addressed the following issues in the earlier submission:

1.Please shorten the title to a maximum of 65 characters.
Acronyms can be used on their own in the title as long as they are
explained in the description field.

This has been done.

2. Please never name your variables T or F.
F.i.: visualisation.R

Oops-- we had tried to make sure that they were TRUE and FALSE before submission, but we missed two instances of this!

11-11-2019:

We have addressed the following issues in the earlier submission:

1. the Authors@R field should be a call to person(), or combine such calls:
c(person(...), person(...), ...)

DONE-- see description

2. Please explain all acronyms (e.g. GO) in your Description text to avoid
misunderstandings.

DONE-- see description

If there are references describing the (theoretical background of)
methods in your package, please add these in the Description field of
your DESCRIPTION file in the form
authors (year) <doi:...>
authors (year) <arXiv:...>
authors (year, ISBN:...)
with no space after 'doi:', 'arXiv:' and angle brackets for auto-linking

3. Although we submitted an extended abstract to a conference, this does not yet have a doi because
it is currently in the process of being peer reviewed.  We will add the doi as soon we have it.

06-11-2019: 

New submission.  Other than that, no ERRORS, WARNINGS, or NOTES detected
on Mac, Windows, Ubuntu Linux, or Fedora Linux (via rhub).

An extended abstract associated with this package has been submitted to RECOMB2020.---
title: "PAFway: Pairwise Associations Between Functional Annotations in Networks and Pathways"
author: Daphne Ezer
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PAFway}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The purpose of this package is to allow the user to find pairs of annotations that are enriched in a network.  For instance, the network might be a gene regulatory network, where the nodes represent genes and the edges represent regulatory interactions between pairs of genes.  Each gene might have one or more functional annotation labels (such as GO terms) associated with them.  The user might be interested in learning whether a specific GO term is enriched upstream of a second GO term.  This function works with directed networks, with and without edge weights.  The results can be depicted as either a network or a heatmap.  

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(fig.width=8, fig.height=8)
```

## Statistics explanation:

### No edge weights

When no edge weights are considered, enrichment between pairs of genes is determined by the binomial test.

### Edge weights

When a gene network contains edge weights, we calculate the sum of the edge weights of each edge type, and we would like to know whether this value is higher than would be expected by chance. For two functional annotations $a$ and $b$, let us define $z_{a,b}$ as the sum of the edge weights of edge type $(a,b)$ in the network. Let us say that $c_{a,b}$ is the count of the number of edges of that type. $P(c_{a,b}=i)$ is the probability of observing exactly $i$ edges of type $(a,b)$ and $P(x \geq z_{a,b} | c_{a,b}=i)$  is the probability of observing a sum of edge weights greater than $z_{a.b}$ given that $c_{a,b}=i$.  The probability of observing at least $z_{a,b}$ is: % a weighted average of the probability of observing at least $z_{a,b}$ if there were exactly $c_{a,b}$ edges of edge type $(a,b)$ for all $c_{a,b}$ from $1$ to $N$ (where $N$ is the number of edges of the network). 
\begin{equation}
\label{eq:summation} 
P(x \geq z_{a,b})=\sum_{i=1}^N  P(c_{a,b}=i) P(x \geq z_{a,b} | c_{a,b}=i) 
\end{equation}

where $N$ is the number of edges in the network.  Note that $P(x \geq z_{a,b})$ is the p-value.



## Example with a random network

First, let us construct a random network with 300 nodes, 1000 edges and 14 GO terms.
```{r setup}
library(PAFway)

set.seed(123)
#Make 300 nodes
nodes=paste("node", c(1:300))
#First 3 node names:
print(nodes[1:3])

#Assign them random GO terms
randomGO=c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N")[sample(c(1:14), 300, replace=T)]
names(randomGO)=nodes
#First 3 nodes and associated GO terms:
print(randomGO[1:3])

#Make 1000 edges
edgesRandom=t(sapply(c(1:1000), function(i){
    nodes[sample(300, 2)]
 }))
#First 3 edges:
print(edgesRandom[1:3,])
```

We can also consider a random network, where each gene can have more than one functional annotation:

```{r}
#Assign each node a second GO term, separated by a '_' symbol
randomGO2=c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N")[sample(c(1:14), 300, replace=T)]
randomGO_multiple=sapply(c(1:300), function(i){paste(randomGO[i], randomGO2[i], sep="_")})
names(randomGO_multiple)=nodes

#print first 5 elements, as a demo
print(randomGO_multiple[1:5])
```

We can also select a sub-set of GO terms which we consider 'interesting':
```{r}
#Interesting GO terms:
GO_interesting=c("B", "C", "D", "F")

```

PAFway works with and without edge weights.  Here we generate random edge weights:
```{r}
random_edge_weights=rnorm(length(edgesRandom[,1]), 1, 0.001)
print(random_edge_weights[1:5])
print(length(random_edge_weights))
```

Now that we've set up some networks, we can see whether there are any enriched pairwise relationships between edges.

## Enrichment of pairwise associations without edge weights

First, we will use the main pafway function to find p-values for each function annotation pair.  We will start off with the simplest example, which doesn't use any optional parameters:
```{r}
#This will run pafway, with no edge weights, for all the GO terms 
a=pafway(randomGO, edgesRandom, unique(randomGO))
print(a[1:5, 1:5])
```

This can be displayed as either a heatmap or a network:
```{r}
draw_network(a)

draw_heatmap(a)
```

However, in this example, we do not correct for multiple hypothesis testing, so we get quite a few false positives, even though we know that we have started with a random network.  Let us re-draw these, after adjustment for multiple hypotheses.  We now see that no edges have a p-value<0.05.  
```{r}
draw_network(a, adjMethod = "bonferroni")
draw_heatmap(a, adjMethod = "bonferroni")
```

## Enrichment of pairwise associations with edge weights

Next, we'll repeat the previous analysis, but with edge weights.  We will start off with the simplest example, which doesn't use any optional parameters:
```{r}
#This will run pafway, with no edge weights, for all the GO terms 
b=pafway_edge_weights(randomGO, cbind(edgesRandom, random_edge_weights), unique(randomGO))
print(b[1:5, 1:5])
```

This can be displayed as either a heatmap or a network:
```{r}
draw_network(b)

draw_heatmap(b)
```

However, in this example, we do not correct for multiple hypothesis testing, so we get quite a few false positives, even though we know that we have started with a random network.  Let us re-draw these, after adjustment for multiple hypotheses.  We now see that no edges have a p-value<0.05.  
```{r}
draw_network(b, adjMethod = "bonferroni")
draw_heatmap(b, adjMethod = "bonferroni")
```

## More complex scenarios:

### More than one GO annotation per gene
If you use a larger database of GO terms, there may be more than one annotation per gene.  These can be appended together, separated by a "_" symbol:
```{r}
#Multiple GO terms are in: randomGO_multiple
b=pafway(randomGO_multiple, edgesRandom, unique(randomGO), exact=F)
print(b[1:5], b[1:5])
```
### Only a subset of GO annotations are interesting
It is usually recommended that you only perform this analysis on GO terms that are of particular interest to you, because otherwise you will lose a lot of statistical power by comparing pairs of GO terms that you don't care about.
```{r}
#GO terms of interest are in GO_interesting
b=pafway(randomGO, edgesRandom, GO_interesting)
print(b[1:5], b[1:5])
```
### Code is running too slowly (on a really big network) 
If you are running pafway (specifically with edge weights) on a really big network, it can take a while.  It might be worth decreasing accuracy and increasing speed.  One way to do this is to change the threshold at which a value in a pdf is rounded to zero.  Another way is to change the step size.
```{r}
#This will run pafway, with no edge weights, for all the GO terms 
b=pafway_edge_weights(randomGO, cbind(edgesRandom, random_edge_weights), unique(randomGO), step=0.001, thresholdZero=0.0001)
print(b[1:5, 1:5])
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mainpafway.R
\name{pafway_edge_weights}
\alias{pafway_edge_weights}
\title{Find pairwise-associations between annotations in a network with edge weights.}
\usage{
pafway_edge_weights(GO, edges, GOtypes, exact = TRUE,
  adjustByEdgeCount = FALSE, step = 0.001, thresholdZero = 1e-04)
}
\arguments{
\item{GO}{A vector of Strings, equal to the length of all the nodes.  The names of the vector should be the names of the nodes.  The values should either be the functional annotations, or a concatenation of the functional annotations, separated by a "_" symbol.}

\item{edges}{A matrix of Strings, with at least three columns.  Each row will represent an edge, linking the node in the first column to the node in the second column, and the third column will contain an edge weight.  Please make sure the node names are the same as those in "GO"}

\item{GOtypes}{This is a vector that contains the functional annotations or GO terms that are of interest}

\item{exact}{A boolean.  If it is true, it will look for an exact match between the term in GOtypes and the vector GO.  Otherwise, it will look for substrings.}

\item{adjustByEdgeCount}{A boolean.  If true, then the probability of observing a functional annotation will be calculated in terms of the number of nodes, but if it is false, it is calculated in terms of the number of edges that contain that node.}

\item{step}{FFT is used to speed up the calculation.  In the first step, a certain number of values are evenly sampled from the function, across its range.  This value will determine the distance between sampled points.}

\item{thresholdZero}{In order to decrease the space and time requirements, values in the probability distributions that are below a certain threshold are set to be exactly zero.  This is the threshold.}
}
\value{
A matrix that has the same number of rows and columns as length(GOtypes).  This will contain p-values.
}
\description{
Find pairwise-associations between annotations in a network with edge weights.
}
\examples{
nodes=paste("node", c(1:10))
set.seed(123)
randomGO=c("A", "B", "C")[sample(c(1:3), 10, replace=TRUE)]
names(randomGO)=nodes
edgesRandom=sapply(c(1:20), function(i){
   nodes[sample(10, 2)]
})
getBinomPvalueRandom1=pafway_edge_weights(randomGO, cbind(t(edgesRandom),
rnorm(length(edgesRandom[1,]), 1, 0.001)), unique(randomGO))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualisation.R
\name{draw_network}
\alias{draw_network}
\title{Draw network of enriched functional annotation pairs}
\usage{
draw_network(graph, pval = 0.05, adjMethod = NULL, seed = 123)
}
\arguments{
\item{graph}{The output of either the pafway or pafway_edge_weight functions}

\item{pval}{The threshold of p-value at which to draw an arrow}

\item{adjMethod}{The method for correcting for multiple hypotheses.  This can be any method that is acceptable to the p.adjust function in the stats package: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none".  If this is NULL, then no adjustment will be made.}

\item{seed}{The random seed that will be used.}
}
\value{
A matrix that has the same number of rows and columns as length(GOtypes).  This will contain p-values.
}
\description{
Draw network of enriched functional annotation pairs
}
\examples{
a=matrix(c(0.1, 0.003, 0.005, 0.004, 0.5, 0.7, 0.001, 0.002, 0.003), nrow=3)
colnames(a)=c('A', 'B', 'C')
rownames(a)=c('A', 'B', 'C')
draw_network(a)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mainpafway.R
\name{pafway}
\alias{pafway}
\title{Find pairwise-associations between annotations in a network without edge weights.}
\usage{
pafway(GO, edges, GOtypes, exact = TRUE, adjustByEdgeCount = FALSE)
}
\arguments{
\item{GO}{A vector of Strings, equal to the length of all the nodes.  The names of the vector should be the names of the nodes.  The values should either be the functional annotations, or a concatenation of the functional annotations, separated by a "_" symbol.}

\item{edges}{A matrix of Strings, with at least two columns.  Each row will represent an edge, linking the node in the first column to the node in the second column.  Please make sure the node names are the same as those in "GO"}

\item{GOtypes}{This is a vector that contains the functional annotations or GO terms that are of interest}

\item{exact}{A boolean.  If it is true, it will look for an exact match between the term in GOtypes and the vector GO.  Otherwise, it will look for substrings.}

\item{adjustByEdgeCount}{A boolean.  If true, then the probability of observing a functional annotation will be calculated in terms of the number of nodes, but if it is false, it is calculated in terms of the number of edges that contain that node.}
}
\value{
A matrix that has the same number of rows and columns as length(GOtypes).  This will contain p-values.
}
\description{
Find pairwise-associations between annotations in a network without edge weights.
}
\examples{
nodes=paste("node", c(1:10))
set.seed(123)
randomGO=c("A", "B", "C")[sample(c(1:3), 10, replace=TRUE)]
names(randomGO)=nodes
edgesRandom=sapply(c(1:100), function(i){
   nodes[sample(10, 2)]
})
pafway(randomGO, t(edgesRandom), unique(randomGO))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualisation.R
\name{draw_heatmap}
\alias{draw_heatmap}
\title{Draw network of enriched functional annotation pairs as a heatmap}
\usage{
draw_heatmap(graph, adjMethod = NULL, xlab = "downstream",
  ylab = "upstream", colPal = NULL)
}
\arguments{
\item{graph}{The output of either the pafway or pafway_edge_weight functions}

\item{adjMethod}{The method for correcting for multiple hypotheses.  This can be any method that is acceptable to the p.adjust function in the stats package: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none".  If this is NULL, then no adjustment will be made.}

\item{xlab}{The label for the x-axis of the heatmap}

\item{ylab}{The label for the y-axis of the heatmap}

\item{colPal}{The color palette of the heatmap}
}
\value{
A matrix that has the same number of rows and columns as length(GOtypes).  This will contain p-values.
}
\description{
Draw network of enriched functional annotation pairs as a heatmap
}
\examples{
nodes=paste("node", c(1:300))
set.seed(123)
randomGO=c("A", "B", "C", "D", "E", "F", "G", "H", "I",
"J", "K", "L", "M", "N")[sample(c(1:14), 300, replace=TRUE)]
names(randomGO)=nodes
edgesRandom=sapply(c(1:1000), function(i){
   nodes[sample(300, 2)]
})
getBinomPvalueRandom1=pafway(randomGO, t(edgesRandom), unique(randomGO))
draw_heatmap(getBinomPvalueRandom1)
colPal1=c(colorRampPalette(c("red3", "lightpink", "white", "white"))(20),
colorRampPalette(c("white", "white", "lightgreen", "darkgreen"))(20))
draw_heatmap(getBinomPvalueRandom1, adjMethod="bonferroni", xlab="Downstream",
ylab="Upstream", colPal=colPal1)
}
