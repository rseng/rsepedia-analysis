# SeqNet
An R package for simulating RNA-seq counts from gene-gene association networks

# Installation

SeqNet is now available on CRAN: https://cran.r-project.org/web/packages/SeqNet/index.html

``` r
# Download from CRAN for the current stable version:
install.packages('SeqNet')
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{create_empty_network}
\alias{create_empty_network}
\title{Create a network object.}
\usage{
create_empty_network(p)
}
\arguments{
\item{p}{The number of nodes in the network}
}
\value{
A network object.
}
\description{
Creates a 'network' object containing no modules.
}
\examples{
nw <- create_empty_network(10)
plot(nw) # A network with no edges.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{is_symmetric_cpp}
\alias{is_symmetric_cpp}
\title{C++ implementation to check if a matrix is symmetric}
\usage{
is_symmetric_cpp(m, tol = 1e-12)
}
\arguments{
\item{m}{A matrix to check.}

\item{tol}{A Numeric scalar >= 0. Differences smaller than tol are ignored.}
}
\value{
Returns TRUE if the matrix is symmetric and FALSE otherwise.
}
\description{
C++ implementation to check if a matrix is symmetric
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections.default}
\alias{remove_connections.default}
\title{Remove connections in a network}
\usage{
\method{remove_connections}{default}(x, prob_remove, run_checks = TRUE,
  ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_remove}{A value between 0 and 1. Each edge will be removed with 
probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired <- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections.matrix}
\alias{remove_connections.matrix}
\title{Remove connections in a network}
\usage{
\method{remove_connections}{matrix}(x, prob_remove, run_checks = TRUE,
  ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_remove}{A value between 0 and 1. Each edge will be removed with 
probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired <- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{get_adjacency_matrix.network_module}
\alias{get_adjacency_matrix.network_module}
\title{Get adjacency matrix}
\usage{
\method{get_adjacency_matrix}{network_module}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
An adjacency matrix with entry ij = 1 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
The adjacency matrix is constructed from all modules in a network.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module <- nw$modules[[1]]
get_adjacency_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/misc.R
\name{is_PD}
\alias{is_PD}
\title{Internal function to check if a matrix is positive definite}
\usage{
is_PD(x)
}
\arguments{
\item{x}{A matrix to check.}
}
\value{
Returns TRUE if the matrix is positive definite and FALSE otherwise.
}
\description{
Internal function to check if a matrix is positive definite
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{gen_zinb}
\alias{gen_zinb}
\title{Generate ZINB counts from an underlying network}
\usage{
gen_zinb(n, network, reference = NULL, params = NULL,
  library_sizes = NULL, adjust_library_size = NULL, verbose = TRUE)
}
\arguments{
\item{n}{The number of samples to generate.}

\item{network}{A 'network' object or list of 'network' objects.}

\item{reference}{Either a vector or data.frame of counts from a reference
gene expression profile. If a data.frame is provided, each column should
correspond to a gene. If both 'reference' and 'params' are NULL, then parameters
are estimated from the kidney dataset.}

\item{params}{A matrix of ZINB parameter values; each column should contain 
the size, mu, and rho parameters for a gene.}

\item{library_sizes}{A vector of library sizes. Used only if 'reference' is 
NULL.}

\item{adjust_library_size}{A boolean value. If TRUE, the library size of 
generated counts are adjusted based on the reference library sizes. If both 
'reference' and 'library_size' is NULL, then no adjustment is made. 
By default, this adjustment is made if the necessary information is provided.}

\item{verbose}{Boolean indicator for message output.}
}
\value{
A list containing the generated counts and the ZINB parameters used
to create them. If a list of networks were provided, then the results for
each network are returned as a list.
}
\description{
The count data are generated based on the gene-gene associations of an
udnerlying network. An association structure is imposed by first generating 
data from a multivariate Gaussian distribution, and counts are then obtained
through the inverse tranformation method. To generate realistic counts, either 
a reference dataset or parameters for the ZINB model (size, mu, rho) can be provided.
}
\examples{
nw <- random_network(10) # Create a random network with 10 nodes.
nw <- gen_partial_correlations(nw) # Add weights to connections in the network.
# If no reference is provided, ZINB data are generated using an internal reference.
x <- gen_zinb(20, nw)$x # Simulate 20 ZINB observations from the network.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{is_weighted.default}
\alias{is_weighted.default}
\title{Check if an object is weighted}
\usage{
\method{is_weighted}{default}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.
object are weighted by 0s and 1s, and returns TRUE otherwise. If there
are no connections in the module, then this function returns TRUE.}
}
\description{
Check if an object is weighted
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw <- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{print.network}
\alias{print.network}
\title{Print function for 'network' object.}
\usage{
\method{print}{network}(x, ...)
}
\arguments{
\item{x}{A 'network' object.}

\item{...}{Additional arguments are ignored.}
}
\value{
Prints a summary of the module.
}
\description{
Print function for 'network' object.
}
\examples{
nw <- random_network(10)
nw
print(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_adjacency_matrix.network}
\alias{get_adjacency_matrix.network}
\title{Get adjacency matrix}
\usage{
\method{get_adjacency_matrix}{network}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
An adjacency matrix with entry ij = 1 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
The adjacency matrix is constructed from all modules in a network.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module <- nw$modules[[1]]
get_adjacency_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{set_node_names}
\alias{set_node_names}
\title{Set the node names in a network}
\usage{
set_node_names(network, node_names)
}
\arguments{
\item{network}{The network to modify.}

\item{node_names}{A vector of strings containing the names for each node
in the network. If a numeric vector is provided, the values will be coerced
into strings. If 'node_names' is NULL, then the names will default to 
"1", "2", ..., "p".}
}
\value{
The modified network.
}
\description{
Set the node names in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections_to_node}
\alias{remove_connections_to_node}
\title{Remove connections to a node}
\usage{
remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to unwire.}

\item{prob_remove}{A value between 0 and 1. Each connection to 'node_index' 
will be removed with probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Remove all connections to node 1.
nw_rewired <- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{edges_from_adjacency_cpp}
\alias{edges_from_adjacency_cpp}
\title{C++ implementation for obtaining an edge list from adjacency matrix}
\usage{
edges_from_adjacency_cpp(adj)
}
\arguments{
\item{adj}{An adjacency matrix.}
}
\value{
Returns a matrix with 2 columns containing the indicies in the
lower-triangle of the matrix that are nonzero.
}
\description{
C++ implementation for obtaining an edge list from adjacency matrix
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{as_single_module}
\alias{as_single_module}
\title{Collapses all modules in network into a single module}
\usage{
as_single_module(network)
}
\arguments{
\item{network}{The 'network' object to modify}
}
\value{
The modified 'network' object.
}
\description{
This modification can be used if it is desired to simulate from a single
GGM rather than averaging over the GGMs for each module.
}
\examples{
# This function can be used prior to generating weights for the network 
# connections. With multiple modules in the network, the weighted network may
# gain conditional dependencies between nodes across modules. If the network
# is reduced to a single module prior to generating weights, then the
# weighted and unweighted networks will maintain the same structure.
nw <- random_network(20, n_modules = 3)
g <- plot(nw)
nw <- gen_partial_correlations(nw)
plot(nw, g) # Additional edges appear from conditional dependencies across modules.
nw <- remove_weights(nw) # Remove weights to avoid warning message in next call.
nw <- as_single_module(nw)
nw <- gen_partial_correlations(nw)
plot(nw, g) # With only one module, the weighted network has the same structure.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{replace_module_in_network}
\alias{replace_module_in_network}
\title{Internal function for replacing a module in the network}
\usage{
replace_module_in_network(module_index, module, network)
}
\arguments{
\item{module_index}{The index of the module to replace.}

\item{module}{The new module to replace with.}

\item{network}{The network to modify.}
}
\value{
The modified network.
}
\description{
Internal function for replacing a module in the network
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{create_module_from_association_matrix}
\alias{create_module_from_association_matrix}
\title{Create a module from an association matrix}
\usage{
create_module_from_association_matrix(association_matrix, nodes = NULL,
  module_name = NULL)
}
\arguments{
\item{association_matrix}{The association matrix used to create the module.}

\item{nodes}{A numeric vector indicating which nodes in the network are
contained in this module.}

\item{module_name}{(optional) Character string specifying the name of the 
module. If NULL, the module will be unnamed.}
}
\value{
A 'network_module' object.
}
\description{
The edge weights in the module will be set to the corresponding values
in the association matrix. The edges are undirected, and only the lower 
triangle of the matrix is considered. See ?set_module_weights for more details.
}
\examples{
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
assoc_mat <- get_association_matrix(nw)
create_module_from_association_matrix(assoc_mat)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{get_edge_weights_from_module}
\alias{get_edge_weights_from_module}
\title{Get edge weights.}
\usage{
get_edge_weights_from_module(module)
}
\arguments{
\item{module}{The 'network_module' object to get edge weights for.}
}
\value{
A vector containing the weights of each edge. If the edges are 
unweighted, then a vector of 1's is returned. If there are no edges, in the
module, then NULL is returned.
}
\description{
Get edge weights.
}
\examples{
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
module <- nw$modules[[1]]
get_edge_weights_from_module(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot_gene_pair}
\alias{plot_gene_pair}
\title{Scatter plot of two gene expressions}
\usage{
plot_gene_pair(x_list, geneA, geneB, method = "loess", se_alpha = 0.1,
  do_facet_wrap = FALSE, scales = "fixed")
}
\arguments{
\item{x_list}{A named list containing one or more n by p gene expression 
profiles, one for each group or subpopulation under consideration.}

\item{geneA}{The name of the first gene to plot. Must be either a character
string matching a column name in each matrix of x_list or an integer
to index the columns.}

\item{geneB}{The name of the second gene to plot. Must be either a character
string matching a column name in each matrix of x_list or an integer
to index the columns.}

\item{method}{Charater string either "lm" or "loess" used for plotting. 
For no line, set method = NULL.}

\item{se_alpha}{Sets transparancy of confidence interval around association 
trend line. Set to 0 to remove the confidence interval.}

\item{do_facet_wrap}{If TRUE, the groups are plotted in seperate graphs.}

\item{scales}{Only used if do_facet_wrap is TRUE. See ggplot2::facet_wrap
for details.}
}
\value{
Returns the generated plot.
}
\description{
Plots the expression of two genes for visual assessment of association.
}
\examples{
\donttest{
data(reference)
rnaseq <- reference$rnaseq
genes <- colnames(rnaseq)
plot_gene_pair(rnaseq, genes[1], genes[2])
# Suppose we had multiple data frames.
control <- rnaseq[1:100, 1:10]
treatment1 <- rnaseq[101:200, 1:10]
treatment2 <- rnaseq[201:250, 1:10]
plot_gene_pair(list(ctrl = control, trt1 = treatment1, trt2 = treatment2),
               genes[1], genes[2], method = NA)
plot_gene_pair(list(ctrl = control, trt = treatment1),
               genes[1], genes[2], do_facet_wrap = TRUE, method = "lm")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot.network_plot}
\alias{plot.network_plot}
\title{Plot function for 'network_plot' class}
\usage{
\method{plot}{network_plot}(x, ...)
}
\arguments{
\item{x}{A 'network_plot' object obtained from plot.network() or
plot_network().}

\item{...}{Additional arguments passed to plot.igraph().}
}
\description{
Plot function for 'network_plot' class
}
\examples{
nw <- random_network(10)
g <- plot(nw)
# Can change the plot by modifying the instance `g`.
# For example, make vertex size and edge width twice as big.
g$edge.width <- 2 * g$edge.width
g$vertex.size <- 2 * g$vertex.size
# Change color of verticies, edges, and vertex labels.
g$edge.color <- "orange"
g$vertex.color <- "navy"
g$vertex.label.color <- "white"
plot(g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggm.R
\name{all_networks_contain_same_modules}
\alias{all_networks_contain_same_modules}
\title{Internal function to check if a list of networks all contain the same modules.}
\usage{
all_networks_contain_same_modules(network_list)
}
\arguments{
\item{network_list}{A list of 'network' objects.}
}
\value{
A logical value; TRUE indicates the networks contain the same modules,
FALSE indicates otherwise. Note, this only checks that the modules contain
the same nodes - the structure of the modules are allowed to differ.
}
\description{
Internal function to check if a list of networks all contain the same modules.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections_to_node.default}
\alias{rewire_connections_to_node.default}
\title{Rewire connections to a node}
\usage{
\method{rewire_connections_to_node}{default}(x, node, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to rewire.}

\item{prob_rewire}{A value between 0 and 1, inclusive. Each connection to 'node' 
will be rewired with probability equal to 'prob_rewire'. Note, the degree of 
'node' is unchanged after this operation.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Rewire connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire connections to the first node.
nw_rewired <- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{qzinb}
\alias{qzinb}
\title{The Zero-Inflated Negative Binomial Distribution}
\usage{
qzinb(p, size, mu, rho, lower.tail = TRUE, log.p = FALSE)
}
\arguments{
\item{p}{A vector of probabilities}

\item{size}{The dispersion paramater used in dnbinom.}

\item{mu}{The distribution mean.}

\item{rho}{The zero-inflation parameter.}

\item{lower.tail}{Logical; if TRUE, then probabilities are P(X <= x).
Otherwise, P(X > x).}

\item{log.p}{Logical; if TRUE, then exp(p) is used.}
}
\description{
The Zero-Inflated Negative Binomial Distribution
}
\examples{
x <- rzinb(10, 1, 10, 0.1)
p <- pzinb(x, 1, 10, 0.1)
y <- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 < X < 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{remove_connections_to_node.network}
\alias{remove_connections_to_node.network}
\title{Remove connections to a node}
\usage{
\method{remove_connections_to_node}{network}(x, node, prob_remove,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to unwire.}

\item{prob_remove}{A value between 0 and 1. Each connection to 'node_index' 
will be removed with probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Remove all connections to node 1.
nw_rewired <- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{set_module_name}
\alias{set_module_name}
\title{Set the name for a module}
\usage{
set_module_name(module, module_name)
}
\arguments{
\item{module}{The 'network_module' object to modify.}

\item{module_name}{A character string.}
}
\value{
The modified 'network_module' object.
}
\description{
Set the name for a module
}
\examples{
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
module <- nw$modules[[1]]
named_module <- set_module_name(module, "new name")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_degree_distribution}
\alias{get_degree_distribution}
\title{Get the degree distribution for a network.}
\usage{
get_degree_distribution(network)
}
\arguments{
\item{network}{A network object.}
}
\value{
A vector of length p, containing the degree for each node in the 
network.
}
\description{
Counts the connections to each node within each structure. Note, this
is not the same as the degree distribution from the adjacency matrix
obtained from the network, which collapses the individual structures into
one graph.
}
\examples{
set.seed(13245)
nw <- random_network(10)
deg <- get_degree_distribution(nw) # Degree of each node.
table(deg) # Frequency table of degrees.
# Five nodes have degree 2, three nodes have degree 3, etc.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{est_params_from_reference}
\alias{est_params_from_reference}
\title{Estimate ZINB parameters from reference data}
\usage{
est_params_from_reference(reference, verbose = TRUE)
}
\arguments{
\item{reference}{Either a vector or data.frame of counts from a reference
gene expression profile. If a data.frame is provided, each column should
correspond to a gene.}

\item{verbose}{Boolean indicator for message output.}
}
\value{
Returns a list containing a matrix of parameter estimates 'size', 
'mu', and 'rho' for each gene in the reference, and the reference dataset
used.
}
\description{
The observations in the reference dataset should be as homogeneous as possible.
For example, we should not expect differential expression or differential 
connectivity of genes within the sample. If the data are heterogeneous, the
estimation of the parameters may be unreliable.
}
\examples{
# The internal reference dataset already contains ZINB parameter estimates,
# so running est_params_from_reference() is not necessary. To simulate 
# ZINB data from a different RNA-seq reference dataset, the data can
# be passed into gen_zinb() directly using the 'reference' argument, and 
# est_params_from_reference() will be used automatically (i.e. the user
# does not need to call this function directly).
\donttest{
# An example using the reference dataset
data(reference) 
# The RNA-seq dataset should have samples as rows and genes as columns:
rnaseq <- reference$rnaseq
# Estimate ZINB params for first ten genes.
params <- est_params_from_reference(rnaseq[, 1:10])$params 
# However, the previous call is not needed for simulated ZINB data.
# The RNA-seq dataset can be passed directly to `gen_zinb()`.
nw <- random_network(10)
x <- gen_zinb(20, nw, reference = rnaseq[, 1:10])$x # Pass in 'rnaseq' directly.
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_association_matrix.network}
\alias{get_association_matrix.network}
\title{Get association matrix}
\usage{
\method{get_association_matrix}{network}(x, tol = 10^-13, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{tol}{A small tolerance threshold; any entry that is within `tol` from zero
is set to zero.}

\item{...}{Additional arguments.}
}
\value{
An association matrix with entry ij != 0 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
Get association matrix
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module <- nw$modules[[1]]
get_association_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_weights.matrix}
\alias{remove_weights.matrix}
\title{Removes the weights of all connections}
\usage{
\method{remove_weights}{matrix}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Removes the weights of all connections
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw <- remove_weights(nw)
is_weighted(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_association_matrix.default}
\alias{get_association_matrix.default}
\title{Get association matrix}
\usage{
\method{get_association_matrix}{default}(x, tol = 10^-13, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{tol}{A small tolerance threshold; any entry that is within `tol` from zero
is set to zero.}

\item{...}{Additional arguments.}
}
\value{
An association matrix with entry ij != 0 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
Get association matrix
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module <- nw$modules[[1]]
get_association_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{rzinb}
\alias{rzinb}
\title{The Zero-Inflated Negative Binomial Distribution}
\usage{
rzinb(n, size, mu, rho)
}
\arguments{
\item{n}{The number of random values to return.}

\item{size}{The dispersion paramater used in dnbinom.}

\item{mu}{The distribution mean.}

\item{rho}{The zero-inflation parameter.}
}
\description{
The Zero-Inflated Negative Binomial Distribution
}
\examples{
x <- rzinb(10, 1, 10, 0.1)
p <- pzinb(x, 1, 10, 0.1)
y <- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 < X < 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot.network}
\alias{plot.network}
\title{Plot function for 'network' object}
\usage{
\method{plot}{network}(x, compare_graph = NULL, show_modules = FALSE,
  as_subgraph = FALSE, ...)
}
\arguments{
\item{x}{A 'network' object.}

\item{compare_graph}{The plot of another network to use for comparison.}

\item{show_modules}{If TRUE, the modules will highlighted in the graph. 
Defaults to FALSE if there is exactly one module in the network and to TRUE
otherwise.}

\item{as_subgraph}{If TRUE, only nodes of positive degree will be shown. 
Defaults to FALSE if there are 100 or fewer nodes in the network and to TRUE
otherwise.}

\item{...}{Additional arguments passed to plot_modules() or plot_network().}
}
\value{
Creates a plot of the module and returns a graph object. 
See ?plot_modules and ?plot_network for details.

A 'network_plot' object for the network. This object can be passed 
back into a future call of plot.network() through the `compare_graph` 
argument, which will setup the plot for easier comparison between the old 
graph and the new graph of `network`.
}
\description{
This function plots the given network. If the result of another plot is 
provided, this plot will be modified for easier comparison.
}
\examples{
nw <- random_network(10)
plot(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{remove_weights.network}
\alias{remove_weights.network}
\title{Removes the weights of all connections}
\usage{
\method{remove_weights}{network}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Removes the weights of all connections
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw <- remove_weights(nw)
is_weighted(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{get_sigma.network_module}
\alias{get_sigma.network_module}
\title{Get the covariance matrix}
\usage{
\method{get_sigma}{network_module}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A covariance matrix.
}
\description{
The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i) 
as the weight, where m_i is the number of modules containing gene i.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module <- nw$modules[[1]]
get_sigma(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{ecdf_cpp}
\alias{ecdf_cpp}
\title{C++ implementation of empirical CDF}
\usage{
ecdf_cpp(x)
}
\arguments{
\item{x}{The observation to construct the empirical CDF from.}
}
\value{
Returns the values for F(x).
}
\description{
Constructs the empirical CDF, F, for a set of observations, x, and 
returns F(x).
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{create_empty_module}
\alias{create_empty_module}
\title{Create a module}
\usage{
create_empty_module(nodes)
}
\arguments{
\item{nodes}{A numeric vector indicating which nodes in the network are
contained in this module.}
}
\value{
A 'network_module' object.
}
\description{
Create a module
}
\examples{
module <- create_empty_module(1:10)
plot(module) # A module with no edges.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cytoscape.R
\name{create_cytoscape_file}
\alias{create_cytoscape_file}
\title{Create an edge table file for Cytoscape}
\usage{
create_cytoscape_file(g)
}
\arguments{
\item{g}{A 'network_plot' object. See ?plot_network().}
}
\description{
The returned data frame can be saved as a .csv file. Then, in Cytopscape use 
File -> Import -> Network -> File. Select the .csv file containing the data
frame generated by this function. There will be a popup window. The source, 
interaction, and target columns should automatically be identified. Click OK.
}
\examples{
nw <- random_network(10)
g <- plot(nw)
nw_plot_cytoscape <- create_cytoscape_file(g)
\donttest{
# Save the edge table in a .csv file to be used in cytoscape.
write.table(nw_plot_cytoscape, file.path(tempdir(), "file_name.csv"), 
            sep = ",", row.names = FALSE, col.names = TRUE, quote = FALSE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{is_weighted.network}
\alias{is_weighted.network}
\title{Check if an object is weighted}
\usage{
\method{is_weighted}{network}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.
object are weighted by 0s and 1s, and returns TRUE otherwise. If there
are no connections in the module, then this function returns TRUE.}
}
\description{
Check if an object is weighted
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw <- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections.default}
\alias{rewire_connections.default}
\title{Rewire connections}
\usage{
\method{rewire_connections}{default}(x, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_rewire}{A value between 0 and 1. The connections to each node 
will be rewired with probability equal to 'prob_rewire'.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified module.
}
\description{
Rewire connections
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired <- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{remove_weights.network_module}
\alias{remove_weights.network_module}
\title{Removes the weights of all connections}
\usage{
\method{remove_weights}{network_module}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Removes the weights of all connections
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw <- remove_weights(nw)
is_weighted(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{components_in_adjacency}
\alias{components_in_adjacency}
\title{C++ implementation to obtain connected components in a graph.}
\usage{
components_in_adjacency(adj)
}
\arguments{
\item{adj}{An adjacency matrix.}
}
\value{
Returns a matrix with 2 columns containing the indicies in the
lower-triangle of the matrix that are nonzero.
}
\description{
C++ implementation to obtain connected components in a graph.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{get_association_matrix.network_module}
\alias{get_association_matrix.network_module}
\title{Get association matrix}
\usage{
\method{get_association_matrix}{network_module}(x, tol = 10^-13, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{tol}{A small tolerance threshold; any entry that is within `tol` from zero
is set to zero.}

\item{...}{Additional arguments.}
}
\value{
An association matrix with entry ij != 0 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
Get association matrix
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module <- nw$modules[[1]]
get_association_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_adjacency_matrix}
\alias{get_adjacency_matrix}
\title{Get adjacency matrix}
\usage{
get_adjacency_matrix(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
An adjacency matrix with entry ij = 1 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
The adjacency matrix is constructed from all modules in a network.
}
\note{
The connections in an adjacency matrix and association matrix may differ
if the network contains multiple modules. The adjacency matrix only considers 
direct connections in the network, whereas the association matrix takes into 
account the fact that overlapping modules can create conditional dependencies
between two genes in seperate modules (i.e. genes that don't have a direct
connection in the graph).
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module <- nw$modules[[1]]
get_adjacency_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{create_network_from_adjacency_matrix}
\alias{create_network_from_adjacency_matrix}
\title{Create a network object from adjacency matrix}
\usage{
create_network_from_adjacency_matrix(adjacency_matrix, ...)
}
\arguments{
\item{adjacency_matrix}{The adjacency matrix for the network. This is converted
to a single module structure.}

\item{...}{Additional arguments passed to
create_module_from_adjacency_matrix().}
}
\value{
A network object.
}
\description{
Create a network object from adjacency matrix
}
\examples{
adj_mat <- random_module_structure(10)
nw <- create_network_from_adjacency_matrix(adj_mat)
all(adj_mat == get_adjacency_matrix(nw))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_node_names.network}
\alias{get_node_names.network}
\title{Get node names}
\usage{
\method{get_node_names}{network}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A vector containing the node names or node indicies.
}
\description{
Get node names
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{dzinb}
\alias{dzinb}
\title{The Zero-Inflated Negative Binomial Distribution}
\usage{
dzinb(x, size, mu, rho = 0, log = FALSE)
}
\arguments{
\item{x}{A vector of quantities.}

\item{size}{The dispersion paramater used in dnbinom.}

\item{mu}{The distribution mean.}

\item{rho}{The zero-inflation parameter.}

\item{log}{Logical; if TRUE, then log(d) is returned.}
}
\value{
The value(s) of the density function evaluated at x.
}
\description{
The Zero-Inflated Negative Binomial Distribution
}
\examples{
x <- rzinb(10, 1, 10, 0.1)
p <- pzinb(x, 1, 10, 0.1)
y <- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 < X < 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections_to_node.matrix}
\alias{rewire_connections_to_node.matrix}
\title{Rewire connections to a node}
\usage{
\method{rewire_connections_to_node}{matrix}(x, node, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to rewire.}

\item{prob_rewire}{A value between 0 and 1, inclusive. Each connection to 'node' 
will be rewired with probability equal to 'prob_rewire'. Note, the degree of 
'node' is unchanged after this operation.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Rewire connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire connections to the first node.
nw_rewired <- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{create_module_from_adjacency_matrix}
\alias{create_module_from_adjacency_matrix}
\title{Create a module from an adjacency matrix}
\usage{
create_module_from_adjacency_matrix(adjacency_matrix, nodes = NULL,
  module_name = NULL, run_checks = TRUE)
}
\arguments{
\item{adjacency_matrix}{The adjacency matrix used to create the module.}

\item{nodes}{A numeric vector indicating which nodes in the network are
contained in this module.}

\item{module_name}{(optional) Character string specifying the name of the 
module. If NULL, the module will be unnamed.}

\item{run_checks}{If TRUE, then the 'adjacency_matrix' argument is checked.}
}
\value{
A 'network_module' object.
}
\description{
The edges in the module will be set to the edges in the adjacency matrix. 
The edges are undirected, and only the lower triangle of the
matrix is considered. See ?set_module_edges for more details.
}
\examples{
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
adj_mat <- get_adjacency_matrix(nw)
create_module_from_adjacency_matrix(adj_mat)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{is_weighted.matrix}
\alias{is_weighted.matrix}
\title{Check if an object is weighted}
\usage{
\method{is_weighted}{matrix}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.
object are weighted by 0s and 1s, and returns TRUE otherwise. If there
are no connections in the module, then this function returns TRUE.}
}
\description{
Check if an object is weighted
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw <- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{create_modules_for_network}
\alias{create_modules_for_network}
\title{Randomly sample subsets of genes for each module}
\usage{
create_modules_for_network(n_modules, p, avg_module_size = 50,
  sd_module_size = 50, min_module_size = 10, max_module_size = 200,
  sample_link_nodes_fn = sample_link_nodes,
  sample_module_nodes_fn = sample_module_nodes, ...)
}
\arguments{
\item{n_modules}{The number of modules to include in the network.}

\item{p}{The number of nodes in the network.}

\item{avg_module_size}{The average number of nodes in a module.}

\item{sd_module_size}{The standard deviation of module size.}

\item{min_module_size}{The minimum number of nodes in a module.}

\item{max_module_size}{A positive value. Any generated module sizes above this 
value will be reduced to 'max_module_size'. Set to 'Inf' to avoid this 
truncation.}

\item{sample_link_nodes_fn}{A function used for sampling link nodes for a new 
module.}

\item{sample_module_nodes_fn}{A function used for sampling nodes for a new 
module.}

\item{...}{Additional arguments passed to random_module().}
}
\value{
A list containing the indicies for genes contained in each module.
}
\description{
Creates a collection of modules containing randomly samples genes.
}
\examples{
# Create a two modules (having random structures and sizes) from a pool 
# of 100 nodes.
create_modules_for_network(n_modules = 2, p = 100)
# Set n_modules = NULL to continue making modules until all nodes have
# been selected at least once.
create_modules_for_network(n_modules = NULL, p = 100)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{sample_module_nodes}
\alias{sample_module_nodes}
\title{Sample nodes for new module}
\usage{
sample_module_nodes(n, nodes, degree, nu = 0.01, ...)
}
\arguments{
\item{n}{The number of nodes to sample.}

\item{nodes}{The nodes available to sample from.}

\item{degree}{The degree of each node.}

\item{nu}{Multiplier for nodes that are already in one or more modules.}

\item{...}{Additional arguments are ignored.}
}
\value{
A vector of selected nodes of length m.
}
\description{
Sample nodes for new module
}
\note{
This function is used by `create_modules_for_network()` 
and is not meant to be used externally.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{ring_lattice_cpp}
\alias{ring_lattice_cpp}
\title{C++ implementation for creating a ring lattice}
\usage{
ring_lattice_cpp(p, neig_size)
}
\arguments{
\item{p}{The number of nodes in the lattice.}

\item{neig_size}{The neighborhood side within which nodes are connected.}
}
\value{
Returns the adjacency matrix for the ring lattice.
}
\description{
C++ implementation for creating a ring lattice
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_node_names.default}
\alias{get_node_names.default}
\title{Get node names}
\usage{
\method{get_node_names}{default}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A vector containing the node names or node indicies.
}
\description{
Get node names
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_rnaseq.R
\name{gen_rnaseq}
\alias{gen_rnaseq}
\title{Generate RNA-seq data from an underlying network}
\usage{
gen_rnaseq(n, network, reference = NULL, verbose = TRUE)
}
\arguments{
\item{n}{The number of samples to generate.}

\item{network}{A 'network' object or list of 'network' objects.}

\item{reference}{A data.frame containing reference gene expression data. Rows
should correspond to samples and columns to genes. If NULL, then the kidney 
dataset is used.}

\item{verbose}{Boolean indicator for message output.}
}
\value{
A list containing the simulated expression data and the reference 
dataset. If a list of networks were provided, then the results for
each network are returned as a list.
}
\description{
The expression data are generated based on the gene-gene associations of an
underlying network. An association structure is imposed by first generating 
data from a multivariate Gaussian distribution. Those data are then used to
sample from the empirical distribution of gene expression profiles in the 
reference dataset using the inverse transform method.
}
\examples{
nw <- random_network(10) # Create a random network with 10 nodes.
nw <- gen_partial_correlations(nw) # Add weights to connections in the network.
# If no reference is provided, the internal RNA-seq reference dataset is used.
x <- gen_rnaseq(20, nw)$x # Simulate 20 observations from the network.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggm.R
\name{gen_partial_correlations}
\alias{gen_partial_correlations}
\title{Generate partial correlations for a list of networks.}
\usage{
gen_partial_correlations(..., k = 2.5, rweights = function(n)
  (-1)^rbinom(n, 1, 0.5) * runif(n, 0.5, 1))
}
\arguments{
\item{...}{The 'network' objects to modify.}

\item{k}{An integer that ensures the matrix inverse is numerically stable. 
k = 2.5 is default; higher values will allow for larger values of
partial correlations (and will result in a wider distribution of 
Pearson correlations).}

\item{rweights}{A generator for initial weights in the network. By default, 
values are generated uniformly from (-1, -0.5) U (0.5, 1). The weights will
be adjusted so that the sign of a generated weight and the sign of the
corresponding partial correlation agree.}
}
\value{
An updated network object containing random weights. If multiple
networks were provided, then a list of network objects is returned.
}
\description{
Random partial correlations are generated to weigh the network connections. 
If multiple networks are provided, the networks must contain the same nodes
and the same modules (the connections within modules may differ). Any 
connection that is common across different networks will also have the same 
partial correlation weight across networks.
}
\examples{
nw <- random_network(10) # Create a random network with 10 nodes.
nw <- gen_partial_correlations(nw) # Add weights to connections in the network.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_sigma.network}
\alias{get_sigma.network}
\title{Get the covariance matrix}
\usage{
\method{get_sigma}{network}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A covariance matrix.
}
\description{
The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i) 
as the weight, where m_i is the number of modules containing gene i.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module <- nw$modules[[1]]
get_sigma(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{random_module_structure}
\alias{random_module_structure}
\title{Create a random network structure for a module}
\usage{
random_module_structure(size, prob_rewire = 1, prob_remove = 0.5,
  weights = NULL, neig_size = 3, alpha = 100, beta = 1,
  epsilon = 10^-5, ...)
}
\arguments{
\item{size}{The number of nodes to include in the graph.}

\item{prob_rewire}{The probability of rewiring an edge.}

\item{prob_remove}{The probability of removing an edge.}

\item{weights}{(Optional) Weights used for sampling nodes. See 
?rewire_connections_to_node and ?remove_connections_to_node for details.}

\item{neig_size}{The neighborhood size within which the nodes of the 
ring lattice are connected. The initial degree of each node is 2 * 'neig_size',
so long as 'size' >= (1 + 2 * 'neig_size')}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{...}{Additional arguments are ignored.}
}
\value{
An adjacency matrix representing the network structure.
}
\description{
A single, connected graph is created. The graph is initialized as a ring 
lattice, and edges are randomly rewired and/or removed. The procedure
is similar to the Watts-Strogatz method, but the sampling of edges to 
modify can be based on the degree of each node.
}
\examples{
# Create a random module structure (an adjacency matrix) for 10 nodes.
adj_mat <- random_module_structure(10)
# A network object can be created using this structure.
module <- create_module_from_adjacency_matrix(adj_mat)
nw <- create_network_from_modules(10, module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{remove_connections.network}
\alias{remove_connections.network}
\title{Remove connections in a network}
\usage{
\method{remove_connections}{network}(x, prob_remove, run_checks = TRUE,
  ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_remove}{A value between 0 and 1. Each edge will be removed with 
probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired <- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_node_names.matrix}
\alias{get_node_names.matrix}
\title{Get node names}
\usage{
\method{get_node_names}{matrix}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A vector containing the node names or node indicies.
}
\description{
Get node names
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{perturb_network}
\alias{perturb_network}
\title{Perturbs the connections in a network}
\usage{
perturb_network(network, n_hubs = 1, n_nodes = 0,
  rewire_hub_prob = 0.5, rewire_other_prob = 0.5, ...)
}
\arguments{
\item{network}{The network to modify.}

\item{n_hubs}{The number of hub nodes to turn off.}

\item{n_nodes}{The number of non-hub nodes to rewire. When rewiring, the
degree of the node is unchanged.}

\item{rewire_hub_prob}{The probability that a connection is removed from
a hub that is selected to be turned off. If 'rewire_hub_prob' = 1, then
all of the connections to the hub are removed.}

\item{rewire_other_prob}{The probability that a connection is rewired from
a non-hub that is selected for rewiring. If 'rewire_other_prob' = 1, then 
all of the connections to the hub are rewired; however, this does not mean 
that all connections will be changed, as some connections may be removed
but later rewired back.}

\item{...}{Additional arguments passed to rewire_connections_to_node() and 
remove_connections_to_node()}
}
\value{
The modified network.
}
\description{
The network is perturbed by removing connections from hubs and/or rewiring
other nodes in the network. By default, one hub is turned off (i.e. its 
connections are removed each with probability 'rewire_hub_prob' = 0.5), and 
no other nodes are changed. Hub nodes are defined as those having degree
above three standard deviations from the average degree, and nodes are
sampled from these to be turned off; if there are no hub nodes, then
those with the largest degree are turned off.
}
\examples{
# Create a random network, perturb the network, then plot the differential network.
set.seed(12345)
nw <- random_network(100)
# Rewire 2 random hub genes and 10 other random genes:
nw_diff <- perturb_network(nw, n_hubs = 2, n_nodes = 10)
plot_network_diff(nw, nw_diff) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_zinb.R
\name{pzinb}
\alias{pzinb}
\title{The Zero-Inflated Negative Binomial Distribution}
\usage{
pzinb(q, size, mu, rho, lower.tail = TRUE, log.p = FALSE)
}
\arguments{
\item{q}{A vector of quantities.}

\item{size}{The dispersion paramater used in dnbinom.}

\item{mu}{The distribution mean.}

\item{rho}{The zero-inflation parameter.}

\item{lower.tail}{Logical; if TRUE, then probabilities are P(X <= x).
Otherwise, P(X > x).}

\item{log.p}{Logical; if TRUE, then log(p) is returned.}
}
\description{
The Zero-Inflated Negative Binomial Distribution
}
\examples{
x <- rzinb(10, 1, 10, 0.1)
p <- pzinb(x, 1, 10, 0.1)
y <- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 < X < 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_node_names}
\alias{get_node_names}
\title{Get node names}
\usage{
get_node_names(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A vector containing the node names or node indicies.
}
\description{
Get node names
}
\note{
Modules do not retain the names of each node, so the node indicies are
returned instead. These can be used to index into the vector of node
names obtained from the network.
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{get_node_names.network_module}
\alias{get_node_names.network_module}
\title{Get node names}
\usage{
\method{get_node_names}{network_module}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A vector containing the node names or node indicies.
}
\description{
Get node names
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module <- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix <- get_adjacency_matrix(nw)
colnames(adj_matrix) 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggm.R
\name{all_networks_contain_same_nodes}
\alias{all_networks_contain_same_nodes}
\title{Internal function to check if a list of networks all contain the same nodes.}
\usage{
all_networks_contain_same_nodes(network_list)
}
\arguments{
\item{network_list}{A list of 'network' objects.}
}
\value{
A logical value; TRUE indicates the networks contain the same nodes,
FALSE indicates otherwise.
}
\description{
Internal function to check if a list of networks all contain the same nodes.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{set_module_weights}
\alias{set_module_weights}
\title{Internal function to set the connection weights for a module}
\usage{
set_module_weights(module, weights)
}
\arguments{
\item{module}{The 'network_module' object to modify.}

\item{weights}{A vector or matrix of weights for each connetions. If a vector,
its length must equal the number of connections in the module. If a matrix,
it should be square with the number of columns equal to the number of nodes 
in the module; only the entries in the lower triangle that correspond to 
connections in the module will be used.}
}
\value{
The modified 'network_module' object.
}
\description{
Internal function to set the connection weights for a module
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{rewire_connections.network_module}
\alias{rewire_connections.network_module}
\title{Rewire connections}
\usage{
\method{rewire_connections}{network_module}(x, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_rewire}{A value between 0 and 1. The connections to each node 
will be rewired with probability equal to 'prob_rewire'.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified module.
}
\description{
Rewire connections
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired <- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggm.R
\name{gen_gaussian}
\alias{gen_gaussian}
\title{Generate observations from a Gaussian graphical model.}
\usage{
gen_gaussian(n, ...)
}
\arguments{
\item{n}{The number of samples to generate. If multiple networks are provided,
n samples are generated per network.}

\item{...}{The 'network' object(s) to generate data from. Can be a single
network, many networks, or a single list of networks.}
}
\value{
A list containing the n by p matrix of samples and the 'network'
object used to generate them.
}
\description{
Generates data based on the multivariate normal distribution parameterized by
a zero mean vector and a covariance matrix. Observations are generated for
each module in the network individually, and the covariance matrix is set to
the inverse of the standardized association matrix for the module. 
Observations are combined for gene i by taking the sum across the m_i modules 
containing it and dividing by sqrt(m_i).
}
\examples{
nw <- random_network(10) # Create a random network with 10 nodes.
nw <- gen_partial_correlations(nw) # Add weights to connections in the network.
x <- gen_gaussian(20, nw)$x # Simulate 20 Gaussian observations from network. 
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot_modules}
\alias{plot_modules}
\title{Visualize a network and its modules}
\usage{
plot_modules(network, compare_graph = NULL, as_subgraph = TRUE,
  modules = NULL, node_scale = 4, edge_scale = 1,
  node_color = adjustcolor("orange", 0.5),
  group_color = RColorBrewer::brewer.pal(9, "Set1"),
  generate_layout = igraph::nicely, include_vertex_labels = TRUE,
  show_legend = FALSE, legend_position = "topright",
  legend_horizontal = FALSE, display_plot = TRUE, ...)
}
\arguments{
\item{network}{A 'network' object to plot. Alternatively, an adjacency or
association matrix can be provided, in which case the 'modules' argument
should be specified.}

\item{compare_graph}{The plot of another network to use for comparison.}

\item{as_subgraph}{If TRUE, only nodes of positive degree will be shown.}

\item{modules}{A list of modules for the network; this is used to provide
a member list of each module when the 'network' argument is not a 'network' 
object. To get this list from a network, use 'get_network_modules()'.}

\item{node_scale}{Used for scaling of nodes.}

\item{edge_scale}{Used for scaling of edges.}

\item{node_color}{The color used for the nodes.}

\item{group_color}{A vector of colors used for the modules.}

\item{generate_layout}{A function to generate the layout of a graph; used
if coords is NULL. See ?igraph::layout_ for details. Other options include 
'igraph::as_star', 'igraph::in_circle', and 'igraph::with_fr', among many others.}

\item{include_vertex_labels}{If TRUE, the verticies will be labeled.}

\item{show_legend}{If TRUE, a legend for the modules is shown. Default is FALSE.}

\item{legend_position}{The location of the legend. Can be any one of "bottomright",
"bottom", "bottomleft", "left", "topleft", "top", "topright", "right" or "center".}

\item{legend_horizontal}{If TRUE, the legend will be displayed horizontally.}

\item{display_plot}{If TRUE (default), the plot will be generated and displayed.}

\item{...}{Additional arguments passed to plot.igraph().}
}
\value{
A 'network_plot' object for the network. This object can be passed 
back into a future call of plot.network() through the `compare_graph` 
argument, which will setup the plot for easier comparison between the old 
graph and the new graph of `network`.
}
\description{
This function plots a network and highlights the individual modules. 
An attempt is made to layout the nodes so that any visual overlaps among modules
correspond to true overlaps in the network, however it is possible that 
a node may appear to be in multiple modules in the visualization when it does
not actually belong to multiple modules. If the result of another plot is 
provided using the 'compare_graph' argument, then the layout of this network
will be based on that plot and convex hulls are drawn to trace out the modules; 
in this case it is likely that the displayed modules will contain extraneous
nodes.
}
\examples{
set.seed(1)
# Networks can be plotted with modules highlighted.
nw <- random_network(100)
g <- plot_network(nw)
plot_modules(nw, g) # Overlay convex hulls around modules in previous layout.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{is_weighted}
\alias{is_weighted}
\title{Check if an object is weighted}
\usage{
is_weighted(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.
object are weighted by 0s and 1s, and returns TRUE otherwise. If there
are no connections in the module, then this function returns TRUE.}
}
\description{
Check if an object is weighted
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw <- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{heatmap_network}
\alias{heatmap_network}
\title{Plot heatmap representation of a network}
\usage{
heatmap_network(network, main = NULL,
  col = colorRampPalette(RColorBrewer::brewer.pal(8, "Greys"))(50), ...)
}
\arguments{
\item{network}{Either a network object or association matrix of the network.}

\item{main}{A string containing the title for the graph.}

\item{col}{Color palatte used for heatmap. See ?heatmap for details.}

\item{...}{Additional arguments passed to `heatmap()`.}
}
\value{
The matrix used to create the heatmap
}
\description{
This function plots the given network as a heatmap to visualize its
connections. If the network is weighted, then the heatmap will use greyscale
colors to represent connection strengths; black squares correspond to the 
strongest connections, while lighter color squares are weaker connections.
}
\examples{
set.seed(12345)
nw <- random_network(10)
nw <- set_node_names(nw, paste("node", 1:10, sep = "_"))
heatmap_network(nw, "Unweighted Network")
nw <- gen_partial_correlations(nw)
heatmap_network(nw, "Weighted Network")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections}
\alias{remove_connections}
\title{Remove connections in a network}
\usage{
remove_connections(x, prob_remove, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_remove}{A value between 0 and 1. Each edge will be removed with 
probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired <- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_sigma.matrix}
\alias{get_sigma.matrix}
\title{Get the covariance matrix}
\usage{
\method{get_sigma}{matrix}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A covariance matrix.
}
\description{
The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i) 
as the weight, where m_i is the number of modules containing gene i.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module <- nw$modules[[1]]
get_sigma(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_adjacency_matrix.matrix}
\alias{get_adjacency_matrix.matrix}
\title{Get adjacency matrix}
\usage{
\method{get_adjacency_matrix}{matrix}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
An adjacency matrix with entry ij = 1 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
The adjacency matrix is constructed from all modules in a network.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module <- nw$modules[[1]]
get_adjacency_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{sample_link_nodes}
\alias{sample_link_nodes}
\title{Sample link nodes for new module}
\usage{
sample_link_nodes(n, nodes, degree, alpha = 100, beta = 1,
  epsilon = 10^-5, ...)
}
\arguments{
\item{n}{The number of link nodes to sample.}

\item{nodes}{The nodes to sample from.}

\item{degree}{The degree of each node.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{Used when sampling link nodes.}

\item{...}{Additional arguments are ignored.}
}
\value{
A vector of selected nodes (possibly of length 1).
}
\description{
Sample link nodes for new module
}
\note{
This function is used by `create_modules_for_network()` 
and is not meant to be used externally.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_network_characteristics}
\alias{get_network_characteristics}
\title{Characteristics of the network topology}
\usage{
get_network_characteristics(network, global_only = FALSE)
}
\arguments{
\item{network}{A 'network', 'network_module', or 'matrix' object.}

\item{global_only}{If TRUE, only the global characteristics are calculated.}
}
\value{
A list containing characteristics of the network.
}
\description{
The average degree, clustering coefficient, and average path length are calculated.
}
\examples{
nw <- random_network(10)
get_network_characteristics(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections}
\alias{rewire_connections}
\title{Rewire connections}
\usage{
rewire_connections(x, prob_rewire = 1, weights = NULL, alpha = 100,
  beta = 1, epsilon = 10^-5, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_rewire}{A value between 0 and 1. The connections to each node 
will be rewired with probability equal to 'prob_rewire'.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified module.
}
\description{
Rewire connections
}
\note{
When applied to a network object, all modules in the network are
rewired. If
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired <- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_association_matrix}
\alias{get_association_matrix}
\title{Get association matrix}
\usage{
get_association_matrix(x, tol = 10^-13, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{tol}{A small tolerance threshold; any entry that is within `tol` from zero
is set to zero.}

\item{...}{Additional arguments.}
}
\value{
An association matrix with entry ij != 0 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
Get association matrix
}
\note{
The connections in an adjacency matrix and association matrix may differ
if the network contains multiple modules. The adjacency matrix only considers 
direct connections in the network, whereas the association matrix takes into 
account the fact that overlapping modules can create conditional dependencies
between two genes in seperate modules (i.e. genes that don't have a direct
connection in the graph).
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module <- nw$modules[[1]]
get_association_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{random_module}
\alias{random_module}
\title{Create a random module}
\usage{
random_module(nodes, module_name = NULL, ...)
}
\arguments{
\item{nodes}{A numeric vector indicating which nodes in the network 
are contained in this module.}

\item{module_name}{(optional) Character string specifying the name of the 
module. If NULL, the module will be unnamed.}

\item{...}{Additional arguments passed to 'random_module_structure()'.}
}
\value{
A 'network_module' object.
}
\description{
Create a random module
}
\examples{
module <- random_module(1:10)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{remove_connections.network_module}
\alias{remove_connections.network_module}
\title{Remove connections in a network}
\usage{
\method{remove_connections}{network_module}(x, prob_remove,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_remove}{A value between 0 and 1. Each edge will be removed with 
probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections in a network
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired <- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{create_network_from_association_matrix}
\alias{create_network_from_association_matrix}
\title{Create a network object from an association matrix}
\usage{
create_network_from_association_matrix(association_matrix, ...)
}
\arguments{
\item{association_matrix}{The association matrix for the network. This is converted
to a single module structure with partial correlations specified by the
nonzero values in the matrix.}

\item{...}{Additional arguments passed to 
create_module_from_association_matrix().}
}
\value{
A network object.
}
\description{
Create a network object from an association matrix
}
\examples{
# Create a random weighted network and extract the association matrix from it.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
assoc_mat <- get_association_matrix(nw)
# Any association matrix can be used to directly create a network object.
# However, the created network will only contain one module.
nw_from_assoc <- create_network_from_association_matrix(assoc_mat)
all(get_adjacency_matrix(nw) == get_adjacency_matrix(nw_from_assoc))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{is_weighted.network_module}
\alias{is_weighted.network_module}
\title{Check if an object is weighted}
\usage{
\method{is_weighted}{network_module}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.
object are weighted by 0s and 1s, and returns TRUE otherwise. If there
are no connections in the module, then this function returns TRUE.}
}
\description{
Check if an object is weighted
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw <- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections.matrix}
\alias{rewire_connections.matrix}
\title{Rewire connections}
\usage{
\method{rewire_connections}{matrix}(x, prob_rewire = 1, weights = NULL,
  alpha = 100, beta = 1, epsilon = 10^-5, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_rewire}{A value between 0 and 1. The connections to each node 
will be rewired with probability equal to 'prob_rewire'.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified module.
}
\description{
Rewire connections
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired <- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{add_modules_to_network}
\alias{add_modules_to_network}
\title{Internal function for adding a set of modules to the network}
\usage{
add_modules_to_network(network, module_list)
}
\arguments{
\item{network}{The network to modify.}

\item{module_list}{A list of 'network_module' objects to add to the network.}
}
\value{
The modified network.
}
\description{
Internal function for adding a set of modules to the network
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{add_random_module_to_network}
\alias{add_random_module_to_network}
\title{Adds a random module of a given size to the network}
\usage{
add_random_module_to_network(network, module_size, ...)
}
\arguments{
\item{network}{The 'network' object to modify.}

\item{module_size}{The size of the module to generate.}

\item{...}{Additional arguments passed into random_module().}
}
\value{
The modified 'network' object.
}
\description{
Adds a random module of a given size to the network
}
\examples{
# This function provides an alternative way to iteratively add random
# modules to the network. It uses a weighted sampling of nodes, where
# nodes that haven't been selected for a module have a higher probability 
# of being sampled for the new module.
nw <- create_empty_network(100)
plot(nw) # An empty network of 100 nodes.
# Add random modules of size 10 to the network, 1 at a time.
# By plotting the network each time, we can watch it grow.
set.seed(12345)
plot(nw <<- add_random_module_to_network(nw, 10))
plot(nw <<- add_random_module_to_network(nw, 10))
plot(nw <<- add_random_module_to_network(nw, 10))
plot(nw <<- add_random_module_to_network(nw, 10))
plot(nw <<- add_random_module_to_network(nw, 10))
plot(nw <<- add_random_module_to_network(nw, 10))
# Etc.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{print.network_module}
\alias{print.network_module}
\title{Print function for 'network_module' object.}
\usage{
\method{print}{network_module}(x, ...)
}
\arguments{
\item{x}{A 'network_module' object.}

\item{...}{Additional arguments are ignored.}
}
\value{
Prints a summary of the module.
}
\description{
Print function for 'network_module' object.
}
\examples{
module <- random_module(1:10)
module
print(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot_network}
\alias{plot_network}
\title{Visualize a network}
\usage{
plot_network(network, compare_graph = NULL, as_subgraph = FALSE,
  node_scale = 4, edge_scale = 1, node_color = adjustcolor("orange",
  0.5), generate_layout = igraph::nicely, include_vertex_labels = TRUE,
  display_plot = TRUE, ...)
}
\arguments{
\item{network}{A 'network', 'network_module', or 'matrix' object.}

\item{compare_graph}{The plot of another network to use for comparison.}

\item{as_subgraph}{If TRUE, only nodes of positive degree will be shown.}

\item{node_scale}{Used for scaling of nodes.}

\item{edge_scale}{Used for scaling of edges.}

\item{node_color}{The color used for the nodes.}

\item{generate_layout}{A function to generate the layout of a graph; used
if coords is NULL. See ?igraph::layout_ for details. Other options include 
'igraph::as_star', 'igraph::in_circle', and 'igraph::with_fr', among many others.}

\item{include_vertex_labels}{If TRUE, the verticies will be labeled.}

\item{display_plot}{If TRUE (default), the plot will be generated and displayed.}

\item{...}{Additional arguments passed to plot.igraph().}
}
\value{
Creates a plot of the network and returns a graph object. 
The graph object can be passed back into a future call of plot.network() 
through the `compare_edge` argument, which will setup the plot for easier 
comparison between the old graph and the graph of `network`.
}
\description{
This function is used to plot a network. The 'network' argument can be a 
network object, network module, an adjacency matrix, or an association matrix. 
If the result of another plot is provided using the 'compare_graph' argument, 
then the layout of this network will be based on that plot.
}
\examples{
set.seed(0)
# Basic plotting for networks, modules, and matricies
nw <- random_network(10)
plot(nw)
module <- random_module(1:10)
plot(module)
adj_mat <- get_adjacency_matrix(nw)
plot_network(adj_mat)
# To compare multiple networks, the layout from the first plot can be used
# in subsequent plots using the second argument, `compare_graph`.
nw1 <- random_network(10)
nw2 <- remove_connections_to_node(nw1, 6, prob_remove = 1)
g <- plot(nw1)
plot(nw2, g)
# If the network contains many nodes of degree 0, plotting as subgraph
# may be preferred.
nw <- random_network(100, n_modules = 1)
plot(nw)
plot(nw, as_subgraph = TRUE)
# Networks can be plotted with modules highlighted.
nw <- random_network(100)
g <- plot_network(nw)
plot_modules(nw, g)
# For large networks, the vertex labels can clutter the graph; these can
# be removed using the `include_vertex_labels` argument.
nw <- random_network(250)
g <- plot(nw)
plot(nw, g, include = FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{is_adjacency_cpp}
\alias{is_adjacency_cpp}
\title{C++ implementation to check if a matrix is an adjacency matrix}
\usage{
is_adjacency_cpp(m)
}
\arguments{
\item{m}{A matrix to check.}
}
\value{
Returns TRUE if the matrix is an adjacency matrix and FALSE 
otherwise.
}
\description{
C++ implementation to check if a matrix is an adjacency matrix
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_weights}
\alias{remove_weights}
\title{Removes the weights of all connections}
\usage{
remove_weights(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Removes the weights of all connections
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw <- remove_weights(nw)
is_weighted(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_sigma.default}
\alias{get_sigma.default}
\title{Get the covariance matrix}
\usage{
\method{get_sigma}{default}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A covariance matrix.
}
\description{
The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i) 
as the weight, where m_i is the number of modules containing gene i.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module <- nw$modules[[1]]
get_sigma(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections_to_node.default}
\alias{remove_connections_to_node.default}
\title{Remove connections to a node}
\usage{
\method{remove_connections_to_node}{default}(x, node, prob_remove,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to unwire.}

\item{prob_remove}{A value between 0 and 1. Each connection to 'node_index' 
will be removed with probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Remove all connections to node 1.
nw_rewired <- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{rewire_connections_to_node}
\alias{rewire_connections_to_node}
\title{Rewire connections to a node}
\usage{
rewire_connections_to_node(x, node, prob_rewire = 1, weights = NULL,
  alpha = 100, beta = 1, epsilon = 10^-5, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to rewire.}

\item{prob_rewire}{A value between 0 and 1, inclusive. Each connection to 'node' 
will be rewired with probability equal to 'prob_rewire'. Note, the degree of 
'node' is unchanged after this operation.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Rewire connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire connections to the first node.
nw_rewired <- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_sigma}
\alias{get_sigma}
\title{Get the covariance matrix}
\usage{
get_sigma(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
A covariance matrix.
}
\description{
The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i) 
as the weight, where m_i is the number of modules containing gene i.
}
\note{
If a matrix is provided, it is assumed to be a partial correlation matrix;
a warning is given in this case. To avoid the warning message, convert the
matrix into a network object using 'create_network_from_association_matrix()'.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module <- nw$modules[[1]]
get_sigma(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{create_network_from_modules}
\alias{create_network_from_modules}
\title{Create a network object.}
\usage{
create_network_from_modules(p, module_list,
  node_names = as.character(1:p), ...)
}
\arguments{
\item{p}{The number of nodes in the graph}

\item{module_list}{A named list of 'network_module' objects.}

\item{node_names}{(optional) Vector of strings providing names for each node
in the graph. Default names are "1", "2", ..., "p".}

\item{...}{Additional arguments passed to random_module(); only
used if modules need to be generated.}
}
\value{
A network object.
}
\description{
Creates a graph with certain features. This network is then
used with other sample generating methods to obtain count data. Note: the
module structure is used to incorporate general pathways in the graph. These
are randomly constructed by generating a small-world graph using the Watts-Strogatz
method (implemented through igraph::watts.strogatz.game).
}
\examples{
# Networks can be crafted manually by first constructing the individual
# modules, then putting them together to create a network.
module_1 <- random_module(1:10) # A module containing nodes 1-10
module_2 <- random_module(5:15) # A module containing nodes 5-15
# Create a network containing 20 nodes and the two modules. 
nw <- create_network_from_modules(20, list(module_1, module_2))
nw 
# Note: nodes 16-20 are not in a module, so they have no connections.
plot(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_network_modules}
\alias{get_network_modules}
\title{Get a list of modules from the network}
\usage{
get_network_modules(network)
}
\arguments{
\item{network}{A 'network' object.}
}
\value{
A list whose length is the number of modules in the network; 
each element is a vector containing the indicies of the nodes
that belong to that module.
}
\description{
Get a list of modules from the network
}
\examples{
set.seed(12345)
# Create a random network of 50 nodes and modules of sizes between 5-20.
nw <- random_network(50, n_modules = 5, min_module_size = 5, 
                     max_module_size = 20, avg_module_size = 10,
                     sd_module_size = 5)
get_network_modules(nw) # Indicies of nodes contained in each module.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggm.R
\name{get_network_arguments}
\alias{get_network_arguments}
\title{Internal function used to extract 'network' objects from argument list.}
\usage{
get_network_arguments(...)
}
\arguments{
\item{...}{The 'network' object(s) or list of networks.}
}
\value{
A list of 'network' objects.
}
\description{
Internal function used to extract 'network' objects from argument list.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{set_module_edges}
\alias{set_module_edges}
\title{Internal function used to set the edges in a module}
\usage{
set_module_edges(module, edges)
}
\arguments{
\item{module}{The 'network_module' object to modify.}

\item{edges}{A matrix used to indicate the edges in the module. If the matrix
is square and contains the same number of rows and columns as nodes in 
the module, then it is assumed to be an adjacency matrix and the nonzero 
lower-triangle values of the matrix are used to indicate edges in the module.
If the matrix is not square, the first two columns are assumed to be an
edge list.}
}
\value{
The modified 'network_module' object.
}
\description{
Internal function used to set the edges in a module
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot_network_sim}
\alias{plot_network_sim}
\title{Plot the similarity between two networks}
\usage{
plot_network_sim(network_1, network_2, compare_graph = NULL, ...)
}
\arguments{
\item{network_1}{A weighted 'network' or 'matrix' object.}

\item{network_2}{A weighted 'network' or 'matrix' object.}

\item{compare_graph}{The plot of another network to use for comparison.}

\item{...}{Additional arguments passed to 'plot_network()'.}
}
\value{
Creates a plot of the network and returns a graph object. 
The graph object can be passed back into a future call of 'plot_network()',
'plot_network_diff()' or 'plot_network_sim()'
through the 'compare_edge' argument, which will setup the plot for easier 
comparison between the old graph and the graph of 'network'.
}
\description{
This function plots the similarity of connections between two networks. 
Both networks must be weighted. The width of each edge corresponds to 
the strength of similarity and is calculated by sqrt(abs((s1 + s2)s1s2)), 
where s1 and s2 are the weights for a particular
connection in network_1 and network_2, respectively
}
\examples{
# Create two networks, the second being a perturbation of the first.
nw1 <- random_network(20)
nw2 <- perturb_network(nw1, n_nodes = 5)
nw1 <- gen_partial_correlations(nw1)
nw2 <- gen_partial_correlations(nw2)
# Can compare networks by plotting each using the same layout.
g <- plot(nw1)
plot(nw2, g)
# Or, plot the differential network or similarity network
plot_network_diff(nw1, nw2, g)
plot_network_sim(nw1, nw2, g)
# Note the behavior when both networks are the same.
plot_network_diff(nw1, nw1, g) # No differences produces an empty network
plot_network_sim(nw1, nw1, g) # Edge widths are still scaled by connection strength.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{rewire_connections_to_node.network_module}
\alias{rewire_connections_to_node.network_module}
\title{Rewire connections to a node}
\usage{
\method{rewire_connections_to_node}{network_module}(x, node,
  prob_rewire = 1, weights = NULL, alpha = 100, beta = 1,
  epsilon = 10^-5, run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to rewire.}

\item{prob_rewire}{A value between 0 and 1, inclusive. Each connection to 'node' 
will be rewired with probability equal to 'prob_rewire'. Note, the degree of 
'node' is unchanged after this operation.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Rewire connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire connections to the first node.
nw_rewired <- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot_network_diff}
\alias{plot_network_diff}
\title{Plot the difference between two networks}
\usage{
plot_network_diff(network_1, network_2, compare_graph = NULL,
  as_subgraph = FALSE, node_scale = 4, edge_scale = 1,
  node_color = adjustcolor("orange", 0.5), edge_colors = c("black",
  "wheat", "red"), generate_layout = igraph::nicely,
  include_vertex_labels = TRUE, ...)
}
\arguments{
\item{network_1}{A 'network' or 'matrix' object.}

\item{network_2}{A 'network' or 'matrix' object.}

\item{compare_graph}{The plot of another network to use for comparison.}

\item{as_subgraph}{If TRUE, only nodes of positive degree will be shown.}

\item{node_scale}{Used for scaling of nodes.}

\item{edge_scale}{Used for scaling of edges.}

\item{node_color}{The color used for the nodes.}

\item{edge_colors}{A vector of three colors used for edges; the first colors
edges common to both network, the second colors edges in network_1 but not
network_2, and the third colors edges that are in network_2 but not 
network_1. Default is c("black", "wheat", "red").}

\item{generate_layout}{A function to generate the layout of a graph; used
if coords is NULL. See ?igraph::layout_ for details. Other options include 
'igraph::as_star', 'igraph::in_circle', and 'igraph::with_fr', among many others.}

\item{include_vertex_labels}{If TRUE, the verticies will be labeled.}

\item{...}{Additional arguments passed to plot.igraph().}
}
\value{
Creates a plot of the network and returns a graph object. 
The graph object can be passed back into a future call of 'plot_network()',
'plot_network_diff()' or 'plot_network_sim()'
through the 'compare_edge' argument, which will setup the plot for easier 
comparison between the old graph and the graph of 'network'.
}
\description{
This function plots the difference in connectivity between two networks. 
For two identical networks, the graph will be empty. For non-identical 
networks, black edges are shared by both networks but differ in magnitude or 
direction (if the networks are weighted), tan edges are in network_1 but not 
network_2, and red edges are in network_2 but not network_1. All edges are
scaled according to the strongest association in either network.
}
\examples{
# Create two networks, the second being a perturbation of the first.
nw1 <- random_network(20)
nw2 <- perturb_network(nw1, n_nodes = 5)
# Can compare networks by plotting each using the same layout.
g <- plot(nw1)
plot(nw2, g)
# Or, the differential network can be plotted.
plot_network_diff(nw1, nw2, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{rewire_connections.network}
\alias{rewire_connections.network}
\title{Rewire connections}
\usage{
\method{rewire_connections}{network}(x, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{prob_rewire}{A value between 0 and 1. The connections to each node 
will be rewired with probability equal to 'prob_rewire'.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified module.
}
\description{
Rewire connections
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired <- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_association_matrix.matrix}
\alias{get_association_matrix.matrix}
\title{Get association matrix}
\usage{
\method{get_association_matrix}{matrix}(x, tol = 10^-13, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{tol}{A small tolerance threshold; any entry that is within `tol` from zero
is set to zero.}

\item{...}{Additional arguments.}
}
\value{
An association matrix with entry ij != 0 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
Get association matrix
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module <- nw$modules[[1]]
get_association_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{update_module_with_random_weights}
\alias{update_module_with_random_weights}
\title{Generate small-world network structure for module}
\usage{
update_module_with_random_weights(module, rdist = function(n) {    
  runif(n, 0.5, 1) * (-1)^rbinom(n, 1, 0.5) }, ...)
}
\arguments{
\item{module}{The network_module object to modify.}

\item{rdist}{A distribution function that generates random numbers. The first
argument should specify the number of weights to generate. By default, 
weights are generated uniformly from the set (-1, -0.5)U(0.5, 1).}

\item{...}{Additional parameters are ignored.}
}
\value{
An updated 'network_module' object.
}
\description{
The small-world network is generated using the Watts-Strogatz method.
See ?igraph::watts.strogatz.game for details.
}
\examples{
# Create a random module. 
module <- random_module(1:10)
is_weighted(module)
# Add a random weight to each connection.
module <- update_module_with_random_weights(module)
is_weighted(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{random_network}
\alias{random_network}
\title{Create a network object.}
\usage{
random_network(p, n_modules = NULL, consistent_connections = FALSE,
  ...)
}
\arguments{
\item{p}{The number of nodes in the network; 'p' is required to be 
between 10 and 20000.}

\item{n_modules}{The number of modules to include in the network. If NULL,
then modules are created until all nodes in the network have positive degree.}

\item{consistent_connections}{If TRUE, then each module is modified so that,
if two genes are connected in one module, then they are connected in 
every module.}

\item{...}{Additional arguments passed to 'create_modules_for_network()',
which uses 'sample_link_nodes_fn()', 'sample_module_nodes_fn()', and
'random_module()'.}
}
\value{
An unweighted network object.
}
\description{
Creates an unweighted 'network' object containing randomly generated 
modules.
}
\examples{
# Create a random network of 10 nodes
nw <- random_network(10)
nw
# Add a random weight to each connection.
nw <- gen_partial_correlations(nw)
# Plot the network
plot(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{connect_module_structure}
\alias{connect_module_structure}
\title{Connect disconnected components in an adjacency matrix}
\usage{
connect_module_structure(adj, weights = NULL, alpha = 100, beta = 1,
  epsilon = 10^-5)
}
\arguments{
\item{adj}{An adjacency matrix to modify.}

\item{weights}{(Optional) weights used for sampling nodes.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}
}
\value{
A modified adjacency matrix
}
\description{
Connect disconnected components in an adjacency matrix
}
\note{
When connecting two components, a node is sampled from each with
probability proportional to ecdf(weights)(weights)^eta + epsilon,
where 'weights' are subset to only those nodes in the corresponding component.
When 'eta' = 0, this results in uniform sampling. When 'eta' > 0, 
nodes having larger 'weight' are more likely to be selected, where 'weight'
is equal to 'weights' + degree. (If Arugment 'weights' is NULL, then 'weight'
is simply the node degree).
}
\examples{
# This function is used in `random_module_structure()` to reconnect any
# disconnected components. To demonstrate, we'll create a random structure,
# remove connections to one of the nodes (that node will then be a disconnected
# component), and use `connect_module_structure()` to reconnect it back to
# the main component.
adj <- random_module_structure(10)
adj <- remove_connections_to_node(adj, 1, prob_remove = 1)
# Note that there are now two components in the network:
components_in_adjacency(adj) 
g <- plot_network(adj)
# After connecting, the network contains one component.
adj <- connect_module_structure(adj)
components_in_adjacency(adj) 
plot_network(adj, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_weights.default}
\alias{remove_weights.default}
\title{Removes the weights of all connections}
\usage{
\method{remove_weights}{default}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Removes the weights of all connections
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw <- remove_weights(nw)
is_weighted(nw)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{rewire_connections_to_node.network}
\alias{rewire_connections_to_node.network}
\title{Rewire connections to a node}
\usage{
\method{rewire_connections_to_node}{network}(x, node, prob_rewire = 1,
  weights = NULL, alpha = 100, beta = 1, epsilon = 10^-5,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to rewire.}

\item{prob_rewire}{A value between 0 and 1, inclusive. Each connection to 'node' 
will be rewired with probability equal to 'prob_rewire'. Note, the degree of 
'node' is unchanged after this operation.}

\item{weights}{(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.}

\item{alpha}{A positive value used to parameterize the Beta distribution.}

\item{beta}{A positive value used to parameterize the Beta distribution.}

\item{epsilon}{A small constant added to the sampling probability of each node.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified object.
}
\description{
Rewire connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Rewire connections to the first node.
nw_rewired <- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/networks.R
\name{get_summary_for_node}
\alias{get_summary_for_node}
\title{Get summary for a node in the network.}
\usage{
get_summary_for_node(node, network)
}
\arguments{
\item{node}{The node to summarize. Can be a character string 
corresponding to a name of a node in the network, or an integer value from 
1 to p corresponding to the index of a node.}

\item{network}{A network object.}
}
\value{
A list containing summary information for the node; this includes 
a vector of indicies to other nodes in the network it is connected to, and 
a vector of incidices to modules that contain the node.
}
\description{
Get summary for a node in the network.
}
\examples{
set.seed(12345)
nw <- random_network(100)
get_summary_for_node(1, nw)
# Node 1 is contained in modules 1 and 2, and it is connected to nodes 
# 2, 4, 11, 13, 23, and 29.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{print.network_plot}
\alias{print.network_plot}
\title{Print function for 'network_plot' class}
\usage{
\method{print}{network_plot}(x, ...)
}
\arguments{
\item{x}{A 'network_plot' object obtained from plot.network() or
plot_network().}

\item{...}{Additional arguments passed to plot().}
}
\description{
Displays the network plot.
}
\examples{
nw <- random_network(10)
g <- plot(nw, display_plot = FALSE) # Doesn't display the plot.
g # Displays the plot.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{get_layout_for_modules}
\alias{get_layout_for_modules}
\title{Internal function used to create coordinates based on a set of modules}
\usage{
get_layout_for_modules(g, modules)
}
\arguments{
\item{g}{An 'igraph' object}

\item{modules}{A list containing sets of indicies indicating the nodes g that 
belong to each module}
}
\value{
A matrix of coordinates for plotting
}
\description{
Internal function used to create coordinates based on a set of modules
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reference.R
\name{sample_reference_data}
\alias{sample_reference_data}
\title{Sample genes from reference dataset}
\usage{
sample_reference_data(reference_data, p, percent_ZI = NULL,
  threshold_ZI = 0.2)
}
\arguments{
\item{reference_data}{The reference data.frame to use.}

\item{p}{The number of genes (columns) to sample}

\item{percent_ZI}{The percentage of genes to be zero inflated. If
NULL, the genes are sampled at random; in this case, the empirical 
distribution of gene expression profiles will determine the probablility
that a sampled gene is zero inflated.}

\item{threshold_ZI}{The minimum proportion of zero counts for a gene to be
considered as zero inflated.}
}
\description{
Sample genes from reference dataset
}
\examples{
\donttest{
data(reference)
rnaseq <- reference$rnaseq
rnaseq_subset <- sample_reference_data(rnaseq, 10)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{get_adjacency_matrix.default}
\alias{get_adjacency_matrix.default}
\title{Get adjacency matrix}
\usage{
\method{get_adjacency_matrix}{default}(x, ...)
}
\arguments{
\item{x}{Either a 'network', 'network_module', or 'matrix' object.}

\item{...}{Additional arguments.}
}
\value{
An adjacency matrix with entry ij = 1 if node i and j are 
connected, and 0 otherwise. The diagonal entries are all zero.
}
\description{
The adjacency matrix is constructed from all modules in a network.
}
\examples{
# Create a random network with 10 nodes and add random edge weights.
nw <- random_network(10)
nw <- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module <- nw$modules[[1]]
get_adjacency_matrix(module)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{remove_connections_to_node.matrix}
\alias{remove_connections_to_node.matrix}
\title{Remove connections to a node}
\usage{
\method{remove_connections_to_node}{matrix}(x, node, prob_remove,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to unwire.}

\item{prob_remove}{A value between 0 and 1. Each connection to 'node_index' 
will be removed with probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Remove all connections to node 1.
nw_rewired <- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules.R
\name{remove_connections_to_node.network_module}
\alias{remove_connections_to_node.network_module}
\title{Remove connections to a node}
\usage{
\method{remove_connections_to_node}{network_module}(x, node, prob_remove,
  run_checks = TRUE, ...)
}
\arguments{
\item{x}{The 'network', 'network_module', or 'matrix' object to modify.}

\item{node}{The node to unwire.}

\item{prob_remove}{A value between 0 and 1. Each connection to 'node_index' 
will be removed with probability equal to 'prob_remove'.}

\item{run_checks}{If TRUE and 'x' is a matrix, then it is checked that 'x' is an
adjacency matrix. This catches the case where 'x' is a weighted matrix, in which
case the weights are removed and a warning is given.}

\item{...}{Additional arguments.}
}
\value{
The modified adjacency matrix.
}
\description{
Remove connections to a node
}
\examples{
# Create a random network with 10 nodes. 
nw <- random_network(10)
# Remove all connections to node 1.
nw_rewired <- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g <- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{reference}
\alias{reference}
\title{RNA-seq reference dataset}
\format{A list containing two data frames:
\describe{
  \item{$rnaseq}{A 1093 by 15944 data frame containing the raw RNA-seq 
  expression counts}
  \item{$params}{A 3 by 15944 data frame containing the estimated 
  ZINB parameters for each expression profile}
}}
\source{
\url{http://www.linkedomics.org/data_download/TCGA-BRCA/}
}
\usage{
reference
}
\description{
The reference is a breast invasive carcinoma dataset containing gene 
expression profiles generated by The Cancer Genome Atlas (TCGA) and 
downloaded using the LinkedOmics portal. The dataset contains 1093 samples 
and 15944 genes. The reference is a list containing a data frame of the 
expression data and a data frame of estimated ZINB parameters for each 
expression profile.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.R
\name{plot.network_module}
\alias{plot.network_module}
\title{Plot function for 'network_module' object.}
\usage{
\method{plot}{network_module}(x, ...)
}
\arguments{
\item{x}{A 'network_module' object.}

\item{...}{Additional arguments passed to plot_network().}
}
\value{
Creates a plot of the module and returns a graph object. 
See ?plot_network for details.
}
\description{
Plot function for 'network_module' object.
}
\examples{
module <- random_module(1:10)
plot(module)
}
