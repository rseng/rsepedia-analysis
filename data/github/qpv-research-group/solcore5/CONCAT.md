[![image](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/qpv-research-group/solcore5/develop?urlpath=lab)
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
[![All Contributors](https://img.shields.io/badge/all_contributors-25-orange.svg?style=flat-square)](#contributors-)
<!-- ALL-CONTRIBUTORS-BADGE:END -->
[![image](https://zenodo.org/badge/DOI/10.5281/zenodo.1185316.svg)](https://doi.org/10.5281/zenodo.1185316)
[![image](https://img.shields.io/badge/License-LGPLv3-blue.svg)](http://www.gnu.org/licenses/lgpl.html)
[![Documentation Status](http://readthedocs.org/projects/solcore5/badge/?version=latest)](http://solcore5.readthedocs.io/en/latest/?badge=latest)
![Solcore](https://github.com/qpv-research-group/solcore5/workflows/Solcore/badge.svg)
[![codecov](https://codecov.io/gh/qpv-research-group/solcore5/branch/develop/graph/badge.svg)](https://codecov.io/gh/qpv-research-group/solcore5)
[![Codacy Badge](https://api.codacy.com/project/badge/Grade/a1d2e6f702e64d878a67dcf85ce9b3b7)](https://app.codacy.com/gh/qpv-research-group/solcore5?utm_source=github.com&utm_medium=referral&utm_content=qpv-research-group/solcore5&utm_campaign=Badge_Grade_Settings)


Solcore
=======

**Solcore** was born as a modular set of tools, written (almost) entirely in Python 3, to address some of the task we had to solve more. With time, however, it has evolved as a complete semiconductor solver able of modelling the optical and electrical properties of a wide range of solar cells, from quantum well devices to multi-junction solar cells.

Please, visit [Solcore\'s Documentation](http://docs.solcore.solar), the [Tutorial](docs/source/Examples/tutorial.rst) for a step-by-step example of how to use *Solcore* to model a solar cell and also check the [Examples folder](examples) for more specific information and examples of usage.

![](docs/source/Infographics.jpg)

## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://www.imperial.ac.uk/admin-services/ict/self-service/research-support/rcs/research-software-engineering/"><img src="https://avatars.githubusercontent.com/u/6095790?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Diego Alonso Álvarez</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=dalonsoa" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Adalonsoa" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=dalonsoa" title="Documentation">📖</a> <a href="#example-dalonsoa" title="Examples">💡</a> <a href="#ideas-dalonsoa" title="Ideas, Planning, & Feedback">🤔</a> <a href="#infra-dalonsoa" title="Infrastructure (Hosting, Build-Tools, etc)">🚇</a> <a href="#maintenance-dalonsoa" title="Maintenance">🚧</a> <a href="https://github.com/qpv-research-group/solcore5/pulls?q=is%3Apr+reviewed-by%3Adalonsoa" title="Reviewed Pull Requests">👀</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=dalonsoa" title="Tests">⚠️</a><a href="#data-dalonsoa" title="Data">🔣</a></td>
    <td align="center"><a href="https://www.qpvgroup.org/phoebe-pearce"><img src="https://avatars.githubusercontent.com/u/25822065?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Phoebe Pearce</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=phoebe-p" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Aphoebe-p" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=phoebe-p" title="Documentation">📖</a> <a href="#example-phoebe-p" title="Examples">💡</a> <a href="#ideas-phoebe-p" title="Ideas, Planning, & Feedback">🤔</a> <a href="#maintenance-phoebe-p" title="Maintenance">🚧</a> <a href="https://github.com/qpv-research-group/solcore5/pulls?q=is%3Apr+reviewed-by%3Aphoebe-p" title="Reviewed Pull Requests">👀</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=phoebe-p" title="Tests">⚠️</a><a href="#data-phoebe-p" title="Data">🔣</a></td>
    <td align="center"><a href="https://github.com/twmwilson"><img src="https://avatars.githubusercontent.com/u/11062839?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Tom Wilson</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=twmwilson" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Atwmwilson" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=twmwilson" title="Documentation">📖</a> <a href="#example-twmwilson" title="Examples">💡</a> <a href="#ideas-twmwilson" title="Ideas, Planning, & Feedback">🤔</a> <a href="https://github.com/qpv-research-group/solcore5/pulls?q=is%3Apr+reviewed-by%3Atwmwilson" title="Reviewed Pull Requests">👀</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=twmwilson" title="Tests">⚠️</a><a href="#data-twmwilson" title="Data">🔣</a></td>
    <td align="center"><a href="http://www.qpvgroup.org"><img src="https://avatars.githubusercontent.com/u/128552?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ned Ekins-Daukes</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=iclned" title="Documentation">📖</a> <a href="#example-iclned" title="Examples">💡</a> <a href="#ideas-iclned" title="Ideas, Planning, & Feedback">🤔</a> <a href="#financial-iclned" title="Financial">💵</a> <a href="https://github.com/qpv-research-group/solcore5/pulls?q=is%3Apr+reviewed-by%3Aiclned" title="Reviewed Pull Requests">👀</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=iclned" title="Tests">⚠️</a></td>
    <td align="center"><a href="https://github.com/MarkusFF"><img src="https://avatars.githubusercontent.com/u/1842361?v=4?s=100" width="100px;" alt=""/><br /><sub><b>MarkusFF</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=MarkusFF" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3AMarkusFF" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=MarkusFF" title="Documentation">📖</a> <a href="#example-MarkusFF" title="Examples">💡</a> <a href="#ideas-MarkusFF" title="Ideas, Planning, & Feedback">🤔</a> <a href="#design-MarkusFF" title="Design">🎨</a><a href="#data-MarkusFF" title="Data">🔣</a></td>
    <td align="center"><a href="https://github.com/jcohen02"><img src="https://avatars.githubusercontent.com/u/8027703?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Jeremy Cohen</b></sub></a><br /><a href="#infra-jcohen02" title="Infrastructure (Hosting, Build-Tools, etc)">🚇</a></td>
    <td align="center"><a href="https://github.com/PieceMaker"><img src="https://avatars.githubusercontent.com/u/4616735?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Jonathan Adams</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=PieceMaker" title="Tests">⚠️</a> <a href="https://github.com/qpv-research-group/solcore5/pulls?q=is%3Apr+reviewed-by%3APieceMaker" title="Reviewed Pull Requests">👀</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/mhrownaghi"><img src="https://avatars.githubusercontent.com/u/56091044?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Mohammad Hosein Ronaghi</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=mhrownaghi" title="Tests">⚠️</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=mhrownaghi" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/federikovi"><img src="https://avatars.githubusercontent.com/u/17218213?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Federica Trevisan</b></sub></a><br /><a href="#example-federikovi" title="Examples">💡</a></td>
    <td align="center"><a href="https://github.com/Artyko"><img src="https://avatars.githubusercontent.com/u/30906495?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Artyko</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=Artyko" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/emmanuel-carreira"><img src="https://avatars.githubusercontent.com/u/30865344?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Emmanuel Carreira</b></sub></a><br /><a href="#example-emmanuel-carreira" title="Examples">💡</a></td>
    <td align="center"><a href="https://nimishverma.medium.com/"><img src="https://avatars.githubusercontent.com/u/17747722?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Nimish Verma</b></sub></a><br /><a href="#example-NimishVerma" title="Examples">💡</a></td>
    <td align="center"><a href="https://github.com/P-Tillmann"><img src="https://avatars.githubusercontent.com/u/23280737?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Peter Tillmann</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=P-Tillmann" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3AP-Tillmann" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=P-Tillmann" title="Tests">⚠️</a></td>
    <td align="center"><a href="https://github.com/jmllorens"><img src="https://avatars.githubusercontent.com/u/1357438?v=4?s=100" width="100px;" alt=""/><br /><sub><b>jmllorens</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=jmllorens" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Ajmllorens" title="Bug reports">🐛</a> <a href="https://github.com/qpv-research-group/solcore5/commits?author=jmllorens" title="Tests">⚠️</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/Abelarm"><img src="https://avatars.githubusercontent.com/u/6976921?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Luigi Giugliano</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=Abelarm" title="Code">💻</a> <a href="#infra-Abelarm" title="Infrastructure (Hosting, Build-Tools, etc)">🚇</a></td>
    <td align="center"><a href="https://github.com/MichaelNOz"><img src="https://avatars.githubusercontent.com/u/39320219?v=4?s=100" width="100px;" alt=""/><br /><sub><b>michael_oz</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=MichaelNOz" title="Code">💻</a></td>
    <td align="center"><a href="https://www.linkedin.com/in/hrishikesh-suresh-881020136"><img src="https://avatars.githubusercontent.com/u/30840337?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Hrishikesh Suresh</b></sub></a><br /><a href="#example-hrishikeshSuresh" title="Examples">💡</a></td>
    <td align="center"><a href="https://github.com/jscooksey"><img src="https://avatars.githubusercontent.com/u/18700514?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Justin Cooksey</b></sub></a><br /><a href="#example-jscooksey" title="Examples">💡</a></td>
    <td align="center"><a href="https://github.com/yuriy-os"><img src="https://avatars.githubusercontent.com/u/12021598?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yura Osychenko</b></sub></a><br /><a href="#design-yuriy-os" title="Design">🎨</a></td>
    <td align="center"><a href="https://github.com/canns99"><img src="https://avatars.githubusercontent.com/u/70144228?v=4?s=100" width="100px;" alt=""/><br /><sub><b>canns99</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Acanns99" title="Bug reports">🐛</a></td>
    <td align="center"><a href="https://github.com/AndiPOz"><img src="https://avatars.githubusercontent.com/u/66819562?v=4?s=100" width="100px;" alt=""/><br /><sub><b>AndiPOz</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3AAndiPOz" title="Bug reports">🐛</a></td>
  </tr>
  <tr>
    <td align="center"><a href="http://jaib.home.blog"><img src="https://avatars.githubusercontent.com/u/31744868?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Jai Agarwal</b></sub></a><br /><a href="#example-jaibhageria" title="Examples">💡</a></td>
    <td align="center"><a href="https://github.com/jkrich"><img src="https://avatars.githubusercontent.com/u/29390895?v=4?s=100" width="100px;" alt=""/><br /><sub><b>jkrich</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/commits?author=jkrich" title="Code">💻</a> <a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Ajkrich" title="Bug reports">🐛</a></td>
    <td align="center"><a href="https://github.com/Rushil17D070020"><img src="https://avatars.githubusercontent.com/u/89643859?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Rushil17D070020</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3ARushil17D070020" title="Bug reports">🐛</a></td>
    <td align="center"><a href="https://github.com/etervo"><img src="https://avatars.githubusercontent.com/u/51174646?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Eric Tervo</b></sub></a><br /><a href="https://github.com/qpv-research-group/solcore5/issues?q=author%3Aetervo" title="Bug reports">🐛</a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

This project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at d.alonso-alvarez@imperial.ac.uk. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/
# Contributing to Solcore

Thanks for taking the time to contribute to Solcore!

The following is a set of guidelines for contributing to Solcore, a multi-scale, Python-based library for the modelling of solar cells and semiconductor materials. The goal of these guidelines is to make the development of the package efficient and sustainable and to ensure that every commit makes it better, more readable, more robust and better documented. Please, feel free suggest changes and improvements. 

(this guide is based on the [Atom editor guide](https://github.com/atom/atom/blob/master/CONTRIBUTING.md))

#### Table Of Contents

[Code of Conduct](#code-of-conduct)

[How Can I Contribute?](#how-can-i-contribute)
  * [Reporting Bugs](#reporting-bugs)
  * [Suggesting Enhancements](#suggesting-enhancements)
  * [Your First Code Contribution](#your-first-code-contribution)
  * [Pull Requests](#pull-requests)

[Styleguides](#styleguides)
  * [Git Commit Messages](#git-commit-messages)
  * [Documentation Styleguide](#documentation-styleguide)

## Code of Conduct

This project and everyone participating in it is governed by the [Solcore Code of Conduct](CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code. Please report unacceptable behavior to [the repository Administrator](mailto:d.alonso-alvarez@imperial.ac.uk).

## How Can I Contribute?

### Reporting Bugs

This section guides you through submitting a bug report for Solcore. Following these guidelines helps maintainers and the community understand your report :pencil:, reproduce the behavior :computer: :computer:, and find related reports :mag_right:.

Before creating bug reports, please check [this list](https://github.com/dalonsoa/solcore5/issues) (including the closed issues) as you might find out that you don't need to create one. When you are creating a bug report, please [include as many details as possible](#how-do-i-submit-a-good-bug-report). 

> **Note:** If you find a **Closed** issue that seems like it is the same thing that you're experiencing, open a new issue and include a link to the original issue in the body of your new one.

#### How Do I Submit A (Good) Bug Report?

Bugs are tracked as [GitHub issues](https://guides.github.com/features/issues/). Explain the problem and include additional details to help maintainers reproduce the problem:

* **Use a clear and descriptive title** for the issue to identify the problem.
* **Describe the exact steps which reproduce the problem** in as many details as possible. For example, start by explaining how you installed Solcore and what you where trying to do.
* **Provide specific examples to demonstrate the steps**. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use [Markdown code blocks](https://help.github.com/articles/markdown-basics/#multiple-lines).
* **Describe the behavior you observed after following the steps** and point out what exactly is the problem with that behavior.
* **Explain which behavior you expected to see instead and why.**
* **If there is any error output in the temrinal, include that output with your report.**

Provide more context by answering these questions:

* **Did the problem start happening recently** (e.g. after updating to a new version of Solcore) or was this always a problem?
* If the problem started happening recently, **can you reproduce the problem in an older version of Solcore?** What's the most recent version in which the problem doesn't happen? You can download older versions of Solcore from [the releases page](https://github.com/dalonsoa/solcore5/releases).
* **Can you reliably reproduce the issue?** If not, provide details about how often the problem happens and under which conditions it normally happens.

Include details about your configuration and environment:

* **Which version of Solcore are you using?** 
* **What's the name and version of the OS you're using**?
* **Are you running Solcore in a virtual machine?** If so, which VM software are you using and which operating systems and versions are used for the host and the guest?
* **If the problem is related with the Poisson-drift-diffusion solver**, which compiler did you use? What were the installation steps you followed?

### Suggesting Enhancements

This section guides you through submitting an enhancement suggestion for Solcore, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion :pencil: and find related suggestions :mag_right:.

Before creating enhancement suggestions, please check [this list](https://github.com/dalonsoa/solcore5/issues) (including closed issues) as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please [include as many details as possible](#how-do-i-submit-a-good-enhancement-suggestion).

#### How Do I Submit A (Good) Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://guides.github.com/features/issues/). Create an issue on that repository and provide the following information:

* **Use a clear and descriptive title** for the issue to identify the suggestion.
* **Provide a step-by-step description of the suggested enhancement** in as many details as possible.
* **Describe the current behavior** and **explain which behavior you expected to see instead** and why.
* **Explain why this enhancement would be useful** to most Solcore users, maybe including some links to scientific papers showing the enhancement in action.
* **List some other packages or applications where this enhancement exists.**
* **Specify the name and version of the OS you're using.**

### Your First Code Contribution

Unsure where to begin contributing to Atom? You can start by looking through these `beginner` and `help-wanted` issues:

* [Beginner issues](https://github.com/dalonsoa/solcore5/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) - issues which should only require a few lines of code, and a test or two.
* [Help wanted issues](https://github.com/dalonsoa/solcore5/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) - issues which should be a bit more involved than `beginner` issues.

### Pull Requests

The process described here has several goals:

- Maintain Solcore's quality
- Fix problems that are important to users
- Engage the community in working toward the best possible Solcore
- Enable a sustainable system for Solcore's maintainers to review contributions

Please follow these steps to have your contribution considered by the maintainers:

1. **Describe clearly what is the purpose of the pull request**. Refer to the relevant issues on [Bugs](#reporting-bugs) or [Enhancements](#suggesting-enhancements). In general, an issue should always be open *prior* to a pull request, to discuss its contents with a maintainer and make sure it makes sense for Solcore. If the pull request is a work in progress that will take some time to be ready but still you want to discuss it with the community, open a [draft pull request](https://github.blog/2019-02-14-introducing-draft-pull-requests/). 
2. **Include relevant unit tests and integration tests, where needed**. Solcore's test suite is quite limited at the moment. We are working to improve this and tests as many features as possible, so any new addition to the code must come with its own set of tests to avoid going backwards in this matter.   
3. **For new features and enhancements, include documentation and examples**. Both in the code, as docstrings in classes, functions and modules, and as proper documentation describing how to use the new feature. 
4. Follow the [styleguides](#styleguides)
5. After you submit your pull request, verify that all [status checks](https://help.github.com/articles/about-status-checks/) are passing <details><summary>What if the status checks are failing?</summary>If a status check is failing, and you believe that the failure is unrelated to your change, please leave a comment on the pull request explaining why you believe the failure is unrelated. A maintainer will re-run the status check for you. If we conclude that the failure was a false positive, then we will open an issue to track that problem with our status check suite.</details>

While the prerequisites above must be satisfied prior to having your pull request reviewed, the reviewer(s) may ask you to complete additional design work, tests, or other changes before your pull request can be ultimately accepted.

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line
* When only changing documentation, include `[ci skip]` in the commit title
* Consider starting the commit message with an applicable emoji:
    * :art: `:art:` when improving the format/structure of the code
    * :racehorse: `:racehorse:` when improving performance
    * :non-potable_water: `:non-potable_water:` when plugging memory leaks
    * :memo: `:memo:` when writing docs
    * :penguin: `:penguin:` when fixing something on Linux
    * :apple: `:apple:` when fixing something on macOS
    * :checkered_flag: `:checkered_flag:` when fixing something on Windows
    * :bug: `:bug:` when fixing a bug
    * :fire: `:fire:` when removing code or files
    * :green_heart: `:green_heart:` when fixing the CI build
    * :white_check_mark: `:white_check_mark:` when adding tests
    * :lock: `:lock:` when dealing with security
    * :arrow_up: `:arrow_up:` when upgrading dependencies
    * :arrow_down: `:arrow_down:` when downgrading dependencies
    * :shirt: `:shirt:` when removing linter warnings
    
### Documentation Styleguide

* Use [Markdown](https://daringfireball.net/projects/markdown).
* Reference methods and classes in markdown with the custom `{}` notation:
    * Reference classes with `{ClassName}`
    * Reference instance methods with `{ClassName::methodName}`
    * Reference class methods with `{ClassName.methodName}`
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.


**To Reproduce**
Steps to reproduce the behavior:


**Expected behavior**
A clear and concise description of what you expected to happen.


**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Solcore Version [e.g. 22]


**Additional context**
Add any other context about the problem here.
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
---
name: Question
about: Ask a question about Solcore and it’s use
title: ''
labels: question
assignees: ''

---

**Please, confirm the following:**

- [ ] I have checked [Solcore’s documentation](http://docs.solcore.solar/en/master/) and could not find the answer.
- [ ] I haven’t found any [other issue](https://github.com/qpv-research-group/solcore5/issues?q=) on a related topic.

**What’s the question?**
Please, be concise and straight to the point

**Additional information**
Add any other relevant information that could help us answering your question, E.g.:
- Code of a minimum working example showing what you’re trying to do.
- Screenshot showing the problem you are talking about.
- Context in which your question applies
# Fortran Compilers

In order to use the Poisson-Drift-diffusion solver, it will be necessary to have a suitable fortran compiler installed and correctly configured in your system. After that, you do not need to worry about the compilation process: it is done automatically by the installation script. 

## Linux

Most linux systems have a Fortran compiler already installed, typically part of GCC, the GNU compiler collection. If not, you will need to check how to install it for your particular linux distribution. 

## Mac OS X

For Mac OS X we have used the *gfortran* compiler installed together with GCC using [Homebrew](https://brew.sh), a MacOS package manager.  

```brew install gcc```

Other package managers like [MacPorts](https://www.macports.org) or [Fink](http://www.finkproject.org) might also work, but we have not tried. 

## Windows

To get a Fortran compiler properly working under Windows with F2Py, we have followed the [detailed instructions written by Michael Hirsch](https://www.scivision.co/f2py-running-fortran-code-in-python-on-windows/). Read Michael Hirsch's instructions in full for a complete picture, but the important bits are:

1. Install [MSYS2 and MinGW](https://www.scivision.co/install-msys2-windows)

	Follow the instructions there to update all packages and to setup your environment.

2. Install the fortran compiler executing from the PowerShell:

	```bash
	pacman -S mingw-w64-x86_64-gcc-fortran
	````
    
3. Tell Python to use MinGW: create file ```~/pydistutils.cfg``` containing:

    ```
    [build]
    compiler=mingw32
    ```
	
	You can do this executing in the PowerShell
	
	```bash
	echo "[build]`ncompiler=mingw32" | Out-File -Encoding ASCII ~/pydistutils.cfg
	````

And that should be it. With this, your will be able to call the gfortran compiler from the Windows terminal and also the Solcore installer should be able to find it. You can try installing Solcore itself or with the *lowtran* package described in the instructions by [Michael Hirsch](https://www.scivision.co/f2py-running-fortran-code-in-python-on-windows/). Solcore on Windows 10
=====================
The Python part of Solcore, which is the majority, should work under Windows with no problems. However, we have found a lot trouble trying to make the parts and complements that require compilation to work properly (the PDD solver, S4, SMARTS and SPICE). For those who need to use those tools, please follow the instructions below. 

Installing Solcore
------------------
(thanks Phoebe!)

After a lot of effort, we have Solcore fully up and running in Windows 10... more or less, using the Ubuntu shell that comes with Windows 10. To install Solcore there, follow this steps:

All steps on fresh install of Ubuntu (using the Ubuntu terminal on
Windows 10 distributed by Canonical Group, Ubuntu 16.04.3 LTS, Codename:
xenial)

-  Install git if not done already
-  Install python 3.x if not already done
-  Install pip3 (for installing Python3 packages; you may need to update the package list first: sudo apt-get update)::

```bash
sudo apt install python3-pip
```
- You need LAPACK and BLAS libraries linked to the -llapack and -lblas library flags – these are used for scipy and S4. The developers of S4 recommend OpenBLAS (you can find installation instructions by Googling), but this also works and is simpler:

```bash
sudo apt-get install libblas-dev liblapack-dev
```

-  Install matplotlib (and tk, otherwise get an error later):
    
```bash
pip3 install matplotlib
sudo apt-get install python3-tk 
```

-  Other dependencies install automatically & successfully when
      installing Solcore5... hopefully.

-  Now, we actually Install Solcore::

```bash
git clone https://github.com/dalonsoa/solcore5.git
cd solcore5
sudo python3 setup.py install
```

Installing S4
-------------

-  The “make” command must be available:

```bash
sudo apt install make
```

-  You must use the fork of S4 at https://github.com/phoebe-p/S4; the
      main branch is not compatible with Python 3.x:

```bash
git clone https://github.com/phoebe-p/S4.git
cd S4
make S4_pyext
```

Checking if everything works 
--------------------------

- To see if the PDD is working:

```bash
python3
>>> import solcore.solar_cell_solver
```

-  Run tests:

```bash
sudo python3 setup.py test
```

This might result in an error saying that quantum mechanics failed because 5\ :sup:`th` decimal place of result doesn’t match. Simply, ignore it.

- Other information:
    - gcc/g++/gfortran versions used here: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.6)

    -  If everything is working correctly, should be able to import
      solcore.solar_cell_solver without getting warnings about the RCWA
      solver or PDD.

    -  Sometimes, an issue arises with the SOPRA database (and occasionally
   importing solar_cell_solver?) where the permissions are set such that
   you cannot access the database – running sudo python3, or sudo
   [whatever python editor you’re using] fixes this.

Installing SMARTS Windows10/Ubuntu Shell 
----------------------------------------
(thanks Andrew!)

* Register and download SMARTS FOR MAC from http://www.nrel.gov/rredc/smarts/    Yes, we are going to use a Mac software on Windows. Hold on tight.
* Move the SMARTS_xxx_Mac.tar.gz file from Windows to the dedicated Ubuntu folder (e.g. ~$ mv /mnt/c/Users/Andrew/Downloads ~/)
* Unpack the file (~$ tar zxf SMARTS_xxx_Mac.tar.gz)
* The executable script "smarts295.command" in the folder won't work (try running ~$ ./smarts295.command). For example on 64bit Windows the following error is thrown, requiring the source to be recompiled:

```
Source_code/smarts295_cmd: 1: Source_code/smarts295_cmd: dJ: not found
Source_code/smarts295_cmd: 1: Source_code/smarts295_cmd: ȅ8__PAGEZERO__TEXT: not found
Source_code/smarts295_cmd: 1: Source_code/smarts295_cmd: Syntax error: word unexpected (expecting ")")
```

#### Recompiling SMARTS   

* Move to the directory /SMARTS_295_Mac/Source_code/
* Delete the file "smarts295_cmd" (type ~$ rm smarts_cmd). This will need to be recompiled on for your CPU architecture
* Assuming you have gfortran installed (either as part of Anaconda or another third party distribution) you should compile smarts (type ~$ gfortran smarts295.f) which results in an executable called "a.out"
	* N.B. Although the SMARTS documentation suggests changing some flags in the source code you _should not modify_ the SMARTS source code.  Solcore expects the default behaviour with respect to batch mode and file overwrites.  
* Rename the file "a.out" to "smarts295_cmd". Now SMARTS has been recompiled for your CPU architecture.
* IMPORTANT FOR WINDOWS: Solcore on Windows10/Ubuntu looks for the script called "smarts295", instead of "smarts295.command", due to different naming systems in Linux and Mac. Rename "smarts295.command" to just "smarts295".
* You can test the installation of SMARTS using the example file Figure8.py
* Please note that running SMARTS from the command line (typing ~$ ./smarts295) will produce two text files, "smarts295.ext.txt" and "smarts295.out.txt".
   If these are in the SMARTS root folder, they will mess up running SMARTS on Solcore. If you do run SMARTS in the command line, remove these files when you are done.

Solcore on Mac OS X
=====================

Solcore has been heavely tested under Mac OS X, so there should be no problems. However, using NGSPICE requires some details, as shown below.

Installing NGSpice on MacOSX
----------------------------

* Download NGSpice from 
[http://ngspice.sourceforge.net/download.html](http://ngspice.sourceforge.net/download.html)
* Installing the binary package on mac os X will result in the executable residing in ```/Applications/ngspice/bin/ngspice```
* You an set the path using 
``` `\>\>\>import solcore.config\_tools as config
> > > config.set_location_of_spice('/Applications/ngspice/bin/ngspice')


* If NG spice throws an error
``` `dyld: Library not loaded: /opt/X11/lib/libXaw.7.dylib```
`* then you will likely need to install xquartz.  It can be downloaded from from [https://www.xquartz.org](https://www.xquartz.org)
	* run the installer and restart the computer.
* You can test the NGSpice installation using Example\_PV\_module.py



**New in Solcore 5.6.0**
- Add automatic deployment to PyPi
- Add adding custom materials and access to the refractive index database
- Add an alternative formulation for the detail balance calculation

**New in Solcore 5.6.0.dev1**
- Parameters "relative_dielectric_constant" and "dielectric_constant" have been renamed "relative_permittivity" and "permittivity" in the parameter system and solar cell solvers. Changed also in the examples.
- Light holes density of states are now considered in the Depletion Approximation solver by using the ni calculated in the materials system
- The Depletion Approximation solver now checks that the junction is an homojunction
- MORE TO BE ADDED (RAY TRACING, REFRACTIVEINDEX, ETC)
- Added Sunglass, Solcore's graphic user interface

**New in Solcore 5.5.2**
- Updated installation instructions to avoid an error that ocurs when PiP passes the --with_pdd option to all Solcore dependencies.

**New in Solcore 5.5.1**
- Changed the way QWs are solved before using them in a solar cell to avoid problems with not finding the n and k data

**New in Solcore 5.5.0**
- Updated documentation for solar cell solvers
- The *position* option is now set consistently for all optical solvers
- License badge added to the README file
- The Fortran compiler methods have been eliminated, since this is done by distutils, now.
- Eliminated the auto-meshing during the IV calculation of the PDD solver. It was causing inconsistencies.
- Changed name of examples files to be more meaningful
- Corrected an error in light_source.smarts
- Eliminated legacy functions from config_tools
- Added default "pn=True" value to the tunnel junctions
- Added more examples to the Examples page

**New in Solcore 5.4.0**
- Corrected several file names to avoid spaces: all have been replaced by underscores
- Added exe=1 flag in setup.cfg to ensure tests are run, even if they are labelled as executable files.
- Several files adapted to be able to create the documentation in Read the Docs
- Now the default installation does NOT install the PDD solver and, in order to install it, the option --with_pdd must be given.
- Added Examples section in the documentation

**New in Solcore 5.3.0**
- Solcore has been added to Pypi and can now be installed with ```pip install solcore```
- New installer including the compilation of extension modules
- New documentation about installing Solcore, specially under Windows

**New in Solcore 5.2.1**
- Corrected errors in tests and examples.

**New in Solcore 5.2.0**
- Improvements in the quantum solver
- Added plot generation for LDOS
- Corrected an error in the parameters for InP
- Implemented parametric tunnel junction model
- Added support for external tunnel junction IV characteristics
- Improved external optics option
- Added optical properties for GaAsP, GaInP and AlInP, although with just 2 or three-point interpolation
- Started a simple tutorial
- Polished the PDD solver and separated the preparation of the solar cell from the optical solvers
- Material system updated with new properties, and other minor changes
- Radiative recombination coefficient for PDD is calculated from the absorption coefficient
- Improvements in the tunnel junction and the plotting of wavefunctions
- The TMM solver has been vectorized and built directly into Solcore.

**New in Solcore 5.0.0**
- A new SolarCell class has been implemented to create solar cell structures, including not only the junctions but also optical layers.
- All solar cell solvers have been re-written in order to use a common interface - the SolarCell class.
- The calculation of the optical properties of a solar cell has been externalized. Added a transfer matrix algorithm and an interface for the S4 RCWA package.
- Materials in the SOPRA database can now ve imported as normal Solcore materials.
- Added the Modified_CPPB module to the absorption_calculator package.
- The Solcore materials now use, automatically, the mobility calculator if available for that material.

**New in Solcore 4.2.0.dev.3**
- Mobility calculator and data moved to the material_data package

**New in Solcore 4.2.0.dev.2**
- Created the class LightSource as a common interface to all types of light sources.
- solar_spectrum package renamed light_source
- Other Solcore packages adapted to use LightSource, while keeping as much backwards compatibility as possible.

**New in Solcore 4.2.0.dev.1**
- Improved the QE module, now being able of providing the IV curve based on the depletion approximation
- Corrected the instalation of examples, making it compatible with Windows

**New in Solcore 4.1.5**
- The way paths in the config file has been changed, so now they are really compatible with Windows
- Modified spice package to work in Linux, Mac OS and Windows systems (tested with ngspice only)

**New in Solcore 4.1.4**
- Increase compatibility with Windows

**New in Solcore 4.1.3**
- Solved a bug in the Spice module

**New in Solcore 4.1.2**
- Solved a problem with the distributable package, that was created incomplete

**New in Solcore 4.1.1**
- Solved bug in the documentation that prevented it to show properly.

**10th March 2017 - A new stable version has been released! - New in Solcore 4.1.0**
- Documentation of greatly improved, though still incomplete.
- License added: Now Solcore is distributed under the GNU Lesser General Public License.
- The old "database" tools have been removed, as they were not adapted to Solcore v4 working principles.

**New in Solcore 4.1.0.dev.7**
- Solve a bug in the way front surface reflexion was calculated in the PDD model: it was using just the real part of the refractive index and not complex refractive index.
- Added the possibility of calculating the optical properties of a solar cell in the PDD model using the TMM formalism or providing an external generation profile as input for the solver under illumination. Note: It only works properly when using very dense, non-dynamic meshes.
- A structure for the PDD solver now can include layers defined as "optics" and "metal" that can be used to calculate the opticla properties but will be ignored y the electrical solver.
- Added the description of most functions of the PDD solver.
- Created new version of the MJ current voltage calculator, as the previous one didn't work in the dark.
- Added tests for the new MJ current voltage calculator
- Added test for the TMM optics calculator of the PDD solver
- Included an option in the TMM calculator (no_back_reflexion) to prevent reflexion from the back surface.
- Added a filter option for the PDD.Illumination object that accept an arbitrary function as filter.

**New in Solcore 4.1.0.dev.6**
- Removed all mention to the Mod CPPB calculator (test, examples, module and data in “absorption_calculator”)
- Moved all material information to the “materials_data” folder.
- SOPRA database moved to the “materials_data” folder. Module modified accordingly. Test added.
- Added the ellipsometry fitting routine to the "data_analysis_tools" package.
- Added Science_Tracker for the reference_spectra. Reference_spectra changed to function.
- Added documentation concerning the SOPRA database and the transfer matrix calculator

**New in Solcore 4.1.0.dev.5**
- Added new dielectric models to the absorption_calculator package
- Minor bug fixing

**New in Solcore 4.1.0.dev.4**
- Added the Modified_CPPB module to the absorption_calculator package.
- Two example files added to AC_examples.
- test_Modified_CPPB added to tests folder.

**New in Solcore 4.1.0.dev.3**
- Added Custom_Colours module to graphing package for adding a splash of colour to individual and multiple plots.
- Added a Custom_Colours example file to the examples folder.

**New in Solcore 4.1.0.dev.2**
- Added SOPRA database of optical constant data to the absorption calculator package. Package now contains a folder
of SOPRA raw data and documentation and a module file containing the sopra_database.

**New in Solcore 4.1.0.dev.1**
- Added a transfer matrix formalism to the absorption calculator package. It can calculate reflexion, transmisison,
absorption, absorption profile and ellipsometry parameters of a optical stack made of solcore materials, theoretical
dielectric models or available n and k data.

**New in Solcore 4.0.3**
- Version number removed from the solcore_config user file.

**New in Solcore 4.0.2**
- Fix a bug related with import statements that where not using the new package names.
- Implemented an automatic MANIFEST.in creator to avoid missing non-python files when creating a distributable package.

**New in Solcore 4.0.1**
- Adds many files (txt, html, etc) that where missing in the previous version for some estrange reason.

**New in Solcore 4.0.0**
- General code re-writing aiming to comply with the PEP 8 -- Style Guide for Python Code (https://www.python.org/dev/peps/pep-0008/).
- The package has been renamed just 'solcore', droping the version number. Importing Solcore now is done by 'import solcore' rather than 'import solcore3', as it is the usual case for python packages which do not include verison number in the name.
- The pluging system has been removed and the code arranged in the more standard package/module configuration. Most old plugings are now directly imported as subpackages of solcore (eg. import solcore.spice rather than import solcore3.plugings.spice).
- The structure of some modules and packages has changed, grouping them in a (hopefully) more consistent and logical order. The following list summarises some of the changes (likely to be incomplete):
    - solcore3.plugings.qm              -> solcore.quantum_mechanics
    - solcore3.plugings.kp              -> solcore.quantum_mechanics
    - solcore3.plugings.IV              -> solcore.analytic_solar_cells
    - solcore3.plugings.analytic_pin_QE -> solcore.analytic_solar_cells
    - solcore3.plugings.spice           -> solcore.spice
    - solcore3.plugings.spectral2       -> solcore.solar_spectrum
    - solcore3.plugings.smarts          -> solcore.solar_spectrum
    - solcore3.plugings.adachi_alpha    -> solcore.absorption_calculator
    - solcore3.PDD                      -> solcore.poisson_drift_diffusion
- Some functions within the above modules and packages have been renamed to have a more descriptive name.
- All the old plugins related with parameters of materials are now included inside the 'parameter system' and not as packages.
- All the old plugins related with description of materials n and k data are now included inside the 'material system' and not as packages.
- A configuration file and a set configuration tools have been created to simplify the addition of new data or personalised behavior.
- SMARTS has been removed from the Solcore directory tree, as it is a third party software and platform dependent. The path to the SMARTS distribution can be set with the configuration tools. SMARTS can be found in http://www.nrel.gov/rredc/smarts/
- Solcore has been arranged to be used with 'setuptools', which simplifies its distribution, testing an maintenance. If everything goes alright, the command 'python3 setup.py install' will install Solcore and all its dependencies (except the Fortran compiler). Tested in MacOS X.
- A set of test have been written to assert the correct behaviour of Solcore, either before performing the installation or if one of the existing packages is modified. They can be run with 'python3 setup.py test'
- The 'poisson_drift_diffusion' solver now can print the output of the calculation to a log file, rather than the terminal.
- The correct temperature dependence has been incorporated to the analytic IV calculator.
- A set of examples have been created to illustrate the use of Solcore. Such examples can be copied to a user-speficied folder, where they can be easily edited.
.. image:: _static/header.png
    :align: center

:literal:`Solcore` was born as a modular set of tools, written (almost) entirely in Python 3, to address some of the task we had to solve more often, such as fitting dark IV curves or luminescence decays. With time, however,  it has evolved as a complete semiconductor solver able of modelling the optical and electrical properties of a wide range of solar cells, from quantum well devices to multi-junction solar cells. A compact description of Solcore's functionality and physics can be found in the open access publication:

`D. Alonso-Álvarez, T. Wilson, P. Pearce, M. Führer, D. Farrell, N. Ekins-Daukes, Journal of Computational Electronics (2018) <https://doi.org/10.1007/s10825-018-1171-3>`_.

Please, cite this article if you find Solcore useful for your research.

.. image:: Infographics.jpg
    :align: center


Contents:
---------

.. toctree::
    :maxdepth: 2

    Installation/installation
    Structures/structure
    Systems/systems
    QM/Schrodinger
    spectral/spectral
    Optics/optics
    Solvers/solving_solar_cells
    Quasi3D/spice
    Examples/main

.. Indices and tables
.. ==================
..
.. * :ref:`genindex`
.. * :ref:`modindex`
.. * :ref:`search`

SPICE-based solar cell solver
=============================

- Example 1: :doc:`PV module calculator <../Examples/example_pv_module>`
- Example 2: :doc:`Quasi-3D 3J solar cell <../Examples/example_quasi3D_cell>`

﻿When the two diode model is used to define the junctions in a MJ solar cell, then larger scale circuits can be constructed. Solcore includes two levels of large scale equivalent circuits: quasi-3D solar cell modelling and solar array modelling. Both solvers are based on the interface between Solcore and SPICE, allowing for a fast calculation of complex structures with many elements.

This solver has been tested with NGSPICE, only. Check the installation :doc:`instructions for Windows <../Installation/Solcore_on_Windows>` and :doc:`for MacOS <../Installation/Solcore_on_MacOSX>`.

.. toctree::
    :maxdepth: 0

    pv_panel
    quasi3D

Spice solver files
------------------

.. automodule:: solcore.spice.spice
    :members:
    :undoc-members:
Quasi-3D solar cell solver
==========================

- Example: :doc:`Quasi-3D 3J solar cell <../Examples/example_quasi3D_cell>`

﻿The quasi-3D solar cell model included in Solcore uses a SPICE-based electrical network to model the flow of injected current through the solar cell. The plane of the cell is discretized into many elements, each of them representing a small portion of the cell. Depending on the location of the element - exposed to the sunlight or underneath a metal finger - the IV curve of the cell will be the light IV or the dark IV. Each element is linked to their neighbours with resistors, representing the lateral current flow and dependent on the sheet resistance of the cells. This method can be applied to any number of junctions.

This type of formalism is widely used to simulate the performance of solar cells when the effect of a spatial variable needs to be incorporated in the model. This variable can be the design of the front metal grid, in order to minimise the effect of series resistances; the inhomogeneous illumination profile in concentrator devices; the impact of such inhomogeneity on the transport through the tunnel junctions; or the distribution of defects or inhomogeneities. Recently, this formalism was used to model the photoluminescence and the electroluminescence based IV curves of MJ devices, accounting for the limited lateral carrier transport.

Specifically for the modelling and optimization of the front grid of solar cells in order to minimise shading losses and series resistance, there are two packages already available: `PVMOS <https://github.com/IEK-5/PVMOS>`_, developed by B. E. Pieters in C and released as open source, and `Griddler <https://www.pvlighthouse.com.au/cms/simulation-programs/griddler>`_, developed by J. Wong using Matlab and available at PV Lighthouse.

.. image:: quasi3Dimg.png
    :align: center

In-plane discretization
-----------------------

There are two regions in the plane: the metal and the aperture. These two are provided to Solcore as
grey scale images that will work as masks. The resolution of the images,
in pixels, will define the in-plane discretization. By default, the
aspect ratio of the pixels in the image will be 1:1, but this can be set
to a different value in order to reduce the number of elements and
improve speed. For example, the in-plane discretization of Fig.
[fig:spice\_overview]a has an aspect ratio :math:`A_r=L_y/L_x = 4`, with
:math:`L_x` and :math:`L_y` the pixel size in each direction.

The values
of the pixels in the metal mask are <55 where there is no metal (the
aperture area), >200 where there is metal and the external electrical
contacts (the boundaries with fixed, externally set voltage values) and
any other value in between to represent regions with metal but not fixed
voltage. The pixels of the illumination mask - which become the aperture
mask after removing the areas shadowed by the metal - can have any value
between 0 and 255. These values divided by 255 will indicate the
intensity of the sunlight at that pixel relative to the maximum
intensity.

The minimum total number of nodes where SPICE will need to calculate the
voltages will be
N\ :math:`\times`\ M\ :math:`\times`\ 2\ :math:`\times`\ Q, with N and M
the number of pixels in both in-plane directions and Q the number of
junctions, which require 2 nodes each. To this, the front and back metal
contacts could add a maximum of 2(N\ :math:`\times`\ M) nodes. Exploiting
symmetries of the problem as well as choosing an appropriate pixel
aspect ratio will significantly reduce the number of nodes and therefore
the time required for the computation of the problem.


Vertical discretization
-----------------------

First, the solar cell is solved in order to obtain the parameters for the 2-diode
model at the given illumination conditions. These parameters are then
used to replicate the 2-diode model in SPICE. The :math:`I_{SC}` is
scaled in each pixel by the intensity of the illumination given by the
illumination mask. Sheet resistances above and below each junction,
:math:`R_{sh}(top)` and :math:`R_{sh}(bot)`, account for the lateral
transport. Beneath the metal, there is no current source, as the region
is in the dark, and there are extra resistances accounting for the
contact between the metal and the semiconductor :math:`R_c` and the
transport along the metal finger :math:`R_s`. Given that the pixels can be
asymmetric, these resistances need to be defined in both in-plane
directions, :math:`x` and :math:`y`:

.. math::

   \begin{aligned}
   R_{sh}^x &= \frac{1}{A_r} R_{sh} \\
   R_{sh}^y &= A_r R_{sh} \\
   R_s^x &= \frac{1}{hA_r} \rho_m \\
   R_s^y &= \frac{A_r}{h} \rho_m \\
   R_c &= R_{back} = \frac{1}{L_x^2 A_r} \rho_c\end{aligned}

where :math:`h` is the height of the metal, :math:`\rho_m` their linear
resistivity and :math:`\rho_c` the contact resistivity between metal and
semiconductor. The sheet resistance of a stack of semiconductor layers
:math:`R_{sh}` is equal to the combination in parallel of the individual
sheet resistances. Using the single junction example of the figure, :math:`R_{sh}(top)` will be given by:

.. math:: \frac{1}{R_{sh}(top)} = \frac{1}{R_{sh}(window)} + \frac{1}{R_{sh}(emitter)}

Each of these can be estimated from the thickness of the layer
:math:`d`, the majority carrier mobility :math:`\mu` and the doping
:math:`N` as:

.. math:: \frac{1}{R_{sh}} = qd\mu N

If the solar cell has been defined using only the DA and PDD junction
models, this information is already available for all the layers of the
structure. For junctions using the DB and two diode models,
:math:`R_{sh}` will need to be provided for the top and bottom regions
of each junction. Intrinsic layers will be ignored as they do not
contribute to the lateral current transport.

Quasi-3D solver functions
-------------------------

.. automodule:: solcore.spice.quasi_3D_solver
    :members:
    :undoc-members:
Solar array model
=================

- Example: :doc:`PV module calculator <../Examples/example_pv_module>`

The ability to use Solcore to build a SPICE equivalent circuit allows
entire PV systems to be simulated from the bottom
up. Each photovoltaic solar cell is described
using an equivalent circuit which can then be arranged in strings of
series and parallel cells to represent the entire system. An example for
a triple junction solar cell, complete with a bypass diode is shown in
figure [fig:3J\_equiv\_curcuit]; this unit is the basic building block
for a concentrator PV module.

.. image:: pv_module.png
    :align: center

The diode and resistance values for the equivalent circuit are
determined from solar cell testing, while the current source is
evaluated by integrating the product of the spectral irradiance
(estimated using an appropriate radiative transfer code e.g. SPCTRAL2 or
SMARTS) and the quantum efficiency which in turn can be calculated
dynamically as a function of temperature by
Solcore.

Since the entire module (and subsequently the system) is assembled from
individual solar cell components, it is possible (and indeed, necessary)
to distribute the component values to accommodate for manufacturing
tolerances. This enables a close match between the modelled output power
and that measured experimentally and has been used to determine how both
aerosols and precipitable water affect the electricity yield from
concentrator PV systems.
Where system IV data is available, the emergence of electrical faults,
(e.g. shunts or shading) can also be accounted
for.

PV module solver functions
--------------------------

.. automodule:: solcore.spice.pv_module_solver
    :members:
    :undoc-members:
The Material System
===================

.. toctree::
    :maxdepth: 1

    Materials

The parameters database contains the basic properties of many
semiconductor materials, including silicon, germanium and many III-V
semiconductor binary and ternary alloys. Among other parameters, it
includes the energy bandgap, the electron and hole effective masses, the
lattice constants and the elastic constants.

The main sources of data are the article by I. Vurgaftman on *Band
parameters for III-V semiconductors* ([#Ref10]_) and the *Handbook Series on
Semiconductor Parameters* by Levinshtein et al.([#Ref9]_). The carrier mobility calculator
is based on the empirical low-field mobility model by Sotoodeh et
al. ([#Ref6]_) and it is available only for
some materials where the inputs for the model are available.

There are two methods for retrieving parameters from the database. The
first one consists simply of getting the data using the
``get_parameter`` function with the required inputs. For example:

.. code-block:: Python

    get_parameter("GaAsP", "band_gap", P=0.45, T=300)

will return the bandgap of GaAsP for a phosphorus concentration of 45%
at a temperature of 300 K, equal to 1.988 eV. This method only uses the
existing data. Another method is to create a material object which will
contain all the properties existing in the database for that material,
as well as those included as input, which will override the value of the
database parameter, if it exists. The following example creates a GaAs
object and an AlGaAs object, using a custom electron effective mass in
the latter:

.. code-block:: Python

    GaAs = material("GaAs")(T=300, Na=1e24)
    AlGaAs = material("AlGaAs")(T=300, Al=0.3, Nd=1e23, eff_mass_electron=0.1)

Now, any parameter - including the custom ones - are attributes that can
be easily accessed and used anywhere in the program. For example
``GaAs.band_gap`` is the GaAs bandgap and ``AlGaAs.lattice_constant`` is
the AlGaAs lattice constant, both at the composition and temperature
chosen when creating the objects.

The image below shows the well-known bandgap vs. lattice constant
map of all semiconductor materials and alloys (only ternary compounds)
currently implemented into Solcore. However, any other material can be
used in all of the Solcore functions, as long as the necessary input
parameters are provided. This can be done by overriding all the
properties of an existing material during the creation as above, or
adding it as an external material in the configuration files.

.. image:: eg_vs_lattice_constant.png
    :align: center

The material class
------------------

.. automodule:: solcore.material_system.material_system
    :members:
    :undoc-members:

Accessing parameters
---------------------

.. automodule:: solcore.parameter_system.parameter_system
    :members:
    :undoc-members:


The mobility module
-------------------

This module allows to calculate the carrier mobilities based on the material composition, temperature (T>100K) and impurity concentration. It is an implementation of the mobility model by Sotoodeh *et al.* ([#Ref6]_). The material class described above uses this module internally to get the mobililty of the materials it is implemented for.

The material parameters used in the model are included in the file *mobility_parameters.json*. At the moment, the supported materials are:

	  - **Binaries**: AlAs, GaAs, InAs, InP, GaP
	  - **Ternaries**: InAlAs, AlGaAs, InGaAs, GaInP, (GaAsP), (InAsP)
	  - **Quaternaries**: InGaAsP

The last two ternaries are simply calculated as a linear interpolation of the parameters of the corresponding binaries, so the transition from direct to indirect bandgap and other dependencies might not be very accurate. *InGaAsP*, in turn, is calculated only based on the *InGaAs* and *GaInP* data and it is mostly valid for compositions lattice matched to *InP*.

.. automodule:: solcore.material_data.mobility
    :members:
    :undoc-members:

The critical point picker
-------------------------

.. automodule:: solcore.material_system.critical_point_picker
    :members:
    :undoc-members:

References
----------

.. [#Ref10] Vurgaftman, I., Meyer, J.R., Ram-Mohan, L.R.: Band parameters for III–V compound semiconductors and their alloys. J. Appl. Phys. 89(11), 5815–5875 (2001)
.. [#Ref9] Levinshtein, M., Rumyantsev, S., Shur, M., Levinshtein, M., Rumyantsev, S., Shur, M.: Handbook Series on Semiconductor Parameters, ser. Volume 2: Ternary and Quaternary III-V Com- pounds, vol. 2. World Scientific, Singapore (2012)
.. [#Ref6] M. Sotoodeh, A. H. Khalid, and A. A. Rezazadeh, “Empirical low-field mobility model for III–V compounds applicable in device simulation codes,” *J. Appl. Phys.*, **87**, 2890, (2000).The Units System
================

Most of these functions can be acccessed directly from Solcore::

    >>> from solcore import eV

    >>> print(eV(1e-19))
    0.624 eV

.. automodule:: solcore.units_system.units_system
    :members:
    :undoc-members:
Defining new materials
=======================

.. toctree::
    :maxdepth: 1

    Materials

There are two main ways to use a material which is not built in
to the Solcore database, which can also be connected. They are:

1. Downloading and using the database from `refractiveindex.info <https://refractiveindex.info/>`_
2. Providing n and k data, and other parameters, to ``create_new_material``

In order to control where custom materials get saved, you need to tell Solcore where to
create and look for new materials by adding some entries to your user configuration file
(by default, a hidden folder called .solcore_config.txt in your home directory):

- Path the refractiveindex.info database will be downloaded to is set under [Others] with flag ``nk``.
- Path where n and k data will be saved is set under [Others] with flag ``custom_mats``.
- Path where the file containing parameters of custom materials will be created is set under [Parameters] with flag ``custom``. 

The following code snippet sets the location for each of these within a folder called Solcore, which
is a sub-directory of your home folder (you could also manually add the correct paths to the config
file).

.. code-block:: Python

    import os
    from solcore.config_tools import add_source
	
    home_folder = os.path.expanduser('~')
    custom_nk_path = os.path.join(home_folder, 'Solcore/custommats')
    nk_db_path = os.path.join(home_folder, 'Solcore/NK.db')
    param_path = os.path.join(home_folder, 'Solcore/custom_params.txt')

    add_source('Others', 'custom_mats', custom_nk_path)
    add_source('Others', 'nk', nk_db_path)
    add_source('Parameters', 'custom', param_path)
	

Adding new materials to the database
-------------------------------------

.. automodule:: solcore.material_system.create_new_material
    :members:
    :undoc-members:
	
The correct format for the n and k files are tab or space separated text files,
with the first column the wavelength **in metres** and the second column n or k.
The file containing other parameters should take 

When you add a new material to the database, a new folder will be created for it
as a subfolder of the path specified in your (user or default) configuration under
the ``custom_mats`` path. The n and k data files you provide will be copied into that folder
(they are renamed automatically). Any other parameters you supply will be copied into
the file specified under the ``custom`` path.

Using refractiveindex.info
---------------------------

.. automodule:: solcore.absorption_calculator.nk_db
    :members:
    :undoc-members:

Before the first use, you will need to download the database:

.. code-block:: Python

	from solcore.absorption_calculator download_db
	download_db()

``download_db`` takes two (optional) arguments: the URL of the database to be downloaded,
(default is the most recent, hardcoded into the function), and how many interpolation points 
to use when saving the database (default is 200).

The code which is used to download and get data from the refractiveindex.info
database is based on code from `Hugo Guillen
<https://github.com/HugoGuillen/refractiveindex.info-sqlite>`_.

You can now directly use materials from the .db file created this way by 
referencing them via their **pageid**. To locate which database entry you want to use,
you can search the database; the code below searches the database for entries matching
'Diamond' and then uses the pageid of the first result to create an instance of this
new Diamond material. In general, though, it is a good idea to check explicitly which
of the database entries is appropriate (e.g. in terms of the wavelength range, and which type
of data is available) rather than simply using the first result.

.. code-block:: Python

	results = search_db('Diamond')
	Diamond = material(name = str(results[0][0]), nk_db = True)()


Adding materials from refractiveindex.info to the database
---------------------------------------------------------------

There is a convenient function, ``create_nk_txt``, to generate the n and k data files needed to
add a new material to the Solcore database directly from the downloaded refractiveindex.info database:

.. code-block:: Python

	results = search_db('Diamond')
	create_nk_txt(pageid=results[0][0], file='C_Diamond')
	create_new_material(mat_name = 'Diamond', n_source='C_Diamond_n.txt', k_source='C_Diamond_k.txt')

This searches the refractiveindex.info database for entries matching 'Diamond', and then creates
files with the n and k data from the first matching database entry in the format required by 
``create_new_material``.
Materials and units
======================

These are the modules that deal with material properties and units. Together with the :doc:`structure modules <../Structures/structure>`, they form the backbone of Solcore.

.. toctree::
    :maxdepth: 2

    Materials
    Units
    NewMatsInstallation and configuration
==============================

Trying Solcore
^^^^^^^^^^^^^^

You can try Solcore without installing anything in your computer by using the online service `MyBinder.org <https://mybinder.org/>`_. To do so, just click in the following badge:

.. image:: https://mybinder.org/badge_logo.svg
 :target: https://mybinder.org/v2/gh/qpv-research-group/solcore5/devel

It might take a few minutes to start the server. Be patient! Once launched, this service offers a full-feature Jupyter server with Solcore and all its dependencies installed on it. You can use it to try different features and run the examples shipped with Solcore, but it is not recommended for production: resources in MyBinder are limited and the execution depends on a reliable internet connexion.

Once you are ready to install it in your own machine, go to the next section.

Installing Solcore
^^^^^^^^^^^^^^^^^^

Solcore is written mostly in Python, but the Poisson-Drift-diffusion (PDD) solver is written in Fortran to make it more efficient. The following instructions are expected to work in most systems, but check the sections below for OS specific instructions and caveats. In order to install Solcore in your computer, you will need the following:

- Python >3.7
- pip
- setuptools
- :doc:`a suitable Fortran compiler (only needed for the PDD solver) <compilation>`

*Pip* is normally part of the standard Python installation, but you might need to install *setuptools* manually with::

    pip install setuptools

Now, installing Solcore should be as easy as writing in the terminal::

    pip install solcore

This will download Solcore form the Pypi repository and install the package within the Python packages tree, but it will *NOT* install the PDD solver, for which you need a suitable Fortran compiler :doc:`(read this to install your Fortran compiler) <compilation>`. Assuming you have a Fortran compiler correctly installed and configured, you can install Solcore with the PDD solver by doing::

    pip install solcore
    pip install --no-deps --force-reinstall --install-option="--with_pdd" solcore

**NOTE**: Pip passes the --install-option to all the dependencies of the package and therefore the installation will fail since those dependencies do not have the option "--with_pdd". That is the reason why, for now, Solcore needs to be installed twice: the first one to install Solcore normally with all the dependencies and the second one re-installs Solcore with PDD support. 

And that's all!! Solcore should be available to be used as with any Python package::

    >>> import solcore

        Welcome to Solcore - version 5.6.0
        Copyright (c) 2018, Imperial College, London All rights reserved.
        Software released under the GNU Lesser General Public License.

Alternative installation method
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Alternatively, you can `download the source from the Solcore GitHub repository <https://github.com/dalonsoa/solcore5>`_, either using 'git' or as a zip file using one of the links on the right. If you want to install it, unpack it and run from the directory where *setup.py* is located (you still need *pip*, *setuptools* and *numpy* installed; see above)::

    pip install .

or::

    pip install . --install-option="--with_pdd"

If you want to test first if Solcore will work in your computer, without actually installing it, or if you want to become a developer and therefore you need to have it in a more accessible place, you can test if Solcore works with::

    python setup.py test

This will also install the Solcore dependencies and run a few tests that probe several of the Solcore tools. If it fails, it will indicate which parts failed to work and why, and you could try to solve them. At the moment, this only cover some of Solcore's functionality, but it will be expanded with time. The tests related to the PDD solver will fail, of course, since the PDD solver will not be compiled. If you want to test everything, compiling the the PDD solver, just run::

    python setup.py test --with_pdd

Install in development mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are planning to develop Solcore further, you would want to have all the files in an accessible place but still being able to use the package from other places and examples, behaving as if it were truly installed. For this, install Solcore in development mode. `Download the source from the Solcore GitHub repository <https://github.com/dalonsoa/solcore5>`_ as above and then::

    pip install -e .[dev]

or::

    pip install -e .[dev] --install-option="--with_pdd"
    
Solcore uses *pre-commit* to do a few things before commiting the changes (for example, clearing the output of Jupyter Notebooks). The *pre-commit* package is installed automatically with the above commands, but each user needs to be initialise it before it can work. This can be done with::

    pre-commit install
   
Check the `pre-commit webpage <https://pre-commit.com/#3-install-the-git-hook-scripts>`_ for more information on how it works. 

Getting started
^^^^^^^^^^^^^^^

After installing Solcore (or even without installing it), there are a few things you might want to do in order to personalise it and start using it. These are general instructions that, hopefully, should work in most *NIX systems. Check specific instructions for:

- :doc:`Windows 10 <Solcore_on_Windows>`
- :doc:`Mac OS X <Solcore_on_MacOSX>`

1. **Create a user configuration file:** The first time Solcore is run, it will create a hidden folder in your user directory. This folder will contain the local configuration and will store custom materials and other parameters. You can customize the location of by setting the environmental variable :code:`SOLCORE_USER_DATA`. You can check the current configuration with:

.. code:: python

	from solcore import config
	print(config)
	
You can find all the functionality of the :code:`config` object in `The config_tools`_

2. **Check Solcore examples:** This is the fastest way of getting started. These examples include all the scripts used in the main Solcore paper in the `Journal of Computational Electronics (2018) <https://doi.org/10.1007/s10825-018-1171-3>`_ and a few others to explore other functionality. We hope to increase the number and usefulness of these examples over time. You can try directly the examples using `MyBinder.org <https://mybinder.org/v2/gh/qpv-research-group/solcore5/deployment>`_.

3. **Set the location of a SPICE executable and the SMARTS folder:** You will need to do this eventually in order to use those tools::

.. code:: python

	from solcore import config
	
	config.spice('/path/to/the/SPICE/executable')
	config.smarts('/path/to/the/SMARTS/folder')


4. **Installing S4:** The rigorous-coupled wave analysis (RCWA) solver S4, created by the Stanford University, needs to be installed separately using `the fork by Phoebe Pearce <http://github.com/phoebe-p/S4>`_. The original version **do not work** with Python 3.x, only with Python 2. You can find more information about the solver in the `project webpage <http://web.stanford.edu/group/fan/S4/>`_. An example of its use with Solcore is included in the examples folder, *Figure9.py*.

5. **Getting specific information about Solcore:** Even though the documentation "should" be more complete, you can get information about any object in python (including any Solcore function, module and package) using the :code:`help` built-in function, for example::

.. code:: python

	from solcore import config
	help(config)


Problems with the installation
------------------------------

There are several things that can go wrong in the above description, specially in Windows.

1. **The tests associated with the Poisson-Drift-Diffusion solver fail**: This is usually the result of not having a Fortran compiler installed in your system, not being correctly configured or having a temperamental F2PY version, the tool - included in numpy - that makes Fotran code accesible from Python. Please, make sure you follow all the steps indicated in the :doc:`Fortran compiler section <compilation>` and above to have the PDD solver up and running.

2. **Some of the dependencies fail to install**: That is rarely the case, as all dependencies are in the main Python repositories. However, there might be issues with Numpy, Matplotlib and Scipy. Depending on your Python distribution, some of these packages might need to be compiled and it is often easy to get them as a scientific bundle. You can check `Anaconda <https://www.continuum.io/downloads>`_ which provides all these packages together already configured for the correct OS.

The config_tools
^^^^^^^^^^^^^^^^

This module contains all the functions that will help you to setup and configure your Solcore installation, as it has been highlighted above. The full description of the functions included in this module are:

.. autoclass:: solcore.config_tools.SolcoreConfig
    :members: 
Quantum Solvers
===============

- Example 1: :doc:`KP calculator and effective mass fitting <../Examples/example_K_and_effective_mass>`
- Example 2: :doc:`Calculating the bandstructure and local density of states in QWs and MQWs <../Examples/example_QWs>`

﻿The electronic band structure of semiconductor materials is responsible for their light absorption and emission properties as well as for many of their transport properties, ultimately depending on the carriers' effective masses. These properties are not intrinsic to the material, but depend on external factors, too, most notably the strain and the quantum confinement.

Given the crystalline nature of most semiconductor materials, there will be strain whenever two materials with different crystal lattice constants are grown on top of each other pseudomorphically. Even those with the same lattice constant might be under stress due to other effects such as the presence of impurities or if used at different temperatures having dissimilar thermal expansion coefficients. Quantum confinement, in turn, takes place when the size of the semiconductor material in one or more dimensions is reduced to a few nanometres. In that situation, the energy levels available to the carriers become quantized in the direction of confinement, also changing the density of states. Both conditions take place simultaneously when dealing with strain-balanced quantum wells (QW).

Quantum wells - and more recently quantum wires - have been employed to tune the absorption properties of high efficiency solar cells for the past two decades. The need for appropriate tools to study them in the context of photovoltaics led to the development of the simulation models that were the seed of Solcore. As strained materials with quantum confinement, special care must be taken to obtain a sensible set of parameters for the QW structures, including the band edges with confined energy levels, the effective masses and the absorption coefficient.

Solcore's approach for evaluating the properties of QWs involves calculating first the effect of strain using a 8-band Pikus-Bir Hamiltonian , treating each material in the structure as bulk, and then using the shifted bands and effective masses to solve the 1D Schödinger equation, after a proper alignment between layers. Finally, the absorption coefficient is calculated based on the 2D density of states, including the effect of excitons.

This section describes the tools used for the calculation of the band structure. The QW absorption profile is discussed in :doc:`the optics section section <../Optics/material_optics>`.

Bulk 8-band kp solver
---------------------

.. automodule:: solcore.quantum_mechanics.kp_bulk
    :members:
    :undoc-members:

Quantum well 1D-Schrodinger calculator
--------------------------------------

.. automodule:: solcore.quantum_mechanics.high_level_kp_QW
    :members:
    :undoc-members:

.. automodule:: solcore.quantum_mechanics.structure_utilities
    :members:
    :undoc-members:

.. automodule:: solcore.quantum_mechanics.potential_utilities
    :members:
    :undoc-members:

.. automodule:: solcore.quantum_mechanics.graphics
    :members:
    :undoc-members:

4-bands kp QW solver (experimental)
-----------------------------------

.. automodule:: solcore.quantum_mechanics.kp_QW
    :members:
    :undoc-members:Structures and support classes
==============================

While Solcore is mostly about physics, it also needs a lot of tools that keep everiting working together properly or that support the creation and management of solar cell structure. Here you can find (some) information about all those extra bits and pieces Solcore is made of.

.. toctree::
    :maxdepth: 2

    structure

Structure
---------

Solcore calculates optical and electrical properties of solar cells or, in other words, of a certain combination of layers made of different materials and serving to specific purposes. The *structure* module contains tha basic building blocks that allow you to make a solar cell structure and calculate their properties. Their use will be explained with examples in other packages - such as in the quantum efficiency calculator or the Poisson-drift-diffusion solver.

.. automodule:: solcore.structure
    :members:
    :undoc-members:

Another, very useful class is the *state_object* which makes the use of dictionaries very easy.

.. automodule:: solcore.state
    :members:
    :undoc-members:

Solar Cells
-----------

Finally, the higher level building block of solar cells is contained in the *solar_cell* module.

.. automodule:: solcore.solar_cell
    :members:
    :undoc-members:

Science tracker
---------------

Solcore is an original work, but the equations it implements and the data it uses have been often published elsewere. The Science tracker allows you to keep track of those references and check yourself their origin and assumpions.

.. automodule:: solcore.science_tracker
    :members:
    :undoc-members:

Other classes
-------------

Solcore depends on many other classes and functions that work in the background and keep everything together. Some of them are used directly, others are completely transparent but make Solcore work they way it does. Unfortunately, their documentation is not very extensive or explicit, so feel free to explore the source code to understand what they are doing and how.

.. automodule:: solcore.interpolate
    :members:
    :undoc-members:

.. automodule:: solcore.crystals
    :members:
    :undoc-members:

.. automodule:: solcore.smooth
    :members:
    :undoc-members:

.. automodule:: solcore.singleton
    :members:
    :undoc-members:

.. automodule:: solcore.source_managed_class
    :members:
    :undoc-members:

Light Sources
=============

- Example: :doc:`Example of the use of the light_sources module <../Examples/example_light_sources>`

The Solcore module **light_source** is designed to deal easily with
different light sources. It has direct support for:

-  Gaussian emission, typical of lasers and light emitting diodes.

-  Black-body radiation, characteristic of halogen lamps defined by a
   temperature, but also used very often to simulate the spectrum of the
   Sun, very close to a black body source at 5800 K.

-  Standard solar spectra: the extraterrestial spectrum AM0 and the two
   terrestial ones, AM1.5D and AM1.5G as defined by the ASTM G173 -
   03(2008) standard.

-  Irradiance models, using location, time and atmospheric parameters to
   calculate a synthetic solar spectrum. Solcore includes two models:
   SPECTRAL2, fully implemented in Python, and an interface to SMARTS
   binaries (which need to be installed separately), which greatly
   simplifies its use in batch mode.

-  User-defined irradiances, provided externally from a database or any
   other source, allowing for maximum flexibility.

The syntax in all cases is simple and intuitive considering the type of
source that needs to be created. In the case of the irradiance models,
which often have a large number of inputs, Solcore defines a set of
default values, so only those that are different need to be provided.
These default values can be obtained by:

.. code-block:: Python

    import solcore.light_source as ls

    ls.get_default_spectral2_object()
    ls.get_default_smarts_object()

Once created, specific parameters of the light sources can be easily
modified without the need for creating the source from scratch. That is
particularly useful for the irradiance models, where we might be
interested in getting the spectrum as a function of a certain parameter
(e.g. the hour of the day, or the humidity) without changing the others.
For example, ``smarts.spectrum(HOUR=11)`` and
``smarts.spectrum(HOUR=17)`` will provide the spectrum of the SMART
light source (assuming it has already been created) calculated at 11h and at 17h, respectively;
all additional parameters have the default values. This method has been
used to model experimental solar irradiances measured by different
spectroradiometers based on the local atmospheric
conditions.

A final, very convenient feature of the LightSource class is the ability
to request the spectrum in a range of different units. The default is
power density per nanometer, but other common units are power density
per eV or photon flux per nanometer, among others. While these unit
conversions are straightforward, it is often an initial source of errors
due to missing constants or incompatible magnitudes.

The **light_source** module has been described in the context of the
solar spectrum, but it can be applied broadly where there is spectral
data involved, such as the fitting of photoluminescence,
electroluminescence or Raman spectra.


Description of functions and modules
------------------------------------

.. automodule:: solcore.light_source.light_source
    :members:
    :undoc-members:

.. automodule:: solcore.light_source.smarts
    :members:
    :undoc-members:

.. automodule:: solcore.light_source.spectral2
    :members:
    :undoc-members:
Using the TMM solver to calculate the reflextion of a multilayered ARC
======================================================================

.. image:: RAT_of_ARC.png
   :width: 50%

- Required extra files, available in `Solcore's Github repository (Examples folder) <https://github.com/dalonsoa/solcore5>`_:

    - AlInP_nk.csv
    - GaInP_nk.csv
    - MgF_nk.csv
    - SiCx_nk.csv
    - ZnS_nk.csv

.. code-block:: Python

    from scipy.interpolate import interp1d
    import matplotlib.pyplot as plt
    import numpy as np

    from solcore.structure import Structure
    from solcore.absorption_calculator import calculate_rat

    E_eV = np.linspace(0.65, 4, 1000)


    def nk_convert(fname, energy):
        """ Designed to handle nk data files"""

        # Import data...
        E_n, n, E_k, k = np.loadtxt(fname, delimiter=",", unpack=True)
        print("File :: " + fname + " :: Imported Successfully!")

        # Interpolate data...
        n_interp = interp1d(E_n, n, bounds_error=False, fill_value=(n[0], n[-1]))(energy)
        k_interp = interp1d(E_k, k, bounds_error=False, fill_value=(k[0], k[-1]))(energy)

        return (energy, n_interp, k_interp)


    # Load nk data using nk_convert function...
    alinp_nk = nk_convert("AlInP_nk.csv", energy=E_eV)
    gainp_nk = nk_convert("GaInP_nk.csv", energy=E_eV)
    mgf_nk = nk_convert("MgF_nk.csv", energy=E_eV)
    sic_nk = nk_convert("SiCx_nk.csv", energy=E_eV)
    zns_nk = nk_convert("ZnS_nk.csv", energy=E_eV)

    # Build the optical stack...
    stack = Structure([
        [117, 1240 / E_eV, mgf_nk[1], mgf_nk[2]],
        [80, 1240 / E_eV, sic_nk[1], sic_nk[2]],
        [61, 1240 / E_eV, zns_nk[1], zns_nk[2]],
        [25, 1240 / E_eV, alinp_nk[1], alinp_nk[2]],
        [350000, 1240 / E_eV, gainp_nk[1], gainp_nk[2]]
    ])

    angles = np.linspace(0, 80, 10)
    RAT_angles = []

    print("Calculate RAT ::")
    for theta in angles:
        print("Calculating at angle :: %4.1f deg" % theta)
        # Calculate RAT data...
        rat_data = calculate_rat(stack, angle=theta, wavelength=1240 / E_eV)

        RAT_angles.append((theta, rat_data["R"], rat_data["A"]))

    colors = plt.cm.jet(np.linspace(1, 0, len(RAT_angles)))

    fig, ax2 = plt.subplots(1, 1)

    for i, RAT in enumerate(RAT_angles):
        ax2.plot(1240 / E_eV, RAT[1] * 100, ls="-", color=colors[i], label="%4.1f$^\circ$" % RAT[0])
        ax2.plot(1240 / E_eV, RAT[2] * 100, ls="--", color=colors[i])

    ax2.set_ylim([0, 100])
    ax2.set_xlim([300, 1800])
    ax2.set_xlabel("Wavelength (nm)")
    ax2.set_ylabel("Reflection and Transmission (%)")
    ax2.legend(loc=5)
    ax2.text(0.05, 0.45, '(a)', transform=ax2.transAxes, fontsize=12)

    plt.tight_layout(w_pad=4)
    plt.show()
Comparison of Solcore's optical models
======================================================================

.. image:: optmodelcomp.png
   :width: 80%

The different optical models in Solcore are suitable for different purposes. The Beer-Lambert (BL) model does not include front surface reflection,
unless it is externally specified, but is extremely fast and may be suitable for material stacks where the layers are optically thick
(especially if the front surface reflectivity is specified by the user, e.g. from measured data). The transfer matrix model (TMM)
deals with multi-layer interference correctly, and can be used at multiple incidence angles and either s, p, or unpolarized light.
Finally, the RCWA capability integrated in Solcore is the most advanced solver, capable of dealing with periodic structures.
For any multi-layer structures without diffracting layers, it gives the same results as the TMM solver. However, as the number
of diffraction orders used in the calculation increases, the computation time can become very significant.

The plot above shows the EQE results for a thin GaAs cell with various light-trapping structures, considered using
the different solvers. The structure is a relatively thin (500 nm) GaAs cell, with :math:`TiO_2` nanoparticles (NPs) on the front
and a distributed Bragg reflector (DBR) consisting of 10 GaAs/AlAs bilayers. The NP array is made up of disks 50 nm in height,
with 100 nm diameter and arranged in a square pattern with a period of 400 nm. A DBR is a selective reflector, in this case
designed to reflect light with wavelengths around 800 nm, close to the bandgap of GaAs where transmission losses would be highest.
The figure above shows that the simplest model, the BL law, does not give any front-surface reflection, with all the light absorbed
at short wavelengths. At longer wavelengths, there is some transmission into the GaAs substrate; although absorption in the DBR
will be calculated, the interference effects which lead to wavelength-selective reflection are ignored by the BL model.
The TMM model with the DBR removed from the structure shows a similar profile to the BL EQE, but significantly lower due
to reflection at the front surface. When the DBR is included, two clear new peaks in the EQE calculated using the TMM are
observed. Finally, when the full structure is modelled using RCWA, these peaks due to the DBR remain but the EQE at all
wavelengths is increased, due to an anti-reflection effect from the NPs and increased path length in the GaAs cell
due to diffraction effects.


.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    from solcore import si, material
    from solcore.structure import Junction, Layer
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver, default_options
    from solcore.light_source import LightSource
    from solcore.constants import vacuum_permittivity
    from solcore.optics import RCWASolverError

    # user options
    T = 298
    wl = si(np.linspace(400, 900, 80), 'nm')
    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl,
                               output_units='photon_flux_per_m', concentration=1)
    opts = default_options
    opts.wavelength, opts.no_back_reflection, opts.size, opts.light_source, opts.T_ambient = \
        wl, False, ((400, 0), (0, 400)), light_source, T
    opts.recalculate_absorption = True
    # The size of the unit cell for the RCWA structure is 400 x 400 nm

    # Defining all the materials we need
    Air = material('Air')(T=T)
    p_GaAs = material('GaAs')(T=T, Na=si('4e18cm-3'))  # for the GaAs cell emitter
    n_GaAs = material('GaAs')(T=T, Nd=si('2e17cm-3'))  # for the GaAs cell base
    AlAs, GaAs = material('AlAs')(T=T), material('GaAs')(T=T)  # for the DBR
    SiO2 = material('SiO2', sopra=True)(T=T)  # for the spacer layer
    TiO2 = material('TiO2', sopra=True)(T=T)  # for the nanoparticles

    # some parameters for the QE solver
    for mat in [n_GaAs, p_GaAs]:
        mat.hole_mobility, mat.electron_mobility, mat.permittivity = 3.4e-3, 5e-2, 9 * vacuum_permittivity
        n_GaAs.hole_diffusion_length, p_GaAs.electron_diffusion_length = si("500nm"), si("5um")

    # Define the different parts of the structure we will use. For the GaAs junction, we use the depletion approximation
    GaAs_junction = [Junction([Layer(width=si('100nm'), material=p_GaAs, role="emitter"),
                               Layer(width=si('400nm'), material=n_GaAs, role="base")], T=T, kind='DA')]

    # this creates 10 repetitions of the AlAs and GaAs layers, to make the DBR structure
    DBR = 10 * [Layer(width=si("73nm"), material=AlAs), Layer(width=si("60nm"), material=GaAs)]

    # The layer with nanoparticles
    NP_layer = [Layer(si('50nm'), Air, geometry=[{'type': 'circle', 'mat': TiO2, 'center': (200, 200),
                                                  'radius': 50}])]

    substrate = [Layer(width=si('50um'), material=GaAs)]
    spacer = [Layer(width=si('25nm'), material=SiO2)]

    # --------------------------------------------------------------------------
    # solar cell with SiO2 coating
    solar_cell = SolarCell(spacer + GaAs_junction + substrate)

    opts.optics_method = 'TMM'
    solar_cell_solver(solar_cell, 'qe', opts)
    TMM_EQE = solar_cell[1].eqe(opts.wavelength)

    opts.optics_method = 'BL'
    solar_cell_solver(solar_cell, 'qe', opts)
    BL_EQE = solar_cell[1].eqe(opts.wavelength)

    # --------------------------------------------------------------------------
    # as above, with a DBR on the back
    solar_cell = SolarCell(spacer + GaAs_junction + DBR + substrate)

    opts.optics_method = 'TMM'
    solar_cell_solver(solar_cell, 'qe', opts)
    TMM_EQE_DBR = solar_cell[1].eqe(opts.wavelength)

    # --------------------------------------------------------------------------
    # cell with TiO2 nanocylinder array on the front
    solar_cell = SolarCell(NP_layer + spacer + GaAs_junction + DBR + substrate)

    opts.optics_method = 'TMM'
    solar_cell_solver(solar_cell, 'qe', opts)
    TMM_EQE_NP = solar_cell[2].eqe(opts.wavelength)

    opts.optics_method = 'BL'
    solar_cell_solver(solar_cell, 'qe', opts)
    BL_EQE_NP = solar_cell[2].eqe(opts.wavelength)

    try:
        opts.optics_method = 'RCWA'
        opts.orders = 19  # number of diffraction orders to keep in the RCWA solver
        solar_cell_solver(solar_cell, 'qe', opts)
        RCWA_EQE_NP = solar_cell[2].eqe(opts.wavelength)
        RCWA_legend = 'RCWA (GaAs SC + NP array + DBR)'
    except RCWASolverError:
        RCWA_EQE_NP = np.zeros_like(BL_EQE_NP)
        RCWA_legend = '(RCWA solver S4 not available)'


    plt.figure()
    plt.plot(wl * 1e9, BL_EQE_NP, wl * 1e9, TMM_EQE, wl * 1e9, TMM_EQE_DBR, wl * 1e9, RCWA_EQE_NP)
    plt.legend(labels=['Beer-Lambert law (all structures)', 'TMM (GaAs SC)', 'TMM (GaAs SC + DBR)',
                       RCWA_legend])
    plt.xlabel("Wavelength (nm)")
    plt.ylabel("Quantum efficiency")
    plt.show()
Looking at the effect of substrate and the no_back_reflection option in the TMM solver
=====================================================================================

.. image:: substrate_RAT.png
   :width: 40%
.. image:: substrate_Adepth.png
   :width: 40%


.. code-block:: Python

	# TMM and RCWA solvers can take into account the presence of a substrate if it is specified in the solar_cell object.
	# This example illustrates this for the TMM solver.

	from solcore import material
	from solcore import si
	import matplotlib.pyplot as plt
	import numpy as np
	from solcore.solar_cell import default_GaAs, SolarCell, Layer, Junction
	from solcore.solar_cell_solver import solar_cell_solver
	from solcore.absorption_calculator import OptiStack


	T = 298

	GaAs = material('GaAs')(T = T)

	thin_GaAs = SolarCell([Layer(material = GaAs, width=si('500nm'))])

	GaAs_on_substrate = SolarCell([Layer(material = GaAs, width=si('500nm'))], substrate = GaAs)

	wl = si(np.linspace(300, 900, 200), 'nm')

	# Thin solar cell, no substrate - will get significant absorption enhancement from reflection at the GaAs/air interface at the back
	# MUST specify no_back_reflection = False, so that Solcore does not automatically suppress reflections from the back
	# (currently, the default setting in solcore is to suppress reflections from the back, so no_back_reflection = True
	solar_cell_solver(thin_GaAs, 'optics', user_options={'wavelength': wl, 'optics_method': 'TMM', 'no_back_reflection': False})
	z_pos = np.linspace(0, thin_GaAs.width, 201)
	profiles_thin = thin_GaAs[0].absorbed(z_pos)
	# Same thin solar cell, but now on a GaAs substrate. In this case, we get the same result whether or not we specify
	# no_back_reflection to be True or False, since with a GaAs on GaAs cell we don't get any reflection at the back interface anyway
	solar_cell_solver(GaAs_on_substrate, 'optics', user_options={'wavelength': wl, 'optics_method': 'TMM'})
	profiles_thick = GaAs_on_substrate[0].absorbed(z_pos)

	plt.figure()
	plt.plot(wl * 1e9,  thin_GaAs[0].layer_absorption)
	plt.plot(wl * 1e9,  GaAs_on_substrate[0].layer_absorption)

	# Now we consider the thin solar cell without substrate again but ask Solcore to suppress back reflections. We must also
	# ask Solcore to recalculate the absorption, otherwise it will just use the results calculated above which are already
	# in the thin_GaAs object
	# What no_back_reflection = True actually does is add a highly absorbing layer based on the final layer in the stack so that
	# nothing is reflected.

	solar_cell_solver(thin_GaAs, 'optics', user_options={'wavelength': wl, 'optics_method': 'TMM', 'no_back_reflection': True,
														 'recalculate_absorption': True})

	plt.plot(wl * 1e9,  thin_GaAs[0].layer_absorption, '--')
	plt.legend(labels=['No substrate (air below)', 'On GaAs substrate', 'No substrate, suppress back reflection'])
	plt.xlabel("Wavelength (nm)")
	plt.ylabel("Absorption")
	plt.show()
	# we can see that, correctly, the results for the cell with an explicitly specified GaAs substrate and for the thin
	# cell purposely suppressing back reflections are the same, while the thin cell with back reflections shows thin-film
	# oscillations in the absorption spectrum.

	# Let's look at what the absorption profile looks like...

	# absorption profile around 750 nm incident wavelength:
	plt.figure()
	plt.plot(z_pos*1e9, profiles_thin[:,150])
	plt.plot(z_pos*1e9, profiles_thick[:,150])
	plt.xlabel("Depth in GaAs junction (nm)")
	plt.show()


KP calculator and effective mass fitting
========================================

.. image:: kp.png
   :width: 35%
.. image:: eff_mass_fit.png
   :width: 50%

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    from solcore import material
    from solcore.constants import electron_mass
    from solcore.quantum_mechanics import kp_bands

    # Material parameters
    GaAs = material("GaAs")(T=300)
    InGaAs = material("InGaAs")

    # As a test, we solve the problem for an intermediate indium composition
    InGaAs2 = InGaAs(In=0.15, T=300)
    masses = kp_bands(InGaAs2, GaAs, graph=True, fit_effective_mass=True, effective_mass_direction="L", return_so=True)

    comp = np.linspace(0.01, 0.25, 15)
    me = []
    mhh = []
    mlh = []
    mso = []
    for i in comp:
        InGaAs2 = InGaAs(In=i, T=300)

        # Set graph = True to see the fitting of the bands
        c, hh, lh, so, m_eff_c, m_eff_hh, m_eff_lh, m_eff_so = kp_bands(InGaAs2, GaAs, graph=False, fit_effective_mass=True,
                                                                        effective_mass_direction="L", return_so=True)

        me.append(m_eff_c / electron_mass)
        mhh.append(m_eff_hh / electron_mass)
        mlh.append(m_eff_lh / electron_mass)
        mso.append(m_eff_so / electron_mass)

        print('Effective masses for In = {:2.3}%:'.format(i * 100))
        print('- m_e = {:1.3f} m0'.format(me[-1]))
        print('- m_hh = {:1.3f} m0'.format(mhh[-1]))
        print('- m_lh = {:1.3f} m0'.format(mlh[-1]))
        print('- m_so = {:1.3f} m0'.format(mso[-1]))
        print()

    plt.plot(comp * 100, me, 'b-o', label='e')
    plt.plot(comp * 100, mhh, 'r-o', label='hh')
    plt.plot(comp * 100, mlh, 'g-o', label='lh')
    plt.plot(comp * 100, mso, 'k-o', label='so')

    plt.xlabel("Indium content (%)")
    plt.ylabel("Effective mass (m$_0$)")
    plt.legend()
    plt.show()
Example of a PV solar array
===========================

.. image:: IV_solar_module.png
   :width: 40%
.. image:: IV_param_dispersion.png
   :width: 40%

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    from solcore.solar_cell import SolarCell
    from solcore.light_source import LightSource
    from solcore.spice.pv_module_solver import solve_pv_module
    from solcore.structure import Junction

    T = 298

    # First we define the properties of the MJ solar cell that the solar module is made of. We use junctions of kind 2-diode
    db_junction = Junction(kind='2D', T=T, reff=1, jref=300, Eg=0.66, A=1, R_series=0.00236, R_shunt=1e14, n=3.5)
    db_junction2 = Junction(kind='2D', T=T, reff=1, jref=300, Eg=1.4, A=1, R_series=0.00012, R_shunt=1e14, n=3.5)
    db_junction3 = Junction(kind='2D', T=T, reff=1, jref=300, Eg=1.9, A=1, R_series=8.0e-5, R_shunt=1e14, n=3.5)

    my_solar_cell = SolarCell([db_junction3, db_junction2, db_junction], T=T, R_series=0.0, area=0.1)

    wl = np.linspace(350, 2000, 301) * 1e-9
    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl, output_units='photon_flux_per_m',
                               concentration=1)

    options = {'light_iv': True, 'wavelength': wl, 'light_source': light_source}

    # After defining the individual solar cell, we solve the module IV characteristics adding some dispersion in the
    # values of the short circuit currents.
    voltage, current, all_Isc_values, raw_data = solve_pv_module(my_solar_cell, options, jscSigma=0.02)

    plt.figure(1)

    plt.subplot(311)
    plt.title('Histogram of sub-cell photocurrents')
    plt.ylabel('InGaP')
    plt.hist(([row[0] for row in all_Isc_values]), bins=20)

    plt.subplot(312)
    plt.hist(([row[1] for row in all_Isc_values]), bins=20)
    plt.ylabel('GaAs')

    plt.subplot(313)
    plt.xlabel('Current (A)')
    plt.ylabel('Ge')
    plt.hist(([row[2] for row in all_Isc_values]), bins=20)

    plt.figure(2)
    plt.plot(voltage, current)
    plt.xlabel('Voltage (V)')
    plt.ylabel('Current (A)')
    plt.xlim(0, 80)
    plt.ylim(0, 17)

    plt.show()
Example of a 3J solar cell calculated with the DA solver
=========================================================

.. image:: DA_iv.png
   :width: 40%
.. image:: DA_qe.png
   :width: 40%

- Required extra files, available in `Solcore's Github repository (Examples folder) <https://github.com/dalonsoa/solcore5>`_:

    - MgF-ZnS_AR.csv
    - in01gaas.csv
    - Ge-Palik.csv

.. code-block:: Python

    import os
    import numpy as np
    import matplotlib.pyplot as plt

    from solcore import siUnits, material, si
    from solcore.interpolate import interp1d
    from solcore.solar_cell import SolarCell
    from solcore.structure import Junction, Layer
    from solcore.solar_cell_solver import solar_cell_solver

    all_materials = []


    def this_dir_file(f):
        return os.path.join(os.path.split(__file__)[0], f)


    # We need to build the solar cell layer by layer.
    # We start from the AR coating. In this case, we load it from an an external file
    refl_nm = np.loadtxt(this_dir_file("MgF-ZnS_AR.csv"), unpack=True, delimiter=",")
    ref = interp1d(x=siUnits(refl_nm[0], "nm"), y=refl_nm[1], bounds_error=False, fill_value=0)

    # TOP CELL - GaInP
    # Now we build the top cell, which requires the n and p sides of GaInP and a window layer.
    # We also load the absorption coefficient from an external file. We also add some extra parameters needed for the
    # calculation such as the minority carriers diffusion lengths
    AlInP = material("AlInP")
    InGaP = material("GaInP")
    window_material = AlInP(Al=0.52)
    top_cell_n_material = InGaP(In=0.49, Nd=siUnits(2e18, "cm-3"), hole_diffusion_length=si("200nm"))
    top_cell_p_material = InGaP(In=0.49, Na=siUnits(1e17, "cm-3"), electron_diffusion_length=si("1um"))

    all_materials.append(window_material)
    all_materials.append(top_cell_n_material)
    all_materials.append(top_cell_p_material)

    # MID CELL  - InGaAs
    # We add manually the absorption coefficient of InGaAs since the one contained in the database doesn't cover
    # enough range, keeping in mind that the data has to be provided as a function that takes wavelengths (m) as input and
    # returns absorption (1/m)
    InGaAs = material("InGaAs")
    InGaAs_alpha = np.loadtxt(this_dir_file("in01gaas.csv"), unpack=True, delimiter=",")
    InGaAs.alpha = interp1d(x=1240e-9 / InGaAs_alpha[0][::-1], y=InGaAs_alpha[1][::-1], bounds_error=False, fill_value=0)

    mid_cell_n_material = InGaAs(In=0.01, Nd=siUnits(3e18, "cm-3"), hole_diffusion_length=si("500nm"))
    mid_cell_p_material = InGaAs(In=0.01, Na=siUnits(1e17, "cm-3"), electron_diffusion_length=si("5um"))

    all_materials.append(mid_cell_n_material)
    all_materials.append(mid_cell_p_material)

    # BOTTOM CELL - Ge
    # We add manually the absorption coefficient of Ge since the one contained in the database doesn't cover
    # enough range.
    Ge = material("Ge")
    Ge_alpha = np.loadtxt(this_dir_file("Ge-Palik.csv"), unpack=True, delimiter=",")
    Ge.alpha = interp1d(x=1240e-9 / Ge_alpha[0][::-1], y=Ge_alpha[1][::-1], bounds_error=False, fill_value=0)

    bot_cell_n_material = Ge(Nd=siUnits(2e18, "cm-3"), hole_diffusion_length=si("800nm"))
    bot_cell_p_material = Ge(Na=siUnits(1e17, "cm-3"), electron_diffusion_length=si("50um"))

    all_materials.append(bot_cell_n_material)
    all_materials.append(bot_cell_p_material)

    # We add some other properties to the materials, assumed the same in all cases, for simplicity.
    # If different, we should have added them above in the definition of the materials.
    for mat in all_materials:
        mat.hole_mobility = 5e-2
        mat.electron_mobility = 3.4e-3
        mat.hole_mobility = 3.4e-3
        mat.electron_mobility = 5e-2
        mat.relative_permittivity = 9

    # And, finally, we put everything together, adding also the surface recombination velocities. We also add some shading
    # due to the metallisation of the cell = 8%, and indicate it has an area of 0.7x0.7 mm2 (converted to m2)
    solar_cell = SolarCell(
        [
            Junction([Layer(si("25nm"), material=window_material, role='window'),
                      Layer(si("100nm"), material=top_cell_n_material, role='emitter'),
                      Layer(si("600nm"), material=top_cell_p_material, role='base'),
                      ], sn=1, sp=1, kind='DA'),
            Junction([Layer(si("200nm"), material=mid_cell_n_material, role='emitter'),
                      Layer(si("3000nm"), material=mid_cell_p_material, role='base'),
                      ], sn=1, sp=1, kind='DA'),
            Junction([Layer(si("400nm"), material=bot_cell_n_material, role='emitter'),
                      Layer(si("100um"), material=bot_cell_p_material, role='base'),
                      ], sn=1, sp=1, kind='DA'),
        ], reflectivity=ref, shading=0.08, cell_area=0.7 * 0.7 / 1e4)

    wl = np.linspace(300, 1800, 700) * 1e-9
    solar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl})

    plt.figure(1)
    plt.plot(wl * 1e9, solar_cell[0].eqe(wl) * 100, 'b', label='GaInP')
    plt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'g', label='InGaAs')
    plt.plot(wl * 1e9, solar_cell[2].eqe(wl) * 100, 'r', label='Ge')

    plt.legend()
    plt.ylim(0, 100)
    plt.ylabel('EQE (%)')
    plt.xlabel('Wavelength (nm)')

    V = np.linspace(0, 3, 300)
    solar_cell_solver(solar_cell, 'iv', user_options={'voltages': V, 'light_iv': True, 'wavelength': wl})

    plt.figure(2)
    plt.plot(V, solar_cell.iv['IV'][1], 'k', linewidth=3, label='Total')
    plt.plot(V, -solar_cell[0].iv(V), 'b', label='GaInP')
    plt.plot(V, -solar_cell[1].iv(V), 'g', label='InGaAs')
    plt.plot(V, -solar_cell[2].iv(V), 'r', label='Ge')

    plt.legend()
    plt.ylim(0, 200)
    plt.xlim(0, 3)
    plt.ylabel('Current (A/m$^2$)')
    plt.xlabel('Voltage (V)')

    plt.show()
Setting up the options for and defining custom materials
========================================================

.. image:: SiGeSn_nk.png
   :width: 40%
.. image:: Diamond_nk.png
   :width: 40%


.. code-block:: Python

	from solcore import material
	from solcore import si
	from solcore.material_system import create_new_material
	from solcore.absorption_calculator import create_nk_txt, download_db, search_db
	from solcore.config_tools import add_source
	import matplotlib.pyplot as plt
	import numpy as np
	import os

	# first we need to tell Solcore some things about where to put custom materials. for this,
	# we use the add_source function from config_tools, although we could also manually edit
	# the solcore configuration file (which should be in your home directory).
	# You need to add two things to the config file: where to put the n and k data for new
	# materials added to the database, and where to put the other parameters (these can all
	# go in the same file).

	home_folder = os.path.expanduser('~')
	custom_nk_path = os.path.join(home_folder, 'Solcore/custommats')
	nk_db_path = os.path.join(home_folder, 'Solcore/NK.db')
	param_path = os.path.join(home_folder, 'Solcore/custom_params.txt')

	add_source('Others', 'custom_mats', custom_nk_path)
	add_source('Others', 'nk', nk_db_path)
	add_source('Parameters', 'custom', param_path)

	# EXAMPLE 1

	# need to have n and k data, and a parameter file in the correct format -
	# see examples of parameter files in e.g. material_data/Adachi/binaries.txt

	# create a new material, silicon-germanium-tin, from input files. Here,
	# the parameters in SiGeSn_params.txt have been copied directly from Ge.
	create_new_material('SiGeSn', 'SiGeSn_n.txt', 'SiGeSn_k.txt', 'SiGeSn_params.txt')

	# can now create an instance of it like any Solcore material
	SiGeSn = material('SiGeSn')()

	plt.figure()
	plt.plot(si(np.arange(300, 1700, 5), 'nm')*1e9, SiGeSn.n(si(np.arange(300, 1700, 5), 'nm')))
	plt.plot(si(np.arange(300, 1700, 5), 'nm')*1e9, SiGeSn.k(si(np.arange(300, 1700, 5), 'nm')))
	plt.show()

	# EXAMPLE 2
	# Can also create a Solcore material from a material in the refractiveindex.info database:

	# if necessary, download database:
	download_db()

	# search what options are available for diamond, then use the first result's pageid to
	# create data files for the n & k of diamond:

	results = search_db('Diamond')
	create_nk_txt(pageid=results[0][0], file='C_Diamond')
	create_new_material(mat_name = 'Diamond', n_source='C_Diamond_n.txt', k_source='C_Diamond_k.txt')

	Diamond = material('Diamond')()

	plt.figure()
	plt.plot(si(np.arange(100, 800, 5), 'nm')*1e9, Diamond.n(si(np.arange(100, 800, 5), 'nm')))
	plt.plot(si(np.arange(100, 800, 5), 'nm')*1e9, Diamond.k(si(np.arange(100, 800, 5), 'nm')))
	plt.show()
Example of a tunnel junction
============================

.. image:: tunnel_junction.png
    :width: 60%
    :align: center

.. code-block:: Python

    import matplotlib.pyplot as plt

    from solcore.structure import TunnelJunction
    from solcore.solar_cell_solver import default_options
    from solcore.analytic_solar_cells import parametric_tunnel_junction

    # We define the tunnel junction and solve its properties
    tunnel = TunnelJunction(v_peak=0.2, j_peak=100, v_valley=0.9, j_valley=10, prefactor=10, j01=1e-21, kind='parametric')
    parametric_tunnel_junction(tunnel, default_options)

    v = tunnel.voltage

    plt.plot(v, tunnel.tunnel_current(v), 'r--', label='Tunnel')
    plt.plot(v, tunnel.excess_current(v), 'g--', label='Excess')
    plt.plot(v, tunnel.diffusion_current(v), 'b--', label='Diffusion')
    plt.plot(v, tunnel.current, 'k', linewidth=3, color='DimGray', label='Total')
    plt.plot((0.2, 0.9), (100, 10), 'ko')

    plt.annotate('V$_P$, J$_P$', xy=(0.2, 110), fontsize=12)
    plt.annotate('V$_V$, J$_V$', xy=(0.6, 10), fontsize=12)

    plt.legend(fontsize=12, frameon=False)
    plt.ylim(0, 150)
    plt.xlim(0, 2)
    plt.ylabel('Current Density(A/$m^2$)', fontsize=12)
    plt.xlabel('Voltage(V)', fontsize=12)
    plt.tick_params(labelsize=12)
    plt.tight_layout()
    plt.show()
Example of the creation of light sources
========================================

.. image:: ls_compare.png
   :width: 40%
.. image:: ls_smarts.png
   :width: 40%

**Note**: This script requires having SMARTS installed and correctly configured. If you do not have it, comment those lines related to the SMARTS light source.

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    from solcore.light_source import LightSource

    # The wavelength range of the spectra
    wl = np.linspace(300, 3000, 200)

    # Now different types of light sources can be defined
    gauss = LightSource(source_type='laser', x=wl, center=800, linewidth=50, power=200)
    bb = LightSource(source_type='black body', x=wl, T=5800, entendue='Sun')
    am15g = LightSource(source_type='standard', x=wl, version='AM1.5g')
    smarts = LightSource(source_type='SMARTS', x=wl)
    spectral = LightSource(source_type='SPECTRAL2', x=wl)

    # Plot comparing the different light sources
    plt.figure(1)
    plt.plot(*gauss.spectrum(), label='Gauss')
    plt.plot(*bb.spectrum(), label='Black body')
    plt.plot(*am15g.spectrum(), label='AM1.5G')
    plt.plot(*smarts.spectrum(), label='SMARTS')
    plt.plot(*spectral.spectrum(), label='SPECTRAL2')

    plt.xlim(300, 3000)
    plt.xlabel('Wavelength (nm)')
    plt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')
    plt.tight_layout()
    plt.legend()

    # Plot comparing the spectra calculated with SMARTS at different hours of the day
    plt.figure(2)
    for h in range(8, 20):
        plt.plot(*smarts.spectrum(HOUR=h), label='{} h'.format(h))

    plt.xlim(300, 3000)
    plt.xlabel('Wavelength (nm)')
    plt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')
    plt.tight_layout()
    plt.legend()
    plt.show()

Example of a 2J solar cell calculated with the PDD solver
=========================================================

.. image:: PDD_carrier_density.png
   :width: 40%
.. image:: PDD_IV.png
   :width: 40%
.. image:: PDD_qe.png
   :width: 40%

.. code-block:: Python

    import matplotlib.pyplot as plt
    import numpy as np

    from solcore.solar_cell import SolarCell, default_GaAs
    from solcore.structure import Layer, Junction
    from solcore import si
    from solcore import material
    from solcore.light_source import LightSource
    from solcore.solar_cell_solver import solar_cell_solver

    T = 298

    substrate = material('GaAs')(T=T)


    def AlGaAs(T):
        # We create the other materials we need for the device
        window = material('AlGaAs')(T=T, Na=5e24, Al=0.8)
        p_AlGaAs = material('AlGaAs')(T=T, Na=1e24, Al=0.4)
        n_AlGaAs = material('AlGaAs')(T=T, Nd=8e22, Al=0.4)
        bsf = material('AlGaAs')(T=T, Nd=2e24, Al=0.6)

        output = Junction([Layer(width=si('30nm'), material=window, role="Window"),
                           Layer(width=si('150nm'), material=p_AlGaAs, role="Emitter"),
                           Layer(width=si('1000nm'), material=n_AlGaAs, role="Base"),
                           Layer(width=si('200nm'), material=bsf, role="BSF")], sn=1e6, sp=1e6, T=T, kind='PDD')

        return output


    my_solar_cell = SolarCell([AlGaAs(T), default_GaAs(T)], T=T, R_series=0, substrate=substrate)

    Vin = np.linspace(-2, 2.61, 201)
    V = np.linspace(0, 2.6, 300)
    wl = np.linspace(350, 1000, 301) * 1e-9
    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl, output_units='photon_flux_per_m',
                               concentration=1)

    # We calculate the IV curve under illumination
    solar_cell_solver(my_solar_cell, 'iv',
                      user_options={'T_ambient': T, 'db_mode': 'boltzmann', 'voltages': V, 'light_iv': True,
                                    'wavelength': wl, 'optics_method': 'BL', 'mpp': True, 'internal_voltages': Vin,
                                    'light_source': light_source})

    # We can plot the electron and hole densities in equilibrium and at short circuit, both calculated automatically
    # before calculating the IV curve
    plt.figure(1)
    for j in my_solar_cell.junction_indices:
        zz = my_solar_cell[j].short_circuit_data.Bandstructure['x'] + my_solar_cell[j].offset
        n = my_solar_cell[j].short_circuit_data.Bandstructure['n']
        p = my_solar_cell[j].short_circuit_data.Bandstructure['p']
        plt.semilogy(zz, n, 'b')
        plt.semilogy(zz, p, 'r')

        zz = my_solar_cell[j].equilibrium_data.Bandstructure['x'] + my_solar_cell[j].offset
        n = my_solar_cell[j].equilibrium_data.Bandstructure['n']
        p = my_solar_cell[j].equilibrium_data.Bandstructure['p']
        plt.semilogy(zz, n, 'b--')
        plt.semilogy(zz, p, 'r--')

    plt.xlabel('Position (m)')
    plt.ylabel('Carrier density (m$^{-3}$)')

    # And the IV curves of the individual junctions and of the MJ device
    plt.figure(2)
    plt.plot(V, abs(my_solar_cell[0].iv(V)), 'b', label='AlGaAs')
    plt.plot(V, abs(my_solar_cell[1].iv(V)), 'r', label='GaAs')
    plt.plot(my_solar_cell.iv.IV[0], abs(my_solar_cell.iv.IV[1]), 'k', label='MJ')

    plt.legend()
    plt.xlim(0, 2.6)
    plt.ylim(0, 200)
    plt.xlabel('Bias (V)')
    plt.ylabel('Current (A/m$^2}$)')

    # Now we calculate the quantum efficiency
    solar_cell_solver(my_solar_cell, 'qe',
                      user_options={'T_ambient': T, 'db_mode': 'boltzmann', 'voltages': V, 'light_iv': True,
                                    'wavelength': wl, 'optics_method': 'BL', 'mpp': True, 'internal_voltages': Vin,
                                    'light_source': light_source})

    plt.figure(3)

    plt.plot(wl * 1e9, my_solar_cell[0].eqe(wl), 'b', label='AlGaAs')
    plt.plot(wl * 1e9, my_solar_cell[1].eqe(wl), 'r', label='GaAs')

    plt.xlabel('Wavelength (nm)')
    plt.ylabel('EQE')

    plt.show()
Setting up the options for and defining custom materials
========================================================

.. image:: Single_QW.png
   :width: 40%
.. image:: MQW_LDOS.png
   :width: 40%

.. code-block:: Python

    from solcore import si, material
    from solcore.structure import Layer, Structure
    import solcore.quantum_mechanics as QM

    # First we create the materials we need
    bulk = material("GaAs")(T=293, strained=False)
    barrier = material("GaAsP")(T=293, P=0.1, strained=True)

    # As well as some of the layers
    top_layer = Layer(width=si("30nm"), material=barrier)
    inter = Layer(width=si("3nm"), material=bulk)
    barrier_layer = Layer(width=si("5nm"), material=barrier)
    bottom_layer = top_layer

    # We create the QW material at the given composition
    QW = material("InGaAs")(T=293, In=0.15, strained=True)

    # And the layer
    well_layer = Layer(width=si("7.2nm"), material=QW)

    # The following lines create the QW structure, with different number of QWs and interlayers. Indicating the substrate
    # material with the keyword "substrate" is essential in order to calculate correctly the strain.

    # A single QW with interlayers
    test_structure_1 = Structure([top_layer, inter, well_layer, inter, bottom_layer], substrate=bulk)
    output_1 = QM.schrodinger(test_structure_1, quasiconfined=0, graphtype='potentials', num_eigenvalues=20, show=True)

    # 10 QWs without interlayers
    test_structure_2 = Structure([top_layer, barrier_layer] + 10 * [well_layer, barrier_layer] + [bottom_layer],
                                 substrate=bulk)
    output_2 = QM.schrodinger(test_structure_2, quasiconfined=0.05, graphtype='potentialsLDOS', num_eigenvalues=200,
                              show=True)
Example of using the DB solver to calculate the efficiency map of a 3J solar cell
=================================================================================

.. image:: MJ_efficiency_map.png
   :width: 40%
.. image:: MJ_IV_optimal.png
   :width: 40%

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib import cm

    from solcore.light_source import LightSource
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver
    from solcore.structure import Junction

    # Illumination spectrum
    wl = np.linspace(300, 4000, 4000) * 1e-9
    light = LightSource(source_type='standard', version='AM1.5g', x=wl, output_units='photon_flux_per_m')

    T = 298
    V = np.linspace(0, 5, 500)


    # This function assembles the solar cell and calculates the IV cruve
    def solve_MJ(EgBot, EgMid, EgTop):
        db_junction0 = Junction(kind='DB', T=T, Eg=EgBot, A=1, R_shunt=np.inf, n=3.5)
        db_junction1 = Junction(kind='DB', T=T, Eg=EgMid, A=1, R_shunt=np.inf, n=3.5)
        db_junction2 = Junction(kind='DB', T=T, Eg=EgTop, A=1, R_shunt=np.inf, n=3.5)

        my_solar_cell = SolarCell([db_junction2, db_junction1, db_junction0], T=T, R_series=0)

        solar_cell_solver(my_solar_cell, 'iv',
                          user_options={'T_ambient': T, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,
                                        'internal_voltages': np.linspace(-6, 5, 1100), 'wavelength': wl,
                                        'mpp': True, 'light_source': light})

        return my_solar_cell


    # We create an efficiency map using Eg0 as the bandgap of the bottom junction and scanning the bandgaps of the middle
    # and top junctions
    N1 = 30
    N2 = 30
    Eg0 = 1.12

    all_Eg1 = np.linspace(1.3, 1.8, N1)
    all_Eg2 = np.linspace(1.7, 2.4, N2)
    eff = np.zeros((N1, N2))

    N = N1 * N2
    index = 0
    Effmax = -1
    Eg1_max = all_Eg1[0]
    Eg2_max = all_Eg2[0]

    # And we run the calculation
    for i, Eg1 in enumerate(all_Eg1):
        for j, Eg2 in enumerate(all_Eg2):

            my_solar_cell = solve_MJ(Eg0, Eg1, Eg2)
            mpp = my_solar_cell.iv.Pmpp

            eff[i, j] = mpp

            if mpp > Effmax:
                Effmax = mpp
                Eg1_max = Eg1
                Eg2_max = Eg2

            index += 1
            print(int(index / N * 100), '%\n')

    optimum_MJ = solve_MJ(Eg0, Eg1_max, Eg2_max)

    plt.figure(1)
    plt.plot(V, optimum_MJ.iv.IV[1], 'k', linewidth=4, label='Total')
    plt.plot(V, -optimum_MJ[0].iv(V), 'r', label='Bottom')
    plt.plot(V, -optimum_MJ[1].iv(V), 'g', label='Middle')
    plt.plot(V, -optimum_MJ[2].iv(V), 'b', label='Top')
    plt.ylim(0, 200)
    plt.xlim(0, 3.75)
    plt.legend()
    plt.xlabel('Voltage (V)')
    plt.ylabel('Current (A/m$^2$)')

    plt.figure(2)
    eff = eff / light.power_density * 100
    plt.contourf(all_Eg2, all_Eg1, eff, 50, cmap=cm.jet)
    plt.xlabel('TOP Eg (eV)')
    plt.ylabel('MID Eg (eV)')
    cbar = plt.colorbar()
    cbar.set_label('Efficiency (%)', rotation=270, labelpad=10)
    plt.tight_layout()
    plt.show()
Searching the refractiveindex.info database and comparing materials
===================================================================

.. image:: Ag_n.png
   :width: 40%
.. image:: Ag_k.png
   :width: 40%
.. image:: Ag_GaAs_abs.png
   :width: 40%


.. code-block:: Python

	from solcore.absorption_calculator.nk_db import download_db, search_db
	from solcore import material
	from solcore import si
	from solcore.solar_cell import SolarCell
	from solcore.structure import Layer
	from solcore.solar_cell_solver import solar_cell_solver, default_options

	import numpy as np
	import matplotlib.pyplot as plt

	wl = si(np.arange(100, 900, 10), 'nm')

	opts = default_options
	opts.optics_method = 'TMM'
	opts.wavelength = wl
	# Download the database from refractiveindex.info. This only needs to be done once.
	# Can specify the source URL and number of interpolation points.
	# download_db()

	# Can search the database to select an appropriate entry. Search by element/chemical formula.
	# In this case, look for silver.

	search_db('Ag', exact = True)
	# This prints out, line by line, matching entries. This shows us entries with
	# "pageid"s 0 to 14 correspond to silver.

	# Let's compare the optical behaviour of some of those sources:
	# pageid = 0, Johnson
	# pageid = 2, McPeak
	# pageid = 8, Hagemann
	# pageid = 12, Rakic (BB)

	# create instances of materials with the optical constants from the database.
	# The name (when using Solcore's built-in materials, this would just be the
	# name of the material or alloy, like 'GaAs') is the pageid, AS A STRING, while
	# the flag nk_db must be set to True to tell Solcore to look in the previously
	# downloaded database from refractiveindex.info
	Ag_Joh = material(name = '0', nk_db=True)()
	Ag_McP = material(name = '2', nk_db=True)()
	Ag_Hag = material(name = '8', nk_db=True)()
	Ag_Rak = material(name = '12', nk_db=True)()

	Ag_Sol = material(name = 'Ag')() # Solcore built-in (from SOPRA)

	# plot the n and k data. Note that not all the data covers the full wavelength range,
	# so the n/k value stays flat.

	names = ['Johnson', 'McPeak', 'Hagemann', 'Rakic', 'Solcore built-in']

	plt.figure()
	plt.plot(wl * 1e9, Ag_Joh.n(wl), wl * 1e9, Ag_McP.n(wl),
			 wl * 1e9, Ag_Hag.n(wl), wl * 1e9, Ag_Rak.n(wl), wl * 1e9, Ag_Sol.n(wl))
	plt.legend(labels=names)
	plt.xlabel("Wavelength (nm)")
	plt.ylabel("n")
	plt.show()

	plt.figure()
	plt.plot(wl * 1e9, Ag_Joh.k(wl), wl * 1e9, Ag_McP.k(wl),
			 wl * 1e9, Ag_Hag.k(wl), wl * 1e9, Ag_Rak.k(wl), wl * 1e9, Ag_Sol.k(wl))
	plt.legend(labels=names)
	plt.xlabel("Wavelength (nm)")
	plt.ylabel("k")
	plt.show()

	# Compare performance as a back mirror on a GaAs 'cell'
	# Solid line: absorption in GaAs
	# Dashed line: absorption in Ag

	GaAs = material('GaAs')()

	colors = ['b', 'r', 'k', 'm', 'y']

	plt.figure()
	for c, Ag_mat in enumerate([Ag_Joh, Ag_McP, Ag_Hag, Ag_Rak, Ag_Sol]):
		my_solar_cell = SolarCell([Layer(width=si('50nm'), material = GaAs)] +
								[Layer(width = si('100nm'), material = Ag_mat)])
		solar_cell_solver(my_solar_cell, 'optics', opts)
		GaAs_positions = np.linspace(my_solar_cell[0].offset, my_solar_cell[0].offset + my_solar_cell[0].width, 1000)
		Ag_positions = np.linspace(my_solar_cell[1].offset, my_solar_cell[1].offset + my_solar_cell[1].width, 1000)
		GaAs_abs = np.trapz(my_solar_cell[0].diff_absorption(GaAs_positions), GaAs_positions)
		Ag_abs = np.trapz(my_solar_cell[1].diff_absorption(Ag_positions), Ag_positions)
		plt.plot(wl*1e9, GaAs_abs, color=colors[c], linestyle='-', label=names[c])
		plt.plot(wl*1e9, Ag_abs, color=colors[c], linestyle='--')

	plt.legend()
	plt.xlabel("Wavelength (nm)")
	plt.ylabel("Absorbed")
	plt.show()

Example of a quasi-3D modelling of a 3J solar cell
==================================================

(code shown for 1J, but the extension is immediate)

.. image:: square_mask_V1_3.png
   :width: 40%
.. image:: square_mask_IV.png
   :width: 40%

.. image:: circular_mask_V1_3.png
   :width: 40%
.. image:: circular_mask_IV.png
   :width: 40%


- Required extra files, available in `Solcore's Github repository (Examples folder) <https://github.com/dalonsoa/solcore5>`_:

    - masks_illumination.png
    - masks_sq.png
    - masks_cl.png

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    from solcore.structure import Junction
    from solcore.solar_cell import SolarCell
    from solcore.light_source import LightSource
    from solcore.spice import solve_quasi_3D

    # First we load the masks defining the illumination pattern and the contacts. Both must be greyscale images
    # The solver expect images with values between 0 and 255 and imread of a PNG image is between 0 and 1, even when
    # it is in grey, so we scale it multiplying by 255. If the image were JPG, the result would be already in (0,255).
    illuminationMask = (plt.imread('masks_illumination.png') * 255).astype(np.int)
    contactsMask = (plt.imread('masks_sq.png') * 255).astype(np.int)

    nx, ny = illuminationMask.shape

    # For symmetry arguments (not completely true for the illumination), we can mode just 1/4 of the device and then
    # multiply the current by 4
    illuminationMask = illuminationMask[int(nx / 2):, int(ny / 2):]
    contactsMask = contactsMask[int(nx / 2):, int(ny / 2):]

    # Size of the pixels (m)
    Lx = 10e-6
    Ly = 10e-6

    # Height of the metal fingers (m)
    h = 2.2e-6

    # Contact resistance (Ohm m2)
    Rcontact = 3e-10

    # Resistivity metal fingers (Ohm m)
    Rline = 2e-8

    # Bias (V)
    vini = 0
    vfin = 1.3
    step = 0.01

    T = 298
    db_junction = Junction(kind='2D', T=T, reff=1, jref=300, Eg=0.66, A=1, R_sheet_top=100, R_sheet_bot=1e-16,
                           R_shunt=1e16, n=3.5)
    db_junction2 = Junction(kind='2D', T=T, reff=1, jref=300, Eg=1.4, A=1, R_sheet_top=100, R_sheet_bot=1e-16,
                            R_shunt=1e16, n=3.5)
    db_junction3 = Junction(kind='2D', T=T, reff=0.5, jref=300, Eg=1.8, A=1, R_sheet_top=100, R_sheet_bot=100,
                            R_shunt=1e16, n=3.5)

    # For a single junction, this will have >28800 nodes and for the full 3J it will be >86400, so it is worth to
    # exploit symmetries whenever possible. A smaller number of nodes also makes the solver more robust.
    my_solar_cell = SolarCell([db_junction2], T=T)

    wl = np.linspace(350, 2000, 301) * 1e-9
    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl, output_units='photon_flux_per_m',
                               concentration=100)

    options = {'light_iv': True, 'wavelength': wl, 'light_source': light_source}

    V, I, Vall, Vmet = solve_quasi_3D(my_solar_cell, illuminationMask, contactsMask, options=options, Lx=Lx, Ly=Ly, h=h,
                                      R_back=1e-16, R_contact=Rcontact, R_line=Rline, bias_start=vini, bias_end=vfin,
                                      bias_step=step)

    # Since we model 1/4 of the device, we multiply the current by 4
    I = I * 4

    # This will plot the voltage at the last external voltage point V=1.3 V for the top layer of the top junction.
    plt.figure(1)
    plt.imshow(Vall[:, :, -2, -1])

    plt.figure(2)
    plt.semilogy(V, abs(I))
    plt.show()
Tutorial: 2J solar cell with QWs in the bottom cell
===================================================

This tutorial will guide you, step-by-step, in the creation of a solar
cell and the calculation of their properties using *Solcore*.

**What do we have?**

-  Dual junction GaInP/GaAs solar cell, lattice matched to GaAs.
-  The bottom cell has 30 strained-balanced quantum wells (QW), made of
   GaAsP/InGaAs.
-  There is a tunnel junction in between the subcells.
-  There is a dual layer anti-reflecting coating on the front made of
   MgF-ZnS

**What do we want to find out?**

-  The absorption properties of our QWs
-  The QE of the solar cell
-  Its efficiency (Eff), short circuit current (Isc), open circuit
   voltage (Voc) and fill factor (FF) as a function of the
   concentration.

Let's get started!

Defining the structure
----------------------

First we need to create the solar cell structure. It is made of several
bits and pieces: the QWs, 2xJunctions, 1x tunnel junction and the ARC.
We start with the first.

**Defining the QWs:**

.. code:: python

    from solcore import material
    from solcore.structure import Layer
    import solcore.poisson_drift_diffusion as PDD
    import numpy as np

    T = 300 
    wl = np.linspace(350, 1050, 1001) * 1e-9

    # First, we create the materials of the QW
    QWmat = material('InGaAs')(T=T, In=0.2, strained=True)
    Bmat = material('GaAsP')(T=T, P=0.1, strained=True)
    i_GaAs = material('GaAs')(T=T)

    # The QW is 7 nm wide, with GaAs interlayers 2 nm thick at each side and GaAsP barriers 10 nm thick.
    # The final device will have 30 of these QWs.
    QW = PDD.QWunit([Layer(width=10e-9, material=Bmat, role="barrier"),
                 Layer(width=2e-9, material=i_GaAs, role="well"),
                 Layer(width=7e-9, material=QWmat, role="well"),
                 Layer(width=2e-9, material=i_GaAs, role="well"),
                 Layer(width=10e-9, material=Bmat, role="barrier")], T=T, repeat=30, substrate=i_GaAs)

    # We solve the quantum properties of the QW, leaving the default values of all parameters
    QW_list = QW.GetEffectiveQW(wavelengths=wl)

The first few lines import the *Solcore* utilities needed to define the
structure, including the *material* function, the *Layer* class and the
Poisson-Drift-Diffusion solver. After that, we create the materials that
will made the QWs and create a "QWunit". We will use these
structure just to be able to solve the QWs afterwards and transform it
into a sequence of layers with effective properties that the PDD solver
understands. The call to "QWunit" has several inputs,
including the temperature, the substrate, the number of repetition of
the QWs and the structure of the layers. The call to "GetEffectiveQW"
will, indeed, use the utilities within the *quantum\_mechanics* module
to calculate the band structure of the QWs, their absorption coefficient
and, finally, will calculate effective bandgap, density of states, etc.
that the PDD solver will use. Although the device will have 30 quantum
wells, only one unit (the one indicated in *Layers*) will be modelled as
an isolated QW.

If we only want to solve the properties of the QWs, without creating an
effective structure for the PDD solver, we will use, instead:

.. code:: python

    from solcore import material
    from solcore.structure import Layer, Structure
    import solcore.quantum_mechanics as QM

    T = 300 

    # First, we create the materials of the QW
    QWmat = material('InGaAs')(T=T, In=0.2, strained=True)
    Bmat = material('GaAsP')(T=T, P=0.1, strained=True)
    i_GaAs = material('GaAs')(T=T)

    # The QW is 7 nm wide, with GaAs interlayers 2 nm thick at each side and GaAsP barriers 10 nm thick.
    QW = Structure([Layer(width=10e-9, material=Bmat, role="barrier"),
                    Layer(width=2e-9, material=i_GaAs, role="interlayer"),
                    Layer(width=7e-9, material=QWmat, role="well"),
                    Layer(width=2e-9, material=i_GaAs, role="interlayer"),
                    Layer(width=10e-9, material=Bmat, role="barrier") ], 
                    substrate = i_GaAs)

    # Finally, the quantum properties are calculated here
    output = QM.schrodinger(QW)                     

While *Solcore* can solve the Schrödinger equation in a structure with
any number of layers, the absorption calculator for QWs can only deal
properly with single QWs. That is the reason of modelling only 1 QW
despite having 30 in the structure. This will clearly represent a
limitation when modelling the absorption of superlattices, where there
is a strong coupling between neighbouring QWs.

In the code above, we have used the "GetEffectiveQW" and
"QM.schrodinger" functions with the default values, but they both can
have a number of optional input parameters to define the number of
confined states to calculate, the energy of quasiconfined states,
electric field, boundary conditions, etc. Please, visit the
documentation of those functions to find out all the available options.

**Defining the junctions:**

In order to calculate the properties of a solar junction using the PDD
solver, we need to give all the layers and materials the junciton is
made of, in a similar way we have done for the QWs. One thing to note is
that if *Solcore* cannot find a property it needs to solve the PDD
equations, *it will take the corresponding property for GaAs as a
default value*. So, be sure you provide all the required values or that
you are happy with the defaults.

***NOTE***: The different code snippets are additive in order to get a
final, complete script. Normally, all the "import" statements would be
packed together at the beginning.

.. code:: python

    from solcore.structure import Junction

    T = 300 

    ## Materials for the BOTTOM junction
    window_bottom = material('GaInP')(T=T, Nd=5e24, In=0.49)
    n_GaAs = material('GaAs')(T=T, Nd=1e24)
    p_GaAs = material('GaAs')(T=T, Na=8e22)
    bsf_bottom = material('GaInP')(T=T, Na=5e24, In=0.49)

    GaAs_junction = Junction([Layer(width=10e-9, material=window_bottom, role="Window"),
                              Layer(width=150e-9, material=n_GaAs, role="Emitter")] +
                             QW_list +
                             [Layer(width=2000e-9, material=p_GaAs, role="Base"),
                              Layer(width=200e-9, material=bsf_bottom, role="BSF")], sn=1e6, sp=1e6, T=T, kind='PDD')

    ## Materials for the TOP junction
    window_top = material('AlInP')(T=T, Nd=5e23, Al=0.53)
    n_GaInP = material('GaInP')(T=T, Nd=5e23, In=0.49)
    p_GaInP = material('GaInP')(T=T, Na=8e22, In=0.49)
    bsf_top = material('AlInP')(T=T, Na=5e24, Al=0.53)

    GaInP_junction = Junction([Layer(width=120e-9, material=n_GaInP, role="Emitter"),
                               Layer(width=800e-9, material=p_GaInP, role="Base")], sn=1e3, sp=1e3, T=T, kind='PDD')

As it can be seen, while we have defined the window and back surface
field layer (BSF) for the TOP junction, we have not included it into the
Junction definition. The reason for this is that very wide bandgap
materials cause convergence problems when doing calculations under
illumination, specially when working as the front-most window layers or
in distributted Bragg reflectors, where there are very abrupt changes of
properties in pery short distances. In order to account for their
presence, two things are done: (1) the surface recombination velocity of
the top junction is set to a low value to mimic the passivating effect
of the window and BSF layers, and (2) the missing layers are added
outside the Junction object when creating the full solar cell in order
to consider their optical properties (see below).

**TRICK:** The TMM solver work best with "thin" layers therefore, if the
results of optical calculations look strange, try dividing thick layers
(> 2-3 µm) into thinner ones (~500 nm). The reason is that the waves
propagating forwards and backwards, leading to interference are
ultimately complex exponentials that increase (or decrease) quite fast
away from the interfaces, resulting in a loss of numerical accuracy when
they trying to interact far from the interfaces.

The only tunnel junction of this solar cell will be defined according to
the parametric model and we will assume it is made of GaInP layers, 40
nm-thick in total, that will block part of the light reaching the bottom
junction. Since the top junction is also made of GaInP, most of the
light should already be absorbed and therefore it should not represent a
very important loss. We will use a relatively low peak current to
demonstrate the effect of tunnel junction breakdown when working at high
concentration.

.. code:: python

    from solcore.structure import TunnelJunction

    tunnel = TunnelJunction([Layer(width=40e-9, material=n_GaInP, role="TJ")],
                            v_peak=0.2, j_peak=7.5e4, v_valley=1, j_valley=4e4, prefactor=5, j01=1e-23, kind='parametric')

**Defining the AR coating:**

The AR coating will reduce the front surface reflection and, therefore,
increase the photocurrent of the solar cell. We use a simple dual layer
coating made of MgF2 and ZnS. Both materials are available in the SOPRA
database of optical constants ("MgF2" and "ZnScub", respectively). The
data for MgF2 only extends to 900 nm, but we will assume its optical
properties will be similar at longer wavelengths, extrapolating the
available data.

.. code:: python

    MgF2 = material('MgF2')()
    ZnS = material('ZnScub')()

**Creating the solar cell:**

With all the materials and structures defined, we just need to put
everything together, including the front window layer and the BSF layer
of the top junction that we had left outside.

.. code:: python

    from solcore.solar_cell import SolarCell

    my_solar_cell = SolarCell([Layer(width=110e-9, material=MgF2, role="ARC1"),
                               Layer(width=60 - 9, material=ZnS, role="ARC2"),
                               Layer(width=30e-9, material=window_top, role="window"),
                               GaInP_junction,
                               Layer(width=100e-9, material=bsf_top, role="BSF"),
                               tunnel,
                               GaAs_junction],
                               T=T, substrate=n_GaAs)

Calculating the external quantum efficiency
===========================================

With the structure fully defined, now it is possible to calculate its
behavior as solar cell. We first calculate the external quantum
efficiency at 1 Sun of intensity using the AM1.5g solar spectrum. The
code that defines the spectrum to use and lunch the calculation will be:

.. code:: python

    from solcore.solar_cell_solver import solar_cell_solver
    from solcore.light_source import LightSource

    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl,
                               output_units='photon_flux_per_m', concentration=1)

    solar_cell_solver(my_solar_cell, 'qe',
                      user_options={'light_source': light_source, 'wavelength': wl, 'optics_method': 'TMM'})

The calculation will proceed in several stages: (1) The structure is
processed and discretized, (2) the problem is solved under equilibrium,
(2) the problem is solved under short circuit conditions increasing in
small steps the intensity of the illumination, and (3), the quantum
efficiency is calculated, one wavelength at a time. This is done for the
two junctions. The following code plots the electrons and holes
densities at equilibrium (dashed line) and at short circuit (continuous
line), as well as the EQE of the two junctions and the total absorption
in the layers.

.. code:: python

    from solcore.solar_cell_solver import solar_cell_solver
    from solcore.light_source import LightSource

    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl,
                               output_units='photon_flux_per_m', concentration=1)

    solar_cell_solver(my_solar_cell, 'qe',
                      user_options={'light_source': light_source, 'wavelength': wl, 'optics_method': 'TMM'})

.. figure:: qe.jpg
   :alt: Quantum efficiency

﻿As it can be seen, the minority carrier population increases
significantly under illumination, specially in the QW region of the
bottom cell, which is a relatively thick, undoped region. The EQE of the
bottom junction, in comparison with the total absorbed light, indicates
excellent carrier collection with only some missing carriers in the
region of the spectrum where light is absorbed by the QWs. The top
junction is not performing that well, the reason being a combination of
low mobility of carriers in GaInP between 3 and 6 times smaller than
that of p-GaAs), insufficient thickness to absorb all light (part of it
reaching the GaAs junction), parasitic absorption of the AlGaP window
layer and surface recombination.

Calculating the IV characteristics
----------------------------------

The calculation of the current-voltage characteristics proceed in a
similar way. In this case, care must be taken to use the correct
polarity for the (internal) voltage sweep, and the polarity of the
tunnel junction, already defined above as *pn*. As the optical
properties have already been calculated, we set the
*optics\_method=None*, so they are not calculated again. The next code
shows the definition of the voltages, the sunlight concentration factor
(from 1 to 1000 suns) and the execution of the calculation within a for
loop.

**NOTE**: This example will take several hours to run due to the
presence of QWs, which increase the number of mesh points in the bottom
cell to several thousand. To have an example of the results faster,
reduce the number of concentrations (19 in the example) and comment the
QWs related line in the definition of the GaAs junction above.

.. code:: python

    con = np.logspace(0, 3, 19)
    vint = np.linspace(-3.5, 4, 600)
    V = np.linspace(-3.5, 0, 300)

    allI = []
    isc = []
    voc = []
    FF = []
    pmpp = []

    for c in con:
        light_source.options['concentration'] = c

        solar_cell_solver(my_solar_cell, 'iv',
                          user_options={'light_source': light_source, 'wavelength': wl, 'optics_method': None,
                                        'light_iv': True, 'mpp': True, 'voltages': V, 'internal_voltages': vint})
                                        
        isc.append(my_solar_cell.iv['Isc'])
        voc.append(my_solar_cell.iv['Voc'])
        FF.append(my_solar_cell.iv['FF'])
        pmpp.append(my_solar_cell.iv['Pmpp'])
        allI.append(my_solar_cell.iv['IV'][1])

The next figure shows the summary of the efficiency, Isc, Voc and fill
factor (FF) versus concentration.

.. figure:: iv_params.jpg
   :alt: iv_params


The efficiency of the cell is just above 30% at 1 sun, and increases
with concentration , peaking at around 200-300 suns. Further increasing
the concentration rapidly decreases the efficiency. Both, Isc and Voc
follow the expected linear trend in log-log and semilog plots,
respectively, while the fill factor increases for low concentrations and
then continuously drops from 20 suns and, specially, from 200 suns. The
initial smooth drop of the fill factor can be related with a limited
carrier transport across the QW region, that under concentration,
suffers from charge accumulation and damping of the electric field.
However, the abrupt drop at higher concentrations is related to the
failure of the tunnel junction which, by design, had a low peak current.
This effect can be better seen in the last figure where, for the two
highest concentrations, the IV curve exhibit steps due to the tunnel
junction limiting the current.

.. figure:: iv.jpg
   :alt: IV
Radiative coupling in a MJ solar cell
=====================================

The figure shows the IV curve under the AM1.5G solar
spectrum of a three junction solar cell (a) without and (b) with
radiative coupling. Without coupling, the middle junction severely
limits the current of the MJ solar cell. When coupling is enabled, the
middle junction is still the limiting one but part of the excess current
of the top junction is transferred to it, increasing its photocurrent by
around 20 A/m\ :math:`^2`. Part of the radiative recombination is also
transferred to the bottom cell, increasing slightly its photocurrent. In
this case, given that the junction was overproducing current already,
such coupling is only visible as an increase in the voltage. Altogether,
the radiative coupling results in an enhancement of the V\ :math:`_{oc}`
of 30 mV and of the efficiency :math:`\eta` of 5.3%. This example uses
junctions with 100% radiative efficiency to illustrate the effect, but
this phenomenon is always present to some extent, becoming especially
important under concentration.

.. image:: MJ_with_rad_coupling.png
   :width: 60%
   :align: center

.. code-block:: Python

    import matplotlib.pyplot as plt
    import numpy as np

    from solcore.structure import Junction
    from solcore.solar_cell import SolarCell
    from solcore.light_source import LightSource
    from solcore.solar_cell_solver import solar_cell_solver
    from solcore.graphing.Custom_Colours import colours

    T = 298

    Vin = np.linspace(-6, 2, 600)
    V = np.linspace(-1.5, 4, 500)
    wl = np.linspace(350, 2000, 301) * 1e-9
    light_source = LightSource(source_type='standard', version='AM1.5g', x=wl, output_units='photon_flux_per_m',
                               concentration=1)

    color = ['b', 'g', 'r']
    label = ['Top', 'Mid', 'Bot']

    fig, ax = plt.subplots(1, 2, sharey='all', figsize=(7, 4.5))

    for k, rad in enumerate([False, True]):

        # Input data for the 2D kind of junction
        db_junction = Junction(kind='2D', T=T, reff=0.3, jref=300, Eg=0.66, A=1, R_shunt=np.inf, n=3.5)
        db_junction2 = Junction(kind='2D', T=T, reff=1, jref=300, Eg=1.4, A=1, R_shunt=np.inf, n=3.5)
        db_junction3 = Junction(kind='2D', T=T, reff=1, jref=300, Eg=1.8, A=1, R_shunt=np.inf, n=3.5)

        my_solar_cell = SolarCell([db_junction3, db_junction2, db_junction], T=T, R_series=0)

        solar_cell_solver(my_solar_cell, 'iv',
                          user_options={'T_ambient': T, 'voltages': V, 'light_iv': True, 'wavelength': wl,
                                        'light_source': light_source, 'radiative_coupling': rad, 'mpp': True,
                                        'internal_voltages': Vin})

        # This is the total junction IV
        ax[k].plot(my_solar_cell.iv['IV'][0], my_solar_cell.iv['IV'][1], marker='o', color=colours("Black"), ls='-',
                   markerfacecolor='none', markeredgecolor=colours("Black"))

        # This is the junciton IV when it is in the MJ device, including coupling if it is enabled.
        for i, data in enumerate(my_solar_cell.iv['junction IV']):
            ax[k].plot(data[0], data[1], color[i] + '--', linewidth=2)

        # This is the junction IV as if it were an isolated device and therefore not affected by coupling or current limiting.
        for i in range(my_solar_cell.junctions):
            ax[k].plot(V, -my_solar_cell(i).iv(V), color[i], linewidth=2, label=label[i])

        ax[k].set_ylim(0, 300)
        ax[k].set_xlim(0, 3.5)

        ax[k].set_xlabel('Bias (V)')

        Isc = my_solar_cell.iv["Isc"]
        Voc = my_solar_cell.iv["Voc"]
        FF = my_solar_cell.iv["FF"] * 100
        Eta = my_solar_cell.iv["Eta"] * 100

        ax[k].text(1.75, 275, 'I$_{sc}$ = ' + str(round(Isc, 1)) + ' A/m$^2$', fontsize=12)
        ax[k].text(1.75, 250, 'V$_{oc}$ = ' + str(round(Voc, 2)) + ' V', fontsize=12)
        ax[k].text(1.75, 225, 'FF = {:.1f} %'.format(FF), fontsize=12)
        ax[k].text(1.75, 200, r'$\eta$ = {:.1f} %'.format(Eta), fontsize=12)

    ax[0].set_ylabel('Current (A/m$^2$)')
    ax[0].text(0.9, 0.05, '(a)', transform=ax[0].transAxes, fontsize=12)
    ax[1].text(0.9, 0.05, '(b)', transform=ax[1].transAxes, fontsize=12)
    plt.tight_layout()
    ax[0].legend(loc=(0.10, 0.80), frameon=False)
    plt.show()
Examples
========

List of examples illustrating the use of Solcore. More examples are available in the `Solcore's Github repository (Examples folder) <https://github.com/dalonsoa/solcore5>`_ and will be listed here at some point

Quantum solvers
---------------

- :doc:`Calculating the bandstructure and local density of states in QWs and MQWs <example_QWs>`
- :doc:`KP calculator and effective mass fitting <example_K_and_effective_mass>`

Light sources
-------------

- :doc:`Example of the use of the light_sources module <example_light_sources>`

Optical methods
---------------

- :doc:`Using the TMM solver to calculate the reflextion of a multilayered ARC <example_RAT_of_ARC>`
- :doc:`Looking at the effect of substrate and the no_back_reflection option in the TMM solver <example_substrate>`
- :doc:`Comparing optical models (TMM, Beer-Lambert, and RCWA) <example_optics_comparison>`

Custom materials
----------------

- :doc:`Setting up the options for and defining custom materials <custom_materials_example>`
- :doc:`Searching the refractiveindex.info database and comparing materials <refractiveindex_info_db_example>`

MJ solar cells
--------------

- :doc:`Tutorial: 2J solar cell with QWs in the bottom cell <tutorial>`
- :doc:`Example of a 2J solar cell calculated with the PDD solver <example_PDD_solver>`
- :doc:`Radiative coupling in a 3J solar cell <example_radiative_coupling>`
- :doc:`MJ solar cell efficiency map <example_MJ_efficiency_map>`
- :doc:`Traditional GaInP/InGaAs/Ge solar cell <example_3J_with_DA_solver>`
- :doc:`Example of a tunnel junction <../Examples/example_tunnel_junction>`

SPICE-based solar cell solver
-----------------------------

- :doc:`PV module calculator <example_pv_module>`
- :doc:`Quasi-3D 3J solar cell <example_quasi3D_cell>`

QW unit creator
===============

Quantum wells have been developed in the context of solar cells mainly
to tailor the absorption edge of the sub-cells in multi-junction devices
to their optimum values ([#Ref4]_). Typically,
achieving the proper performance requires a delicate trade-off between
carrier collection and light absorption ([#Ref5]_, [#Ref6]_).
Solcore includes a simplified QW structure in the PDD solver in order to
calculate the performance of solar cells containing them. Contrary to
other programs like Nextnano, Solcore does not solve the Schrödinger
equation and the PDD equations self-consistently: first, the energy
levels of the quantum wells are solved using a flat-band condition,
considering also the strain in the materials, and then an effective band
structure is used to solve the transport equations in a bulk-like
fashion. This is illustrated in the next figure:

.. image:: Figures/QWunit.png
    :align: center

From the perspective of the PDD solver, the actual bandgap and electron
affinity of each layer in a quantum well depend on the energy levels,
i.e. the minimum energy for electrons is not the band edge of the
conduction band, but the ground confined level. The same applies to
holes, with the actual band edge being the maximum between the ground
states of light holes and heavy holes. The resulting band profiles used
in the PDD solver are shown in the right end of the figure.

To use QWs in the PDD solver, we create an effective electron affinity
and bandgaps for all layers in the QW. For the barriers, the electron
affinity and band gap are the same as they are in bulk, modified by the
strain, if necessary. For interlayers, if present, it depends on what is
higher, the band edges of the interlayer or the confined carrier levels.

The density of states and the absorption profile need to be modified in
a similar way. For the density of states:

-  **Barriers** have the bulk density of states and absorption profile.

-  **Interlayers** only have the bulk density of states above the
   barrier and the bulk absorption from the barrier energy and zero
   below that.

-  **Wells** have all the density of states associated with the confined
   states and the bulk density of states above the barrier, while they
   have the absorption of the confined levels below the barrier energy
   and of the bulk above it.

These simplifications are similar to those in Nelson et al.
([#Ref2]_) and in Cabrera et al. ([#Ref3]_) and allow us to keep the bulk-like
form of the carrier densities in the drift diffusion equations under the
Boltzmann approximation. A more rigorous treatment will be necessary in
the presence of tunnel transport across a supperlattice, tunnel escape
from the QWs to the barriers - possible in the presence of high electric
fields - and in the case of very deep QWs, when carrier escape from the
less confined levels might be possible but not from the deeper ones. In
these situations, a set of rate equations linking the different levels,
as well as a self-consistent solution of the transport and Schrödinger
equations would be required, besides using more advanced methods such as
a non-equilibrium Green’s functions (NEGF)
formalism ([#Ref7]_).


The QWunit class
----------------

This module defines a class derived from *solcore.Structure* that allows to solve the Schrodinger equation and the kp model. It also prepares the properties of the structure (bandedges, efective density of states (DOS), etc) in order to have a meaningful set of properties for the PDD. Without this preparation, the structure is just a collection of layers with bulk-like properties, as it is illustrated in the figure:

.. py:class:: QWunit (*args, **kwargs)

	Asembles a group of layers as a quantum well, calculating its properties as a whole. As with any **solcore.Structure**, a QWunit usually gets as input a list of **solcore.Layers** and a **solcore.material** as substrate (defined with the keyword 'substrate'). In this case, the class constructor is designed to work specifically for the PDD solver so it requires the following:

	- It needs a minimum of 3 layers.
	- There must be exactly one layer with the role = "well".
	- Top and bottom layers are assumed to be the barriers.
	- Anything not a barrier nor a well will be considered as "interlayer".
	- A substrate.

	Since the PDD solver can not work with superlattices, there is no point of considering the solution of more than one QW. All QWs entering into the solver are independent, regardless of the width of the barriers. To account for the possible presence of nearby QWs, perdiodic boundary conditions can be used to solve the Schrodinger equation. If barriers + interlayers are thick enought, this make no difference but if they are thin, it affects the number and energy of the confined levels. It does not 'create' minibands, though, so the results with thin barriers must be used with caution.
	
	
	.. py:method:: solve([V=0, WLsteps=(300e-9, 1100e-9, 201), wavelengths=None, periodic=True, filter_strength=0.0, blur=None, blurmode="left", offset=0,use_kp=True, use_Adachi=False, calculate_absorption=True, alpha_params=None, T=293])
	
		Solves the structure, calculating the energy levels, the absorption, etc. First, it calls the Schrodinger solver and then it uses the result to obtain an effective band profile for the conduction and valence band, an effective density of states considering both, the bulk and quantum levels, and the absorption coefficient. This is done for each layer of the structure (see the following methods for details). The input parameters of this method are the same that for the Schrodinger solver except for the wavelengths definition that can be used as default (WLsteps) or be added with 'wavelengths'.
		
		The method returns as output the output dictionary of the Schrodinger solver.
		
	.. py:method:: RecalculateBandEdges(use_kp, SR)
	
		From the perspective of the PDD solver, the actual bandgap and electron affinity of each layer depend on the energy levels, i.e. the minimum energy for electrons is not the band edge of the conduction band, but the ground confined level. The same applies to holes, being the actual band edge the maximum between the ground states of light holes and heavy holes (see :ref:`figure-QWunit`). 
		
		In this method we modify that by creating an effective electron affinity and band gaps for all layers in the QW. For the barriers, the electron affinity and band gap are the same than in bulk, modified by the kp calculation, if necessary. For interlayers, it depends on what is higher, the bandedges of the interlayer or the confined carrier levels.
		
		It requires as input if kp should be used to recalculate the band positions and effective masses ('use_kp=True') and the output of the Schrodinger solver.
		
	.. py:method:: RecalculateDensityOfStates(SR)
	
		Calculates the effective density of states for each layer in the QW. The general rule is:
		- Barriers have the bulk density of states
		- QW have ALL the density of states asociated with the confined states + bulk density of states above the barrier
		- Interlayers have only the bulk density of states above the barrier

		This simplification is similar to that in Nelson et al. [#Ref2]_ and allow us to keep the bulk-like form of the carrier densities in the drift diffusion equations under the Boltzmann approximation. From a physical porint of view, it probably can be done better.
		
	.. py:method:: CalculateAbsorption(use_Adachi, SR):
	
		If required, this function calculates the absorption of the QW, putting together the absorption of the confined levels and the absorption of the bulk. As with the density of states, the rules are:
		
		- Barriers have the bulk absorption
		- Interlayers have the bulk absorption from the barrier energy and zero below that
		- Wells have the absorption of the confined levels below the barrier energy and of the bulk above it. 
		
		The calculation is similar to that in [#Ref3]_ but, as with the DOS, it can probably be improved. 
		
		The required input is if Adachi method [#Ref1]_ for calculating the absorption should be used ('use_Adachi=True') and the output of the Schrodinger solver.

    .. py:method:: GetEffectiveQW(calculate_absorption=True, wavelengths=None, periodic=True, filter_strength=0.0, blur=None, blurmode="left",use_kp=True, use_Adachi=False, alpha_params=None)

        Considers the device as a QW and solves its properties, including the modification of the bandeges due to strain, the efective mases and the absorption coefficient. Without calling this function, the structure is just a collection of layers with bulk-like properties.

        **Output**: A list of layers with the effective properties of the QWs, repeated as many times as needed in case of a MQW.

    .. code-block:: python

       # This example illustrates the creation of a QW structure with 40 wells, solve its quantum properties and
       # add it to the intrinsic region of a p-i-n solar cell

       import solcore.poisson_drift_diffusion as PDD
       from solcore.structure import Layer
       from solcore import material

       # First, we create the materials of the QW
       QWmat       = material('InGaAs')    (T=300, In=0.2)
       Bmat        = material('GaAsP')     (T=300, P=0.1)
       i_GaAs      = material('GaAs')      (T=300)

       # The QW is 7 nm wide, with GaAs interlayers 2 nm thick at each side and GaAsP barriers 10 nm thick.
       # The final device will have 40 of these QWs.
       QW = PDD.QWunit( [Layer(width = 10e-9,          material = Bmat,           role="barrier"),
                         Layer(width = 2e-9,           material = i_GaAs,         role="interlayer"),
                         Layer(width = 7e-9,           material = QWmat,          role="well"),
                         Layer(width = 2e-9,           material = i_GaAs,         role="interlayer"),
                         Layer(width = 10e-9,          material = Bmat,           role="barrier") ],
                         T = 300, repeat = 40)

       # We solve the quantum properties of the QW
       effective_QW = QW.GetEffectiveQW(QW)

In this case, "effective_QW" is a list of 200 layers (5 layers per QW unit repeated 40 times) but rather than the bulk material properties, they include effective properties as a result of the quantum calculation.
		
All functions description
-------------------------

.. automodule:: solcore.poisson_drift_diffusion.QWunit
    :members:
    :undoc-members:
		
References
----------

.. [#Ref1] S. Adachi “Optical dispersion relations for GaP, GaAs, GaSb, InP, InAs, InSb, AlxGa1−xAs, and In1−xGaxAsyP1−y,” J. Appl. Phys.,66, 6030 (1989).

.. [#Ref2] J. Nelson, M. Paxman, K. W. J. Barnham, J. S. Roberts, and C. Button, “Steady-state carrier escape from single quantum wells,” IEEE J. Quantum Electron., vol. 29, no. 6, pp. 1460–1468, 1993.

.. [#Ref3] C. I. Cabrera, J. C. Rimada, J. P. Connolly, and L. Hernandez, “Modelling of GaAsP/InGaAs/GaAs strain-balanced multiple-quantum well solar cells,” J. Appl. Phys., 113, 024512, (2013).

.. [#Ref4] Thomas, T., Wilson, T., Führer, M., Alonso-Álvarez, D., Ekins- Daukes, N.J., Lackner, D., Kailuweit, P., Philipps, S.P., Bett, A.W., Toprasertpong, K., Sugiyama, M., Okada, Y.: Potential for reaching 50% power conversion efficiency using quantum heterostructures. In: 6th World Conference on Photovoltaic Energy Conversion, pp. 1–2 (2014)

.. [#Ref5] Alonso-Álvarez, D., Führer, M., Thomas, T., Ekins-Daukes, N.: Elements of modelling and design of multi-quantum well solar cells. In: 2014 IEEE 40th Photovoltaic Specialists Conference (PVSC), pp. 2865–2870 (2014)

.. [#Ref6] Alonso-Álvarez, D., Ekins-Daukes, N.J.: Quantum wells for high- efficiency photovoltaics. In: Freundlich, A., Lombez, L., Sugiyama, M. (eds.) Physics, Simulation, and Photonic Engineering of Pho- tovoltaic Devices V, vol. 9743, p. 974311. SPIE OPTO, San Francisco, CA (2016). https://doi.org/10.1117/12.2217590

.. [#Ref7] Aeberhard, U.: Quantum-kinetic perspective on photovoltaic device operation in nanostructure-based solar cells. J. Mater. Res. 33, 373–386 (2018)Device Structure
================

This module contains the functions necessary to build a sample structure that can be read by the PDD solver. Typically, you will not need to use any of these except in the case of including quantum wells in the solar cell. In this case, you will need to use this methods to solve the quantum properties and create an effective medium before executing the PDD solver.

.. _main-functions:

Main functions
--------------

.. py:function:: CreateDeviceStructure(name [, role='device', T=293, layers=[], comments='', repeat=1, substrate=DefaultMaterial, reflection=None])

	Creates a dictionary with subdctionaries and lists storing all the parameters and material information necessary to solve the Poisson - Drift-Diffusion equations. It might be useful, also, to get all the properties of a given material that will be used in the PDD solver.
	
	*Layers* is a list of objects of class *solcore.Layer*. A *solcore.Structure* or a *solcore.Junction* are also valid inputs since all of them are made of a list of layers. Any property not defined explicitly in the definition of the materials for the layers and that can not be calculated by :literal:`Solcore` is taken from the default material (see section :ref:`default-material`). *substrate* must be a *solcore.material*, otherwise the default material is used.

   	**Output**: dictionary with all the information of the structure.

.. code-block:: python

    # This example illustrates the creation of a p-i-n Junction including AlGaAs window and back surface field layers.
    # A custom absorption coefficient for the GaAs of the intrinsic layer is used.

    import solcore.poisson_drift_diffusion as PDD
    from solcore.structure import Layer, Junction
    from solcore.import material

    # First, we create the materials, overriding any default property we want, such as the doping or the absorption coefficient
    window      = material('AlGaAs')    (T=300, Na = 1e24, Al=0.8)
    p_GaAs      = material('GaAs')      (T=300, Na = 1e24)
    i_GaAs      = material('GaAs')      (T=300)
    n_GaAs      = material('GaAs')      (T=300, Nd = 1e23)
    bsf         = material('AlGaAs')    (T=300, Nd = 1e24, Al=0.4)

    # We put everything together in a Junction. We include the surface recombination velocities,
    # sn and sp, although they are not necessary in this case.
    MyJunction = Junction([ Layer(width = 30e-9,         material = window,           role="Window"),
                            Layer(width = 400e-9,        material = p_GaAs,           role="Emitter"),
                            Layer(width = 400e-9,        material = i_GaAs,           role="Intrinsic"),
                            Layer(width = 2000e-9,       material = n_GaAs,           role="Base"),
                            Layer(width = 200e-9,        material = bsf,              role="BSF")],
                            sn=1e3, sp=1e3, T=300, kind='PDD')

    # Then, we create the structure. What actually this "creation" does is getting all the information of the materials
    # from the materials database relevant for the PDD solver and storing them in a dictionary.
    MyDevice = PDD.CreateDeviceStructure( 'TestDevice', T = MyJunction.T, layers = MyJunction)

Now "MyDevice" is a dictionary with several entries with the specific information that will be used by the PDD solver (if required). For example :code:`MyDevice['layers'][1]['properties']` will contain the following (the order might be different):

.. code-block:: python

    {'composition': {'material': 'GaAs'},
    'width': 4e-07,
    'band_gap': 2.279067404056071e-19,
    'electron_affinity': 6.62903371354393e-19,
    'eff_mass_electron_Gamma': 0.067,
    'eff_mass_hh_z': 0.34129421032745344,
    'eff_mass_lh_z': 0.0879370668050916,
    'electron_mobility': 0.9399999990563772,
    'hole_mobility': 0.017374281562790292,
    'ni': 1767480124457.733,
    'Nc': 4.3519622483962564e+23,
    'Nv': 5.657793654818883e+24,
    'electron_minority_lifetime': 3e-06,
    'hole_minority_lifetime': 2.5e-07,
    'permittivity': 12.9,
    'electron_auger_recombination': 1e-42,
    'hole_auger_recombination': 1e-42,
    'radiative_recombination': 2.8744203894058427e-17,
    'Nd': 1, 'Na': 1e+24,
    'sn': 1000000.0,
    'sp': 1000000.0}

The information for layers 2 and 3 wil be similar since we have GaAs in all cases, except for the mobilities as these depend on the doping, which is different.


.. _default-material:

Default material
----------------

The default material is **GaAs at 293K**. In general, all the intrinsic properties of the materials are taken from the literature and calculated by the :literal:`Solcore` material system. If not found there (for example if the material or alloy is not in the database) or if they are extrinsic, the default values below are used. The extrinsic properties, that depend on the quality of the material or its doping, are just asigned a 'reasonable' value. The user must make sure that this 'reasonable' value is indeed resonable for the intended application and override it with his/her own, otherwise.

The total list of parameters and the default values are:

============================ ============================ ====================== =============================================
Parameter                    Default value                Units                  Notes
============================ ============================ ====================== =============================================
band_gap                     Calculated for GaAs at 293K  J                      \-
electron_affinity            Calculated for GaAs at 293K  J                      \-
eff_mass_electron_Gamma	     Calculated for GaAs at 293K  relative to m0         \-
eff_mass_hh_z                Calculated for GaAs at 293K  relative to m0         \-
eff_mass_lh_z                Calculated for GaAs at 293K  relative to m0         \-
permittivity                 12.9                         relative to epsilon0   \-
electron_mobility            Calculated for GaAs at 293K  m2 V-1 s-1             \-
hole_mobility                Calculated for GaAs at 293K  m2 V-1 s-1             \-
electron_minority_lifetime   3e-6                         s                      SRH [#f1]_ recombination time for electrons
hole_minority_lifetime       2.5e-7                       s                      SRH recombination time for holes
electron_auger_recombination 1e-42                        m6 s-1                 \-
hole_auger_recombination     1e-42                        m6 s-1                 \-
radiative_recombination	     Calculated for GaAs          m3 s-1                 Derived from the absorption coefficient
Nd                           1                            m-3                    Density of donors
Na                           1                            m-3                    Density of acceptors
============================ ============================ ====================== =============================================

.. [#f1] Shockley-Read-Hall

All functions description
-------------------------

.. automodule:: solcore.poisson_drift_diffusion.DeviceStructure
    :members:
    :undoc-members:
Multi-junction electrical solver
================================

- Example 1: :doc:`Tutorial: 2J solar cell with QWs in the bottom cell <../Examples/tutorial>`
- Example 2: :doc:`Example of a 2J solar cell calculated with the PDD solver <../Examples/example_PDD_solver>`
- Example 3: :doc:`Radiative coupling in a 3J solar cell <../Examples/example_radiative_coupling>`
- Example 4: :doc:`MJ solar cell efficiency map <../Examples/example_MJ_efficiency_map>`
- Example 5: :doc:`Traditional GaInP/InGaAs/Ge solar cell <../Examples/example_3J_with_DA_solver>`
- Example 6: :doc:`Example of a tunnel junction <../Examples/example_tunnel_junction>`

﻿A complete photovoltaic solar cell can include one or more junctions, metal contacts, optical layers (including anti-reflective coatings and nano-photonic structures) and tunnel junctions. The junctions, in turn, might range from simple PN homojunctions to complex heterojunctions, including multi-quantum well structures. The solvers described so far only calculate the properties of single junction devices. To combine them into a multi-junction device, it is necessary to consider that the individual junctions are electrically connected in series and the potential coupling of light emitted by the wider bandgap junctions into those with smaller bandgap.


No radiative coupling
---------------------

We first consider the case of no radiative coupling between junctions.
This is a good approximation for materials which do not radiate
efficiently or radiative materials working at low concentration, when
the fraction of radiative recombination compared to non-radiative
recombination is low. In this case, the IV curve of each junction can be
calculated independently of each other and the current flowing through
the MJ structure is limited by the junction with the lowest current at
any given voltage. Series resistances defined for each junction are now
added together and included as a single term. The operating voltage of
each of the junctions is finally back-calculated and added together to
get the voltage of the MJ device.

The pseudocode for this solver is:

#. Calculate the :math:`I_j(V)` of each junction :math:`j` in the
   structure.

#. Find the current flowing through the MJ device as
   :math:`I_{MJ}(V) = I_j(V)`, if
   :math:`|I_j(V)| = \min ([|I_1(V)|...|I_N(V)|])`.

#. Calculate the voltage of each junction by interpolating its IV curve
   at the new current values, :math:`V_j(I_{MJ})`, and the voltage
   dropped due to the series resistances, :math:`V_{Rs} = R_s I_{MJ}`.

#. Calculate the total voltage at a given current as
   :math:`V_{MJ} = V_{Rs} + \sum_j V_j`.

#. Interpolate the :math:`I_{MJ}(V_{MJ})` and the :math:`I_{MJ}(V_j)` to
   the desired output voltage values.

The figure shows the simulated IV curve of a 3J solar cell made
of Ge/InGaAs/GaAsP. The electrical properties of the three junctions
were calculated using the depletion approximation solver. In the dark
the voltages of each of the junctions at a given
current add together, resulting in the total voltage of the MJ
structure. The :math:`R_s` contribution to the voltage goes in the same
direction as those of the junctions. Under illumination the junction producing the lower current (the top
junction in this case) limits the overall current of the MJ device. At
zero bias, or even at some negative bias, the non-limiting junctions are
positively biased, recombining all the photocurrent that cannot be
extracted because of the limiting top cell. The contribution of the
:math:`R_s` to the voltage of the MJ device is negative, resulting in a
reduction of the fill factor and the overall efficiency of the solar
cell.

.. image:: ../Examples/DA_iv2.png
    :width: 60%
    :align: center

With radiative coupling
-----------------------

Radiative coupling takes place when the light produced by a high bandgap
junction due to radiative recombination is absorbed by a lower bandgap
junction, contributing to its photocurrent and changing the operating
point. It has been identified in numerous highly radiative materials
such as quantum well solar cells and III-V MJ solar
cells . It appears as an artefact during the QE measurements of MJ solar cells
but it is also an effect that can be exploited to increase the performance of MJ devices
and their tolerance to spectral changes, resulting in superior annual energy yield.

The radiative coupling formalism included in Solcore is based on the
works by Chan et al. (2014) and Nelson et al. (1997).

For a more detailed description of the radiative coupling calculator `refer to the main Solcore paper (open access) <https://doi.org/10.1007/s10825-018-1171-3>`_ and references therein.

An example of the radiative coupling in action can be found :doc:`here <../Examples/example_radiative_coupling>`.

Tunnel junctions
----------------

Solcore includes partial support for tunnel junctions. They represent an
optical loss due to parasitic absorption in the layers, but also an
electrical loss. At the moment, there are two models for tunnel
junctions. The first one is a simple resistive model, where the tunnel
junction is simply modelled as a series resistance. This approximation
should be valid in most cases, but will break down if the current is
close to or higher than the peak current density of the junction.

The second model is a parametric model, based on the simple formalism
described by Sze. In this model, the
total current of the tunnel junction will have three components: the
tunnel current :math:`J_T` accounting for band-to-band transport, the
excess current :math:`J_{ex}` related to transport across states inside
the forbidden gap, and the diffusion current :math:`J_D`, which is the
usual minority-carrier injection current in PN junctions. The following
equations summarise all these components.

.. math:: J_{TJ} = J_{T} + J_{ex} + J_D

.. math:: J_{T} = \frac{J_P V}{V_P} \exp{\left( 1 - \frac{V}{V_P} \right) }

.. math:: J_{ex} =J_V \exp{\left[ C \left( V - V_V \right) \right] }

.. math:: J_{D} =J_0 \left[  \exp{ \left( \frac{qV}{k_b T}  \right) } - 1  \right]

As illustrated in the next figure, :math:`J_P` and :math:`V_P` are the
peak current and voltage, :math:`J_V` and :math:`V_V` are the valley
current and voltages, :math:`C` is a prefactor of the exponent and
:math:`J_0` the reverse saturation current. In this simple
implementation, these 6 parameters need to be provided as inputs, and
can be used as fitting parameters to reproduce experimental data. This
allows to correctly account for the break down of the tunnel junction in
situations when the current is above the peak current.
The code for this example can be found :doc:`here <../Examples/example_tunnel_junction>`.

.. image:: ../Examples/tunnel_junction.png
    :width: 60%
    :align: center

Solcore can also accept external IV data for the tunnel junctions and
the implementation of the more rigorous, but still analytic model,
described by Louarn *et al.* (2016) is currently under way in order to relate
the tunnel currents with the actual materials and layer structure used
in the tunnel junction definition.

Multi-junction IV functions
--------------------------

.. automodule:: solcore.analytic_solar_cells.IV
    :members:
    :undoc-members:

.. automodule:: solcore.analytic_solar_cells.tunnel_junctions
    :members:
    :undoc-members:
Detailed balance approximation
==============================

- Example: :doc:`MJ solar cell efficiency map <../Examples/example_MJ_efficiency_map>`

This solver calculates the electrical properties of the junction by
balancing the elementary processes taking place in the solar cell,
carrier generation and radiative recombination, using the formalism
described by Araújo and Martí (1996) ([#Ref20]_). The
method is widely used by the photovoltaic community to calculate the
limiting conversion efficiencies of the different solar cell
architectures or materials. The simplest DB formulation only needs an
absorption edge energy and an absorptivity value above that edge. Out of
this, the carrier generation and radiative recombination are calculated
for different internal chemical potentials, equal to the external
electrical bias, in the ideal case. Solcore includes this basic model,
but also allows the user to provide a more complex absorption profile.

For a more detailed description of the implementation of the DB solver in
Solcore, `refer to the main Solcore paper (open access) <https://doi.org/10.1007/s10825-018-1171-3>`_ and references therein.

Detailed balance functions
--------------------------

.. automodule:: solcore.analytic_solar_cells.detailed_balance
    :members:
    :undoc-members:

References
----------

.. [#Ref20] Martí, A., Araújo, G.L.: Limiting efficiencies for photovoltaic energy conversion in multigap systems. Sol. Energy Mater. Sol. Cells 43(2), 203–222 (1996)Solar cell solvers
==================

Solcore includes several methods to solve the properties of a solar cell, including optics and electrical properties. To solve the optics, :literal:`Solcore` have built in a transfer matrix solver and can be linked to `S4 <http://github.com/phoebe-p/S4>`_, a rigorous couple wave analysis solver. For the electrical properties, :literal:`Solcore` includes from the fundamental detailed balance (DB) solver to the more rigorous Poisson-drift-diffusion (PDD) equation solver. The electrical solvers apply to the *individual junctions* separately, and then their ouput are combined to get the properties of a multi-junction device.

The two most important elements of the solar cell solver module are the **solar_cell_solver** function and the **default_options** variable (see :ref:`solver-options`). The former is the function to be called to calculate any property of any solar cell, regardless of how the junctions have been defined or the specific property of interest. It provides a common interface for any calculation. To use it, simply do:
    ::

        from solcore.solar_cell_solver import solar_cell_solver

        solar_cell_solver(my_solar_cell_object, task, user_options)

The *task* has to be "optics", "iv", "qe", "equilibrium" or "short_circuit", the last two only working for PDD junctions. The sequence followed by the solver is:

#.  The default options are updated with the user defined options
#.  The solar cell structure is scanned, calculating derived information like the width of the junctions or the offset of each layer or junction with respect the front of the cell.
#.  The solar cell object and the updated options are sent to the corresponding solver ("optics", "iv", "qe", "equilibrium" or "short_circuit"), depending on the chosen task.
#.  Except in the case of "Equilibrium", all other tasks will require calculating the optics of the cell. This is done according to the chosen *optics_method* selected in the options. The default is "BL" (Beer-Lambert law). Alternative *optics_method* values are "TMM", "RCWA", "external" or None, if optics do not need to be calculated. Visit the  :doc:`optical methods section <../Optics/optics>` for information specific to the optical solvers.
#.  For the "iv" and "qe" tasks, each of the junctions present in the solar cell will be solved, according to the method used in their definition ("PDD", "DA", "2D" or "DB"). Details of each of this methods are described in the corresponding section.
#.  Finally, for the "iv" task, the individual IV curves of the junctions and tunnel junctions, if present, are combined to calculate the IV curve of the multi-junction solar cell, taking into account radiative coupling, if required.

All of the above calculations modify the original solar cell object, adding attributes or methods to its structure. For example, after calculating the IV curve of my_solar_cell_object, this will have a new attribute called "iv" that is a dictionary with the IV of the total solar cell, the IV curves of each of the junctions, information of the Voc and Isc, if relevant, etc.

More details of the specific electrical solvers included in Solcore can be found in:

.. toctree::
    :maxdepth: 0

    detailed_balance
    TwoDiode
    depletion
    DDsolver
    multijunction_iv


.. _solver-options:

Solver Options
--------------

All options that need to be passed to the solvers (either electrical or optical) are passed as a dictionary via de *user_options* keyword to the *solar_cell_solver* method described above. If no options are provided, the solver will try to use the default ones, which might or might not be adequate to your specific problem. These options are common for all calculations.

The options available as well as the default values are:

- General
    - **T_ambient** = 298
        Ambient temperature (K)

    - **T** = 298
        Cell temperature (K). It is actually made equal to the temperature in the solar solar cell definition: my_solar_cell.T .

- :doc:`Illumination spectrum <../spectral/spectral>`
    - **wavelength** = np.linspace(300, 1800, 251) * 1e-9
        Wavelengths of the illumination spectrum (m)

    - **light_source** = LightSource(source_type='standard', version='AM1.5g', x=default_options.wavelength, output_units='photon_flux_per_m')
        The illumination spectrum Air Mass 1.5 global spectrum, provided at the above wavelengths in units of photons•s\ :sup:`-1` m\ :sup:`-2`.

- IV control
    - **voltages** = np.linspace(0, 1.2, 100)
        Voltages at which to calculate the IV curve of the *complete* solar cell.

    - **mpp** = False
        If the parameters of the solar cell under illumination (Isc, Voc, Pmpp, Impp, Vmpp, fill factor and efficiency) have to be calculated. If False, all of them will have the value None.

    - **light_iv** = False
        If the light IV curve is to be simulated.

    - **internal_voltages** = np.linspace(-6, 4, 1000)
        The voltages at which the IV curve of *each of the junctions* inside the cell have to be calculated. This range has to be wider than the **voltages** above, in general. The same voltage range will be used in all junctions.

    - **position** = np.arange(0, solar_cell.width, 1e-10)
        Positions inside the solar cell structure in which to calculate the absorption. By default, it is calculated each angstrom for the whole width of the cell. To control the depth spacing, the user can pass:

        #. a vector which specifies each position (in m) at which the depth should be calculated
        #. a single number which specifies the spacing (in m) to generate the position vector, e.g. 1e-9 for 1 nm spacing
        #. a list of numbers which specify the spacing (in m) to be used in each layer. This list can have EITHER the length of the number of individual layers + the number of junctions in the cell object, OR the length of the total number of individual layers including layers inside junctions.

    - **radiative_coupling** = False
        If radiative coupling has to be included in the calculation.

- Optics control
    - **optics_method** = 'BL'
        Default method to calculate the optical properties of the cell. Other possible values are "TMM", "RCWA", "external" or None.

- :doc:`Rigorous couple wave analysis options <../Optics/S4doc>`
    Check the RCWA section for details on this parameters.

    - **size** = [500, 500]
    - **orders** = 4
    - **theta** = 0
    - **phi** = 0
    - **pol** = 'u'

- :doc:`Detailed balance solver options <detailed_balance>`
    - **db_mode** = 'boltzmann'
        If the Boltzmann approximation should be used in the detailed balance solver. Any other choice will result in using the full Plank equation, which will be slower, in general.

- :doc:`Depletion approximation solver options <depletion>`
    - **da_mode** = 'bvp'
        Selects the numerical approximation method for the drift-diffusion equation in the depletion approximation solver. Possible values are “bvp” for numerical solution using the `solve_bvp` method of the `scipy.integrate` module or 'green' for a semi-analytic solution using Green's functions. The latter is expected to be faster. 

- :doc:`Poisson-drift diffusion solver options <DriftDiffusionUtilities>`
    Check the PDD section for details on this parameters.

    - Mesh control
        - **meshpoints** = -400
        - **growth_rate** = 0.7
        - **coarse** = 20e-9
        - **fine** = 1e-9
        - **ultrafine** = 0.2e-9

    - Convergence control
        - **clamp** = 20
        - **nitermax** = 100
        - **ATol** = 1e-14
        - **RTol** = 1e-6

    - Recombination control
        - **srh** = 1
        - **rad** = 1
        - **aug** = 0
        - **sur** = 1
        - **gen** = 0


Solar cell solver module functions
----------------------------------

.. automodule:: solcore.solar_cell_solver
    :members:
    :undoc-members:

Poisson - Drift-Diffusion solver (PDD)
======================================

- Example 1: :doc:`Example of a simple 2J solar cell calculated with the PDD solver <../Examples/example_PDD_solver>`
- Example 2: :doc:`Tutorial: 2J solar cell with QWs in the bottom cell <../Examples/tutorial>`

The PDD package provide all tools necesary to build a solar cell structure and calculate its properties by solving simultaneously the Poisson equation and the drfit diffusion equations. Normally, these functions will not need to be accessed directly, but are called internally by :literal:`Solcore` when using the higher level methods in the :doc:`solar cell solver <solving_solar_cells>`.

For using the PDD package, it is enough to include the following line in your code:

.. code-block:: python

	import solcore.poisson_drift_diffusion as PDD
	
With this, all the functionality of the package will be available to the user. The actual functions and calculations are spread in several modules:
	
1.	:doc:`Drift Diffusion Utilities <DriftDiffusionUtilities>`
    **File:** solcore/PDD/DriftDiffusionUtilities.py
	Contains the python interface that dumps all the information of the device structure into the fortran variables and that executes the chosen calculation, getting the data from the fortran variables at the end. This module contains the following methods called internally by the solar_cell_solver:

	- equilibrium_pdd
	- short_circuit_pdd
	- iv_pdd
	- qe_pdd

2.	:doc:`Device Structure <DeviceStructure>`
    **File:** solcore/PDD/DeviceStructure.py
	Contains several functions necessary to build a structure that can be read by the PDD solver. The most important of this functions is **CreateDeviceStructure** that scans the junction layers and extracts from the materials database all the parameters required by the PDD solver. Finally, it contains the default properties that are used if they are not found for a particular material. In general, these default properties correspond to those of GaAs at 293 K.

3.	:doc:`QW unit creator <QWunit>`
    **File:** solcore/PDD/QWunit.py
	Contains utilities that transform the sequence of layers into a *structure* that, in turn, can be used to solve the Schrodinger equation and the kp model. It also prepares the properties of the structure (bandedges, efective density of states, etc) in order to have a meaningful set of properties for the DD solver, using the **GetEffectiveQW**.

4.	**Drift Diffusion Fortran solver**

	**File:** solcore/PDD/DDmodel-current.f95

      This is the current version of the Fortran code that, once compiled, performs all the heavy numerical calculations. Normally you would not need to care about this file except if you intend to modify the numerical solver itself.
	
\---------------------

.. toctree::
   :maxdepth: 2

   DeviceStructure
   DriftDiffusionUtilities
   QWunitAnalytic solar cells calculator
===============================

**WARNING: Documentation not updated for Solcore 5**

This package include the tools to calculate, using an analytical approach, the quantum efficiency or the IV characteristics of a solar cell (single junction or multi-junction). The tools that can be accessed directly when importing this package are:

- multijunctionIV
- spectral_response_all_junctions

Check below for other tools that might be available when importing the modules within this package.

.. _quantum_efficiency_calculator:

Quantum efficiency calculator
-----------------------------
This module calculates the quantum efficiency of any number of junctions. It uses the diffusion coefficients, diffusion lengths and the depletion aproximation to find out the fraction of photon that can be collected as a function or energy.

Contrary to the :ref:`iv_calculator`, calculating the QE requires a substantial amount of information related to the material properties for each of the junctions and each of the layers that form each junction. In the next example we show the structure definition for calculating the QE of a GaInP/InGaAs/Ge tripple junction solar cell. Each subcell is a PN junction - requiring therefore two materials, one for the P and the other for the N side - and also includes a window layer and an AR coating.
::

    import numpy as np
    import os
    from solcore import siUnits, material, si, asUnit
    from solcore.constants import h, c, vacuum_permittivity
    from solcore.structure import Structure, Junction, Layer
    from solcore.state import State
    from solcore.interpolate import interp1d

    # We need to build the solar cell layer by layer.
    # All the materials will be stored in this list, from top to bottom.
    all_materials = []

    # We start from the AR coating. We only need this to define the reflexion of the cell.
    # In this case, we load it from an an external file
    def this_dir_file(f):
        return os.path.join(os.path.split(__file__)[0], f)

    refl_nm = np.loadtxt(this_dir_file("MgF-ZnS_AR.csv"), unpack=True, delimiter=",")
    refl_J = np.array((h * c / siUnits(refl_nm[0], "nm")[::-1], refl_nm[1][::-1]))

    # Next is the window layer, made of AlInP. We load the absorption coefficent of AlInP from an external file, too
    AlInP = material("AlInP")
    window_material = AlInP(Al=0.52)
    window_alpha = np.loadtxt(this_dir_file("alinp.csv"), unpack=True, delimiter=",")
    window_material.alphaE = interp1d(x=siUnits(window_alpha[0], "eV"), y=window_alpha[1], bounds_error=False, fill_value=0)

    all_materials.append(window_material)

    # TOP CELL - GaInP
    # Now we build the top cell, which requires the n and p sides of GaInP.
    # We also load the absorption coefficient from an external file. We also add some extra parameters needed for the
    # calculation such as the minority carriers diffusion lengths
    InGaP = material("GaInP")
    top_cell_n_material = InGaP(In=0.49, Nd=siUnits(2e18, "cm-3"), role="n")
    top_cell_p_material = InGaP(In=0.49, Na=siUnits(1e17, "cm-3"), role="p")
    top_cell_alpha = np.loadtxt(this_dir_file("in048ga052p.csv"), unpack=True, delimiter=",")
    top_cell_n_material.alphaE = interp1d(x=siUnits(top_cell_alpha[0], "eV"), y=top_cell_alpha[1], bounds_error=False,
                                          fill_value=0)
    top_cell_p_material.alphaE = top_cell_n_material.alphaE
    top_cell_n_material.hole_minority_carrier_diffusion_length = si("200nm")
    top_cell_p_material.electron_minority_carrier_diffusion_length = si("1um")

    all_materials.append(top_cell_n_material)
    all_materials.append(top_cell_p_material)

    # MID CELL  - InGaAs
    # The same thing.
    InGaAs = material("InGaAs")
    mid_cell_n_material = InGaAs(In=0.01, Nd=siUnits(3e18, "cm-3"), role="n")
    mid_cell_p_material = InGaAs(In=0.01, Na=siUnits(1e17, "cm-3"), role="p")
    mid_cell_alpha = np.loadtxt(this_dir_file("in01gaas.csv"), unpack=True, delimiter=",")
    mid_cell_n_material.alphaE = interp1d(x=siUnits(mid_cell_alpha[0], "eV"), y=mid_cell_alpha[1], bounds_error=False,
                                          fill_value=0)
    mid_cell_p_material.alphaE = mid_cell_n_material.alphaE
    mid_cell_n_material.hole_minority_carrier_diffusion_length = si("500nm")
    mid_cell_p_material.electron_minority_carrier_diffusion_length = si("5um")

    all_materials.append(mid_cell_n_material)
    all_materials.append(mid_cell_p_material)

    # BOTTOM CELL - Ge
    # Idem
    Ge = material("Ge")
    bot_cell_n_material = Ge(Nd=siUnits(2e18, "cm-3"), role="n")
    bot_cell_p_material = Ge(Na=siUnits(1e17, "cm-3"), role="p")
    Ge_alpha = np.loadtxt(this_dir_file("Ge-Palik.csv"), unpack=True, delimiter=",")
    Ge.alphaE = interp1d(x=siUnits(Ge_alpha[0], 'eV'), y=Ge_alpha[1])
    bot_cell_n_material.hole_minority_carrier_diffusion_length = si("800nm")
    bot_cell_p_material.electron_minority_carrier_diffusion_length = si("50um")

    all_materials.append(bot_cell_n_material)
    all_materials.append(bot_cell_p_material)

    # We add some other properties to the materials, assumed the same in all cases.
    # If different, we should have added them above.
    for mat in all_materials:
        mat.hole_mobility = 3.4e-3
        mat.electron_mobility = 5e-2
        mat.dielectric_constant = 9 * vacuum_permittivity

    # And, finally, we put everything together, adding also the surface recombination velocities.
    triplejunction = Structure(
        [
            Layer(material=window_material, width=si("25nm")),
            Junction(
                (
                    Layer(si("100nm"), material=top_cell_n_material),
                    Layer(si("600nm"), material=top_cell_p_material),
                ),
                sn=1,
                sp=1,
            ),
            Junction(
                (
                    Layer(si("100nm"), material=mid_cell_n_material),
                    Layer(si("3.5um"), material=mid_cell_p_material),
                ),
                sn=1,
                sp=1,
            ),
            Junction(
                (
                    Layer(si("400nm"), material=bot_cell_n_material),
                    Layer(si("100um"), material=bot_cell_p_material),
                ),
                sn=1,
                sp=1,
            ),
        ]
    )

    # Now the 'solar_cell' object below contains all the information regarding the solar cell. So, we use it
    solar_cell = State()
    solar_cell.structure = triplejunction
    solar_cell.reflectivity = refl_J

So far, it has been only the definition of the structure. To actually calculate the quantum efficiency we need to add the energy range in which we want to calculate the results and call the *spectral_response_all_junctions* function:
::

    import solcore.analytic_solar_cells as ASC

    # The energy in SI units
    E = si(np.linspace(0.6, 3.4, 1000), "eV")

    # We add this energy to the solar cell structure.
    solar_cell.energies = E

    # We run the simulation. Verbose=True ensures that we have a full report of the parameters printed on the screen
    qe_result = ASC.spectral_response_all_junctions(solar_cell, verbose=True)

Below there is an image of the QE corresponding to the three junctions as a function of wavelength, which is a more common representation.

.. image:: Figures/qe_mj.png
	:align: center

Since we didn't define any solar spectrum or solar cell geometry, we can not have the short circuit current for each of the junctions. We add that information to the solar_cell object above and sun again the solver. We are assuming we have some concentration optics and metallisation on top of the solar cell:
::

    from solcore.solar_spectrum import calculate_spectrum_spectral2

    # Configure cell geometry and concentration
    # Cell area is stated to be 7mm x 7mm
    cell_area = 0.7 * 0.7 / 1e4  # expressed in m-2
    # Geometrical concentration is 1000, but the optical efficiency is approximately 0.85 and cell metalisation shading 8%
    concentration_factor = 1000 * 0.85 * (1 - 0.08)

    # We create a solar spectrum using SPECTRAL2 and the default configuration
    # - See documentation and example of that package for more info
    spectrum = calculate_spectrum_spectral2()

    # We use the spectrum is in SI units: Watts m-2 joule-1.
    incident_x_J_y_per_J = spectrum["incident spectrum energy si"]
    incident_function = interp1d(y=incident_x_J_y_per_J[1] * concentration_factor * cell_area, x=incident_x_J_y_per_J[0])
    power_density = spectrum["incident power density"]
    print('Power density = {:.2f} W m-2\n'.format(power_density))

    # We already have the energies, as defined above
    solar_cell.incident_light = (E, incident_function(E) / E )
    qe_result = ASC.spectral_response_all_junctions(solar_cell, verbose=False)

    print("Subcell photocurrent density [mA cm-2]:")
    print('\tJsc(Top) = {:.2f}'.format(1e3 * qe_result["junctions"][0]["J"] / (cell_area * 1e4 * concentration_factor)))
    print('\tJsc(Mid) = {:.2f}'.format(1e3 * qe_result["junctions"][1]["J"] / (cell_area * 1e4 * concentration_factor)))
    print('\tJsc(Bot) = {:.2f}'.format(1e3 * qe_result["junctions"][2]["J"] / (cell_area * 1e4 * concentration_factor)))

After these modifications, the quantum efficiency has not changed, but we can have the short circuit current density of each of the subcells:
::

    Power density = 891.90 W m-2

    Subcell photocurrent density [mA cm-2]:
        Jsc(Top) = 9.73
        Jsc(Mid) = 12.02
        Jsc(Bot) = 25.18


.. automodule:: solcore.analytic_solar_cells.QE
    :members:
    :undoc-members:

.. _iv_calculator:

Multi-junction current voltage calculator
-----------------------------------------
This module contanes all the functions necessary to calculate the IV curve of single and multi-junction solar cells using the2-diode equation as the starting point. In addition to the *multijunctionIV* function that can invoked directly when importing the solcore.analytic_solar_cells package, this module containes several tools to calculate the reverse saturation currents under the radiative aproximation, using a radiative efficiency or based on the knowledge of Voc and Jsc.

Here is an example on how to use this module to calculate the IV curve of a triple junction solar cell, using the results of the Example 3 above (see :ref:`quantum_efficiency_calculator`) and ploting them with the *solcore.graphing* package:
::

    import numpy as np
    from solcore.structure import Structure, Junction
    import solcore.analytic_solar_cells as ASC
    from solcore.state import State
    from solcore.graphing import *

    # We import the QE results obtained in ASC_example_3 which contain the short circuit currents of each junction
    # when the solar cell is illuminated with the default SPECTAL2 spectrum
    from ASC_example_3 import qe_result, power_density, cell_area, concentration_factor

    # Ref temperature ºC. Let's say we have the reverse saturation currents J01 and J02 of each junction at a
    # reference temperature and we want the IV curve at a different one. We have to make a correction to the J01 and J02
    cell_temp = 60
    ref_temp = 25

    Tcell = 273 + cell_temp
    Tref = 273 + ref_temp

    # The IV data will be stored in a State object. We create it, including the cell and reference temperatures.
    IV_calculation_state = State(T=Tcell, Tref=Tref)

    # From the QE object we get the short circuit currents
    Isc_array = [qe_result["junctions"][0]["J"], qe_result["junctions"][1]["J"], qe_result["junctions"][2]["J"]]

    # And we create a list with the reverse saturation currents. In this case, we don't calculate them but just assume we
    # have them from somewhere.
    I01_array = [4.93e-24, 1.0e-21, 4.93e-6]
    I02_array = [3.28e-15, 2.7e-10, 1.0e-5]

    # This is the structure to calculate.
    IV_calculation_state.structure = Structure(
        [
            Junction(Eg=1.9, j01=I01_array[0], j02=I02_array[0], R_shunt=3e6,
                     R_series=0.0236, n1=1.00, n2=2.0, photocurrent=Isc_array[0]),
            Junction(Eg=1.4, j01=I01_array[1], j02=I02_array[1], R_shunt=1.5e6,
                     R_series=0.0012, n1=1.00, n2=2.0, photocurrent=Isc_array[1]),
            Junction(Eg=0.66, j01=I01_array[2], j02=I02_array[2], R_shunt=115,
                     R_series=8e-4, n1=1.00, n2=2.0, photocurrent=Isc_array[2]),
        ]
    )

    # We solve it, including explicitely the range of voltages we are interested
    IV_result = ASC.multijunctionIV(IV_calculation_state, V=np.linspace(0, 4, 1000))

    # We use the tools of the graphing package to get a nice plot of the IV curves.
    junction_colors = ["blue", "green", "red"]
    graph_lines = [GraphData(iv, label="Junction {}".format(i + 1), color=junction_colors[i])
                   for i, iv in enumerate(IV_result["junction IV"])]
    graph_lines.append(GraphData(IV_result["IV"], linewidth=2, color="black", label="Multijunction"))
    g = Graph(graph_lines, ylim=(0, 7), xlabel="Bias (V)", ylabel="Current (A)", legend="best").draw()

    eta = IV_result["Pmpp"] / (power_density * cell_area * concentration_factor)

    print('\nThe solar cell properties are: ')
    print('\tIsc = {:.2f} mA cm-2'.format(1e3 * IV_result["Isc"] / (cell_area * 1e4 * concentration_factor) ))
    print('\tVoc = {:.2f} V'.format(IV_result["Voc"]))
    print('\tFF = {:.2f} % '.format(IV_result["FF"] * 100))
    print('\tEta = {:.2f} %'.format(eta * 100))

The result of the above coe will be the figure below and the following output:
::

    Power density = 891.90 W m-2

    Subcell photocurrent density [mA cm-2]:
        Jsc(Top) = 9.73
        Jsc(Mid) = 12.02
        Jsc(Bot) = 25.18

    The solar cell properties are:
        Isc = 9.73 mA cm-2
        Voc = 3.34 V
        FF = 89.20 %
        Eta = 32.51 %

.. image:: Figures/iv_mj.png
	:align: center

.. automodule:: solcore.analytic_solar_cells.IV
    :members:
    :undoc-members:
Drift Diffusion Utilities
=========================

This module is the interface between Python and Fortran. It takes a structure created with the tools in :doc:`Device Structure <DeviceStructure>` and dumps all that information into the Fortran variables. Then, it runs the selected calculation. This process is completely transparent for the user who only needs to use the higher level methods in the :doc:`solar cell solver <solving_solar_cells>`.

At the end of this page there is a detailed description of the format of all the functions within this module, but here we focus in the more practical aspect, including also examples of usage.

.. py:function:: ProcessStructure(device [, wavelengths=None] )

	This function reads a dictionary containing all the device structure, extract the electrical and optical properties of the materials, and loads all that information into the Fortran variables. Finally, it initialises the device (in Fortran) calculating an initial mesh and all the properties as a function of the position. An initial estimation of the quasi-Fermi energies, electrostatic potential and carrier concentration is also performed. This will be used as initial condition for the numerical solver.

	**Output** (see :ref:`output-dictionary`): **Properties**

.. py:function:: equilibrium_pdd(junction, options):

	Solves the PDD equations under equilibrium: in the dark with no external current and zero applied voltage. Internally, it calls *CreateDeviceStructure* to retrieve all the material parameters (as described in :doc:`DeviceStructure`) and *ProcessStructure* to dump all the data into the Fortran variables and perform the initialization of the structure.

	After finishing the calculation, the junction object will be updated with an attribute called "equilibrium_data" containing the dictionaries **Properties** and **Bandstructure** (see :ref:`output-dictionary`).


.. py:function:: short_circuit_pdd(junction, options):

	Solves the PDD equations under short circuit conditions: current flowing through the structure due to the light absorbed and zero applied voltage. It calls internally to *equilibrium_pdd* before solving the problem in short circuit.

	After finishing the calculation, the junction object will be updated with an attribute called "short_circuit_data" containing the dictionaries **Properties**, **Bandstructure** and **Optics** (see :ref:`output-dictionary`), in addition to the "equilibrium_data" attribute.

The following example shows the result of calculating a solar cell under short circuit conditions, comparing the resulting band structure. Note that neither equilibrium_pdd nor short_circuit_pdd are called directly, but they are accessed internally by *solar_cell_solver*.

.. code-block:: python

    import matplotlib.pyplot as plt

    from solcore import material
    from solcore.structure import Layer, Junction
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver

    T = 298

    # First, we create the materials, overriding any default property we want, such as the doping or the absorption coefficient
    window = material('AlGaAs')(T=T, Na=1e24, Al=0.8)
    p_GaAs = material('GaAs')(T=T, Na=1e24)
    i_GaAs = material('GaAs')(T=T)
    n_GaAs = material('GaAs')(T=T, Nd=1e23)
    bsf = material('AlGaAs')(T=T, Nd=1e24, Al=0.4)

    # We put everything together in a Junction.
    MyJunction = Junction([ Layer(width=30e-9, material=window, role="Window"),
                            Layer(width=400e-9, material=p_GaAs, role="Emitter"),
                            Layer(width=400e-9, material=i_GaAs, role="Intrinsic"),
                            Layer(width=2000e-9, material=n_GaAs, role="Base"),
                            Layer(width=200e-9, material=bsf, role="BSF")],
                            sn=1e3, sp=1e3, T=T, kind='PDD')

    my_solar_cell = SolarCell([MyJunction], T=T, R_series=0, substrate=n_GaAs)

    # We solve the short circuit problem
    solar_cell_solver(my_solar_cell, 'short_circuit')

    # We can plot the electron and hole densities in short circuit...
    zz = my_solar_cell[0].short_circuit_data.Bandstructure['x'] * 1e9
    n = my_solar_cell[0].short_circuit_data.Bandstructure['n']
    p = my_solar_cell[0].short_circuit_data.Bandstructure['p']
    plt.semilogy(zz, n, 'b', label='e @ short circuit')
    plt.semilogy(zz, p, 'r', label='h @ short circuit')

    # ... and equilibrium
    zz = my_solar_cell[0].equilibrium_data.Bandstructure['x'] * 1e9
    n = my_solar_cell[0].equilibrium_data.Bandstructure['n']
    p = my_solar_cell[0].equilibrium_data.Bandstructure['p']
    plt.semilogy(zz, n, 'b--', label='e @ equilibrium')
    plt.semilogy(zz, p, 'r--', label='h @ equilibrium')

    plt.xlabel('Position (nm)')
    plt.ylabel('Carrier density (m$^{-3}$)')
    plt.legend()
    plt.show()


The result of the above calculation is this:
	
.. image:: Figures/EQandSC.png
    :align: center

.. py:function:: iv_pdd(junction, options):

	Calculates the IV curve of the device at the **internal_voltages** indicated in the options. Depending on the options, also, the IV will be calculated in the dark (calling the equilibrium_pdd function) or under illumination (calling the short_circuit_pdd function). If the voltage range has positive and negative values, the problem is solved twice: from 0 V to the maximum positive and from 0 V to the maximum negative, concatenating the results afterwards.

    After finishing the calculation, the Junction object will have a few extra attributes, in addition to those resulting from equilibrium_pdd and short_circuit_pdd (yes, there is a lot of redundancy at the moment):

    - **pdd_data**: Contains all the data (**Properties**, **Bandstructure**, etc.) of the positive and negative voltage calculations.
    - **voltage**: An array with the internal_voltages
    - **current**: An array with the total current at the internal_voltages, including the effect of any shunt resistance, if present.
    - **recombination_currents**: A dictionary containing the different recombination currents at the internal voltages: radiative, SRH, Auger and surface recombination.
    - **iv**: A function that returns the current at the input voltage. Essentially, it interpolates the voltages and currents of the junction using the Scipy function interp1d.

In the following example, we use the same solar cell described above and calculate the dark IV curve, plotting the different contributions to the current.

.. code-block:: python

    import matplotlib.pyplot as plt

    from solcore import material
    from solcore.structure import Layer, Junction
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver

    T = 298

    substrate = material('GaAs')(T=T)

    # First, we create the materials, overriding any default property we want, such as the doping or the absorption coefficient
    window = material('AlGaAs')(T=T, Na=1e24, Al=0.8)
    p_GaAs = material('GaAs')(T=T, Na=1e24)
    i_GaAs = material('GaAs')(T=T)
    n_GaAs = material('GaAs')(T=T, Nd=1e23)
    bsf = material('AlGaAs')(T=T, Nd=1e24, Al=0.4)

    # We put everything together in a Junction. We include the surface recombination velocities,
    # sn and sp, although they are not necessary in this case.
    MyJunction = Junction([Layer(width=30e-9, material=window, role="Window"),
                           Layer(width=400e-9, material=p_GaAs, role="Emitter"),
                           Layer(width=400e-9, material=i_GaAs, role="Intrinsic"),
                           Layer(width=2000e-9, material=n_GaAs, role="Base"),
                           Layer(width=200e-9, material=bsf, role="BSF")],
                          sn=1e3, sp=1e3, T=T, kind='PDD')

    my_solar_cell = SolarCell([MyJunction], T=T, R_series=0, substrate=substrate)

    # We calculate the IV curve under illumination, using all the default options
    solar_cell_solver(my_solar_cell, 'iv')

    plt.semilogy(my_solar_cell[0].voltage, abs(my_solar_cell[0].current), 'k', linewidth=4, label='Total')
    plt.semilogy(my_solar_cell[0].voltage, abs(my_solar_cell[0].recombination_currents['Jrad']), 'r', label='Jrad')
    plt.semilogy(my_solar_cell[0].voltage, abs(my_solar_cell[0].recombination_currents['Jsrh']), 'b', label='Jsrh')
    plt.semilogy(my_solar_cell[0].voltage, abs(my_solar_cell[0].recombination_currents['Jsur']), 'g', label='Jsur')

    plt.legend()
    plt.xlim(-0.5, 1.3)
    plt.ylim(1e-10, 1e5)
    plt.xlabel('Bias (V)')
    plt.ylabel('Current (A/m$^2}$)')

    plt.show()


The result of the above calculation is this:
	
.. image:: Figures/IV.png
    :align: center

In order to get the IV curve under illumination, we simply indicate it with the *user_options* keyword in the solar_solar_cell solver function, also asking for the parameters under illumination (Voc, Isc, etc.).

.. code-block:: python

    solar_cell_solver(my_solar_cell, 'iv', user_options={'light_iv' : True, 'mpp' : True})

    plt.plot(my_solar_cell[0].voltage, -my_solar_cell[0].current, 'r', linewidth=2, label='Total')

    plt.xlim(-0.5, 1.3)
    plt.ylim(0, 350)
    plt.xlabel('Bias (V)')
    plt.ylabel('Current (A/m$^2}$)')

    plt.text(0, 200, 'Voc = {:4.1f} V\n'
                     'Isc = {:4.1f} A/m${^2}$\n'
                     'FF = {:4.1f} %\n'
                     'Pmpp = {:4.1f} W/m${^2}$'.format(my_solar_cell.iv['Voc'], my_solar_cell.iv['Isc'],
                                               my_solar_cell.iv['FF'] * 100, my_solar_cell.iv['Pmpp']))


While the power at maximum power point seems very high (>300 W/m :sup:`2` ) let's keep in mind that the default modelling options use the Beer-Lambert law optics method which *does not take into account* front surface reflection. If that is included (for example using the TMM optics method) Isc will be much lower and so will the power.
	
.. image:: Figures/LightIV.png
    :align: center


.. py:function:: qe_pdd(junction, options):

	Calculates the quantum efficiency at short circuit with bias light, given in the options. Internally, it calls short_circuit_pdd, getting all the related output information (see above).

    After finishing the calculation, the junction object will have an attribute called **qe_data** with the EQE and all the associated losses due to radiative recombination, SRH recombination, Auger recombination or front/back surface recombination. It will also have a method **eqe** that accepts an array of wavelengths and returns the EQE.

.. code-block:: Python

    import matplotlib.pyplot as plt

    from solcore import material
    from solcore.structure import Layer, Junction
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver

    T = 298

    substrate = material('GaAs')(T=T)

    # First, we create the materials, overriding any default property we want, such as the doping or the absorption coefficient
    window = material('AlGaAs')(T=T, Na=1e24, Al=0.8)
    p_GaAs = material('GaAs')(T=T, Na=1e24)
    i_GaAs = material('GaAs')(T=T)
    n_GaAs = material('GaAs')(T=T, Nd=1e23)
    bsf = material('AlGaAs')(T=T, Nd=1e24, Al=0.4)

    # We put everything together in a Junction. We include the surface recombination velocities,
    # sn and sp, although they are not necessary in this case.
    MyJunction = Junction([Layer(width=30e-9, material=window, role="Window"),
                           Layer(width=400e-9, material=p_GaAs, role="Emitter"),
                           Layer(width=400e-9, material=i_GaAs, role="Intrinsic"),
                           Layer(width=2000e-9, material=n_GaAs, role="Base"),
                           Layer(width=200e-9, material=bsf, role="BSF")],
                          sn=1e6, sp=1e6, T=T, kind='PDD')

    my_solar_cell = SolarCell([MyJunction], T=T, R_series=0, substrate=substrate)

    # We calculate the EQE of the cell, using the TMM optics method.
    solar_cell_solver(my_solar_cell, 'qe', user_options={'optics_method': 'TMM'})

    wl = my_solar_cell[0].qe_data.wavelengths * 1e9

    plt.plot(wl, 1 - my_solar_cell.reflected, 'b')
    plt.fill_between(wl, 1 - my_solar_cell.reflected, 1, facecolor='blue', alpha=0.6, label='Reflected')
    plt.fill_between(wl, 1 - my_solar_cell.reflected, my_solar_cell.absorbed, facecolor='yellow', alpha=0.5,
                     label='Transmitted')

    # EQE + fraction lost due to recombination in the front surface
    plt.plot(wl, my_solar_cell[0].qe_data.EQE + my_solar_cell[0].qe_data.EQEsurf, 'r')
    plt.fill_between(wl, my_solar_cell[0].qe_data.EQE + my_solar_cell[0].qe_data.EQEsurf, my_solar_cell[0].qe_data.EQE,
                     facecolor='red', alpha=0.5, label='Front surface recombination')

    plt.plot(wl, my_solar_cell[0].qe_data.EQE, 'k', linewidth=4)
    plt.fill_between(wl, my_solar_cell[0].qe_data.EQE, 0, facecolor='green', alpha=0.5, label='EQE')

    plt.legend()
    plt.xlim(300, 950)
    plt.ylim(0, 1)
    plt.xlabel('Wavelength (nm)')
    plt.ylabel('EQE (%/100)')

    plt.show()

The result of running the code above is the next figure, where the EQE of the cell is plotted together with the main sources of losses in this particular case: reflection, recombination in the front surface and sub-bandgap light transmission.

.. image:: Figures/QE.png
    :align: center

In principle, EQE + all the internal sources of losses (SRH, surface recombination, etc.) should be equal to the total absorbed light and, in any case, smaller than 1. **Sometimes this does not happen and the result is > 1**. The reason is the vertical discretization process of the solar cell which is not accurate in situations where there is a fast variation of the absorption and/or the electron generation. This happens at short wavelengths, when absorption is very fast in the first few nanometers, and at longer wavelengths in the presence of oscillations due to interference. There are three tricks to tackle this issue:

- Increase the number of mesh points in the PDD solver by adjusting the options dealing with the mesh creation (see below and :ref:`solver-options`). This will result in a global increase in mesh points and therefore will make the PDD solver slower.
- Divide thick layers into thinner ones. This will increase the number of mesh points locally in that region, and therefore good if the one causing problems is identified. This solution is helpful for the case of fast oscillations.
- Increase the number of points used by the optical solver. By default, this is one point per angstrom, and therefore very dense already, but might help, specially at short wavelengths. This is controlled by the 'position' option (see :ref:`solver-options`).


Setting different aspects of the solver
---------------------------------------

.. py:function:: SetMeshParameters(**kwargs)

Set the parameters that control the meshing of the structure. Changing this values might improve convergence in some difficult cases. The absolute maximum number of meshpoints at any time is 6000. The keywords and default values are:
	
	- **meshpoints = -400** : Defines the type of meshing that must be done. 
		- *meshpoints* > 0: The mesh is homogeneous with that many mesh points. 
		- *meshpoints* = 0: The mesh is inhomogeneous with master nodes at the interfaces between layers and denser mesh around them. This density and distribution of the points are controlled by the variables *coarse*, *fine* and *ultrafine*. 
		- *meshpoints* < 0: The exact value does not matter. The mesh is inhomogeneous with master nodes at the interfaces between layers and denser mesh around them. Initially, their density and distribution is controlled by the variables *coarse*, *fine* and *ultrafine* but then this is dynamically modified to increase or reduce their density in a 'smooth' way, wherever the mesh points are needed more. This dynamic remeshing is performed at different stages of the above solvers. Master nodes are not modified.		
		
	- **growth_rate = 0.7** : Defines how 'fast' mesh points are increased by the dynamic meshing routine. It should between 0 and 1. Small values produce denser meshes and larger values produce coarser ones.
	
	- **coarse = 20e-9**
	- **fine = 1e-9**
	- **ultrafine = 0.2e-9**
		Values are in nanometers. Define the structure of the inhomogeneous mesh and the initial dynamic mesh. After defining the master nodes (two nodes separated 0.1 nm per interface), the space between them is divided in equal size elemens smaller or equal than *coarse*. Then, the coarse elements adjacent to the master nodes are divided in equal size elemens smaller or equal than *fine*. Finally, the fine elements adjacent to the master nodes are divided in equal size elemens smaller or equal than *ultrafine*. This structure is static if *meshpoints* = 0 and evolves if *meshpoints* < 0 to a smoother configuration. 

.. image:: Figures/mesh.png
	:align: center
	
	
.. py:function:: SetRecombinationParameters(**kwargs)

	Activate (1) and deactivate (0) a given recombination mechanism. The 'virtual experiment' functions above use this function to activate/deactive the generation, depending of whether there is ligth or not. The keywords and default values are:

	- **srh = 1** : Schockley-Read-Hall recombination
	- **rad = 1** : Radiative recombination
	- **aug = 0** : Auger recombination
	- **sur = 1**	: Surface recombination (at the front and back contacts)
	- **gen = 0**	: Generation
	
	
.. py:function:: SetConvergenceParameters(**kwargs)

	Control the convergence of the solver by changing the maximum number of iterations and the tolerances. The keywords and default values are:
	
	- **clamp = 20** : In *kT* units. Limits the maximum change in the electrostatic potential and quasi-Fermi energies at each iteration of the solver. Smaller values migth improve convergence in detriment of the speed. 
	- **nitermax = 100** : Maximum number of iterations of the solver. 
	- **ATol = 1.5e-08** : Absolute tolerance of the solver. If the residual is smaller than this, the solver will finish. This is the square root of the machine epsilon of *numpy.float64*. Lower values than this often lead to numerical errors and lack of convergence, in adition to much lower speed.
	- **RTol = 1e-4** : Relative tolerance of the solver. If the difference of the residual between sucessive calculations is smaller than this value, the solver will finish.
	

.. _output-dictionary:

Output dictionary
-----------------

All virtual experiments described above produce a dictionary as output. A variable can be accessed as:
::

	output[<primary_key>][<secondary_key]


The total list of primary (columns) and secondary (rows) keys are:

============== ============== ============== ============== ==============
Properties     Bandstructure  IV             QE             Optics
============== ============== ============== ============== ==============
x              x              V              wavelengths    wavelengths
Xi             n              J              EQE            R
Eg	           p              Jrad           EQEsrh         T
Nd             ni             Jsrh           EQErad         \-
Na             Rho            Jaug           EQEaug         \-
Nc             Efe            Jsur           EQEsurf        \-
Nv             Efh            Jsc [a]_       EQEsurb        \-
\-             potential      Voc [a]_       \-             \-
\-             Ec             Jmpp [a]_      \-             \-
\-             Ev             Vmpp [a]_      \-             \-
\-             GR             FF [a]_        \-             \-
\-             G              \-             \-             \-
\-             Rrad           \-             \-             \-
\-             Rsrh           \-             \-             \-
\-             Raug           \-             \-             \-
============== ============== ============== ============== ==============

.. [a] Only available in light IV if *IV_info=True*

All functions description
-------------------------

.. automodule:: solcore.poisson_drift_diffusion.DriftDiffusionUtilities
    :members:
    :undoc-members:

References
----------

.. [#Ref1] S. Adachi “Optical dispersion relations for GaP, GaAs, GaSb, InP, InAs, InSb, AlxGa1−xAs, and In1−xGaxAsyP1−y,” J. Appl. Phys.,66, 6030 (1989).

.. [#Ref4] Reference AM1.5 Spectra. NREL. http://rredc.nrel.gov/solar/spectra/am1.5/
	2-diode equation
================

- Example 1: :doc:`MJ solar cell with radiative coupling <../Examples/example_radiative_coupling>`
- Example 2: :doc:`Quasi-3D 3J solar cell <../Examples/example_quasi3D_cell>`
- Example 3: :doc:`PV module calculator <../Examples/example_pv_module>`

This is the simplest method for simulating the behaviour of a solar
cell, using electrical components to model the different transport and
recombination mechanisms of the device. The 2D model is widely applied
when modelling solar cells at the most engineering end of the topic,
when a detailed knowledge of the solar cell structure (layers,
absorption coefficient, etc.) are not known or sought. It is often used
to fit experimental IV curves and find approximate, general information
on the solar cell quality without entering on the fundamental processes.
It can provide valuable information to engineers, when designing solar
modules for example, or for diagnostic purposes The complete form of the
equation is:

.. math::

   \label{eq:2diode}
   \begin{split}
   J = J_{sc} & - J_{01} \left( e^ \frac{q(V-R_sJ)}{n_1 k_b T} - 1 \right) \\
   & - J_{02} \left( e^ \frac{q(V-R_sJ)}{n_2 k_b T} - 1 \right) \\
   & - \frac{V-R_sJ}{R_{sh}}
   \end{split}

Generally, the photocurrent is modelled as a current source
(:math:`J_{sc}`), with radiative and non-radiative recombination
modelled as two diodes with reverse saturation currents :math:`J_{01}`
and :math:`J_{02}`, and ideality factors :math:`n_1\approx 1` and
:math:`n_2\approx 2`, respectively. The shunt resistance :math:`R_{sh}`
accounts for alternative current paths between the contacts of the solar
cell, being infinite in the ideal case, and the series resistance
:math:`R_s` accounts for the other transport losses. The values of the
saturation currents and ideality factors can, ultimately, be calculated
from the material properties and device structure, as is done in the
:doc:`depletion approximation model <depletion>`, but the 2D model
allows them to be provided directly as input, obtained from a fit to
experimental data, for example. They can also be calculated internally,
:doc:`using the DB solver <detailed_balance>` to obtain :math:`J_{01}` and :math:`J_{sc}`, and
then using a radiative efficiency coefficient to obtain :math:`J_{02}`.
The radiative efficiency :math:`\eta` is defined as the fraction of
radiative current :math:`J_{rad}` at a given reference total current
:math:`J_{ref}`:

.. math::

   \label{eq:eta_rad}
   \eta = \frac{J_{rad}}{J_{ref}} = \frac{J_{01}}{J_{ref}} \left( e ^{\frac{qV_{ref}}{n_1k_bT}} - 1 \right)

The reference voltage :math:`V_{ref}` can be written as a function of
:math:`\eta` and :math:`J_{ref}` as:

.. math::

   \label{eq:vref}
   V_{ref} = \frac{n_1k_bT}{q} \log \left( \frac{\eta J_{ref}}{J_{01}} + 1 \right)

On the other hand, the radiative coefficient can also be written as:

.. math::

   \label{eq:eta_nrad}
   \eta = \frac{J_{ref} - J_{nrad} - V_{ref}/R_{sh}}{J_{ref}}

Combining the last two equations and using the expression for
the diode with ideality factor :math:`n_2`, :math:`J_{02}` can be
written as:

.. math::

   \label{eq:J02}
   J_{02} = \frac{(1-\eta) J_{ref} - V_{ref} / R_{sh}}{e^ {\frac{qV_{ref}}{n_2k_bT} } - 1 }

In the common situation of very large shunt resistance and
:math:`V_{ref} >> k_bT/q`, this equation further simplifies to:

.. math::

   \label{eq:J02_simple}
   J_{02} = (1-\eta) J_{ref} \left( \frac{J_{01} }{ J_{ref} \eta } \right)^{n_1/n_2}

This process can, of course, be reversed to use knowledge of
:math:`J_{01}` and :math:`J_{02}` at a given reference current to
calculate the radiative efficiency of a solar cell, which is useful to
compare different materials, technologies or processing methods. This
was done by Chan et al. using :math:`J_{ref} = 30` mA/cm\ :math:`^2`,
obtaining :math:`\eta` values of 20% for InGaP, 22% for GaAs, and 27%
for InGaAs devices ([#Ref21]_). It should be pointed
out that this method is only valid under the assumption that
:math:`J_{01}` corresponds only to radiative recombination and
:math:`J_{02}` only to non-radiative recombination, which is generally
true for QW solar cells and some III-V solar cells, like those made of
GaAs or InGaP, but not for Si or Ge, for example. Other definitions of
the radiative efficiency are based on the external quantum efficiency,
the I\ :math:`_{sc}` and V\ :math:`_{oc}` of the cell, as described by
Green (2011) ([#Ref22]_).

Despite the simplicity of the 2-diode model, it is very useful to guide
the design of new solar cells and explore the performance of new
materials, such as dilute bismuth
alloys ([#Ref23]_), or to asses the performance of
large arrays of solar cells ([#Ref24]_).


2-diode equation functions
--------------------------

.. automodule:: solcore.analytic_solar_cells.diode_equation
    :members:
    :undoc-members:

References
----------

.. [#Ref21] Chan, N.L.A., Ekins-Daukes, N.J., Adams, J.G.J., Lumb, M.P., Gonzalez, M., Jenkins, P.P., Vurgaftman, I., Meyer, J.R., Walters, R.J.: Optimal bandgap combinations—does material quality mat- ter? IEEE J. Photovolt. 2(2), 202–208 (2012)
.. [#Ref22] Green, M.A.: Radiative efficiency of state-of-the-art photovoltaic cells. Prog. Photovolt. Res. Appl. 20(4), 472–476 (2011)
.. [#Ref23] Thomas, T., Mellor, A., Hylton, N.P., Führer, M., Alonso-Álvarez, D., Braun, A., Ekins-Daukes, N.J., David, J.P.R., Sweeney, S.J.: Requirements for a GaAsBi 1 eV sub-cell in a GaAs-based multi- junction solar cell. Semicond. Sci. Technol. 30(9), 094010-6 (2015)
.. [#Ref24] Ekins-Daukes, N.J., Kemmoku, Y., Araki, K., Betts, T.R., Gottschalg, R., Infield, D.G., Yamaguchi, M.: The design specifica- tion for Syracuse; a multi-junction concentrator system computer model. In: Proceedings of the 19th European Photovoltaic Solar Energy Conference, pp. 1–4 (2004)Depletion approximation
=======================

- Example: :doc:`Traditional GaInP/InGaAs/Ge solar cell <../Examples/example_3J_with_DA_solver>`

The depletion approximation provides an analytical - or semi-analytical
- solution to the Poisson-drift-diffusion equations described in the
previous section applied to simple PN homojunction solar cells.
Historically, it has been used extensively to model solar cells and it
is still valid, to a large extent, for traditional PN junctions. More
importantly, it requires less input parameters than the PDD solver and
these can be easily related to macroscopic measurable quantities, like
mobility or diffusion lengths. The DA model is based on the assumption
that around the junction between the P and N regions, there are no free
carriers and therefore all the electric field is due to the fixed,
ionized dopants. This “depletion” of free carriers reaches a certain
depth towards the N and P sides; beyond this region, free and fixed
carriers of opposite charges balance and the regions are neutral. Under
these conditions, Poisson’s equation decouples from the drift and
diffusion equations and it can be solved analytically for each region.
For example, for a PN junction with the interface between the two
regions at :math:`z=0`, the solution to Poisson's equation will be:

.. math::

   \phi(z) =
   \left\{
       \begin{array}{ll}
           0  & \mbox{if } z < -w_p \\
           \frac{qN_a}{2\epsilon_s}(z+w_p)^2  & \mbox{if } -w_p < z < 0 \\
           -\frac{qN_d}{2\epsilon_s}(z-w_n)^2 + V_{bi} & \mbox{if } 0 < z < w_n  \\
           V_{bi} & \mbox{if } w_n < z
       \end{array}
   \right.

where :math:`w_n` and :math:`w_p` are the extensions of the depletion
region towards the N and P sides, respectively, and can be found by the
requirement that the electric field :math:`F` and the potential
:math:`\phi` need to be continuous at :math:`z=0`. :math:`V_{bi}` is the
built-in voltage, which can be expressed in terms of the doping
concentration on each side, :math:`N_d` and :math:`N_a`, and the
intrinsic carrier concentration in the material, :math:`n_i^2`:

.. math:: V_{bi} = \frac{k_bT}{q} \ln \left(\frac{N_dN_a}{n_i^2} \right)

Another consequence of the depletion approximation is that the
quasi-Fermi level energies are constant throughout the corresponding
neutral regions and also constant in the depletion region, where their
separation is equal to the external bias :math:`qV`. Based on these
assumptions, the drift-diffusion equations
simplify and an analytical expression can be found for the dependence of
the recombination and generation currents on the applied voltage. A full
derivation of these expressions is included in
Nelson (2003) ([#Nelson2003]_).

Solcore’s implementation of the depletion approximation includes two
modifications to the basic equations. The first one is allowing for an
intrinsic region to be included between the P and N regions to form a
PIN junction. For low injection conditions (low illumination or low
bias) this situation can be treated as described before, simply
considering that the depletion region is now widened by the thickness of
the intrinsic region. Currently, no low doping level is allowed for this
region.

The second modification is related to the generation profile, which in
the equations provided by Nelson is given by the BL law
which has an explicit dependence on :math:`z` and results in analytic
expressions for the current densities. In Solcore, we integrate the
expressions for the drift-diffusion equations under the depletion
approximation numerically or by using the Green's function method to allow
for an arbitrary generation profile calculated with any of the :doc:`optical
solvers <../Optics/optics.rst>`. It should be noted that although the equations
are integrated numerically this will not be a self-consistent solution of the
Poisson-drift-diffusion equations, as is achieved by the PDD solver.

Detailed balance functions
--------------------------

.. automodule:: solcore.analytic_solar_cells.depletion_approximation
    :members:
    :undoc-members:

References
----------

.. [#Nelson2003] Nelson, J.: The Physics of Solar Cells. Imperial College Press, London; River Edge, NJ: Distributed by World Scientific Pub. Co, (2003)
Optical properties of materials
===============================

Solcore has several ways of accessing the optical properties of materials: databases and parametric dielectric functions.

.. toctree::
    :maxdepth: 2

    material_optics

Dielectric constants models and Adachi parametrization
------------------------------------------------------

Understanding the optical response of both established and novel
materials is crucial to effective solar cell design. To efficiently
model the complex dielectric function of a material Solcore incorporates
an optical constant calculator based on the well-known Critical-Point
Parabolic-Band (CPPB) formalism popularised by Adachi ([#Ref11]_, [#Ref12]_, [#Ref13]_). In this
model, contributions to *:math:`\epsilon_2(\omega)`* from critical
points in the Brillouin Zone at which the probability for optical
transitions is large (van Hove singularities) are considered. The
transition probability for such transitions is proportional to the joint
density of states (JDOS) :math:`\textbf{J}_{cv}(\omega)`, which
describes the number of available electronic states between the valence
and conduction bands at given photon energy. The imaginary part of the
complex dielectric function is related to the JDOS by:

.. math::

   \label{eqn:JDOS}
   \epsilon_2(\omega) = \frac{4 \hbar^2 e^2}{\pi \mu_{0}^{2} \omega^2} \left| \left \langle c | p | v \right \rangle \right|^2 \textbf{J}_{cv}(\omega)

Where :math:`\left| \left \langle c | p | v \right \rangle \right|` is
the momentum matrix element for transitions from the valence band
(:math:`v`) to the conduction band (:math:`c`). Critical point
transitions are considered at the following points of symmetry in the
band structure: *:math:`E_0`* corresponds to the optical transition at
the *:math:`\Gamma`* point and *:math:`E_0 + \Delta_0`* to the
transition from the spin-orbit split off band to the conduction band at
the *:math:`\Gamma`* point. *:math:`E_1`* and *:math:`E_1 + \Delta_1`*
denote the transitions from the valence heavy-hole (HH) band and the
valence light-hole (LH) band respectively to the conduction band at the
*L* point. The *:math:`E'_0`* triplet and *:math:`E_2`* transitions
occur at higher energies, between the HH band and the split conduction
bands at the :math:`\Gamma` point as well as across the wide gap *X*
valley. The model also includes contributions from the lowest energy
indirect band-gap transition and the exciton absorption at the
*:math:`E_0`* critical point. The contributions listed above are summed
to compute the overall value of :math:`\epsilon_2(\omega)`. The real and
imaginary components of the overall complex dielectric function
:math:`\epsilon(\omega) = \epsilon_1(\omega) - i\epsilon_2(\omega)` are
then related via the Kramers-Kronig relations;

.. math::

   \label{eqn:KKR_1}
       \epsilon_1(\omega) = 1 + \frac{2}{\pi} \int_{0}^{\infty} \frac{\omega' \epsilon_2(\omega')}{(\omega')^2 - \omega^2} d\omega'

.. math::

   \label{eqn:KKR_2}
       \epsilon_2(\omega) = - \frac{2}{\pi} \int_{0}^{\infty} \frac{\epsilon_1(\omega')}{(\omega')^2 - \omega^2} d\omega'

The CPPB model included with Solcore also incorporates a modification to
the critical point broadening present in Adachi’s description, which is
shown to produce a poor fit to experimental data in the vicinity of the
:math:`E_0` and :math:`E_1` critical points ([#Ref14]_). To give a more accurate description of
the broadening of the optical dielectric function, Kim et al. proposed
that a frequency-dependent damping parameter be used to replace the
damping constant given by Adachi at each critical point
([#Ref15]_, [#Ref16]_);

.. math::

   \label{eqn:Kim_damping}
       \Gamma'(\omega) = \Gamma exp \left[ -\alpha \left( \frac{\hbar \omega - E_0}{\Gamma}\right) ^2 \right]

Where :math:`\Gamma` is the damping constant used by Adachi and
:math:`\alpha` describes the shape of the lineshape broadening with
:math:`\alpha = 0` producing purely Lorentzian character and
:math:`\alpha = 0.3` producing a good approximation to Gaussian
broadening.

The Solcore module ``absorption_calculator`` contains the CPPB model
within the ``Custom_CPPB`` class. The class offers a flexible way to
build up the optical constant model by adding individual critical point
contributions through the *Oscillator* structure type within Solcore. In
addition to the oscillator functions described by Adachi the
``Custom_CPPB`` class also provides additional oscilator models and the
Sellmeier equation for describing the real part of the dielectric
function for non-absorbing materials ([#Ref17]_).

**Description of functions in this module**

.. automodule:: solcore.absorption_calculator.dielectric_constant_models
    :members:
    :undoc-members:

.. automodule:: solcore.absorption_calculator.adachi_alpha
    :members:
    :undoc-members:

SOPRA database
--------------

n order to calculate and model the optical response of potential solar
cell architectures and material systems, access to a library of accurate
optical constant data is essential. Therefore, Solcore incorporates a
resource of freely available optical constant data measured by Sopra S.
A. and provided by `Software Spectra Inc <http://www.sspectra.com/sopra.html>`_.
The refractive index :math:`n` and
extinction coefficient :math:`k` are provided for over 200 materials,
including many III-V, II-VI and group IV compounds in addition to a
range of common metals, glasses and dielectrics.

Any material within the Sopra S.A. optical constant database can be
used with the :doc:`“material” function <../Systems/Materials>`, but they will have
only the optical parameters :math:`n` and :math:`k`. In the case of
materials that are in both databases, the keyword “sopra” will need to
be set to “True” when creating the material. Once a material is loaded
its :math:`n`, :math:`k` and absorption coefficient data is returned by
calling the appropriate method, for example ``SiO2.n(wavelength)`` and
``SiO2.k(wavelength)``. For certain materials in the database, the
optical constants are provided for a range of alloy compositions. In
these cases, any desired composition within the range can be specified
and the interpolated :math:`n` and :math:`k` data is returned.

.. automodule:: solcore.absorption_calculator.sopra_db
    :members:
	
Manually changing optical constants of a material
------------------------------------------------------

If you would like to define a material with optical constant data from a file, 
you can do this by telling Solcore the path to the optical constant data, e.g.:

.. code-block:: python

    this_dir = os.path.split(__file__)[0]

    SiGeSn = material('Ge')(T=T, electron_mobility=0.05, hole_mobility=3.4e-3)

    SiGeSn.n_path = this_dir + '/SiGeSn_n.txt'
    SiGeSn.k_path = this_dir + '/SiGeSn_k.txt'
	
In this case, we have defined a material which is like the built-in Solcore germanium
material, but with new data for the refractive index and extinction coefficient from 
the files SiGeSn_n.txt and SiGeSn_k.txt, respectively, which are in the same folder 
as the Python script. The format of these files is tab-separated, with the first column
being wavelength (in nm) and the second column n or k. 

References
----------

.. [#Ref11] Adachi, S.: Model dielectric constants of GaP, GaAs, GaSb, InP, InAs, and InSb. Phys. Rev. B 35(14), 7454–7463 (1987)
.. [#Ref12] Adachi, S.: Optical dispersion relations for GaP, GaAs, GaSb, InP, InAs, InSb, Alx Ga1−x As, and In1−x Gax Asy P1−y . J. Appl. Phys. 66(12), 6030–6040 (1989)
.. [#Ref13] Adachi, S.: Optical dispersion relations for Si and Ge. J. Appl. Phys. 66(7), 3224–3231 (1989)
.. [#Ref14] Rakic ́, A.D., Majewski, M.L.: Modeling the optical dielectric func- tion of GaAs and AlAs: extension of Adachi’s model. J. Appl. Phys. 80(10), 5909–5914 (1996)
.. [#Ref15] Kim, C.C., Garland, J.W., Abad, H., Raccah, P.M.: Modeling the optical dielectric function of semiconductors: extension of the critical-point parabolic-band approximation. Phys. Rev. B 45(20), 11 749–11 767 (1992)
.. [#Ref16] Kim, C.C., Garland, J.W., Raccah, P.M.: Modeling the optical dielectric function of the alloy system AlxGa1-xAs. Phys. Rev. B 47(4), 1876–1888 (1993)
.. [#Ref17] Woollam, J.A.: Guide to using WVASE 32: spectroscopic ellipsometry data acquisition and analysis software. J. A. Woollam Company (2008). `https://books.google.co.uk/books? id=xOupYgEACAAJ`_Rigorous Coupled Wave Analysis (S4)
=====================================

Example 1: :doc:`Comparing optical models (TMM, Beer-Lambert, and RCWA) <../Examples/example_optics_comparison>`

Solcore’s capacity for modelling periodic nanophotonic structures is provided through an interface with the :math:`S^4` Python extension,
an implementation of RCWA (Rigorous Coupled Wave Analysis) developed in the Fan Group in the Stanford Electrical Engineering Department.
The documentation for S4 can be found here_. The basic mechanics of the RCWA module are:


* Solcore translates the relevant inputs (list) into the appropriate notation for :math:`S^4`
* Solcore calls :math:`S^4` and feeds in the relevant inputs
* Solcore translates the outputs from :math:`S^4` into the relevant outputs, which match the outputs from Solcore’s other optics methods (absorption, reflection, transmission, absorption profile with depth).

To use :math:`S^4` from within Solcore, first `make sure S4 is installed from the custom branch compatible with Python3 <https://https://github.com/phoebe-p/S4>`_.
:literal:`Layers` in the :literal:`SolarCell` object are defined in the usual Solcore way, but now have an additional :literal:`geometry` attribute, e.g.:



.. code-block:: Python

    # define materials
    Air = material('Air')(T=T)
    TiO2 = material('TiO2', sopra=True)(T=T)  # for the nanoparticles
    # define a layer with circular discs
    NP_layer = [Layer(si('50nm'), Air, geometry=[{'type': 'circle', 'mat': TiO2,
                    'center': (200, 200), 'radius': 50}])]

The :literal:`geometry` attribute is a **list of dictionaries** containing relevant entries. You can add more than one shape
per layer by simply adding more dictionaries to the list; each dictionary defines one shape, which is assumed to be periodic
in two directions. The necessary information to define shapes is:

For all shapes:

* ‘type’: 'circle', 'ellipse', 'rectangle' or 'polygon'
* ‘mat’: the material the shape is made of; a Solcore material object.
* ‘center’: a tuple giving x and y coordinates (in nm) of the centre of the shape: `(x, y)`

Additional shape-dependent parameters:

* Circle:
  * 'radius': a number in nm


* Ellipse:
  * ‘angle’: a number in degrees, defining the angle by which the x-axis of the shape should be rotated (counter-clockwise).
  * ‘halfwidths’: a tuple of halfwidths in the *x* and *y* directions: `(hw_x, hw_y)`
  
* Rectangle: ‘angle’ and ‘halfwidths’, as before

* Polygon:
  * ‘angle’ as before
  * ‘vertices’: a tuple of tuples; each entry in the outer tuple are the x- and y-coordinates of the vertices of the (unrotated) polygon, one after another, in counter-clockwise order, e.g. `((x1, y1), (x2, y2), (x3, y3))`. Coordinates are in nm.

Additionally, you should set the lattice vectors u and v defining the unit cell in your user options, and the number of Fourier orders to keep in the calculations in `opts.orders`:

.. code-block:: Python

    opts.size = ((400, 0), (0, 400)) # lattice vectors for a square grating with period 400 nm
    opts.size = ((400, 0), (400 / 2, np.sin(np.pi / 3) * 400))
    # lattice vectors for a grating with hexagonal symmetry (triangular unit cell)

    opts.orders = 19 # keep 19 Fourier orders

The calculation should converge for a higher number of orders, but computational time increases dramatically with the number of orders (scaled as the
number of orders cubed).

Note that **all dimensional information for the size and geometries should be in nm**!


The RCWA interface for the solar cell solver
--------------------------------------------

This is the method actually called from the solar cell solver, serving as interface between the solar cell and the RCWA formalism.
The :doc:`Beer-Lambert calculator <other_methods>`, :doc:`TMM calculator <tmm>` and the :doc:`external optics calculator <other_methods>`
(where the user simply adds the reflection and the absorption profile manually) have similar interfaces.

The RCWA solver can handle different input angles and polarizations, specified in the options (specifically, options.theta,
options.phi and options.pol). Theta is the polar angle while phi is the azimuthal angle clockwise from the y-axis. Both
angles are in degrees, while pol is 's', 'p'  or 'u' (computationally, 'u' is simply the average of 's' and 'p' and thus requires
two calculations - therefore it will take twice as long.)


.. automodule:: solcore.optics.rcwa
    :members:
    :undoc-members:

Implementation of RCWA optical methods
---------------------------------------

.. automodule:: solcore.absorption_calculator.rigorous_coupled_wave
    :members:
    :undoc-members:



.. _here: http://web.stanford.edu/group/fan/S4/
Transfer matrix method
======================

Example 1: :doc:`Using the TMM solver to calculate the reflextion of a multilayered ARC <../Examples/example_RAT_of_ARC>`

Example 2: :doc:`Looking at the effect of substrate and the no_back_reflection option in the TMM solver <../Examples/substrate_example>`

Example 3: :doc:`Coherent and incoherent layers in the TMM solver<../Examples/example_coherency>`


.. toctree::
    :maxdepth: 2

    tmm
	

The TMM interface for the solar cell solver
-------------------------------------------

This is the method actually called from the solar cell solver, serving as interface between the solar cell and the lower level TMM formalism. 
The :doc:`Beer-Lambert calculator <other_methods>`, the :doc:`RCWA calculator <S4doc>` and the :doc:`external optics calculator <other_methods>` 
(where the user simply adds the reflection and the absorption profile manually) have similar interfaces.

The TMM solver can handle different input angles and polarizations, specified in the options (specifically, options.theta and options.pol).
The input angle is in degrees, while pol is 's', 'p'  or 'u' (computationally, 'u' is simply the average of 's' and 'p' and thus requires
two calculations.)

Using the default options, all layers (except very thick layers, with the layer thickness more than 10 times the maximum incident wavelength)
will be considered as coherent, i.e. phase information in the wave-optical calculation is retained. However, layers can also be specified to be
incoherent using a coherency_list option with one entry (either 'c' or 'i') per layer. 

.. automodule:: solcore.optics.tmm
    :members:
    :undoc-members:

The OptiStack and the high level TMM optical methods
-----------------------------------------------------

.. automodule:: solcore.absorption_calculator.transfer_matrix
    :members:
    :undoc-members:

Transfer matrix engine
----------------------

.. automodule:: solcore.absorption_calculator.tmm_core_vec
    :members:
    :undoc-members:
Other optical methods
=====================

Finally, the optical properties of the solar cell can be defined with a simple Beer-Lambert formalism and also provided externally by the user. These section describe the methods that are called internally by the solar cell solver in these two cases.

.. toctree::
    :maxdepth: 2

    other_methods

Beer-Lambert law
----------------

.. automodule:: solcore.optics.beer_lambert
    :members:
    :undoc-members:

External optics
---------------

.. automodule:: solcore.optics.external_optics
    :members:
    :undoc-members:
Absorption of quantum wells
===========================

For modelling the optical properties of QWs we use the method described
by S. Chuang ([#Ref18]_). The absorption
coefficient at thermal equilibrium in a QW is given by:

.. math::

   \label{eq:QW_abs2}
   \begin{split}
   \alpha_0(E) & = C_0(E) \sum_{n,m} |I_{hm}^{en}|^2 | \hat{e} \cdot \vec{p} |^2 \rho_{rmn}^{2D} \\
   & \times \left[ H(E-E^{en} + E_{hm}) + F_{nm}(E) \right]
   \end{split}

where :math:`|I_{hm}^{en}|^2` is the overlap integral between the holes
in level :math:`m` and the electrons in level :math:`n`; :math:`H` is a
step function, :math:`H(x)` = 1 for :math:`x>0`, 0 and 0 for
:math:`x<0`, :math:`\rho_{rmn}^{2D}` is the 2D joint density of states,
:math:`C_0` a proportionality constant dependent on the energy, and
:math:`F` the excitonic contribution, which will be discussed later.

.. math::

   \begin{aligned}
   \label{eq:qw_abs}
   C_0 (E) & =    \frac{\pi q^2 \hbar }{n_r c \epsilon_0 m_0^2 E} \\
   \rho_r^{2D} &= \frac{m_{rmn}^*}{\pi \hbar L}\end{aligned}

Here, :math:`n_r` is the refractive index of the material,
:math:`m_{rmn} = m_{en} m_{hm} / (m_{en} + m_{hm})` the reduced,
in-plane, effective mass and :math:`L` an effective period of the
quantum wells. The in-plane effective mass of each type of carriers is
calculated for each level, accounting for the spread of the wavefunction
into the barriers as ([#Ref19]_):

.. math::

   \begin{aligned}
   \label{eq:in_plane}
   m_{\perp} =  \int_{0}^{L} m(z) | \psi(z) |^2\end{aligned}

This in-plane effective mass is also used to calculate the local density
of states shown in Figure [fig:qw]b. In Eq. [eq:QW\_abs2],
:math:`| \hat{e} \cdot \vec{p} |^2` is the momentum matrix element,
which depends on the polarization of the light and on the Kane’s energy
:math:`E_p`, specific to each material and determined experimentally.
For band edge absorption, where :math:`k` = 0, the matrix elements for
the absorption of TE and TM polarized light for the transitions
involving the conduction band and the heavy and light holes bands are
given in Table [tab:matrix\_elements]. As can be deduced from this
table, transitions involving heavy holes cannot absorb TM polarised
light.

+----------------+---------------------+-------------------+
|                | TE                  | TM                |
+================+=====================+===================+
| :math:`c-hh`   | :math:`3/2 M_b^2`   | 0                 |
+----------------+---------------------+-------------------+
| :math:`c-lh`   | :math:`1/2 M_b^2`   | :math:`2 M_b^2`   |
+----------------+---------------------+-------------------+

Table: Momentum matrix elements for transitions in QWs.
:math:`M_b^2=m_0 E_p /6` is the bulk matrix element.

In addition to the band-to-band transitions, QWs usually have strong
excitonic absorption, included in Eq. [eq:qw\_abs] in the term
:math:`F_{nm}`. This term is a Lorenzian (or Gaussian) defined by an
energy :math:`E_{nmx, j}` and oscillator strength :math:`f_{ex, j}`. It
is zero except for :math:`m=n \equiv j` where it is given by Klipstein
et al. ([#Ref20]_):

.. math::

   \begin{aligned}
   F_{nm} &= f_{ex, j} \mathcal{L}(E - E_{nmx, j}, \sigma) \\
   E_{nmx, j} &= E^{en} - E_{hm} - \frac{R}{(j-\nu)^2} \\
   f_{ex, j} &= \frac{2R}{(j-\nu)^3} \\
   R &= \frac{m_r q^4}{2 ( 4\pi \epsilon_r \epsilon_0)^2 \hbar^2 }\end{aligned}

Here, :math:`\nu` is a constant with a value between 0 and 0.5 and
:math:`\sigma` is the width of the Lorentzian, both often adjusted to
fit some experimental data. In Solcore, they have default values of
:math:`\nu` = 0.15 and :math:`\sigma` = 6 meV. :math:`R` is the exciton
Rydberg energy ([#Ref18]_).

Fig. [fig:QW\_absorption] shows the absorption coefficient of a range of
InGaAs/GaAsP QWs with a GaAs interlayer and different In content. Higher
indium content increases the depth of the well, allowing the absorption
of less energetic light and more transitions.

.. image:: qw_absorption.png
    :align: center


.. automodule:: solcore.absorption_calculator.absorption_QW
    :members:

References
----------

.. [#Ref18] Chuang, S.L.: Physics of Optoelectronic Devices. Wiley- Interscience, New York (1995)
.. [#Ref19] Barnham, K., Vvedensky, D. (eds.): Low-Dimensional Semi- conductor Structures: Fundamentals and Device Applications. Cambridge University Press, Cambridge (2001)
.. [#Ref20] Klipstein, P.C., Apsley, N.: A theory for the electroreflectance spec- tra of quantum well structures. J. Phys. C Solid State Phys. 19(32), 6461–6478 (2000)Optical methods
===============

Solcore includes several methods to calculate the optical properties of individual materials and of full stacks of layers. Some of them are built in, but it can also deal with externally provided data and, currently, it has also an interface to **S4** to perform rigorous couple wave analysis calculations.

.. toctree::
    :maxdepth: 2

    material_optics
    qw_absorption
    tmm
    rcwa
    other_methods

