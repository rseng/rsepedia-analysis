About the Copyright Holders
===========================

*   Copyright (c) 2013, Sandia National Laboratories

    Sandia National Laboratories developed pvlib python based on code in
    PVLib MATLAB.

*   Copyright (c) 2014-2018, pvlib python Development Team

    The pvlib python Development Team is the collection of developers of the
    pvlib python project.

Full credits for pvlib python contributors can be found in the documentation.

Our Copyright Policy
====================

pvlib python uses a shared copyright model. Each contributor maintains copyright
over their contributions to pvlib python. However, it is important to note that
these contributions are typically only changes to the repositories. Thus,
the pvlib python source code, in its entirety, is not the copyright of any single
person or institution. Instead, it is the collective copyright of the
entire pvlib python Development Team. If individual contributors want to maintain
a record of what changes/contributions they have specific copyright on,
they should indicate their copyright in the commit message of the change
when they commit the change to the pvlib python repository.

License
=======

pvlib python is distributed under a 3-clause BSD license.
<img src="docs/sphinx/source/_images/pvlib_logo_horiz.png" width="600">

<table>
<tr>
  <td>Latest Release</td>
  <td>
    <a href="https://pypi.org/project/pvlib/">
    <img src="https://img.shields.io/pypi/v/pvlib.svg" alt="latest release" />
    </a>
    <a href="https://anaconda.org/conda-forge/pvlib-python">
    <img src="https://anaconda.org/conda-forge/pvlib-python/badges/version.svg" />
    </a>
    <a href="https://anaconda.org/conda-forge/pvlib-python">
    <img src="https://anaconda.org/conda-forge/pvlib-python/badges/latest_release_date.svg" />
    </a>
</tr>
<tr>
  <td>License</td>
  <td>
    <a href="https://github.com/pvlib/pvlib-python/blob/master/LICENSE">
    <img src="https://img.shields.io/pypi/l/pvlib.svg" alt="license" />
    </a>
</td>
</tr>
<tr>
  <td>Build Status</td>
  <td>
    <a href="http://pvlib-python.readthedocs.org/en/stable/">
    <img src="https://readthedocs.org/projects/pvlib-python/badge/?version=stable" alt="documentation build status" />
    </a>
    <a href="https://dev.azure.com/solararbiter/pvlib%20python/_build/latest?definitionId=4&branchName=master">
      <img src="https://dev.azure.com/solararbiter/pvlib%20python/_apis/build/status/pvlib.pvlib-python?branchName=master" alt="Azure Pipelines build status" />
    </a>
  </td>
</tr>
<tr>
  <td>Code Quality</td>
  <td>
    <a href="https://lgtm.com/projects/g/pvlib/pvlib-python/context:python">
    <img src="https://img.shields.io/lgtm/grade/python/g/pvlib/pvlib-python.svg?logo=lgtm&logoWidth=18" alt="lgtm quality grade" />
    </a>
    <a href="https://lgtm.com/projects/g/pvlib/pvlib-python/alerts">
    <img src="https://img.shields.io/lgtm/alerts/g/pvlib/pvlib-python.svg?logo=lgtm&logoWidth=18" alt="lgtm alters" />
    </a>
  </td>
</tr>
<tr>
  <td>Coverage</td>
  <td>
    <a href="https://coveralls.io/r/pvlib/pvlib-python">
    <img src="https://img.shields.io/coveralls/pvlib/pvlib-python.svg" alt="coveralls coverage" />
    </a>
    <a href="https://codecov.io/gh/pvlib/pvlib-python">
    <img src="https://codecov.io/gh/pvlib/pvlib-python/branch/master/graph/badge.svg" alt="codecov coverage" />
    </a>
  </td>
</tr>
<tr>
  <td>Publications</td>
  <td>
    <a href="https://doi.org/10.5281/zenodo.3762635">
    <img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3762635.svg" alt="zenodo reference">
    </a>
    <a href="http://joss.theoj.org/papers/41187535cad22dd4b076c89b72f874b1">
    <img src="http://joss.theoj.org/papers/41187535cad22dd4b076c89b72f874b1/status.svg" alt="JOSS reference" />
    </a>
  </td>
</tr>
<tr>
  <td>Downloads</td>
  <td>
    <a href="https://pypi.org/project/pvlib/">
    <img src="https://img.shields.io/pypi/dm/pvlib" alt="PyPI downloads" />
    </a>
    <a href="https://anaconda.org/conda-forge/pvlib-python">
    <img src="https://anaconda.org/conda-forge/pvlib-python/badges/downloads.svg" alt="conda-forge downloads" />
    </a>
  </td>
</tr>
</table>


pvlib python is a community supported tool that provides a set of
functions and classes for simulating the performance of photovoltaic
energy systems. pvlib python was originally ported from the PVLIB MATLAB
toolbox developed at Sandia National Laboratories and it implements many
of the models and methods developed at the Labs. More information on
Sandia Labs PV performance modeling programs can be found at
https://pvpmc.sandia.gov/. We collaborate with the PVLIB MATLAB project,
but operate independently of it.


Documentation
=============

Full documentation can be found at [readthedocs](http://pvlib-python.readthedocs.io/en/stable/).


Installation
============

pvlib-python releases may be installed using the ``pip`` and ``conda`` tools.
Please see the [Installation page](http://pvlib-python.readthedocs.io/en/stable/installation.html) of the documentation for complete instructions.


Contributing
============

We need your help to make pvlib-python a great tool!
Please see the [Contributing page](http://pvlib-python.readthedocs.io/en/stable/contributing.html) for more on how you can contribute.
The long-term success of pvlib-python requires substantial community support.


Citing
======

If you use pvlib-python in a published work, please cite:

  William F. Holmgren, Clifford W. Hansen, and Mark A. Mikofski.
  "pvlib python: a python package for modeling solar energy systems."
  Journal of Open Source Software, 3(29), 884, (2018).
  https://doi.org/10.21105/joss.00884

Please also cite the DOI corresponding to the specific version of
pvlib-python that you used. pvlib-python DOIs are listed at
[Zenodo.org](https://zenodo.org/search?page=1&size=20&q=conceptrecid:593284&all_versions&sort=-version)

If you use pvlib-python in a commercial or publicly-available application, please
consider displaying one of the "powered by pvlib" logos:

<img src="docs/sphinx/source/_images/pvlib_powered_logo_vert.png" width="300"><img src="docs/sphinx/source/_images/pvlib_powered_logo_horiz.png" width="300">

Getting support
===============

pvlib usage questions can be asked on
[Stack Overflow](http://stackoverflow.com) and tagged with
the [pvlib](http://stackoverflow.com/questions/tagged/pvlib) tag.

The [pvlib-python google group](https://groups.google.com/forum/#!forum/pvlib-python)
is used for discussing various topics of interest to the pvlib-python
community. We also make new version announcements on the google group.

If you suspect that you may have discovered a bug or if you'd like to
change something about pvlib, then please make an issue on our
[GitHub issues page](https://github.com/pvlib/pvlib-python/issues).



License
=======

BSD 3-clause.


NumFOCUS
========

pvlib python is a [NumFOCUS Affiliated Project](https://numfocus.org/sponsored-projects/affiliated-projects)

[![NumFocus Affliated Projects](https://i0.wp.com/numfocus.org/wp-content/uploads/2019/06/AffiliatedProject.png)](https://numfocus.org/sponsored-projects/affiliated-projects)
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at pvlib-admin@googlegroups.com, which
will forward your email to holmgren@email.arizona.edu, cwhanse@sandia.gov, and
mikofski@berkeley.edu, or you can email an individual directly if you prefer. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq
---
title: 'pvlib python: a python package for modeling solar energy systems'
tags:
  - Python
  - solar energy
  - photovoltaics
  - renewable energy
authors:
  - name: William F. Holmgren
    orcid: 0000-0001-6218-9767
    affiliation: 1
  - name: Clifford W. Hansen
    orcid: 0000-0002-8620-5378
    affiliation: 2
  - name: Mark A. Mikofski
    orcid: 0000-0001-8001-8582
    affiliation: 3
affiliations:
 - name: Department of Hydrology and Atmospheric Sciences, University of Arizona
   index: 1
 - name: Sandia National Laboratories
   index: 2
 - name: DNV-GL
   index: 3
date: 2 August 2018
bibliography: paper.bib
---

# Summary

pvlib python is a community-supported open source tool that provides a
set of functions and classes for simulating the performance of
photovoltaic energy systems. pvlib python aims to provide reference
implementations of models relevant to solar energy, including for
example algorithms for solar position, clear sky irradiance, irradiance
transposition, DC power, and DC-to-AC power conversion. pvlib python is
an important component of a growing ecosystem of open source tools for
solar energy [@Holmgren2018].

pvlib python is developed on GitHub by contributors from academia,
national laboratories, and private industry. pvlib python is released
with a BSD 3-clause license allowing permissive use with attribution.
pvlib python is extensively tested for functional and algorithm
consistency. Continuous integration services check each pull request on
multiple platforms and Python versions. The pvlib python API is
thoroughly documented and detailed tutorials are provided for many
features. The documentation includes help for installation and
guidelines for contributions. The documentation is hosted at
readthedocs.org as of this writing. A Google group and StackOverflow tag
provide venues for user discussion and help.

The pvlib python API was designed to serve the various needs of the many
subfields of solar power research and engineering. It is implemented in
three layers: core functions, the ``Location`` and ``PVSystem`` classes,
and the ``ModelChain`` class. The core API consists of a collection of
functions that implement algorithms. These algorithms are typically
implementations of models described in peer-reviewed publications. The
functions provide maximum user flexibility, however many of the function
arguments require an unwieldy number of parameters. The next API level
contains the ``Location`` and ``PVSystem`` classes. These abstractions
provide simple methods that wrap the core function API layer. The method
API simplification is achieved by separating the data that represents
the object (object attributes) from the data that the object methods
operate on (method arguments). For example, a ``Location`` is
represented by a latitude, longitude, elevation, timezone, and name,
which are ``Location`` object attributes. Then a ``Location`` object
method operates on a ``datetime`` to get the corresponding solar
position. The methods combine these data sources when calling the
function layer, then return the results to the user. The final level of
API is the ``ModelChain`` class, designed to simplify and standardize
the process of stitching together the many modeling steps necessary to
convert a time series of weather data to AC solar power generation,
given a PV system and a location.

pvlib python was ported from the PVLib MATLAB toolbox in 2014
[@Stein2012, @Andrews2014]. Efforts to make the project more pythonic
were undertaken in 2015 [@Holmgren2015]. Additional features continue to
be added, see, for example [@Stein2016, @Holmgren2016] and the
documentation's "What's New" section.

pvlib python has been used in numerous studies, for example, of solar
power forecasting [@Gagne2017, @Holmgren2017], development of solar
irradiance models [@Polo2016], and estimation of photovoltaic energy
potential [@Louwen2017]. Mikofski et. al. used pvlib python to study
the accuracy of clear sky models with different aerosol optical depth
and precipitable water data sources [@Mikofski2017] and to determine the
effects of spectral mismatch on different PV devices [@Mikofski2016].
pvlib python is a foundational piece of an award, "An Open Source
Evaluation Framework for Solar Forecasting," made under the Department
of Energy Solar Forecasting 2 program [@DOESF2].

Plans for pvlib python development includes the implementation of new
and existing models, addition of functionality to assist with
input/output, and improvements to API consistency.

The source code for each pvlib python version is archived with Zenodo
[@pvlibZenodo].

# Acknowledgements

The authors acknowledge and thank the code, documentation, and
discussion contributors to the project.

WH acknowledges support from the Department of Energy's Energy
Efficiency and Renewable Energy Postdoctoral Fellowship Program
(2014-2016), Tucson Electric Power, Arizona Public Service, and Public
Service Company of New Mexico (2016-2018), and University of Arizona
Institute for Energy Solutions (2017-2018).

CH acknowledges support from the U.S. Department of Energy's Solar
Energy Technology Office.

WH and CH acknowledge support from the Department of Energy Solar
Forecasting 2 program.

MM acknowledges support from SunPower Corporation (2016-2017).

Sandia National Laboratories is a multi-mission laboratory managed and
operated by National Technology and Engineering Solutions of Sandia,
LLC., a wholly owned subsidiary of Honeywell International, Inc., for
the U.S. Department of Energy's National Nuclear Security Administration
under contract DE-NA-0003525.

# References
Contributing
============

We welcome your contributions! Please see the [contributing](http://pvlib-python.readthedocs.io/en/latest/contributing.html) page for information about how to contribute.
<!-- Thank you for your contribution! The following items must be addressed before the code can be merged. Please don't hesitate to ask for help if you're unsure of how to accomplish any of the items. Feel free to remove checklist items that are not relevant to your change. -->

 - [ ] Closes #xxxx
 - [ ] I am familiar with the [contributing guidelines](https://pvlib-python.readthedocs.io/en/latest/contributing.html)
 - [ ] Tests added
 - [ ] Updates entries to [`docs/sphinx/source/api.rst`](https://github.com/pvlib/pvlib-python/blob/master/docs/sphinx/source/api.rst) for API changes.
 - [ ] Adds description and name entries in the appropriate "what's new" file in [`docs/sphinx/source/whatsnew`](https://github.com/pvlib/pvlib-python/tree/master/docs/sphinx/source/whatsnew) for all changes. Includes link to the GitHub Issue with `` :issue:`num` `` or this Pull Request with `` :pull:`num` ``. Includes contributor name and/or GitHub username (link with `` :ghuser:`user` ``).
 - [ ] New code is fully documented. Includes [numpydoc](https://numpydoc.readthedocs.io/en/latest/format.html) compliant docstrings, examples, and comments where necessary.
 - [ ] Pull request is nearly complete and ready for detailed review.
 - [ ] Maintainer: Appropriate GitHub Labels and Milestone are assigned to the Pull Request and linked Issue.

<!-- Brief description of the problem and proposed solution (if not already fully described in the issue linked to above): -->
---
name: Support question
about: If you have a support or usage question, please see the pvlib stack overflow
  tag or the pvlib-python google group

---

pvlib usage questions can be asked on [Stack Overflow](http://stackoverflow.com) and tagged with the [pvlib](http://stackoverflow.com/questions/tagged/pvlib) tag.

The [pvlib-python google group](https://groups.google.com/forum/#!forum/pvlib-python) is used for discussing various topics of interest to the pvlib-python community. We also make new version announcements on the google group.
---
name: Bug report
about: Create a report to help us improve

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Versions:**
 - ``pvlib.__version__``: 
 - ``pandas.__version__``: 
 - python:

**Additional context**
Add any other context about the problem here.
---
name: Feature request
about: Suggest an idea for this project

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
# NOTICE

Copyright (c) 2008-2011 Alliance for Sustainable Energy, LLC, All Rights Reserved

The Solar Position Algorithm ("Software") is code in development prepared by 
employees of the Alliance for Sustainable Energy, LLC, (hereinafter the 
"Contractor"), under Contract No. DE-AC36-08GO28308 ("Contract") with the 
U.S. Department of Energy (the "DOE"). The United States Government has been 
granted for itself and others acting on its behalf a paid-up, non-exclusive, 
irrevocable, worldwide license in the Software to reproduce, prepare 
derivative works, and perform publicly and display publicly. Beginning five 
(5) years after the date permission to assert copyright is obtained from the 
DOE, and subject to any subsequent five (5) year renewals, the United States 
Government is granted for itself and others acting on its behalf a paid-up, 
non-exclusive, irrevocable, worldwide license in the Software to reproduce, 
prepare derivative works, distribute copies to the public, perform publicly 
and display publicly, and to permit others to do so. If the Contractor ceases 
to make this computer software available, it may be obtained from DOE's 
Office of Scientific and Technical Information's Energy Science and 
Technology Software Center (ESTSC) at P.O. Box 1020, Oak Ridge, TN 
37831-1020. THIS SOFTWARE IS PROVIDED BY THE CONTRACTOR "AS IS" AND ANY 
EXPRESS OR IMPLIED WARRANTIES, INCLUDING BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE CONTRACTOR OR THE U.S. GOVERNMENT BE LIABLE 
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER, 
INCLUDING BUT NOT LIMITED TO CLAIMS ASSOCIATED WITH THE LOSS OF DATA OR 
PROFITS, WHICH MAY RESULT FROM AN ACTION IN CONTRACT, NEGLIGENCE OR OTHER 
TORTIOUS CLAIM THAT ARISES OUT OF OR IN CONNECTION WITH THE ACCESS, USE OR 
PERFORMANCE OF THIS SOFTWARE.

The Software is being provided for internal, noncommercial purposes only and 
shall not be re-distributed. Please contact [Jean 
Schulte](mailto:Jean.Schulte@nrel.gov) in the NREL Commercialization and 
Technology Transfer Office for information concerning a commercial license to 
use the Software.

As a condition of using the Software in an application, the developer of the 
application agrees to reference the use of the Software and make this Notice 
readily accessible to any end-user in a Help|About screen or equivalent manner.
README
------

NREL provides a C implementation of the solar position algorithm described in
[Reda, I.; Andreas, A. (2003). Solar Position Algorithm for Solar Radiation Applications. 55 pp.; NREL Report No. TP-560-34302](http://www.nrel.gov/docs/fy08osti/34302.pdf).

This folder contains the files required to make SPA C code accessible
to the `pvlib-python` package. We use the Cython package to wrap the NREL SPA 
implementation. 

** Due to licensing issues, the SPA C files can _not_ be distributed with
`pvlib-python`. You must download the SPA C files from the
[NREL website](https://midcdmz.nrel.gov/spa/). **

Download the `spa.c` and `spa.h` files from NREL,  and copy them into the
`pvlib/spa_c_files` directory. When the extension is built, the ``timezone``
field in the SPA C files is replaced with `time_zone` to avoid a nameclash
with the function `__timezone` that is redefined by Python>=3.5. This issue
is [Python bug 24643](https://bugs.python.org/issue24643).

There are a total of 5 files needed to compile the C code, described below:

* `spa.c`: original C code from NREL 
* `spa.h`: header file for spa.c
* `cspa_py.pxd`: a cython header file which essentially tells cython which
  parts of the main header file to pay attention to
* `spa_py.pyx`: the cython code used to define both functions in the python
  namespace. NOTE: It is possible to provide user access to other paramters of
  the SPA algorithm through modifying this file 
* `setup.py`: a distutils file which performs the compiling of the cython code

The cython compilation process produces two files:
* `spa_py.c`: an intermediate cython c file
* `spa_py.so` or `spa_py.<cpyver-plat>.pyd`: the python module which
  can be imported into a namespace

To create the SPA Python extension, use the following shell command inside this
folder:

    $ python setup.py build_ext --inplace

There are four optional keyword arguments `delta_ut1=0`, `slope=30.0`,
`azm_rotation=-10`, `atmos_refract` that effect four optional return values
`incidence`, `suntransit`, `sunrise`, and `sunset`. If not given, the defaults
shown are used.

There is an example in `spa_py_example.py` that contains a test function called
`spa_calc_example` that users can use to check that the result is consistent
with expected values:

    >>> from spa_py_example import spa_calc_example
    >>> r = spa_calc_example()
    {
        'year': 2004,
        'month': 10,
        'day': 17,
        'hour': 12,
        'minute': 30,
        'second': 30.0,
        'delta_ut1': 0.0,
        'delta_t': 67.0,
        'time_zone': -7.0,
        'longitude': -105.1786,
        'latitude': 39.742476,
        'elevation': 1830.14,
        'pressure': 820.0,
        'temperature': 11.0,
        'slope': 30.0,
        'azm_rotation': -10.0,
        'atmos_refract': 0.5667,
        'function': 3,
        'e0': 39.59209464796398,
        'e': 39.60858878898177,
        'zenith': 50.39141121101823,
        'azimuth_astro': 14.311961805946808,
        'azimuth': 194.3119618059468,
        'incidence': 25.42168493680471,
        'suntransit': 11.765833793714224,
        'sunrise': 6.22578372122376,
        'sunset': 17.320379610556166
    }
Benchmarks
==========

pvlib includes a small number of performance benchmarking tests. These
tests are run using
[airspeed velocity](https://asv.readthedocs.io/en/stable/) (ASV).

The basic structure of the tests and how to run them is described below.
We refer readers to the ASV documentation for more details. The AstroPy
[documentation](https://github.com/astropy/astropy-benchmarks/tree/master)
may also be helpful.

The test configuration is described in [asv.conf.json](asv.conf.json).
The performance tests are located in the [benchmarks](benchmarks) directory.

Comparing timings
-----------------

Note that, unlike pytest, the asv tests require changes to be committed
to git before they can be tested. The ``run`` command takes a positional
argument to describe the range of git commits or branches to be tested.
For example, if your feature branch is named ``feature``, a useful asv
run may be (from the same directory as `asv.conf.json`):

```
$ asv run master..feature
```

This will generate timings for every commit between the two specified
revisions. If you only care about certain commits, you can run them by
their git hashes directly like this:

```
$ asv run e42f8d24^!
```

Note: depending on what shell they use, Windows users may need to use
double-carets:

```
$ asv run e42f8d24^^!
```

You can then compare the timing results of two commits:

```
$ asv compare 0ff98b62 e42f8d24

All benchmarks:

       before           after         ratio
     [0ff98b62]       [e42f8d24]
     <asv_setup~1>       <asv_setup>
+      3.90±0.6ms         31.3±5ms     8.03  irradiance.Irradiance.time_aoi
       3.12±0.4ms       2.94±0.2ms     0.94  irradiance.Irradiance.time_aoi_projection
          256±9ms         267±10ms     1.05  irradiance.Irradiance.time_dirindex
```

The `ratio` column shows the ratio of `after / before` timings. For this
example, the `aoi` function was slowed down on purpose to demonstrate
the comparison.

Generating an HTML report
-------------------------

asv can generate a collection of interactive plots of benchmark timings across
a commit history. First, generate timings for a series of commits, like:

```
$ asv run v0.6.0..v0.8.0
```

Next, generate the HTML report:

```
$ asv publish
```

Finally, start a http server to view the test results:

```
$ asv preview

```


Nightly benchmarking
--------------------

The benchmarks are run nightly for new commits to pvlib-python/master.

- Timing results: https://pvlib-benchmarker.github.io/pvlib-benchmarks/
- Information on the process: https://github.com/pvlib-benchmarker/pvlib-benchmarks
Example Gallery
===============

This gallery shows examples of pvlib functionality.  Community contributions are welcome!Reflections
-----------

Soiling
-------
I-V Modeling
------------

Shading
-------
Spectrum
--------
Irradiance Transposition
------------------------

Solar Tracking
--------------
Solar Position
--------------

.. _contributing:

Contributing
============

Encouraging more people to help develop pvlib-python is essential to our
success. Therefore, we want to make it easy and rewarding for you to
contribute.

There is a lot of material in this section, aimed at a variety of
contributors from novice to expert. Don't worry if you don't (yet)
understand parts of it.


Easy ways to contribute
~~~~~~~~~~~~~~~~~~~~~~~

Here are a few ideas for how you can contribute, even if you are new to
pvlib-python, git, or Python:

* Ask and answer `pvlib questions on StackOverflow <http://stackoverflow.com/questions/tagged/pvlib>`_
  and participate in discussions in the `pvlib-python google group <https://groups.google.com/forum/#!forum/pvlib-python>`_.
* Make `GitHub issues <https://github.com/pvlib/pvlib-python/issues>`_
  and contribute to the conversations about how to resolve them.
* Read issues and pull requests that other people created and
  contribute to the conversation about how to resolve them.
  Look for issues tagged with
  `good first issue <https://github.com/pvlib/pvlib-python/labels/good%20first%20issue>`_,
  `easy <https://github.com/pvlib/pvlib-python/labels/easy>`_,
  or `help wanted <https://github.com/pvlib/pvlib-python/labels/help%20wanted>`_.
* Improve the documentation and the unit tests.
* Improve the IPython/Jupyter Notebook tutorials or write new ones that
  demonstrate how to use pvlib-python in your area of expertise.
* If you have MATLAB experience, you can help us keep pvlib-python
  up to date with PVLIB_MATLAB or help us develop common unit tests.
  For more, see `Issue #2 <https://github.com/pvlib/pvlib-python/issues/2>`_
  and `Issue #3 <https://github.com/pvlib/pvlib-python/issues/3>`_.
* Tell your friends and colleagues about pvlib-python.
* Add your project to our
  `Projects and publications that use pvlib-python wiki
  <https://github.com/pvlib/pvlib-python/wiki/Projects-and-publications-
  that-use-pvlib-python>`_.


How to contribute new code
~~~~~~~~~~~~~~~~~~~~~~~~~~

The basics
----------

Contributors to pvlib-python use GitHub's pull requests to add/modify
its source code. The GitHub pull request process can be intimidating for
new users, but you'll find that it becomes straightforward once you use
it a few times. Please let us know if you get stuck at any point in the
process. Here's an outline of the process:

#. Create a GitHub issue and get initial feedback from users and
   maintainers. If the issue is a bug report, please include the
   code needed to reproduce the problem.
#. Obtain the latest version of pvlib-python: Fork the pvlib-python
   project to your GitHub account, ``git clone`` your fork to your computer.
#. Make some or all of your changes/additions and ``git commit`` them to
   your local repository.
#. Share your changes with us via a pull request: ``git push`` your
   local changes to your GitHub fork, then go to GitHub make a pull
   request.

The Pandas project maintains an excellent `contributing page
<http://pandas.pydata.org/pandas-docs/stable/contributing.html>`_ that goes
into detail on each of these steps. Also see GitHub's `Set Up Git
<https://help.github.com/articles/set-up-git/>`_ and `Using Pull
Requests <https://help.github.com/articles/using-pull-requests/>`_.

We strongly recommend using virtual environments for development.
Virtual environments make it trivial to switch between different
versions of software. This `astropy guide
<http://astropy.readthedocs.org/en/latest/development/workflow/
virtual_pythons.html>`_ is a good reference for virtual environments. If
this is your first pull request, don't worry about using a virtual
environment.

You must include documentation and unit tests for any new or improved
code. We can provide help and advice on this after you start the pull
request. See the Testing section below.


.. _pull-request-scope:

Pull request scope
------------------

This section can be summed up as "less is more".

A pull request can quickly become unmanageable if too many lines are
added or changed. "Too many" is hard to define, but as a rule of thumb,
we encourage contributions that contain less than 50 lines of primary code.
50 lines of primary code will typically need at least 250 lines
of documentation and testing. This is about the limit of what the
maintainers can review on a regular basis.

A pull request can also quickly become unmanageable if it proposes
changes to the API in order to implement another feature. Consider
clearly and concisely documenting all proposed API changes before
implementing any code. Modifying
`api.rst <https://github.com/pvlib/pvlib-python/blob/master/docs/sphinx/source/api.rst>`_
and/or the latest `whatsnew file <https://github.com/pvlib/pvlib-python/tree/master/docs/sphinx/source/whatsnew>`_
can help formalize this process.

Questions about related issues frequently come up in the process of
addressing implementing code for a pull request. Please try to avoid
expanding the scope of your pull request (this also applies to
reviewers!). We'd rather see small, well-documented additions to the
project's technical debt than see a pull request languish because its
scope expanded beyond what the reviewer community is capable of
processing.

Of course, sometimes it is necessary to make a large pull request. We
only ask that you take a few minutes to consider how to break it into
smaller chunks before proceeding.

pvlib-python contains :ref:`3 "layers" of code <modeling-paradigms>`:
functions, PVSystem/Location, and ModelChain. We recommend that
contributors focus their work on only one or two of those layers in a
single pull request. New models are *not* required to be available to
the higher-level API!


When should I submit a pull request?
------------------------------------

The short answer: anytime.

The long answer: it depends. If in doubt, go ahead and submit. You do
not need to make all of your changes before creating a pull request.
Your pull requests will automatically be updated when you commit new
changes and push them to GitHub.

There are pros and cons to submitting incomplete pull-requests. On the
plus side, it gives everybody an easy way to comment on the code and can
make the process more efficient. On the minus side, it's easy for an
incomplete pull request to grow into a multi-month saga that leaves
everyone unhappy. If you submit an incomplete pull request, please be
very clear about what you would like feedback on and what we should
ignore. Alternatives to incomplete pull requests include creating a
`gist <https://gist.github.com>`_ or experimental branch and linking to
it in the corresponding issue.

The best way to ensure that a pull request will be reviewed and merged in
a timely manner is to:

#. Start by creating an issue. The issue should be well-defined and
   actionable.
#. Ask the maintainers to tag the issue with the appropriate milestone.
#. Make a limited-scope pull request. It can be a lot of work to check all of
   the boxes in `pull request guidelines
   <https://github.com/pvlib/pvlib-python/blob/master/.github/PULL_REQUEST_TEMPLATE.md>`_,
   especially for pull requests with a lot of new primary code.
   See :ref:`pull-request-scope`.
#. Tag pvlib community members or ``@pvlib/maintainer`` when the pull
   request is ready for review. (see :ref:`pull-request-reviews`)


.. _pull-request-reviews:

Pull request reviews
--------------------

The pvlib community and maintainers will review your pull request in a
timely fashion. Please "ping" ``@pvlib/maintainer`` if it seems that
your pull request has been forgotten at any point in the pull request
process.

Keep in mind that the PV modeling community is diverse and each pvlib
community member brings a different perspective when reviewing code.
Some reviewers bring years of expertise in the sub-field that your code
contributes to and will focus on the details of the algorithm. Other
reviewers will be more focused on integrating your code with the rest of
pvlib, ensuring that it is feasible to maintain, that it meets the
:ref:`code style <code-style>` guidelines, and that it is
:ref:`comprehensively tested <testing>`. Limiting the scope of the pull
request makes it much more likely that all of these reviews can be
conducted and any issues can be resolved in a timely fashion.

Sometimes it's hard for reviewers to be immediately available, so the
right amount of patience is to be expected. That said, interested
reviewers should do their best to not wait until the last minute to put
in their two cents.


.. _code-style:

Code style
~~~~~~~~~~

pvlib python generally follows the `PEP 8 -- Style Guide for Python Code
<https://www.python.org/dev/peps/pep-0008/>`_. Maximum line length for code
is 79 characters.

pvlib python uses a mix of full and abbreviated variable names. See
:ref:`variables_style_rules`. We could be better about consistency.
Prefer full names for new contributions. This is especially important
for the API. Abbreviations can be used within a function to improve the
readability of formulae.

Set your editor to strip extra whitespace from line endings. This
prevents the git commit history from becoming cluttered with whitespace
changes.

Please see :ref:`Documentation` for information specific to documentation
style.

Remove any ``logging`` calls and ``print`` statements that you added
during development. ``warning`` is ok.

We typically use GitHub's
"`squash and merge <https://help.github.com/articles/about-pull-request-merges/#squash-and-merge-your-pull-request-commits>`_"
feature to merge your pull request into pvlib. GitHub will condense the
commit history of your branch into a single commit when merging into
pvlib-python/master (the commit history on your branch remains
unchanged). Therefore, you are free to make commits that are as big or
small as you'd like while developing your pull request.


.. _documentation:

Documentation
~~~~~~~~~~~~~

Documentation must be written in
`numpydoc format <https://numpydoc.readthedocs.io/>`_ format which is rendered
using the `Sphinx Napoleon extension
<https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html>`_.

The numpydoc format includes a specification for the allowable input
types. Python's `duck typing <https://en.wikipedia.org/wiki/Duck_typing>`_
allows for multiple input types to work for many parameters. pvlib uses
the following generic descriptors as short-hand to indicate which
specific types may be used:

* dict-like : dict, OrderedDict, pd.Series
* numeric : scalar, np.array, pd.Series. Typically int or float dtype.
* array-like : np.array, pd.Series. Typically int or float dtype.

Parameters that specify a specific type require that specific input type.

Read the Docs will automatically build the documentation for each pull
request. Please confirm the documentation renders correctly by following
the ``docs/readthedocs.org:pvlib-python`` link within the checks
status box at the bottom of the pull request.

Building the documentation
--------------------------

Building the documentation locally is useful for testing out changes to the
documentation's source code without having to repeatedly update a PR and have
Read the Docs build it for you.  Building the docs locally requires installing
pvlib python as an editable library (see :ref:`installation` for instructions).
First, install the ``doc`` dependencies specified in the
``EXTRAS_REQUIRE`` section of
`setup.py <https://github.com/pvlib/pvlib-python/blob/master/setup.py>`_.
An easy way to do this is with::

    pip install pvlib[doc]

Note: Anaconda users may have trouble using the above command to update an
older version of docutils. If that happens, you can update it with ``conda``
(e.g. ``conda install docutils=0.15.2``) and run the above command again.

Once the ``doc`` dependencies are installed, navigate to ``/docs/sphinx`` and
execute::

    make html

Be sure to skim through the output of this command because Sphinx might emit
helpful warnings about problems with the documentation source code.
If the build succeeds, it will make a new directory ``docs/sphinx/build``
with the documentation's homepage located at ``build/html/index.html``.
This file can be opened with a web browser to view the local version
like any other website. Other output formats are available; run ``make help``
for more information.

Note that Windows users need not have the ``make`` utility installed as pvlib
includes a ``make.bat`` batch file that emulates its interface.

Example Gallery
---------------

The example gallery uses `sphinx-gallery <https://sphinx-gallery.github.io/>`_
and is generated from script files in the
`docs/examples <https://github.com/pvlib/pvlib-python/tree/master/docs/examples>`_
directory.  sphinx-gallery will execute example files that start with
``plot_`` and capture the output.

Here is a starter template for new examples:

.. code-block:: python

    """
    Page Title
    ==========

    A sentence describing the example.
    """

    # %%
    # Explanatory text about the example, what it does, why it does it, etc.
    # Text in the comment block before the first line of code `import pvlib`
    # will be printed to the example's webpage.

    import pvlib
    import matplotlib.pyplot as plt

    plt.scatter([1, 2, 3], [4, 5, 6])
    plt.show()

For more details, see the sphinx-gallery
`docs <https://sphinx-gallery.github.io/stable/syntax.html#embedding-rst>`_.

.. _testing:

Testing
~~~~~~~

Developers **must** include comprehensive tests for any additions or
modifications to pvlib. New unit test code should be placed in the
corresponding test module in the
`pvlib/tests <https://github.com/pvlib/pvlib-python/tree/master/pvlib/tests>`_
directory.

A pull request will automatically run the tests for you on a variety of
platforms (Linux, Mac, Windows) and python versions. However, it is
typically more efficient to run and debug the tests in your own local
environment.

To run the tests locally, install the ``test`` dependencies specified in the
`setup.py <https://github.com/pvlib/pvlib-python/blob/master/setup.py>`_
file. See :ref:`installation` instructions for more information.

pvlib's unit tests can easily be run by executing ``pytest`` on the
pvlib directory::

    pytest pvlib

or, for a single module::

    pytest pvlib/tests/test_clearsky.py

or, for a single test::

    pytest pvlib/tests/test_clearsky.py::test_ineichen_nans

We suggest using pytest's ``--pdb`` flag to debug test failures rather
than using ``print`` or ``logging`` calls. For example::

    pytest pvlib --pdb

will drop you into the
`pdb debugger <https://docs.python.org/3/library/pdb.html>`_ at the
location of a test failure. As described in :ref:`code-style`, pvlib
code does not use ``print`` or ``logging`` calls, and this also applies
to the test suite (with rare exceptions).

To include all network-dependent tests, include the ``--remote-data`` flag to
your ``pytest`` call::

    pytest pvlib --remote-data

And consider adding ``@pytest.mark.remote_data`` to any network dependent test
you submit for a PR.

pvlib-python contains 3 "layers" of code: functions, PVSystem/Location,
and ModelChain. Contributors will need to add tests that correspond to
the layers that they modify.

Functions
---------
Tests of core pvlib functions should ensure that the function returns
the desired output for a variety of function inputs. The tests should be
independent of other pvlib functions (see :issue:`394`). The tests
should ensure that all reasonable combinations of input types (floats,
nans, arrays, series, scalars, etc) work as expected. Remember that your
use case is likely not the only way that this function will be used, and
your input data may not be generic enough to fully test the function.
Write tests that cover the full range of validity of the algorithm.
It is also important to write tests that assert the return value of the
function or that the function throws an exception when input data is
beyond the range of algorithm validity.

PVSystem/Location
-----------------
The PVSystem and Location classes provide convenience wrappers around
the core pvlib functions. The tests in test_pvsystem.py and
test_location.py should ensure that the method calls correctly wrap the
function calls. Many PVSystem/Location methods pass one or more of their
object's attributes (e.g. PVSystem.module_parameters, Location.latitude)
to a function. Tests should ensure that attributes are passed correctly.
These tests should also ensure that the method returns some reasonable
data, though the precise values of the data should be covered by
function-specific tests discussed above.

We prefer to use the ``pytest-mock`` framework to write these tests. The
test below shows an example of testing the ``PVSystem.ashraeiam``
method. ``mocker`` is a ``pytest-mock`` object. ``mocker.spy`` adds
features to the ``pvsystem.ashraeiam`` *function* that keep track of how
it was called. Then a ``PVSystem`` object is created and the
``PVSystem.ashraeiam`` *method* is called in the usual way. The
``PVSystem.ashraeiam`` method is supposed to call the
``pvsystem.ashraeiam`` function with the angles supplied to the method
call and the value of ``b`` that we defined in ``module_parameters``.
The ``pvsystem.ashraeiam.assert_called_once_with`` tests that this does,
in fact, happen. Finally, we check that the output of the method call is
reasonable.

.. code-block:: python

    def test_PVSystem_ashraeiam(mocker):
        # mocker is a pytest-mock object.
        # mocker.spy adds code to a function to keep track of how it is called
        mocker.spy(pvsystem, 'ashraeiam')

        # set up inputs
        module_parameters = {'b': 0.05}
        system = pvsystem.PVSystem(module_parameters=module_parameters)
        thetas = 1

        # call the method
        iam = system.ashraeiam(thetas)

        # did the method call the function as we expected?
        # mocker.spy added assert_called_once_with to the function
        pvsystem.ashraeiam.assert_called_once_with(thetas, b=module_parameters['b'])

        # check that the output is reasonable, but no need to duplicate
        # the rigorous tests of the function
        assert iam < 1.

Avoid writing PVSystem/Location tests that depend sensitively on the
return value of a statement as a substitute for using mock. These tests
are sensitive to changes in the functions, which is *not* what we want
to test here, and are difficult to maintain.

ModelChain
----------
The tests in test_modelchain.py should ensure that
``ModelChain.__init__`` correctly configures the ModelChain object to
eventually run the selected models. A test should ensure that the
appropriate method is actually called in the course of
``ModelChain.run_model``. A test should ensure that the model selection
does have a reasonable effect on the subsequent calculations, though the
precise values of the data should be covered by the function tests
discussed above. ``pytest-mock`` can also be used for testing ``ModelChain``.

The example below shows how mock can be used to assert that the correct
PVSystem method is called through ``ModelChain.run_model``.

.. code-block:: python

    def test_modelchain_dc_model(mocker):
        # set up location and system for model chain
        location = location.Location(32, -111)
        system = pvsystem.PVSystem(module_parameters=some_sandia_mod_params,
                                   inverter_parameters=some_cecinverter_params)

        # mocker.spy adds code to the system.sapm method to keep track of how
        # it is called. use returned mock object m to make assertion later,
        # but see example above for alternative
        m = mocker.spy(system, 'sapm')

        # make and run the model chain
        mc = ModelChain(system, location,
                        aoi_model='no_loss', spectral_model='no_loss')
        times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')
        mc.run_model(times)

        # assertion fails if PVSystem.sapm is not called once
        m.assert_called_once()

        # use `assert m.call_count == num` if function should be called
        # more than once

        # ensure that dc attribute now exists and is correct type
        assert isinstance(mc.dc, (pd.Series, pd.DataFrame))


Benchmarking
~~~~~~~~~~~~

pvlib includes a small number of performance benchmarking tests. These
tests are run using the `airspeed velocity
<https://asv.readthedocs.io/en/stable/>`_ tool. We do not require new
performance tests for most contributions at this time. Pull request
reviewers will provide further information if a performance test is
necessary. See our `README
<https://github.com/pvlib/pvlib-python/tree/master/benchmarks/README.md>`_
for instructions on running the benchmarks.


This documentation
~~~~~~~~~~~~~~~~~~

If this documentation is unclear, help us improve it! Consider looking
at the `pandas
documentation <http://pandas.pydata.org/pandas-docs/stable/
contributing.html>`_ for inspiration.

Code of Conduct
~~~~~~~~~~~~~~~
All contributors are expected to adhere to the `Contributor Code of Conduct
<https://github.com/pvlib/pvlib-python/blob/master/CODE_OF_CONDUCT.md#contributor-covenant-code-of-conduct>`_.
.. _whatsnew:

**********
What's New
**********

These are new features and improvements of note in each release.

.. include:: whatsnew/v0.9.1.rst
.. include:: whatsnew/v0.9.0.rst
.. include:: whatsnew/v0.8.1.rst
.. include:: whatsnew/v0.8.0.rst
.. include:: whatsnew/v0.7.2.rst
.. include:: whatsnew/v0.7.1.rst
.. include:: whatsnew/v0.7.0.rst
.. include:: whatsnew/v0.6.3.rst
.. include:: whatsnew/v0.6.2.rst
.. include:: whatsnew/v0.6.1.rst
.. include:: whatsnew/v0.6.0.rst
.. include:: whatsnew/v0.5.2.rst
.. include:: whatsnew/v0.5.1.rst
.. include:: whatsnew/v0.5.0.rst
.. include:: whatsnew/v0.4.5.txt
.. include:: whatsnew/v0.4.4.txt
.. include:: whatsnew/v0.4.3.txt
.. include:: whatsnew/v0.4.2.txt
.. include:: whatsnew/v0.4.1.txt
.. include:: whatsnew/v0.4.0.txt
.. include:: whatsnew/v0.3.3.txt
.. include:: whatsnew/v0.3.2.txt
.. include:: whatsnew/v0.3.1.txt
.. include:: whatsnew/v0.3.0.txt
.. include:: whatsnew/v0.2.2.txt
.. include:: whatsnew/v0.2.1.txt
.. include:: whatsnew/v0.2.0.txt
.. include:: whatsnew/v0.1.0.txt
.. image:: _images/pvlib_logo_horiz.png
  :width: 600

pvlib python
============

pvlib python is a community supported tool that provides a set of
functions and classes for simulating the performance of photovoltaic
energy systems. pvlib python was originally ported from the PVLIB MATLAB
toolbox developed at Sandia National Laboratories and it implements many
of the models and methods developed at the Labs. More information on
Sandia Labs PV performance modeling programs can be found at the `PVPMC <https://pvpmc.sandia.gov/>`_. We collaborate with the PVLIB MATLAB project,
but operate independently of it.

The source code for pvlib python is hosted on `github
<https://github.com/pvlib/pvlib-python>`_.

Please see the :ref:`installation` page for installation help.

For examples of how to use pvlib python, please see
:ref:`package_overview` and our `Jupyter Notebook tutorials
<http://nbviewer.ipython.org/github/pvlib/pvlib-python/tree/master/docs/
tutorials/>`_. The documentation assumes general familiarity with
Python, NumPy, and Pandas. Google searches will yield many
excellent tutorials for these packages.

The pvlib python GitHub wiki has a `Projects and publications that use
pvlib python
<https://github.com/pvlib/pvlib-python/wiki/Projects-and-publications-
that-use-pvlib-python>`_ page for inspiration and listing of your
application.

There is a :ref:`variable naming convention <variables_style_rules>` to
ensure consistency throughout the library.

Citing pvlib python
===================

Many of the contributors to pvlib-python work in institutions where
citation metrics are used in performance or career evaluations. If you
use pvlib python in a published work, please cite:

  William F. Holmgren, Clifford W. Hansen, and Mark A. Mikofski.
  "pvlib python: a python package for modeling solar energy systems."
  Journal of Open Source Software, 3(29), 884, (2018).
  https://doi.org/10.21105/joss.00884

Please also cite the DOI corresponding to the specific version of
pvlib python that you used. pvlib python DOIs are listed at
`Zenodo.org <https://zenodo.org/search?page=1&size=20&q=conceptrecid:593284&all_versions&sort=-version>`_

If you use pvlib-python in a commercial or publicly-available
application, please consider displaying one of the "powered by pvlib"
logos:

.. image:: _images/pvlib_powered_logo_horiz.png
  :width: 300

.. image:: _images/pvlib_powered_logo_vert.png
  :width: 300

Additional pvlib python publications include:

* J. S. Stein, “The photovoltaic performance modeling
  collaborative (PVPMC),” in Photovoltaic Specialists Conference, 2012.
* R.W. Andrews, J.S. Stein, C. Hansen, and D. Riley, “Introduction
  to the open source pvlib for python photovoltaic system
  modelling package,” in 40th IEEE Photovoltaic Specialist
  Conference, 2014.
  (`paper
  <http://energy.sandia.gov/wp/wp-content/gallery/uploads/PV_LIB_Python_final_SAND2014-18444C.pdf>`__)
* W.F. Holmgren, R.W. Andrews, A.T. Lorenzo, and J.S. Stein,
  “PVLIB Python 2015,” in 42nd Photovoltaic Specialists Conference, 2015.
  (`paper
  <https://github.com/pvlib/pvsc2015/blob/master/pvlib_pvsc_42.pdf>`__ and
  the `notebook to reproduce the figures
  <http://nbviewer.ipython.org/github/pvlib/pvsc2015/blob/master/paper.ipynb>`_)
* J.S. Stein, W.F. Holmgren, J. Forbess, and C.W. Hansen,
  "PVLIB: Open Source Photovoltaic Performance Modeling Functions
  for Matlab and Python," in 43rd Photovoltaic Specialists Conference, 2016.
* W.F. Holmgren and D.G. Groenendyk,
  "An Open Source Solar Power Forecasting Tool Using PVLIB-Python,"
  in 43rd Photovoltaic Specialists Conference, 2016.

License
=======

`BSD 3-clause <https://github.com/pvlib/pvlib-python/blob/master/LICENSE>`_.

NumFOCUS
========

pvlib python is a `NumFOCUS Affiliated Project <https://numfocus.org/sponsored-projects/affiliated-projects>`_

.. image:: https://i0.wp.com/numfocus.org/wp-content/uploads/2019/06/AffiliatedProject.png
  :target: https://numfocus.org/sponsored-projects/affiliated-projects
  :alt: NumFocus Affliated Projects

Contents
========

.. toctree::
   :maxdepth: 1

   user_guide/index
   gallery/index
   reference/index
   whatsnew
   contributing


Indices and tables
==================

* :ref:`genindex`
* :ref:`search`
{{ fullname | escape | underline }}

.. currentmodule:: {{ module }}

.. autofunction:: {{ fullname }}

{# not sure how to get the minigallery directive to not render empty #}
{# galleries, so just use the old `include` style instead #}
{# .. minigallery:: {{ fullname }} #}

.. include:: gallery_backreferences/{{fullname}}.examples
{{ fullname | escape | underline }}

.. currentmodule:: {{ module }}

.. automethod:: {{ fullname }}

{# not sure how to get the minigallery directive to not render empty #}
{# galleries, so just use the old `include` style instead #}
{# .. minigallery:: {{ fullname }} #}

.. include:: gallery_backreferences/{{fullname}}.examples
{{ fullname | escape | underline}}

.. currentmodule:: {{ module }}

.. autoclass:: {{ objname }}

   {% block methods %}
   {% if methods %}
   .. rubric:: Methods

   .. autosummary::
      :toctree:
      :recursive:
   {% for item in methods %}
      ~{{ name }}.{{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}

   {% block attributes %}
   {% if attributes %}
   .. rubric:: Attributes

   .. autosummary::
   {% for item in attributes %}
      ~{{ name }}.{{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}

{# not sure how to get the minigallery directive to not render empty #}
{# galleries, so just use the old `include` style instead #}
{# .. minigallery:: {{ fullname }} #}

.. include:: gallery_backreferences/{{fullname}}.examples
.. _whatsnew_0520:

v0.5.2 (May 13, 2018)
---------------------

API Changes
~~~~~~~~~~~
* removed unused 'pressure' arg from irradiance.liujordan function (:issue:`386`)
* replaced logging.warning calls with warnings.warn calls, and removed
  logging.debug calls. We encourage users to explore tools such as pdb and
  trackback in place of the logging.debug calls. Fixes (:issue:`447`).

Enhancements
~~~~~~~~~~~~
* Improve clearsky.lookup_linke_turbidity speed, changing .mat source file
  to .h5 (:issue:`437`)
* Updated libraries for CEC module parameters to SAM release 2017.9.5
  (library dated 2017.6.30) and CEC inverter parameters to file posted to
  www.github.com/NREL/SAM on 2018.3.18, with one entry removed due to a
  missing parameter value. (:issue:'440')

Bug fixes
~~~~~~~~~
* fixed redeclaration of test_simplified_solis_series_elevation (:issue:`387`)
* physicaliam now returns a Series if called with a Series as an
  argument. (:issue:`397`)
* corrected docstring for irradiance.total_irrad (:issue: '423')
* modified solar_azimuth_analytical to handle some borderline cases, thereby
  avoiding the NaN values and/or warnings that were previously produced
  (:issue: '420')
* removed RuntimeWarnings due to divide by 0 or nans in input data within
  irradiance.perez, clearsky.simplified_solis, pvsystem.adrinverter,
  pvsystem.ashraeiam, pvsystem.physicaliam, pvsystem.sapm_aoi_loss,
  pvsystem.v_from_i. (:issue:`428`)


Documentation
~~~~~~~~~~~~~
* Improve physicaliam doc string. (:issue:`397`)

Testing
~~~~~~~
* Test Python 3.6 on Windows with Appveyor instead of 3.4. (:issue:`392`)
* Fix failing test on pandas 0.22 (:issue:`406`)
* Fix too large test tolerance (:issue:`414`)

Contributors
~~~~~~~~~~~~
* Cliff Hansen
* Will Holmgren
* KonstantinTr
* Anton Driesse
* Cedric Leroy
.. _whatsnew_0720:

v0.7.2 (April 22, 2020)
-------------------------

API Changes
~~~~~~~~~~~
* :py:class:`pvlib.forecast.ForecastModel` now requires ``start`` and ``end``
  arguments to be tz-localized. (:issue:`877`, :pull:`879`)
* :py:func:`pvlib.iotools.read_tmy3` when coerced to a single year now returns
  indices that are monotonically increasing. Therefore, the last index will be
  January 1, 00:00 of the *next* year. (:pull:`910`)
* Renamed ``pvlib.losses`` to :py:mod:`pvlib.soiling`. Additional loss
  models will go into code modules named for the loss or effect type.
  (:issue:`935`, :issue:`891`)
* Renamed ``pvlib.losses.soiling_hsu`` to :py:func:`pvlib.soiling.hsu`
  (:issue:`935`)

Enhancements
~~~~~~~~~~~~
* TMY3 dataframe returned by :py:func:`~pvlib.iotools.read_tmy3` now contains
  the original ``Date (MM/DD/YYYY)`` and ``Time (HH:MM)`` columns that the
  indices were parsed from. (:pull:`866`)
* Add :py:func:`pvlib.pvsystem.PVSystem.faiman` and added
  ``temperature_model='faiman'`` option to :py:class:`~pvlib.modelchain.ModelChain`
  (:pull:`897`) (:issue:`836`).
* Add Kimber soiling model :py:func:`pvlib.losses.soiling_kimber`. (:pull:`860`)
* Add :py:func:`pvlib.iotools.read_pvgis_tmy` for files downloaded using the
* Add Kimber soiling model :py:func:`pvlib.soiling.kimber`. (:pull:`860`,
   :issue`935`)
* Add :func:`~pvlib.iotools.read_pvgis_tmy` for files downloaded using the
  PVGIS tool. (:issue:`880`)
* Add :py:func:`pvlib.temperature.sapm_cell_from_module` to convert back of
  module temperature to cell temperature (:issue:`927`)
* Add new module :py:mod:`pvlib.snow` to contain models related to snow coverage and effects on a PV system. (:pull:`764`)
* Add snow coverage model :py:func:`pvlib.snow.coverage_nrel` and function to identify when modules are fully covered by snow :py:func:`pvlib.snow.fully_covered_nrel`. (:issue:`577`)
* Add function :py:func:`pvlib.snow.dc_loss_nrel` for effect of snow coverage on DC output. (:pull:`764`)
* Add capability to calculate current at reverse bias using an avalanche
  breakdown model, affects :py:func:`pvlib.singlediode.bishop88`,
  :py:func:`pvlib.singlediode.bishop88_i_from_v`, :py:func:`pvlib.singlediode.bishop88_v_from_i`,
  :py:func:`pvlib.singlediode.bishop88_mpp`. (:pull:`948`)
* Add weather data arguments in get_solarpostion method of modelchain.ModelChain.prepare_inputs :py:func:`modelchain.ModelChain.prepare_inputs` (:pull:`936`)

Bug fixes
~~~~~~~~~
* Fix :py:func:`~pvlib.iotools.read_tmy3` parsing when February contains
  a leap year. (:pull:`866`)
* Implement NREL Developer Network API key for consistent success with API
  calls in :py:mod:`pvlib.tests.iotools.test_psm3`. (:pull:`873`)
* Fix issue with :py:class:`pvlib.location.Location` creation when
  passing ``tz=datetime.timezone.utc``. (:pull:`879`)
* Fix documentation homepage title to "pvlib python" based on first heading on
  the page. (:pull:`890`) (:issue:`888`)
* Fix missing
  `0.7.0 what's new <https://pvlib-python.readthedocs.io/en/stable/whatsnew.html#v0-7-0-december-18-2019>`_
  entries about changes to ``PVSystem.pvwatts_ac``. Delete unreleased
  0.6.4 what's new file. (:issue:`898`)
* Compatibility with cftime 1.1. (:issue:`895`)
* Minor implemention changes to avoid runtime and deprecation warnings in
  :py:func:`~pvlib.clearsky.detect_clearsky`,
  :py:func:`~pvlib.iam.martin_ruiz_diffuse`,
  :py:func:`~pvlib.losses.soiling_hsu`,
  and various test functions.
* Fix :py:func:`~pvlib.iotools.read_tmy3` so that when coerced to a single year
  the TMY3 index will be monotonically increasing. (:pull:`910`)
* Fix :py:func:`pvlib.spa.julian_day_dt` so that microseconds are scaled
  correctly (:issue:`940`) (:pull:`942`)

Testing
~~~~~~~
* Rename `system` fixture to `sapm_dc_snl_ac_system` in model chain
  tests. (:issue:`908`, :pull:`915`).
* Implement `pytest-remotedata <https://github.com/astropy/pytest-remotedata>`_
  to increase test suite speed. Requires ``--remote-data`` pytest flag to
  execute data retrieval tests over a network. (:issue:`882`)(:pull:`896`)
* Add Python3.8 to Azure Pipelines CI. (:issue:`903`)(:pull:`904`)
* Add documentation build test to Azure Pipelines CI. (:pull:`909`)
* Implement the `pytest.mark.flaky` decorator from `pytest-rurunfailures`
  `<https://github.com/pytest-dev/pytest-rerunfailures>`_ on all network
  dependent iotools tests to repeat them on failure. (:pull:`919`)
* Separate azure-pipelines.yml platform-specific tests to their own templates
  located in ``./ci/azure/``.  (:pull:`926`)

Documentation
~~~~~~~~~~~~~
* Add NumFOCUS affiliation to Sphinx documentation. (:pull:`862`)
* Add example of IV curve generation. (:pull:`872`)
* Add section about gallery examples to Contributing guide. (:pull:`905`)
* Add section with link to Code of Conduct in Contributing guide. (:pull:`922`)
* Add example of GHI to POA transposition (:pull:`933`)

Requirements
~~~~~~~~~~~~
* nrel-pysam (optional) minimum set to v1.0.0 (:issue:`874`)
* cftime (optional) minimum set to >=1.1.1. Use of
  `only_use_python_datetimes` kwarg in `netCDF4.num2date` in forecast.py
  requires >=1.1.1 which is >=Python3.6. (:pull:`947`)

Contributors
~~~~~~~~~~~~
* Mark Mikofski (:ghuser:`mikofski`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Cameron T. Stark (:ghuser:`camerontstark`)
* Will Holmgren (:ghuser:`wholmgren`)
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Karthikeyan Singaravelan (:ghuser:`tirkarthi`)
* Siyan (Veronica) Guo (:ghuser:`veronicaguo`)
* Eric Fitch (:ghuser:`ericf900`)
* Joseph Palakapilly (:ghuser:`JPalakapilly`)
* Auguste Colle(:ghuser:`augustecolle`)
* Ahan M R (:ghuser:`Ahanmr`)
.. _whatsnew_0510:

v0.5.1 (October 17, 2017)
-------------------------

API Changes
~~~~~~~~~~~
* `pvsystem.v_from_i` and `pvsystem.i_from_v` functions now accept
  resistance_series = 0 and/or resistance_shunt = numpy.inf as inputs
  (:issue:`340`)

Enhancements
~~~~~~~~~~~~
* Improve clearsky.lookup_linke_turbidity speed. (:issue:`368`)
* Ideal devices supported in single diode model, e.g.,
  resistance_series = 0 and/or resistance_shunt = numpy.inf (:issue:`340`)
* `pvsystem.v_from_i` and `pvsystem.i_from_v` computations for near ideal
  devices are more numerically stable. However, very, very near ideal
  resistance_series and/or resistance_shunt may still cause issues with the
  implicit solver (:issue:`340`)

Bug fixes
~~~~~~~~~
* Remove condition causing Overflow warning from clearsky.haurwitz
  (:issue:`363`)
* modelchain.basic_chain now correctly passes 'solar_position_method'
  arg to solarposition.get_solarposition (:issue:`370`)
* Fixed: `Variables and Symbols extra references not available
  <https://github.com/pvlib/pvlib-python/issues/380>`_ (:issue:`380`)
* Removed unnecessary calculations of alpha_prime in spa.solar_position_numpy
  and spa.solar_position_loop (:issue:`366`)
* Fixed args mismatch for solarposition.pyephem call
  from solarposition.get_solarposition with method='pyephem'
  arg to solarposition.get_solarposition (:issue:`370`)
* ModelChain.prepare_inputs and ModelChain.complete_irradiance now
  correctly pass the 'solar_position_method' argument to
  solarposition.get_solarposition (:issue:`377`)
* Fixed usage of inplace parameter for tmy._recolumn (:issue:`342`)

Documentation
~~~~~~~~~~~~~
* Doc string of modelchain.basic_chain was updated to describe args
  more accurately. (:issue:`370`)
* Doc strings of `singlediode`, `pvsystem.v_from_i`, and `pvsystem.i_from_v`
  were updated to describe acceptable input arg ranges. (:issue:`340`)

Testing
~~~~~~~
* Changed test for clearsky.haurwitz to operate on zenith angles
* Significant new test cases added for `pvsystem.v_from_i` and
  `pvsystem.i_from_v` (:issue:`340`)

Contributors
~~~~~~~~~~~~
* Cliff Hansen
* KonstantinTr
* Will Holmgren
* Mark Campanelli
* DaCoEx
.. _whatsnew_0900:

v0.9.0 (September 1, 2021)
--------------------------

Breaking changes
~~~~~~~~~~~~~~~~
* Moved functions related to inverters from ``pvsystem.py`` to ``inverter.py``.
  Functions are renamed to follow a more consistent pattern, as follows (:pull:`886`, :pull:`1136`):

    - ``pvlib.pvsystem.snlinverter`` is now :py:func:`pvlib.inverter.sandia`
    - ``pvlib.pvsystem.pvwatts_ac`` is now :py:func:`pvlib.inverter.pvwatts`
    - ``pvlib.pvsystem.adrinverter`` is now :py:func:`pvlib.inverter.adr`

* Argument ``ac_model`` for :py:class:`pvlib.modelchain.ModelChain` now accepts
  ``'sandia'``, ``'pvwatts'`` and ``'adr'`` for the inverter models. (:pull:`886`, :pull:`1136`)

* Calling :py:meth:`pvlib.pvsystem.PVSystem.sapm_celltemp` without setting
  ``PVSystem.temperature_model_parameters``,
  or a valid combination of ``PVsystem.module_type`` and ``PVsystem.racking_model``, will
  now raise an exception. (:issue:`1030`, :pull:`1033`, :pull:`1136`)

* Deprecated arbitrary keyword arguments for
  :py:class:`pvlib.location.Location`, :py:class:`pvlib.pvsystem.PVSystem`,
  :py:class:`pvlib.tracking.SingleAxisTracker`, and
  :py:class:`pvlib.modelchain.ModelChain`. Supplying arbitrary keyword
  to these objects result in TypeErrors in v0.9. (:issue:`1029`, :pull:`1053`, :pull:`1136`)

* ``pvlib.pvsystem.LocalizedPVSystem`` and ``pvlib.pvsystem.LocalizedSingleAxisTracker``
  have been removed. Use
  :py:class:`pvlib.location.Location`, :py:class:`pvlib.pvsystem.PVSystem`,
  :py:class:`pvlib.tracking.SingleAxisTracker`, and
  :py:class:`pvlib.modelchain.ModelChain` instead.
  (:issue:`1029`, :pull:`1034`, :pull:`1053`, :pull:`1136`)

* ``irradiance.liujordan`` and ``ForecastModel.cloud_cover_to_irradiance_liujordan``
  have been removed. (:pull:`1136`)

* ``ModelChain.snlinverter`` changed to ``ModelChain.sandia_inverter``.
  ``ModelChain.adrinverter`` changed to ``ModelChain.adr_inverter``.
  (:pull:`1150`)

* The ``orientation_strategy`` parameter has been removed from the various
  :py:class:`pvlib.modelchain.ModelChain` constructors and ``surface_tilt``,
  ``surface_azimuth`` are now required parameters for
  :py:func:`pvlib.modelchain.basic_chain` (:issue:`1028`, :pull:`1181`)

* Removed the ``**kwargs`` parameters from :py:meth:`~pvlib.pvsystem.PVSystem.sapm` and
  :py:meth:`~pvlib.pvsystem.PVSystem.calcparams_desoto` and
  :py:meth:`~pvlib.pvsystem.PVSystem.calcparams_cec` (:issue:`1118`, :pull:`1222`)

* Switched the order of the outputs from the PSM3 iotools, notably
  :py:func:`~pvlib.iotools.get_psm3` and :py:func:`~pvlib.iotools.read_psm3`
  (:issue:`1245`, :pull:`1268`)

* Changed the naming of the inputs ``startdate``/``enddate`` to ``start``/``end`` in
  :py:func:`~pvlib.iotools.get_ecmwf_macc`
  (:issue:`1245`, :pull:`1268`)

* Change the naming of the inputs ``lat``/``lon`` to ``latitude``/``longitude`` in
  :py:func:`~pvlib.iotools.get_pvgis_tmy` (:issue:`1245`, :pull:`1268`)

Deprecations
~~~~~~~~~~~~
* The following ``ModelChain`` attributes are deprecated. They have been moved
  to the :py:class:`~pvlib.modelchain.ModelChainResult` class that is
  accessible via ``ModelChain.results``:

  * ``ModelChain.ac``
  * ``ModelChain.airmass``
  * ``ModelChain.aoi``
  * ``ModelChain.aoi_modifier``
  * ``ModelChain.cell_temperature``
  * ``ModelChain.dc``
  * ``ModelChain.diode_params``
  * ``ModelChain.effective_irradiance``
  * ``ModelChain.losses``
  * ``ModelChain.solar_position``
  * ``ModelChain.spectral_modifier``
  * ``ModelChain.total_irrad``
  * ``ModelChain.tracking``
  * ``ModelChain.weather``
  * ``ModelChain.times``

* The following ``PVSystem`` cell temperature methods have been deprecated
  and consolidated into the new wrapper method
  :py:meth:`~pvlib.pvsystem.PVSystem.get_cell_temperature` (:pull:`1211`):

  * :py:meth:`~pvlib.pvsystem.PVSystem.sapm_celltemp`
  * :py:meth:`~pvlib.pvsystem.PVSystem.pvsyst_celltemp`
  * :py:meth:`~pvlib.pvsystem.PVSystem.faiman_celltemp`
  * :py:meth:`~pvlib.pvsystem.PVSystem.fuentes_celltemp`
  * :py:meth:`~pvlib.pvsystem.PVSystem.noct_sam_celltemp`

* The ``eta_m`` parameter for :py:func:`~pvlib.temperature.pvsyst_cell` is
  replaced by parameter ``module_efficiency``. (:issue:`1188`, :pull:`1218`)

* The following attributes of :py:class:`pvlib.pvsystem.PVSystem` and
  :py:class:`pvlib.tracking.SingleAxisTracker` have been deprecated in
  favor of the corresponding :py:class:`pvlib.pvsystem.Array` attributes:

  * ``PVSystem.albedo``
  * ``PVSystem.module``
  * ``PVSystem.module_parameters``
  * ``PVSystem.module_type``
  * ``PVSystem.modules_per_string``
  * ``PVSystem.racking_model``
  * ``PVSystem.strings_per_inverter``
  * ``PVSystem.surface_tilt``
  * ``PVSystem.surface_azimuth``
  * ``PVSystem.temperature_model_parameters``

* The :py:class:`pvlib.tracking.SingleAxisTracker` class is deprecated and
  replaced by using :py:class:`pvlib.pvsystem.PVSystem` with the new
  :py:class:`pvlib.pvsystem.SingleAxisTrackerMount` (:pull:`1176`)


Enhancements
~~~~~~~~~~~~
* Added :func:`~pvlib.iotools.read_pvgis_hourly` and
  :func:`~pvlib.iotools.get_pvgis_hourly` for reading and retrieving hourly
  solar radiation data and PV power output from PVGIS. (:pull:`1186`,
  :issue:`849`)
* Added ``map_variables`` option to :func:`~pvlib.iotools.get_pvgis_tmy` and
  :func:`~pvlib.iotools.read_pvgis_tmy` (:issue:`1250`, :pull:`1268`)
* Add :func:`~pvlib.iotools.get_bsrn` and :func:`~pvlib.iotools.read_bsrn`
  for retrieving and reading BSRN solar radiation data files.
  (:pull:`1254`, :pull:`1145`, :issue:`1015`)
* Add :func:`~pvlib.iotools.get_cams`,
  :func:`~pvlib.iotools.parse_cams`, and
  :func:`~pvlib.iotools.read_cams`
  for retrieving, parsing, and reading CAMS Radiation and McClear time-series
  files. (:pull:`1175`)
* In :py:class:`~pvlib.modelchain.ModelChain`, attributes which contain
  output of models are now collected into ``ModelChain.results``.
  (:pull:`1076`, :issue:`1067`)
* Added :py:class:`~pvlib.pvsystem.Array` class to represent an array of
  modules separately from a :py:class:`~pvlib.pvsystem.PVSystem`.
  (:pull:`1076`, :issue:`1067`)
* Added :py:class:`~pvlib.pvsystem.FixedMount` and
  :py:class:`~pvlib.pvsystem.SingleAxisTrackerMount` classes to use with
  the new :py:class:`~pvlib.pvsystem.Array` class (:pull:`1176`)
* Added capability for modeling a PV system with multiple arrays in
  :py:class:`~pvlib.pvsystem.PVSystem`. Updates the ``PVSystem`` API
  to operate on and return tuples where each element of the tuple corresponds
  to the input or output for a specific ``Array``. (:pull:`1076`,
  :issue:`1067`)
* Support for systems with multiple ``Arrays`` added to
  :py:class:`~pvlib.modelchain.ModelChain`. This includes substantial API
  enhancements for accepting different weather input for each ``Array`` in the
  system. (:pull:`1076`, :issue:`1067`)
* Support for :py:func:`~pvlib.inverter.sandia_multi` and
  :py:func:`~pvlib.inverter.pvwatts_multi` added to
  :py:class:`~pvlib.pvsystem.PVSystem` and
  :py:class:`~pvlib.modelchain.ModelChain` (as ``ac_model='sandia'``
  and ``ac_model='pvwatts'``).
  (:pull:`1076`, :issue:`1067`, :pull:`1132`, :issue:`1117`, :pull:`1150`)
* :py:class:`~pvlib.modelchain.ModelChain` 'run_model' methods now
  automatically switch to using ``'effective_irradiance'`` (if available) for
  cell temperature models, when ``'poa_global'`` is not provided in input
  weather or calculated from input weather data.
* :py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc` now scales the DC power
  by ``pvsystem.PVSystem.modules_per_strings`` and
  ``pvsystem.PVSystem.strings_per_inverter``. Note that both attributes still
  default to 1. (:pull:`1138`)
* :py:meth:`~pvlib.pvsystem.PVSystem.get_ac` is added to calculate AC power
  from DC power. Use parameter ``model`` to specify which inverter model to use.
  (:pull:`1147`, :issue:`998`, :pull:`1150`)
* Added :py:func:`~pvlib.temperature.noct_sam`, a cell temperature model
  implemented in SAM. (:pull:`1177`, :pull:`1195`)
* Added :py:func:`~pvlib.ivtools.sdm.pvsyst_temperature_coeff` to calculate
  the temperature coefficient of power for the pvsyst module model.
  (:pull:`1190`)
* :py:func:`~pvlib.irradiance.get_total_irradiance` and
  :py:func:`~pvlib.irradiance.get_sky_diffuse` now fill in ``airmass``
  if required and not provided. These functions now raise a ``ValueError``
  if ``dni_extra`` is required and not provided. (:issue:`949`, :pull:`1225`)

Bug fixes
~~~~~~~~~
* Corrected an error in :py:func:`~pvlib.irradiance.perez` where the horizon
  irradiance component was prevented from taking negative values. Negative
  values are intentional according to the original publication. Changes in
  output are expected to be small and primarily occur at low irradiance
  conditions.
  (:issue:`1238`, :pull:`1239`)
* Pass weather data to solar position calculations in
  :py:meth:`~pvlib.modelchain.ModelChain.prepare_inputs_from_poa`.
  (:issue:`1065`, :pull:`1140`)
* Reindl model fixed to generate sky_diffuse=0 when GHI=0.
  (:issue:`1153`, :pull:`1154`)
* Fix floating point round-off issue in
  :py:func:`~pvlib.irradiance.aoi_projection` (:issue:`1185`, :pull:`1191`)
* Update GFS product names for GFS v16. (:issue:`1202`, :pull:`1203`)
* Take into account ``EgRef``, ``dEgdT``, ``irrad_ref`` and ``temp_ref`` when
  calling :py:func:`~pvlib.pvsystem.calcparams_cec`. (:issue:`1215`, :pull:`1216`)
* Corrected methodology error in :py:func:`~pvlib.scaling.wvm`. Tracks with
  fix in PVLib for MATLAB. (:issue:`1206`, :pull:`1213`)
* Corrected an error affecting :py:func:`~pvlib.clearsky.detect_clearsky`
  when data time step is not one minute. Error was introduced in v0.8.1.
  (:issue:`1241`, :pull:`1242`)
* Corrected error affecting :py:func:`~pvlib.scaling._compute_wavelet` when
  passing a pandas time series with a sampling rate faster than 1 second.
  (:issue:`1257`, :pull:`1258`)
* Changed deprecated use of ``.astype()`` to ``.view()`` in :py:mod:`~pvlib.solarposition`.
  (:pull:`1256`, :issue:`1261`, :pull:`1262`)
* Fix :py:func:`~pvlib.tracking.singleaxis` AOI wrong when sun behind module.
  (:pull:`1273`, :issue:`1221`)
* Fix :py:meth:`~pvlib.forecast.ForecastModel.get_data` failure to correct for
  non-UTC timezones. (:issue:`1237`, :pull:`1285`)
* Fixed :py:class:`~pvlib.forecast.HRRR` by changing model name to reflect change on the server. (:issue:`1291`,
  :pull:`1292`)

Testing
~~~~~~~
* Added ``__init__.py`` to ``pvlib/tests`` and subdirectories. This follows
  pytest recommendations for package layout and imports from ``conftest.py``.
  Solves issue with test discovery in vscode. (:pull:`1204`)

Documentation
~~~~~~~~~~~~~
* Update intro tutorial to highlight the use of historical meteorological data
  and to make the procedural and OO results match exactly. (:issue:`1116`, :pull:`1144`)
* Add a gallery example showing how to appropriately use interval-averaged
  weather data for modeling. (:pull:`1152`)
* Update documentation links in :py:func:`pvlib.iotools.get_psm3` (:pull:`1169`)
* Use ``Mount`` classes in ``introtutorial`` and ``pvsystem`` docs pages (:pull:`1267`)
* Clarified how statistics are calculated for :py:func:`pvlib.clearsky.detect_clearsky`
  (:issue:`1070`, :pull:`1243`)
* Add gallery examples using the new ``Mount`` classes (:pull:`1266`)
* Add "powered by pvlib" logos (:pull:`1277`)

Requirements
~~~~~~~~~~~~
* ``dataclasses`` is required for python 3.6 (:pull:`1076`)
* ``h5py`` is now a required dependency.  This replaces ``tables``, which was formerly
  an optional dependency.  (:pull:`1299`, :issue:`1252`, :issue:`1286`)

Contributors
~~~~~~~~~~~~
* Will Holmgren (:ghuser:`wholmgren`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Will Vining (:ghuser:`wfvining`)
* Anton Driesse (:ghuser:`adriesse`)
* Mark Mikofski (:ghuser:`mikofski`)
* Nate Croft (:ghuser:`ncroft-b4`)
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Adam R. Jensen (:ghuser:`AdamRJensen`)
* Joshua Stein (:ghuser:`jsstein`)
* Tony Lorenzo (:ghuser:`alorenzo175`)
* Damjan Postolovski (:ghuser:`dpostolovski`)
* Miguel Sánchez de León Peque (:ghuser:`Peque`)
* Joe Ranalli (:ghuser:`jranalli`)
* Chas Schweizer (:ghuser:`cpr-chas`)
* Yoann Louvet (:ghuser:`YoannUniKS`)
* Brandon Carpenter (:ghuser:`hashstat`)
* :ghuser:`kahemker`
* :ghuser:`zhammond147`
* :ghuser:`PeterGrant`
* :ghuser:`rockstaedt`
* :ghuser:`MichaelHopwood`
* :ghuser:`EricDuminil`
* :ghuser:`FeiYao-Edinburgh`
.. _whatsnew_0620:

v0.6.2 (May 15, 2019)
---------------------

This is a minor release. We recommend all users of v0.6.1 upgrade to this
release.

**Python 2.7 support will end on June 1, 2019**. Releases made after this
date will require Python 3. This release is likely to be the last that
supports Python 2.7. (:issue:`501`)

**Minimum pandas requirement bumped 0.15.0=>0.16.0**


API Changes
~~~~~~~~~~~
* :py:func:`~pvlib.irradiance.erbs` *doy* argument changed to
  *datetime_or_doy* to be consistent with allowed types and similar
  functions (:py:func:`~pvlib.irradiance.disc`,
  :py:func:`~pvlib.irradiance.get_extra_radiation`). (:issue:`681`)
* :py:func:`~pvlib.irradiance.erbs` DataFrame vs. OrderedDict return
  behavior now determined by type of *datetime_or_doy* instead of
  *ghi* or *zenith*. (:issue:`681`)
* Added *min_cos_zenith* and *max_zenith* keyword arguments to
  :py:func:`~pvlib.irradiance.erbs`. (:issue:`681`)
* Deprecated :py:meth:`~pvlib.modelchain.ModelChain.prepare_inputs`
  assumption of clear sky if no irradiance fields were provided.
  (:issue:`705`, :issue:`707`)
* Remove automatic column name mapping from :py:func:`~pvlib.iotools.read_midc`
  and :py:func:`~pvlib.iotools.read_midc_raw_data_from_nrel` and added
  optional keyword argument `variable_map` to map columns. (:issue:`721`)
* Update :py:func:`~pvlib.bifacial.pvfactors_timeseries` and tests to use
  ``pvfactors`` v1.0.1 (:issue:`699`)

Enhancements
~~~~~~~~~~~~
* Add US CRN data reader to :ref:`iotools`. (:issue:`666`)
* Add SOLRAD data reader to :ref:`iotools`. (:issue:`667`)
* Add EPW data reader to :ref:`iotools`. (:issue:`591`)
* Add PSM3 reader to :ref:`iotools`. (:issue:`592`)
* Improve ModelChain inference method error text. (:issue:`621`)

Bug fixes
~~~~~~~~~
* Compatibility with pandas 0.24 deprecations. (:issue:`659`)
* :py:func:`~pvlib.pvsystem.pvwatts_ac` raised ``ZeroDivisionError``
  when called with scalar ``pdc=0``
  and a ``RuntimeWarning`` for ``array(0)`` input. Now correctly returns
  0s of the appropriate type. (:issue:`675`)
* Fixed :py:func:`~pvlib.irradiance.erbs` behavior when zenith is
  near 90 degrees. (:issue:`681`)
* :py:func:`~pvlib.irradiance.dni` now referenced in API under
  Decomposing and Combining irradiance header. (:issue:`686`)
* Fixed NaN output from :py:func:`~pvlib.tracking.singleaxis` when sun
  near horizon. (:issue:`656`)
* Fixed numpy warnings in :py:func:`~pvlib.tracking.singleaxis` when
  comparing NaN values to limits. (:issue:`622`)
* Change ModelChain to apply ``pvwatts_losses`` to ``mc.dc`` instead of
  ``mc.ac``. (:issue:`696`)
* Fixed a bug in the day angle equation for the ASCE
  extraterrestrial irradiance model. (:issue:`211`)
* Silenced divide by 0 irradiance warnings in
  :py:func:`~pvlib.irradiance.klucher` and
  :py:func:`~pvlib.pvsystem.calcparams_desoto`. (:issue:`698`)
* Fix :py:class:`~pvlib.forecast.NDFD` model by updating variables.
* Fix :py:func:`~pvlib.iotools.srml.format_index` to parse non
  one-minute data correctly. (:issue:`709`)


Testing
~~~~~~~
* Remove most expected warnings emitted by test suite. (:issue:`698`)


Contributors
~~~~~~~~~~~~
* Cliff Hansen (:ghuser:`cwhanse`)
* Will Holmgren (:ghuser:`wholmgren`)
* Roel Loonen (:ghuser:`roelloonen`)
* Todd Hendricks (:ghuser:`tahentx`)
* Kevin Anderson (:ghuser:`kevinsa5`)
* :ghuser:`bentomlinson`
* :ghuser:`yxh289`
* Jonathan Gaffiot (:ghuser:`jgaffiot`)
* Leland Boeman (:ghuser:`lboeman`)
* Marc Anoma (:ghuser:`anomam`)
.. _whatsnew_0800:

v0.8.0 (September 8, 2020)
--------------------------

Breaking changes
~~~~~~~~~~~~~~~~
* The ``ivtools.py`` module has been reorganized into a subpackage and functions
  in ``ivtools.py`` have been renamed (:pull:`708`):

    - Functions for fitting diode models are now in :py:mod:`pvlib.ivtools.sdm`
    - :py:func:`pvlib.ivtools.fit_sdm_cec_sam` is now :py:func:`pvlib.ivtools.sdm.fit_cec_sam`
    - :py:func:`pvlib.ivtools.fit_sdm_desoto` is now :py:func:`pvlib.ivtools.sdm.fit_desoto`
    - Functions for fitting the single diode equation are now in :py:mod:`pvlib.ivtools.sde`
    - :py:func:`pvlib.ivtools.fit_sde_sandia` is now :py:func:`pvlib.ivtools.sde.fit_sandia_simple`

* Removed ``run_parallel_calculations`` and ``n_workers_for_parallel_calcs``
  from :py:func:`pvlib.bifacial.pvfactors_timeseries` inputs (:issue:`902`) (:pull:`934`)

* :py:func:`pvlib.iotools.read_tmy3` can now only read local data files because
  the NREL RREDC server hosting the TMY3 dataset has been retired. For
  fetching TMY data from NREL servers, :py:func:`pvlib.iotools.get_psm3` is
  now recommended to retrieve newer PSM3 data over the older TMY3 data.
  (:issue:`996`) (:pull:`1004`)

* The tkinter-based file selection dialog has been removed from
  :py:func:`pvlib.iotools.read_tmy2` and :py:func:`pvlib.iotools.read_tmy3`;
  the filepath is now a required parameter. (:pull:`1004`)

* Removed ``systemdef`` function from ``pvsystem.py``. This function was not
  used in pvlib and its output was not directly compatible with any pvlib
  function. See :py:func:`pvlib.iotools.read_tmy2`,
  :py:func:`pvlib.iotools.read_tmy3`, :py:meth:`pvlib.location.Location.from_tmy`, and
  :py:class:`pvlib.pvsystem.LocalizedPVSystem` for alternatives. (:issue:`965`)
  (:pull:`1008`)

* The following functions, methods, and arguments were deprecated in a previous
  release and have now been removed (:issue:`966`, :pull:`1033`):

    * ``pvsystem.PVSystem.ashraeiam``. Use :py:meth:`pvlib.pvsystem.PVSystem.get_iam`.
    * ``pvsystem.PVSystem.physicaliam``. Use :py:meth:`pvlib.pvsystem.PVSystem.get_iam`.
    * ``pvsystem.PVSystem.sapm_aoi_loss``. Use :py:meth:`pvlib.pvsystem.PVSystem.get_iam`.
    * ``pvsystem.ashraeiam``. Use :py:func:`pvlib.iam.ashrae`.
    * ``pvsystem.physicaliam``. Use :py:func:`pvlib.iam.physical`.
    * ``pvsystem.sapm_aoi_loss``. Use :py:func:`pvlib.iam.sapm`.
    * ``pvsystem.sapm_celltemp``. Use :py:func:`pvlib.temperature.sapm_cell`.
    * ``pvsystem.pvsyst_celltemp``. Use :py:func:`pvlib.temperature.pvsyst_cell`.
    * ``times`` keyword argument of
      :py:meth:`pvlib.modelchain.ModelChain.run_model`,
      :py:meth:`pvlib.modelchain.ModelChain.complete_irradiance`, and
      :py:meth:`pvlib.modelchain.ModelChain.prepare_inputs`.
      The index of the input DataFrame is used instead.
    * ``temp_model`` keyword argument of
      :py:meth:`pvlib.modelchain.ModelChain`. Use ``temperature_model`` instead.

Deprecations
~~~~~~~~~~~~
* Moved functions related to inverters from ``pvsystem.py`` to ``inverter.py``.
  Functions are renamed to follow a more consistent pattern, as follows (:pull:`886`):

    - ``pvlib.pvsystem.snlinverter`` is now :py:func:`pvlib.inverter.sandia`
    - ``pvlib.pvsystem.pvwatts_ac`` is now :py:func:`pvlib.inverter.pvwatts`
    - ``pvlib.pvsystem.adrinverter`` is now :py:func:`pvlib.inverter.adr`

* Argument ``ac_model`` for :py:class:`pvlib.modelchain.ModelChain` now accepts
  ``'sandia'``, ``'pvwatts'`` and ``'adr'`` for the inverter models.  (:pull:`886`)

* :py:class:`pvlib.pvsystem.PVSystem` ``module_type`` and ``racking_model`` now
  default to ``None``. This continues a deprecation of assuming SAPM values
  for cell temperature modeling. In this v0.8 release series, calling
  :py:meth:`pvlib.pvsystem.PVSystem.sapm_celltemp` without setting ``PVSystem.temperature_model_parameters``,
  or a valid combination of ``PVsystem.module_type`` and ``PVsystem.racking_model``, will cause
  ``PVSystem.temperature_model_parameters`` to be set to SAPM values for a
  glass/glass module in open racking and emit a warning. In v0.9, users must
  provide ``temperature_model_parameters`` or a valid combination of
  ``module_type`` and ``racking_model``. (:issue:`1030`, :pull:`1033`)

* Deprecated arbitrary keyword arguments for
  :py:class:`pvlib.location.Location`, :py:class:`pvlib.pvsystem.PVSystem`,
  :py:class:`pvlib.tracking.SingleAxisTracker`, and
  :py:class:`pvlib.modelchain.ModelChain`. Supplying arbitrary keyword
  to these objects will result in TypeErrors in v0.9. (:issue:`1029`, :pull:`1053`)

* ``pvlib.pvsystem.LocalizedPVSystem`` and ``pvlib.pvsystem.LocalizedSingleAxisTracker``
  are deprecated and will be removed in 0.9. Use
  :py:class:`pvlib.location.Location`, :py:class:`pvlib.pvsystem.PVSystem`,
  :py:class:`pvlib.tracking.SingleAxisTracker`, and
  :py:class:`pvlib.modelchain.ModelChain` instead.
  (:issue:`1029`, :pull:`1034`, :pull:`1053`)

Enhancements
~~~~~~~~~~~~
* Update :func:`~pvlib.bifacial.pvfactors_timeseries` to run with ``pvfactors`` v1.4.1 (:issue:`902`)(:pull:`934`)
* Add :py:func:`pvlib.iam.marion_diffuse` and
  :py:func:`pvlib.iam.marion_integrate` to calculate IAM values for
  diffuse irradiance. (:pull:`984`)
* Add :py:func:`pvlib.shading.sky_diffuse_passias`,
  :py:func:`pvlib.shading.masking_angle_passias`, and
  :py:func:`pvlib.shading.masking_angle` to model diffuse shading loss.
  (:pull:`1017`)
* Add :py:func:`pvlib.inverter.fit_sandia` that fits the Sandia inverter model
  to a set of inverter efficiency curves. (:pull:`1011`)
* Add :py:func:`pvlib.ivtools.sdm.fit_pvsyst_sandia` and :py:func:`pvlib.ivtools.sdm.fit_desoto_sandia`
  for fitting the Pvsyst and De Soto models to IV curve data (:issue:`227`)(:pull:`708`)
* Add factory methods :py:meth:`~pvlib.modelchain.ModelChain.with_pvwatts`
  :py:meth:`~pvlib.modelchain.ModelChain.with_sapm` to create ``ModelChain``
  objects configured for the respective modeling paradigms. The
  configurations are defined in ``modelchain.PVWATTS_CONFIG``, and
  ``modelchain.SAPM_CONFIG``. (:issue:`1013`, :pull:`1022`)
* Added ``racking_model``, ``module_type``, and ``temperature_model_parameters`` to
  :py:class:`~pvlib.pvsystem.PVSystem` and :py:class:`~pvlib.tracking.SingleAxisTracker`
  repr methods. (:issue:`1027`)
* Added :py:func:`~pvlib.tracking.calc_axis_tilt` to calculate the
  tracker axes tilt and :py:func:`~pvlib.tracking.calc_cross_axis_tilt` to
  calculate the cross-axis tilt, which is the angle, relative to horizontal, of
  the line formed by the intersection between the slope containing the tracker
  axes and a plane perpendicular to the tracker axes. (:pull:`823`)
* Added ``cross_axis_tilt`` argument to :py:func:`~pvlib.tracking.singleaxis`
  and :py:func:`~pvlib.tracking.SingleAxisTracker` which defaults to zero. Use
  :py:func:`~pvlib.tracking.calc_cross_axis_tilt` to calculate the cross-axis
  tilt angle if necessary. (:pull:`823`)
* Added ability for :py:func:`pvlib.soiling.hsu` to accept arbitrary time intervals. (:pull:`980`)
* Added :py:func:`pvlib.temperature.fuentes` for cell temperature modeling. (:pull:`1037`)
* Add :py:func:`pvlib.pvsystem.combine_loss_factors` as general purpose
  function to combine loss factors with a common index.
  Partialy addresses :issue:`988`. Contributed by Brock Taute :ghuser:`btaute`
* Add capability to run a ModelChain starting with plane-of-array or effective
  irradiance, or with back-of-module or cell temperature data. New methods are
  :py:meth:`pvlib.modelchain.ModelChain.run_model_from_poa`,
  :py:meth:`pvlib.modelchain.ModelChain.run_model_from_effective_irradiance`,
  and :py:meth:`pvlib.modelchain.ModelChain.prepare_inputs_from_poa` (:issue:`536`, :pull:`943`)

Bug fixes
~~~~~~~~~
* Fixed unit and default value errors in :py:func:`pvlib.soiling.hsu`. (:pull:`977`, :pull:`980`)
* Handle NUL characters and fix version column dtype in
  :py:func:`~pvlib.iotools.read_crn`. (:issue:`1025`)
* Fix low sun angle tracker rotation calculation. (:issue:`824`)
* Fix issue with big-endian and little-endian data in ``forecast.py``.
  (:issue:`921`)

Testing
~~~~~~~
* Decorator :py:func:`pvlib.conftest.fail_on_pvlib_version` can now be
  applied to functions that require args or kwargs. (:pull:`973`)
* Test added for :py:class:`pvlib.modelchain.ModelChain` to confirm ValueError when
  ``ac_model`` is an invalid string. (:pull:`886`)
* Add minimum requirements configuration to Azure Pipelines build.
  (:pull:`1006`)
* Update the `data/test_psm3_tmy-2017.csv` datafile to match the updated
  NSRDB data. (:issue:`1005`, :pull:`1007`)
* Add wrappers around the pandas assert_X_equal functions to accommodate the
  changed API and default precision thresholds in pandas 1.1.0
  (:issue:`1018`, :pull:`1021`)
* Add github action for publishing tags to
  `pypi.org <https://pypi.org/project/pvlib/>`_.
  (:issue:`950`, :pull:`1038`, :pull:`1039`)
* Remove Travis CI configuration. (:issue:`950`)

Documentation
~~~~~~~~~~~~~
* Improved formatting and content of docstrings in :py:mod:`pvlib.atmosphere`.
  (:pull:`969`)
* Fix LaTeX rendering in :py:func:`pvlib.singlediode.bishop88`. (:pull:`967`)
* Clarify units for heat loss factors in
  :py:func:`pvlib.temperature.pvsyst_cell` and
  :py:func:`pvlib.temperature.faiman`. (:pull:`960`)
* Added hsu soiling model example to the gallery.  (:pull:`990`)
* Add make.bat so that docs can be built on Windows without ``make`` installed.
  (:issue:`978`, :pull:`981`)
* Add instructions to build the documentation. (:pull:`982`)
* Corrected key names for :py:func:`pvlib.inverter.sandia`. (:issue:`976`,
  :pull:`886`)
* Add a transposition gain example to the gallery.  (:pull:`979`)
* Add a gallery example of calculating diffuse IAM using
  :py:func:`pvlib.iam.marion_diffuse`. (:pull:`984`)
* Add a gallery example of modeling diffuse shading loss. (:pull:`1017`)
* Add minigalleries to API reference pages. (:pull:`991`)

Requirements
~~~~~~~~~~~~
* Python 3.6 or greater. (:pull:`1035`)
* Minimum pandas version increased to v0.22.0, released Dec 31, 2017. (:pull:`1003`)
* Scipy >= v1.2.0, released Dec 17, 2018, is now a required dependency
  rather an optional dependency. (:issue:`972`, :pull:`1035`)

Contributors
~~~~~~~~~~~~
* Cliff Hansen (:ghuser:`cwhanse`)
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Mark Mikofski (:ghuser:`mikofski`)
* Joshua S. Stein (:ghuser:`jsstein`)
* Marc A. Anoma (:ghuser:`anomam`)
* Will Holmgren (:ghuser:`wholmgren`)
* Brock Taute (:ghuser:`btaute`)
* Cameron Stark (:ghuser:`CameronTStark`)
* :ghuser:`kahemker`
* Miguel Sánchez de León Peque (:ghuser:`Peque`)
* Stephen Lightfoote (:ghuser:`srlightfoote`)
﻿.. _whatsnew_0700:

v0.7.0 (December 18, 2019)
--------------------------

This is a major release that drops support for Python 2 and Python 3.4. We
recommend all users of v0.6.3 upgrade to this release after checking API
compatibility notes.

**Python 2.7 support ended on June 1, 2019.** (:issue:`501`)
**Minimum numpy version is now 1.12.0. Minimum pandas version is now 0.18.1.** (:issue:`830`, :issue:`748`)

API Breaking Changes
~~~~~~~~~~~~~~~~~~~~
* The `effective_irradiance` argument for :py:func:`pvsystem.sapm` now requires
  units of W/m^2. Previously, units for this input were suns. A RuntimeWarning
  warning is raised if all `effective_irradiance < 2.0`.
* The output of :py:func:`pvsystem.sapm_effective_irradiance` is now in units
  of W/m2 rather than suns.
* Calling :py:func:`pvlib.pvsystem.retrieve_sam` with no parameters will raise
  an exception instead of displaying a dialog.
* The `modelchain.ModelChain.diode_params` attribute is now formatted in
  a pandas.DataFrame with `DatetimeIndex`, rather than in a tuple.
* ``PVSystem.pvwatts_ac`` now uses inverter DC input limit
  ``PVSystem.inverter_parameters['pdc0']`` instead of module nameplate
  capacity ``PVSystem.module_parameters['pdc0']``. (:issue:`734`)
* ``ModelChain.infer_ac_model`` now uses the presence of the key ``'pdc0'``
  ``PVSystem.inverter_parameters`` to determine if the `pvwatts_ac`
  inverter model should be used. The inference method previously looked
  for the key in ``PVSystem.module_parameters``. (:issue:`734`)

API Changes with Deprecations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Changes related to cell temperature models (:issue:`678`):
   * Changes to functions
      - Moved functions for cell temperature from `pvsystem.py` to `temperature.py`.
      - Renamed `pvsystem.sapm_celltemp` and `pvsystem.pvsyst_celltemp`
        to `temperature.sapm_cell` and `temperature.pvsyst_cell`.
      - `temperature.sapm_cell` returns only the cell temperature, whereas the
        old `pvsystem.sapm_celltemp` returned a `DataFrame` with both cell and module temperatures.
      - Created `temperature.sapm_module` to return module temperature using the SAPM temperature model.
      - Changed the order of arguments for `pvsystem.sapm_celltemp`,
        `pvsystem.pvsyst_celltemp` and `PVSystem.sapm_celltemp` to be consistent
        among cell temperature model functions.
      - Removed `model` as a kwarg from `temperature.sapm_cell` and
        `temperature.pvsyst_cell`. These functions now require model-specific parameters.
      - Added the argument `irrad_ref`, default value 1000, to `temperature.sapm_cell`.
   * Changes to named temperature model parameter sets
      - Renamed `pvsystem.TEMP_MODEL_PARAMS` to `temperature.TEMPERATURE_MODEL_PARAMETERS`.
      - `temperature.TEMPERATURE_MODEL_PARAMETERS` uses dict rather than
        tuple for a parameter set.
      - Names for parameter sets in `temperature.TEMPERATURE_MODEL_PARAMETERS` have changed.
      - Parameter sets for the SAPM cell temperature model named
        'open_rack_polymer_thinfilm_steel' and '22x_concentrator_tracker'
        are considered obsolete and have been removed.
   * Changes to `PVSystem` class
      - Changed the `model` kwarg in `PVSystem.sapm_celltemp` and
        `PVSystem.pvsyst_celltemp` to `parameter_set`. `parameter_set` expects
        a str which is a valid key for `temperature.TEMPERATURE_MODEL_PARAMETERS`
        for the corresponding temperature model.
      - Added an attribute `PVSystem.module_type` (str) to record module
        front and back materials, default is `glass_polymer`.
      - Changed meaning of `PVSystem.racking_model` to describe racking
        only, e.g., default is `open_rack`.
      - Added an attribute `PVSystem.temperature_model_parameters` (dict).
        to contain temperature model parameters.
      - If `PVSystem.temperature_model_parameters` is not specified and
        `PVSystem.racking_model` and `PVSystem.module_type` combine to a valid
        parameter set name for the SAPM cell temperature model, that parameter
        set is assigned to `PVSystem.temperature_model_parameters`. Otherwise
        `PVSystem.temperature_model_parameters` is assigned an empty dict. The
        result is that the default parameter set for SAPM cell temperature model
        is `open_rack_glass_polymer`; the old default was `open_rack_glass_glass`.
   * Changes to `ModelChain` class
      - `ModelChain.temp_model` renamed to `ModelChain.temperature_model`.
      - `ModelChain.temperature_model` now defaults to `None`. The temperature
        model can be inferred from `PVSystem.temperature_model_parameters`.
      - `ModelChain.temperature_model_parameters` now defaults to `None`. The temperature
        model can be inferred from `PVSystem.temperature_model_parameters`.
      - `ModelChain.temps` attribute renamed to `ModelChain.cell_temperature`,
        and its datatype is now `numeric` rather than `DataFrame`.
      - If `PVSystem.temperature_model_parameters` is not specified, `ModelChain`
        defaults to old behavior, using the SAPM temperature model with parameter
        set `open_rack_glass_glass`. This behavior is deprecated, and will be
        removed in v0.8. In v0.8 `PVSystem.temperature_model_parameters` will
        be required for `ModelChain`.
      - Implemented `pvsyst` as an option for `ModelChain.temperature_model`.
      - `modelchain.basic_chain` has a new required argument
        `temperature_model_parameters`.

* Changes related to IAM (AOI loss) functions (:issue:`680`):
   * Changes to functions
      - Moved functions from `pvsystem.py` to `iam.py`. `pvsystem` IAM
        functions are deprecated and will be removed in v0.8.
      - Functions are renamed to a consistent pattern:
         - `pvsystem.physicaliam` is `iam.physical`
         - `pvsystem.ashraeiam` is `iam.ashrae`
         - `pvsystem.sapm_aoi_loss` is `iam.sapm`
   * Changes to `PVSystem` class
      - IAM models are provided by `PVSystem.get_iam` with kwarg `iam_model`.
      - Methods `PVSystem.ashraeiam`, `PVSystem.physicaliam` and
        `PVSystem.sapm_aoi_loss` are deprecated and will be removed in v0.8.

* Changes related to spectral modifier (:issue:`782`):
   * Changes to functions
      - Added the argument `pw_min` and `pw_max`, default values 0.1 and 8 resp.,
	to `atmosphere.first_solar_spectral_correction`. This function now returns NaN
	if pw value higher than `pw_max`.
* The `times` keyword argument has been deprecated in the
  :py:meth:`pvlib.modelchain.ModelChain.run_model`,
  :py:meth:`pvlib.modelchain.ModelChain.prepare_inputs`, and
  :py:meth:`pvlib.modelchain.ModelChain.complete_irradiance` methods.
  Model times are now determined by the input `weather`. `DataFrame`.
  Therefore, the `weather` DataFrame must have a `DatetimeIndex`.
  The `weather` argument of the above methods is now the first, required
  positional argument and the `times` argument is kept as the second keyword
  argument for capability during the deprecation period.
* Parameter `pvsystem.DC_MODEL_PARAMS` is renamed to `pvsystem._DC_MODEL_PARAMS`.
  Users should not rely on this dictionary's existence or structure.

Other API Changes
~~~~~~~~~~~~~~~~~
* :py:func:`pvlib.iotools.midc.read_midc` now passes additional keyword
  arguments to `pandas.read_csv`
* Add `timeout` argument to :py:func:`pvlib.iotools.midc.read_midc_raw_data_from_nrel`
* :py:mod:`pvlib.bifacial` is now imported when ``pvlib`` is imported.
  (:issue:`766`)

Enhancements
~~~~~~~~~~~~
* Created one new temperature model function:
  :py:func:`pvlib.temperature.faiman`. (:issue:`750`)
* Created two new incidence angle modifier (IAM) functions:
  :py:func:`pvlib.iam.martin_ruiz` and :py:func:`pvlib.iam.interp`. (:issue:`751`)
* Created one new incidence angle modifier (IAM) function for diffuse irradiance:
  :py:func:`pvlib.iam.martin_ruiz_diffuse`. (:issue:`751`)
* Add the `martin_ruiz` IAM function as an option for `ModelChain.aoi_model`.
* Updated the file for module parameters for the CEC model, from the SAM file
  dated 2017-6-5 to the SAM file dated 2019-03-05. (:issue:`761`)
* Updated the file for inverter parameters for the CEC model, from the SAM file
  dated 2018-3-18 to the SAM file dated 2019-03-05. (:issue:`761`)
* Added recombination current parameters to bishop88 single-diode functions and also
  to :py:func:`pvlib.pvsystem.max_power_point`. (:issue:`762`)
* Add `ivtools` module to contain functions for IV model fitting.
* Add :py:func:`~pvlib.ivtools.fit_sde_sandia`, a simple method to fit
  the single diode equation to an IV curve.
* Add :py:func:`~pvlib.ivtools.fit_sdm_cec_sam`, a wrapper for the CEC single
  diode model fitting function '6parsolve' from NREL's System Advisor Model.
* Add :py:func:`~pvlib.ivtools.fit_sdm_desoto`, a method to fit the De Soto single
  diode model to the typical specifications given in manufacturers datasheets.
* Add `timeout` to :py:func:`pvlib.iotools.get_psm3`.
* Add :py:func:`~pvlib.scaling.wvm`, a port of the wavelet variability model for
  computing reductions in variability due to a spatially distributed plant.
* Add :py:meth:`~pvlib.location.Location.from_epw`, a method to create a Location
  object from epw metadata, typically coming from `pvlib.iotools.epw.read_epw`.

Bug fixes
~~~~~~~~~
* Fix handling of keyword arguments in `forecasts.get_processed_data`.
  (:issue:`745`)
* Fix output as Series feature in :py:func:`pvlib.pvsystem.ashraeiam`.
* Fix rounding issue in `clearsky._linearly_scale`, a function that converts
  longitude or latitude degree to an index number in a Linke turbidity lookup
  table. Also rename the function to `clearsky._degrees_to_index`.
  (:issue:`754`)
* Fix reading raw MIDC CSV files from NREL where the number of header
  columns does not match the number of data columns.
* Fix installation issue due to missing ``requests`` dependency.
  (:issue:`725`)
* ``PVSystem.pvwatts_ac`` now uses inverter DC input limit
  ``PVSystem.inverter_parameters['pdc0']`` instead of module nameplate
  capacity ``PVSystem.module_parameters['pdc0']``. (:issue:`734`)

Testing
~~~~~~~
* Added 30 minutes to timestamps in `test_psm3.csv` to match change
  in NSRDB (:issue:`733`)
* Added tests for methods in bifacial.py.
* Added tests for changes to cell temperature models.
* Add tests configuration for bare python environment (no conda).
  (:issue:`727`)
* Added tests for changes to IAM models.
* Added test for `ModelChain.infer_aoi_model`.

Documentation
~~~~~~~~~~~~~
* Corrected docstring for `pvsystem.PVSystem.sapm`
* Fixed broken ipython examples from CEC data updates
* Edited docstring for `pvsystem.sapm` to remove DataFrame option for input
  `module`. The DataFrame option was never tested and would cause an error if
  used. (:issue:`785`)
* Note warning about _TMY3.epw files retrieved from energyplus.net in docstring
  of `epw.read_epw`
* Improved sphinx rendering of API reference entries for `clearsky.ineichen`,
  `clearsky.haurwitz`, `tracking.singleaxis`, `iotools.read_midc`,
  `Location.from_tmy`, `ModelChain.run_model`, `ModelChain.complete_irradiance`,
  and `ModelChain.prepare_inputs`
* Removed duplicate `pvwatts_losses` entry in `api.rst`

Removal of prior version deprecations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Removed `irradiance.extraradiation`.
* Removed `irradiance.grounddiffuse`.
* Removed `irradiance.total_irrad`.
* Removed `irradiance.globalinplane`.
* Removed `atmosphere.relativeairmass`.
* Removed `atmosphere.relativeairmass`.
* Removed `solarposition.get_sun_rise_set_transit`.
* Removed `tmy` module.
* Removed `ModelChain.singlediode` method.
* Removed `ModelChain.prepare_inputs` clearsky assumption when no irradiance
  data was provided.

Requirements
~~~~~~~~~~~~
* numpy minimum increased to v1.12.0, released in 2017. (:issue:`830`)
* pandas minimum increased to v1.18.1, released in 2016. (:issue:`748`)

Contributors
~~~~~~~~~~~~
* Mark Campanellli (:ghuser:`markcampanelli`)
* Will Holmgren (:ghuser:`wholmgren`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Oscar Dowson (:ghuser:`odow`)
* Anton Driesse (:ghuser:`adriesse`)
* Alexander Morgan (:ghuser:`alexandermorgan`)
* Miguel Sánchez de León Peque (:ghuser:`Peque`)
* Tanguy Lunel (:ghuser:`tylunel`)
* Veronica Guo (:ghuser:`veronicaguo`)
* Joseph Ranalli (:ghuser:`jranalli`)
* Tony Lorenzo (:ghuser:`alorenzo175`)
* Todd Karin (:ghuser:`toddkarin`)
* Mark Mikofski (:ghuser:`mikofski`)
* Kevin Anderson (:ghuser:`kevinsa5`)
* Cameron Stark (:ghuser:`camerontstark`)
* Janine Freeman (:ghuser:`janinefreeman`)
* Roel Loonen (:ghuser:`roelloonen`)
* Birgit Schachler (:ghuser:`birgits`)
* Hamilton Kibbe (:ghuser:`hamiltonkibbe`)
* Adam Peretti (:ghuser:`aperetti`)
* Cedric Leroy (:ghuser:`cedricleroy`)
* Joseph Palakapilly (:ghuser:`JPalakapillyKWH`)
* (:ghuser:`shall-resurety`)
.. _whatsnew_0600:

v0.6.0 (September 17, 2018)
---------------------------

This is a major release and contains a large number of API changes, new
features, and bug fixes. Users should carefully read the changelog below
before upgrading.

**Python 2.7 support will end on June 1, 2019**. Releases made after this
date will require Python 3. (:issue:`501`)


API Changes
~~~~~~~~~~~
* pvlib python is changing a handful of function names. In general, functions
  that can calculate a quantity using multiple algorithms now start
  with the prefix ``get_``. For example, ``relativeairmass`` can calculate
  airmass using one of many ``model`` arguments. Its name has been changed
  to :func:`~pvlib.atmosphere.get_relative_airmass`. The old function names remain in this
  release, but will emit a ``PVLibDeprecationWarning`` when called. The
  old functions will be removed in the v0.7 release. Functions composed
  of multiple words jammed together have been renamed with underscores
  separating the words (see above).
  Each change is detailed below. (:issue:`427`)
* Deprecated ``relativeairmass``; it will be removed in v0.7.
  Use the new :func:`~pvlib.atmosphere.get_relative_airmass` instead. (:issue:`427`)
* Deprecated ``absoluteairmass``; it will be removed in v0.7.
  Use the new :func:`~pvlib.atmosphere.get_absolute_airmass` instead. (:issue:`427`)
* Deprecated ``irradiance.globalinplane``; it will be removed in v0.7.
  Use the new :func:`~pvlib.irradiance.poa_components` instead. (:issue:`427`)
* Added :func:`~pvlib.irradiance.poa_components`. Function is the same as the now-deprecated
  ``irradiance.globalinplane``, but adds ``'poa_sky_diffuse'`` and
  ``'poa_ground_diffuse'`` to the output. (:issue:`427`)
* Deprecated ``irradiance.extraradiation``; it will be removed in v0.7.
  Use :func:`pvlib.irradiance.get_extra_radiation` instead. (:issue:`427`)
* Deprecated ``irradiance.grounddiffuse``; it will be removed in v0.7. Use
  :func:`~pvlib.irradiance.get_ground_diffuse` instead. (:issue:`427`)
* Added :func:`~pvlib.irradiance.get_poa_sky_diffuse`. (:issue:`427`)
* Deprecated ``irradiance.total_irrad``; it will be removed in v0.7. Use
  :func:`~pvlib.irradiance.get_total_poa_irradiance` instead. (:issue:`427`)
* Removed ``'klutcher'`` from ``get_sky_diffuse``/``total_irrad``. This misspelling was
  deprecated long ago but never removed. (:issue:`97`)
* :func:`~pvlib.pvsystem.calcparams_desoto` now requires arguments for each module model
  parameter. (:issue:`462`)
* Add losses_parameters attribute to PVSystem objects and remove the kwargs
  support from PVSystem.pvwatts_losses. Enables custom losses specification
  in ModelChain calculations. (:issue:`484`)
* removed irradiance parameter from ModelChain.run_model and ModelChain.prepare_inputs
* Add ``perez_enhancement`` keyword argument to clearsky.ineichen to control
  whether or not the "perez enhancement factor" is applied. The enhancement
  factor was always applied until now. Now it is turned off by default. The
  enhancement factor can yield unphysical results, especially for latitudes
  closer to the poles and especially in the winter months. It may yield
  improved results under other conditions. (:issue:`435`)
* Add min_cos_zenith, max_zenith keyword arguments to disc, dirint, and
  dirindex functions. (:issue:`311`, :issue:`396`)
* Method ModelChain.infer_dc_model now returns a tuple (function handle, model name string)
  instead of only the function handle (:issue:`417`)
* Add DC model methods desoto and pvsyst to ModelChain, and deprecates DC model method
  singlediode (singlediode defaults to desoto until v0.7.0) (:issue:`487`)
* Add the CEC module model in pvsystem.calcparams_cec and ModelChain.cec. The CEC model
  differs from the desoto model by using the parameter Adjust. Modules selected from
  the SAM CEC library sam-library-cec-modules-2017-6-5.csv include the Adjust parameter
  and ModelChain.infer_dc_model will now select the cec model rather than the desoto model.
  (:issue:`463`)
* The behavior of irradiance.perez(return_components=True) has changed.
  The function previously returned a tuple of total sky diffuse and
  an OrderedDict/DataFrame of components. The function now returns
  an OrderedDict/DataFrame with total sky diffuse and each component.
  The behavior for return_components=False remains unchanged. (:issue:`434`)


Enhancements
~~~~~~~~~~~~
* Add sea surface albedo in ``irradiance.py`` (:issue:`458`)
* Implement :meth:`~pvlib.modelchain.ModelChain.first_solar_spectral_loss`
  in ``modelchain.py`` (:issue:`359`)
* Clarify arguments ``Egref`` and ``dEgdT`` for
  :func:`~pvlib.pvsystem.calcparams_desoto` (:issue:`462`)
* Add pvsystem.calcparams_pvsyst to compute values for the single diode equation
  using the PVsyst v6 model (:issue:`470`)
* Extend :func:`~pvlib.pvsystem.singlediode` with an additional keyword argument
  ``method`` in ``('lambertw', 'newton', 'brentq')``, default is ``'lambertw'``,
  to select a method to solve the single diode equation for points on the IV
  curve. Selecting either ``'brentq'`` or ``'newton'`` as the method uses
  :func:`~pvlib.singlediode.bishop88` with the corresponding method.
  (:issue:`410`)
* Implement new methods ``'brentq'`` and ``'newton'`` for solving the single
  diode equation for points on the IV curve. ``'brentq'`` uses a bisection
  method (Brent, 1973) that may be slow but guarantees a solution. ``'newton'``
  uses the Newton-Raphson method and may be faster but is not guaranteed to
  converge. However, ``'newton'`` should be safe for well-behaved IV curves.
  (:issue:`408`)
* Implement :func:`~pvlib.singlediode.bishop88` for explicit calculation
  of arbitrary IV curve points using diode voltage instead of cell voltage. If
  ``method`` is either ``'newton'`` or ``'brentq'`` and ``ivcurve_pnts`` in
  :func:`~pvlib.pvsystem.singlediode` is provided, the IV curve points will be
  log spaced instead of linear.
* Implement :func:`~pvlib.singlediode.estimate_voc` to estimate open
  circuit voltage by assuming :math:`R_{sh} \to \infty` and :math:`R_s=0` as an
  upper bound in bisection method for :func:`~pvlib.pvsystem.singlediode` when
  method is either ``'newton'`` or ``'brentq'``.
* Add :func:`~pvlib.pvsystem.max_power_point` method to compute the max power
  point using the new ``'brentq'`` method.
* Add new module ``pvlib.singlediode`` with low-level functions for
  solving the single diode equation such as:
  :func:`~pvlib.singlediode.bishop88`,
  :func:`~pvlib.singlediode.estimate_voc`,
  :func:`~pvlib.singlediode.bishop88_i_from_v`,
  :func:`~pvlib.singlediode.bishop88_v_from_i`, and
  :func:`~pvlib.singlediode.bishop88_mpp`.
* Add PVSyst thin-film recombination losses for CdTe and a:Si (:issue:`163`)
* Python 3.7 officially supported. (:issue:`496`)
* Improve performance of solarposition.ephemeris. (:issue:`512`)
* Improve performance of Location.get_airmass. Most noticeable when
  solar position is supplied, time index length is less than 10000, and
  method is looped over. (:issue:`502`)
* Add irradiance.gti_dirint function. (:issue:`396`)
* Add irradiance.clearness_index function. (:issue:`396`)
* Add irradiance.clearness_index_zenith_independent function. (:issue:`396`)
* Add checking for consistency between module_parameters and dc_model. (:issue:`417`)
* Add DC model methods ``'desoto'`` and ``'pvsyst'`` to ModelChain (:issue:`487`)
* Add the CEC module model in `pvsystem.calcparams_cec` and `ModelChain.cec`. (:issue:`463`)
* Add DC model methods desoto and pvsyst to ModelChain (:issue:`487`)
* pvlib now ships with a pvlib[optional] installation option to automatically
  install packages needed to support additional pvlib features:
  ``pip install pvlib[optional]``. Additional installation options include
  `doc` (requirements for minimal documentation build), `test` (requirements
  for testing), and `all` (optional + doc + test). (:issue:`553`, :issue:`483`)
* Set default alpha to 1.14 in :func:`~pvlib.atmosphere.angstrom_aod_at_lambda` (:issue:`563`)
* tracking.singleaxis now accepts scalar and 1D-array input.


Bug fixes
~~~~~~~~~
* Unset executable bits of irradiance.py and test_irradiance.py (:issue:`460`)
* Fix failing tests due to column order on Python 3.6+ and Pandas 0.23+
  (:issue:`464`)
* ModelChain.prepare_inputs failed to pass solar_position and airmass to
  Location.get_clearsky. Fixed. (:issue:`481`)
* Add User-Agent specification to TMY3 remote requests to avoid rejection.
  (:issue:`493`)
* Fix ``pvlib.irradiance.klucher`` output is different for Pandas Series vs.
  floats and NumPy arrays. (:issue:`508`)
* Make GitHub recognize the license, add AUTHORS.md, clarify shared copyright.
  (:issue:`503`)
* Fix issue with non-zero direct irradiance contribution to Reindl, Klucher,
  and Hay-Davies diffuse sky algorithms when the sun is behind the array.
  (:issue:`526`)
* Fix issue with dividing by near-0 cos(solar_zenith) values in Reindl and
  Hay-Davies diffuse sky algorithms. (:issue:`432`)
* Fix argument order of longitude and latitude when querying weather forecasts
  by lonlat bounding box (:issue:`521`)
* Fix issue with unbounded clearness index calculation in disc. (:issue:`540`)
* Limit pvwatts_ac results to be greater than or equal to 0. (:issue:`541`)
* Fix bug in get_relative_airmass(model='youngirvine1967'). (:issue:`545`)
* Fix bug in variable names returned by forecast.py's HRRR_ESRL model.
  (:issue:`557`)
* Fixed bug in tracking.singleaxis that mistakenly assigned nan values when
  the Sun was still above the horizon. No effect on systems with axis_tilt=0.
  (:issue:`569`)
* Source distribution did not contain LICENSE file. Added LICENSE, AUTHORS.md,
  and some docs to MANIFEST. (:issue:`579`)
* Patch SPA C-files to fix timezone macro name clash with `pyconfig.h`. (:issue:`168`)


Documentation
~~~~~~~~~~~~~
* Expand testing section with guidelines for functions, PVSystem/Location
  objects, and ModelChain.
* Updated several incorrect statements in ModelChain documentation regarding
  implementation status and default values. (:issue:`480`)
* Expanded general contributing and pull request guidelines.
* Added section on single diode equation with some detail on solutions used in
  pvlib-python (:issue:`518`)
* Minor improvements and updates to installation documentation. (:issue:`531`)
* Improve LocalizedPVSystem and LocalizedSingleAxisTracker documentation.
  (:issue:`532`)
* Move the "Getting Started"/"Modeling Paradigms" section to a new
  top-level "Intro Examples" page.
* Copy pvlib documentation's "Getting support" section to README.md.
* Add PVSystem documentation page. (:issue:`514`, :issue:`319`)
* Add example of Kasten Linke Turbidity calculation, discuss broadband AOD and
  Angstrom Turbidity Model. (:issue:`302`)
* Add JOSS paper to "Citing pvlib-python" section.


Testing
~~~~~~~
* Add pytest-mock dependency
* Use pytest-mock to ensure that PVSystem and ModelChain methods call
  corresponding functions correctly. Removes implicit dependence on precise
  return values of some function/methods. (:issue:`394`)
* Additional test refactoring to limit test result dependence to a single
  function per test. (:issue:`394`)
* Use pytest-mock to ensure that ModelChain DC model is set up correctly.
* Add Python 3.7 to build matrix
* Make test_forecast.py more robust. (:issue:`293`)
* Improve test_atmosphere.py. (:issue:`158`)
* Add LGTM.com integration. (:issue:`554`)
* Add SticklerCI integration.
* Add codecov integration.


Contributors
~~~~~~~~~~~~
* Will Holmgren (:ghuser:`wholmgren`)
* Yu Cao (:ghuser:`tsaoyu`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Mark Mikofski (:ghuser:`mikofski`)
* Alan Mathew (:ghuser:`alamathe1`)
* Xavier Rene-Corail (:ghuser:`xcorail`)
* Anton Driesse (:ghuser:`adriesse`)
* Mark Campanelli (:ghuser:`thunderfish24`)
* Cedric Leroy (:ghuser:`cedricleroy`)
* Jessica Forbess (:ghuser:`jforbess`)
* Jeff Newmiller (:ghuser:`jdnewmil`)
* :ghuser:`josricha`
* Marc A. Anoma (:ghuser:`anomam`)
* William C Grisaitis (:ghuser:`grisaitis`)
* Karel De Brabandere (:ghuser:`kdebrab`)
* :ghuser:`tadatoshi`.. _whatsnew_0630:

v0.6.3 (May 15, 2019)
---------------------

This is a minor release on top of v0.6.2 to fix an installation issue.
We recommend that all users of v0.6.1 and v0.6.2 upgrade to this release.

**Python 2.7 support will end on June 1, 2019**. Releases made after this
date will require Python 3. This release is likely to be the last that
supports Python 2.7. (:issue:`501`)


Bug fixes
~~~~~~~~~
* Fix installation issue due to missing ``requests`` dependency.
  (:issue:`725`)


Contributors
~~~~~~~~~~~~
* Will Holmgren (:ghuser:`wholmgren`)
.. _whatsnew_0500:

v0.5.0 (August 11, 2017)
------------------------

API Changes
~~~~~~~~~~~
* Removed parameter w from _calc_d (:issue:`344`)
* SingleAxisTracker.get_aoi and SingleAxisTracker.get_irradiance
  now require surface_zenith and surface_azimuth (:issue:`351`)
* Changes calculation of the Incidence Angle Modifier to return 0
  instead of np.nan for angles >= 90°. This improves the calculation of
  effective irradiance close to sunrise and sunset. (:issue:`338`)
* Change the default ModelChain orientation strategy from
  'south_at_latitude_tilt' to ``None``. (:issue:`290`)

Bug fixes
~~~~~~~~~
* Method of multi-inheritance has changed to make it possible to use kwargs in
  the parent classes of LocalizedPVSystem and LocalizedSingleAxisTracker
  (:issue:`330`)
* Fix the `__repr__` method of `ModelChain`, crashing when
  `orientation_strategy` is set to `'None'` (:issue:`352`)
* Fix the `ModelChain`'s angle of incidence calculation for
  SingleAxisTracker objects (:issue:`351`)
* Fix issue with ForecastModel.cloud_cover_to_transmittance_linear method of
  forecast.py ignoring 'offset' parameter. (:issue:`343`)

Enhancements
~~~~~~~~~~~~
* Added default values to docstrings of all functions (:issue:`336`)
* Added analytical method that calculates solar azimuth angle (:issue:`291`)

Documentation
~~~~~~~~~~~~~
* Added ModelChain documentation page
* Added nbsphinx to documentation build configuration.
* Added a pull request template file (:issue:`354`)

Testing
~~~~~~~
* Added explicit tests for aoi and aoi_projection functions.
* Update test of `ModelChain.__repr__` to take in account :issue:`352`
* Added a test for solar_azimuth_analytical function.

Contributors
~~~~~~~~~~~~
* Johannes Kaufmann
* Will Holmgren
* Uwe Krien
* Alaina Kafkes
* Birgit Schachler
* Jonathan Gaffiot
* Siyan (Veronica) Guo
* KonstantinTr
.. _whatsnew_0810:

v0.8.1 (January 4, 2021)
------------------------

Deprecations
~~~~~~~~~~~~
* ``pvlib.irradiance.liujordan`` is deprecated. :py:func:`pvlib.irradiance.campbell_norman`
  replaces ``pvlib.irradiance.liujordan``.

Enhancements
~~~~~~~~~~~~
* Add a numpy-based implementation of the SPECTRL2 spectral irradiance model
  :py:func:`pvlib.spectrum.spectrl2` (:pull:`1062`)
* Create :py:func:`~pvlib.pvsystem.PVSystem.fuentes_celltemp` and add ``temperature_model='fuentes'``
  option to :py:class:`~pvlib.modelchain.ModelChain`. (:issue:`1042`) (:pull:`1073`)
* Added :py:func:`pvlib.temperature.ross` for cell temperature modeling using
  only NOCT. (:pull:`1045`)
* :py:func:`pvlib.clearsky.detect_clearsky` now uses centered rolling windows
  instead of left-aligned rolling windows. (:pull:`1074`)
* The 'times' and 'window_length' parameters are now optional kwargs in
  :py:func:`pvlib.clearsky.detect_clearsky`. If omitted, 'times' is set
  equal to the index of parameter 'measured', and 'window_length' is set to
  10 minutes. (:pull:`1074`)
* Added :py:func:`pvlib.inverter.sandia_multi` and :py:func:`pvlib.inverter.pvwatts_multi`
  for modeling inverters with multiple MPPTs (:issue:`457`, :pull:`1085`, :pull:`1106`)
* Added optional ``attributes`` parameter to :py:func:`pvlib.iotools.get_psm3`
  and added the option of fetching 5- and 15-minute PSM3 data. (:pull:`1086`)
* Added :py:func:`pvlib.irradiance.campbell_norman` for estimating DNI, DHI and GHI
  from extraterrestrial irradiance. This function replaces ``pvlib.irradiance.liujordan``;
  users of ``pvlib.irradiance.liujordan`` should note that :py:func:`pvlib.irradiance.campbell_norman`
  expects different parameters. (:pull:`1104`)
* :py:meth:`pvlib.forecast.ForecastModel.cloud_cover_to_irradiance_campbell_norman`
  replaces ``pvlib.forecast.ForecastModel.cloud_cover_to_irradiance_liujordan``. (:pull:`1104`)

Bug fixes
~~~~~~~~~
* Fix issue with :py:func:`pvlib.temperature.fuentes` with timezone-aware
  inputs. (:issue:`1071`, :pull:`1072`)
* Raise ``ValueError`` from  :py:meth:`pvlib.modelchain.ModelChain.prepare_inputs`
  when input does not have a 'dhi' column. (:issue:`1092`, :pull:`1093`)
* Add missing modules (including ``shading`` and ``scaling``) to ``__init__.py``.
  (:pull:`1103`)

Testing
~~~~~~~
* Add airspeed velocity performance testing configuration and a few benchmarks.
  (:issue:`419`, :pull:`1049`, :pull:`1059`)
* Add Python 3.9 CI configurations. (:issue:`1102`, :pull:`1112`)
* Update ``test_pvgis.py`` to be more flexible about the PVGIS copyright notice
  (:pull:`1121`)

Documentation
~~~~~~~~~~~~~
* Update sphinx to 3.1.2 and use the ``recursive`` option in ``autosummary`` class template.
  (:issue:`1055`, :pull:`1075`)
* Add gallery example about backtracking on sloped terrain. (:pull:`1077`)
* Add toggle button for code prompts to make copying code easier (:pull:`1096`)
* Add project urls to setup.py for pypi page (:pull:`1119`)


Contributors
~~~~~~~~~~~~
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Siyan (Veronica) Guo (:ghuser:`veronicaguo`)
* Will Holmgren (:ghuser:`wholmgren`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Will Vining (:ghuser:`wfvining`)
* Michael Jurasovic (:ghuser:`jurasofish`)
* Aziz Ben Othman (:ghuser:`AzizCode92`)
* Anton Driesse (:ghuser:`adriesse`)
* Mark Mikofski (:ghuser:`mikofski`)
* Junaid Fatehi (:ghuser:`jhfatehi`)

.. _whatsnew_0710:

v0.7.1 (January 17, 2020)
-------------------------

Enhancements
~~~~~~~~~~~~
* Added :py:func:`~pvlib.iotools.read_psm3` to read local NSRDB PSM3 files and
  :py:func:`~pvlib.iotools.parse_psm3` to parse local NSRDB PSM3 file-like
  objects. (:issue:`841`)
* Added `leap_day` parameter to `iotools.get_psm3` instead of hardcoding it as
  False.
* Added :py:func:`~pvlib.iotools.get_pvgis_tmy` to get PVGIS TMY datasets.
  (:pull:`845`)
* Added :py:func:`~pvlib.iotools.parse_epw` to parse a file-like buffer
  containing weather data in the EPW format.
* Added a new module `pvlib.losses` for various loss models.
* Added the Humboldt State University soiling model
  :py:func:`~pvlib.losses.soiling_hsu`. (:issue:`739`)

Bug fixes
~~~~~~~~~
* Fix error in logic for emitting deprecation warning in
  :py:func:`~pvlib.pvsystem.sapm` (:pull:`844`)
* Changed the PSM3 API endpoint for TMY requests in `iotools.get_psm3`.

Testing
~~~~~~~
* Added single-year PSM3 API test for `iotools.get_psm3`.
* Added tests for `iotools.parse_psm3` and `iotools.read_psm3`.
* Change `pvlib/test` folder to `pvlib/tests` and reorganize tests into
  subfolders, *e.g.*: created `pvlib/tests/iotools` (:pull:`859`)
* replace `os.path` with `pathlib` and stringify path objects for Python<=3.5

Documentation
~~~~~~~~~~~~~
* Created an Example Gallery. (:pull:`846`)
* Updated list of allowed years for `iotools.get_psm3`.

Contributors
~~~~~~~~~~~~
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Mark Mikofski (:ghuser:`mikofski`)
* :ghuser:`dzimmanck`
* Will Holmgren (:ghuser:`wholmgren`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Valliappan CA (:ghuser:`nappaillav`)
* Anton Driesse (:ghuser:`adriesse`)
.. _whatsnew_0910:

v0.9.1 (TBD)
--------------------------

Breaking changes
~~~~~~~~~~~~~~~~

Deprecations
~~~~~~~~~~~~

Enhancements
~~~~~~~~~~~~

Bug fixes
~~~~~~~~~
* Address round-off effects in :py:func:`pvlib.ivtools.utils._schumaker_qspline`
  (:issue:`1311`, :pull:`1315`)
* Fixed a bug in :py:func:`pvlib.spectrum.spectrl2` where negative spectral irradiance
  values were returned when the sun is behind the plane of array (:issue:`1348`, :pull:`1349`)
* Fixed bug in :py:func:`pvlib.iotools.get_pvgis_hourly` where the ``optimal_surface_tilt``
  argument was not being passed to the ``optimalinclination`` request parameter (:pull:`1356`)
* Fixed bug in :py:func:`pvlib.bifacial.pvfactors_timeseries` where scalar ``surface_tilt``
  and ``surface_azimuth`` inputs caused an error (:issue:`1127`, :issue:`1332`, :pull:`1361`) 
* Changed the metadata entry for the wind speed unit to "Wind Speed Units" in
  the PSM3 iotools function (:pull:`1375`)

Testing
~~~~~~~

Documentation
~~~~~~~~~~~~~
* Fix documentation return error in :py:meth:`pvlib.forecast.ForecastModel.cloud_cover_to_transmittance_linear`
  (:issue:`1367`, :pull:`1370`)


Requirements
~~~~~~~~~~~~

Contributors
~~~~~~~~~~~~
* Cliff Hansen (:ghuser:`cwhanse`)
* :ghuser:`Antoine-0`
* :ghuser:`Carlosbogo`
* Christian Weickhmann (:ghuser:`cweickhmann`)
* Kevin Anderson (:ghuser:`kanderso-nrel`)
* Adam R. Jensen (:ghuser:`AdamRJensen`)
* Johann Loux (:ghuser:`JoLo90`)
.. _whatsnew_0601:

v0.6.1 (January 31, 2019)
-------------------------

This is a minor release. We recommend all users of v0.6.0 upgrade to this
release.

**Python 2.7 support will end on June 1, 2019**. Releases made after this
date will require Python 3. (:issue:`501`)

**Minimum pandas requirement bumped 0.14.0=>0.15.0**


API Changes
~~~~~~~~~~~
* Created the ``pvlib.iotools`` subpackage. (:issue:`29`, :issue:`261`)
* Deprecated ``tmy``, ``tmy.readtmy2`` and ``tmy.readtmy3``;
  they will be removed in v0.7. Use the new :py:func:`pvlib.iotools.read_tmy2`
  and :py:func:`pvlib.iotools.read_tmy3` instead. (:issue:`261`)
* Added keyword argument ``horizon`` to :func:`~pvlib.solarposition.pyephem`
  and :func:`~pvlib.solarposition.calc_time` with default value ``'+0:00'``.
  (:issue:`588`)
* Add `max_airmass` keyword argument to :py:func:`pvlib.irradiance.disc`.
  Default value (`max_airmass=12`) is consistent with polynomial fit in
  original paper describing the model. This change may result in different
  output of functions that use the `disc` *Kn* calculation for times when
  input zenith angles approach 90 degrees. This includes
  :py:func:`pvlib.irradiance.dirint` and :py:func:`pvlib.irradiance.dirindex`
  when `min_cos_zenith` and `max_zenith` kwargs are used, as well as
  :py:func:`pvlib.irradiance.gti_dirint`. (:issue:`450`)
* Changed key names for `components` returned from
  :py:func:`pvlib.clearsky.detect_clearsky`. (:issue:`596`)
* Changed function name from `pvlib.solarposition.get_rise_set_transit`
  (deprecated) to :py:func:`pvlib.solarposition.sun_rise_set_transit_spa.
  `sun_rise_set_transit_spa` requires time input to be localized to the
  specified latitude/longitude. (:issue:`316`)
* Created new bifacial section for `pvfactors` limited implementation (:issue:`421`)


Enhancements
~~~~~~~~~~~~
* Add :py:func:`~pvlib.solarposition.sun_rise_set_transit_ephem`to calculate sunrise, sunset
  and transit times using pyephem (:issue:`114`)
* Add geometric functions for sunrise, sunset, and sun transit times,
  :func:`~pvlib.solarposition.sun_rise_set_transit_geometric` (:issue:`114`)
* Add `Location` class method :py:func:`~pvlib.location.Location.get_sun_rise_set_transit`
* Created :py:func:`pvlib.iotools.read_srml` and
  :py:func:`pvlib.iotools.read_srml_month_from_solardat` to read University of
  Oregon Solar Radiation Monitoring Laboratory data. (:issue:`589`)
* Created :py:func:`pvlib.iotools.read_surfrad` to read NOAA SURFRAD data. (:issue:`590`)
* Created :py:func:`pvlib.iotools.read_midc` and :py:func:`pvlib.iotools.read_midc_raw_data_from_nrel`
  to read NREL MIDC data. (:issue:`601`)
* Created :py:func:`pvlib.iotools.get_ecmwf_macc` and :py:func:`pvlib.iotools.read_ecmwf_macc`
  to get and read ECMWF MACC data. (:issue:`602`)
* Use HRRR modeled surface temperature values instead of inferring from
  isobaric values and modeled wind speed instead of inferring from gust.
  (:issue:`604`)
* Change :py:func:`pvlib.pvsystem.sapm_spectral_loss` to avoid numpy warning.
* Add warning message when :py:func:`pvlib.spa` is reloaded. (:issue:`401`)
* Add option for :py:func:`pvlib.irradiance.disc` to use relative airmass
  by supplying `pressure=None`. (:issue:`449`)
* Created :py:func:`pvlib.pvsystem.pvsyst_celltemp` to implement PVsyst's cell temperature model. (:issue:`552`)
* Created :py:func:`pvlib.bifacial.pvfactors_timeseries` to use open-source `pvfactors` package to calculate back surface irradiance (:issue:`421`)
* Add `PVSystem` class method :py:func:`~pvlib.pvsystem.PVSystem.pvsyst_celltemp` (:issue:`633`)
* Add :py:func:`pvlib.irradiance.clearsky_index` to calculate clear-sky index
  from measured GHI and modeled clear-sky GHI. (:issue:`551`)


Bug fixes
~~~~~~~~~
* Fix when building documentation using Matplotlib 3.0 or greater.
* `~pvlib.spa.calculate_deltat`: Fix constant coefficient of the polynomial
  expression for years >= 1860 and < 1900, fix year 2050 which was
  returning 0. (:issue:`600`)
* Fix and improve :func:`~pvlib.solarposition.hour_angle` (:issue:`598`)
* Fix error in :func:`pvlib.clearsky.detect_clearsky` (:issue:`506`)
* Fix documentation errors when using IPython >= 7.0.
* Fix error in :func:`pvlib.modelchain.ModelChain.infer_spectral_model` (:issue:`619`)
* Fix error in ``pvlib.spa`` when using Python 3.7 on some platforms.
* Fix error in :func:`pvlib.irradiance._delta_kt_prime_dirint` (:issue:`637`). The error affects
  the first and last values of DNI calculated by the function :func:`pvlib.irradiance.dirint`
* Fix errors on Python 2.7 and Numpy 1.6. (:issue:`642`)
* Replace deprecated `np.asscalar` with `array.item()`. (:issue:`642`)


Testing
~~~~~~~
* Add test for :func:`~pvlib.solarposition.hour_angle` (:issue:`597`)
* Update tests to be compatible with pytest 4.0. (:issue:`623`)
* Add tests for :py:func:`pvlib.bifacial.pvfactors_timeseries` implementation (:issue:`421`)


Contributors
~~~~~~~~~~~~
* Will Holmgren (:ghuser:`wholmgren`)
* Leland Boeman (:ghuser:`lboeman`)
* Cedric Leroy (:ghuser:`cedricleroy`)
* Ben Ellis (:ghuser:`bhellis725`)
* Cliff Hansen (:ghuser:`cwhanse`)
* Mark Mikofski (:ghuser:`mikofski`)
* Anton Driesse (:ghuser:`adriesse`)
* Cameron Stark (:ghuser:`camerontstark`)
* Jonathan Gaffiot (:ghuser:`jgaffiot`)
* Marc Anoma (:ghuser:`anomam`)
* Anton Driesse (:ghuser:`adriesse`)
* Kevin Anderson (:ghuser:`kevinsa5`)
.. _comparison_pvlib_matlab:

****************************
Comparison with PVLIB MATLAB
****************************

PVLIB was originally developed as a library for MATLAB at Sandia
National Lab, and Sandia remains the official maintainer of the MATLAB
library. Sandia supported the initial Python port and
then released further project maintenance and development to the
`pvlib-python maintainers <https://github.com/orgs/pvlib/people>`_.

The pvlib-python maintainers collaborate with the PVLIB MATLAB
maintainers but operate independently. We'd all like to keep the core
functionality of the Python and MATLAB projects synchronized, but this
will require the efforts of the larger pvlib-python community, not just
the maintainers. Therefore, do not expect feature parity between the
libaries, only similarity.

The `PV_LIB Matlab help webpage <https://pvpmc.sandia.gov/PVLIB_Matlab_Help/>`_
is a good reference for this comparison.

Missing functions
~~~~~~~~~~~~~~~~~

See pvlib-python GitHub `issue #2
<https://github.com/pvlib/pvlib-python/issues/2>`_ for a list of
functions missing from the Python version of the library.

Major differences
~~~~~~~~~~~~~~~~~

* pvlib-python uses git version control to track all changes
  to the code. A summary of changes is included in the whatsnew file
  for each release. PVLIB MATLAB documents changes in Changelog.docx
* pvlib-python has a comprehensive test suite, whereas PVLIB MATLAB does
  not have a test suite at all. Specifically, pvlib-python

    * Uses TravisCI for automated testing on Linux.
    * Uses Appveyor for automated testing on Windows.
    * Uses Coveralls to measure test coverage.

* Using readthedocs for automated documentation building and hosting.
* Removed ``pvl_`` from module/function names.
* Consolidated similar functions into topical modules.
  For example, functions from ``pvl_clearsky_ineichen.m`` and
  ``pvl_clearsky_haurwitz.m`` have been consolidated into ``clearsky.py``.
* PVLIB MATLAB uses ``location`` structs as the input to some functions.
  pvlib-python just uses the lat, lon, etc. as inputs to the functions.
  Furthermore, pvlib-python replaces the structs with classes, and these classes
  have methods, such as :py:func:`~pvlib.location.Location.get_solarposition`,
  that automatically reference the appropriate data.
  See :ref:`modeling-paradigms` for more information.
* pvlib-python implements a handful of class designed to simplify the
  PV modeling process. These include :py:class:`~pvlib.location.Location`,
  :py:class:`~pvlib.pvsystem.PVSystem`,
  :py:class:`~pvlib.tracking.SingleAxisTracker`,
  and
  :py:class:`~pvlib.modelchain.ModelChain`.

Other differences
~~~~~~~~~~~~~~~~~

* Very few tests of input validitity exist in the Python code.
  We believe that the vast majority of these tests were not necessary.
  We also make use of Python's robust support for raising and catching
  exceptions.
* Removed unnecessary and sometimes undesired behavior such as setting
  maximum zenith=90 or airmass=0. Instead, we make extensive use of
  ``nan`` values in returned arrays.
* Implemented the NREL solar position calculation algorithm.
  Also added a PyEphem option to solar position calculations.
* Specify time zones using a string from the standard IANA Time Zone
  Database naming conventions or using a pytz.timezone instead of an
  integer GMT offset.
* ``clearsky.ineichen`` supports interpolating monthly
  Linke Turbidities to daily resolution.
* Instead of requiring effective irradiance as an input, ``pvsystem.sapm``
  calculates and returns it based on input POA irradiance, AM, and AOI.
* pvlib-python does not come with as much example data.
* pvlib-python does not currently implement as many algorithms as
  PVLIB MATLAB.

Documentation
~~~~~~~~~~~~~

* Using Sphinx to build the documentation,
  including dynamically created inline examples.
* Additional Jupyter tutorials in ``/docs/tutorials``.
.. _forecasts:

***********
Forecasting
***********

pvlib python provides a set of functions and classes that make it easy
to obtain weather forecast data and convert that data into a PV power
forecast. Users can retrieve standardized weather forecast data relevant
to PV power modeling from NOAA/NCEP/NWS models including the GFS, NAM,
RAP, HRRR, and the NDFD. A PV power forecast can then be obtained using
the weather data as inputs to the comprehensive modeling capabilities of
pvlib python. Standardized, open source, reference implementations of
forecast methods using publicly available data may help advance the
state-of-the-art of solar power forecasting.

pvlib python uses Unidata's `Siphon
<http://siphon.readthedocs.org/en/latest/>`_ library to simplify access
to real-time forecast data hosted on the Unidata `THREDDS catalog
<http://thredds.ucar.edu/thredds/catalog.html>`_. Siphon is great for
programatic access of THREDDS data, but we also recommend using tools
such as `Panoply <http://www.giss.nasa.gov/tools/panoply/>`_
to easily browse the catalog and become more familiar with its contents.

We do not know of a similarly easy way to access archives of forecast data.

This document demonstrates how to use pvlib python to create a PV power
forecast using these tools. The `forecast
<http://nbviewer.jupyter.org/github/pvlib/pvlib-python/blob/
master/docs/tutorials/forecast.ipynb>`_ and `forecast_to_power
<http://nbviewer.jupyter.org/github/pvlib/pvlib-python/blob/
master/docs/tutorials/forecast_to_power.ipynb>`_ Jupyter notebooks
provide additional example code.

.. warning::

    The forecast module algorithms and features are highly experimental.
    The API may change, the functionality may be consolidated into an io
    module, or the module may be separated into its own package.

.. note::

    This documentation is difficult to reliably build on readthedocs.
    If you do not see images, try building the documentation on your
    own machine or see the notebooks linked to above.


Accessing Forecast Data
~~~~~~~~~~~~~~~~~~~~~~~~~~

The Siphon library provides access to, among others, forecasts from the
Global Forecast System (GFS), North American Model (NAM), High
Resolution Rapid Refresh (HRRR), Rapid Refresh (RAP), and National
Digital Forecast Database (NDFD) on a Unidata THREDDS server.
Unfortunately, many of these models use different names to describe the
same quantity (or a very similar one), and not all variables are present
in all models. For example, on the THREDDS server, the GFS has a field
named
``Total_cloud_cover_entire_atmosphere_Mixed_intervals_Average``,
while the NAM has a field named
``Total_cloud_cover_entire_atmosphere_single_layer``, and a
similar field in the HRRR is named
``Total_cloud_cover_entire_atmosphere``.

pvlib python aims to simplify the access of the model fields relevant
for solar power forecasts. Model data accessed with pvlib python is
returned as a pandas DataFrame with consistent column names:
``temp_air, wind_speed, total_clouds, low_clouds, mid_clouds,
high_clouds, dni, dhi, ghi``. To accomplish this, we use an
object-oriented framework in which each weather model is represented by
a class that inherits from a parent
:py:class:`~pvlib.forecast.ForecastModel` class.
The parent :py:class:`~pvlib.forecast.ForecastModel` class contains the
common code for accessing and parsing the data using Siphon, while the
child model-specific classes (:py:class:`~pvlib.forecast.GFS`,
:py:class:`~pvlib.forecast.HRRR`, etc.) contain the code necessary to
map and process that specific model's data to the standardized fields.

The code below demonstrates how simple it is to access and plot forecast
data using pvlib python. First, we set up make the basic imports and
then set the location and time range data.

.. ipython:: python

    import pandas as pd
    import matplotlib.pyplot as plt
    import datetime

    # import pvlib forecast models
    from pvlib.forecast import GFS, NAM, NDFD, HRRR, RAP

    # specify location (Tucson, AZ)
    latitude, longitude, tz = 32.2, -110.9, 'US/Arizona'

    # specify time range.
    start = pd.Timestamp(datetime.date.today(), tz=tz)
    end = start + pd.Timedelta(days=7)

    irrad_vars = ['ghi', 'dni', 'dhi']


Next, we instantiate a GFS model object and get the forecast data
from Unidata.

.. ipython:: python

    # GFS model, defaults to 0.5 degree resolution
    # 0.25 deg available
    model = GFS()

    # retrieve data. returns pandas.DataFrame object
    raw_data = model.get_data(latitude, longitude, start, end)

    print(raw_data.head())

It will be useful to process this data before using it with pvlib. For
example, the column names are non-standard, the temperature is in
Kelvin, the wind speed is broken into east/west and north/south
components, and most importantly, most of the irradiance data is
missing. The forecast module provides a number of methods to fix these
problems.

.. ipython:: python

    data = raw_data

    # rename the columns according the key/value pairs in model.variables.
    data = model.rename(data)

    # convert temperature
    data['temp_air'] = model.kelvin_to_celsius(data['temp_air'])

    # convert wind components to wind speed
    data['wind_speed'] = model.uv_to_speed(data)

    # calculate irradiance estimates from cloud cover.
    # uses a cloud_cover to ghi to dni model or a
    # uses a cloud cover to transmittance to irradiance model.
    # this step is discussed in more detail in the next section
    irrad_data = model.cloud_cover_to_irradiance(data['total_clouds'])
    data = data.join(irrad_data, how='outer')

    # keep only the final data
    data = data[model.output_variables]

    print(data.head())

Much better.

The GFS class's
:py:func:`~pvlib.forecast.GFS.process_data` method combines these steps
in a single function. In fact, each forecast model class
implements its own ``process_data`` method since the data from each
weather model is slightly different. The ``process_data`` functions are
designed to be explicit about how the data is being processed, and users
are **strongly** encouraged to read the source code of these methods.

.. ipython:: python

    data = model.process_data(raw_data)

    print(data.head())

Users can easily implement their own ``process_data`` methods on
inherited classes or implement similar stand-alone functions.

The forecast model classes also implement a
:py:func:`~pvlib.forecast.ForecastModel.get_processed_data` method that
combines the :py:func:`~pvlib.forecast.ForecastModel.get_data` and
:py:func:`~pvlib.forecast.ForecastModel.process_data` calls.

.. ipython:: python

    data = model.get_processed_data(latitude, longitude, start, end)

    print(data.head())


Cloud cover and radiation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All of the weather models currently accessible by pvlib include one or
more cloud cover forecasts. For example, below we plot the GFS cloud
cover forecasts.

.. ipython:: python

    # plot cloud cover percentages
    cloud_vars = ['total_clouds', 'low_clouds',
                  'mid_clouds', 'high_clouds']
    data[cloud_vars].plot();
    plt.ylabel('Cloud cover %');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('GFS 0.5 deg forecast for lat={}, lon={}'
              .format(latitude, longitude));
    @savefig gfs_cloud_cover.png width=6in
    plt.legend();
    @suppress
    plt.close();

However, many of forecast models do not include radiation components in
their output fields, or if they do then the radiation fields suffer from
poor solar position or radiative transfer algorithms. It is often more
accurate to create empirically derived radiation forecasts from the
weather models' cloud cover forecasts.

pvlib python provides two basic ways to convert cloud cover forecasts to
irradiance forecasts. One method assumes a linear relationship between
cloud cover and GHI, applies the scaling to a clear sky climatology, and
then uses the DISC model to calculate DNI. The second method assumes a
linear relationship between cloud cover and atmospheric transmittance,
and then uses the Campbell-Norman model to calculate GHI, DNI, and
DHI [Cam98]_. Campbell-Norman is an approximation of Liu-Jordan [Liu60]_.

*Caveat emptor*: these algorithms are not rigorously verified! The
purpose of the forecast module is to provide a few exceedingly simple
options for users to play with before they develop their own models. We
strongly encourage pvlib users first read the source code and second
to implement new cloud cover to irradiance algorithms.

The essential parts of the clear sky scaling algorithm are as follows.
Clear sky scaling of climatological GHI is also used in Larson et. al.
[Lar16]_.

.. code-block:: python

    solpos = location.get_solarposition(cloud_cover.index)
    cs = location.get_clearsky(cloud_cover.index, model='ineichen')
    # offset and cloud cover in decimal units here
    # larson et. al. use offset = 0.35
    ghi = (offset + (1 - offset) * (1 - cloud_cover)) * ghi_clear
    dni = disc(ghi, solpos['zenith'], cloud_cover.index)['dni']
    dhi = ghi - dni * np.cos(np.radians(solpos['zenith']))

The figure below shows the result of the total cloud cover to
irradiance conversion using the clear sky scaling algorithm.

.. ipython:: python

    # plot irradiance data
    data = model.rename(raw_data)
    irrads = model.cloud_cover_to_irradiance(data['total_clouds'], how='clearsky_scaling')
    irrads.plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('GFS 0.5 deg forecast for lat={}, lon={} using "clearsky_scaling"'
              .format(latitude, longitude));
    @savefig gfs_irrad_cs.png width=6in
    plt.legend();
    @suppress
    plt.close();


The essential parts of the Campbell-Norman cloud cover to irradiance algorithm
are as follows.

.. code-block:: python

    # cloud cover in percentage units here
    transmittance = ((100.0 - cloud_cover) / 100.0) * 0.75
    # irrads is a DataFrame containing ghi, dni, dhi
    irrads = campbell_norman(apparent_zenith, transmittance)

The figure below shows the result of the Campbell-Norman total cloud cover to
irradiance conversion.

.. ipython:: python

    # plot irradiance data
    irrads = model.cloud_cover_to_irradiance(data['total_clouds'], how='campbell_norman')
    irrads.plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('GFS 0.5 deg forecast for lat={}, lon={} using "campbell_norman"'
              .format(latitude, longitude));
    @savefig gfs_irrad_lj.png width=6in
    plt.legend();
    @suppress
    plt.close();


Most weather model output has a fairly coarse time resolution, at least
an hour. The irradiance forecasts have the same time resolution as the
weather data. However, it is straightforward to interpolate the cloud
cover forecasts onto a higher resolution time domain, and then
recalculate the irradiance.

.. ipython:: python

    resampled_data = data.resample('5min').interpolate()
    resampled_irrads = model.cloud_cover_to_irradiance(resampled_data['total_clouds'], how='clearsky_scaling')
    resampled_irrads.plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('GFS 0.5 deg forecast for lat={}, lon={} resampled'
              .format(latitude, longitude));
    @savefig gfs_irrad_high_res.png width=6in
    plt.legend();
    @suppress
    plt.close();

Users may then recombine resampled_irrads and resampled_data using
slicing :py:func:`pandas.concat` or :py:meth:`pandas.DataFrame.join`.

We reiterate that the open source code enables users to customize the
model processing to their liking.

.. [Lar16] Larson et. al. "Day-ahead forecasting of solar power output
    from photovoltaic plants in the American Southwest" Renewable
    Energy 91, 11-20 (2016).

.. [Cam98] Campbell, G. S., J. M. Norman (1998) An Introduction to
    Environmental Biophysics. 2nd Ed. New York: Springer.

.. [Liu60] B. Y. Liu and R. C. Jordan, The interrelationship and
    characteristic distribution of direct, diffuse, and total solar
    radiation, *Solar Energy* **4**, 1 (1960).


Weather Models
~~~~~~~~~~~~~~

Next, we provide a brief description of the weather models available to
pvlib users. Note that the figures are generated when this documentation
is compiled so they will vary over time.

GFS
---
The Global Forecast System (GFS) is the US model that provides forecasts
for the entire globe. The GFS is updated every 6 hours. The GFS is run
at two resolutions, 0.25 deg and 0.5 deg, and is available with 3 hour
time resolution. Forecasts from GFS model were shown above. Use the GFS,
among others, if you want forecasts for 1-7 days or if you want forecasts
for anywhere on Earth.


HRRR
----
The High Resolution Rapid Refresh (HRRR) model is perhaps the most
accurate model, however, it is only available for ~15 hours. It is
updated every hour and runs at 3 km resolution. The HRRR excels in
severe weather situations. See the `NOAA ESRL HRRR page
<http://rapidrefresh.noaa.gov/hrrr/>`_ for more information. Use the
HRRR, among others, if you want forecasts for less than 24 hours.
The HRRR model covers the continental United States.

.. ipython:: python

    model = HRRR()
    data = model.get_processed_data(latitude, longitude, start, end)

    data[irrad_vars].plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('HRRR 3 km forecast for lat={}, lon={}'
              .format(latitude, longitude));
    @savefig hrrr_irrad.png width=6in
    plt.legend();
    @suppress
    plt.close();


RAP
---
The Rapid Refresh (RAP) model is the parent model for the HRRR. It is
updated every hour and runs at 40, 20, and 13 km resolutions. Only the
20 and 40 km resolutions are currently available in pvlib. It is also
excels in severe weather situations. See the `NOAA ESRL HRRR page
<http://rapidrefresh.noaa.gov/hrrr/>`_ for more information. Use the
RAP, among others, if you want forecasts for less than 24 hours.
The RAP model covers most of North America.

.. ipython:: python

    model = RAP()
    data = model.get_processed_data(latitude, longitude, start, end)

    data[irrad_vars].plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('RAP 13 km forecast for lat={}, lon={}'
              .format(latitude, longitude));
    @savefig rap_irrad.png width=6in
    plt.legend();
    @suppress
    plt.close();


NAM
---
The North American Mesoscale model covers, not surprisingly, North
America. It is updated every 6 hours. pvlib provides access to 20 km
resolution NAM data with a time horizon of up to 4 days.

.. ipython:: python

    model = NAM()
    data = model.get_processed_data(latitude, longitude, start, end)

    data[irrad_vars].plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('NAM 20 km forecast for lat={}, lon={}'
              .format(latitude, longitude));
    @savefig nam_irrad.png width=6in
    plt.legend();
    @suppress
    plt.close();


NDFD
----
The National Digital Forecast Database is not a model, but rather a
collection of forecasts made by National Weather Service offices
across the country. It is updated every 6 hours.
Use the NDFD, among others, for forecasts at all time horizons.
The NDFD is available for the United States.

.. ipython:: python
   :okexcept:

    model = NDFD()
    data = model.get_processed_data(latitude, longitude, start, end)

    data[irrad_vars].plot();
    plt.ylabel('Irradiance ($W/m^2$)');
    plt.xlabel('Forecast Time ({})'.format(tz));
    plt.title('NDFD forecast for lat={}, lon={}'
              .format(latitude, longitude));
    @savefig ndfd_irrad.png width=6in
    plt.legend();
    @suppress
    plt.close();


PV Power Forecast
~~~~~~~~~~~~~~~~~

Finally, we demonstrate the application of the weather forecast data to
a PV power forecast. Please see the remainder of the pvlib documentation
for details.

.. ipython:: python

    from pvlib.pvsystem import PVSystem, retrieve_sam
    from pvlib.temperature import TEMPERATURE_MODEL_PARAMETERS
    from pvlib.tracking import SingleAxisTracker
    from pvlib.modelchain import ModelChain

    sandia_modules = retrieve_sam('sandiamod')
    cec_inverters = retrieve_sam('cecinverter')
    module = sandia_modules['Canadian_Solar_CS5P_220M___2009_']
    inverter = cec_inverters['SMA_America__SC630CP_US__with_ABB_EcoDry_Ultra_transformer_']
    temperature_model_parameters = TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']

    # model a big tracker for more fun
    system = SingleAxisTracker(module_parameters=module, inverter_parameters=inverter, temperature_model_parameters=temperature_model_parameters, modules_per_string=15, strings_per_inverter=300)

    # fx is a common abbreviation for forecast
    fx_model = GFS()
    fx_data = fx_model.get_processed_data(latitude, longitude, start, end)

    # use a ModelChain object to calculate modeling intermediates
    mc = ModelChain(system, fx_model.location)

    # extract relevant data for model chain
    mc.run_model(fx_data);

Now we plot a couple of modeling intermediates and the forecast power.
Here's the forecast plane of array irradiance...

.. ipython:: python

    mc.results.total_irrad.plot();
    @savefig poa_irrad.png width=6in
    plt.ylabel('Plane of array irradiance ($W/m^2$)');
    plt.legend(loc='best');
    @suppress
    plt.close();

...the cell and module temperature...

.. ipython:: python

    mc.results.cell_temperature.plot();
    @savefig pv_temps.png width=6in
    plt.ylabel('Cell Temperature (C)');
    @suppress
    plt.close();

...and finally AC power...

.. ipython:: python

    mc.results.ac.fillna(0).plot();
    plt.ylim(0, None);
    @savefig ac_power.png width=6in
    plt.ylabel('AC Power (W)');
    @suppress
    plt.close();

.. _modelchaindoc:

ModelChain
==========

The :py:class:`~.modelchain.ModelChain` class provides a high-level
interface for standardized PV modeling. The class aims to automate much
of the modeling process while providing flexibility and remaining
extensible. This guide aims to build users' understanding of the
ModelChain class. It assumes some familiarity with object-oriented
code in Python, but most information should be understandable even
without a solid understanding of classes.

A :py:class:`~.modelchain.ModelChain` has three components:

* a :py:class:`~.pvsystem.PVSystem` object, representing a collection of modules and inverters
* a :py:class:`~.location.Location` object, representing a location on the planet
* values for attributes that specify the model to be used for for each step in the PV modeling
  process.

Modeling with a :py:class:`~.ModelChain` typically involves 3 steps:

1. Creating an instance of :py:class:`~pvlib.modelchain.ModelChain`.
2. Executing a ModelChain.run_model method with weather data as input. See
   :ref:`modelchain_runmodel` for a list of run_model methods.
3. Examining the model results that are stored in the ModelChain's
   :py:class:`ModelChain.results <pvlib.modelchain.ModelChainResult>` attribute.

A simple ModelChain example
---------------------------

Before delving into the intricacies of ModelChain, we provide a brief
example of the modeling steps using ModelChain. First, we import pvlib’s
objects, module data, and inverter data.

.. ipython:: python

    import pandas as pd
    import numpy as np

    # pvlib imports
    import pvlib

    from pvlib.pvsystem import PVSystem, FixedMount
    from pvlib.location import Location
    from pvlib.modelchain import ModelChain
    from pvlib.temperature import TEMPERATURE_MODEL_PARAMETERS
    temperature_model_parameters = TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']

    # load some module and inverter specifications
    sandia_modules = pvlib.pvsystem.retrieve_sam('SandiaMod')
    cec_inverters = pvlib.pvsystem.retrieve_sam('cecinverter')

    sandia_module = sandia_modules['Canadian_Solar_CS5P_220M___2009_']
    cec_inverter = cec_inverters['ABB__MICRO_0_25_I_OUTD_US_208__208V_']

Now we create a Location object, a Mount object, a PVSystem object, and a
ModelChain object.

.. ipython:: python

    location = Location(latitude=32.2, longitude=-110.9)
    system = PVSystem(surface_tilt=20, surface_azimuth=200,
                      module_parameters=sandia_module,
                      inverter_parameters=cec_inverter,
                      temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(system, location)

Printing a ModelChain object will display its models.

.. ipython:: python

    print(mc)

Next, we run a model with some simple weather data.

.. ipython:: python

    weather = pd.DataFrame([[1050, 1000, 100, 30, 5]],
                           columns=['ghi', 'dni', 'dhi', 'temp_air', 'wind_speed'],
                           index=[pd.Timestamp('20170401 1200', tz='US/Arizona')])

    mc.run_model(weather)

ModelChain stores the modeling results in the ``results`` attribute. The
``results`` attribute is an instance of :py:class:`~pvlib.modelchain.ModelChainResult`.
A few examples of attributes of :py:class:`~pvlib.modelchain.ModelChainResult`
are shown below.

.. ipython:: python

    mc.results.aoi

.. ipython:: python

    mc.results.cell_temperature

.. ipython:: python

    mc.results.dc

.. ipython:: python

    mc.results.ac

The remainder of this guide examines the ModelChain functionality and
explores common pitfalls.

Defining a ModelChain
---------------------

A :py:class:`~pvlib.modelchain.ModelChain` object is defined by:

1. The properties of its :py:class:`~pvlib.pvsystem.PVSystem`
   and :py:class:`~pvlib.location.Location` objects
2. The keyword arguments passed to it at construction

ModelChain uses the keyword arguments passed to it to determine the
models for the simulation. The documentation describes the allowed
values for each keyword argument. If a keyword argument is not supplied,
ModelChain will attempt to infer the correct set of models by inspecting
the Location and PVSystem attributes.

Below, we show some examples of how to define a ModelChain.

Let’s make the most basic Location and PVSystem objects and build from
there.

.. ipython:: python

    location = Location(32.2, -110.9)
    poorly_specified_system = PVSystem()
    print(location)
    print(poorly_specified_system)

These basic objects do not have enough information for ModelChain to be
able to automatically determine its set of models, so the ModelChain
will throw an error when we try to create it.

.. ipython:: python
   :okexcept:

    ModelChain(poorly_specified_system, location)

Next, we define a PVSystem with a module from the SAPM database and an
inverter from the CEC database. ModelChain will examine the PVSystem
object’s properties and determine that it should choose the SAPM DC
model, AC model, AOI loss model, and spectral loss model.

.. ipython:: python

    sapm_system = PVSystem(
        module_parameters=sandia_module,
        inverter_parameters=cec_inverter,
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(sapm_system, location)
    print(mc)

.. ipython:: python

    mc.run_model(weather);
    mc.results.ac

Alternatively, we could have specified single diode or PVWatts related
information in the PVSystem construction. Here we pass parameters for
PVWatts models to the PVSystem. ModelChain will automatically determine that
it should choose PVWatts DC and AC models. ModelChain still needs us to specify
``aoi_model`` and ``spectral_model`` keyword arguments because the
``system.module_parameters`` dictionary does not contain enough
information to determine which of those models to choose.

.. ipython:: python

    pvwatts_system = PVSystem(
        module_parameters={'pdc0': 240, 'gamma_pdc': -0.004},
        inverter_parameters={'pdc0': 240},
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(pvwatts_system, location,
                    aoi_model='physical', spectral_model='no_loss')
    print(mc)

.. ipython:: python

    mc.run_model(weather);
    mc.results.ac

User-supplied keyword arguments override ModelChain’s inspection
methods. For example, we can tell ModelChain to use different loss
functions for a PVSystem that contains SAPM-specific parameters.

.. ipython:: python

    sapm_system = PVSystem(
        module_parameters=sandia_module,
        inverter_parameters=cec_inverter,
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(sapm_system, location, aoi_model='physical', spectral_model='no_loss')
    print(mc)

.. ipython:: python

    mc.run_model(weather);
    mc.results.ac

Of course, these choices can also lead to failure when executing
:py:meth:`~pvlib.modelchain.ModelChain.run_model` if your system objects
do not contain the required parameters for running the model chain.

As a convenience, ModelChain includes two class methods that return a ModelChain
with models selected to be consistent with named PV system models:

* :py:meth:`~pvlib.modelchain.ModelChain.with_pvwatts`
* :py:meth:`~pvlib.modelchain.ModelChain.with_sapm`

Each "with" method returns a ModelChain using a Location and PVSystem. Parameters
used to define the PVSystem need to be consistent with the models specified by
the "with" method. Using location and sapm_system defined above:

.. ipython:: python

    mc = mc.with_sapm(sapm_system, location)
    print(mc)

    mc.run_model(weather)
    mc.results.dc


Demystifying ModelChain internals
---------------------------------

The ModelChain class has a lot going in inside it in order to make
users' code as simple as possible.

The key parts of ModelChain are:

    1. The ModelChain.run_model methods.
    2. A set of methods that wrap and call the PVSystem methods.
    3. A set of methods that can inspect user-supplied objects to infer
       the appropriate model when a model isn't specified by the user.

run_model methods
~~~~~~~~~~~~~~~~~

ModelChain provides three methods for executing the chain of models. The
methods allow for simulating the output of the PVSystem with different
input data:

* :py:meth:`~pvlib.modelchain.ModelChain.run_model`, use when ``weather``
  contains global horizontal, direct and diffuse horizontal irradiance
  (``'ghi'``, ``'dni'`` and ``'dhi'``).
* :py:meth:`~pvlib.modelchain.ModelChain.run_model_from_poa`, use when
  ``weather`` broadband direct, diffuse and total irradiance in the plane of array
  (``'poa_global'``, ``'poa_direct'``, ``'poa_diffuse'``).
* :py:meth:`~pvlib.modelchain.ModelChain.run_model_from_effective_irradiance`,
  use when ``weather`` contains spectrally- and reflection-adjusted total
  irradiance in the plane of array ('effective_irradiance').

To illustrate the use of the `run_model` method, assume that a user has GHI and DHI.
:py:meth:`~pvlib.modelchain.ModelChain.prepare_inputs` requires all three
irradiance components (GHI, DNI, and DHI). In this case, the user needs
to calculate DNI before using `run_model`. The :py:meth:`~pvlib.modelchain.ModelChain.complete_irradiance`
method is available for calculating the full set of GHI, DNI, or DHI if
only two of these three series are provided. See also :ref:`dniestmodels`
for methods and functions that can help fully define the irradiance inputs.

The :py:meth:`~pvlib.modelchain.ModelChain.run_model` method, shown below,
calls a series of methods to complete the modeling steps. The first
method, :py:meth:`~pvlib.modelchain.ModelChain.prepare_inputs`, computes
parameters such as solar position, airmass, angle of incidence, and
plane of array irradiance. Next, :py:meth:`~pvlib.modelchain.ModelChain.run_model` calls the
wrapper methods for AOI loss, spectral loss, effective irradiance, cell
temperature, DC power, AC power, and other losses. These methods are
assigned to generic names, as described in the next section.

.. ipython:: python

    mc.run_model??

The methods called by :py:meth:`~pvlib.modelchain.ModelChain.run_model`
store their results in the ``results`` attribute, which is an instance of
:py:class:`~pvlib.modelchain.ModelChainResult`. For example, :py:class:`~.ModelChainResult`
includes the following attributes: ``solar_position``, ``effective_irradiance``,
``cell_temperature``,  ``dc``, ``ac``. See :py:class:`~pvlib.modelchain.ModelChainResult`
for a full list of results attributes.


Wrapping methods into a unified API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Readers may notice that the source code of the :py:meth:`~pvlib.modelchain.ModelChain.run_model`
method is model-agnostic. :py:meth:`~pvlib.modelchain.ModelChain.run_model` calls generic methods
such as ``self.dc_model`` rather than a specific model such as
``pvwatts_dc``. So how does :py:meth:`~pvlib.modelchain.ModelChain.run_model` know what models
it’s supposed to run? The answer comes in two parts, and allows us to
explore more of the ModelChain API along the way.

First, ModelChain has a set of methods that wrap the PVSystem methods
that perform the calculations (or further wrap the pvsystem.py module’s
functions). Each of these methods takes the same arguments (``self``)
and sets the same attributes, thus creating a uniform API. For example,
the :py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc` method is shown below. Its only argument is
``self``, and it sets the ``dc`` attribute.

.. ipython:: python

    mc.pvwatts_dc??

The :py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc` method calls the pvwatts_dc method of the
PVSystem object that we supplied when we created the ModelChain instance,
using data that is stored in the ModelChain ``effective_irradiance`` and
``cell_temperature`` attributes. The :py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc` method assigns its
result to the ``dc`` attribute of the ModelChain's ``results`` object. The code
below shows a simple example of this.

.. ipython:: python

    # make the objects
    pvwatts_system = PVSystem(
        module_parameters={'pdc0': 240, 'gamma_pdc': -0.004},
        inverter_parameters={'pdc0': 240},
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(pvwatts_system, location,
                    aoi_model='no_loss', spectral_model='no_loss')

    # manually assign data to the attributes that ModelChain.pvwatts_dc will need.
    # for standard workflows, run_model would assign these attributes.
    mc.results.effective_irradiance = pd.Series(1000, index=[pd.Timestamp('20170401 1200-0700')])
    mc.results.cell_temperature = pd.Series(50, index=[pd.Timestamp('20170401 1200-0700')])

    # run ModelChain.pvwatts_dc and look at the result
    mc.pvwatts_dc();
    mc.results.dc

The :py:meth:`~pvlib.modelchain.ModelChain.sapm` method works in a manner similar
to the :py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc`
method. It calls the :py:meth:`~pvlib.pvsystem.PVSystem.sapm` method using stored data, then
assigns the result to the ``dc`` attribute of ``ModelChain.results``.
The :py:meth:`~pvlib.modelchain.ModelChain.sapm` method differs from the
:py:meth:`~pvlib.modelchain.ModelChain.pvwatts_dc` method in
a notable way: the PVSystem.sapm method returns a DataFrame with current,
voltage, and power results, rather than a simple Series
of power. The ModelChain methods for single diode models (e.g.,
:py:meth:`~pvlib.modelchain.ModelChain.desoto`) also return a DataFrame with
current, voltage and power, and a second DataFrame with the single diode
equation parameter values.

All ModelChain methods for DC output use the
:py:meth:`~pvlib.pvsystem.PVSystem.scale_voltage_current_power` method to scale
DC quantities to the output of the full PVSystem.

.. ipython:: python

    mc.sapm??

.. ipython:: python

    # make the objects
    sapm_system = PVSystem(
        module_parameters=sandia_module,
        inverter_parameters=cec_inverter,
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(sapm_system, location)

    # manually assign data to the attributes that ModelChain.sapm will need.
    # for standard workflows, run_model would assign these attributes.
    mc.results.effective_irradiance = pd.Series(1000, index=[pd.Timestamp('20170401 1200-0700')])
    mc.results.cell_temperature = pd.Series(50, index=[pd.Timestamp('20170401 1200-0700')])

    # run ModelChain.sapm and look at the result
    mc.sapm();
    mc.results.dc

We’ve established that the ``ModelChain.pvwatts_dc`` and
``ModelChain.sapm`` have the same API: they take the same arugments
(``self``) and they both set the ``dc`` attribute.\* Because the methods
have the same API, we can call them in the same way. ModelChain includes
a large number of methods that perform the same API-unification roles
for each modeling step.

Again, so how does :py:meth:`~pvlib.modelchain.ModelChain.run_model` know which
models it’s supposed to run?

At object construction, ModelChain assigns the desired model’s method
(e.g. ``ModelChain.pvwatts_dc``) to the corresponding generic attribute
(e.g. ``ModelChain.dc_model``) either with the value assigned to the ``dc_model``
parameter at construction, or by inference as described in the next
section.

.. ipython:: python

    pvwatts_system = PVSystem(
        module_parameters={'pdc0': 240, 'gamma_pdc': -0.004},
        inverter_parameters={'pdc0': 240},
        temperature_model_parameters=temperature_model_parameters)
    mc = ModelChain(pvwatts_system, location,
                    aoi_model='no_loss', spectral_model='no_loss')
    mc.dc_model.__func__

The ModelChain.run_model method can ignorantly call ``self.dc_module``
because the API is the same for all methods that may be assigned to this
attribute.

\* some readers may object that the API is *not* actually the same
because the type of the ``dc`` attribute is different (Series
vs. DataFrame)!

Inferring models
~~~~~~~~~~~~~~~~

When ModelChain's attributes are not assigned when the instance is created,
ModelChain can infer the appropriate model from data stored on the ``PVSystem``
object. ModelChain uses a set of methods (e.g., :py:meth:`~pvlib.modelchain.ModelChain.infer_dc_model`,
:py:meth:`~pvlib.modelchain.ModelChain.infer_ac_model`, etc.) that examine the
parameters on the user-supplied PVSystem object. The inference methods use set
logic to assign one of the model-specific methods, such as
:py:meth:`~pvlib.modelchain.ModelChain.sapm` or :py:meth:`~pvlib.modelchain.ModelChain.sandia_inverter`,
to the universal method names ``ModelChain.dc_model`` and ``ModelChain.ac_model``,
respectively. A few examples are shown below. Inference methods generally work
by inspecting the parameters for all required parameters for a corresponding
method.

.. ipython:: python

    mc.infer_dc_model??

.. ipython:: python

    mc.infer_ac_model??
    pvlib.modelchain._snl_params??
    pvlib.modelchain._adr_params??
    pvlib.modelchain._pvwatts_params??

ModelChain for a PVSystem with multiple Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The PVSystem can represent a PV system with a single array of modules, or
with multiple arrays (see :ref:`multiarray`). The same models are applied to
all ``PVSystem.array`` objects, so each ``Array`` must contain the appropriate model
parameters. For example, if ``ModelChain.dc_model='pvwatts'``, then each 
``Array.module_parameters`` must contain ``'pdc0'``.

When the PVSystem contains multiple arrays, ``ModelChain.results`` attributes
are tuples with length equal to the number of Arrays. Each tuple's elements
are in the same order as in ``PVSystem.arrays``.

.. ipython:: python

    from pvlib.pvsystem import Array
    location = Location(latitude=32.2, longitude=-110.9)
    inverter_parameters = {'pdc0': 10000, 'eta_inv_nom': 0.96}
    module_parameters = {'pdc0': 250, 'gamma_pdc': -0.004}
    array_one = Array(mount=FixedMount(surface_tilt=20, surface_azimuth=200),
                      module_parameters=module_parameters,
                      temperature_model_parameters=temperature_model_parameters,
                      modules_per_string=10, strings=2)
    array_two = Array(mount=FixedMount(surface_tilt=20, surface_azimuth=160),
                      module_parameters=module_parameters,
                      temperature_model_parameters=temperature_model_parameters,
                      modules_per_string=10, strings=2)
    system_two_arrays = PVSystem(arrays=[array_one, array_two],
                                 inverter_parameters={'pdc0': 8000})
    mc = ModelChain(system_two_arrays, location, aoi_model='no_loss',
                    spectral_model='no_loss')

    mc.run_model(weather)

    mc.results.dc
    mc.results.dc[0]

When ``weather`` is a single DataFrame, these data are broadcast and used
for all arrays. Weather data can be specified for each array, in which case
``weather`` needs to be a tuple or list of DataFrames in the same order as
the arrays of the PVSystem. To specify data separately for each array, provide a tuple
for ``weather`` where each element is a DataFrame containing the required data.

Air, module and cell temperatures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The different run_model methods allow the ModelChain to be run starting with
different irradiance data. Similarly, ModelChain run_model methods can be used
with different temperature data as long as cell temperature can be determined.
Temperature data are passed in the ``weather`` DataFrame and can include:

* cell temperature (``'cell_temperature'``). If passed in ``weather`` no
  cell temperature model is run.
* module temperature (``'module_temperature'``), typically measured on the rear surface.
  If found in ``weather`` and ``ModelChain.temperature_model='sapm'`` 
  (either set directly or inferred), the :py:meth:`~pvlib.modelchain.ModelChain.sapm_temp`
  method is used to calculate cell temperature. If ``ModelChain.temperature_model``
  is set to any other model, ``'module_temperature'`` is ignored.
* ambient air temperature (``'temp_air'``). In this case ``ModelChain.temperature_model``
  is used to calculate cell temeprature.

Cell temperature models also can use irradiance as input. All cell
temperature models expect POA irradiance (``'poa_global'``) as  input. When
``weather`` contains ``'effective_irradiance'`` but not
``'poa_global'``, ``'effective_irradiance'`` is substituted for calculating
cell temperature.


User-defined models
-------------------

Users may also write their own functions and pass them as arguments to
ModelChain. The first argument of the function must be a ModelChain
instance. For example, the functions below implement the PVUSA model and
a wrapper function appropriate for use with ModelChain. This follows the
pattern of implementing the core models using the simplest possible
functions, and then implementing wrappers to make them easier to use in
specific applications. Of course, you could implement it in a single
function if you wanted to.

.. ipython:: python

    def pvusa(poa_global, wind_speed, temp_air, a, b, c, d):
        """
        Calculates system power according to the PVUSA equation
        P = I * (a + b*I + c*W + d*T)
        where
        P is the output power,
        I is the plane of array irradiance,
        W is the wind speed, and
        T is the temperature
        a, b, c, d are empirically derived parameters.
        """
        return poa_global * (a + b*poa_global + c*wind_speed + d*temp_air)


    def pvusa_mc_wrapper(mc):
        """
        Calculate the dc power and assign it to mc.results.dc
        Set up to iterate over arrays and total_irrad. mc.system.arrays is
        always a tuple. However, when there is a single array
        mc.results.total_irrad will be a Series (if multiple arrays,
        total_irrad will be a tuple). In this case we put total_irrad
        in a list so that we can iterate. If we didn't put total_irrad
        in a list, iteration will access each value of the Series, one
        at a time.
        The iteration returns a tuple. If there is a single array, the
        tuple is of length 1. As a convenience, pvlib unwraps tuples of length 1
        that are assigned to ModelChain.results attributes.
        Returning mc is optional, but enables method chaining.
        """
        if mc.system.num_arrays == 1:
            total_irrads = [mc.results.total_irrad]
        else:
            total_irrads = mc.results.total_irrad
        mc.results.dc = tuple(
            pvusa(total_irrad['poa_global'], mc.results.weather['wind_speed'],
                  mc.results.weather['temp_air'], array.module_parameters['a'],
                  array.module_parameters['b'], array.module_parameters['c'],
                  array.module_parameters['d'])
            for total_irrad, array
            in zip(total_irrads, mc.system.arrays))
        return mc


    def pvusa_ac_mc(mc):
        # keep it simple
        mc.results.ac = mc.results.dc
        return mc


    def no_loss_temperature(mc):
        # keep it simple
        mc.results.cell_temperature = mc.results.weather['temp_air']
        return mc


.. ipython:: python

    module_parameters = {'a': 0.2, 'b': 0.00001, 'c': 0.001, 'd': -0.00005}
    pvusa_system = PVSystem(module_parameters=module_parameters)

    mc = ModelChain(pvusa_system, location,
                    dc_model=pvusa_mc_wrapper, ac_model=pvusa_ac_mc,
                    temperature_model=no_loss_temperature,
                    aoi_model='no_loss', spectral_model='no_loss')

A ModelChain object uses Python’s functools.partial function to assign
itself as the argument to the user-supplied functions.

.. ipython:: python

    mc.dc_model.func

The end result is that ModelChain.run_model works as expected!

.. ipython:: python

    mc = mc.run_model(weather)
    mc.results.dc
.. _clearsky:

Clear sky
=========

This section reviews the clear sky modeling capabilities of
pvlib-python.

pvlib-python supports two ways to generate clear sky irradiance:

1. A :py:class:`~pvlib.location.Location` object's
   :py:meth:`~pvlib.location.Location.get_clearsky` method.
2. The functions contained in the :py:mod:`~pvlib.clearsky` module,
   including :py:func:`~pvlib.clearsky.ineichen` and
   :py:func:`~pvlib.clearsky.simplified_solis`.

Users that work with simple time series data may prefer to use
:py:meth:`~pvlib.location.Location.get_clearsky`, while users
that want finer control, more explicit code, or work with
multidimensional data may prefer to use the basic functions in the
:py:mod:`~pvlib.clearsky` module.

The :ref:`location` subsection demonstrates the easiest way to obtain a
time series of clear sky data for a location. The :ref:`ineichen` and
:ref:`simplified_solis` subsections detail the clear sky algorithms and
input data. The :ref:`detect_clearsky` subsection demonstrates the use
of the clear sky detection algorithm.

We'll need these imports for the examples below.

.. ipython::

    In [1]: import os

    In [1]: import itertools

    In [1]: import matplotlib.pyplot as plt

    In [1]: import pandas as pd

    In [1]: import pvlib

    In [1]: from pvlib import clearsky, atmosphere, solarposition

    In [1]: from pvlib.location import Location

    In [1]: from pvlib.iotools import read_tmy3


.. _location:

Location
--------

The easiest way to obtain a time series of clear sky irradiance is to use a
:py:class:`~pvlib.location.Location` object's
:py:meth:`~pvlib.location.Location.get_clearsky` method. The
:py:meth:`~pvlib.location.Location.get_clearsky` method does the dirty
work of calculating solar position, extraterrestrial irradiance,
airmass, and atmospheric pressure, as appropriate, leaving the user to
only specify the most important parameters: time and atmospheric
attenuation. The time input must be a :py:class:`pandas.DatetimeIndex`,
while the atmospheric attenuation inputs may be constants or arrays.
The :py:meth:`~pvlib.location.Location.get_clearsky` method always
returns a :py:class:`pandas.DataFrame`.

.. ipython::

    In [1]: tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')

    In [1]: times = pd.date_range(start='2016-07-01', end='2016-07-04', freq='1min', tz=tus.tz)

    In [1]: cs = tus.get_clearsky(times)  # ineichen with climatology table by default

    In [1]: cs.plot();

    In [1]: plt.ylabel('Irradiance $W/m^2$');

    @savefig location-basic.png width=6in
    In [1]: plt.title('Ineichen, climatological turbidity');

The :py:meth:`~pvlib.location.Location.get_clearsky` method accepts a
model keyword argument and propagates additional arguments to the
functions that do the computation.

.. ipython::

    In [1]: cs = tus.get_clearsky(times, model='ineichen', linke_turbidity=3)

    In [1]: cs.plot();

    In [1]: plt.title('Ineichen, linke_turbidity=3');

    @savefig location-ineichen.png width=6in
    In [1]: plt.ylabel('Irradiance $W/m^2$');

.. ipython::

    In [1]: cs = tus.get_clearsky(times, model='simplified_solis', aod700=0.2, precipitable_water=3)

    In [1]: cs.plot();

    In [1]: plt.title('Simplfied Solis, aod700=0.2, precipitable_water=3');

    @savefig location-solis.png width=6in
    In [1]: plt.ylabel('Irradiance $W/m^2$');


See the sections below for more detail on the clear sky models.


.. _ineichen:

Ineichen and Perez
------------------

The Ineichen and Perez clear sky model parameterizes irradiance in terms
of the Linke turbidity [Ine02]_. pvlib-python implements this model in
the :py:func:`pvlib.clearsky.ineichen` function.


Turbidity data
^^^^^^^^^^^^^^

pvlib includes a file with monthly climatological turbidity values for
the globe. The code below creates turbidity maps for a few months of
the year. You could run it in a loop to create plots for all months.

.. ipython::

    In [1]: import calendar

    In [1]: import os

    In [1]: import h5py

    In [1]: pvlib_path = os.path.dirname(os.path.abspath(pvlib.clearsky.__file__))

    In [1]: filepath = os.path.join(pvlib_path, 'data', 'LinkeTurbidities.h5')

    In [1]: def plot_turbidity_map(month, vmin=1, vmax=100):
       ...:     plt.figure();
       ...:     with h5py.File(filepath, 'r') as lt_h5_file:
       ...:         ltdata = lt_h5_file['LinkeTurbidity'][:, :, month-1]
       ...:     plt.imshow(ltdata, vmin=vmin, vmax=vmax);
       ...:     # data is in units of 20 x turbidity
       ...:     plt.title('Linke turbidity x 20, ' + calendar.month_name[month]);
       ...:     plt.colorbar(shrink=0.5);
       ...:     plt.tight_layout();

    @savefig turbidity-1.png width=10in
    In [1]: plot_turbidity_map(1)

    @savefig turbidity-7.png width=10in
    In [1]: plot_turbidity_map(7)

The :py:func:`~pvlib.clearsky.lookup_linke_turbidity` function takes a
time, latitude, and longitude and gets the corresponding climatological
turbidity value for that time at those coordinates. By default, the
:py:func:`~pvlib.clearsky.lookup_linke_turbidity` function will linearly
interpolate turbidity from month to month, assuming that the raw data is
valid on 15th of each month. This interpolation removes discontinuities
in multi-month PV models. Here's a plot of a few locations in the
Southwest U.S. with and without interpolation. We chose points that are
relatively close so that you can get a better sense of the spatial noise
and variability of the data set. Note that the altitude of these sites
varies from 300 m to 1500 m.

.. ipython::

    In [1]: times = pd.date_range(start='2015-01-01', end='2016-01-01', freq='1D')

    In [1]: sites = [(32, -111, 'Tucson1'), (32.2, -110.9, 'Tucson2'),
       ...:          (33.5, -112.1, 'Phoenix'), (35.1, -106.6, 'Albuquerque')]

    In [1]: plt.figure();

    In [1]: for lat, lon, name in sites:
       ...:     turbidity = pvlib.clearsky.lookup_linke_turbidity(times, lat, lon, interp_turbidity=False)
       ...:     turbidity.plot(label=name)

    In [1]: plt.legend();

    In [1]: plt.title('Raw data (no interpolation)');

    @savefig turbidity-no-interp.png width=6in
    In [1]: plt.ylabel('Linke Turbidity');

    In [1]: plt.figure();

    In [1]: for lat, lon, name in sites:
       ...:     turbidity = pvlib.clearsky.lookup_linke_turbidity(times, lat, lon)
       ...:     turbidity.plot(label=name)

    In [1]: plt.legend();

    In [1]: plt.title('Interpolated to the day');

    @savefig turbidity-yes-interp.png width=6in
    In [1]: plt.ylabel('Linke Turbidity');

The :py:func:`~pvlib.atmosphere.kasten96_lt` function can be used to calculate
Linke turbidity [Kas96]_ as input to the clear sky Ineichen and Perez function.
The Kasten formulation requires precipitable water and broadband aerosol
optical depth (AOD). According to Molineaux, broadband AOD can be approximated
by a single measurement at 700-nm [Mol98]_. An alternate broadband AOD
approximation from Bird and Hulstrom combines AOD measured at two
wavelengths [Bir80]_, and is implemented in
:py:func:`~pvlib.atmosphere.bird_hulstrom80_aod_bb`.

.. ipython::

    In [1]: pvlib_data = os.path.join(os.path.dirname(pvlib.__file__), 'data')

    In [1]: mbars = 100  # conversion factor from mbars to Pa

    In [1]: tmy_file = os.path.join(pvlib_data, '703165TY.csv')  # TMY file

    In [1]: tmy_data, tmy_header = read_tmy3(tmy_file, coerce_year=1999)  # read TMY data

    In [1]: tl_historic = clearsky.lookup_linke_turbidity(time=tmy_data.index,
       ...:     latitude=tmy_header['latitude'], longitude=tmy_header['longitude'])

    In [1]: solpos = solarposition.get_solarposition(time=tmy_data.index,
       ...:     latitude=tmy_header['latitude'], longitude=tmy_header['longitude'],
       ...:     altitude=tmy_header['altitude'], pressure=tmy_data['Pressure']*mbars,
       ...:     temperature=tmy_data['DryBulb'])

    In [1]: am_rel = atmosphere.get_relative_airmass(solpos.apparent_zenith)

    In [1]: am_abs = atmosphere.get_absolute_airmass(am_rel, tmy_data['Pressure']*mbars)

    In [1]: airmass = pd.concat([am_rel, am_abs], axis=1).rename(
       ...:     columns={0: 'airmass_relative', 1: 'airmass_absolute'})

    In [1]: tl_calculated = atmosphere.kasten96_lt(
       ...:     airmass.airmass_absolute, tmy_data['Pwat'], tmy_data['AOD'])

    In [1]: tl = pd.concat([tl_historic, tl_calculated], axis=1).rename(
       ...:     columns={0:'Historic', 1:'Calculated'})

    In [1]: tl.index = tmy_data.index.tz_convert(None)  # remove timezone

    In [1]: tl.resample('W').mean().plot();

    In [1]: plt.grid()

    In [1]: plt.title('Comparison of Historic Linke Turbidity Factors vs. \n'
       ...:     'Kasten Pyrheliometric Formula at {name:s}, {state:s} ({usaf:d}TY)'.format(
       ...:     name=tmy_header['Name'], state=tmy_header['State'], usaf=tmy_header['USAF']));

    In [1]: plt.ylabel('Linke Turbidity Factor, TL');

    @savefig kasten-tl.png width=10in
    In [1]: plt.tight_layout()


Examples
^^^^^^^^

A clear sky time series using only basic pvlib functions.

.. ipython::

    In [1]: latitude, longitude, tz, altitude, name = 32.2, -111, 'US/Arizona', 700, 'Tucson'

    In [1]: times = pd.date_range(start='2014-01-01', end='2014-01-02', freq='1Min', tz=tz)

    In [1]: solpos = pvlib.solarposition.get_solarposition(times, latitude, longitude)

    In [1]: apparent_zenith = solpos['apparent_zenith']

    In [1]: airmass = pvlib.atmosphere.get_relative_airmass(apparent_zenith)

    In [1]: pressure = pvlib.atmosphere.alt2pres(altitude)

    In [1]: airmass = pvlib.atmosphere.get_absolute_airmass(airmass, pressure)

    In [1]: linke_turbidity = pvlib.clearsky.lookup_linke_turbidity(times, latitude, longitude)

    In [1]: dni_extra = pvlib.irradiance.get_extra_radiation(times)

    # an input is a pandas Series, so solis is a DataFrame
    In [1]: ineichen = clearsky.ineichen(apparent_zenith, airmass, linke_turbidity, altitude, dni_extra)

    In [1]: plt.figure();

    In [1]: ax = ineichen.plot()

    In [1]: ax.set_ylabel('Irradiance $W/m^2$');

    In [1]: ax.set_title('Ineichen Clear Sky Model');

    @savefig ineichen-vs-time-climo.png width=6in
    In [1]: ax.legend(loc=2);


The input data types determine the returned output type. Array input
results in an OrderedDict of array output, and Series input results in a
DataFrame output. The keys are 'ghi', 'dni', and 'dhi'.

Grid with a clear sky irradiance for a few turbidity values.

.. ipython::

    In [1]: times = pd.date_range(start='2014-09-01', end='2014-09-02', freq='1Min', tz=tz)

    In [1]: solpos = pvlib.solarposition.get_solarposition(times, latitude, longitude)

    In [1]: apparent_zenith = solpos['apparent_zenith']

    In [1]: airmass = pvlib.atmosphere.get_relative_airmass(apparent_zenith)

    In [1]: pressure = pvlib.atmosphere.alt2pres(altitude)

    In [1]: airmass = pvlib.atmosphere.get_absolute_airmass(airmass, pressure)

    In [1]: linke_turbidity = pvlib.clearsky.lookup_linke_turbidity(times, latitude, longitude)

    In [1]: print('climatological linke_turbidity = {}'.format(linke_turbidity.mean()))

    In [1]: dni_extra = pvlib.irradiance.get_extra_radiation(times)

    In [1]: linke_turbidities = [linke_turbidity.mean(), 2, 4]

    In [1]: fig, axes = plt.subplots(ncols=3, nrows=1, sharex=True, sharey=True, squeeze=True, figsize=(12, 4))

    In [1]: axes = axes.flatten()

    In [1]: for linke_turbidity, ax in zip(linke_turbidities, axes):
       ...:     ineichen = clearsky.ineichen(apparent_zenith, airmass, linke_turbidity, altitude, dni_extra)
       ...:     ineichen.plot(ax=ax, title='Linke turbidity = {:0.1f}'.format(linke_turbidity));

    @savefig ineichen-grid.png width=10in
    In [1]: ax.legend(loc=1);

    @suppress
    In [1]: plt.close();


Validation
^^^^^^^^^^

See [Ine02]_, [Ren12]_.

Will Holmgren compared pvlib's Ineichen model and climatological
turbidity to `SoDa's McClear service
<http://www.soda-pro.com/web-services/radiation/cams-mcclear>`_ in
Arizona. Here are links to an
`ipynb notebook
<https://forecasting.energy.arizona.edu/media/ineichen_vs_mcclear.ipynb>`_
and its `html rendering
<https://forecasting.energy.arizona.edu/media/ineichen_vs_mcclear.html>`_.


.. _simplified_solis:

Simplified Solis
----------------

The Simplified Solis model parameterizes irradiance in terms of
precipitable water and aerosol optical depth [Ine08ss]_. pvlib-python
implements this model in the :py:func:`pvlib.clearsky.simplified_solis`
function.

Aerosol and precipitable water data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are a number of sources for aerosol and precipitable water data
of varying accuracy, global coverage, and temporal resolution.
Ground based aerosol data can be obtained from
`Aeronet <http://aeronet.gsfc.nasa.gov>`_. Precipitable water can be obtained
from `radiosondes <http://weather.uwyo.edu/upperair/sounding.html>`_,
`ESRL GPS-MET <http://gpsmet.noaa.gov/cgi-bin/gnuplots/rti.cgi>`_, or
derived from surface relative humidity using functions such as
:py:func:`pvlib.atmosphere.gueymard94_pw`.
Numerous gridded products from satellites, weather models, and climate models
contain one or both of aerosols and precipitable water. Consider data
from the `ECMWF <https://software.ecmwf.int/wiki/display/WEBAPI/Access+ECMWF+Public+Datasets>`_
and `SoDa <http://www.soda-pro.com/web-services/radiation/cams-mcclear>`_.

Aerosol optical depth (AOD) is a function of wavelength, and the Simplified
Solis model requires AOD at 700 nm.
:py:func:`~pvlib.atmosphere.angstrom_aod_at_lambda` is useful for converting
AOD between different wavelengths using the Angstrom turbidity model. The
Angstrom exponent, :math:`\alpha`, can be calculated from AOD at two
wavelengths with :py:func:`~pvlib.atmosphere.angstrom_alpha`.
[Ine08con]_, [Ine16]_, [Ang61]_.

.. ipython::

    In [1]: aod1240nm = 1.2  # fictitious AOD measured at 1240-nm

    In [1]: aod550nm = 3.1  # fictitious AOD measured at 550-nm

    In [1]: alpha_exponent = atmosphere.angstrom_alpha(aod1240nm, 1240, aod550nm, 550)

    In [1]: aod700nm = atmosphere.angstrom_aod_at_lambda(aod1240nm, 1240, alpha_exponent, 700)

    In [1]: aod380nm = atmosphere.angstrom_aod_at_lambda(aod550nm, 550, alpha_exponent, 380)

    In [1]: aod500nm = atmosphere.angstrom_aod_at_lambda(aod550nm, 550, alpha_exponent, 500)

    In [1]: aod_bb = atmosphere.bird_hulstrom80_aod_bb(aod380nm, aod500nm)

    In [1]: print('compare AOD at 700-nm = {:g}, to estimated broadband AOD = {:g}, '
       ...:     'with alpha = {:g}'.format(aod700nm, aod_bb, alpha_exponent))

Examples
^^^^^^^^

A clear sky time series using only basic pvlib functions.

.. ipython::

    In [1]: latitude, longitude, tz, altitude, name = 32.2, -111, 'US/Arizona', 700, 'Tucson'

    In [1]: times = pd.date_range(start='2014-01-01', end='2014-01-02', freq='1Min', tz=tz)

    In [1]: solpos = pvlib.solarposition.get_solarposition(times, latitude, longitude)

    In [1]: apparent_elevation = solpos['apparent_elevation']

    In [1]: aod700 = 0.1

    In [1]: precipitable_water = 1

    In [1]: pressure = pvlib.atmosphere.alt2pres(altitude)

    In [1]: dni_extra = pvlib.irradiance.get_extra_radiation(times)

    # an input is a Series, so solis is a DataFrame
    In [1]: solis = clearsky.simplified_solis(apparent_elevation, aod700, precipitable_water,
       ...:                                   pressure, dni_extra)

    In [1]: ax = solis.plot();

    In [1]: ax.set_ylabel('Irradiance $W/m^2$');

    In [1]: ax.set_title('Simplified Solis Clear Sky Model');

    @savefig solis-vs-time-0.1-1.png width=6in
    In [1]: ax.legend(loc=2);

    @suppress
    In [1]: plt.close();

The input data types determine the returned output type. Array input
results in an OrderedDict of array output, and Series input results in a
DataFrame output. The keys are 'ghi', 'dni', and 'dhi'.

Irradiance as a function of solar elevation.

.. ipython::

    In [1]: apparent_elevation = pd.Series(np.linspace(-10, 90, 101))

    In [1]: aod700 = 0.1

    In [1]: precipitable_water = 1

    In [1]: pressure = 101325

    In [1]: dni_extra = 1364

    In [1]: solis = clearsky.simplified_solis(apparent_elevation, aod700,
       ...:                                   precipitable_water, pressure, dni_extra)

    In [1]: ax = solis.plot();

    In [1]: ax.set_xlabel('Apparent elevation (deg)');

    In [1]: ax.set_ylabel('Irradiance $W/m^2$');

    In [1]: ax.set_title('Irradiance vs Solar Elevation')

    @savefig solis-vs-elevation.png width=6in
    In [1]: ax.legend(loc=2);

    @suppress
    In [1]: plt.close();


Grid with clear sky irradiance for a few PW and AOD values.

.. ipython::

    In [1]: times = pd.date_range(start='2014-09-01', end='2014-09-02', freq='1Min', tz=tz)

    In [1]: solpos = pvlib.solarposition.get_solarposition(times, latitude, longitude)

    In [1]: apparent_elevation = solpos['apparent_elevation']

    In [1]: pressure = pvlib.atmosphere.alt2pres(altitude)

    In [1]: dni_extra = pvlib.irradiance.get_extra_radiation(times)

    In [1]: aod700 = [0.01, 0.1]

    In [1]: precipitable_water = [0.5, 5]

    In [1]: fig, axes = plt.subplots(ncols=2, nrows=2, sharex=True, sharey=True, squeeze=True)

    In [1]: axes = axes.flatten()

    @savefig solis-grid.png width=10in
    In [1]: for (aod, pw), ax in zip(itertools.chain(itertools.product(aod700, precipitable_water)), axes):
       ...:     cs = clearsky.simplified_solis(apparent_elevation, aod, pw, pressure, dni_extra)
       ...:     cs.plot(ax=ax, title='aod700={}, pw={}'.format(aod, pw))

    @suppress
    In [1]: plt.close();

Contour plots of irradiance as a function of both PW and AOD.

.. ipython::

    In [1]: aod700 = np.linspace(0, 0.5, 101)

    In [1]: precipitable_water = np.linspace(0, 10, 101)

    In [1]: apparent_elevation = 70

    In [1]: pressure = 101325

    In [1]: dni_extra = 1364

    In [1]: aod700, precipitable_water = np.meshgrid(aod700, precipitable_water)

    # inputs are arrays, so solis is an OrderedDict
    In [1]: solis = clearsky.simplified_solis(apparent_elevation, aod700,
       ...:                                   precipitable_water, pressure,
       ...:                                   dni_extra)

    In [1]: n = 15

    In [1]: vmin = None

    In [1]: vmax = None

    In [1]: def plot_solis(key):
       ...:     irrad = solis[key]
       ...:     fig, ax = plt.subplots()
       ...:     im = ax.contour(aod700, precipitable_water, irrad[:, :], n, vmin=vmin, vmax=vmax)
       ...:     imf = ax.contourf(aod700, precipitable_water, irrad[:, :], n, vmin=vmin, vmax=vmax)
       ...:     ax.set_xlabel('AOD')
       ...:     ax.set_ylabel('Precipitable water (cm)')
       ...:     ax.clabel(im, colors='k', fmt='%.0f')
       ...:     fig.colorbar(imf, label='{} (W/m**2)'.format(key))
       ...:     ax.set_title('{}, elevation={}'.format(key, apparent_elevation))

.. ipython::

    @savefig solis-ghi.png width=10in
    In [1]: plot_solis('ghi')

    @suppress
    In [1]: plt.close();

    @savefig solis-dni.png width=10in
    In [1]: plot_solis('dni')

    @suppress
    In [1]: plt.close();

    @savefig solis-dhi.png width=10in
    In [1]: plot_solis('dhi')

    @suppress
    In [1]: plt.close();


Validation
^^^^^^^^^^

See [Ine16]_.

We encourage users to compare the pvlib implementation to Ineichen's
`Excel tool <http://www.unige.ch/energie/fr/equipe/ineichen/solis-tool/>`_.

.. _detect_clearsky:

Detect Clearsky
---------------

The :py:func:`~pvlib.clearsky.detect_clearsky` function implements the
[Ren16]_ algorithm to detect the clear and cloudy points of a time
series. The algorithm was designed and validated for analyzing GHI time
series only. Users may attempt to apply it to other types of time series
data using different filter settings, but should be skeptical of the
results.

The algorithm detects clear sky times by comparing statistics for a
measured time series and an expected clearsky time series. Statistics
are calculated using a sliding time window (e.g., 10 minutes). An
iterative algorithm identifies clear periods, uses the identified
periods to estimate bias in the clearsky data, scales the clearsky data
and repeats.

Clear times are identified by meeting 5 criteria. Default values for
these thresholds are appropriate for 10 minute windows of 1 minute GHI
data.

Next, we show a simple example of applying the algorithm to synthetic
GHI data. We first generate and plot the clear sky and measured data.

.. ipython:: python

    abq = Location(35.04, -106.62, altitude=1619)

    times = pd.date_range(start='2012-04-01 10:30:00', tz='Etc/GMT+7', periods=30, freq='1min')

    cs = abq.get_clearsky(times)

    # scale clear sky data to account for possibility of different turbidity
    ghi = cs['ghi']*.953

    # add a cloud event
    ghi['2012-04-01 10:42:00':'2012-04-01 10:44:00'] = [500, 300, 400]

    # add an overirradiance event
    ghi['2012-04-01 10:56:00'] = 950

    fig, ax = plt.subplots()

    ghi.plot(label='input');

    cs['ghi'].plot(label='ineichen clear');

    ax.set_ylabel('Irradiance $W/m^2$');

    @savefig detect-clear-ghi.png width=10in
    plt.legend(loc=4);

    @suppress
    plt.close();

Now we run the synthetic data and clear sky estimate through the
:py:func:`~pvlib.clearsky.detect_clearsky` function.

.. ipython:: python

    clear_samples = clearsky.detect_clearsky(ghi, cs['ghi'], cs.index, 10)

    fig, ax = plt.subplots()

    clear_samples.astype(int).plot();

    @savefig detect-clear-detected.png width=10in
    ax.set_ylabel('Clear (1) or Cloudy (0)');

    @suppress
    plt.close();

The algorithm detected the cloud event and the overirradiance event.


References
----------

.. [Ine02] P. Ineichen and R. Perez, "A New airmass independent formulation for
   the Linke turbidity coefficient", Solar Energy, 73, pp. 151-157,
   2002.

.. [Ine08ss] P. Ineichen, "A broadband simplified version of the
   Solis clear sky model," Solar Energy, 82, 758-762 (2008).

.. [Ine16] P. Ineichen, "Validation of models that estimate the clear
   sky global and beam solar irradiance," Solar Energy, 132,
   332-344 (2016).

.. [Ine08con] P. Ineichen, "Conversion function between the Linke turbidity
   and the atmospheric water vapor and aerosol content", Solar Energy,
   82, 1095 (2008).

.. [Ren12] M. Reno, C. Hansen, and J. Stein, "Global Horizontal Irradiance Clear
   Sky Models: Implementation and Analysis", Sandia National
   Laboratories, SAND2012-2389, 2012.

.. [Ren16] Reno, M.J. and C.W. Hansen, "Identification of periods of clear
   sky irradiance in time series of GHI measurements" Renewable Energy,
   v90, p. 520-531, 2016.

.. [Mol98] B. Molineaux, P. Ineichen, and N. O’Neill, “Equivalence of
   pyrheliometric and monochromatic aerosol optical depths at a single key
   wavelength.,” Appl. Opt., vol. 37, no. 30, pp. 7008–18, Oct. 1998.

.. [Kas96] F. Kasten, “The linke turbidity factor based on improved values
   of the integral Rayleigh optical thickness,” Sol. Energy, vol. 56, no. 3,
   pp. 239–244, Mar. 1996.

.. [Bir80] R. E. Bird and R. L. Hulstrom, “Direct Insolation Models,”
   1980.

.. [Ang61] A. ÅNGSTRÖM, “Techniques of Determinig the Turbidity of the
   Atmosphere,” Tellus A, vol. 13, no. 2, pp. 214–223, 1961.
.. _timetimezones:

Time and time zones
===================

Dealing with time and time zones can be a frustrating experience in any
programming language and for any application. pvlib-python relies on
:py:mod:`pandas` and `pytz <http://pythonhosted.org/pytz/>`_ to handle
time and time zones. Therefore, the vast majority of the information in
this document applies to any time series analysis using pandas and is
not specific to pvlib-python.

General functionality
---------------------

pvlib makes extensive use of pandas due to its excellent time series
functionality. Take the time to become familiar with pandas' `Time
Series / Date functionality page
<http://pandas.pydata.org/pandas-docs/version/0.18.0/timeseries.html>`_.
It is also worthwhile to become familiar with pure Python's
:py:mod:`python:datetime` module, although we usually recommend
using the corresponding pandas functionality where possible.

First, we'll import the libraries that we'll use to explore the basic
time and time zone functionality in python and pvlib.

.. ipython:: python

    import datetime
    import pandas as pd
    import pytz


Finding a time zone
*******************

pytz is based on the Olson time zone database. You can obtain a list of
all valid time zone strings with ``pytz.all_timezones``. It's a long
list, so we only print every 20th time zone.

.. ipython:: python

    len(pytz.all_timezones)
    pytz.all_timezones[::20]

Wikipedia's `List of tz database time zones
<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>`_ is also
good reference.

The ``pytz.country_timezones`` function is useful, too.

.. ipython:: python

    pytz.country_timezones('US')

And don't forget about Python's :py:func:`python:filter` function.

.. ipython:: python

    list(filter(lambda x: 'GMT' in x, pytz.all_timezones))

Note that while pytz has ``'EST'`` and ``'MST'``, it does not have
``'PST'``. Use ``'Etc/GMT+8'`` instead, or see :ref:`fixedoffsets`.

Timestamps
**********

:py:class:`pandas.Timestamp` and :py:class:`pandas.DatetimeIndex`
can be created in many ways. Here we focus on the time zone issues
surrounding them; see the pandas documentation for more information.

First, create a time zone naive pandas.Timestamp.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00')

You can specify the time zone using the ``tz`` keyword argument or the
``tz_localize`` method of Timestamp and DatetimeIndex objects.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00', tz='America/Denver')
    pd.Timestamp('2015-1-1 00:00').tz_localize('America/Denver')

Localized Timestamps can be converted from one time zone to another.

.. ipython:: python

    midnight_mst = pd.Timestamp('2015-1-1 00:00', tz='America/Denver')
    corresponding_utc = midnight_mst.tz_convert('UTC')  # returns a new Timestamp
    corresponding_utc

It does not make sense to convert a time stamp that has not been
localized, and pandas will raise an exception if you try to do so.

.. ipython:: python
   :okexcept:

    midnight = pd.Timestamp('2015-1-1 00:00')
    midnight.tz_convert('UTC')

The difference between ``tz_localize`` and ``tz_convert`` is a common
source of confusion for new users. Just remember: localize first,
convert later.

Daylight savings time
*********************

Some time zones are aware of daylight savings time and some are not. For
example the winter time results are the same for US/Mountain and MST,
but the summer time results are not.

Note the UTC offset in winter...

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00').tz_localize('US/Mountain')
    pd.Timestamp('2015-1-1 00:00').tz_localize('Etc/GMT+7')

vs. the UTC offset in summer...

.. ipython:: python

    pd.Timestamp('2015-6-1 00:00').tz_localize('US/Mountain')
    pd.Timestamp('2015-6-1 00:00').tz_localize('Etc/GMT+7')

pandas and pytz make this time zone handling possible because pandas
stores all times as integer nanoseconds since January 1, 1970.
Here is the pandas time representation of the integers 1 and 1e9.

.. ipython:: python

    pd.Timestamp(1)
    pd.Timestamp(1e9)

So if we specify times consistent with the specified time zone, pandas
will use the same integer to represent them.

.. ipython:: python

    # US/Mountain
    pd.Timestamp('2015-6-1 01:00', tz='US/Mountain').value

    # MST
    pd.Timestamp('2015-6-1 00:00', tz='Etc/GMT+7').value

    # Europe/Berlin
    pd.Timestamp('2015-6-1 09:00', tz='Europe/Berlin').value

    # UTC
    pd.Timestamp('2015-6-1 07:00', tz='UTC').value

    # UTC
    pd.Timestamp('2015-6-1 07:00').value

It's ultimately these integers that are used when calculating quantities
in pvlib such as solar position.

As stated above, pandas will assume UTC if you do not specify a time
zone. This is dangerous, and we recommend using localized timeseries,
even if it is UTC.


.. _fixedoffsets:

Fixed offsets
*************

The ``'Etc/GMT*'`` time zones mentioned above provide fixed offset
specifications, but watch out for the counter-intuitive sign convention.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00', tz='Etc/GMT-2')

Fixed offset time zones can also be specified as offset minutes
from UTC using ``pytz.FixedOffset``.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00', tz=pytz.FixedOffset(120))

You can also specify the fixed offset directly in the ``tz_localize``
method, however, be aware that this is not documented and that the
offset must be in seconds, not minutes.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00', tz=7200)

Yet another way to specify a time zone with a fixed offset is by using
the string formulation.

.. ipython:: python

    pd.Timestamp('2015-1-1 00:00+0200')


Native Python objects
*********************

Sometimes it's convenient to use native Python
:py:class:`python:datetime.date` and
:py:class:`python:datetime.datetime` objects, so we demonstrate their
use next. pandas Timestamp objects can also be created from time zone
aware or naive
:py:class:`python:datetime.datetime` objects. The behavior is as
expected.

.. ipython:: python

    # tz naive python datetime.datetime object
    naive_python_dt = datetime.datetime(2015, 6, 1, 0)

    # tz naive pandas Timestamp object
    pd.Timestamp(naive_python_dt)

    # tz aware python datetime.datetime object
    aware_python_dt = pytz.timezone('US/Mountain').localize(naive_python_dt)

    # tz aware pandas Timestamp object
    pd.Timestamp(aware_python_dt)

One thing to watch out for is that python
:py:class:`python:datetime.date` objects gain time information when
passed to ``Timestamp``.

.. ipython:: python

    # tz naive python datetime.date object (no time info)
    naive_python_date = datetime.date(2015, 6, 1)

    # tz naive pandas Timestamp object (time=midnight)
    pd.Timestamp(naive_python_date)

You cannot localize a native Python date object.

.. ipython:: python
   :okexcept:

    # fail
    pytz.timezone('US/Mountain').localize(naive_python_date)


pvlib-specific functionality
----------------------------

.. note::

    This section applies to pvlib >= 0.3. Version 0.2 of pvlib used a
    ``Location`` object's ``tz`` attribute to auto-magically correct for
    some time zone issues. This behavior was counter-intuitive to many
    users and was removed in version 0.3.

How does this general functionality interact with pvlib? Perhaps the two
most common places to get tripped up with time and time zone issues in
solar power analysis occur during data import and solar position
calculations.

Data import
***********

Let's first examine how pvlib handles time when it imports a TMY3 file.

.. ipython:: python

    import os
    import inspect
    import pvlib

    # some gymnastics to find the example file
    pvlib_abspath = os.path.dirname(os.path.abspath(inspect.getfile(pvlib)))
    file_abspath = os.path.join(pvlib_abspath, 'data', '703165TY.csv')
    tmy3_data, tmy3_metadata = pvlib.iotools.read_tmy3(file_abspath)

    tmy3_metadata

The metadata has a ``'TZ'`` key with a value of ``-9.0``. This is the
UTC offset in hours in which the data has been recorded. The
:py:func:`~pvlib.iotools.read_tmy3` function read the data in the file,
created a :py:class:`~pandas.DataFrame` with that data, and then
localized the DataFrame's index to have this fixed offset. Here, we
print just a few of the rows and columns of the large dataframe.

.. ipython:: python

    tmy3_data.index.tz

    tmy3_data.loc[tmy3_data.index[0:3], ['GHI', 'DNI', 'AOD']]

The :py:func:`~pvlib.iotools.read_tmy2` function also returns a DataFrame
with a localized DatetimeIndex.

Solar position
**************

The correct solar position can be immediately calculated from the
DataFrame's index since the index has been localized.

.. ipython:: python

    solar_position = pvlib.solarposition.get_solarposition(tmy3_data.index,
                                                           tmy3_metadata['latitude'],
                                                           tmy3_metadata['longitude'])

    ax = solar_position.loc[solar_position.index[0:24], ['apparent_zenith', 'apparent_elevation', 'azimuth']].plot()

    ax.legend(loc=1);
    ax.axhline(0, color='darkgray');  # add 0 deg line for sunrise/sunset
    ax.axhline(180, color='darkgray');  # add 180 deg line for azimuth at solar noon
    ax.set_ylim(-60, 200);  # zoom in, but cuts off full azimuth range
    ax.set_xlabel('Local time ({})'.format(solar_position.index.tz));
    @savefig solar-position.png width=6in
    ax.set_ylabel('(degrees)');

`According to the US Navy
<http://aa.usno.navy.mil/rstt/onedaytable?ID=AA&year=1997&month=1&day=1&state=AK&place=sand+point>`_,
on January 1, 1997 at Sand Point, Alaska, sunrise was at 10:09 am, solar
noon was at 1:46 pm, and sunset was at 5:23 pm. This is consistent with
the data plotted above (and depressing).

Solar position (assumed UTC)
****************************

What if we had a DatetimeIndex that was not localized, such as the one
below? The solar position calculator will assume UTC time.

.. ipython:: python

    index = pd.date_range(start='1997-01-01 01:00', freq='1h', periods=24)
    index

    solar_position_notz = pvlib.solarposition.get_solarposition(index,
                                                                tmy3_metadata['latitude'],
                                                                tmy3_metadata['longitude'])

    ax = solar_position_notz.loc[solar_position_notz.index[0:24], ['apparent_zenith', 'apparent_elevation', 'azimuth']].plot()

    ax.legend(loc=1);
    ax.axhline(0, color='darkgray');  # add 0 deg line for sunrise/sunset
    ax.axhline(180, color='darkgray');  # add 180 deg line for azimuth at solar noon
    ax.set_ylim(-60, 200);  # zoom in, but cuts off full azimuth range
    ax.set_xlabel('Time (UTC)');
    @savefig solar-position-nolocal.png width=6in
    ax.set_ylabel('(degrees)');

This looks like the plot above, but shifted by 9 hours.

Solar position (calculate and convert)
**************************************

In principle, one could localize the tz-naive solar position data to
UTC, and then convert it to the desired time zone.

.. ipython:: python

    fixed_tz = pytz.FixedOffset(tmy3_metadata['TZ'] * 60)
    solar_position_hack = solar_position_notz.tz_localize('UTC').tz_convert(fixed_tz)

    solar_position_hack.index

    ax = solar_position_hack.loc[solar_position_hack.index[0:24], ['apparent_zenith', 'apparent_elevation', 'azimuth']].plot()

    ax.legend(loc=1);
    ax.axhline(0, color='darkgray');  # add 0 deg line for sunrise/sunset
    ax.axhline(180, color='darkgray');  # add 180 deg line for azimuth at solar noon
    ax.set_ylim(-60, 200);  # zoom in, but cuts off full azimuth range
    ax.set_xlabel('Local time ({})'.format(solar_position_hack.index.tz));
    @savefig solar-position-hack.png width=6in
    ax.set_ylabel('(degrees)');

Note that the time has been correctly localized and converted, however,
the calculation bounds still correspond to the original assumed-UTC range.

For this and other reasons, we recommend that users supply time zone
information at the beginning of a calculation rather than localizing and
converting the results at the end of a calculation.
.. _installation:

Installation
============

Installing pvlib-python ranges from trivial to difficult depending
on your python experience, how you want to use pvlib, and your
system configuration.

**Do you already have Python and the NumPy and Pandas libraries?**

    If the answer to this is *No*, follow the :ref:`nopython` instructions
    to obtain the Anaconda Python distribution before proceeding.

**Do you want to use the pvlib-python as-is, or do you want to be
able to edit the source code?**

    If you want to use pvlib-python *as-is*, follow the simple
    :ref:`standardrelease` instructions.

    If you want to be able to *edit the source code*, follow the
    :ref:`editablelibrary` instructions.

Installing pvlib-python is similar to installing most scientific python
packages, so see the :ref:`references` section for further help.

Please see the :ref:`compatibility` section for information on the
optional packages that are needed for some pvlib-python features.

.. _nopython:

If you don't have Python
------------------------

There are many ways to install Python on your system, but the Anaconda
Python distribution is the easiest way for most new users to get
started. Anaconda includes all of the popular libraries that you'll need
for pvlib, including Pandas, NumPy, and SciPy.

#. **Install** the Anaconda Python distribution available at
   `Anaconda.com <https://www.anaconda.com/download/>`_.

See `What is Anaconda? <https://www.anaconda.com/what-is-anaconda/>`_
and the `Anaconda Documentation <https://docs.anaconda.com/anaconda/>`_
for more information.

You can now install pvlib-python by one of the methods below.


.. _standardrelease:

Install standard release
------------------------

Users may install pvlib-python using either the
`conda <https://conda.io/docs/>`_ or `pip <https://pip.pypa.io>`_
package manager. We recommend that most users install pvlib-python
using the conda package manager in the
`Anaconda Python distribution <https://www.anaconda.com/what-is-anaconda/>`_.
To install the most recent stable release of pvlib-python in a
non-editable way, use one of the following commands to install pvlib-python::

    # get the package from the pvlib conda channel
    # best option for installing pvlib in the base Anaconda distribution
    conda install -c pvlib pvlib

    # get the package from the conda-forge conda channel
    # best option if using pvlib.forecast module
    # strongly recommend installing in a separate conda env as shown below
    conda create -n pvlib -c conda-forge pvlib-python; conda activate pvlib

    # get the package from the Python Package Index
    # best option if you know what you are doing
    pip install pvlib

    # get pvlib and optional dependencies from the Python Package Index
    # another option if you know what you are doing
    pip install pvlib[optional]

.. note::

    By default, pvlib will not install some infrequently used dependencies.
    If you run into an error such as
    `ModuleNotFoundError: No module named 'netCDF4'`
    you can either install pvlib with all optional dependencies using
    `pip install pvlib[optional]`, or you can install pvlib from conda-forge
    `conda create -n pvlib -c conda-forge pvlib-python; conda activate pvlib`.

If your system complains that you don't have access privileges or asks
for a password then you're probably trying to install pvlib into your
system's Python distribution. This is usually a bad idea and you should
follow the :ref:`nopython` instructions before installing pvlib.

You may still want to download the Python source code so that you can
easily get all of the Jupyter Notebook tutorials. Either clone the `git
repository <https://github.com/pvlib/pvlib-python>`_ or go to the
`Releases page <https://github.com/pvlib/pvlib-python/releases>`_ to
download the zip file of the most recent release. You can also use the
nbviewer website to choose a tutorial to experiment with. Go to our
`nbviewer tutorial page
<http://nbviewer.jupyter.org/github/pvlib/pvlib-python/tree/master/docs/
tutorials/>`_.


.. _editablelibrary:

Install as an editable library
------------------------------

Installing pvlib-python as an editable library involves 3 steps:

1. :ref:`obtainsource`
2. :ref:`setupenvironment`
3. :ref:`installsource`

None of these steps are particularly challenging, but they become
more difficult when combined.
With a little bit of practice the process will be fast and easy.
Experienced users can easily execute these steps in less than a minute.
You'll get there.

.. _obtainsource:

Obtain the source code
~~~~~~~~~~~~~~~~~~~~~~

We will briefly describe how to obtain the pvlib-python source code
using the git/GitHub version control system. We strongly encourage users
to learn how to use these powerful tools (see the :ref:`references`!),
but we also recognize that they can be a substantial roadblock to
getting started with pvlib-python. Therefore, you should know that you
can download a zip file of the most recent development version of the
source code by clicking on the **Download Zip** button on the right side
of our `GitHub page <https://github.com/pvlib/pvlib-python>`_ or
download a zip file of any stable release from our `Releases page
<https://github.com/pvlib/pvlib-python/releases>`_.

Follow these steps to obtain the library using git/GitHub:

#. **Download** the `GitHub Desktop <https://desktop.github.com>`_ application.
#. **Fork** the pvlib-python project by clicking on the "Fork" button on
   the upper right corner of the
   `pvlib-python GitHub page <https://github.com/pvlib/pvlib-python>`_.
#. **Clone** your fork to your computer using the GitHub Desktop application
   by clicking on the *Clone to Desktop* button on your fork's homepage.
   This button is circled in the image below. Remember the system path that
   you clone the library to.

.. image:: ../_images/clonebutton.png

Please see GitHub's
`Forking Projects <https://guides.github.com/activities/forking/>`_,
`Fork A Repo <https://help.github.com/articles/fork-a-repo/>`_,
and the `git-scm <https://git-scm.com/documentation>`_ for
more details.

.. _setupenvironment:

Set up a virtual environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We strongly recommend working in a `virtual environment
<http://astropy.readthedocs.org/en/latest/development/workflow/
virtual_pythons.html>`_ if you're going to use an editable version
of the library. You can skip this step if:

#. You already have Anaconda or another scientific Python distribution
#. You don't mind polluting your Python installation with your
   development version of pvlib.
#. You don't want to work with multiple versions of pvlib.

There are many ways to use virtual environments in Python,
but Anaconda again provides the easiest solution. These are often
referred to as *conda environments*, but they're the same for our purposes.

#. **Create** a new conda environment for pvlib and pre-install
   the required packages into the environment:
   ``conda create --name pvlibdev python pandas scipy``
#. **Activate** the new conda environment: ``conda activate pvlibdev``
#. **Install** additional packages into your development environment:
   ``conda install jupyter ipython matplotlib pytest nose flake8``

The `conda documentation <https://conda.io/docs/index.html>`_ has more
information on how to use conda virtual environments. You can also add
``-h`` to most pip and conda commands to get help (e.g. ``conda -h`` or
``conda env -h``)

.. _installsource:

Install the source code
~~~~~~~~~~~~~~~~~~~~~~~

Good news -- installing the source code is the easiest part!
With your conda/virtual environment still active...

#. **Install** pvlib-python in "development mode" by running
   ``pip install -e .`` from within the directory you previously cloned.
   Consider installing pvlib using ``pip install -e .[all]`` so that
   you can run the unit tests and build the documentation.
   Your clone directory is probably similar to
   ``C:\Users\%USER%\Documents\GitHub\pvlib-python``(Windows) or
   ``/Users/%USER%/Documents/pvlib-python`` (Mac).
#. **Test** your installation by running ``python -c 'import pvlib'``.
   You're good to go if it returns without an exception.

The version of pvlib-python that is on that path is now available
as an installed package inside your conda/virtual environment.

Any changes that you make to this pvlib-python will be available inside
your environment. If you run a git checkout, branch, or pull command the
result will be applied to your pvlib-python installation. This
is great for development. Note, however, that you will need to use
Python's ``reload`` function (`python 3
<https://docs.python.org/3/library/importlib.html#importlib.reload>`_)
if you make changes to pvlib during an interactive Python
session (including a Jupyter notebook). Restarting the Python
interpreter will also work.

Remember to ``conda activate pvlibdev`` (or whatever you named your
environment) when you start a new shell or terminal.

.. _compatibility:

Compatibility
-------------

pvlib-python is compatible with Python 3.

pvlib-python requires Pandas, Numpy, and SciPy. The minimum version requirements
are specified in
`setup.py <https://github.com/pvlib/pvlib-python/blob/master/setup.py>`_.
They are typically releases from several years ago.

A handful of pvlib-python features require additional packages that must
be installed separately using pip or conda. These packages/features
include:

* statsmodels: parameter fitting
* numba: fastest solar position calculations
* pyephem: solar positions calculations using an astronomical library
* siphon: forecasting PV power using the pvlib.forecast module

The Anaconda distribution includes most of the above packages.

Alternatively, users may install all optional dependencies using

    pip install pvlib[optional]


.. _nrelspa:

NREL SPA algorithm
------------------

pvlib-python is distributed with several validated, high-precision, and
high-performance solar position calculators. We strongly recommend using
the built-in solar position calculators.

pvlib-python also includes unsupported wrappers for the official NREL
SPA algorithm. NREL's license does not allow redistribution of the
source code, so you must jump through some hoops to use it with pvlib.
You will need a C compiler to use this code.

To install the NREL SPA algorithm for use with pvlib:

#. Download the pvlib repository (as described in :ref:`obtainsource`)
#. Download the `SPA files from NREL <http://www.nrel.gov/midc/spa/>`_
#. Copy the SPA files into ``pvlib-python/pvlib/spa_c_files``
#. From the ``pvlib-python`` directory, run ``pip uninstall pvlib``
   followed by ``pip install .``

.. _references:

References
----------

Here are a few recommended references for installing Python packages:

* `The Pandas installation page
  <http://pandas.pydata.org/pandas-docs/stable/install.html>`_
* `python4astronomers Modules, Packages, and all that
  <https://python4astronomers.github.io/installation/packages.html>`_
* `Python Packaging User Guide
  <http://python-packaging-user-guide.readthedocs.org/en/latest/>`_
* `Conda User Guide
  <http://conda.pydata.org/docs/index.html>`_

Here are a few recommended references for git and GitHub:

* `The git documentation <https://git-scm.com/doc>`_:
  detailed explanations, videos, more links, and cheat sheets. Go here first!
* `Forking Projects <https://guides.github.com/activities/forking/>`_
* `Fork A Repo <https://help.github.com/articles/fork-a-repo/>`_
* `Cloning a repository
  <https://help.github.com/articles/cloning-a-repository/>`_
* `Aha! Moments When Learning Git
  <http://betterexplained.com/articles/aha-moments-when-learning-git/>`_

==========
User Guide
==========


.. toctree::
   :maxdepth: 2

   package_overview
   installation
   introtutorial
   pvsystem
   modelchain
   timetimezones
   clearsky
   forecasts
   comparison_pvlib_matlab
   variables_style_rules
   singlediode
.. _introtutorial:

Intro Tutorial
==============

This page contains introductory examples of pvlib python usage.

.. _modeling-paradigms:

Modeling paradigms
------------------

The backbone of pvlib-python
is well-tested procedural code that implements PV system models.
pvlib-python also provides a collection of classes for users
that prefer object-oriented programming.
These classes can help users keep track of data in a more organized way,
provide some "smart" functions with more flexible inputs,
and simplify the modeling process for common situations.
The classes do not add any algorithms beyond what's available
in the procedural code, and most of the object methods
are simple wrappers around the corresponding procedural code.

Let's use each of these pvlib modeling paradigms
to calculate the yearly energy yield for a given hardware
configuration at a handful of sites listed below.

.. ipython:: python

    import pvlib
    import pandas as pd
    import matplotlib.pyplot as plt

    # latitude, longitude, name, altitude, timezone
    coordinates = [
        (32.2, -111.0, 'Tucson', 700, 'Etc/GMT+7'),
        (35.1, -106.6, 'Albuquerque', 1500, 'Etc/GMT+7'),
        (37.8, -122.4, 'San Francisco', 10, 'Etc/GMT+8'),
        (52.5, 13.4, 'Berlin', 34, 'Etc/GMT-1'),
    ]

    # get the module and inverter specifications from SAM
    sandia_modules = pvlib.pvsystem.retrieve_sam('SandiaMod')
    sapm_inverters = pvlib.pvsystem.retrieve_sam('cecinverter')
    module = sandia_modules['Canadian_Solar_CS5P_220M___2009_']
    inverter = sapm_inverters['ABB__MICRO_0_25_I_OUTD_US_208__208V_']
    temperature_model_parameters = pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']


In order to retrieve meteorological data for the simulation, we can make use of
the :ref:`iotools` module. In this example we will be using PVGIS, one of the
data sources available, to retrieve a Typical Meteorological Year (TMY) which
includes irradiation, temperature and wind speed.

.. ipython:: python

    tmys = []
    for location in coordinates:
        latitude, longitude, name, altitude, timezone = location
        weather = pvlib.iotools.get_pvgis_tmy(latitude, longitude,
                                              map_variables=True)[0]
        weather.index.name = "utc_time"
        tmys.append(weather)


Procedural
^^^^^^^^^^

The straightforward procedural code can be used for all modeling
steps in pvlib-python.

The following code demonstrates how to use the procedural code
to accomplish our system modeling goal:

.. ipython:: python

    system = {'module': module, 'inverter': inverter,
              'surface_azimuth': 180}

    energies = {}

    for location, weather in zip(coordinates, tmys):
        latitude, longitude, name, altitude, timezone = location
        system['surface_tilt'] = latitude
        solpos = pvlib.solarposition.get_solarposition(
            time=weather.index,
            latitude=latitude,
            longitude=longitude,
            altitude=altitude,
            temperature=weather["temp_air"],
            pressure=pvlib.atmosphere.alt2pres(altitude),
        )
        dni_extra = pvlib.irradiance.get_extra_radiation(weather.index)
        airmass = pvlib.atmosphere.get_relative_airmass(solpos['apparent_zenith'])
        pressure = pvlib.atmosphere.alt2pres(altitude)
        am_abs = pvlib.atmosphere.get_absolute_airmass(airmass, pressure)
        aoi = pvlib.irradiance.aoi(
            system['surface_tilt'],
            system['surface_azimuth'],
            solpos["apparent_zenith"],
            solpos["azimuth"],
        )
        total_irradiance = pvlib.irradiance.get_total_irradiance(
            system['surface_tilt'],
            system['surface_azimuth'],
            solpos['apparent_zenith'],
            solpos['azimuth'],
            weather['dni'],
            weather['ghi'],
            weather['dhi'],
            dni_extra=dni_extra,
            model='haydavies',
        )
        cell_temperature = pvlib.temperature.sapm_cell(
            total_irradiance['poa_global'],
            weather["temp_air"],
            weather["wind_speed"],
            **temperature_model_parameters,
        )
        effective_irradiance = pvlib.pvsystem.sapm_effective_irradiance(
            total_irradiance['poa_direct'],
            total_irradiance['poa_diffuse'],
            am_abs,
            aoi,
            module,
        )
        dc = pvlib.pvsystem.sapm(effective_irradiance, cell_temperature, module)
        ac = pvlib.inverter.sandia(dc['v_mp'], dc['p_mp'], inverter)
        annual_energy = ac.sum()
        energies[name] = annual_energy

    energies = pd.Series(energies)

    # based on the parameters specified above, these are in W*hrs
    print(energies)

    energies.plot(kind='bar', rot=0)
    @savefig proc-energies.png width=6in
    plt.ylabel('Yearly energy yield (W hr)')
    @suppress
    plt.close();


.. _object-oriented:

Object oriented (Location, Mount, Array, PVSystem, ModelChain)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The object oriented paradigm uses a model with three main concepts:

1. System design (modules, inverters etc.) is represented by
   :py:class:`~pvlib.pvsystem.PVSystem`, :py:class:`~pvlib.pvsystem.Array`,
   and :py:class:`~pvlib.pvsystem.FixedMount`
   /:py:class:`~pvlib.pvsystem.SingleAxisTrackerMount` objects.
2. A particular place on the planet is represented by a
   :py:class:`~pvlib.location.Location` object.
3. The modeling chain used to calculate power output for a particular
   system and location is represented by a
   :py:class:`~pvlib.modelchain.ModelChain` object.

This can be a useful paradigm if you prefer to think about the
PV system and its location as separate concepts or if you develop your
own ModelChain subclasses. It can also be helpful if you make extensive
use of Location-specific methods for other calculations.

The following code demonstrates how to use
:py:class:`~pvlib.location.Location`,
:py:class:`~pvlib.pvsystem.PVSystem`, and
:py:class:`~pvlib.modelchain.ModelChain` objects to accomplish our
system modeling goal. ModelChain objects provide convenience methods
that can provide default selections for models and can also fill
necessary input with modeled data. For example, no air temperature
or wind speed data is provided in the input *weather* DataFrame,
so the ModelChain object defaults to 20 C and 0 m/s. Also, no irradiance
transposition model is specified (keyword argument `transposition_model` for
ModelChain) so the ModelChain defaults to the `haydavies` model. In this
example, ModelChain infers the DC power model from the module provided
by examining the parameters defined for the module.

.. ipython:: python

    from pvlib.pvsystem import PVSystem, Array, FixedMount
    from pvlib.location import Location
    from pvlib.modelchain import ModelChain

    energies = {}
    for location, weather in zip(coordinates, tmys):
        latitude, longitude, name, altitude, timezone = location
        location = Location(
            latitude,
            longitude,
            name=name,
            altitude=altitude,
            tz=timezone,
        )
        mount = FixedMount(surface_tilt=latitude, surface_azimuth=180)
        array = Array(
            mount=mount,
            module_parameters=module,
            temperature_model_parameters=temperature_model_parameters,
        )
        system = PVSystem(arrays=[array], inverter_parameters=inverter)
        mc = ModelChain(system, location)
        mc.run_model(weather)
        annual_energy = mc.results.ac.sum()
        energies[name] = annual_energy

    energies = pd.Series(energies)

    # based on the parameters specified above, these are in W*hrs
    print(energies)

    energies.plot(kind='bar', rot=0)
    @savefig modelchain-energies.png width=6in
    plt.ylabel('Yearly energy yield (W hr)')
    @suppress
    plt.close();
.. _singlediode:

Single Diode Equation
=====================

This section reviews the solutions to the single diode equation used in
pvlib-python to generate an IV curve of a PV module.

pvlib-python supports two ways to solve the single diode equation:

1. Lambert W-Function
2. Bishop's Algorithm

The :func:`pvlib.pvsystem.singlediode` function allows the user to choose the
method using the ``method`` keyword.

Lambert W-Function
------------------
When ``method='lambertw'``, the Lambert W-function is used as previously shown
by Jain, Kapoor [1, 2] and Hansen [3]. The following algorithm can be found on
`Wikipedia: Theory of Solar Cells
<https://en.wikipedia.org/wiki/Theory_of_solar_cells>`_, given the basic single
diode model equation.

.. math::

   I = I_L - I_0 \left(\exp \left(\frac{V + I R_s}{n Ns V_{th}} \right) - 1 \right)
       - \frac{V + I R_s}{R_{sh}}

Lambert W-function is the inverse of the function
:math:`f \left( w \right) = w \exp \left( w \right)` or
:math:`w = f^{-1} \left( w \exp \left( w \right) \right)` also given as
:math:`w = W \left( w \exp \left( w \right) \right)`. Defining the following
parameter, :math:`z`, is necessary to transform the single diode equation into
a form that can be expressed as a Lambert W-function.

.. math::

   z = \frac{R_s I_0}{n Ns V_{th} \left(1 + \frac{R_s}{R_{sh}} \right)} \exp \left(
       \frac{R_s \left( I_L + I_0 \right) + V}{n Ns V_{th} \left(1 + \frac{R_s}{R_{sh}}\right)}
       \right)

Then the module current can be solved using the Lambert W-function,
:math:`W \left(z \right)`.

.. math::

   I = \frac{I_L + I_0 - \frac{V}{R_{sh}}}{1 + \frac{R_s}{R_{sh}}}
       - \frac{n Ns V_{th}}{R_s} W \left(z \right)


Bishop's Algorithm
------------------
The function :func:`pvlib.singlediode.bishop88` uses an explicit solution [4]
that finds points on the IV curve by first solving for pairs :math:`(V_d, I)`
where :math:`V_d` is the diode voltage :math:`V_d = V + I*Rs`. Then the voltage
is backed out from :math:`V_d`. Points with specific voltage, such as open
circuit, are located using the bisection search method, ``brentq``, bounded
by a zero diode voltage and an estimate of open circuit voltage given by

.. math::

   V_{oc, est} = n Ns V_{th} \log \left( \frac{I_L}{I_0} + 1 \right)

We know that :math:`V_d = 0` corresponds to a voltage less than zero, and
we can also show that when :math:`V_d = V_{oc, est}`, the resulting
current is also negative, meaning that the corresponding voltage must be
in the 4th quadrant and therefore greater than the open circuit voltage
(see proof below). Therefore the entire forward-bias 1st quadrant IV-curve
is bounded because :math:`V_{oc} < V_{oc, est}`, and so a bisection search
between 0 and :math:`V_{oc, est}` will always find any desired condition in the
1st quadrant including :math:`V_{oc}`.

.. math::

   I = I_L - I_0 \left(\exp \left(\frac{V_{oc, est}}{n Ns V_{th}} \right) - 1 \right)
       - \frac{V_{oc, est}}{R_{sh}} \newline

   I = I_L - I_0 \left(\exp \left(\frac{n Ns V_{th} \log \left(\frac{I_L}{I_0} + 1 \right)}{n Ns V_{th}} \right) - 1 \right)
       - \frac{n Ns V_{th} \log \left(\frac{I_L}{I_0} + 1 \right)}{R_{sh}} \newline

   I = I_L - I_0 \left(\exp \left(\log \left(\frac{I_L}{I_0} + 1 \right) \right)  - 1 \right)
       - \frac{n Ns V_{th} \log \left(\frac{I_L}{I_0} + 1 \right)}{R_{sh}} \newline

   I = I_L - I_0 \left(\frac{I_L}{I_0} + 1  - 1 \right)
       - \frac{n Ns V_{th} \log \left(\frac{I_L}{I_0} + 1 \right)}{R_{sh}} \newline

   I = I_L - I_0 \left(\frac{I_L}{I_0} \right)
       - \frac{n Ns V_{th} \log \left(\frac{I_L}{I_0} + 1 \right)}{R_{sh}} \newline

   I = I_L - I_L - \frac{n Ns V_{th} \log \left( \frac{I_L}{I_0} + 1 \right)}{R_{sh}} \newline

   I = - \frac{n Ns V_{th} \log \left( \frac{I_L}{I_0} + 1 \right)}{R_{sh}}

References
----------
[1] "Exact analytical solutions of the parameters of real solar cells using
Lambert W-function," A. Jain, A. Kapoor, Solar Energy Materials and Solar Cells,
81, (2004) pp 269-277.
:doi:`10.1016/j.solmat.2003.11.018`

[2] "A new method to determine the diode ideality factor of real solar cell
using Lambert W-function," A. Jain, A. Kapoor, Solar Energy Materials and Solar
Cells, 85, (2005) 391-396.
:doi:`10.1016/j.solmat.2004.05.022`

[3] "Parameter Estimation for Single Diode Models of Photovoltaic Modules,"
Clifford W. Hansen, Sandia `Report SAND2015-2065
<https://prod.sandia.gov/techlib-noauth/access-control.cgi/2015/152065.pdf>`_,
2015 :doi:`10.13140/RG.2.1.4336.7842`

[4] "Computer simulation of the effects of electrical mismatches in
photovoltaic cell interconnection circuits" JW Bishop, Solar Cell (1988)
:doi:`10.1016/0379-6787(88)90059-2`.. _variables_style_rules:

Variables and Symbols
=====================

There is a convention on consistent variable names throughout the library:

.. csv-table:: List of used Variables and Parameters
   :file: ../../../../pvlib/data/variables_style_rules.csv
   :delim: ;
   :header-rows: 1
   :widths: 5, 5
   :stub-columns: 1
   
For a definition and further explanation on the variables, common symbols and units refer to the following sources:


* `Reference Variable List by PVPMC <https://pvpmc.sandia.gov/resources-and-events/variable-list/>`_
* `IEC 61724-1:2017  -- Photovoltaic system performance - Part 1: Monitoring  <https://webstore.iec.ch/publication/33622>`_ section: 3 -- Terms and definitions; the Indian Standard referencing the withdrawn earlier global IEC standard IEC 61724:1998 is available online: `IS/IEC 61724 (1998) <https://archive.org/details/gov.in.is.iec.61724.1998>`_ and can provide relevant contents.
* Explanation of Solar irradiation and solar geometry by `SoDa Service <http://www.soda-pro.com/home>`_
  
   * `Acronyms, Terminology and Units <http://www.soda-pro.com/help/general/acronyms-terminology-and-units>`_
   * `Plane orientations and radiation components <http://www.soda-pro.com/help/general/plane-orientations-and-radiation-components>`_
   * `Time references <http://www.soda-pro.com/help/general/time-references>`_
   * `Units and conversion tool <http://www.soda-is.com/eng/education/units.html>`_
   * `Terminology: definitions of the main quantities. <http://www.soda-is.com/eng/education/terminology.html>`_
   * `Acronyms in solar radiation <http://www.soda-is.com/eng/education/acronymes.html>`_ (more extensive list)

.. note:: These further references might not use the same terminology as *pvlib*. But the physical process referred to is the same.
.. _pvsystemdoc:

PVSystem
========

.. ipython:: python
   :suppress:

    import pandas as pd
    from pvlib import pvsystem


The :py:class:`~pvlib.pvsystem.PVSystem` represents one inverter and the
PV modules that supply DC power to the inverter. A PV system may be on fixed
mounting or single axis trackers. The :py:class:`~pvlib.pvsystem.PVSystem`
is supported by the :py:class:`~pvlib.pvsystem.Array` which represents the
PV modules in the :py:class:`~pvlib.pvsystem.PVSystem`. An instance of
:py:class:`~pvlib.pvsystem.PVSystem` has a single inverter, but can have
multiple instances of :py:class:`~pvlib.pvsystem.Array`. An instance of the
Array class represents a group of modules with the same orientation and
module type. Different instances of Array can have different tilt, orientation,
and number or type of modules, where the orientation is defined by the
Array's mount (a :py:class:`~pvlib.pvsystem.FixedMount`,
:py:class:`~pvlib.pvsystem.SingleAxisTrackerMount`, or other).

The :py:class:`~pvlib.pvsystem.PVSystem` class methods wrap many of the
functions in the :py:mod:`~pvlib.pvsystem` module. Similarly, the Mount classes
and :py:class:`~pvlib.pvsystem.Array` wrap several functions with their class
methods.  Methods that wrap functions have similar names as the wrapped functions.
This practice simplifies the API for :py:class:`~pvlib.pvsystem.PVSystem`
and :py:class:`~pvlib.pvsystem.Array` methods by eliminating the need to specify
arguments that are stored as attributes of these classes, such as
module and inverter properties. Using :py:class:`~pvlib.pvsystem.PVSystem`
is not better or worse than using the functions it wraps -- it is an
alternative way of organizing your data and calculations.

This guide aims to build understanding of the PVSystem class. It assumes
basic familiarity with object-oriented code in Python, but most
information should be understandable without a solid understanding of
classes. Keep in mind that `functions` are independent of objects,
while `methods` are attached to objects.

See :py:class:`~pvlib.modelchain.ModelChain` for an application of
PVSystem to time series modeling.


.. _designphilosophy:

Design philosophy
-----------------

The PVSystem class allows modelers to easily separate the data that
represents a PV system (e.g. tilt angle or module parameters) from the
data that influences the PV system (e.g. the weather).

The data that represents the PV system is *intrinsic*. The
data that influences the PV system is *extrinsic*.

Intrinsic data is stored in object attributes. For example, the parameters
that describe a PV system's modules and inverter are stored in
`PVSystem.module_parameters` and `PVSystem.inverter_parameters`.

.. ipython:: python

    module_parameters = {'pdc0': 5000, 'gamma_pdc': -0.004}
    inverter_parameters = {'pdc0': 5000, 'eta_inv_nom': 0.96}
    system = pvsystem.PVSystem(inverter_parameters=inverter_parameters,
                               module_parameters=module_parameters)
    print(system.inverter_parameters)


Extrinsic data is passed to the arguments of PVSystem methods. For example,
the :py:meth:`~pvlib.pvsystem.PVSystem.pvwatts_dc` method accepts extrinsic
data irradiance and temperature.

.. ipython:: python

    pdc = system.pvwatts_dc(g_poa_effective=1000, temp_cell=30)
    print(pdc)

Methods attached to a PVSystem object wrap the corresponding functions in
:py:mod:`~pvlib.pvsystem`. The methods simplify the argument list by
using data stored in the PVSystem attributes. Compare the
:py:meth:`~pvlib.pvsystem.PVSystem.pvwatts_dc` method signature to the
:py:func:`~pvlib.pvsystem.pvwatts_dc` function signature:

    * :py:meth:`PVSystem.pvwatts_dc(g_poa_effective, temp_cell) <pvlib.pvsystem.PVSystem.pvwatts_dc>`
    * :py:func:`pvwatts_dc(g_poa_effective, temp_cell, pdc0, gamma_pdc, temp_ref=25.) <pvlib.pvsystem.pvwatts_dc>`

How does this work? The :py:meth:`~pvlib.pvsystem.PVSystem.pvwatts_dc`
method looks in `PVSystem.module_parameters` for the `pdc0`, and
`gamma_pdc` arguments. Then the :py:meth:`PVSystem.pvwatts_dc
<pvlib.pvsystem.PVSystem.pvwatts_dc>` method calls the
:py:func:`pvsystem.pvwatts_dc <pvlib.pvsystem.pvwatts_dc>` function with
all of the arguments and returns the result to the user. Note that the
function includes a default value for the parameter `temp_ref`. This
default value may be overridden by specifying the `temp_ref` key in the
`PVSystem.module_parameters` dictionary.

.. ipython:: python

    system.arrays[0].module_parameters['temp_ref'] = 0
    # lower temp_ref should lead to lower DC power than calculated above
    pdc = system.pvwatts_dc(1000, 30)
    print(pdc)

Multiple methods may pull data from the same attribute. For example, the
`PVSystem.module_parameters` attribute is used by the DC model methods
as well as the incidence angle modifier methods.


.. _multiarray:

PVSystem and Arrays
-------------------

The PVSystem class can represent a PV system with a single array of modules,
or with multiple arrays. For a PV system with a single array, the parameters
that describe the array can be provided directly to the PVSystem instand.
For example, the parameters that describe the array's modules are can be
passed to `PVSystem.module_parameters`:

.. ipython:: python

    module_parameters = {'pdc0': 5000, 'gamma_pdc': -0.004}
    inverter_parameters = {'pdc0': 5000, 'eta_inv_nom': 0.96}
    system = pvsystem.PVSystem(module_parameters=module_parameters,
                               inverter_parameters=inverter_parameters)
    print(system.arrays[0].module_parameters)
    print(system.inverter_parameters)


A system with multiple arrays is specified by passing a list of
:py:class:`~pvlib.pvsystem.Array` to the :py:class:`~pvlib.pvsystem.PVSystem`
constructor. For a PV system with several arrays, the module parameters are
provided for each array, and the arrays are provided to
:py:class:`~pvlib.pvsystem.PVSystem` as a tuple or list of instances of
:py:class:`~pvlib.pvsystem.Array`:

.. ipython:: python

    module_parameters = {'pdc0': 5000, 'gamma_pdc': -0.004}
    mount = pvsystem.FixedMount(surface_tilt=20, surface_azimuth=180)
    array_one = pvsystem.Array(mount=mount, module_parameters=module_parameters)
    array_two = pvsystem.Array(mount=mount, module_parameters=module_parameters)
    system_two_arrays = pvsystem.PVSystem(arrays=[array_one, array_two],
                                          inverter_parameters=inverter_parameters)
    print([array.module_parameters for array in system_two_arrays.arrays])
    print(system_two_arrays.inverter_parameters)


The :py:class:`~pvlib.pvsystem.Array` class includes those 
:py:class:`~pvlib.pvsystem.PVSystem` attributes that may vary from array
to array. These attributes include
`module_parameters`, `temperature_model_parameters`, `modules_per_string`,
`strings_per_inverter`, `albedo`, `surface_type`, `module_type`, and
`racking_model`.

When instantiating a :py:class:`~pvlib.pvsystem.PVSystem` with a tuple or list
of :py:class:`~pvlib.pvsystem.Array`, each array parameter must be specified for
each instance of :py:class:`~pvlib.pvsystem.Array`. For example, if all arrays
are at the same tilt you must still specify the tilt value for
each array. When using :py:class:`~pvlib.pvsystem.Array` you shouldn't
also pass any array attributes to the `PVSystem` attributes; when Array instances
are provided to PVSystem, the PVSystem attributes are ignored.


.. _pvsystemattributes:

PVSystem attributes
-------------------

Here we review the most commonly used PVSystem and Array attributes.
Please see the :py:class:`~pvlib.pvsystem.PVSystem` and 
:py:class:`~pvlib.pvsystem.Array` class documentation for a
comprehensive list of attributes.


Tilt and azimuth
^^^^^^^^^^^^^^^^

The first parameters which describe the DC part of a PV system are the tilt
and azimuth of the modules. In the case of a PV system with a single array,
these parameters can be specified using the `PVSystem.surface_tilt` and
`PVSystem.surface_azimuth` attributes.  This will automatically create
an :py:class:`~pvlib.pvsystem.Array` with a :py:class:`~pvlib.pvsystem.FixedMount`
at the specified tilt and azimuth:

.. ipython:: python

    # single south-facing array at 20 deg tilt
    system_one_array = pvsystem.PVSystem(surface_tilt=20, surface_azimuth=180)
    print(system_one_array.arrays[0].mount)


In the case of a PV system with several arrays, the parameters are specified
for each array by passing a different :py:class:`~pvlib.pvsystem.FixedMount`
(or another `Mount` class):

.. ipython:: python

    array_one = pvsystem.Array(pvsystem.FixedMount(surface_tilt=30, surface_azimuth=90))
    print(array_one.mount.surface_tilt, array_one.mount.surface_azimuth)
    array_two = pvsystem.Array(pvsystem.FixedMount(surface_tilt=30, surface_azimuth=220))
    system = pvsystem.PVSystem(arrays=[array_one, array_two])
    system.num_arrays
    for array in system.arrays:
        print(array.mount)


The `surface_tilt` and `surface_azimuth` attributes are used in PVSystem
(or Array) methods such as :py:meth:`~pvlib.pvsystem.PVSystem.get_aoi` or
:py:meth:`~pvlib.pvsystem.Array.get_aoi`. The angle of incidence (AOI)
calculations require `surface_tilt`, `surface_azimuth` and the extrinsic
sun position. The `PVSystem` method :py:meth:`~pvlib.pvsystem.PVSystem.get_aoi`
uses the `surface_tilt` and `surface_azimuth` attributes from the
:py:class:`pvlib.pvsystem.PVSystem` instance, and so requires only `solar_zenith`
and `solar_azimuth` as arguments.

.. ipython:: python

    # single south-facing array at 20 deg tilt
    system_one_array = pvsystem.PVSystem(surface_tilt=20, surface_azimuth=180)
    print(system_one_array.arrays[0].mount)

    # call get_aoi with solar_zenith, solar_azimuth
    aoi = system_one_array.get_aoi(solar_zenith=30, solar_azimuth=180)
    print(aoi)


The `Array` method :py:meth:`~pvlib.pvsystem.Array.get_aoi`
operates in a similar manner.

.. ipython:: python

    # two arrays each at 30 deg tilt with different facing
    array_one = pvsystem.Array(pvsystem.FixedMount(surface_tilt=30, surface_azimuth=90))
    array_one_aoi = array_one.get_aoi(solar_zenith=30, solar_azimuth=180)
    print(array_one_aoi)


The `PVSystem` method :py:meth:`~pvlib.pvsystem.PVSystem.get_aoi`
operates on all `Array` instances in the `PVSystem`, whereas the the
`Array` method operates only on its `Array` instance.

.. ipython:: python

    array_two = pvsystem.Array(pvsystem.FixedMount(surface_tilt=30, surface_azimuth=220))
    system_multiarray = pvsystem.PVSystem(arrays=[array_one, array_two])
    print(system_multiarray.num_arrays)
    # call get_aoi with solar_zenith, solar_azimuth
    aoi = system_multiarray.get_aoi(solar_zenith=30, solar_azimuth=180)
    print(aoi)


As a reminder, when the PV system includes more than one array, the output of the
`PVSystem` method :py:meth:`~pvlib.pvsystem.PVSystem.get_aoi` is a *tuple* with
the order of the elements corresponding to the order of the arrays.

Other `PVSystem` and `Array` methods operate in a similar manner. When a `PVSystem`
method needs input for each array, the input is provided in a tuple:

.. ipython:: python

    aoi = system.get_aoi(solar_zenith=30, solar_azimuth=180)
    print(aoi)
    system_multiarray.get_iam(aoi)


Module and inverter parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`module_parameters` and `inverter_parameters` contain the data
necessary for computing DC and AC power using one of the available
PVSystem methods. Values for these attributes can be obtained from databases
included with pvlib python by using the :py:func:`~pvlib.pvsystem.retrieve_sam` function:

.. ipython:: python

    # Load the database of CEC module model parameters
    modules = pvsystem.retrieve_sam('cecmod')
    # retrieve_sam returns a dict. the dict keys are module names,
    # and the values are model parameters for that module
    module_parameters = modules['Canadian_Solar_Inc__CS5P_220M']
    # Load the database of CEC inverter model parameters
    inverters = pvsystem.retrieve_sam('cecinverter')
    inverter_parameters = inverters['ABB__MICRO_0_25_I_OUTD_US_208__208V_']
    system_one_array = pvsystem.PVSystem(module_parameters=module_parameters,
                                         inverter_parameters=inverter_parameters)


The module and/or inverter parameters can also be specified manually.
This is useful for modules or inverters that are not
included in the supplied databases, or when using the PVWatts model,
as demonstrated in :ref:`designphilosophy`.


Module strings
^^^^^^^^^^^^^^

The attributes `modules_per_string` and `strings_per_inverter` are used
in the :py:meth:`~pvlib.pvsystem.PVSystem.scale_voltage_current_power`
method. Some DC power models in :py:class:`~pvlib.modelchain.ModelChain`
automatically call this method and make use of these attributes. As an
example, consider a system with a single array comprising 35 modules
arranged into 5 strings of 7 modules each.

.. ipython:: python

    system = pvsystem.PVSystem(modules_per_string=7, strings_per_inverter=5)
    # crude numbers from a single module
    data = pd.DataFrame({'v_mp': 8, 'v_oc': 10, 'i_mp': 5, 'i_x': 6,
                         'i_xx': 4, 'i_sc': 7, 'p_mp': 40}, index=[0])
    data_scaled = system.scale_voltage_current_power(data)
    print(data_scaled)


Losses
^^^^^^

The `losses_parameters` attribute contains data that may be used with
methods that calculate system losses. At present, these methods include
only :py:meth:`pvlib.pvsystem.PVSystem.pvwatts_losses` and
:py:func:`pvlib.pvsystem.pvwatts_losses`, but we hope to add more related functions
and methods in the future.


.. _sat:

SingleAxisTracker
-----------------

The :py:class:`~pvlib.tracking.SingleAxisTracker` is a subclass of
:py:class:`~pvlib.pvsystem.PVSystem`. The SingleAxisTracker class
includes a few more keyword arguments and attributes that are specific
to trackers, plus the
:py:meth:`~pvlib.tracking.SingleAxisTracker.singleaxis` method. It also
overrides the `get_aoi` and `get_irradiance` methods.
.. _package_overview:

Package Overview
================

Introduction
------------

The core mission of pvlib-python is to provide open, reliable,
interoperable, and benchmark implementations of PV system models.

There are at least as many opinions about how to model PV systems as
there are modelers of PV systems, so pvlib-python provides several
modeling paradigms: functions, the Location/PVSystem classes, and the
ModelChain class. Read more about this in the :ref:`introtutorial`
section.


User extensions
---------------
There are many other ways to organize PV modeling code. We encourage you
to build on these paradigms and to share your experiences with the pvlib
community via issues and pull requests.


Getting support
---------------

pvlib usage questions can be asked on
`Stack Overflow  <http://stackoverflow.com>`_ and tagged with
the `pvlib <http://stackoverflow.com/questions/tagged/pvlib>`_ tag.

The `pvlib-python google group <https://groups.google.com/forum/#!forum/pvlib-python>`_
is used for discussing various topics of interest to the pvlib-python
community. We also make new version announcements on the google group.

If you suspect that you may have discovered a bug or if you'd like to
change something about pvlib, then please make an issue on our
`GitHub issues page <https://github.com/pvlib/pvlib-python/issues>`_ .


How do I contribute?
--------------------
We're so glad you asked! Please see :ref:`Contributing` for information and
instructions on how to contribute. We really appreciate it!


Credits
-------
The pvlib-python community thanks Sandia National Lab
for developing PVLIB Matlab and for supporting
Rob Andrews of Calama Consulting to port the library to Python.
Will Holmgren thanks the Department of Energy's Energy
Efficiency and Renewable Energy Postdoctoral Fellowship Program
(2014-2016), the University of Arizona Institute for Energy Solutions (2017-2018),
and the DOE Solar Forecasting 2 program (2018).
The pvlib-python maintainers thank all of pvlib's contributors of issues
and especially pull requests.
The pvlib-python community thanks all of the
maintainers and contributors to the PyData stack.
.. currentmodule:: pvlib

Classes
=======

pvlib-python provides a collection of classes for users that prefer
object-oriented programming. These classes can help users keep track of
data in a more organized way, and can help to simplify the modeling
process. The classes do not add any functionality beyond the procedural
code. Most of the object methods are simple wrappers around the
corresponding procedural code. For examples of using these classes, see
the :ref:`pvsystemdoc` and :ref:`modelchaindoc` pages.

.. autosummary::
   :toctree: generated/

   location.Location
   pvsystem.PVSystem
   pvsystem.Array
   pvsystem.FixedMount
   pvsystem.SingleAxisTrackerMount
   tracking.SingleAxisTracker
   modelchain.ModelChain
   modelchain.ModelChainResult
.. currentmodule:: pvlib

Scaling
=======

Methods for manipulating irradiance for temporal or spatial considerations

.. autosummary::
   :toctree: generated/

   scaling.wvm
.. currentmodule:: pvlib

ModelChain
==========

Creating a ModelChain object.

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain
   modelchain.ModelChain.with_pvwatts
   modelchain.ModelChain.with_sapm

.. _modelchain_runmodel:

Running
-------

A ModelChain can be run from a number of starting points, depending on the
input data available.

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain.run_model
   modelchain.ModelChain.run_model_from_poa
   modelchain.ModelChain.run_model_from_effective_irradiance

Functions to assist with setting up ModelChains to run

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain.complete_irradiance
   modelchain.ModelChain.prepare_inputs
   modelchain.ModelChain.prepare_inputs_from_poa

Results
-------

Output from the running the ModelChain is stored in the
:py:attr:`modelchain.ModelChain.results` attribute. For more
information see :py:class:`modelchain.ModelChainResult`.

Attributes
----------

Simple ModelChain attributes:

``system, location, clearsky_model, transposition_model,
solar_position_method, airmass_model``

Properties
----------

ModelChain properties that are aliases for your specific modeling functions.

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain.dc_model
   modelchain.ModelChain.ac_model
   modelchain.ModelChain.aoi_model
   modelchain.ModelChain.spectral_model
   modelchain.ModelChain.temperature_model
   modelchain.ModelChain.dc_ohmic_model
   modelchain.ModelChain.losses_model
   modelchain.ModelChain.effective_irradiance_model

Model definitions
-----------------

ModelChain model definitions.

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain.sapm
   modelchain.ModelChain.cec
   modelchain.ModelChain.desoto
   modelchain.ModelChain.pvsyst
   modelchain.ModelChain.pvwatts_dc
   modelchain.ModelChain.sandia_inverter
   modelchain.ModelChain.adr_inverter
   modelchain.ModelChain.pvwatts_inverter
   modelchain.ModelChain.ashrae_aoi_loss
   modelchain.ModelChain.physical_aoi_loss
   modelchain.ModelChain.sapm_aoi_loss
   modelchain.ModelChain.no_aoi_loss
   modelchain.ModelChain.first_solar_spectral_loss
   modelchain.ModelChain.sapm_spectral_loss
   modelchain.ModelChain.no_spectral_loss
   modelchain.ModelChain.sapm_temp
   modelchain.ModelChain.pvsyst_temp
   modelchain.ModelChain.faiman_temp
   modelchain.ModelChain.fuentes_temp
   modelchain.ModelChain.dc_ohmic_model
   modelchain.ModelChain.no_dc_ohmic_loss
   modelchain.ModelChain.pvwatts_losses
   modelchain.ModelChain.no_extra_losses

Inference methods
-----------------

Methods that automatically determine which models should be used based
on the information in the associated :py:class:`~pvsystem.PVSystem` object.

.. autosummary::
   :toctree: generated/

   modelchain.ModelChain.infer_dc_model
   modelchain.ModelChain.infer_ac_model
   modelchain.ModelChain.infer_aoi_model
   modelchain.ModelChain.infer_spectral_model
   modelchain.ModelChain.infer_temperature_model
   modelchain.ModelChain.infer_losses_model

Functions
---------

Functions for power modeling.

.. autosummary::
   :toctree: generated/

   modelchain.basic_chain
   modelchain.get_orientation
.. currentmodule:: pvlib

Clear sky
=========

.. autosummary::
   :toctree: generated/

   location.Location.get_clearsky
   clearsky.ineichen
   clearsky.lookup_linke_turbidity
   clearsky.simplified_solis
   clearsky.haurwitz
   clearsky.detect_clearsky
   clearsky.bird
.. currentmodule:: pvlib

Bifacial
========

Methods for calculating back surface irradiance

.. autosummary::
   :toctree: generated/

   bifacial.pvfactors_timeseries
.. currentmodule:: pvlib

Solar Position
==============

Functions and methods for calculating solar position.

The :py:meth:`location.Location.get_solarposition` method and the
:py:func:`solarposition.get_solarposition` function with default
parameters are fast and accurate. We recommend using these functions
unless you know that you need a different function.

.. autosummary::
   :toctree: generated/

   location.Location.get_solarposition
   solarposition.get_solarposition
   solarposition.spa_python
   solarposition.ephemeris
   solarposition.pyephem
   solarposition.spa_c


Additional functions for quantities closely related to solar position.

.. autosummary::
   :toctree: generated/

   solarposition.calc_time
   solarposition.pyephem_earthsun_distance
   solarposition.nrel_earthsun_distance
   spa.calculate_deltat


Functions for calculating sunrise, sunset and transit times.

.. autosummary::
   :toctree: generated/

   location.Location.get_sun_rise_set_transit
   solarposition.sun_rise_set_transit_ephem
   solarposition.sun_rise_set_transit_spa
   solarposition.sun_rise_set_transit_geometric


The spa module contains the implementation of the built-in NREL SPA
algorithm.

.. autosummary::
   :toctree: generated/

   spa

Correlations and analytical expressions for low precision solar position
calculations.

.. autosummary::
   :toctree: generated/

   solarposition.solar_zenith_analytical
   solarposition.solar_azimuth_analytical
   solarposition.declination_spencer71
   solarposition.declination_cooper69
   solarposition.equation_of_time_spencer71
   solarposition.equation_of_time_pvcdrom
   solarposition.hour_angle
.. currentmodule:: pvlib

Forecasting
===========

Forecast models
---------------

.. autosummary::
   :toctree: generated/

   forecast.GFS
   forecast.NAM
   forecast.RAP
   forecast.HRRR
   forecast.HRRR_ESRL
   forecast.NDFD

Getting data
------------

.. autosummary::
   :toctree: generated/

   forecast.ForecastModel.get_data
   forecast.ForecastModel.get_processed_data

Processing data
---------------

.. autosummary::
   :toctree: generated/

   forecast.ForecastModel.process_data
   forecast.ForecastModel.rename
   forecast.ForecastModel.cloud_cover_to_ghi_linear
   forecast.ForecastModel.cloud_cover_to_irradiance_clearsky_scaling
   forecast.ForecastModel.cloud_cover_to_transmittance_linear
   forecast.ForecastModel.cloud_cover_to_irradiance_campbell_norman
   forecast.ForecastModel.cloud_cover_to_irradiance
   forecast.ForecastModel.kelvin_to_celsius
   forecast.ForecastModel.isobaric_to_ambient_temperature
   forecast.ForecastModel.uv_to_speed
   forecast.ForecastModel.gust_to_speed

IO support
----------

These are public for now, but use at your own risk.

.. autosummary::
   :toctree: generated/

   forecast.ForecastModel.set_dataset
   forecast.ForecastModel.set_query_latlon
   forecast.ForecastModel.set_location
   forecast.ForecastModel.set_time
.. currentmodule:: pvlib

Tracking
========

SingleAxisTracker
-----------------

The :py:class:`~tracking.SingleAxisTracker` inherits from
:py:class:`~pvsystem.PVSystem`.

.. autosummary::
   :toctree: generated/

   tracking.SingleAxisTracker
   tracking.SingleAxisTracker.singleaxis
   tracking.SingleAxisTracker.get_irradiance

Functions
---------

.. autosummary::
   :toctree: generated/

   tracking.singleaxis
   tracking.calc_axis_tilt
   tracking.calc_cross_axis_tilt
.. currentmodule:: pvlib

Irradiance
==========

Methods for irradiance calculations
-----------------------------------

.. autosummary::
   :toctree: generated/

   pvsystem.PVSystem.get_irradiance
   pvsystem.PVSystem.get_aoi
   pvsystem.PVSystem.get_iam
   tracking.SingleAxisTracker.get_irradiance

Decomposing and combining irradiance
------------------------------------

.. autosummary::
   :toctree: generated/

   irradiance.get_extra_radiation
   irradiance.aoi
   irradiance.aoi_projection
   irradiance.poa_horizontal_ratio
   irradiance.beam_component
   irradiance.poa_components
   irradiance.get_ground_diffuse
   irradiance.dni

Transposition models
--------------------

.. autosummary::
   :toctree: generated/

   irradiance.get_total_irradiance
   irradiance.get_sky_diffuse
   irradiance.isotropic
   irradiance.perez
   irradiance.haydavies
   irradiance.klucher
   irradiance.reindl
   irradiance.king

.. _dniestmodels:

DNI estimation models
---------------------

.. autosummary::
   :toctree: generated/

   irradiance.disc
   irradiance.dirint
   irradiance.dirindex
   irradiance.erbs
   irradiance.campbell_norman
   irradiance.gti_dirint

Clearness index models
----------------------

.. autosummary::
   :toctree: generated/

   irradiance.clearness_index
   irradiance.clearness_index_zenith_independent
   irradiance.clearsky_index
.. currentmodule:: pvlib

.. _iotools:

IO Tools
========

Functions for retrieving, reading, and writing data from a variety
of sources and file formats relevant to solar energy modeling.

.. autosummary::
   :toctree: generated/

   iotools.read_tmy2
   iotools.read_tmy3
   iotools.read_epw
   iotools.parse_epw
   iotools.read_srml
   iotools.read_srml_month_from_solardat
   iotools.read_surfrad
   iotools.read_midc
   iotools.read_midc_raw_data_from_nrel
   iotools.read_ecmwf_macc
   iotools.get_ecmwf_macc
   iotools.read_crn
   iotools.read_solrad
   iotools.get_psm3
   iotools.read_psm3
   iotools.parse_psm3
   iotools.get_pvgis_tmy
   iotools.read_pvgis_tmy
   iotools.get_pvgis_hourly
   iotools.read_pvgis_hourly
   iotools.get_bsrn
   iotools.read_bsrn
   iotools.parse_bsrn
   iotools.get_cams
   iotools.read_cams
   iotools.parse_cams

A :py:class:`~pvlib.location.Location` object may be created from metadata
in some files.

.. autosummary::
   :toctree: generated/

   location.Location.from_tmy
   location.Location.from_epw
.. currentmodule:: pvlib

Airmass and atmospheric models
==============================

.. autosummary::
   :toctree: generated/

   location.Location.get_airmass
   atmosphere.get_absolute_airmass
   atmosphere.get_relative_airmass
   atmosphere.pres2alt
   atmosphere.alt2pres
   atmosphere.gueymard94_pw
   atmosphere.first_solar_spectral_correction
   atmosphere.bird_hulstrom80_aod_bb
   atmosphere.kasten96_lt
   atmosphere.angstrom_aod_at_lambda
   atmosphere.angstrom_alpha
.. currentmodule:: pvlib

#############
API reference
#############

.. toctree::
   :maxdepth: 2

   classes
   solarposition
   clearsky
   airmass_atmospheric
   irradiance
   pv_modeling
   effects_on_pv_system_output
   tracking
   iotools
   forecasting
   modelchain
   bifacial
   scaling
.. currentmodule:: pvlib

PV Modeling
===========

Classes
-------

The :py:class:`~pvsystem.PVSystem` class provides many methods that
wrap the functions listed below. See its documentation for details.

.. autosummary::
   :toctree: generated/

   pvsystem.PVSystem

Incident angle modifiers
------------------------

.. autosummary::
   :toctree: generated/

   iam.physical
   iam.ashrae
   iam.martin_ruiz
   iam.martin_ruiz_diffuse
   iam.sapm
   iam.interp
   iam.marion_diffuse
   iam.marion_integrate

PV temperature models
---------------------

.. autosummary::
   :toctree: generated/

   temperature.sapm_cell
   temperature.sapm_module
   temperature.sapm_cell_from_module
   temperature.pvsyst_cell
   temperature.faiman
   temperature.fuentes
   temperature.ross
   temperature.noct_sam
   pvsystem.PVSystem.get_cell_temperature

Temperature Model Parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. currentmodule:: pvlib.temperature
.. autodata:: TEMPERATURE_MODEL_PARAMETERS
   :annotation:

.. currentmodule:: pvlib

Single diode models
-------------------

Functions relevant for single diode models.

.. autosummary::
   :toctree: generated/

   pvsystem.calcparams_cec
   pvsystem.calcparams_desoto
   pvsystem.calcparams_pvsyst
   pvsystem.i_from_v
   pvsystem.singlediode
   pvsystem.v_from_i
   pvsystem.max_power_point
   ivtools.sdm.pvsyst_temperature_coeff

Low-level functions for solving the single diode equation.

.. autosummary::
   :toctree: generated/

   singlediode.estimate_voc
   singlediode.bishop88
   singlediode.bishop88_i_from_v
   singlediode.bishop88_v_from_i
   singlediode.bishop88_mpp

Functions for fitting diode models

.. autosummary::
   :toctree: generated/

    ivtools.sde.fit_sandia_simple
    ivtools.sdm.fit_cec_sam
    ivtools.sdm.fit_desoto

Inverter models (DC to AC conversion)
-------------------------------------

.. autosummary::
   :toctree: generated/

   pvsystem.PVSystem.get_ac
   inverter.sandia
   inverter.sandia_multi
   inverter.adr
   inverter.pvwatts
   inverter.pvwatts_multi

Functions for fitting inverter models

.. autosummary::
   :toctree: generated/

   inverter.fit_sandia


PV System Models
----------------

Sandia array performance model (SAPM)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. autosummary::
   :toctree: generated/

   pvsystem.sapm
   pvsystem.sapm_effective_irradiance
   pvsystem.sapm_spectral_loss
   inverter.sandia
   temperature.sapm_cell

Pvsyst model
^^^^^^^^^^^^

.. autosummary::
   :toctree: generated/

   temperature.pvsyst_cell
   pvsystem.calcparams_pvsyst
   pvsystem.singlediode
   ivtools.sdm.pvsyst_temperature_coeff
   pvsystem.dc_ohms_from_percent
   pvsystem.dc_ohmic_losses

PVWatts model
^^^^^^^^^^^^^

.. autosummary::
   :toctree: generated/

   pvsystem.pvwatts_dc
   inverter.pvwatts
   pvsystem.pvwatts_losses

Estimating PV model parameters
------------------------------

Functions for fitting single diode models

.. autosummary::
   :toctree: generated/

    ivtools.sdm.fit_cec_sam
    ivtools.sdm.fit_desoto
    ivtools.sdm.fit_pvsyst_sandia
    ivtools.sdm.fit_desoto_sandia

Functions for fitting the single diode equation

.. autosummary::
   :toctree: generated/

    ivtools.sde.fit_sandia_simple

Utilities for working with IV curve data

.. autosummary::
   :toctree: generated/

    ivtools.utils.rectify_iv_curve

Other
-----

.. autosummary::
   :toctree: generated/

   pvsystem.retrieve_sam
   pvsystem.scale_voltage_current_power
.. currentmodule:: pvlib

Effects on PV System Output
===========================

Loss models
-----------

.. autosummary::
   :toctree: generated/

   pvsystem.combine_loss_factors
   pvsystem.dc_ohms_from_percent

Snow
----

.. autosummary::
   :toctree: generated/

   snow.coverage_nrel
   snow.fully_covered_nrel
   snow.dc_loss_nrel

Soiling
-------

.. autosummary::
   :toctree: generated/

   soiling.hsu
   soiling.kimber

Shading
-------

.. autosummary::
   :toctree: generated/

   shading.masking_angle
   shading.masking_angle_passias
   shading.sky_diffuse_passias

Spectrum
--------

.. autosummary::
   :toctree: generated/

   spectrum.spectrl2
