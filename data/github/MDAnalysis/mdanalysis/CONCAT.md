# Governance of MDAnalysis

Please see [About MDAnalysis: Governance](https://www.mdanalysis.org/about/#governance) for the description of how decisions are made for the MDAnalysis project.

Below is a summary of the governance model (but note that if the text on this page and the page  [About MDAnalysis: Governance](https://www.mdanalysis.org/about/#governance)  disagree then the [About MDAnalysis: Governance](https://www.mdanalysis.org/about/#governance) page takes precedence):

----

Project leadership is provided by a subset of contributors, the **MDAnalysis Core Developers** ([@MDAnalysis/coredevs](https://github.com/orgs/MDAnalysis/teams/coredevs)) who have produced substantial contributions over extended lengths of time and who remain active in reviewing issues and discussions on the various mailing lists. MDAnalysis Core Developers are granted commit rights (write access) to the GitHub source code repository. New MDAnalysis Core Developers are elected with a simple majority of current MDAnalysis Core Developers.

All decisions are made by simple majority of the MDAnalysis Core Developers.

A rotating subset of three MDAnalysis Core Developers is tasked to respond to and to investigate [Code of Conduct](https://www.mdanalysis.org/pages/conduct/) violations.
<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
**Table of Contents**

- [MDAnalysis Code of Conduct and Community Guidelines](#mdanalysis-code-of-conduct-and-community-guidelines)
- [Reporting](#reporting)
- [Enforcement](#enforcement)
- [Acknowledgment](#acknowledgment)

<!-- markdown-toc end -->
# MDAnalysis Code of Conduct and Community Guidelines

MDAnalysis is an engaged and respectful community made up of people from all
over the world. Your involvement helps us to further our mission and to create
an open platform that serves a broad range of communities, from research and
education to industry and beyond. This diversity is one of our biggest
strengths, but it can also lead to communication issues and conflicts.
Therefore, we have a few ground rules we ask that our community members adhere
to.

Fundamentally, we are committed to providing a productive,
harassment-free environment for everyone. Rather than considering this
code an exhaustive list of things that you can’t do, take it in the
spirit it is intended - a guide to make it easier to enrich all of us
and the communities in which we participate.

Importantly: as a member of our community, you are also a steward of these
values. Not all problems need to be resolved via formal processes, and often a
quick, friendly but clear word on an online forum or in person can help resolve
a misunderstanding and de-escalate things.

However, sometimes these informal processes may be inadequate: they fail to
work, there is urgency or risk to someone, nobody is intervening publicly and
you don't feel comfortable speaking in public, etc. For these or other reasons,
structured follow-up may be necessary and here we provide the means for that: we
welcome reports by
emailing [*Conduct-email*][conduct-mail] or
in anonymous by filling out [*this form*][conduct-form].

This code applies equally to founders, developers, mentors and new
community members, in all spaces managed by MDAnalysis. This
includes the mailing lists, our GitHub organizations, our chat rooms,
in-person events, and any other forums created by the project team. In
addition, violations of this code outside these spaces may affect a
person's ability to participate within them.

By embracing the following principles, guidelines and actions to follow or
avoid, you will help us make MDAnalysis a welcoming and productive community. If
that doesn't answer your questions, feel free to contact us
at our [*user-mailing-list*](mailto:mdnalysis-discussions@googlegroups.com).


1. **Be friendly and patient**.

2. **Be welcoming**. We strive to be a community that welcomes and supports
   people of all backgrounds and identities. This includes, but is not limited
   to, members of any race, ethnicity, culture, national origin, color,
   immigration status, social and economic class, educational level, sex, sexual
   orientation, gender identity and expression, age, physical appearance, family
   status, political belief, technological or professional choices, academic
   discipline, religion, mental ability, and physical ability.

3. **Be considerate**. Your work will be used by other people, and you in turn
   will depend on the work of others. Any decision you take will affect users
   and colleagues, and you should take those consequences into account when
   making decisions. Remember that we're a world-wide community. You may be
   communicating with someone with a different primary language or cultural
   background.

4. **Be respectful**. Not all of us will agree all the time, but disagreement is
   no excuse for poor behavior or poor manners. We might all experience some
   frustration now and then, but we cannot allow that frustration to turn into a
   personal attack. It’s important to remember that a community where people
   feel uncomfortable or threatened is not a productive one.

5. **Be careful in the words that you choose**. Be kind to others. Do not insult
   or put down other community members. Harassment and other exclusionary
   behavior are not acceptable. This includes, but is not limited to:
   * threats or violent language directed against another person
   * discriminatory jokes and language
   * posting sexually explicit or violent material
   * posting (or threatening to post) other people's personally identifying
     information ("doxing")
   * personal insults, especially those using racist or sexist terms
   * unwelcome sexual attention
   * advocating for, or encouraging, any of the above behavior
   * repeated harassment of others. In general, if someone asks you to stop,
     then stop

6. **Moderate your expectations**. Many in our community volunteer their time.
   They are probably not purposefully ignoring issues, refusing to engage in
   discussion, avoiding features, etc. but often just unavailable.

7. **When we disagree, try to understand why**. Disagreements, both social and
   technical, happen all the time and MDAnalysis is no exception. It is important
   that we resolve disagreements and differing views constructively. Remember
   that we’re different. The strength of MDAnalysis comes from its varied community
   that includes people from a wide range of backgrounds. Different people have
   different perspectives on issues. Being unable to understand why someone
   holds a viewpoint doesn’t mean they’re wrong. Don’t forget that it is human
   to err and blaming each other doesn’t get us anywhere. Instead, focus on
   helping to resolve issues and learning from mistakes.

8. **A simple apology can go a long way**. It can often de-escalate a situation,
   and telling someone that you are sorry is act of empathy that doesn’t
   automatically imply an admission of guilt.

# Reporting

If someone makes you or any other contributor feel unsafe or unwelcome, please
report this in a timely manner. Code of conduct violations reduce the value of
the community for everyone and we take them seriously. All complaints will be
reviewed and investigated and will result in a response that is deemed necessary
and appropriate to the circumstances.

You can file a report by emailing
the [*Conduct-mail*][conduct-mail] or by
filing out [this form][conduct-form]. The project team is obligated to maintain
confidentiality with regard to the reporter of an incident.

The online form gives you the option to keep your report anonymous or request
that we follow up with you directly. While we cannot follow up on an anonymous
report, we will take appropriate action.

# Enforcement

When a report is sent to us we will reply as soon as possible to confirm receipt;
we strive to answer in less than 24 hours. We will review the incident and
determine, to the best of our ability

- what happened
- whether this event constitutes a code of conduct violation
- who, if anyone, was at fault
- whether this is an ongoing situation

This information will be collected in writing. We strive to reach a resolution
within a week of confirmation. Once a resolution has been agreed upon, but before it is
enacted, we will contact the original reporter and any other affected parties
and explain the proposed resolution. We will ask if this resolution is
acceptable and note feedback for the record. We are, however, not required to act
on this feedback.


# Acknowledgment

Original text courtesy of
the
[*Speak Up!*](http://web.archive.org/web/20141109123859/http://speakup.io/coc.html),
[*Django*](https://www.djangoproject.com/conduct),
[*Contributor Covenant*](http://contributor-covenant.org/),
and
[*Jupyter*](https://github.com/jupyter/governance/blob/master/conduct/code_of_conduct.md) projects,
modified by MDAnalysis. We are grateful to those projects for contributing these
materials under open licensing terms for us to easily reuse.

All content on this page is licensed under a [*Creative Commons
Attribution*](http://creativecommons.org/licenses/by/3.0/) license. 

[conduct-mail]: mailto:mdnalysis-conduct@googlegroups.com
[conduct-form]: https://goo.gl/forms/w2IwBKkY3oT0aVEB3
## Contributing to MDAnalysis

Thanks for contributing to MDAnalysis!

All members of the MDAnalysis community adhere to our [Code of Conduct](https://www.mdanalysis.org/pages/conduct/). By contributing code and interacting with us on GitHub, the forums, or by any other means you consent to follow the Code of Conduct.

#### Reporting issues

If you've found a defect with MDAnalysis we'd love to know so we can fix it.  Please follow the Issue template so we can quickly diagnose the problem, in particular the piece of code that causes the problem.

If your issue isn't a defect with the code and instead you require help using MDAnalysis, drop by the [discussion forum](https://groups.google.com/forum/#!forum/mdnalysis-discussion).

#### Contributing code

If you're contributing code, please check out [How to contribute](https://www.mdanalysis.org/UserGuide/contributing.html) in the User Guide and look at the [Style guide](https://github.com/MDAnalysis/mdanalysis/wiki/Style-Guide).

MDAnalysis devs are most easily reached through the [development list](https://groups.google.com/forum/#!forum/mdnalysis-devel).

Fixes #

Changes made in this Pull Request:
 - 


PR Checklist
------------
 - [ ] Tests?
 - [ ] Docs?
 - [ ] CHANGELOG updated?
 - [ ] Issue raised/referenced?
---
name: Questions
about: If you want to ask a question please use the mailing list!

---

If you have a **QUESTION** such as 

- how to use MDAnalysis in general
- how to accomplish something specific,
- what output means
- ... or similar questions related to *USING* MDAnalysis 

then please *ask this question on the user mailing list*

   https://groups.google.com/forum/#!forum/mdnalysis-discussion

The issue tracker is meant for DEFECTS ("BUGS"), new FEATURES, and decisions on the API. In order to keep the volume of work on the issue tracker manageable for our volunteer developers, we will **IMMEDIATELY CLOSE ISSUES WITH QUESTIONS** as these questions are better answered on the mailing list.

We really appreciate you getting in touch with us --- no matter what you want to discuss. But we need your help keeping the amount of work manageable so please use the mailing list for questions and the issue tracker for code-related issues.

Thank you!

The MDAnalysis Development Team
---
name: Bug report
about: Create a report to help us improve

---

## Expected behavior ##

<!-- A clear and concise description of what you want to do and what you think should happen. (Code to reproduce the behavior can be added below). -->


## Actual behavior ##

<!-- What happened instead. Add as much detail as you can. Include (copy and paste) stack traces and any output. -->


## Code to reproduce the behavior ##

<!-- Show us how to reproduce the failure. If you can, use trajectory files from the test data. Use the code snipped below as a starting point. -->

``` python
import MDAnalysis as mda
from MDAnalysis.tests.datafiles import PSF, DCD,  GRO, PDB, TPR, XTC, TRR,  PRMncdf, NCDF

u = mda.Universe(PSF, DCD)

....

```

## Current version of MDAnalysis ##

- Which version are you using? (run `python -c "import MDAnalysis as mda; print(mda.__version__)"`)
- Which version of Python (`python -V`)?
- Which operating system?
---
name: Feature request
about: Suggest an idea for this project

---

## Is your feature request related to a problem? ##
<!-- A clear and concise description of what the problem is. For example, I'm always frustrated when [...] -->


## Describe the solution you'd like ##
<!-- A description of what you want to happen. For example, I'd like to be able to do [...] -->


## Describe alternatives you've considered ##
<!-- A description of any alternative solutions or features you've considered or possible solutions that you've seen elsewhere. -->


## Additional context ##
<!-- Add any other context or screenshots about the feature request here. -->
Coordinate tests can have special small test-files that cover everything that
needs to be tested. That can mean mail formated files or files that don't
fullfill their standard completely but are still read by most tools (eq. PDB).

Here follows a list of each file with a short description how it was generated
and how the content can be validated.

text.xyz
--------
## Creation
Written with MDAnalysis using the 'create_data.py' script

## Validation
Manually examining the file in a text editor of your choice. The atom names
should be the same as in 'test_topology.pdb'.

test.xyz.bz2
------------
## Creation

    bzip2 test.xyz

## Validation
unpack and check that the content is the same as test.xyz

test.xtc
--------
## Creation
Written with MDAnalysis using the 'create_data.py' script

## Validation
With `gmx dump -f test.xtc` you can look at the content of the file in
plain text using Gromacs utilities.

test.trr
--------
## Creation
Written with MDAnalysis using the 'create_data.py' script

## Validation
With `gmx dump -f test.trr` you can look at the content of the file in
plain text using Gromacs utilities.

test.h5md
---------
## Creation
Written with MDAnalysis using the 'create_h5md_data.py' script

## Validation
Manually examined contents of the datasets in test.h5md with h5py and compared
with MDAnalysis.
Avast, here be scurvy ascii files with DOS line endings.

They be here for the testing of reading these on different platforrrrms.

See related issues #2125 and #2128 on the good ship Github.================================
  MDAnalysis Repository README
================================

|numfocus| |build| |cron| |travis| |cov| [*]_

|docs| |devdocs| |usergroup| |developergroup| |anaconda| |mybinder|

MDAnalysis_ is a Python library for the analysis of computer simulations of many-body systems at the molecular scale, spanning use cases from interactions of drugs with proteins to novel materials. It is widely used in the scientific community and is written by scientists for scientists. 

It works with a wide range of popular simulation packages including Gromacs, Amber, NAMD, CHARMM, DL_Poly, HooMD, LAMMPS and many others — see the lists of supported `trajectory formats`_ and `topology formats`_.
MDAnalysis also includes widely used analysis algorithms in the `MDAnalysis.analysis`_ module.

.. _numfocus-fiscal-sponsor-attribution:

The MDAnalysis project uses an `open governance model`_ and is fiscally sponsored by `NumFOCUS`_. Consider making 
a `tax-deductible donation`_ to help the project pay for developer time, professional services, travel, workshops, and a variety of other needs.

.. image:: https://www.mdanalysis.org/public/images/numfocus-sponsored-small.png
   :alt: NumFOCUS (Fiscally Sponsored Project)
   :target: https://numfocus.org/project/mdanalysis
   :align: center

This project is bound by a `Code of Conduct`_.

|powered_by_MDA|

If you use MDAnalysis_ in your project consider lettting your users and the world know about it by displaying the MDAnalysis_ badge! `Embedding code`_ is available for different markups.

Example analysis script
=======================

.. code:: python

   import MDAnalysis as mda

   # Load simulation results with a single line
   u = mda.Universe('topol.tpr','traj.trr')

   # Select atoms
   ag = u.select_atoms('name OH')

   # Atom data made available as Numpy arrays
   ag.positions
   ag.velocities
   ag.forces

   # Iterate through trajectories
   for ts in u.trajectory:
       print(ag.center_of_mass())


Documentation
=============

**New users** should read the `Quickstart Guide`_ and might want to
look at our videos_, in which core developers explain various aspects
of MDAnalysis.

**All users** should read the `User Guide`_.

**Developers** may also want to refer to the `MDAnalysis API docs`_.

A growing number of `tutorials`_ are available that explain how to
conduct RMSD calculations, structural alignment, distance and contact
analysis, and many more.


Installation and availability
=============================

The latest release can be **installed via ``pip`` or ``conda``** as
described in the `Installation Quick Start`_.

**Source code** is hosted in a git repository at
https://github.com/MDAnalysis/mdanalysis and is available under the
GNU General Public License, version 2 (see the file LICENSE_).


Contributing
============

Please report **bugs** or **enhancement requests** through the `Issue
Tracker`_. Questions can also be asked on the `user mailing list`_.

If you are a **new developer** who would like to start contributing to
MDAnalysis get in touch on the `developer mailing list`_. To set up a
development environment and run the test suite read the `developer
guide`_.


Citation
========

When using MDAnalysis in published work, please cite the following
two papers:

*   R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy,
    M. N. Melo, S. L. Seyler, D. L. Dotson, J. Domanski,
    S. Buchoux, I. M. Kenney, and O. Beckstein. MDAnalysis:
    A Python package for the rapid analysis of molecular
    dynamics simulations. In S. Benthall and S. Rostrup,
    editors, Proceedings of the 15th Python in Science
    Conference, pages 102-109, Austin, TX, 2016. SciPy.
    doi:`10.25080/Majora-629e541a-00e`_    

*   N. Michaud-Agrawal, E. J. Denning, T. B. Woolf,
    and O. Beckstein. MDAnalysis: A Toolkit for the Analysis of Molecular
    Dynamics Simulations. *J. Comput. Chem.* **32** (2011), 2319--2327.
    doi:`10.1002/jcc.21787`_

For citations of included algorithms and sub-modules please see the references_.



.. Footnotes

.. [*] **build**: Unit testing is for the whole package; **coverage** is
       shown for the core library modules and the analysis modules.

.. _NumFOCUS: https://numfocus.org/
.. _open governance model: https://www.mdanalysis.org/about/#governance
.. _tax-deductible donation: https://numfocus.org/donate-to-mdanalysis
.. _`Code of Conduct`: https://www.mdanalysis.org/pages/conduct/
.. _trajectory formats: https://docs.mdanalysis.org/documentation_pages/coordinates/init.html#id1
.. _topology formats: https://docs.mdanalysis.org/documentation_pages/topology/init.html#supported-topology-formats
.. _MDAnalysis: https://www.mdanalysis.org
.. _LICENSE:
   https://github.com/MDAnalysis/mdanalysis/blob/master/LICENSE
.. _`Installation Quick Start`:
   https://www.mdanalysis.org/pages/installation_quick_start/
.. _`MDAnalysis.analysis`: https://docs.mdanalysis.org/documentation_pages/analysis_modules.html
.. _`tutorials`: https://userguide.mdanalysis.org/examples/README.html
.. _`videos`: https://www.mdanalysis.org/pages/learning_MDAnalysis/#videos
.. _`Quickstart Guide`:
   https://userguide.mdanalysis.org/examples/quickstart.html
.. _`User Guide`: https://userguide.mdanalysis.org
.. _`MDAnalysis API docs`:
   https://docs.mdanalysis.org
.. _`Issue Tracker`: https://github.com/mdanalysis/mdanalysis/issues
.. _`user mailing list`:
   https://groups.google.com/group/mdnalysis-discussion
.. _`developer guide`:
   https://userguide.mdanalysis.org/contributing.html
.. _`developer mailing list`:
   https://groups.google.com/group/mdnalysis-devel
.. _`10.1002/jcc.21787`: https://dx.doi.org/10.1002/jcc.21787
.. _`10.25080/Majora-629e541a-00e`: https://doi.org/10.25080/Majora-629e541a-00e
.. _references: https://docs.mdanalysis.org/documentation_pages/references.html
.. _Embedding code: https://www.mdanalysis.org/pages/citations/#powered-by-mdanalysis


.. |usergroup| image:: https://img.shields.io/badge/Google%20Group-Users-lightgrey.svg
   :alt: User Google Group
   :target: https://groups.google.com/group/mdnalysis-discussion

.. |developergroup| image:: https://img.shields.io/badge/Google%20Group-Developers-lightgrey.svg
   :alt: Developer Google Group
   :target: https://groups.google.com/group/mdnalysis-devel

.. |docs| image:: https://img.shields.io/badge/docs-latest-brightgreen.svg
   :alt: Documentation (latest release)
   :target: https://docs.mdanalysis.org

.. |devdocs| image:: https://img.shields.io/badge/docs-development-yellow.svg
   :alt: Documentation (development version)
   :target: https://docs.mdanalysis.org/dev

.. |numfocus| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A
   :alt: Powered by NumFOCUS
   :target: https://www.numfocus.org/

.. |build| image:: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci.yaml/badge.svg
   :alt: Github Actions Build Status
   :target: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci.yaml

.. |cron| image:: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci-cron.yaml/badge.svg
   :alt: Github Actions Cron Job Status
   :target: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci-cron.yaml

.. |travis| image:: https://img.shields.io/travis/MDAnalysis/mdanalysis/develop?label=Travis%20CI
   :alt: Travis CI Build Status
   :target: https://travis-ci.com/MDAnalysis/mdanalysis

.. |cov|   image:: https://codecov.io/gh/MDAnalysis/mdanalysis/branch/develop/graph/badge.svg
   :alt: Coverage Status
   :target: https://codecov.io/gh/MDAnalysis/mdanalysis

.. |anaconda| image:: https://anaconda.org/conda-forge/mdanalysis/badges/version.svg
   :alt: Anaconda
   :target: https://anaconda.org/conda-forge/mdanalysis

.. |mybinder| image:: https://mybinder.org/badge.svg
   :alt: My Binder
   :target: https://mybinder.org/v2/gh/MDAnalysis/binder-notebook/master

.. |powered_by_MDA| image:: https://img.shields.io/badge/Powered%20by-MDAnalysis-orange.svg?logoWidth=15&logo=data:image/x-icon;base64,AAABAAEAEBAAAAEAIAAoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJD+XwCY/fEAkf3uAJf97wGT/a+HfHaoiIWE7n9/f+6Hh4fvgICAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACT/yYAlP//AJ///wCg//8JjvOchXly1oaGhv+Ghob/j4+P/39/f3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJH8aQCY/8wAkv2kfY+elJ6al/yVlZX7iIiI8H9/f7h/f38UAAAAAAAAAAAAAAAAAAAAAAAAAAB/f38egYF/noqAebF8gYaagnx3oFpUUtZpaWr/WFhY8zo6OmT///8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAn46Ojv+Hh4b/jouJ/4iGhfcAAADnAAAA/wAAAP8AAADIAAAAAwCj/zIAnf2VAJD/PAAAAAAAAAAAAAAAAICAgNGHh4f/gICA/4SEhP+Xl5f/AwMD/wAAAP8AAAD/AAAA/wAAAB8Aov9/ALr//wCS/Z0AAAAAAAAAAAAAAACBgYGOjo6O/4mJif+Pj4//iYmJ/wAAAOAAAAD+AAAA/wAAAP8AAABhAP7+FgCi/38Axf4fAAAAAAAAAAAAAAAAiIiID4GBgYKCgoKogoB+fYSEgZhgYGDZXl5e/m9vb/9ISEjpEBAQxw8AAFQAAAAAAAAANQAAADcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjo6Mb5iYmP+cnJz/jY2N95CQkO4pKSn/AAAA7gAAAP0AAAD7AAAAhgAAAAEAAAAAAAAAAACL/gsAkv2uAJX/QQAAAAB9fX3egoKC/4CAgP+NjY3/c3Nz+wAAAP8AAAD/AAAA/wAAAPUAAAAcAAAAAAAAAAAAnP4NAJL9rgCR/0YAAAAAfX19w4ODg/98fHz/i4uL/4qKivwAAAD/AAAA/wAAAP8AAAD1AAAAGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALGxsVyqqqr/mpqa/6mpqf9KSUn/AAAA5QAAAPkAAAD5AAAAhQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADkUFBSuZ2dn/3V1df8uLi7bAAAATgBGfyQAAAA2AAAAMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0AAADoAAAA/wAAAP8AAAD/AAAAWgC3/2AAnv3eAJ/+dgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9AAAA/wAAAP8AAAD/AAAA/wAKDzEAnP3WAKn//wCS/OgAf/8MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIQAAANwAAADtAAAA7QAAAMAAABUMAJn9gwCe/e0Aj/2LAP//AQAAAAAAAAAA
   :alt: Powered by MDAnalysis
   :target: https://www.mdanalysis.org
=====================
MDAnalysis benchmarks
=====================

Benchmarking MDAnalysis with Airspeed Velocity.

Usage with MDAnalysis
---------------------

Airspeed Velocity builds clean conda environments to
benchmark the performance of MDAnalysis at different
time points in its history (for different git commit
hashes).

To build / install Airspeed Velocity it should
suffice to clone the `git repo`_, building the master
branch with::

    python setup.py install --user

`Airspeed Velocity commands`_ are described in detail in their
documentation. A common usage example for evaluating the
performance of a feature branch / pull request would be::

    asv continuous --bench GROReadBench d76c9348 e0bc303 -e

In the above, ``GROReadBench`` is handled as a regular
expression for the specific benchmark test to run between
the provided git commit hashes.

To evaluate a benchmark test over the course of project
history one would commonly use ``asv run``. For example,
to probe performance for trajectory readers at 20 commit
hashes evenly spread over a few years of the project one
might run::

     asv run -e -s 20 ddb57592..e0bc3034 --bench TrajReaderBench -j

It is also possible to specify ``ALL`` to space the performance
tests over the entire lifetime of the project, but exercise
caution as very early commits may represent a state of the
project where many features are not available and / or
files are not in the expected locations. Using ``--merges`` is also
frequently advisable as merge commits are more likely to build
and run successfully.

The ``asv run`` command will store detailed benchmark data locally
as ``JSON`` files, which can be converted into interactive website
data and hosted locally with::

    asv publish
    asv preview

.. _git repo: https://github.com/airspeed-velocity/asv
.. _Airspeed Velocity commands: http://asv.readthedocs.io/en/latest/commands.html

Writing benchmarks
------------------

The Airspeed Velocity `documentation for writing benchmarks`_ is a
suitable reference. As a quick summary of guidelines:

- wrap imports from MDAnalysis in the test modules because older
  commit hashes may not have the name imported for various reasons::

     try:
        from MDAnalysis.coordinates.DCD import DCDReader
     except ImportError:
        pass

  The benchmarks themselves will automatically handle the missing
  features if the above is done.

- leave the timing code to ASV -- don't implement your own

- the benchmarks are written as Python modules in the `benchmark`
  directory (and subdirectories thereof). There are no formal
  naming requirements for these modules. Benchmarks are generally
  written as functions of the form `time_feature()` with the `time`
  prefix, sometimes within a broader class object. A `setup` method
  or attribute may be used to perform operations that are required
  for the test suite, but should not be included in the performance
  timing.

- parametrized benchmarks can be quite powerful for testing several
  inputs to a test; note that all possible combinations will be tested,
  and it is very useful to label the parameters with names as these
  will be nicely summarized in the output::

       params = (['XTC', 'TRR', 'DCD'],
                 [10, 20, 30])
       param_names = ['traj_format', 'num_atoms']

- memory usage can also be profiled with test prefixes including `mem`
  and `peakmem`

.. _documentation for writing benchmarks: http://asv.readthedocs.io/en/latest/writing_benchmarks.html

Advanced Notes
--------------

- the depedencies installed in the clean conda benchmarking environments,
  and indeed the decision to use conda over virtualenv, can be controlled
  in the ``asv.conf.json`` file, as can which versions of Python are probed

- the above file also controls which branch of MDAnalysis is used for a
  first-pass check of the benchmarks that are written--regardless of where you
  run the benchmarks from, the current ``JSON`` file indicates that ASV
  will check your benchmark code against the latest commit hash on develop
  branch first, before running the actual benchmarks for the specified commit
  hashes
================================
  MDAnalysis Repository README
================================

|numfocus| |build| |travis| |cov| [*]_

|docs| |devdocs| |usergroup| |developergroup| |anaconda| |mybinder|

MDAnalysis_ is a Python library for the analysis of computer simulations of many-body systems at the molecular scale, spanning use cases from interactions of drugs with proteins to novel materials. It is widely used in the scientific community and is written by scientists for scientists. 

It works with a wide range of popular simulation packages including Gromacs, Amber, NAMD, CHARMM, DL_Poly, HooMD, LAMMPS and many others — see the lists of supported `trajectory formats`_ and `topology formats`_.
MDAnalysis also includes widely used analysis algorithms in the `MDAnalysis.analysis`_ module.

.. _numfocus-fiscal-sponsor-attribution:

The MDAnalysis project uses an `open governance model`_ and is fiscally sponsored by `NumFOCUS`_. Consider making 
a `tax-deductible donation`_ to help the project pay for developer time, professional services, travel, workshops, and a variety of other needs.

.. image:: https://www.mdanalysis.org/public/images/numfocus-sponsored-small.png
   :alt: NumFOCUS (Fiscally Sponsored Project)
   :target: https://numfocus.org/project/mdanalysis
   :align: center

This project is bound by a `Code of Conduct`_.

|powered_by_MDA|

If you use MDAnalysis_ in your project consider lettting your users and the world know about it by displaying the MDAnalysis_ badge! `Embedding code`_ is available for different markups.

Example analysis script
=======================

.. code:: python

   import MDAnalysis as mda

   # Load simulation results with a single line
   u = mda.Universe('topol.tpr','traj.trr')

   # Select atoms
   ag = u.select_atoms('name OH')

   # Atom data made available as Numpy arrays
   ag.positions
   ag.velocities
   ag.forces

   # Iterate through trajectories
   for ts in u.trajectory:
       print(ag.center_of_mass())


Documentation
=============

**New users** should read the `Quickstart Guide`_ and might want to
look at our videos_, in which core developers explain various aspects
of MDAnalysis.

**All users** should read the `User Guide`_.

**Developers** may also want to refer to the `MDAnalysis API docs`_.

A growing number of `tutorials`_ are available that explain how to
conduct RMSD calculations, structural alignment, distance and contact
analysis, and many more.


Installation and availability
=============================

The latest release can be **installed via ``pip`` or ``conda``** as
described in the `Installation Quick Start`_.

**Source code** is hosted in a git repository at
https://github.com/MDAnalysis/mdanalysis and is available under the
GNU General Public License, version 2 (see the file LICENSE_).


Contributing
============

Please report **bugs** or **enhancement requests** through the `Issue
Tracker`_. Questions can also be asked on the `user mailing list`_.

If you are a **new developer** who would like to start contributing to
MDAnalysis get in touch on the `developer mailing list`_. To set up a
development environment and run the test suite read the `developer
guide`_.


Citation
========

When using MDAnalysis in published work, please cite the following
two papers:

*   R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy,
    M. N. Melo, S. L. Seyler, D. L. Dotson, J. Domanski,
    S. Buchoux, I. M. Kenney, and O. Beckstein. MDAnalysis:
    A Python package for the rapid analysis of molecular
    dynamics simulations. In S. Benthall and S. Rostrup,
    editors, Proceedings of the 15th Python in Science
    Conference, pages 102-109, Austin, TX, 2016. SciPy.
    doi:`10.25080/Majora-629e541a-00e`_    

*   N. Michaud-Agrawal, E. J. Denning, T. B. Woolf,
    and O. Beckstein. MDAnalysis: A Toolkit for the Analysis of Molecular
    Dynamics Simulations. *J. Comput. Chem.* **32** (2011), 2319--2327.
    doi:`10.1002/jcc.21787`_

For citations of included algorithms and sub-modules please see the references_.



.. Footnotes

.. [*] **build**: Unit testing is for the whole package; **coverage** is
       shown for the core library modules and the analysis modules.

.. _NumFOCUS: https://numfocus.org/
.. _open governance model: https://www.mdanalysis.org/about/#governance
.. _tax-deductible donation: https://numfocus.org/donate-to-mdanalysis
.. _`Code of Conduct`: https://www.mdanalysis.org/pages/conduct/
.. _trajectory formats: https://docs.mdanalysis.org/documentation_pages/coordinates/init.html#id1
.. _topology formats: https://docs.mdanalysis.org/documentation_pages/topology/init.html#supported-topology-formats
.. _MDAnalysis: https://www.mdanalysis.org
.. _LICENSE:
   https://github.com/MDAnalysis/mdanalysis/blob/master/LICENSE
.. _`Installation Quick Start`:
   https://www.mdanalysis.org/pages/installation_quick_start/
.. _`MDAnalysis.analysis`: https://docs.mdanalysis.org/documentation_pages/analysis_modules.html
.. _`tutorials`: https://userguide.mdanalysis.org/examples/README.html
.. _`videos`: https://www.mdanalysis.org/pages/learning_MDAnalysis/#videos
.. _`Quickstart Guide`:
   https://userguide.mdanalysis.org/examples/quickstart.html
.. _`User Guide`: https://userguide.mdanalysis.org
.. _`MDAnalysis API docs`:
   https://docs.mdanalysis.org
.. _`Issue Tracker`: https://github.com/mdanalysis/mdanalysis/issues
.. _`user mailing list`:
   https://groups.google.com/group/mdnalysis-discussion
.. _`developer guide`:
   https://userguide.mdanalysis.org/contributing.html
.. _`developer mailing list`:
   https://groups.google.com/group/mdnalysis-devel
.. _`10.1002/jcc.21787`: https://dx.doi.org/10.1002/jcc.21787
.. _`10.25080/Majora-629e541a-00e`: https://doi.org/10.25080/Majora-629e541a-00e
.. _references: https://docs.mdanalysis.org/documentation_pages/references.html
.. _Embedding code: https://www.mdanalysis.org/pages/citations/#powered-by-mdanalysis


.. |usergroup| image:: https://img.shields.io/badge/Google%20Group-Users-lightgrey.svg
   :alt: User Google Group
   :target: https://groups.google.com/group/mdnalysis-discussion

.. |developergroup| image:: https://img.shields.io/badge/Google%20Group-Developers-lightgrey.svg
   :alt: Developer Google Group
   :target: https://groups.google.com/group/mdnalysis-devel

.. |docs| image:: https://img.shields.io/badge/docs-latest-brightgreen.svg
   :alt: Documentation (latest release)
   :target: https://docs.mdanalysis.org

.. |devdocs| image:: https://img.shields.io/badge/docs-development-yellow.svg
   :alt: Documentation (development version)
   :target: https://docs.mdanalysis.org/dev

.. |numfocus| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A
   :alt: Powered by NumFOCUS
   :target: https://www.numfocus.org/

.. |build| image:: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci.yaml/badge.svg
   :alt: Github Actions Build Status
   :target: https://github.com/MDAnalysis/mdanalysis/actions/workflows/gh-ci.yaml

.. |travis| image:: https://img.shields.io/travis/MDAnalysis/mdanalysis/develop?label=Travis%20CI
   :alt: Travis CI Build Status
   :target: https://travis-ci.com/MDAnalysis/mdanalysis

.. |cov|   image:: https://codecov.io/gh/MDAnalysis/mdanalysis/branch/develop/graph/badge.svg
   :alt: Coverage Status
   :target: https://codecov.io/gh/MDAnalysis/mdanalysis

.. |anaconda| image:: https://anaconda.org/conda-forge/mdanalysis/badges/version.svg
   :alt: Anaconda
   :target: https://anaconda.org/conda-forge/mdanalysis

.. |mybinder| image:: https://mybinder.org/badge.svg
   :alt: My Binder
   :target: https://mybinder.org/v2/gh/MDAnalysis/binder-notebook/master

.. |powered_by_MDA| image:: https://img.shields.io/badge/Powered%20by-MDAnalysis-orange.svg?logoWidth=15&logo=data:image/x-icon;base64,AAABAAEAEBAAAAEAIAAoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJD+XwCY/fEAkf3uAJf97wGT/a+HfHaoiIWE7n9/f+6Hh4fvgICAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACT/yYAlP//AJ///wCg//8JjvOchXly1oaGhv+Ghob/j4+P/39/f3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJH8aQCY/8wAkv2kfY+elJ6al/yVlZX7iIiI8H9/f7h/f38UAAAAAAAAAAAAAAAAAAAAAAAAAAB/f38egYF/noqAebF8gYaagnx3oFpUUtZpaWr/WFhY8zo6OmT///8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAn46Ojv+Hh4b/jouJ/4iGhfcAAADnAAAA/wAAAP8AAADIAAAAAwCj/zIAnf2VAJD/PAAAAAAAAAAAAAAAAICAgNGHh4f/gICA/4SEhP+Xl5f/AwMD/wAAAP8AAAD/AAAA/wAAAB8Aov9/ALr//wCS/Z0AAAAAAAAAAAAAAACBgYGOjo6O/4mJif+Pj4//iYmJ/wAAAOAAAAD+AAAA/wAAAP8AAABhAP7+FgCi/38Axf4fAAAAAAAAAAAAAAAAiIiID4GBgYKCgoKogoB+fYSEgZhgYGDZXl5e/m9vb/9ISEjpEBAQxw8AAFQAAAAAAAAANQAAADcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjo6Mb5iYmP+cnJz/jY2N95CQkO4pKSn/AAAA7gAAAP0AAAD7AAAAhgAAAAEAAAAAAAAAAACL/gsAkv2uAJX/QQAAAAB9fX3egoKC/4CAgP+NjY3/c3Nz+wAAAP8AAAD/AAAA/wAAAPUAAAAcAAAAAAAAAAAAnP4NAJL9rgCR/0YAAAAAfX19w4ODg/98fHz/i4uL/4qKivwAAAD/AAAA/wAAAP8AAAD1AAAAGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALGxsVyqqqr/mpqa/6mpqf9KSUn/AAAA5QAAAPkAAAD5AAAAhQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADkUFBSuZ2dn/3V1df8uLi7bAAAATgBGfyQAAAA2AAAAMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0AAADoAAAA/wAAAP8AAAD/AAAAWgC3/2AAnv3eAJ/+dgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9AAAA/wAAAP8AAAD/AAAA/wAKDzEAnP3WAKn//wCS/OgAf/8MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIQAAANwAAADtAAAA7QAAAMAAABUMAJn9gwCe/e0Aj/2LAP//AQAAAAAAAAAA
   :alt: Powered by MDAnalysis
   :target: https://www.mdanalysis.org
.. -*- coding: utf-8 -*-
.. MDAnalysis documentation master file, created by
.. sphinx-quickstart on Mon Sep 27 09:39:55 2010.
.. You can adapt this file completely to your liking, but it should at least
.. contain the root `toctree` directive.

###############################
MDAnalysis documentation
###############################


:Release: |release|
:Date: |today|

**MDAnalysis** (`www.mdanalysis.org`_) is an object-oriented python
toolkit to analyze molecular dynamics trajectories generated by
CHARMM_, Gromacs_, Amber_, NAMD_, LAMMPS_, `DL_POLY`_ and other
packages; it also reads other formats (e.g., PDB_ files and `XYZ
format`_ trajectories; see :ref:`Supported coordinate formats` and
:ref:`Supported topology formats` for the full lists). It can write
most of these formats, too, together with atom selections for use in
Gromacs_, CHARMM_, VMD_ and PyMol_ (see :ref:`Selection exporters`).

It allows one to read molecular dynamics trajectories and access the
atomic coordinates through NumPy_ arrays. This provides a flexible and
relatively fast framework for complex analysis tasks. Fairly complete
atom :ref:`selection-commands-label` are implemented. Trajectories can
also be manipulated (for instance, fit to a reference structure) and
written out in a range of formats.

.. _`www.mdanalysis.org`: https://www.mdanalysis.org
.. _NumPy: http://numpy.scipy.org
.. _CHARMM:  http://www.charmm.org/
.. _Amber:   http://ambermd.org/
.. _LAMMPS:  http://lammps.sandia.gov/
.. _NAMD:    http://www.ks.uiuc.edu/Research/namd/
.. _Gromacs: http://www.gromacs.org/
.. _`DL_POLY`: http://www.scd.stfc.ac.uk//44516.aspx
.. _VMD: http://www.ks.uiuc.edu/Research/vmd/
.. _PyMol: http://www.pymol.org/
.. _PDB: http://www.rcsb.org/pdb/static.do?p=file_formats/pdb/index.html
.. _XYZ format: http://openbabel.org/wiki/XYZ_%28format%29


Getting involved
================

Please report **bugs** or **enhancement requests** through the `Issue
Tracker`_. Questions can also be asked on the `mdnalysis-discussion mailing
list`_.

The MDAnalysis community subscribes to a `Code of Conduct`_ that all community
members agree and adhere to --- please read it.

.. _Issue Tracker: https://github.com/MDAnalysis/mdanalysis/issues
.. _`mdnalysis-discussion mailing list`:
   http://groups.google.com/group/mdnalysis-discussion
.. _`Code of Conduct`: https://www.mdanalysis.org/pages/conduct/



User Guide
==========

The MDAnalysis `User Guide`_ provides comprehensive information on how to
use the library. We would recommend that new users have a look at the
`Quick Start Guide`_. The User Guide also has a set of `examples`_ on how to
use the MDAnalysis library which may be of interest.

.. _`User Guide`: https://userguide.mdanalysis.org/stable/index.html
.. _`Quick Start Guide`: https://userguide.mdanalysis.org/stable/examples/quickstart.html
.. _`examples`: https://userguide.mdanalysis.org/stable/examples/README.html


.. _installation-instructions:

Installing MDAnalysis
=====================

The easiest approach to `install the latest release`_ is to use a package that
can be installed either with conda_ or pip_.

conda
-----

First installation with conda_:	

.. code-block:: bash 

   conda config --add channels conda-forge
   conda install mdanalysis

which will automatically install a *full set of dependencies*.

To upgrade later:

.. code-block:: bash 

   conda update mdanalysis

pip
---

Installation with `pip`_ and a *minimal set of dependencies*:

.. code-block:: bash 

   pip install --upgrade MDAnalysis

To install with a *full set of dependencies* (which includes everything needed
for :mod:`MDAnalysis.analysis`), add the ``[analysis]`` tag:

.. code-block:: bash 

   pip install --upgrade MDAnalysis[analysis]


Tests
-----

If you want to `run the tests`_ or use example files to follow some of the
examples in the documentation or the tutorials_, also install the
``MDAnalysisTests`` package:

.. code-block:: bash 

   conda install mdanalysistests            # with conda
   pip install --upgrade MDAnalysisTests    # with pip

.. _install the latest release:
   https://userguide.mdanalysis.org/stable/installation.html#installation
.. _pip:
   http://www.pip-installer.org/en/latest/index.html
.. _conda:
   http://conda.pydata.org/docs/
.. _run the tests: https://github.com/MDAnalysis/mdanalysis/wiki/UnitTests
.. _tutorials: https://www.mdanalysis.org/pages/learning_MDAnalysis/


Source Code
===========

**Source code** is available from
https://github.com/MDAnalysis/mdanalysis/ under the `GNU Public
Licence, version 2`_. Obtain the sources with `git`_.

.. code-block:: bash

   git clone https://github.com/MDAnalysis/mdanalysis.git


The `User Guide`_ provides more information on how to
`install the development version`_ of MDAnalysis.

.. _GNU Public Licence, version 2:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
.. _git: https://git-scm.com/
.. _`install the development version`: https://userguide.mdanalysis.org/stable/installation.html#development-versions


Citation
========

When using MDAnalysis in published work, please cite
[Michaud-Agrawal2011]_ and [Gowers2016]_.

MDAnalysis also contains specific algorithms and whole analysis
modules whose algorithms have also been published in the scientific
literature. Please make sure to also reference any
:ref:`references-components` in published work.

Thank you!


.. Hide the contents from the front page because they are already in
.. the side bar in the Alabaster sphinx style; requires Alabaster
.. config sidebar_includehidden=True (default)

.. Contents
.. ========

.. toctree::
   :maxdepth: 4
   :numbered:		
   :hidden:
   
   ./documentation_pages/overview
   ./documentation_pages/topology
   ./documentation_pages/selections
   ./documentation_pages/analysis_modules
   ./documentation_pages/topology_modules
   ./documentation_pages/coordinates_modules
   ./documentation_pages/converters
   ./documentation_pages/trajectory_transformations
   ./documentation_pages/selections_modules
   ./documentation_pages/auxiliary_modules
   ./documentation_pages/core_modules
   ./documentation_pages/visualization_modules
   ./documentation_pages/lib_modules
   ./documentation_pages/version
   ./documentation_pages/units
   ./documentation_pages/exceptions
   ./documentation_pages/references
	

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

.. _lib:

*******************************************
Library functions --- :mod:`MDAnalysis.lib`
*******************************************

.. module:: MDAnalysis.lib
   :synopsis: ``lib`` collects independent code for re-use in MDAnalysis

:mod:`MDAnalysis.lib` contains code that is independent of the
specific MDAnalysis framework, such as fast calculators for distances
or simple logging support. Modules do not depend on other code inside
MDAnalysis except in :mod:`MDAnalysis.lib` itself (and possibly in
:mod:`MDAnalysis.exceptions`) and thus can be easily imported
elsewhere.

Overview
--------

:mod:`MDAnalysis.lib.distances` contains many high performance maths
functions. Most of them have the keyword *backend* that allows one to
either select serial (single threaded) code (``backend="serial``) or
to use parallelized versions (e.g. ``backend="OpenMP"`` for OpenMP
parallelism).

:mod:`MDAnalysis.lib.transformations` contains a multitude of
matrix operations for manipulating coordinate data.

:mod:`MDAnalysis.lib.qcprot` contains a fast implementation of
superposition by minimizing the RMSD.

:mod:`MDAnalysis.lib.util` contains various file and string utility
functions whereas mathematical functions are to be found in
:mod:`MDAnalysis.lib.mdamath`.

A number of modules are concerned with finding
neighbors. :mod:`MDAnalysis.lib.NeighborSearch` contains high-level
classes to do neighbor searches with MDAnalysis
objects. :mod:`MDAnalysis.lib.nsgrid` contains a fast implementation
of grid neighbor search whereas :mod:`MDAnalysis.lib.pkdtree` uses
KDTrees (with periodic images) for neighbor searching. Some of the
functions in :mod:`MDAnalysis.lib.distances` user either of these
algorithms to speed up distance calculations.



List of modules
---------------

.. toctree::
   :maxdepth: 1

   ./lib/distances
   ./lib/NeighborSearch
   ./lib/nsgrid
   ./lib/pkdtree	      
   ./lib/log
   ./lib/mdamath
   ./lib/transformations
   ./lib/qcprot
   ./lib/util
   ./lib/correlations
   ./lib/picklable_file_io

Low level file formats
----------------------

The modules in :mod:`MDAnalysis.lib.formats` contain code to access various file
formats in a way that is *independent from other MDAnalysis functionality*
(i.e., they do not use any classes from :mod:`MDAnalysis.core` or
:mod:`MDAnalysis.topology`). This low-level code is used in the
:mod:`MDAnalysis.coordinates` module but can also be re-used by other
Python-based projects.

.. toctree::
   :maxdepth: 1

   ./lib/formats/libmdaxdr
   ./lib/formats/libdcd
.. Contains the formatted docstrings from the auxiliary modules located in 'mdanalysis/MDAnalysis/auxiliary'

*****************
Auxiliary modules
*****************

The auxiliary module contains the classes to read auxiliary data and sort out
alignment between auxiliary and trajectory data.

.. toctree::
   :maxdepth: 1

   auxiliary/init
   auxiliary/base
   auxiliary/core
   auxiliary/XVG

.. Contains the formatted docstrings for the transformations located in 'mdanalysis/MDAnalysis/transformations'
.. _transformations:

*********************************************************
Trajectory transformations ("on-the-fly" transformations)
*********************************************************

.. module:: MDAnalysis.transformations

In MDAnalysis, a *transformation* is a function/function-like class
that modifies the data for the current :class:`Timestep` and returns the
:class:`Timestep`. For instance, coordinate transformations, such as
PBC corrections and molecule fitting are often required for some
analyses and visualization. Transformation functions
(``transformation_1`` and ``transformation_2`` in the following
example) can be called by the user for any given :class:`Timestep` of
the trajectory,

.. code-block:: python

    u = MDAnalysis.Universe(topology, trajectory)

    for ts in u.trajectory:
       ts = transformation_2(transformation_1(ts))

where they change the coordinates of the timestep ``ts`` in
place. There is nothing special about these transformations except
that they have to be written in such a way that they change the
:class:`Timestep` in place.

As described under :ref:`workflows`, multiple transformations can be
grouped together and associated with a trajectory so that the
trajectory is **transformed on-the-fly**, i.e., the data read from the
trajectory file will be changed before it is made available in, say,
the :attr:`AtomGroup.positions` attribute.

The submodule :mod:`MDAnalysis.transformations` contains a
collection of transformations (see :ref:`transformations-module`) that
can be immediately used but one can always write custom
transformations (see :ref:`custom-transformations`).


.. _workflows:

Workflows
---------

Instead of manually applying transformations, it is much more
convenient to associate a whole *workflow* of transformations with a
trajectory and have the transformations be called automatically.

A workflow is a sequence (tuple or list) of transformation functions
that will be applied in this order. For example,

.. code-block:: python

    workflow = [transformation_1, transformation_2]
    
would effectively result in

.. code-block:: python
		
     ts = transformation_2(transformation_1(ts))

for every time step in the trajectory.

One can add a workflow using the
:meth:`Universe.trajectory.add_transformations
<MDAnalysis.coordinates.base.ReaderBase.add_transformations>` method
of a trajectory (where the list ``workflow`` is taken from the example
above),

.. code-block:: python

    u.trajectory.add_transformations(*workflow)

or upon :class:`Universe <MDAnalysis.core.universe.Universe>`
creation using the keyword argument `transformations`:

.. code-block:: python
    
    u = MDAnalysis.Universe(topology, trajectory, transformations=workflow)

Note that in these two cases, the workflow cannot be changed after having
being added.


.. _custom-transformations:

Creating transformations
------------------------

A simple *transformation* can also be a function that takes a
:class:`~MDAnalysis.coordinates.base.Timestep` as input, modifies it, and
returns it. If it takes no other arguments but a :class:`Timestep`
can be defined as the following example:

.. code-block:: python

    def up_by_2(ts):
        """
        Translate all coordinates by 2 angstroms up along the Z dimension.
        """
        ts.positions = ts.positions + np.array([0, 0, 2], dtype=np.float32)
        return ts

If the transformation requires other arguments besides the :class:`Timestep`,
the following two methods can be used to create such transformation:


.. _custom-transformations-class:

Creating complex transformation classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

It is implemented by inheriting from
:class:`MDAnalysis.transformations.base.TransformationBase`,
which defines :func:`__call__` for the transformation class
and can be applied directly to a :class:`Timestep`. :func:`_transform` has to
be defined and include the operations on the :class:`MDAnalysis.coordinates.base.Timestep`.

So, a transformation class can be roughly defined as follows:

.. code-block:: python

    from MDAnalysis.transformations import TransformationBase

    class up_by_x_class(TransformationBase):
        def __init__(self, distance):
            self.distance = distance

        def _transform(self, ts):
            ts.positions = ts.positions + np.array([0, 0, self.distance], dtype=np.float32)
            return ts

It is the default construction method in :mod:`MDAnalysis.transformations`
from release 2.0.0 onwards because it can be reliably serialized.
See :class:`MDAnalysis.transformations.translate` for a simple example.


.. _custom-transformations-closure:

Creating complex transformation closure functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Transformation can also be a wrapped function takes the :class:`Timestep` object as argument. 
So in this case, a transformation function (closure) can be roughly defined as follows:

.. code-block:: python

    def up_by_x_func(distance):
        """
        Creates a transformation that will translate all coordinates by a given amount along the Z dimension.
        """
        def wrapped(ts):
            ts.positions = ts.positions + np.array([0, 0, distance], dtype=np.float32)
            return ts
        return wrapped

An alternative to using a wrapped function is using partials from :mod:`functools`. The
above function can be written as:

.. code-block:: python

    import functools

    def up_by_x(ts, distance):
        ts.positions = ts.positions + np.array([0, 0, distance], dtype=np.float32)
        return ts

    up_by_2 = functools.partial(up_by_x, distance=2)

Although functions (closures) work as transformations, they are not used in
in MDAnalysis from release 2.0.0 onwards because they cannot be reliably
serialized and thus a :class:`Universe` with such transformations cannot be
used with common parallelization schemes (e.g., ones based on
:mod:`multiprocessing`).
For detailed descriptions about how to write a closure-style transformation,
please refer to MDAnalysis 1.x documentation.

.. _transformations-module:

Transformations in MDAnalysis
-----------------------------

The module :mod:`MDAnalysis.transformations` contains transformations that can
be immediately used in your own :ref:`workflows<workflows>`. In order to use
any of these transformations, the module must first be imported:

.. code-block:: python

   import MDAnalysis.transformations

A workflow can then be added to a trajectory as described above. Notably,
the parameter `max_threads` can be defined when creating a transformation
instance to limit the maximum threads.
(See :class:`MDAnalysis.transformations.base.TransformationBase` for more details) 
Whether a specific transformation can be used along with parallel analysis
can be assessed by checking its 
:attr:`~MDAnalysis.transformations.base.TransformationBase.parallelizable`
attribute.

See :ref:`implemented-transformations` for more on the existing
transformations in :mod:`MDAnalysis.transformations`.
    

How to transformations
----------------------

Translating the coordinates of a single frame (although one would normally add
the transformation to a :ref:`workflow<workflows>`, as shown in the subsequent
examples):

.. code-block:: python

    u = MDAnalysis.Universe(topology, trajectory)
    new_ts = MDAnalysis.transformations.translate([1,1,1])(u.trajectory.ts)
    
Create a workflow and add it to the trajectory:

.. code-block:: python

    u = MDAnalysis.Universe(topology, trajectory)
    workflow = [MDAnalysis.transformations.translate([1,1,1]), 
                MDAnalysis.transformations.translate([1,2,3])]
    u.trajectory.add_transformations(*workflow)

Giving a workflow as a keyword argument when defining the universe:

.. code-block:: python
    
    workflow = [MDAnalysis.transformations.translate([1,1,1]), 
                MDAnalysis.transformations.translate([1,2,3])]
    u = MDAnalysis.Universe(topology, trajectory, transformations=workflow)
    

.. _building-block-transformation:

Building blocks for Transformation Classes
------------------------------------------
Transformations normally ultilize the power of NumPy to get better performance
on array operations. However, when it comes to parallelism, NumPy will sometimes
oversubscribe the threads, either by hyper threading (when it uses OpenBlas backend),
or by working with other parallel engines (e.g. Dask).

In MDAnalysis, we use `threadpoolctl <https://github.com/joblib/threadpoolctl>`_
inside :class:`~MDAnalysis.transformations.base.TransformationBase` to control the maximum threads for transformations.

It is also possible to apply a global thread limit by setting the external environmental
varibale, e.g. :code:`OMP_NUM_THREADS=1 MKL_NUM_THREADS=1 OPENBLAS_NUM_THREADS=1
BLIS_NUM_THREADS=1 python script.py`. Read more about parallelism and resource management
in `scikit-learn documentations <https://scikit-learn.org/dev/computing/parallelism.html>`_.

Users are advised to benchmark code because interaction between different
libraries can lead to sub-optimal performance with defaults.

.. toctree::

   ./transformations/base

.. _implemented-transformations:

Currently implemented transformations
-------------------------------------

.. toctree::
   
   ./transformations/translate
   ./transformations/rotate
   ./transformations/positionaveraging
   ./transformations/fit
   ./transformations/wrap
   ./transformations/boxdimensions

.. Contains the formatted docstrings from the topology modules located in 'mdanalysis/MDAnalysis/topology'

**************************
Topology modules
**************************

The topology module contains the functions to read topology
files. MDAnalysis uses topology files to identify atoms and bonds
between the atoms. It can use topology files from MD packages such as
CHARMM's and NAMD's PSF format or Amber's PRMTOP files. In addition,
it can also glean atom information from single frame coordinate files
such the PDB, CRD, or PQR formats (see the :ref:`Supported topology
formats`).

Typically, MDAnalysis recognizes formats by the file extension and
hence most users probably do not need to concern themselves with
classes and functions described here. However, if MDAnalysis does not
properly recognize a file format then a user can explicitly set the
topology file format in the *topology_format* keyword argument to
:class:`~MDAnalysis.core.universe.Universe`.

.. rubric:: Topology formats

.. toctree::
   :maxdepth: 1

   topology/init
   topology/CRDParser
   topology/DLPolyParser
   topology/DMSParser
   topology/FHIAIMSParser   
   topology/GMSParser
   topology/GROParser
   topology/GSDParser   
   topology/HoomdXMLParser
   topology/ITPParser
   topology/LAMMPSParser
   topology/MinimalParser
   topology/MMTFParser
   topology/MOL2Parser
   topology/PDBParser
   topology/ExtendedPDBParser
   topology/PDBQTParser
   topology/PQRParser
   topology/PSFParser
   topology/TOPParser
   topology/TPRParser
   topology/TXYZParser
   topology/XYZParser

.. rubric:: Topology core modules

The remaining pages are primarily of interest to developers as they
contain functions and classes that are used in the implementation of
the topology readers.

.. toctree::
   :maxdepth: 1

   topology/base
   topology/core
   topology/guessers
   topology/tables
   topology/tpr_util
.. automodule:: MDAnalysis.exceptions
   :members:
.. -*- coding: utf-8 -*-
.. _topology-label:

=====================
 The topology system
=====================

As shown briefly in :ref:`overview-label`, the :class:`~MDAnalysis.core.universe.Universe` class is the primary object and core interface to molecular dynamics data in MDAnalysis.
When loading topology information from a file, as with ::

  >>> from MDAnalysis import Universe
  >>> from MDAnalysis.tests.datafiles import PSF
  >>> u = Universe(PSF)

the file is read, the contents parsed, and a :class:`~MDAnalysis.core.topology.Topology` object is constructed from these contents.
.. Contains the formatted docstrings from the analysis modules located in 'mdanalysis/MDAnalysis/analysis', although in some cases the documentation imports functions and docstrings from other files which are also curated to reStructuredText markup.

****************
Analysis modules
****************

The :mod:`MDAnalysis.analysis` module contains code to carry out specific
analysis functionality for MD trajectories. 
It is based on the core functionality (i.e. trajectory
I/O, selections etc). The analysis modules can be used as examples for how to
use MDAnalysis but also as working code for research projects; typically all
contributed code has been used by the authors in their own work.
An analysis using the available modules
usually follows the same structure

#. Import the desired module, since analysis modules are not imported 
   by default.
#. Initialize the module previously imported.
#. Run the analysis, optionally for specific trajectory slices
#. Access the analysis from the `results` attribute

.. code-block:: python

   from MDAnalysis.analysis import ExampleAnalysisModule  # (e.g. RMSD)

   analysis_obj = ExampleAnalysisModule(universe, ...)
   analysis_obj.run(start_frame, stop_frame, step)
   print(analysis_obj.results)


Please see the individual module documentation for any specific caveats 
and also read and cite the reference papers associated with these algorithms.

.. rubric:: Additional dependencies

Some of the modules in :mod:`MDAnalysis.analysis` require additional Python
packages to enable full functionality. For example,
:mod:`MDAnalysis.analysis.encore` provides more options if `scikit-learn`_ is
installed. If you installed MDAnalysis with
:program:`pip` (see :ref:`installation-instructions`) 
these packages are *not automatically installed*. 
Although, one can add the ``[analysis]`` tag to the
:program:`pip` command to force their installation. If you installed
MDAnalysis with :program:`conda` then a
*full set of dependencies* is automatically installed.

Other modules require external programs. For instance, the
:mod:`MDAnalysis.analysis.hole2.hole` module requires an installation of the
HOLE_ suite of programs. You will need to install these external dependencies
by following their installation instructions before you can use the
corresponding MDAnalysis module.

.. _scikit-learn: http://scikit-learn.org/
.. _HOLE: http://www.holeprogram.org/

Building blocks for Analysis
============================

The building block for the analysis modules is
:class:`MDAnalysis.analysis.base.AnalysisBase`.
To build your own analysis class start by reading the documentation.

.. toctree::
   :maxdepth: 1

   analysis/base

Distances and contacts
======================

.. toctree::
   :maxdepth: 1

   analysis/align
   analysis/contacts
   analysis/distances
   analysis/rms
   analysis/psa
   analysis/encore
   analysis/bat

Hydrogen bonding
================

.. toctree::
   :maxdepth: 1

   analysis/hydrogenbonds
   analysis/hbond_autocorrel
   analysis/wbridge_analysis

Deprecated modules:

.. toctree::
   :maxdepth: 1

   analysis/hbond_autocorrel_deprecated	      

Membranes and membrane proteins
===============================

.. toctree::
   :maxdepth: 1

   analysis/hole2
   analysis/leaflet

Nucleic acids
=============

.. toctree::
   :maxdepth: 1

   analysis/nuclinfo

Polymers
========

.. toctree::
   :maxdepth: 1

   analysis/polymer


Structure
=========

Macromolecules
--------------

.. toctree::
   :maxdepth: 1

   analysis/gnm
   analysis/helix_analysis
   analysis/dihedrals

Liquids
-------

.. toctree::
   :maxdepth: 1

   analysis/rdf
   analysis/msd

Volumetric analysis
===================

.. toctree::
   :maxdepth: 1

   analysis/density
   analysis/lineardensity
   analysis/waterdynamics

Dimensionality Reduction
========================
.. toctree::
   :maxdepth: 1

   analysis/diffusionmap
   analysis/pca

Legacy analysis modules
=======================

The :mod:`MDAnalysis.analysis.legacy` module contains code that for a
range of reasons is not as well maintained and tested as the other
analysis modules. *Use with care.*

.. toctree::
   :maxdepth: 1

   analysis/legacy_modules

Data
====

.. toctree::
   :maxdepth: 1

   analysis/data
.. Contains the formatted docstrings for the core modules located in 'mdanalysis/MDAnalysis/core'

.. _`Selection exporters`:

*******************
Selection exporters
*******************

The classes in this module allow writing a selection to a file that can be read by
*another program* to select the atoms in a MDAnalysis
:class:`MDAnalysis.core.groups.AtomGroup`. Such cross-package interoperability
allows a user to combine their favourite tools with MDAnalysis for further
visualization or simulation.


.. _Supported selection exporters:

.. table:: Table of supported exporters and recognized file name extensions.

   +---------------+-----------+-------+--------------------------------------------+
   |Name           | extension |  IO   | remarks                                    |
   +===============+===========+=======+============================================+
   | vmd           | tcl       | w     | VMD_ macros, available in Representations; |
   |               |           |       | module :mod:`MDAnalysis.selections.vmd`    |
   +---------------+-----------+-------+--------------------------------------------+
   | pymol         | pml       | w     | simple PyMOL_ selection string;            |
   |               | 	       |       | module :mod:`MDAnalysis.selections.pymol`  |
   +---------------+-----------+-------+--------------------------------------------+
   | gromacs       | ndx       | w     | Gromacs_ index file;                       |
   |               |           |       | module :mod:`MDAnalysis.selections.gromacs`|
   +---------------+-----------+-------+--------------------------------------------+
   | charmm        | str       | w     | CHARMM_ selection of individual atoms;     |
   |               |           |       | module :mod:`MDAnalysis.selections.charmm` |
   +---------------+-----------+-------+--------------------------------------------+
   | jmol          | spt       | w     | Jmol_ selection commands;                  |
   |               |           |       | module :mod:`MDAnalysis.selections.jmol`   |
   +---------------+-----------+-------+--------------------------------------------+

How to write selections
=======================

Single AtomGroup
----------------

The typical situation is that one has an
:class:`~MDAnalysis.core.groups.AtomGroup` and wants to work with the
same selection of atoms in a different package, for example, to
visualize the atoms in VMD_. First create an :class:`AtomGroup` (named
``g`` in the example below) and then use its
:class:`~MDAnalysis.core.groups.AtomGroup.write` method with the
appropriate *file extension* (see :ref:`Supported selection
exporters` for the recognized *extension*)::

  g = u.select_atoms('protein")
  g.write("selections.vmd", name="mda_protein")

In VMD_, sourcing the file ``selections.vmd`` (written in Tcl) defines
the "macro" ``mda_protein`` that contains the atom indices to select

.. code-block:: tcl

   source selection.vmd
   set sel [atomselect top mda_mdanalysis]

and in the GUI the macro appears in the :menuselection:`Graphics -->
Representations` window in the list :guilabel:`Selections: Singlewords` as
"mda_protein".


Multiple selections
-------------------

The :class:`~MDAnalysis.core.groups.AtomGroup.write` method can take
additional keyword arguments, including ``mode``. The default is
``mode="w"``, which will overwrite the provided file. If ``mode="a"``
then the selection is *appended* to the file. 

Alternatively, one may use the
:class:`~MDAnalysis.selections.base.SelectionWriter` itself as a
context manager and write each :class:`AtomGroup` inside the
context. For example, to write multiple groups that were selected to
mark different parts of a lipid bilayer to Gromacs_ index file named
"leaflets.ndx"::

   with mda.selections.gromacs.SelectionWriter('leaflets.ndx', mode='w') as ndx:
       ndx.write(upper_saturated, name='upper_sat')
       ndx.write(lower_saturated, name='lower_sat')
       ndx.write(upper_unsaturated, name='upper_unsat')
       ndx.write(lower_unsaturated, name='lower_unsat')

There is a separate :class:`SelectionWriter` for each format, as
described next.


Selection writers
=================

There exist different :class:`~MDAnalysis.selections.base.SelectionWriterBase`
classes for different packages. The
:func:`~MDAnalysis.selections.get_writer` function can automatically pick
the appropriate one, based on the file name extension in the :ref:`Supported
selection exporters`.

.. autofunction:: MDAnalysis.selections.get_writer


.. rubric:: Formats

Each module implements a :class:`SelectionWriter` for a specific format.

.. toctree::
   :maxdepth: 1

   selections/vmd
   selections/pymol
   selections/gromacs
   selections/charmm
   selections/jmol
   selections/base

.. _CHARMM: http://www.charmm.org
.. _Gromacs: http://www.gromacs.org
.. _VMD: http://www.ks.uiuc.edu/Research/vmd/
.. _PyMOL: http://www.pymol.org
.. _Jmol: http://wiki.jmol.org/
.. module:: MDAnalysis.converters

.. _`Converter modules`:

**************************
Converter modules
**************************

.. versionadded:: 2.0.0

The :mod:`MDAnalysis.converters` module contains the Converter classes that
MDAnalysis uses to convert MDAnalysis  structures to and from other Python
packages. 

If you are converting *to* MDAnalysis, you can use the normal syntax for 
creating a Universe from files. Typically MDAnalysis will recognise which 
library it is dealing with, so you will not need to pass in a ``format`` keyword.

For example::

    import MDAnalysis as mda
    from MDAnalysis import GRO
    import parmed as pmd

    pgro = pmd.load_file(GRO)  # creates parmed structure
    ugro = mda.Universe(pgro)  # you can just pass it in

If you are converting *from* MDAnalysis, use the 
:func:`~MDAnalysis.core.groups.AtomGroup.convert_to` method. With this, 
you will have to specify a package name (case-insensitive). ::

    pgro2 = ugro.atoms.convert_to('PARMED')  # converts back to parmed structure

Another syntax is also available for tab-completion support::

    pgro2 = ugro.atoms.convert_to.parmed()


.. rubric:: Available converters

.. toctree::
   :maxdepth: 1

   converters/ParmEd
   converters/RDKit
   converters/OpenMM

.. rubric:: Converter functionalities

.. toctree::
    :maxdepth: 1

    core/accessors

.. Contains the formatted docstrings for the core modules located in 'mdanalysis/MDAnalysis/core'

**************************
Core modules
**************************

The :mod:`MDAnalysis.core` modules contain functionality essential for
MDAnalysis, such as the central data structures in
:mod:`MDAnalysis.core.universe` and :mod:`MDAnalysis.core.groups` or
the selection definitions and parsing in
:mod:`MDAnalysis.core.selection`.

.. toctree::
   :maxdepth: 1

   core/init

Important objects for users
===========================

All users of MDAnalysis need to understand the two most important
classes in this section, namely the
:class:`~MDAnalysis.core.universe.Universe` and the
:class:`~MDAnalysis.core.groups.AtomGroup`.

.. toctree::
   :maxdepth: 1

   core/universe
   core/groups


.. _topology-system-label:

Topology system
===============

The topology system is primarily of interest to developers.

.. toctree::
   :maxdepth: 1

   core/topology
   core/topologyobjects
   core/topologyattrs

.. SeeAlso:: :ref:`Developer notes for Topology
             Parsers <topology-parsers-developer-notes>`

Selection system
================

The selection system is primarily of interest to developers.

.. toctree::
   :maxdepth: 1

   core/selection

.. Contains the formatted docstrings from the visualization modules located in 'mdanalysis/MDAnalysis/visualization'

*********************
Visualization modules
*********************

The :mod:`MDAnalysis.visualization` namespace contains code to carry out
analyses which return data that is specifically-tailored for visualization.

Please see the individual module documentation for additional references and
citation information.

These modules are not imported by default; in order to use them one has to
import them from :mod:`MDAnalysis.visualization`, for instance: ::

    import MDAnalysis.visualization.streamlines

.. Note::

  Some of the modules require additional Python packages such as matplotlib_ or
  scipy_.

.. _matplotlib: http://matplotlib.org
.. _scipy: https://www.scipy.org/scipylib/index.html


Visualization of Lipid Flow
===========================

.. toctree::
   :maxdepth: 1

   visualization/streamlines
   visualization/streamlines_3D



.. automodule:: MDAnalysis.units

.. _overview-label:

==========================
 Overview over MDAnalysis
==========================

**MDAnalysis** is a Python package that provides classes to access
data in molecular dynamics trajectories. It is object oriented so it
treats atoms, groups of atoms, trajectories, etc as different
objects. Each object has a number of operations defined on itself
(also known as "methods") and also contains values describing the
object ("attributes"). For example, a
:class:`~MDAnalysis.core.groups.AtomGroup` object has a
:meth:`~MDAnalysis.core.groups.AtomGroup.center_of_mass` method that
returns the center of mass of the group of atoms. It also contains an
attribute called :attr:`~MDAnalysis.core.groups.AtomGroup.residues`
that lists all the residues that belong to the group. Using methods
such as :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms`
(which uses `CHARMM-style`_ atom :ref:`selection-commands-label`) one
can create new objects (in this case, another
:class:`~MDAnalysis.core.groups.AtomGroup`).

A typical usage pattern is to iterate through a trajectory and analyze
coordinates for every frame. In the following example the end-to-end distance
of a protein and the radius of gyration of the backbone atoms are calculated::

    import MDAnalysis
    from MDAnalysis.tests.datafiles import PSF,DCD  # test trajectory
    import numpy.linalg
    u = MDAnalysis.Universe(PSF,DCD)  # always start with a Universe
    nterm = u.select_atoms('segid 4AKE and name N')[0]  # can access structure via segid (s4AKE) and atom name
    cterm = u.select_atoms('segid 4AKE and name C')[-1]  # ... takes the last atom named 'C'
    bb = u.select_atoms('protein and backbone')  # a selection (a AtomGroup)
    for ts in u.trajectory:  # iterate through all frames
        r = cterm.pos - nterm.pos  # end-to-end vector from atom positions
        d = numpy.linalg.norm(r)   # end-to-end distance
        rgyr = bb.radius_of_gyration()  # method of a AtomGroup; updates with each frame
        print "frame = %d: d = %f Angstroem, Rgyr = %f Angstroem" % (ts.frame, d, rgyr)


.. _NumPy:   http://numpy.scipy.org
.. _CHARMM:  http://www.charmm.org/
.. _LAMMPS:  http://lammps.sandia.gov/
.. _NAMD:    http://www.ks.uiuc.edu/Research/namd/
.. _Gromacs: http://www.gromacs.org/

.. _CHARMM-style:
   http://www.charmm.org/documentation/c37b1/select.html

.. TODO: more about philosophy etc... copy and paste from paper

Using MDAnalysis in python
==========================

If you've installed MDAnalysis in the standard python modules location, load
from within the interpreter::

 from MDAnalysis import *

or ::

 import MDAnalysis

The idea behind MDAnalysis is to get trajectory data into NumPy_
:class:`numpy.ndarray` arrays, where it can then be easily manipulated using
all the power in NumPy_ and SciPy_.

MDAnalysis works well both in scripts and in interactive use. The developers
very much recommend using MDAnalysis from within the IPython_ Python shell.  It
allows one to interactively explore the objects (using TAB-completion and
online help), do analysis and immediately plot results. The examples in this manual
are typically run from an interactive :program:`ipython` session.

Invariably, a MDAnalysis session starts with loading data into the
:class:`~MDAnalysis.core.universe.Universe` class (which can be accessed
as :class:`MDAnalysis.Universe`)::

 from MDAnalysis import *
 universe = Universe(topology, trajectory)

- The *topology* file lists the atoms and residues (and also their
  connectivity). It can be a CHARMM/XPLOR/NAMD PSF file or a coordinate file
  such as a Protein Databank Brookhaven PDB file, a CHARMM card coordinate file
  (CRD), or a GROMOS/Gromacs GRO file.

- The *trajectory* contains a list of coordinates in the order defined in the
  *topology*. It can either be a single frame (PDB, CRD, and GRO are all read)
  or a time series of coordinate frames such as a CHARMM/NAMD/LAMMPS DCD
  binary file, a Gromacs XTC/TRR trajectory, or a XYZ trajectory (possibly
  compressed with gzip or bzip2).

For the remainder of this introduction we are using a short example trajectory
that is provided with MDAnalysis (as part of the `MDAnalysis test suite`_). The
trajectory is loaded with ::

  >>> from MDAnalysis import Universe
  >>> from MDAnalysis.tests.datafiles import PSF,DCD
  >>> u = Universe(PSF, DCD)

(The ``>>>`` signs are the Python input prompt and are not to be typed; they
just make clear in the examples what is input and what is output.)

The :class:`~MDAnalysis.core.universe.Universe` contains a number of important attributes,
the most important ones of which is
:attr:`~MDAnalysis.core.universe.Universe.atoms`::

  >>> print u.atoms
  <AtomGroup with 3341 atoms>

:attr:`Universe.atoms` is a
:class:`~MDAnalysis.core.groups.AtomGroup` and can be thought of as
list consisting of :class:`~MDAnalysis.core.groups.Atom`
objects. The :class:`~MDAnalysis.core.groups.Atom` is the
elementary and fundamental object in MDAnalysis.

The :attr:`MDAnalysis.Universe.trajectory` attribute gives access to the coordinates
over time::

  >>> print u.trajectory
  < DCDReader '/..../MDAnalysis/tests/data/adk_dims.dcd' with 98 frames of 3341 atoms (0 fixed) >

Finally, the :meth:`MDAnalysis.Universe.select_atoms` method generates a new
:class:`~MDAnalysis.core.groups.AtomGroup` according to a selection criterion

  >>> calphas = u.select_atoms("name CA")
  >>> print calphas
  <AtomGroup with 214 atoms>

as described in :ref:`selection-commands-label`.

.. _SciPy: http://www.scipy.org/
.. _IPython: http://ipython.scipy.org/
.. _MDAnalysis test suite: https://github.com/MDAnalysis/mdanalysis/wiki/UnitTests


Examples
========

The easiest way to get started with MDAnalysis is to read this introduction and the chapters on :ref:`topology-label` and :ref:`selection-commands-label`, then explore the package interactively in IPython_ or another interactive Python interpreter.

Included trajectories
---------------------

MDAnalysis comes with a number of real trajectories for testing. You
can also use them to explore the functionality and ensure that
everything is working properly::

  from MDAnalysis import *
  from MDAnalysis.tests.datafiles import PSF,DCD, PDB,XTC
  u_dims_adk = Universe(PSF,DCD)
  u_eq_adk = Universe(PDB, XTC)

The PSF and DCD file are a closed-form-to-open-form transition of
Adenylate Kinase (from [Beckstein2009]_) and the PDB+XTC file are ten
frames from a Gromacs simulation of AdK solvated in TIP4P water with
the OPLS/AA force field.

.. [Beckstein2009] O. Beckstein, E.J. Denning, J.R. Perilla, and
                   T.B. Woolf. Zipping and Unzipping of Adenylate
                   Kinase: Atomistic Insights into the Ensemble of
                   Open <--> Closed Transitions. *J Mol Biol* **394**
                   (2009), 160--176, doi:`10.1016/j.jmb.2009.09.009`_

.. _`10.1016/j.jmb.2009.09.009`: http://dx.doi.org/10.1016/j.jmb.2009.09.009

Code snippets
-------------

The source code distribution comes with a directory `examples`_ that
contains a number of code snippets that show how to use certain
aspects of MDAnalysis.

For instance, there is code that shows how to

* fit a trajectory to a reference structure using the QCP
  RMSD-alignment code in :mod:`MDAnalysis.core.qcprot`
  (`rmsfit_qcp.py`_);

* do a block-averaging error analysis (`blocks.py`_);

* calculate a potential profile across a membrane (`potential_profile.py`_);

* do a native contact analysis using :mod:`MDAnalysis.analysis.contacts` (`nativecontacts.py`_)

* get the lipid composition of the individual leaflets of a bilayer
  using :mod:`MDAnalysis.analysis.leaflet` (`membrane-leaflets.py`_);

* define the multimeric states of a number of transmembrane peptides
  via clustering (`multimers-analysis.py`_);

* convert between trajectory formats (e.g. `dcd2xtc.py`_ or `amber2dcd.py`_)

* use MDAnalysis for simple model building (`make_MthK_tetramer.py`_);

and more.

.. Links to the stable git repository:

.. _examples:
   https://github.com/MDAnalysis/MDAnalysisCookbook/tree/master/examples/

.. _`rmsfit_qcp.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/rmsfit_qcp.py
.. _`blocks.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/blocks.py
.. _`potential_profile.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/potential_profile.py
.. _`nativecontacts.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/nativecontacts.py
.. _`membrane-leaflets.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/membrane-leaflets.py
.. _`multimers-analysis.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/multimers-analysis.py
.. _`dcd2xtc.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/dcd2xtc.py
.. _`amber2dcd.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/amber2dcd.py
.. _`make_MthK_tetramer.py`:
   https://github.com/MDAnalysis/MDAnalysisCookbook/blob/master/examples/make_MthK_tetramer.py
.. -*- coding: utf-8 -*-
.. _selection-commands-label:

====================
 Selection commands
====================

Once you have the :meth:`~MDAnalysis.core.universe.Universe` object, you can
select atoms (using a syntax very similar to `CHARMM's atom selection
syntax`_)::

  >>> kalp = universe.select_atoms("segid KALP")

.. _`CHARMM's atom selection syntax`:
   https://www.charmm.org/charmm/documentation/by-version/c45b1/select.html

The :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` method of a
:class:`~MDAnalysis.core.groups.AtomGroup` or a
:class:`~MDAnalysis.core.universe.Universe` returns a
:class:`~MDAnalysis.core.groups.AtomGroup`, so you can use all the methods
defined for AtomGroups on them. Selections always return an
:class:`~MDAnalysis.core.groups.AtomGroup` with atoms sorted according to their
index in the topology (this is to ensure that there are not any duplicates,
which can happen with complicated selections).

One can group subselections using parentheses::

 >>> universe.select_atoms("segid DMPC and not (name H* or type OW)")
 <AtomGroup with 3420 atoms>

Almost all the basic CHARMM selections work.

It is also possible to export selections for external software
packages with the help of :ref:`Selection exporters`.

.. note::

    By default, atoms are sorted by index in the output AtomGroup.
    For example, the below code will return the first, second, and
    sixth atom in ``ag``::

        >>> ag = u.select_atoms("name N")
        >>> ag2 = ag[[5, 1, 0]]
        >>> ag3 = ag2.select_atoms("name N")
        >>> np.all(ag3.ix == ag2.ix)
        False

    You can turn off sorting behavior with the ``sorted`` keyword::

        >>> ag = u.select_atoms("name N")
        >>> ag2 = ag[[5, 1, 0]]
        >>> ag3 = ag2.select_atoms("name N", sorted=False)
        >>> np.all(ag3.ix == ag2.ix)
        True


Selection Keywords
==================

The following describes all selection keywords currently understood by the
selection parser. The following applies to all selections:

* Keywords are case sensitive.
* Atoms are automatically sequentially ordered in a resulting selection (see
  notes below on :ref:`ordered-selections-label` for how to circumvent this if
  necessary).
* Selections are parsed left to right and parentheses can be used for
  grouping.
* You can use the singular name of any topology attribute as a selection
  keyword. `Defined topology attributes`_ are listed in the User Guide.
  Alternatively, you can define a 
  :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` yourself,
  providing that the attribute ``dtype`` is one of ``int``, ``float``, 
  ``str`` (or ``object``), or ``bool``.
  However, the topology must contain this attribute information for
  the selection to work.

    * Selections of attributes that are integers or floats can use the
      syntax "myTopologyAttr 0 - 2", "myTopologyAttr 0:2", or
      "myTopologyAttr 0 to 2", to select a range with
      both ends inclusive. Whitespace and negative numbers are allowed.
    * "myTopologyAttr 0" can be used to select all atoms
      matching the value; however, this can be tricky with floats because of
      precision differences and we recommend using a range like above when
      possible.
    * Boolean selections default to True, so "myTopologyAttr" and
      "myTopologyAttr True" both give all atoms with
      ``myTopologyAttr == True``.

.. seealso::

    Regular expression patterns
    :data:`~MDAnalysis.core.selection.FLOAT_PATTERN` for matching floats;
    :data:`~MDAnalysis.core.selection.INT_PATTERN` for matching integers;
    and :data:`~MDAnalysis.core.selection.RANGE_PATTERN` for matching
    selection ranges.


.. _`Defined topology attributes`: https://userguide.mdanalysis.org/2.0.0-dev0/topology_system.html#format-specific-attributes


Simple selections
-----------------

This is a non-exhaustive list of the available selection keywords. As noted
in the dot point above, keywords will be automatically generated for any
suitable :class:`~MDAnalysis.core.topologyattrs.TopologyAttr`. A list of
`Defined topology attributes`_ is available in the User Guide.

protein, backbone, nucleic, nucleicbackbone
    selects all atoms that belong to a standard set of residues; a protein
    is identfied by a hard-coded set of residue names so it  may not
    work for esoteric residues.

segid *seg-name*
    select by segid (as given in the topology), e.g. ``segid 4AKE`` or
    ``segid DMPC``

resid *residue-number-range*
    resid can take a single residue number or a range of numbers. A range
    consists of two numbers separated by a colon (inclusive) such
    as ``resid 1:5``. A residue number ("resid") is taken directly from the
    topology.

resnum *resnum-number-range*
    resnum is the canonical residue number; typically it is set to the
    residue id in the original PDB structure.

resname *residue-name*
    select by residue name, e.g. ``resname LYS``

name *atom-name*
    select by atom name (as given in the topology). Often, this is force
    field dependent. Example: ``name CA`` (for C&alpha; atoms) or ``name
    OW`` (for SPC water oxygen)

type *atom-type*
    select by atom type; this is either a string or a number and depends on
    the force field; it is read from the topology file (e.g. the CHARMM PSF
    file contains numeric atom types). It has non-sensical values when a
    PDB or GRO file is used as a topology.

atom *seg-name*  *residue-number*  *atom-name*
    a selector for a single atom consisting of segid resid atomname,
    e.g. ``DMPC 1 C2`` selects the C2 carbon of the first residue of the
    DMPC segment

altLoc *alternative-location*
    a selection for atoms where alternative locations are available, which is
    often the case with high-resolution crystal structures
    e.g. ``resid 4 and resname ALA and altLoc B`` selects only the atoms of ALA-4
    that have an altLoc B record.

chainID *chain-name*
    a selection for atoms where chainIDs have been defined.

element *element-name*
    a selection for atoms where elements have been defined. e.g. ``element H C``

moltype *molecule-type*
    select by molecule type, e.g. ``moltype Protein_A``. At the moment, only
    the TPR format defines the molecule type.

smarts *SMARTS-query*
    select atoms using Daylight's SMARTS queries, e.g. ``smarts [#7;R]`` to
    find nitrogen atoms in rings. Requires RDKit. All matches (max 1000) are
    combined as a unique match.

chiral *R | S*
    select a particular stereocenter. e.g. ``name C and chirality S``
    to select only S-chiral carbon atoms.  Only ``R`` and ``S`` will be
    possible options but other values will not raise an error.

Pattern matching
----------------

The pattern matching notation described below is used to specify 
patterns for matching strings (based on :mod:`fnmatch`):

``?`` 
    Is a pattern that will match any single character. For example,
    ``resname T?R`` selects residues named "TYR" and "THR".
``*`` 
    Is a pattern that will match multiple characters.  For example,
    ``GL*`` selects all strings that start with "GL" such as "GLU",
    "GLY", "GLX29", "GLN".
``[seq]``
    Would match any character in seq. For example, "resname GL[NY]" 
    selects all residues named "GLN" or "GLY" but would not select
    "GLU".
``[!seq]``
    Would match any character not in seq. For example, "resname GL[!NY]"
    would match residues named "GLU" but would not match "GLN" or "GLY".

Boolean
-------

not
    all atoms not in the selection, e.g. ``not protein`` selects all atoms
    that aren't part of a protein

and, or
    combine two selections according to the rules of boolean algebra,
    e.g. ``protein and not (resname ALA or resname LYS)`` selects all atoms
    that belong to a protein, but are not in a lysine or alanine residue

Geometric
---------

around *distance*  *selection*
    selects all atoms a certain cutoff away from another selection,
    e.g. ``around 3.5 protein`` selects all atoms not belonging to protein
    that are within 3.5 Angstroms from the protein

sphlayer *innerRadius* *externalRadius* *selection*
    selects all atoms within a spherical layer centered in the center of
    geometry (COG) of a given selection, e.g., ``sphlayer 2.4 6.0 ( protein
    and ( resid 130 or resid 80 ) )`` selects the center of geometry of
    protein, resid 130, resid 80 and creates a spherical layer of inner
    radius 2.4 and external radius 6.0 around the COG.

sphzone *externalRadius* *selection*
    selects all atoms within a spherical zone centered in the center of
    geometry (COG) of a given selection, e.g. ``sphzone 6.0 ( protein and (
    resid 130 or resid 80 ) )`` selects the center of geometry of protein,
    resid 130, resid 80 and creates a sphere of radius 6.0 around the COG.

cylayer *innerRadius* *externalRadius* *zMax* *zMin* *selection*
    selects all atoms within a cylindric layer centered in the center of
    geometry (COG) of a given selection, e.g. ``cylayer 5 10 10 -8
    protein`` selects the center of geometry of protein, and creates a
    cylindrical layer of inner radius 5, external radius 10 centered on the
    COG. In z, the cylinder extends from 10 above the COG to 8
    below. Positive values for *zMin*, or negative ones for *zMax*, are
    allowed.

cyzone *externalRadius* *zMax* *zMin* *selection*
    selects all atoms within a cylindric zone centered in the center of
    geometry (COG) of a given selection, e.g. ``cyzone 15 4 -8 protein and
    resid 42`` selects the center of geometry of protein and resid 42, and
    creates a cylinder of external radius 15 centered on the COG. In z, the
    cylinder extends from 4 above the COG to 8 below. Positive values for
    *zMin*, or negative ones for *zMax*, are allowed.

    .. versionchanged:: 0.10.0
       keywords *cyzone* and *cylayer* now take *zMax* and *zMin* to be
       relative to the COG of *selection*, instead of absolute z-values
       in the box.

point *x* *y* *z*  *distance*
    selects all atoms within a cutoff of a point in space, make sure
    coordinate is separated by spaces, e.g. ``point 5.0 5.0 5.0 3.5``
    selects all atoms within 3.5 Angstroms of the coordinate (5.0, 5.0,
    5.0)

prop [abs] *property*  *operator*  *value*
    selects atoms based on position, using *property* **x**, **y**, or
    **z** coordinate. Supports the **abs** keyword (for absolute value) and
    the following *operators*: **<, >, <=, >=, ==, !=**. For example,
    ``prop z >= 5.0`` selects all atoms with z coordinate greater than 5.0;
    ``prop abs z <= 5.0`` selects all atoms within -5.0 <= z <= 5.0.


.. note::
   By default periodicity **is** taken into account with geometric
   selections, i.e. selections will find atoms that are in different
   periodic images.
   To control this behaviour, use the boolean ``"periodic"`` keyword
   argument of :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms`.


Similarity and connectivity
---------------------------

same *subkeyword* as *selection*
    selects all atoms that have the same *subkeyword* value as any atom in
    *selection*. Allowed *subkeyword* values are the atom properties: ``name,
    type, resname, resid, segid, mass, charge, radius, bfactor, resnum``, the
    groups an atom belong to: ``residue, segment, fragment``, and the atom
    coordinates ``x, y, z``.

byres *selection*
    selects all atoms that are in the same segment and residue as selection,
    e.g. specify the subselection after the byres keyword.  ``byres`` is a
    shortcut to ``same residue as``

bonded *selection*
    selects all atoms that are bonded to selection
    eg: ``select name H and bonded name O`` selects only hydrogens bonded to
    oxygens

Index
-----

bynum *index-range*
    selects all atoms within a range of (1-based) inclusive indices,
    e.g. ``bynum 1`` selects the first atom in the universe; ``bynum 5:10``
    selects atoms 5 through 10 inclusive. All atoms in the
    :class:`MDAnalysis.Universe` are consecutively numbered, and the index
    runs from 1 up to the total number of atoms.

index *index-range*
    selects all atoms within a range of (0-based) inclusive indices,
    e.g. ``index 0`` selects the first atom in the universe; ``index 5:10``
    selects atoms 6 through 11 inclusive. All atoms in the
    :class:`MDAnalysis.Universe` are consecutively numbered, and the index
    runs from 0 up to the total number of atoms - 1.

.. _pre-selections-label:

Preexisting selections and modifiers
------------------------------------

group `group-name`
    selects the atoms in the :class:`AtomGroup` passed to the function as an
    argument named `group-name`. Only the atoms common to `group-name` and the
    instance :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` was called
    from will be considered, unless ``group`` is preceded by the ``global``
    keyword. `group-name` will be included in the parsing just by comparison of
    atom indices. This means that it is up to the user to make sure the
    `group-name` group was defined in an appropriate :class:`Universe`.

global *selection*
    by default, when issuing
    :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from an
    :class:`~MDAnalysis.core.groups.AtomGroup`, selections and subselections
    are returned intersected with the atoms of that instance.  Prefixing a
    selection term with ``global`` causes its selection to be returned in its
    entirety.  As an example, the ``global`` keyword allows for
    ``lipids.select_atoms("around 10 global protein")`` --- where ``lipids`` is
    a group that does not contain any proteins. Were ``global`` absent, the
    result would be an empty selection since the ``protein`` subselection would
    itself be empty.  When issuing
    :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from a
    :class:`~MDAnalysis.core.universe.Universe`, ``global`` is ignored.

.. versionchanged:: 1.0.0
   The ``fullgroup`` selection has now been removed. Please use the equivalent
   ``global group`` selection.

Dynamic selections
==================

By default :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` returns an
:class:`~MDAnalysis.core.groups.AtomGroup`, in which the list of atoms is
constant across trajectory frame changes. If
:meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` is invoked with named
argument ``updating`` set to ``True``, an
:class:`~MDAnalysis.core.groups.UpdatingAtomGroup` instance will be returned
instead. It behaves just like an :class:`~MDAnalysis.core.groups.AtomGroup`
object, with the difference that the selection expressions are re-evaluated
every time the trajectory frame changes (this happens lazily, only when the
:class:`~MDAnalysis.core.groups.UpdatingAtomGroup` object is accessed so that
there is no redundant updating going on)::

 # A dynamic selection of corner atoms:
 >>> ag_updating = universe.select_atoms("prop x < 5 and prop y < 5 and prop z < 5", updating=True)
 >>> ag_updating
 <UpdatingAtomGroup with 9 atoms>
 >>> universe.trajectory.next()
 >>> ag_updating
 <UpdatingAtomGroup with 14 atoms>

Using the ``group`` selection keyword for
:ref:`preexisting-selections <pre-selections-label>`, one can
make updating selections depend on
:class:`~MDAnalysis.core.groups.AtomGroup`, or even other
:class:`~MDAnalysis.core.groups.UpdatingAtomGroup`, instances.
Likewise, making an updating selection from an already updating group will
cause later updates to also reflect the updating of the base group::

 >>> chained_ag_updating = ag_updating.select_atoms("resid 1:1000", updating=True)
 >>> chained_ag_updating
 <UpdatingAtomGroup with 3 atoms>
 >>> universe.trajectory.next()
 >>> chained_ag_updating
 <UpdatingAtomGroup with 7 atoms>

Finally, a non-updating selection or a slicing/addition operation made on an
:class:`~MDAnalysis.core.groups.UpdatingAtomGroup` will return a static
:class:`~MDAnalysis.core.groups.AtomGroup`, which will no longer update
across frames::

 >>> static_ag = ag_updating.select_atoms("resid 1:1000")
 >>> static_ag
 <UpdatingAtomGroup with 3 atoms>
 >>> universe.trajectory.next()
 >>> static_ag
 <UpdatingAtomGroup with 3 atoms>

.. _ordered-selections-label:

Ordered selections
==================

:meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` sorts the atoms
in the :class:`~MDAnalysis.core.groups.AtomGroup` by atom index before
returning them (this is to eliminate possible duplicates in the
selection). If the ordering of atoms is crucial (for instance when
describing angles or dihedrals) or if duplicate atoms are required
then one has to concatenate multiple AtomGroups, which does not sort
them.

The most straightforward way to concatentate two AtomGroups is by using the
``+`` operator::

 >>> ordered = u.select_atoms("segid DMPC and resid 3 and name P") + u.select_atoms("segid DMPC and resid 2 and name P")
 >>> print list(ordered)
 [< Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'>,
 < Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'>]

A shortcut is to provide *two or more* selections to
:meth:`~MDAnalysis.core.universe.Universe.select_atoms`, which then
does the concatenation automatically::

 >>> print list(universe.select_atoms("segid DMPC and resid 3 and name P", "segid DMPC and resid 2 and name P"))
 [< Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'>,
 < Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'>]

Just for comparison to show that a single selection string does not
work as one might expect::

 # WRONG!
 >>> print list(universe.select_atoms("segid DMPC and ( resid 3 or resid 2 ) and name P"))
 [< Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'>,
 < Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'>]
.. Contains the formatted docstrings from the coordinates modules located in 'mdanalysis/MDAnalysis/coordinates'
.. _Coordinates:

**************************
Coordinates modules
**************************

The coordinates module contains the classes to read and write
trajectories. Typically, MDAnalysis recognizes :ref:`Supported coordinate
formats` by the file extension and hence most users probably do not need to
concern themselves with classes and functions described here. However,
if MDAnalysis fails to recognize a coordinate file then the user can
provide the format in the keyword argument *format* to
:class:`~MDAnalysis.core.universe.Universe` to force the format.

.. rubric:: Coordinate formats

.. toctree::
   :maxdepth: 1

   coordinates/init
   coordinates/CRD
   coordinates/DCD
   coordinates/DLPoly
   coordinates/DMS
   coordinates/GMS
   coordinates/GSD
   coordinates/GRO
   coordinates/H5MD
   coordinates/INPCRD
   coordinates/LAMMPS
   coordinates/MMTF
   coordinates/MOL2
   coordinates/NAMDBIN
   coordinates/PDB
   coordinates/PDBQT
   coordinates/PQR
   coordinates/TRJ
   coordinates/TRR
   coordinates/TRZ
   coordinates/TXYZ
   coordinates/XTC
   coordinates/XYZ
   coordinates/FHIAIMS
   coordinates/memory
   coordinates/chemfiles
   coordinates/null

.. rubric:: Coordinate core modules

The remaining pages are primarily of interest to
developers. Programmers and anyone trying to implement new
functionality should first read the :ref:`Trajectory API`.


.. toctree::
   :maxdepth: 1

   coordinates/base
   coordinates/core
   coordinates/pickle_readers
   coordinates/chain
   coordinates/XDR

In particular, all trajectory readers have to be 
:ref:`serializable<serialization>` and they should pass all tests
available in the ``MDAnalysisTests.coordinates.base.MultiframeReaderTest`` 
or ``MDAnalysisTests.coordinates.base.BaseReaderTest``.
.. -*- coding: utf-8 -*-
.. note: make sure that no lines accidentaly start with a single character
..       followed by a period: reST interprets it as an enumerated list and
..       messes up the formatting

.. The references are accessible globally; you can cite these papers anywhere
.. in the docs.

.. _references:

************
 References
************

MDAnalysis and the included algorithms are scientific software that
are described in academic publications. **Please cite these papers when you use
MDAnalysis in published work.**

It is possible to :ref:`automatically generate a list of references
<citations-using-duecredit>` for any program that uses
MDAnalysis. This list (in common reference manager formats) contains
the citations associated with the specific algorithms and libraries
that were used in the program.


Citations for the whole MDAnalysis library
==========================================

When using MDAnalysis in published work, please cite
[Michaud-Agrawal2011]_ and [Gowers2016]_.

(We are currently asking you to cite *both* papers if at all possible
because the 2016 paper describes many updates to the original 2011
paper and neither paper on its own provides a comprehensive
description of the library. We will publish a complete self-contained
paper with the upcoming 1.0 release of MDAnalysis, which will then
supersede these two citations.)


.. [Michaud-Agrawal2011] N. Michaud-Agrawal, E. J. Denning, T. B. Woolf,
   and O. Beckstein. MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics
   Simulations. *J. Comput. Chem.* **32** (2011),
   2319–2327. doi:`10.1002/jcc.21787`_

.. [Gowers2016] R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N.
   Melo, S. L. Seyler, D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney,
   and O. Beckstein. `MDAnalysis: A Python package for the rapid analysis of
   molecular dynamics simulations`_. In S. Benthall and S. Rostrup, editors,
   *Proceedings of the 15th Python in Science Conference*, pages 98-105,
   Austin, TX, 2016. SciPy. doi:`10.25080/Majora-629e541a-00e`_

.. _`10.1002/jcc.21787`: http://dx.doi.org/10.1002/jcc.21787
.. _`10.25080/Majora-629e541a-00e`:
   https://doi.org/10.25080/Majora-629e541a-00e

.. _`MDAnalysis: A Python package for the rapid analysis of molecular
   dynamics simulations`:
   http://conference.scipy.org/proceedings/scipy2016/oliver_beckstein.html


.. _references-components:

Citations for included algorithms and modules
=============================================

If you use the RMSD calculation (:mod:`MDAnalysis.analysis.rms`) or alignment
code (:mod:`MDAnalysis.analysis.align`) that uses the
:mod:`~MDAnalysis.core.qcprot` module please also cite [Theobald2005b]_ and
[Liu2010b]_.

.. [Theobald2005b] Douglas L. Theobald. Rapid calculation of RMSD using a
   quaternion-based characteristic polynomial. *Acta Crystallographica A*
   **61** (2005), 478-480.

.. [Liu2010b] Pu Liu, Dmitris K. Agrafiotis, and Douglas L. Theobald. Fast
   determination of the optimal rotational matrix for macromolecular
   superpositions. *J. Comput. Chem.* **31** (2010), 1561–1563.

If you use the helix analysis algorithm HELANAL_ in
:mod:`MDAnalysis.analysis.helanal` please cite [Bansal2000b]_.

.. [Bansal2000b] Bansal M, Kumar S, Velavan R. HELANAL — A program to
   characterise helix geometry in proteins. *J. Biomol. Struct. Dyn.* **17**
   (2000), 811–819

.. _HELANAL: http://www.ccrnp.ncifcrf.gov/users/kumarsan/HELANAL/helanal.html

If you use the GNM trajectory analysis code in
:mod:`MDAnalysis.analysis.gnm` please cite [Hall2007b]_.

.. [Hall2007b] Benjamin A. Hall, Samantha L. Kaye, Andy Pang, Rafael Perera, and
   Philip C. Biggin. Characterization of Protein Conformational States by
   Normal-Mode Frequencies. *JACS* **129** (2007), 11394–11401.

If you use the water analysis code in
:mod:`MDAnalysis.analysis.waterdynamics` please cite [Araya-Secchi2014b]_.

.. [Araya-Secchi2014b] R. Araya-Secchi., Tomas Perez-Acle, Seung-gu Kang, Tien
   Huynh, Alejandro Bernardin, Yerko Escalona, Jose-Antonio Garate,
   Agustin D. Martinez, Isaac E. Garcia, Juan C. Saez, Ruhong
   Zhou. Characterization of a novel water pocket inside the human Cx26
   hemichannel structure. *Biophysical Journal*, **107** (2014), 599-612.

If you use the Path Similarity Analysis (PSA) code in
:mod:`MDAnalysis.analysis.psa` please cite [Seyler2015b]_.

.. [Seyler2015b] Seyler SL, Kumar A, Thorpe MF, Beckstein O. Path Similarity
  Analysis: A Method for Quantifying Macromolecular Pathways. *PLoS
  Comput Biol* **11** (2015), e1004568. doi: `10.1371/journal.pcbi.1004568`_

.. _`10.1371/journal.pcbi.1004568`: http://doi.org/10.1371/journal.pcbi.1004568

If you use the implementation of the ENCORE ensemble analysis in
:mod:`MDAnalysis.analysis.encore` please cite [Tiberti2015b]_.

.. [Tiberti2015b] M. Tiberti, E. Papaleo, T. Bengtsen, W. Boomsma,
   and K. Lindorff-Larsen. ENCORE: Software for quantitative ensemble
   comparison. *PLoS Comput Biol*, **11** (2015), e1004415.  doi:
   `10.1371/journal.pcbi.1004415`_

.. _`10.1371/journal.pcbi.1004415`: http://doi.org/10.1371/journal.pcbi.1004415

If you use the streamline visualization in
:mod:`MDAnalysis.visualization.streamlines` and
:mod:`MDAnalysis.visualization.streamlines_3D` please cite [Chavent2014b]_.

.. [Chavent2014b] Chavent, M., Reddy, T., Dahl, C.E., Goose, J., Jobard, B.,
   and Sansom, M.S.P. Methodologies for the analysis of instantaneous lipid
   diffusion in MD simulations of large membrane systems.  *Faraday
   Discussions* **169** (2014), 455–475. doi: `10.1039/c3fd00145h`_

.. _`10.1039/c3fd00145h`: https://doi.org/10.1039/c3fd00145h

If you use the hydrogen bond analysis code in
:mod:`MDAnalysis.analysis.hydrogenbonds.hbond_analysis` please cite [Smith2019]_.

.. [Smith2019] P. Smith, R. M. Ziolek, E. Gazzarrini, D. M. Owen, and C. D. Lorenz.
   On the interaction of hyaluronic acid with synovial fluid lipid membranes. *PCCP*
   **21** (2019), 9845-9857. doi:  `10.1039/C9CP01532A`_

.. _`10.1039/C9CP01532A`: http://dx.doi.org/10.1039/C9CP01532A

If you use :meth:`~MDAnalysis.analysis.pca.PCA.rmsip` or
:func:`~MDAnalysis.analysis.pca.rmsip` please cite [Amadei1999]_ and
[Leo-Macias2004]_ .

.. [Amadei1999] Amadei, A., Ceruso, M. A. & Nola, A. D.
   On the convergence of the conformational coordinates basis set obtained by the essential dynamics analysis of proteins’ molecular dynamics simulations.
   *Proteins: Structure, Function, and Bioinformatics* **36**, 419–424 (1999).
   doi: `10.1002/(SICI)1097-0134(19990901)36:4<419::AID-PROT5>3.0.CO;2-U`_

.. _`10.1002/(SICI)1097-0134(19990901)36:4<419::AID-PROT5>3.0.CO;2-U`: https://doi.org/10.1002/(SICI)1097-0134(19990901)36:4%3C419::AID-PROT5%3E3.0.CO;2-U

.. [Leo-Macias2004] Leo-Macias, A., Lopez-Romero, P., Lupyan, D., Zerbino, D. & Ortiz, A. R.
   An Analysis of Core Deformations in Protein Superfamilies.
   *Biophys J* **88**, 1291–1299 (2005). doi: `10.1529/biophysj.104.052449`_

.. _`10.1529/biophysj.104.052449`: https://dx.doi.org/10.1529%2Fbiophysj.104.052449

If you use :meth:`~MDAnalysis.analysis.pca.PCA.cumulative_overlap` or
:func:`~MDAnalysis.analysis.pca.cumulative_overlap` please cite [Yang2008]_ .

.. [Yang2008] Yang, L., Song, G., Carriquiry, A. & Jernigan, R. L.
   Close Correspondence between the Motions from Principal Component Analysis of Multiple HIV-1 Protease Structures and Elastic Network Modes.
   *Structure* **16**, 321–330 (2008). doi: `10.1016/j.str.2007.12.011`_

.. _`10.1016/j.str.2007.12.011`: https://dx.doi.org/10.1016/j.str.2007.12.011

If you use the Mean Squared Displacement analysis code in
:mod:`MDAnalysis.analysis.msd` please cite [Calandri2011]_ and [Buyl2018]_.

.. [Calandri2011] Calandrini, V., Pellegrini, E., Calligari, P., Hinsen, K., Kneller, G. R.
   NMoldyn-Interfacing Spectroscopic Experiments, Molecular Dynamics Simulations and Models for Time Correlation Functions.
   *Collect. SFN*, **12**, 201–232 (2011). doi: `10.1051/sfn/201112010`_

.. _`10.1051/sfn/201112010`: https://doi.org/10.1051/sfn/201112010

.. [Buyl2018] Buyl, P. tidynamics: A tiny package to compute the dynamics of stochastic and molecular simulations. Journal of Open Source Software,
   3(28), 877 (2018). doi: `10.21105/joss.00877`_

.. _`10.21105/joss.00877`: https://doi.org/10.21105/joss.00877

If you calculate shape parameters using
:meth:`~MDAnalysis.core.group.AtomGroup.shape_parameter`,
:meth:`~MDAnalysis.core.group.ResidueGroup.shape_parameter`,
:meth:`~MDAnalysis.core.group.SegmentGroup.shape_parameter`
please cite [Dima2004a]_.

.. [Dima2004a] Dima, R. I., & Thirumalai, D. (2004). Asymmetry
   in the shapes of folded and denatured states of
   proteins. *J Phys Chem B*, 108(21),
   6564-6570. doi:`10.1021/jp037128y
   <https://doi.org/10.1021/jp037128y>`_

If you calculate asphericities using
:meth:`~MDAnalysis.core.group.AtomGroup.asphericity`,
:meth:`~MDAnalysis.core.group.ResidueGroup.asphericity`,
:meth:`~MDAnalysis.core.group.SegmentGroup.asphericity`
please cite [Dima2004b]_.

.. [Dima2004b] Dima, R. I., & Thirumalai, D. (2004). Asymmetry
   in the shapes of folded and denatured states of
   proteins. *J Phys Chem B*, 108(21),
   6564-6570. doi:`10.1021/jp037128y
   <https://doi.org/10.1021/jp037128y>`_

If you use H5MD files using
:mod:`MDAnalysis.coordinates.H5MD.py`, please cite [Buyl2013]_ and
[Jakupovic2021]_.

.. [Buyl2013] Buyl P., Colberg P., and Höfling F.(2013).
   H5MD: A structured, efficient, and portable file format for molecular data.
   *Computer Physics Communications*, 185. doi:`10.1016/j.cpc.2014.01.018.
   <https://doi.org/10.1016/j.cpc.2014.01.018>`_

.. [Jakupovic2021] Jakupovic E. and Beckstein O., MPI-parallel Molecular
   Dynamics Trajectory Analysis with the H5MD Format in the MDAnalysis
   Python Package, in *Proceedings of the 20th Python in Science Conference*,
   (Meghann Agarwal, Chris Calloway, Dillon Niederhut, and David Shupe, eds.),
   pp. 18 – 26, 2021. doi:`10.25080/majora-1b6fd038-005.
   <https://www.doi.org/10.25080/majora-1b6fd038-005>`_


.. _citations-using-duecredit:


Citations using Duecredit
=========================

Citations can be automatically generated using duecredit_, depending on the
packages used. Duecredit is easy to install via ``pip``. Simply type:

.. code-block:: bash

   pip install duecredit

duecredit_ will remain an optional dependency, i.e. any code using
MDAnalysis will work correctly even without duecredit installed.

A list of citations for ``yourscript.py`` can be obtained using simple
commands.

.. code-block:: bash

   cd /path/to/yourmodule
   python -m duecredit yourscript.py

or set the environment variable :envvar:`DUECREDIT_ENABLE`

.. code-block:: bash

   DUECREDIT-ENABLE=yes python yourscript.py

Once the citations have been extracted (to a hidden file in the
current directory), you can use the :program:`duecredit` program to
export them to different formats. For example, one can display them in
BibTeX format, using:

.. code-block:: bash

   duecredit summary --format=bibtex


**Please cite your use of MDAnalysis and the packages and algorithms
that it uses. Thanks!**


.. _duecredit: https://github.com/duecredit/duecredit
.. automodule:: MDAnalysis.version
.. automodule:: MDAnalysis.transformations.boxdimensions
.. automodule:: MDAnalysis.transformations.translate.. automodule:: MDAnalysis.transformations.rotate.. automodule:: MDAnalysis.transformations.positionaveraging
.. automodule:: MDAnalysis.transformations.fit.. automodule:: MDAnalysis.transformations.base
.. automodule:: MDAnalysis.transformations.wrap.. automodule:: MDAnalysis.auxiliary.XVG

.. automodule:: MDAnalysis.auxiliary.core

.. automodule:: MDAnalysis.auxiliary.__init__

.. automodule:: MDAnalysis.auxiliary.base

.. automodule:: MDAnalysis.visualization.streamlines
.. automodule:: MDAnalysis.visualization.streamlines_3D
    
.. automodule:: MDAnalysis.lib.pkdtree
   :members:
.. automodule:: MDAnalysis.lib.util

.. automodule:: MDAnalysis.lib.c_distances_openmp
   :members:
.. automodule:: MDAnalysis.lib.NeighborSearch
   :members:
.. automodule:: MDAnalysis.lib.mdamath
.. automodule:: MDAnalysis.lib.c_distances
   :members:
.. automodule:: MDAnalysis.lib.qcprot

.. automodule:: MDAnalysis.lib.picklable_file_io
.. automodule:: MDAnalysis.lib.log
   :members:
.. automodule:: MDAnalysis.lib.nsgrid
   :members:.. automodule:: MDAnalysis.lib.distances



Low-level modules for :mod:`MDAnalysis.lib.distances`
=====================================================

:mod:`MDAnalysis.lib._distances` contains low level access to the
*serial* MDAnalysis Cython functions in `distances`.  These have
little to no error checking done on inputs so should be used with
caution. Similarly, :mod:`MDAnalysis.lib._distances_openmp` contains
the OpenMP-enable functions.

.. toctree::
   :maxdepth: 1

   c_distances
   c_distances_openmp
.. automodule:: MDAnalysis.lib.transformations
   :members:
.. automodule:: MDAnalysis.lib.correlations

	Autocorrelation Function
	------------------------
	.. autofunction:: MDAnalysis.lib.correlations.autocorrelation

	Intermittency Function
	----------------------
	.. autofunction:: MDAnalysis.lib.correlations.correct_intermittency.. automodule:: MDAnalysis.lib.formats.libdcd
   :members:
   :inherited-members:
.. automodule:: MDAnalysis.lib.formats.libmdaxdr
   :members:
   :inherited-members:
.. automodule:: MDAnalysis.coordinates.memory
.. automodule:: MDAnalysis.coordinates.DLPoly
   :members:
.. automodule:: MDAnalysis.coordinates.GMS

.. automodule:: MDAnalysis.coordinates.DMS
   :members:
.. automodule:: MDAnalysis.coordinates.TXYZ

.. automodule:: MDAnalysis.coordinates.CRD
   :members:
.. automodule:: MDAnalysis.coordinates.TRR
   :members:
   :inherited-members:
.. automodule:: MDAnalysis.coordinates.chemfiles
.. automodule:: MDAnalysis.coordinates.XDR
   :members:
   :inherited-members:
.. automodule:: MDAnalysis.coordinates.PDB

.. automodule:: MDAnalysis.coordinates.GSD
.. automodule:: MDAnalysis.coordinates.XTC
   :members:
   :inherited-members:
.. automodule:: MDAnalysis.coordinates.NAMDBIN
.. automodule:: MDAnalysis.coordinates.GRO

.. automodule:: MDAnalysis.coordinates.MMTF

.. automodule:: MDAnalysis.coordinates.null
.. automodule:: MDAnalysis.coordinates.PQR
   :members:
.. automodule:: MDAnalysis.coordinates.DCD
.. automodule:: MDAnalysis.coordinates.FHIAIMS

.. automodule:: MDAnalysis.coordinates.H5MD
.. automodule:: MDAnalysis.coordinates.PDBQT
   :members:
.. automodule:: MDAnalysis.coordinates.core
   
.. automodule:: MDAnalysis.coordinates.chain
   
.. automodule:: MDAnalysis.coordinates.__init__

.. automodule:: MDAnalysis.coordinates.INPCRD
.. automodule:: MDAnalysis.coordinates.base
   
.. Contains the formatted docstrings for the serialization of universe located
.. mainly in 'MDAnalysis/libs/pickle_file_io.py'
.. _serialization:

*********************************************************
Serialization of Coordinate Readers
*********************************************************

To achieve a working implementation of parallelism, this document illustrates
the basic idea of how different coordinate readers are being serialized in MDAnalysis,
and what developers should do to serialize a new reader.

To make sure every Trajectory reader can be successfully
serialized, we implement picklable I/O classes (see :ref:`implemented-fileio`).
When the file is pickled, filename and other necessary attributes of the open
file handle are saved. On unpickling, the file is opened by filename.
This means that for a successful unpickle, the original file still has to
be accessible with its filename. To retain the current frame of the trajectory,
:func:`_read_frame(previous frame)` will be called during unpickling.

.. _how_to_serialize_a_new_reader:

How to serialize a new reader
-----------------------------

File Access
^^^^^^^^^^^
If the new reader uses :func:`util.anyopen()`
(e.g. :class:`MDAnalysis.coordinates.PDB.PDBReader`),
the reading handler can be pickled without modification.
If the new reader uses I/O classes from other package
(e.g. :class:`MDAnalysis.coordinates.GSD.GSDReader`),
and cannot be pickled natively, create a new picklable class inherited from
the file class in that package
(e.g. :class:`MDAnalysis.coordinates.GSD.GSDPicklable`),
adding :func:`__getstate__`,
:func:`__setstate__` functions (or :func:`__reduce__` if needed. Consult the
pickle `documentation <https://docs.python.org/3/library/pickle.html>`_ of python)
to allow file handler serialization.

To seek or not to seek
^^^^^^^^^^^^^^^^^^^^^^
Some I/O classes support :func:`seek` and :func:`tell` functions to allow the file
to be pickled with an offset. It is normally not needed for MDAnalysis with
random access. But if error occurs during testing, find a way to make the offset work.
Maybe this I/O class supports frame indexing? Maybe the file handler inside this I/O
class supports offset?

For example, in :class:`MDAnalysis.coordinates.TRZ.TRZReader`,
:func:`_read_frame` is implemented by :func:`_seek` ing the file into
its previous frame and :func:`_read_next_timestep`, so the offset of the file is crucial
for such machinery to work.

Miscellaneous
^^^^^^^^^^^^^
If pickle still fails due to some unpicklable attributes, try to find a way
to pickle those, or write custom :func:`__getstate__` and :func:`__setstate__`
methods for the reader.

If the new reader is written in Cython, read :class:`lib.formats.libmdaxdr` and
:class:`lib.formats.libdcd` files as references.

.. _test_pickle:

Tests
-----
_SingleFrameReader Test
^^^^^^^^^^^^^^^^^^^^^^^
If the new reader is a single-frame reader, the basic test should normally
inherited from :class:`_SingleFrameReader`, where the pickliablity is tested.

BaseReaderTest and MultiframeReaderTest
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
If the test for the new reader uses :class:`BaseReaderTest` or
:class:`MultiframeReaderTest`, whether the current timestep information is
saved (the former), whether its relative position is maintained,
i.e. next() reads the right next timestep, and whether its last timestep
can be pickled, are already tested.

File handler Test
^^^^^^^^^^^^^^^^^
If the new reader accesses the file with :func:`util.anyopen`, add necessary
tests inside ``parallelism/test_multiprocessing.py`` for the reader.

If the new reader accessed the file with a new picklable I/O class,
add necessary tests inside ``utils/test_pickleio.py`` for the I/O class,
``parallelism/test_multiprocessing.py`` for the reader.

.. _implemented-fileio:

Currently implemented picklable IO Formats
------------------------------------------

* :class:`MDAnalysis.lib.picklable_file_io.FileIOPicklable`
* :class:`MDAnalysis.lib.picklable_file_io.BufferIOPicklable`
* :class:`MDAnalysis.lib.picklable_file_io.TextIOPicklable`
* :class:`MDAnalysis.lib.picklable_file_io.BZ2Picklable`
* :class:`MDAnalysis.lib.picklable_file_io.GzipPicklable`
* :class:`MDAnalysis.coordinates.GSD.GSDPicklable`
* :class:`MDAnalysis.coordinates.TRJ.NCDFPicklable`
* :class:`MDAnalysis.coordinates.chemfiles.ChemfilesPicklable`
* :class:`MDAnalysis.coordinates.H5MD.H5PYPicklable`
.. automodule:: MDAnalysis.coordinates.XYZ
   :members:
.. automodule:: MDAnalysis.coordinates.TRJ

.. automodule:: MDAnalysis.coordinates.TRZ

.. automodule:: MDAnalysis.coordinates.LAMMPS

.. automodule:: MDAnalysis.coordinates.MOL2

.. automodule:: MDAnalysis.topology.TXYZParser

.. automodule:: MDAnalysis.topology.FHIAIMSParser

.. automodule:: MDAnalysis.topology.ExtendedPDBParser
.. automodule:: MDAnalysis.topology.MMTFParser
.. automodule:: MDAnalysis.topology.GMSParser
.. automodule:: MDAnalysis.topology.GSDParser
.. automodule:: MDAnalysis.topology.PSFParser

.. automodule:: MDAnalysis.topology.PDBQTParser

.. automodule:: MDAnalysis.topology.PQRParser

.. automodule:: MDAnalysis.topology.DMSParser
.. automodule:: MDAnalysis.topology.GROParser
.. automodule:: MDAnalysis.topology.tables
.. automodule:: MDAnalysis.topology.XYZParser

===============================================
 Utility functions for the TPR topology parser
===============================================

The :mod:`MDAnalysis.topology.tpr` module contains classes and
functions on which the Gromacs TPR topology reader
:class:`~MDAnalysis.topology.TPRParser.TPRParser` is built.

.. automodule:: MDAnalysis.topology.tpr

.. automodule:: MDAnalysis.topology.tpr.setting
   :members:
   :undoc-members:

.. automodule:: MDAnalysis.topology.tpr.obj
   :members:
   :undoc-members:

.. automodule:: MDAnalysis.topology.tpr.utils
   :members:
   :undoc-members:
.. automodule:: MDAnalysis.topology.DLPolyParser
.. automodule:: MDAnalysis.topology.TOPParser

.. automodule:: MDAnalysis.topology.PDBParser

.. automodule:: MDAnalysis.topology.guessers
   :members:
.. automodule:: MDAnalysis.topology.MinimalParser
.. core.rst uses automatic listing of members at the moment; all the
.. other ones have the classes and functions explicitly listed in the
.. reST doc string.

.. automodule:: MDAnalysis.topology.core
   :members:
.. automodule:: MDAnalysis.topology.__init__
.. automodule:: MDAnalysis.topology.base

.. automodule:: MDAnalysis.topology.TPRParser

.. automodule:: MDAnalysis.topology.CRDParser
.. automodule:: MDAnalysis.topology.ITPParser
.. automodule:: MDAnalysis.topology.HoomdXMLParser
.. automodule:: MDAnalysis.topology.LAMMPSParser

.. automodule:: MDAnalysis.topology.MOL2Parser

.. automodule:: MDAnalysis.analysis.diffusionmap
.. automodule:: MDAnalysis.analysis.bat
.. automodule:: MDAnalysis.analysis.pca
===============================================================================
 ENCORE Ensemble Similarity Calculations --- :mod:`MDAnalysis.analysis.encore`
===============================================================================

:Author: Matteo Tiberti, Wouter Boomsma, Tone Bengtsen
:Year: 2015-2017
:Copyright: GNU Public License v3
:Maintainer: Matteo Tiberti <matteo.tiberti@gmail.com>, mtiberti on github

.. versionadded:: 0.16.0

The module contains implementations of similarity measures between protein
ensembles described in [Lindorff-Larsen2009a]_. The implementation and examples
are described in [Tiberti2015a]_.

The module includes facilities for handling ensembles and trajectories through
the :class:`Universe` class, performing clustering or dimensionality reduction
of the ensemble space, estimating multivariate probability distributions from
the input data, and more. ENCORE can be used to compare experimental and
simulation-derived ensembles, as well as estimate the convergence of
trajectories from time-dependent simulations.

ENCORE includes three different methods for calculations of similarity measures
between ensembles implemented in individual functions:


+ **Harmonic Ensemble Similarity** : :func:`~MDAnalysis.analysis.encore.similarity.hes`
+ **Clustering Ensemble Similarity** : :func:`~MDAnalysis.analysis.encore.similarity.ces`
+ **Dimensional Reduction Ensemble Similarity** : :func:`~MDAnalysis.analysis.encore.similarity.dres`

as well as two methods to evaluate the convergence of trajectories:

+ **Clustering based convergence evaluation** : :func:`~MDAnalysis.analysis.encore.similarity.ces_convergence`
+ **Dimensionality-reduction based convergence evaluation** : :func:`~MDAnalysis.analysis.encore.similarity.dres_convergence`


When using this module in published work please cite [Tiberti2015a]_.


Modules
-------

.. toctree::
   :maxdepth: 1

   ./encore/similarity
   ./encore/clustering
   ./encore/dimensionality_reduction
   ./encore/confdistmatrix
   ./encore/covariance
   ./encore/bootstrap
   ./encore/utils
   

References
----------

.. [Lindorff-Larsen2009a] Similarity Measures for Protein Ensembles. Lindorff-Larsen, K. Ferkinghoff-Borg, J. PLoS ONE 2008, 4, e4203.

.. [Tiberti2015a] ENCORE: Software for Quantitative Ensemble.. Comparison. Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, Kresten Lindorff- Larsen. PLoS Comput Biol. 2015, 11, e1004415
.. automodule:: MDAnalysis.analysis.leaflet
.. automodule:: MDAnalysis.analysis.msd
===================================================
 HOLE analysis --- :mod:`MDAnalysis.analysis.hole2`
===================================================

:Author: Lily Wang
:Year: 2020
:Copyright: GNU Public License v3

.. versionadded:: 1.0.0

This module provides an updated interface for the HOLE_ suite of tools [Smart1993]_
[Smart1996]_ to analyse an ion channel pore or transporter pathway [Stelzl2014]_
as a function of time or arbitrary order parameters. It replaces :mod:`MDAnalysis.analysis.hole`.

HOLE_ must be installed separately and can be obtained in binary form
from http://www.holeprogram.org/ or as source from
https://github.com/osmart/hole2. (HOLE is open source and available
under the Apache v2.0 license.)

Module
------

.. automodule:: MDAnalysis.analysis.hole2.hole
		


Utility functions and templates
-------------------------------

.. automodule:: MDAnalysis.analysis.hole2.utils
    :members:


.. automodule:: MDAnalysis.analysis.hole2.templates
    :members:
.. automodule:: MDAnalysis.analysis.data.filenames
   :members:
.. automodule:: MDAnalysis.analysis.hydrogenbonds.wbridge_analysis
.. automodule:: MDAnalysis.analysis.density

.. automodule:: MDAnalysis.analysis.gnm
============================================================
 :mod:`MDAnalysis.analysis.legacy` --- Legacy analysis code
============================================================

.. versionadded:: 0.16.0

The :mod:`MDAnalysis.analysis.legacy` package contains analysis
modules that are not or only incompletely tested and not regularly
maintained. They nevertheless still provide useful and sometimes
unique analysis capabilities and are therefore provided **as
is**. (For further discussion, see `Issue 743`_.)

.. warning::

   Code in the :mod:`~MDAnalysis.analysis.legacy` package is not
   regularly maintained. Please use it very carefully.

If you want to use modules from this package then you will have to import
them explicitly. For example, ::

   from MDAnalysis.analysis.legacy import x3dna


.. _Issue 743: https://github.com/MDAnalysis/mdanalysis/issues/743


Legacy modules
==============

.. toctree::
   :maxdepth: 1

   legacy/x3dna


.. automodule:: MDAnalysis.analysis.rms

.. automodule:: MDAnalysis.analysis.nuclinfo

.. automodule:: MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel
.. automodule:: MDAnalysis.analysis.contacts

.. automodule:: MDAnalysis.analysis.helix_analysis

.. automodule:: MDAnalysis.analysis.psa

.. automodule:: MDAnalysis.analysis.dihedrals
.. automodule:: MDAnalysis.analysis.waterdynamics

.. automodule:: MDAnalysis.analysis.lineardensity
   :members:

.. automodule:: MDAnalysis.analysis.base
   :members:


.. automodule:: MDAnalysis.analysis.distances
   :members:
.. automodule:: MDAnalysis.analysis.polymer
   :members:

.. automodule:: MDAnalysis.analysis.rdf


.. automodule:: MDAnalysis.analysis.align

.. automodule:: MDAnalysis.analysis.hydrogenbonds.hbond_analysis
.. automodule:: MDAnalysis.analysis.hbonds.hbond_autocorrel
.. automodule:: MDAnalysis.analysis.legacy.x3dna
============
 Clustering
============

.. automodule:: MDAnalysis.analysis.encore.clustering.cluster
   :members:

.. automodule:: MDAnalysis.analysis.encore.clustering.ClusterCollection
   :members:

.. automodule:: MDAnalysis.analysis.encore.clustering.ClusteringMethod
   :members:


Clustering algorithms
=====================

The following clustering algorithms are always available:

.. automodule:: MDAnalysis.analysis.encore.clustering.affinityprop
   :members:



==============================
 Utility functions for ENCORE
==============================

.. automodule:: MDAnalysis.analysis.encore.utils
   :members:

.. autofunction:: MDAnalysis.analysis.encore.cutils.PureRMSD
.. automodule:: MDAnalysis.analysis.encore.covariance
   :members:
==========================
 Dimensionality reduction
==========================

.. automodule:: MDAnalysis.analysis.encore.dimensionality_reduction.reduce_dimensionality
   :members:

.. automodule:: MDAnalysis.analysis.encore.dimensionality_reduction.DimensionalityReductionMethod
   :members:

Dimensionality reduction algorithms
===================================

The following dimensionality reduction algorithms are always natively
available:

.. automodule:: MDAnalysis.analysis.encore.dimensionality_reduction.stochasticproxembed
   :members:
.. automodule:: MDAnalysis.analysis.encore.bootstrap
   :members:
.. automodule:: MDAnalysis.analysis.encore.similarity
   :members:
.. automodule:: MDAnalysis.analysis.encore.confdistmatrix
   :members:
.. automodule:: MDAnalysis.converters.ParmEdParser

.. automodule:: MDAnalysis.converters.ParmEd
.. automodule:: MDAnalysis.converters.RDKitParser

.. automodule:: MDAnalysis.converters.RDKit
.. automodule:: MDAnalysis.converters.OpenMMParser

.. automodule:: MDAnalysis.converters.OpenMM
.. automodule:: MDAnalysis.core.topologyobjects
   :members:
.. automodule:: MDAnalysis.core.selection
   :members:
.. automodule:: MDAnalysis.core.universe
.. automodule:: MDAnalysis.core.topology
.. automodule:: MDAnalysis.core.__init__

.. automodule:: MDAnalysis.core.groups
.. automodule:: MDAnalysis.core.topologyattrs
   :members:
.. automodule:: MDAnalysis.core.accessors.. automodule:: MDAnalysis.selections.pymol

.. automodule:: MDAnalysis.selections.gromacs
.. automodule:: MDAnalysis.selections.jmol
.. automodule:: MDAnalysis.selections.vmd

.. automodule:: MDAnalysis.selections.base
.. automodule:: MDAnalysis.selections.charmm


You have to specify the numpy version against which you want to build. For example
to build with numpy 1.12 use the following command.

conda build --numpy 1.12 .



