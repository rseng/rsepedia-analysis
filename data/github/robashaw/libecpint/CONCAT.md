# Architecture

This document describes the high-level architecture of libecpint, to help any new contributors find their way around the codebase.

## High-level overview

The code is roughly divided into four chunks:

- the interface,
- the fixed backend,
- the generated backend,
- the code generator

As a general rule, the API will not change. If functionality is added to the library, it should be exposed through ```api.hpp```, following the style of other functions in that interface. Changing any existing parts of the API will break compatibility, so we will only do this if it is *absolutely* necessary.

The other three parts are discussed below.

## Code Map

### Fixed backend

This is found in ```src/lib``` and can be further divided into the following functionalities:

- Quadrature (```gaussquad.cpp, radial_quad.cpp```)
- Analytic angular integrals (```angular.cpp```)
- Containers (```ecp.cpp, gshell.cpp```)
- Mathematical utilities (```bessel.cpp, mathutil.cpp```)

In brief, this is where you should put changes of any of the above kinds. These are all things that are used by the library as part of core functionality, and that do not change depending on how the generated part of the code is initialised.

Each file generally describes one class (for example, the ```ECP``` object in ```ecp.cpp``` or the ```AngularIntegral``` object in ```angular.cpp```) _OR_ one set of functionalities (e.g. adaptive quadrature for radial integrals, in ```radial_quad.cpp```). Please stick to this convention.

As a general rule, any changes in the fixed backend will only affect other parts of the fixed backend, and will not affect that API or generated code. The exception is ```ecpint.cpp``` which describes an ```ECPIntegral``` object, but connects the fixed and generated code together. As such it is also where much of the integral screening takes place.

### Generated backend

This is found in ```src/generated``` and ```src/generated/radial```. It is where any generated code, or templates required for code generation, are located. Currently there are two "part" files, for the generated file ```qgen.cpp``` that ends up in the main library.

The radial folder is where the unrolling of recurrence relations for the primitive radial integrals happens. Any algorithmic changes with respect to the recurrence relations should be found/placed in here.

### Code generator

The generated code is handled by ```src/generate.cpp``` and the utility functions in ```include/generate.hpp```. The former works by finding all the non-zero integral terms for a particular radial integral class using the ```SumTerm``` objects in the header. These are then sorted and made unique, before the radial code is written into the generated backend described above.   

This part is compiled and run as a separate project before the main library. Therefore if any changes you make depend on the generated code, and in particular the ```qgen``` array in ```ECPIntegral```, you should think very carefully about whether it  will be affected by any changes in the code generation. If so, functionality should be added to the generated backend, in the same way that ```qgen.cpp``` is handled. 
# Libecpint 1.0.7

[![Build Status](https://dev.azure.com/robertshaw383/libecpint/_apis/build/status/robashaw.libecpint?branchName=master)](https://dev.azure.com/robertshaw383/libecpint/_build/latest?definitionId=2&branchName=master)
[![codecov](https://codecov.io/gh/robashaw/libecpint/branch/master/graph/badge.svg)](https://codecov.io/gh/robashaw/libecpint)
[![Documentation Status](https://readthedocs.org/projects/libecpint/badge/?version=latest)](https://libecpint.readthedocs.io/en/latest/index.html)
[![Code Quality](https://www.code-inspector.com/project/15206/status/svg)]()

[![Zenodo](https://zenodo.org/badge/DOI/10.5281/zenodo.4694353.svg)](https://doi.org/10.5281/zenodo.4694353)
[![JOSS](https://joss.theoj.org/papers/10.21105/joss.03039/status.svg)](https://doi.org/10.21105/joss.03039)

Libecpint is a C++ library for the efficient evaluation of integrals over ab initio effective core potentials, using a mixture of generated, recursive code and Gauss-Chebyshev quadrature. It is designed to be standalone and generic, and is now in its first stable release. If you experience any problems please raise an issue here; contributions and suggestions are also welcome.

## Contributing

Contributions are welcomed, either in the form of raising issues or pull requests on this repo. Please take a look at the Code of Conduct before interacting, which includes instructions for reporting any violations.

## New in first full release

- Analytical 1st and 2nd derivatives;
- Integration now >10x faster;
- New, high level API, with ECP library;
- Automated testing suite.

### Patch 1

- Bug fix in screening of on-ECP type 2 integrals
- Improvements in CMake build steps, thanks to nabbelbabbel/moritzBens

### Patch 2

- Fix for memory leaks in derivative routines
- Minor changes to CMake files

### Patch 3

- Fix bug in radial type 1 integrals where quadrature could fail to converge
- Const correctness throughout, should allow for parallelisation
- Minor updates to docs

### Patch 4

- Code generation now takes considerably less time and memory; MAX_L=8 takes ~35 seconds, peaking at 1.5GB of memory (joint effort with Thomas Dresselhaus and Peter Bygrave)
- This will be the final patch before v1.1

## Dependencies

- A modern C++ compiler, at least C++11 standard library is required. This has been tested with:
  * gcc (v6.3.0 and above)
  * clang (v10.0.0 and above), you may need the CXX flag "-std=c++14"
  * icpc (v20.2.1), may also need the CXX flag "-std=c++14"
- CMake/CTest build tools (v3.12 and higher)
- Python (2.7 or above, including 3 and higher)

Additionally, if you wish to regenerate the radial code (see below),  Python >=3.6 is required with numpy and sympy.

## Documentation

Please refer to the main documentation [here](https://libecpint.readthedocs.io/en/latest/index.html).

## Examples

There is also a working example in the example folder, with instructions of how to build and link against the library. Please also the API tests in tests/lib/

## Acknowledging usage

If you use this library in your program and find it helpful, that's great! Any feedback would be much appreciated. If you publish results using this library, please consider citing the following paper detailing the implementation:

R. A. Shaw, J. G. Hill, J. Chem. Phys. 147, 074108 (2017); doi: [10.1063/1.4986887](http://dx.doi.org/10.1063/1.4986887)

A full bibtex citation can be found in CITATION in the main directory.

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
robertshaw383 (at) gmail (dot) com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
[https://www.contributor-covenant.org/version/2/0/code_of_conduct.html][v2.0].

Community Impact Guidelines were inspired by 
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available 
at [https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.0]: https://www.contributor-covenant.org/version/2/0/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations
# Working example

This directory contains a working example of how to use libecpint for its core functionality - calculating integrals and derivatives for, in this example, hydrogen iodide in a CC-pVTZ(-PP) basis.

## Build

To build this, make sure you have built libecpint (and its dependencies, pugixml and Faddeeva). Then using cmake in this directory

```
cmake . -Bbuild -DCMAKE_CXX_FLAGS="-I/include/dirs -std=c++14" -DCMAKE_EXE_LINKER_FLAGS="-L/lib/dirs"
```
where the -I and -L flags are used to point to the libecpint headers and library, respectively, if these are not already in your path.

To then build the library and run the test:
```
cd build
make
./example LIBECPINT_SHARE_DIR
```
where the argument points to the share/libecpint directory.

## With Eigen

If you have Eigen3 installed and want to test the example matrix build, simply add the flag
```
-D_WITH_EIGEN
```
to the CMAKE_CXX_FLAGS in the cmake step. 
---
title: 'libecpint: A C++ library for  the efficient evaluation of integrals over effective core potentials'
tags:
  - C++
  - computational chemistry
authors:
  - name: Robert A. Shaw
    orcid: 0000-0002-9977-0835
    affiliation: 1
  - name: J. Grant Hill
    orcid: 0000-0002-6457-5837
    affiliation: 1
affiliations:
 - name: Department of Chemistry, University of Sheffield, Sheffield S3 7HF, UK
   index: 1
date: February 2, 2021
bibliography: paper.bib
---

# Summary
Effective core potentials (ECPs) are widely-used in computational chemistry both to reduce the computational cost of calculations,[@Dolg2000] and include relevant physics that would not otherwise be present [@Dolg2002]. In particular, for heavy main-group atoms [@Wadt1985] and transition metals [@Hay1985], the number of core electrons greatly outnumbers the number of valence electrons. It is generally considered that these will not play a significant role in chemical reactivity, and thus can be frozen. Moreover, these electrons show significant relativistic character [@Dolg2002; @Dolg2012]. Both of these issues can be resolved with the introduction of an effective core, represented as a fixed electronic potential. This potential is typically represented as a linear combination of gaussians of varying angular momenta [@Dolg2000].

The introduction of an ECP results in an additional term in the core  Hamiltonian, over which new electronic integrals must be computed. These three-center integrals are far from trivial, and they cannot in general be treated the same way as other electronic integrals [@McMurchie1981; @FloresMoreno2006]. Several widely used computational chemistry codes lack the ability to calculate these integrals due to the difficulty involved in their computation. The present library, `libecpint`, provides an open-source solution to this. It is a standalone library written in modern C++ capable of the highly efficient computation of integrals over ECPs with gaussian orbitals of arbitrary angular momentum, along with their first and second geometric derivatives. The methods implemented are based on novel algorithms that use automatic code generation and symbolic simplification of recursive expressions, along with highly optimised Gauss-Chebyshev quadrature.

# Statement of need

Effective core potentials are an essential part of modern computational chemistry. However, existing implementations are typically unavailable or inaccessible for free use by the open source community. Commonly used proprietary software, such as Gaussian [@Gaussian16] or Molpro [@MOLPRO], do not make details of their implementations available, while the few open-source computational chemistry packages either do not include ECP functionality or use outdated implementations that would not be compatible with modern codebases. A notable example of this is the widely-used Psi4 package [@Psi4], in which a rudimentary version of `libecpint` was originally implemented. Prior to this, the inclusion of ECPs was one of the most requested features by the user base.

Additionally, there has been a recent renaissance in the development of efficient algorithms for evaluating ECP integrals. In particular, multiple research groups have outlined new approaches to prescreening integrals,[@Song2015; @Shaw2017; @McKenzie2018] greatly reducing the computational expense. The `libecpint` library implements many of these new algorithms, combining the recursive methods and fine-grained screening of Shaw et al. [@Shaw2017] with the higher-level screening of other recent work [@Song2015; @McKenzie2018]. The only known implementations of the latter papers are otherwise only available in proprietary software. Therefore `libecpint` represents a necessary contribution to the wider open-source computational chemistry community. It has already been adopted by multiple packages, including Entos QCore and Serenity [@Serenity], and will be part of a future release of Psi4 [@Psi4].

# Functionalities

The core functionality of `libecpint` is the evaluation of both type 1 and type 2 integrals over ECP integrals parametrised in terms of contracted sets of primitive gaussians, as described in Shaw et al. [@Shaw2017]. The component parts divide into the following functionalities:

- a built-in library of parametrised ECPs, with generic containers for Gaussian-type ECPs;
- a highly-optimised Bessel function evaluation routine;
- screening of ECP integrals over shell pairs of orbital basis functions [@Song2015; @McKenzie2018], across all ECPs in a system;
- fine-grained screening of the individual type 2 integrals over primitive gaussians; [@Shaw2017]
- recursive, automatically-generated radial integral code; [@Shaw2017]
- adaptive quadrature for integrals not covered by the recursive routines; [@FloresMoreno2006]
- first- and second-order geometric derivatives of ECP integrals over shell pairs of gaussians.

These features can be accessed via two levels of API:

- a high-level interface, where the user provides a molecular geometry and basis set, then calls routines that return the full tensor of integrals (or integral derivatives) across all shell pairs;
- a low-level interface, where the user provides parameters and deals with the primitive integrals directly.

This allows a great deal of flexibility for different use cases, potentially allowing for users to further develop or adapt the routines themselves.

All primitive integral routines have been designed to be thread safe, allowing users to readily parallelise their calculations. In addition, there is a built in testing and benchmarking suite, allowing for efficiency comparisons both with other codes, and when testing new algorithmic developments.  

# Acknowledgements

Thank you to Moritz Bensberg, Peter Bygraves, Thomas Dresselhaus, Christopher Junghans, Peter Kraus, Jan Unsleber, and Jens Wehner, for finding bugs and suggesting improvements to the initial release of `libecpint`, and often providing helpful solutions.

# References
.. libecpint API file

.. _`sec:usage`:

=====
Usage
=====  

There are two main ways to use the libecpint library. In the high-level API, you pass details of the system (basis set, coordinates, ECPs) to libecpint, and it handles the computation of all the integrals and/or derivatives automatically, returning arrays of the (Cartesian) integrals. In the low-level API, you control the calculation of the integrals yourself, calling the relevant routines as and when you need them. We envisage that for most purposes, the high-level API will be more appropriate, and is easier to use. 

Important note about ECP definitions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ECP powers (``u_ns``) are assumed to be including the ``r^2`` from the spherical Jacobian, as is the convention followed with the Stuttgart-Dresden ECPs. In the code, we subtract two from this (see the ECP constructor) as integration is done in Cartesian coordinates. In general, the inputted ``n`` should only ever be 0, 1, or (most commonly) 2. If your ECP definitions are instead -2 or -1, or predominantly 0, that suggests you are following the other convention of not including the Jacobian, so you should add 2. Yes, this is annoying; if in doubt check the built-in ECP library for examples.

High Level API
==============

Examples of using this API can be found in ``tests/lib/api_test1`` and ``tests/lib/api_test2``. 

The ECPIntegrator Object
^^^^^^^^^^^^^^^^^^^^^^^^

The first step in using this API is to include the libecpint header and create an ``ECPIntegrator`` object:

.. code-block:: c++

	include <libecpint.hpp>
	ECPIntegrator factory;
	
This object will form the main interface to all of the subsequent routines, and is described in detail in the Library API.  

Initialisation
^^^^^^^^^^^^^^

There are three steps to initialising the ``ECPIntegrator`` before it can be used to calculate integrals. These are:

	1) specifying the Gaussian basis set
	2) specifying the ECP basis
	3) calling the ``init`` routine
	
These steps are performed as follows:

.. code-block:: c++
	
	factory.set_gaussian_basis(N_shells, g_coords, g_exps, g_coefs, g_ams, g_lengths);
	factory.set_ecp_basis(N_ecps, u_coords, u_exps, u_coefs, u_ams, u_ns, u_lengths);
	factory.init(deriv_order);
	
where ``N_shells`` and ``N_ecps`` are the numbers of shells in the Gaussian basis, and the number of ECP centers, respectively, while ``deriv_order`` is the maximum derivatives needed (0, 1, or 2). The rest of the parameters are:

 - the Cartesian coordinates *in Bohr* (``g_coords, u_coords``);
 - the exponents, coefficients, and angular momenta (and powers, ``u_ns``, for the ECPs) comprising the basis sets
 - the number of exponents per shell (``g_lengths, u_lengths``) 
 
 ``tests/lib/api_test1`` shows how to specify these for HBr in the AVDZ/AVDZ-PP basis. 
 
**NOTE**: The atom order given in ``set_gaussian_basis`` fixes the atom order for all the derivatives, as will be described later. 

The ECP library
^^^^^^^^^^^^^^^

Alternatively, step 2 can be replaced by reading the ECPs from the built-in library provided with libecpint. This can be found in ``share/libecpint``. To do this, you call:

.. code-block:: c++
	
	factory.set_ecp_basis_from_library(N_ecps, u_coords, u_charges, u_names, share_dir);
	
The new parameters are:
	 
	 - ``u_charges`` a list of atomic numbers for the ECPs, corresponding to the centers in u_coords;
	 - ``u_names`` the ECP names for each ECP, e.g. ``ecp10mdf``;
	 - ``share_dir`` the absolute path to the share/libecpint directory, which must be passed by you.
	 
The currently available ECPs in the library (more being added soon), and the atoms they are available for, are given below: 

.. list-table::
	:widths: 25 75
	:header-rows: 1
	
	* - Name
	  - Atoms
	* - ECP10MDF
	  - K -- Kr (Z = 19 -- 36)
	* - ECP28MDF
	  - Rb -- Xe (Z = 37 -- 54)
	* - ECP46MDF
	  - Cs, Ba (Z = 55, 56)
	* - ECP60MDF
	  - Hf -- Rn (Z = 72 -- 86), Ac -- U (Z = 89 -- 92)
	* - ECP78MDF
	  - Fr, Ra (Z = 87, 88)
	* - LANL2DZ
	  - Na -- La (Z = 11 -- 57), Hf -- Bi (Z = 72 -- 83), U -- Pu (Z = 92 -- 94)
	  
** TO ADD AN ECP TO THE LIBRARY ** 

	1) Put the ECP in MOLPRO format in ``share/libecpint/raw`` as ``NAME.ecp``, where ``NAME`` is the name of the ECP; make sure that any exponents are with ``E`` (C-convention) not ``D`` (Fortran-convention).  
	2) Make the top line of ``NAME.ecp`` be the ``NAME``.
	3) In ``share/libecpint`` run ``python3 parseecp.py NAME`` (Python >=3.6 required, with lxml module). This will create ``NAME.xml`` in the ``share/libecpint/xml`` folder, and this ECP will now be available for use by libecpint. Please consider creating a pull request so that everyone can benefit from the addition!
	
*Note* that the ``n`` value for each ECP primitive should typically be 0, 1, or 2 (for the Stuttgart-Dresden ECPs, for example, it is `always` 2). Some input formats follow a convention of subtracting or adding 2 to this.  
	

Computing integrals
^^^^^^^^^^^^^^^^^^^

Computing integrals over all shell pairs is then very simple:

.. code-block:: c++

	factory.compute_integrals()
	
To retrieve these you then create a shared pointer to a vector:
	
.. code-block:: c++
	
	std::shared_ptr<std::vector<double>> integrals = factory.get_integrals();
	double I00 = (*ints)[0]; // example for accessing element (0, 0)

These are stored in row-order, and are in a *Cartesian Gaussian basis*. Typically these would be converted to a spherical harmonic Gaussian basis (we might add the ability to do this later). We follow canonical Cartesian order, so for a d-type function this would be ``xx, xy, xz, yy, yz, zz``, and the order of the shells is the same as when you called ``set_gaussian_basis``. The total number of Cartesian gaussians is stored in ``factory.ncart``; you can access the ij-th integral as

.. code-block:: c++

	double Iij = (*ints)[i*factory.ncart + j]
	

First derivatives
^^^^^^^^^^^^^^^^^

First derivatives are similarly calculated by calling 

.. code-block:: c++

	factory.compute_first_derivs()
	
*Note* that this will only work if ``init`` was called with ``deriv_order > 0``. This will return an array of ``3*factory.natoms`` shared pointers to the integral derivatives with respect to each coordinate. The order is x, y, z, and the order of atoms matches that specified in ``set_gaussian_basis``. For example, to get the array of integral derivatives with respect to the y-coordinate of the n-th atom, you would do:

.. code-block:: c++

	std::vector<std::shared_ptr<std::vector<double>>> first_derivs = factory.get_first_derivs();
	I_dy_atom_n_00 = (*first_derivs[3*n+1])[0];

The order of the elements in each array is identical to that from ``compute_integrals``.

Second derivatives
^^^^^^^^^^^^^^^^^^

As for first derivatives, second derivatives are computed as 

.. code-block:: c++

	factory.compute_second_derivs()
	
and are provided as a vector of shared pointers to arrays. The order of these derivatives is somewhat more complicated though, and takes full advantage of symmetry. If the atoms are A, B, C, ... as specified in ``set_gaussian_basis``, then they are blocked as follows: 

.. code-block:: bash
	
	AA, AB, AC, ..., BB, BC, ..., CC, ...

Within each block the order is ``xx, xy, xz, yy, yz, z`` on the diagonal (e.g. AA, BB, CC, ...) and ``xx, xy, xz, yx, yy, yz, zx, zy, zz`` on the off-diagonal (e.g. AB, AC, BC, ...). There is a helper macro for this, ``H_MACRO``, defined in ``api.hpp``. So for example to get the derivative with respect to Ay (atom index 0) and Cx (atom index = 2) in a system with ``N`` atoms, you would do

.. code-block:: c++

	int deriv_index = H_START(0, 2, N) + 3; // yx is index 3 for off-diagonal blocks
	std::shared_ptr<std::vector<double>> h_Ay_Cx = factory.get_second_derivs()[deriv_index];
	
Hopefully this doesn't give you too much of a headache working out.
 
Updating coordinates
^^^^^^^^^^^^^^^^^^^^

To update the coordinates for the basis and ECPs (for example, after a step in a geometry optimisation), simply pass the new coordinates *in the same order they were given when initialised*. This is done as:

.. code-block:: c++

	 factory.update_gaussian_basis_coords(N_shells, g_coords);
	 factory.update_ecp_basis_coords(N_ecps, u_coords);
	 
You then call the compute routines when you need the new integrals and/or derivatives. 

**NOTE** you will need to re-get the pointers using the get routines every time you recompute integrals/derivatives.

Settings
^^^^^^^^

**TODO** detail optional settings that can be passed to ECPIntegrator


Low Level API
=============

Examples of using this API can be found in ``tests/lib/[name]_test[number]`` where [name] is int (integrals), deriv (first derivatives), or hess (second derivatives), and [number] is 1 or 2. 

The ECPIntegral Object
^^^^^^^^^^^^^^^^^^^^^^

To be able to calculate integrals and derivatives at the shell-pair level, you need to create an ``ECPIntegral`` object instead. This is done as follows:

.. code-block:: c++

	#include <libecpint/ecpint.hpp>
	ECPIntegral ecpint(maxLB, maxLU, deriv_order);

where ``maxLB`` is the maximum angular momentum in the Gaussian basis, ``maxLU`` is the maximum angular momentum in the ECP basis, and ``deriv_order`` is the maximum order of derivative needed (defaults to 0). 

Making shells and ECPs
^^^^^^^^^^^^^^^^^^^^^^

The compute functions in this API require ``ECP`` and ``GaussianShell`` objects representing the ECP and Gaussian basis functions, respectively. These are populated for the ECP as follows:

.. code-block:: c++

	#include <libecpint/ecp.hpp>
	double C[3] = {Cx, Cy, Cz};
	ECP newU(C);
	newU.addPrimitive(n, l, x, c);
	// addPrimitive for each primitive in ECP

where ``C`` is the coordinates of the center of the ECP (in Bohr), and ``n, l, x, c`` are the power, angular momentum, exponent, and coefficient of each primitive in that ECP. For the Gaussian basis instead:

.. code-block:: c++	
	
	#include <libecpint/gshell.hpp>
	double A[3] = {Ax, Ay, Az};
	GaussianShell shellA(A, l); 
	shellA.addPrim(x, c);
	// addPrim for each primitive in this shell

where ``A`` is the coordinates of the center of the shell (in Bohr), and ``l, x, c`` are as above. You need to either create these objects for every shell and ECP as they are needed, or store them, so that they can be passed to the compute routines below. 
 
Computing integrals
^^^^^^^^^^^^^^^^^^^

Computing integrals over a shell pair is then fairly simple. You call

.. code-block:: c++

	#include <libecpint/mathutil.hpp>
	TwoIndex<double> results;
	ecpint.compute_shell_pair(newU, shellA, shellB, results);
	
This will place the integrals in a matrix, ``results``, with dimensions ``(ncartA, ncartB)``. The order in each is the canonical Cartesian order as described earlier for the high-level API. Elements of the results matrix can be accessed in two ways:

.. code-block:: c++
	 
	 double Iij = results(i, j);
	 // or
	 double Iij = results.data[i*ncartB + j];

First derivatives
^^^^^^^^^^^^^^^^^

Similarly, first derivatives are calculated using

.. code-block:: c++
	
	std::vector<TwoIndex<double>> results;
	ecpint.compute_shell_pair_derivative(newU, shellA, shellB, results);
	
Now ``results`` is an array of 9 matrices (the matrices are ordered the same as for ``compute_shell_pair`` above). These are derivative matrices with respect to ``Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz``, where ``A, B, C`` are the centers of ``shellA``, ``shellB``, and ``newU`` respectively.

**NOTE** These derivatives are designed to be additive. Thus, if ``A==B``, then the derivative for the Ax coordinate will be the sum ``Ax+Bx``, etc. 

Second derivatives
^^^^^^^^^^^^^^^^^^

The second derivatives are calculated in the same simple manner, but their ordering is, as with the high-level API, much more complicated. 

.. code-block:: c++

	std::vector<TwoIndex<double>> results;
	ecpint.compute_shell_pair_second_derivative(newU, shellA, shellB, results);
	
Now ``results`` contains **45** different derivative matrices. These are, in order:

.. code-block:: bash

	 AxAx, AxAy, AxAz, AyAy, AyAz, AzAz,
	 AxBx, AxBy, AxBz, AyBx, AyBy, AyBz, AzBx, AzBy, AzBz,
	 AxCx, AxCy, AxCz, AyCx, AyCy, AyCz, AzCx, AzCy, AzCz,
	 BxBx, BxBy, BxBz, ByBy, ByBz, BzBz,
	 BxCx, BxCy, BxCz, ByCx, ByCy, ByCz, BzCx, BzCy, BzCz,
	 CxCx, CxCy, CxCz, CyCy, CyCz, CzCz

where ``A, B, C`` are as described earlier. These are again additive but THERE IS NOW SYMMETRY TO CONSIDER. I *strongly* recommend that you look at the code in ``api.cpp`` for the construction of the full Hessian, to see how this symmetry has to be taken account of when any of the three centers are the same, as it is too complicated to describe here. 
 
Settings
^^^^^^^^

**TODO** detail optional settings that can be passed to ECPIntegral

.. toctree::
   :hidden:
.. libecpint install file

.. _`sec:installation`:

=====================================
Installation
=====================================   

Obtaining libecpint
===================

The latest stable release of libecpint can always be found at the Github Repo_. 

.. _Repo: https://www.github.com/robashaw/libecpint.git

It can be downloaded directly from there, or you can clone it locally using git with the command

.. code-block:: bash

	git clone https://github.com/robashaw/libecpint.git 
	
If you are a developer looking to make changes to the code, please fork the repo into your own version, and make a pull request when you think your changes are production ready. We will not accept any attempts to push directly into master.

Building
========

To build the library, do the following in the top of the source tree (out-of-source build is required!):

.. code-block:: bash

	mkdir build
	cd build
	cmake [options] ..
	make [-jn]

The ``-jn`` flag tells make to use ``n`` threads while compiling (e.g. ``-j4`` would use four threads), and is highly recommended if your computer can cope, as the generated code files can all be compiled independently of one another.

CMake Options
^^^^^^^^^^^^^

The options after cmake above can be included using the syntax `-DOPTION=value`. The pertinent options are as follows:

+----------------------+---------------+------------------------------------------------------+
| Option       	       | Default       |  Description                                         |    
+======================+===============+======================================================+
| CMAKE_CXX_FLAGS      | N/A           | Flags to pass to the C++ compiler. These will depend |
|                      |               | on which compiler you're using, but in general we    |
|                      |               | *strongly* recommend passing optimisation flags,     |
|                      |               | specifically ``-O2`` or ``-O3``.                     |
+----------------------+---------------+------------------------------------------------------+
| CMAKE_INSTALL_PREFIX | /usr/local    | The directory where the library will be installed.   |
|                      |               | You must have permissions to edit this directory.    |
+----------------------+---------------+------------------------------------------------------+
| LIBECPINT_MAX_L      | 5             | The maximum angular momentum (in the orbital and ECP |
|                      |               | basis) that the code will be able to handle. The     |
|                      |               | higher this is, the longer the build stage will take,|
|                      |               | although not significantly so. NOTE: If you want     |
|                      |               | derivatives of up to ``L``, this must be ``L+n``     |
|                      |               | where ``n`` is the order of derivative (1 or 2).     |
+----------------------+---------------+------------------------------------------------------+
| LIBECPINT_MAX_UNROL  | 1             | NOW REDUNDANT. The max. angular momentum the code is |
|                      |               | unrolled up to. Increasing this will make the build  |
|                      |               | much slower but no longer gives any noticeable       |
|                      |               | advantage. We *strongly* recommend leaving this at   |
|                      |               | its default value.                                   |
+----------------------+---------------+------------------------------------------------------+

	  
Documentation
^^^^^^^^^^^^^

This documentation can be generated locally via CMake by running

.. code-block:: bash
	
	make docs
	
This requires the following to be available:

- Doxygen
- Sphinx
- Breathe
- Exhale

Regenerating the radial code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The recursive radial integral code has been pre-generated, as the current setting has been calibrated to balance accuracy and efficiency. If you would like to experiment (warning: after reading the paper), go into the directory ``src/generated/radial``. Edit the top line of  ``unrol_radial.py`` to change ``MAX_UNROL_AM``, the maximum angular momentum to be unrolled. Then do the following:

.. code-block:: bash
	
	python3 unrol_radial.py
	./generate.sh

This will generate the simplified recursive integrals and then piece together the ``radial_gen.cpp`` file and place it in the correct location. It should be very safe (but not very efficient) to decrease ``MAX_UNROL_AM``, but be prepared for things to break if you increase it too much. 


Testing
=======

To run all the tests, in the build directory run

.. code-block:: bash
	
	make test

This will give results that look as follows:

.. code-block:: bash

	 Running tests...
	 Test project [build-dir]
	       Start  1: MathUtil
	  1/16 Test  #1: MathUtil .........................   Passed    0.01 sec
	       Start  2: MultiArray
	  2/16 Test  #2: MultiArray .......................   Passed    0.00 sec
	       Start  3: Bessel
	  3/16 Test  #3: Bessel ...........................   Passed    0.02 sec
	       Start  4: GaussianShell
	  4/16 Test  #4: GaussianShell ....................   Passed    0.01 sec
	       Start  5: GaussianECP
	  5/16 Test  #5: GaussianECP ......................   Passed    0.02 sec
	       Start  6: GaussQuad
	  6/16 Test  #6: GaussQuad ........................   Passed    0.01 sec
	       Start  7: Generator
	  7/16 Test  #7: Generator ........................   Passed    0.00 sec
	       Start  8: IntTest1
	  8/16 Test  #8: IntTest1 .........................   Passed    0.04 sec
	       Start  9: IntTest2
	  9/16 Test  #9: IntTest2 .........................   Passed    0.02 sec
	       Start 10: DerivTest1
	 10/16 Test #10: DerivTest1 .......................   Passed    0.04 sec
	       Start 11: DerivTest2
	 11/16 Test #11: DerivTest2 .......................   Passed    0.12 sec
	       Start 12: HessTest1
	 12/16 Test #12: HessTest1 ........................   Passed    0.12 sec
	       Start 13: HessTest2
	 13/16 Test #13: HessTest2 ........................   Passed    0.11 sec
	       Start 14: APITest1
	 14/16 Test #14: APITest1 .........................   Passed    0.03 sec
	       Start 15: APITest2
	 15/16 Test #15: APITest2 .........................   Passed    0.13 sec
	       Start 16: Type1Test
	 16/16 Test #16: Type1Test ........................   Passed    0.03 sec
	 100% tests passed, 0 tests failed out of 16
	 

If any of these tests fails, the reasons for the failure can then be found in ``build/Testing/Temporary/LastTest.log``. This should help you troubleshoot and problems. If you have followed these instructions and the tests are still failing, please raise an issue on Github, giving details of your environment, any options you gave, and the relevant contents of LastTest.log. 

Stress test
^^^^^^^^^^^

To see how efficient your build is, you can make an additional test as follows:

.. code-block:: bash

	make StressTest
	
This will compute integrals and derivatives for increasing clusters of silver atoms, giving timings for each. At the end it will give estimated scaling exponents. Our latest build (clang 12.0.0, -O3 flag, single core on MacBook Pro 2017) gave these results:

.. code-block:: bash

	N: 2
	  Initialisation...   done. TIME TAKEN:        0.158172 seconds
	       Integrals...   done. TIME TAKEN:        0.116014 seconds
	      1st derivs...   done. TIME TAKEN:        0.321756 seconds
	      2nd derivs...   done. TIME TAKEN:        0.785262 seconds
	N: 4
	  Initialisation...   done. TIME TAKEN:        0.138962 seconds
	       Integrals...   done. TIME TAKEN:         1.23218 seconds
	      1st derivs...   done. TIME TAKEN:         4.16765 seconds
	N: 6
	  Initialisation...   done. TIME TAKEN:        0.128387 seconds
	       Integrals...   done. TIME TAKEN:         4.34048 seconds
	      1st derivs...   done. TIME TAKEN:         15.7498 seconds
	Scaling of integrals: N**3.31
	Scaling of 1st derivs: N**3.56

Installation
============

To install the library and share directory, run

.. code-block:: bash

	make install
	
which will create the following files/directories:

.. code-block:: bash

	${CMAKE_INSTALL_PREFIX}/lib/libecpint.a
	${CMAKE_INSTALL_PREFIX}/include/libecpint.hpp
	${CMAKE_INSTALL_PREFIX}/include/libecpint
	${CMAKE_INSTALL_PREFIX}/share/libecpint


.. toctree::
   :hidden:
.. libecpint documentation master file, created by
   sphinx-quickstart on Sat Sep 19 00:21:17 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

=====================================
libecpint : C++ ECP integral library
=====================================

About
=======

libecpint is an open-source library for the calculation of integrals over effective core potentials (ECPs) in quantum chemistry software. It was written predominantly by Robert A. Shaw (@robertshaw383), with some assistance from J. Grant Hill (@Dr_GHill). It is currently used in at least three major quantum chemistry packages: Psi4 (@PSI_code), Serenity (@QCSerenity), and entos (@EntosAI). 

.. toctree::
   :maxdepth: 2
   
   introduction
   installation
   usage
   api/library_root

   
Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
.. libecpint intro file

.. _`sec:introduction`:

=============
Introduction
=============  

Overview
========

libecpint is a C++ library for the efficient evaluation of integrals over ab initio effective core potentials, using a mixture of generated, recursive code and Gauss-Chebyshev quadrature. It is designed to be standalone and generic, but is currently in development and may not be completely stable. If you experience any problems please raise an issue here; contributions and suggestions are also welcome.

This assumes ECPs and basis sets of the form usually seen in electronic structure calculations, namely those expanded in terms of Gaussian functions. The angular momentum of function that can be treated is in theory arbitrary, but is limited by your choice of maximum when the library is built.

Citing libecpint
================

If you use this library in your program and find it helpful, that's great! Any feedback would be much appreciated. If you publish results using this library, please consider citing the following paper detailing the implementation:

R. A. Shaw, J. G. Hill, J. Chem. Phys. 147, 074108 (2017); doi: [10.1063/1.4986887](http://dx.doi.org/10.1063/1.4986887)

A full bibtex citation can be found in CITATION in the main directory.

Please also cite the ECPs and basis sets you use. 

Requirements
============

For the library
^^^^^^^^^^^^^^^

- A modern C++ compiler, at least C++11 standard library is required. This has currently only been tested with GCC (6.3.0 and above, but will in theory work with any > 4.9) and clang (9.0.0 and above). Intel compilers have been known to cause issues.
- CMake/CTest build tools v. >= 3.12 
- Python (2.7 or above, including 3 and higher)

For the docs
^^^^^^^^^^^^

- Doxygen
- Sphinx
- Breathe
- Exhale

For radial code regeneration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Python 3.6 or above
- numpy
- sympy

License
=======

libecpint is available under an MIT License, allowing for free and open use, reproduction, and modification of the library, so long as the copyright and license notices are preserved. The authors hold no liability for, and give no warranty against, results of the use of this software.

Support
=======

If you have any problems or would like to make suggestions for improvements, please raise an issue on the github repo. We will endeavour to get back to you as soon as possible, but as "we" is predominantly just "me" (Robert), it may take a while. 

Help is always welcome, and if you wish to make contributions to the code yourself, please take a look at the library API docs and have a go. Send a pull request with any enhancements!

.. toctree::
   :hidden:

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp:

Program Listing for File radial_gen.cpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/radial_gen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file was generated as a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       void RadialIntegral::compute_base_integrals(int N_min, int N_max, double p, double o_root_p, double P1,
       double P2, double P1_2, double P2_2, double X1, double X2,
       double oP1, double oP2, double* values) {
       
           // Recursively construct the base integrals in order F2, G3, F4, G5, etc... as described in Shaw2017
           
           int imax = N_max / 2;
           int imin = (N_min + 1) / 2;
           int gmax = (N_max - 1) / 2;
           int gmin = N_min / 2;
       
           double P1_2k = 1.0;
           double P2_2k = 1.0; 
       
           for (int k = 2; k < imin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           double ck, dk, ek, val; 
           double C0 = o_root_p * ROOT_PI;
           for (int n = imin; n <= imax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);   
           
               for (int k = n - 1; k > 1; k--) {
                   ck *= 2*k*(2*k - 1)*(n-k-0.5) / ((2*n - 2*k) * (2*n - 2*k - 1) * p);
                   dk *= oP1;
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               if (n > 1) {
                   ck *= 2*(n-1.5) / ((2*n - 2) * (2*n - 3) * p);
                   val += ck * (X1 - X2); 
               }
           
               values[2*n - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           P1_2k = P1;
           P2_2k = P2;
           for (int k = 1; k < gmin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           } 
       
       
           for (int n = gmin; n <= gmax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);
           
               for (int k = n-1; k >0; k--) {
                   ck *= 2*k*(2*k+1)*(n-k-0.5) / ((2*n-2*k) * (2*n - 1 - 2*k) * p);
                   dk *= oP1; 
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               values[2*n + 1 - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2; 
           } 
       
       }
   
       std::pair<double, bool> RadialIntegral::integrate_small(int N, int l1, int l2, double n, double a, double b, double A, double B) {
           int gridSize = primGrid.getN();
           double zt = n+a+b;
           double pt = (a*A + b*B)/zt;
           primGrid.transformRMinMax(zt, pt); 
           std::vector<double> &gridPoints = primGrid.getX();
       
           double Ftab[gridSize]; 
       
           double z, zA, zB, besselValue1, besselValue2;
           double aA = 2.0 * a * A;
           double bB = 2.0 * b * B;
           
           z = gridPoints[0];
           zA = z-A; zB = z-B;
           besselValue1 = bessie.calculate(aA * z, l1);
           besselValue2 = bessie.calculate(bB * z, l2);
           Ftab[0] = FAST_POW[N](z) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
           
           int i = 1;
           double TOL = tolerance; 
           bool not_in_tail = true;
           double delta=1.0;
           while (not_in_tail && i < gridSize) {
               z = gridPoints[i];
               zA = z - A; 
               zB = z - B; 
               
               besselValue1 = bessie.calculate(aA * z, l1);
               besselValue2 = bessie.calculate(bB * z, l2);        
               Ftab[i] = FAST_POW[N](z) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
   
               delta = Ftab[i] - Ftab[i-1];
               not_in_tail = (Ftab[i] > TOL) || (delta > 0);
               i++; 
           }
           
           for (int j = i; j < gridSize; j++)
               Ftab[j] = 0.0;
       
           std::function<double(double, double*, int)> intgd = RadialIntegral::integrand;
           
           // There should be no instances where this fails, so no backup plan to large grid, but return check just in case 
           bool success = primGrid.integrate(intgd, Ftab, 1e-12); 
           std::pair<double, bool> rval = {primGrid.getI(), success};  
           primGrid.untransformRMinMax(zt, pt);
           return rval; 
       }
       
       void RadialIntegral::type2(std::vector<Triple>& triples, int nbase, int lam, ECP &U, GaussianShell &shellA, GaussianShell &shellB,
       double A, double B, ThreeIndex<double> &radials)
       {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
           
           // Loop over primitives in ECP, only considering correct ang. momentum
           for(const auto& u : U.gaussians) { 
               if (u.l == lam) {
                   
                   // Loop over primitives in orbital basis shellß
                   for(int na = 0; na < npA; na++) {
                       double a = shellA.exp(na);
                       double da = shellA.coef(na); 
               
                       for (int nb = 0; nb < npB; nb++) {
                           double b = shellB.exp(nb);
                           double db = shellB.coef(nb); 
                           
                           // Construct values that will be reused across all radial integrals
                           double p = u.a + a + b;
                           double x = a * A;
                           double y = b * B;
       
                           double P1 = (x + y) / p;
                           double P2 = (y - x) / p;
                           double P1_2 = P1 * P1;
                           double P2_2 = P2 * P2;
                           double oP1 = 1.0 / P1_2;
                           double oP2 = std::abs(P2) < 1e-7 ? 0.0 : 1.0 / P2_2;
                           double root_p = sqrt(p);
                           double o_root_p = 1.0 / root_p; 
                           double aAbB = a*A*A + b*B*B;
                           double Kab = 1.0 / (16.0 * x * y); 
                           double X1 = exp(p * P1_2 - aAbB) * Kab;
                           double X2 = exp(p * P2_2 - aAbB) * Kab;
       
                           double x2 = x * x;
                           double y2 = y * y; 
                           double p2 = p * p; 
       
                           double result = 0.0;
                           
                           // G1A, G1B may not be required, but it seems to be quicker to calculate than to check if needed
                           double daw1 = X1 * Faddeeva::Dawson(root_p * P1);
                           double daw2 = X2 * Faddeeva::Dawson(root_p * P2);   
                           double G1B = 2.0 * ROOT_PI * (daw1 - daw2);
                           double G1A = 2.0 * ROOT_PI * (daw1 + daw2);
                           double H2 =  ROOT_PI * ( X1 + X2 ) * o_root_p; 
   
                           // Compute base integrals
                           double *values = new double[nbase+2]; 
                           compute_base_integrals(2, 3+nbase, p, o_root_p, P1, P2, P1_2, P2_2, X1, X2, oP1, oP2, values); 
                           
                           // Loop over all radial integrals required, divert to generated code
                           for (const Triple& triple : triples ) {
                               int i = std::get<1>(triple);
                               int j = std::get<2>(triple);
                               int k = std::get<0>(triple) + u.n + 2; 
                               
                               int ijk = i*10000 + j*100 + k; 
                               double result = 0.0;
                               if (a * b > MIN_EXP) {// && b > MIN_EXP) { 
                                   switch(ijk) {
                                       case 2 : {
                                           result = ( 1 ) * values[0];
                                           break;
                                       }
   
                                       case 4 : {
                                           result += ( 1 ) * values[ 2 ];
                                           break;
                                       }
   
                                       case 6 : {
                                           result += ( 1 ) * values[ 4 ];
                                           break;
                                       }
   
                                       case 8 : {
                                           result += ( 1 ) * values[ 6 ];
                                           break;
                                       }
   
                                       case 10 : {
                                           result += ( 1 ) * values[ 8 ];
                                           break;
                                       }
   
                                       case 12 : {
                                           result += ( 1 ) * values[ 10 ];
                                           break;
                                       }
   
                                       case 101 : {
                                           result = ( p/y ) * values[0];
                                           result += ( -x/y ) * G1A;
                                           break;
                                       }
   
                                       case 103 : {
                                           result = ( -1/(2*y) ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 105 : {
                                           result += ( -1/(2*y) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 107 : {
                                           result += ( -1/(2*y) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 109 : {
                                           result += ( -1/(2*y) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 111 : {
                                           result += ( -1/(2*y) ) * values[ 8 ];
                                           result += ( 1 ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 10102 : {
                                           result = ( -(p/2 + y2)/(x*y) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10104 : {
                                           result = ( 1/(2*x*y) ) * values[0];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 2 ];
                                           result += ( -1/x ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10106 : {
                                           result += ( 1/(x*y) ) * values[ 2 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -2/x ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10108 : {
                                           result += ( 3/(2*x*y) ) * values[ 4 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -3/x ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10110 : {
                                           result += ( -1/(4*x*y) ) * values[ 6 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 8 ];
                                           result += ( 1/(2*x) ) * values[ 7 ];
                                           result += ( p/x ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 202 : {
                                           result = ( -3*p/(2*y2) + 1 ) * values[0];
                                           result += ( 3*x/(2*y2) ) * G1A;
                                           break;
                                       }
   
                                       case 204 : {
                                           result = ( 3/(4*y2) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -3/(2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 206 : {
                                           result += ( 3/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -3/(2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 208 : {
                                           result += ( 3/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -3/(2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 210 : {
                                           result += ( 3/(4*y2) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 8 ];
                                           result += ( -3/(2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10201 : {
                                           result = ( -p*(p + 2*x2)/(2*x*y2) ) * values[0];
                                           result += ( x2/y2 ) * G1A;
                                           result += ( p/y ) * H2;
                                           break;
                                       }
   
                                       case 10203 : {
                                           result = ( (3*p + 2*y2)/(4*x*y2) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10205 : {
                                           result = ( -3/(4*x*y2) ) * values[0];
                                           result += ( (3*p - 2*y2)/(4*x*y2) ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( 3/(2*x*y) ) * values[ 1 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10207 : {
                                           result += ( -3/(2*x*y2) ) * values[ 2 ];
                                           result += ( 3*(p - 2*y2)/(4*x*y2) ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 3/(x*y) ) * values[ 3 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10209 : {
                                           result += ( -9/(4*x*y2) ) * values[ 4 ];
                                           result += ( (3*p - 10*y2)/(4*x*y2) ) * values[ 6 ];
                                           result += ( p/x ) * values[ 8 ];
                                           result += ( 9/(2*x*y) ) * values[ 5 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20202 : {
                                           result = ( (3*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 20204 : {
                                           result = ( -(3*p/2 + y2)/(x2*y2) ) * values[0];
                                           result += ( (3*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( (3*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20206 : {
                                           result = ( 3/(2*x2*y2) ) * values[0];
                                           result += ( -3*p/(x2*y2) ) * values[ 2 ];
                                           result += ( (3*p2 + 4*y2*(-3*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( -3/(x2*y) ) * values[ 1 ];
                                           result += ( 2*(3*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20208 : {
                                           result += ( 9/(2*x2*y2) ) * values[ 2 ];
                                           result += ( 3*(-3*p + 2*y2)/(2*x2*y2) ) * values[ 4 ];
                                           result += ( (3*p2 + 4*y2*(-5*p + y2))/(4*x2*y2) ) * values[ 6 ];
                                           result += ( p2/x2 ) * values[ 8 ];
                                           result += ( -9/(x2*y) ) * values[ 3 ];
                                           result += ( 3*(3*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 301 : {
                                           result = ( p*(-5*p + 5*x2 + 2*y2)/(2*(y2*y)) ) * values[0];
                                           result += ( x*(15*p - 10*x2 + 6*y2)/(4*(y2*y)) ) * G1A;
                                           result += ( -5*p*x/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 303 : {
                                           result = ( 15*p/(4*(y2*y)) - 3/y ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           result += ( -15*x/(4*(y2*y)) ) * G1A;
                                           break;
                                       }
   
                                       case 305 : {
                                           result = ( -15/(8*(y2*y)) ) * values[0];
                                           result += ( -3/y ) * values[ 2 ];
                                           result += ( 15/(4*y2) ) * values[ 1 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 307 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 2 ];
                                           result += ( -3/y ) * values[ 4 ];
                                           result += ( 15/(4*y2) ) * values[ 3 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 309 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 4 ];
                                           result += ( -3/y ) * values[ 6 ];
                                           result += ( 15/(4*y2) ) * values[ 5 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10302 : {
                                           result = ( (5*p2 + 10*p*x2 - 2*p*y2 - 4*(y2*y2))/(4*x*(y2*y)) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           result += ( -5*x2/(2*(y2*y)) ) * G1A;
                                           result += ( -5*p/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 10304 : {
                                           result = ( -(15*p + 6*y2)/(8*x*(y2*y)) ) * values[0];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 2 ];
                                           result += ( 3*(5*p + 2*y2)/(4*x*y2) ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10306 : {
                                           result = ( 15/(8*x*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p + 6*y2)/(8*x*(y2*y)) ) * values[ 2 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -15/(4*x*y2) ) * values[ 1 ];
                                           result += ( (15*p + 2*y2)/(4*x*y2) ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10308 : {
                                           result += ( 15/(4*x*(y2*y)) ) * values[ 2 ];
                                           result += ( 3*(-5*p + 14*y2)/(8*x*(y2*y)) ) * values[ 4 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -15/(2*x*y2) ) * values[ 3 ];
                                           result += ( (15*p - 2*y2)/(4*x*y2) ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20301 : {
                                           result = ( p*(3*p2 + 2*p*x2 + 4*(x2*x2) + 4*x2*y2 - 4*(y2*y2))/(4*x2*(y2*y)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 1 ];
                                           result += ( -(x2*x)/(y2*y) ) * G1A;
                                           result += ( -p*(3*p + 2*x2 + 2*y2)/(2*x*y2) ) * H2;
                                           break;
                                       }
   
                                       case 20303 : {
                                           result = ( -(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[0];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 2 ];
                                           result += ( (15*p2 + 4*y2*(3*p + y2))/(4*x2*y2) ) * values[ 1 ];
                                           result += ( p2/x2 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20305 : {
                                           result = ( 3*(5*p + 2*y2)/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 4 ];
                                           result += ( -(15*p + 6*y2)/(2*x2*y2) ) * values[ 1 ];
                                           result += ( (15*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[ 3 ];
                                           result += ( p2/x2 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20307 : {
                                           result = ( -15/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(5*p - 2*y2)/(2*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*p2 + 84*p*y2 + 28*(y2*y2))/(8*x2*(y2*y)) ) * values[ 4 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 6 ];
                                           result += ( 15/(2*x2*y2) ) * values[ 1 ];
                                           result += ( -(15*p + 4*y2)/(x2*y2) ) * values[ 3 ];
                                           result += ( (15*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 5 ];
                                           result += ( p2/x2 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 30302 : {
                                           result = ( -(15*(p2*p) + 18*p2*y2 + 12*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 2 ];
                                           result += ( 3*p*(5*p2 + 6*p*y2 + 4*(y2*y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30304 : {
                                           result = ( 3*(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( (-15*(p2*p) + 54*p2*y2 + 4*(y2*y2)*(9*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 4 ];
                                           result += ( -(45*p2 + 12*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(p + 2*y2))/(4*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30306 : {
                                           result = ( -(45*p + 18*y2)/(4*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( 3*(15*p2 - 12*p*y2 - 4*(y2*y2))/(4*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*(p2*p) + 126*p2*y2 + 4*(y2*y2)*(21*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 4 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 6 ];
                                           result += ( 9*(5*p + 2*y2)/(2*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( -(45*p2 + 12*y2*(2*p + y2))/(2*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(-p + 2*y2))/(4*(x2*x)*y2) ) * values[ 5 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 402 : {
                                           result = ( (-5*p*(-7*p + 7*x2 + 4*y2)/4 + (y2*y2))/(y2*y2) ) * values[0];
                                           result += ( 5*x*(-21*p + 14*x2 - 6*y2)/(8*(y2*y2)) ) * G1A;
                                           result += ( 35*p*x/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 404 : {
                                           result = ( 15*(-7*p + 6*y2)/(8*(y2*y2)) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -5/y ) * values[ 1 ];
                                           result += ( 105*x/(8*(y2*y2)) ) * G1A;
                                           break;
                                       }
   
                                       case 406 : {
                                           result = ( 105/(16*(y2*y2)) ) * values[0];
                                           result += ( 45/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 1 ];
                                           result += ( -5/y ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 408 : {
                                           result += ( 105/(16*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 3 ];
                                           result += ( -5/y ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10401 : {
                                           result = ( -p*(-7*p2 - 28*p*x2 + 2*p*y2 + 14*(x2*x2) + 4*x2*y2)/(4*x*(y2*y2)) ) * values[0];
                                           result += ( x2*(-35*p + 14*x2 - 10*y2)/(4*(y2*y2)) ) * G1A;
                                           result += ( p*(-7*p + 7*x2 + 2*y2)/(2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10403 : {
                                           result = ( -(35*p2 + 70*p*x2 - 20*p*y2 - 32*(y2*y2))/(8*x*(y2*y2)) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 1 ];
                                           result += ( 35*x2/(4*(y2*y2)) ) * G1A;
                                           result += ( 35*p/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10405 : {
                                           result = ( 15*(7*p + 2*y2)/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 45*p/(4*x*y2) + 3/x ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( -(105*p + 30*y2)/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10407 : {
                                           result = ( -105/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 15*(7*p - 10*y2)/(16*x*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45*p/(4*x*y2) + 2/x ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 105/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( 5*(-21*p + 2*y2)/(8*x*(y2*y)) ) * values[ 3 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20402 : {
                                           result = ( -(21*(p2*p) + 14*p2*x2 - 6*p2*y2 + 28*p*(x2*x2) + 28*p*x2*y2 - 36*p*(y2*y2) - 8*(y2*y2*y2))/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( 7*(x2*x)/(2*(y2*y2)) ) * G1A;
                                           result += ( 7*p*(3*p + 2*x2 + 2*y2)/(4*x*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 20404 : {
                                           result = ( 3*(35*p2 + 20*p*y2 + 4*(y2*y2))/(16*x2*(y2*y2)) ) * values[0];
                                           result += ( (45*p2 + 4*y2*(6*p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( -(105*p2 + 60*p*y2 + 12*(y2*y2))/(8*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20406 : {
                                           result = ( -(105*p + 30*y2)/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( 3*(35*p2 - 100*p*y2 - 28*(y2*y2))/(16*x2*(y2*y2)) ) * values[ 2 ];
                                           result += ( (45*p2 + 4*y2*(4*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( 15*(7*p + 2*y2)/(4*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*p2 + 20*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 3 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30401 : {
                                           result = ( -p*(15*(p2*p) + 6*p2*x2 + 4*p*(x2*x2) + 24*p*x2*y2 - 36*p*(y2*y2) + 8*(x2*x2*x2) + 8*(x2*x2)*y2 + 8*x2*(y2*y2) - 16*(y2*y2*y2))/(8*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( (p2*p)/(x2*x) ) * values[ 2 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 1 ];
                                           result += ( (x2*x2)/(y2*y2) ) * G1A;
                                           result += ( p*(15*p2 + 6*p*x2 + 20*p*y2 + 4*(x2*x2) + 4*x2*y2 + 4*(y2*y2))/(4*x2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 30403 : {
                                           result = ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( 3*p*(15*p2 + 4*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 2 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 4 ];
                                           result += ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30405 : {
                                           result = ( -(315*p2 + 180*p*y2 + 36*(y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( -(-105*(p2*p) + 450*p2*y2 + 252*p*(y2*y2) + 40*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[ 2 ];
                                           result += ( 3*p*(15*p2 + 4*y2*(2*p + y2))/(4*(x2*x)*y2) ) * values[ 4 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 6 ];
                                           result += ( 9*(35*p2 + 20*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*(p2*p) + 30*p2*y2 + 4*(y2*y2)*(3*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 3 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 40402 : {
                                           result = ( (105*(p2*p2) + 120*(p2*p)*y2 + 72*p2*(y2*y2) + 32*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( 3*p2*(15*p2 + 8*y2*(2*p + y2))/(4*(x2*x2)*y2) ) * values[ 2 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 4 ];
                                           result += ( -p*(105*(p2*p) + 120*p2*y2 + 72*p*(y2*y2) + 32*(y2*y2*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 40404 : {
                                           result = ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(4*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( (105*(p2*p2) - 600*(p2*p)*y2 - 504*p2*(y2*y2) - 160*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[ 2 ];
                                           result += ( p2*(45*p2 + 32*p*y2 + 24*(y2*y2))/(4*(x2*x2)*y2) ) * values[ 4 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 6 ];
                                           result += ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(2*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( p*(-105*(p2*p) + 40*p2*y2 + (y2*y2)*(24*p - 32*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 3 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       default: {
                                           if (estimate_type2(k, i, j, u.a, a, b, A, B) > tolerance){ 
                                               std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                               result = quadval.first; 
                                               if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                           }
                                       }
                                   }
                               } else {
                                   if (estimate_type2(k, i, j, u.a, a, b, A, B) > tolerance){ 
                                       std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                       result = quadval.first; 
                                       if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                   }
                               } 
                               
                               radials(k-2-u.n, i, j) += da * db * u.d * result;
                           }
                           
                           delete[] values; 
                       }
                   }
               }
           }
       }
   }
.. _exhale_function_namespacelibecpint_1ad62d70ca1e4137214af96b66ba9e50f8:

Function libecpint::pow_14
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_14(double)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp:

File ecpint.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/ecpint.cpp``)
------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``cassert``

- ``cmath``

- ``ecpint.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`)

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``qgen.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a99f72ea2f7322f8232307384bd228f5a:

Function libecpint::qgen::Q0_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp:

Program Listing for File qgen.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/qgen.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *         This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #ifndef QGEN_HEAD
   #define QGEN_HEAD
   
   #include "multiarr.hpp"
   #include "radial.hpp"
   #include "angular.hpp"
   #include "gshell.hpp"
   #include "ecp.hpp"
   
   namespace libecpint {
       namespace qgen {
   
           void rolled_up(int lam, int LA, int LB, ThreeIndex<double>& radials, FiveIndex<double>& CA, FiveIndex<double>& CB, TwoIndex<double>& SA, TwoIndex<double>& SB, AngularIntegral& angints, ThreeIndex<double>& values);
   
           void rolled_up_special(int lam, int LA, int LB, ThreeIndex<double>& radials, FiveIndex<double>& CB, TwoIndex<double>& SB, AngularIntegral& angints, ThreeIndex<double>& values);
           
       void Q0_0_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_0_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_0_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_0_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_0_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_0_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_1_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_1_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q0_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q1_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q2_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q3_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q4_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
       void Q5_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
   
   }
   }
   #endif

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp:

File angular.hpp
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/angular.hpp``)
---------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp.rst





Includes
--------


- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_angular_integral`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp:

Program Listing for File gshell.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/gshell.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "gshell.hpp"
   
   namespace libecpint {
   
       GaussianShell::GaussianShell(double *A, const int _l) : centerVec(A), l(_l), local_ptr(false), min_exp(100.0) {}
       GaussianShell::GaussianShell(const std::array<double, 3> & A, const int _l) : l(_l) {
           centerVec = localCenter;
           local_ptr = true;
           localCenter[0] = A[0];
           localCenter[1] = A[1];
           localCenter[2] = A[2];
           min_exp = 100.0;
       }
   
       void GaussianShell::addPrim(const double e, const double c) {
           exps.push_back(e);
           coeffs.push_back(c);
           min_exp = e < min_exp ? e : min_exp;
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1aa362053769b5edcb1ec8552f10d52be6:

Function libecpint::qgen::Q1_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp:

Program Listing for File gshell.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/gshell.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GSHELL_HEAD
   #define GSHELL_HEAD
   
   #include <vector>
   #include <array>
   
   namespace libecpint {
   
       struct GaussianShell {
           std::vector<double> exps; 
           std::vector<double> coeffs; 
           
           double* centerVec; 
           bool local_ptr; 
           
           double localCenter[3];
           
           double min_exp; 
           
           int l; 
           int atom_id; 
           
           GaussianShell(double* A, int l);
           
           GaussianShell(const std::array<double, 3> & A, int l);
           
           GaussianShell(const GaussianShell& other) { 
               exps = other.exps;
               coeffs = other.coeffs;
               centerVec = other.centerVec;
               l = other.l;
               min_exp = other.min_exp;
               
               local_ptr = other.local_ptr;
               if (local_ptr) {
                   localCenter[0] = other.localCenter[0];
                   localCenter[1] = other.localCenter[1];
                   localCenter[2] = other.localCenter[2];
                   centerVec = localCenter;
               }
           } 
           
           void addPrim(double exp, double c);
           
           int nprimitive() const { return exps.size(); }
           
           int ncartesian() const { return ((l+1)*(l+2))/2; }
           
           double* center() const { return centerVec; };
           
           double exp(int i) const { return exps[i]; }
           
           double coef(int i) const { return coeffs[i]; }
           
           int am() const { return l; }
           
           GaussianShell copy() const {
               GaussianShell result(centerVec, l);
               result.min_exp = min_exp;
               result.local_ptr = local_ptr;
               if (local_ptr) {
                   result.localCenter[0] = localCenter[0];
                   result.localCenter[1] = localCenter[1];
                   result.localCenter[2] = localCenter[2];
                   result.centerVec = result.localCenter;
               }
               result.exps = exps;
               result.coeffs = coeffs;
               return result;
           }
       };
   
       struct ShellPairData {
           int LA;         
           int LB;         
           int maxLBasis;  
           int ncartA;     
           int ncartB;     
           double A[3];    
           double B[3];    
           double A2;      
           double Am;      
           double B2;      
           double Bm;      
           double RAB2;    
           double RABm;    
           bool A_on_ecp;  
           bool B_on_ecp;  
       };
   
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1ad7792ee9315576df3c805d0d0bbb6144:

Function libecpint::pow_19
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_19(const double)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp:

File qgen.hpp
=============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Generated header of generated integral functions. 



.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/qgen.hpp``)
--------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`)

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`)



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp`




Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__qgen`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac50f25410860af3e1c8203648ed6c8ae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a747ea3f093bdc2c16930a9e1573bd396`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a36960c9e50c9fce6a6c57aa8792eba3d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab6099b7e4ee5c323c4ec2c6e939ae699`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a02e67630bc3cc6771a283b931a0d0652`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a109fc4cf994a6ef27bc8377bb1221a6e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a89f11f190b2770ba1a6cd3bb0e252038`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7f4b88955a96847da3ebc5c50d56e6d1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab75f9a0fe020cc5eac1855af0311a1e9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5582b3de3f3f06a0dd219525f45efb3b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3bdb99b42efd94923116ddaf39352437`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a70ec2d64c8c090e8a736825df8ac69d2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a04ddf7b46cb449284fe3577036c66685`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab6b41ee8966c9f271f301c75a167fc9a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a09ff49cc3eeef8f281974772d5dffc0f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a70a5cf8de05207c9704d69acbfb5c2dd`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6179b5819e8e7e2f0335cfa6f36eb478`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3be412799b3edfe3eda545484b300a43`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1acd0676a7915b0a5e72926d61e3827eae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abdcc453ff2d05d577ea9cf4bce03402f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a832916799425771d4a829de5f488c7ab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af87f236fd427c9a80540e4117091be15`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a29fd2aafe4d193454e73909dd36e4969`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1f2fae93db97564c6223f7ab0b3a1345`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a379f0d0f5d764bf07e31a8e3e8156bce`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a299bb6bb7a5287c2773d9f4189a26d69`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6cd9cb22f70aaa25147c43511e335d41`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a93772fb9447d2664d73d8a3902fe1b54`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a99f72ea2f7322f8232307384bd228f5a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a8aa5fff0f4772cffde29ece307abe014`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3de0194aa3913e0e14a9eedb28f9ef99`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a261faecbcc2aaa80a07749ef804594d9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ad83d47512070305306433992d08d692a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afa8279cc29fea475b60c95ea30fbcf2a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab1fcb35c6f2cda3a171a75ae36f634d7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0d0c8cc09c76e3efd8f1cf130bd7264d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a01be990e258c413c9db8dd5624f0e071`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7a27208dca8f6953fd31e913e2fff149`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a31e6957c9ced525cbbdba4a9c443c260`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac9d76855b9f0e07c466603e836fc55cf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5aa67d887d7014b406df808637d97331`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a24a7957907649a616a90be7093af0a1e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5b65c0e188633d68627478d6dd43a613`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a23265e6ef8db8355d123e8ef88049d01`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae761a79d75fd6b29c1d7460c5032a2b1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a47eb555b220e5464d0533a99a06fec5f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a57c8f6c91db56996a928592cd15643d7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab1fb4b6ce6020d16a6214a109b2f37d9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af900a11994d6f09f0d83cdbc01a6cf3d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a030ab3019b1098321972e7f2aa3654bc`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a141f8229acaf6ffcc69bbf5f25fde085`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a581417956b752bd71c1a66450c2c13a7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6c9e60c9ff500fb4223a19fa56721bc3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9fad4906bd3daa6941148f903ac156df`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae9a7959c4fbc71226a3cd2a7c4cd1aa8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9634adfd5bb091641ec927cb13898103`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a69e412cf2def6bc140846356256e9aec`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a302b0e3066e69adac6e37c16bc223a36`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a10cf00d4a3d89367f96e19216396af68`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0e4355fdf3c94a702625fb08123cfffb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a029bfa957a1438d6be8340a178fa668d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6ca3f4990879d69f0947dc320cff7512`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a30db4a3e0d94645ef1061ebe49fdf79d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab0da4c56916b9b9ef3a1e82176429161`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab76bee96421fb775cd2fd16ff036664f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a179f27d18c3e44e4d6d77a0713ffbe2d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aba431d549c947101b9d20b8ae5cb521a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af9a4da1d53cb16463d2d1144809f55c7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab9eaa8ccb9792d3efb90ed7143af727a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a153993173e1a3f56f30abea2b345db76`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a04b44167d55d965bd4f0b5fca498a4f9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abe81347b5a52f811b3bac69af1f8f9bb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2f1b593fe7a6e4e2810e6b989f0e5e0f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1e41f79e7d2cae760fbb9efe656d79a6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab5c03c9c7a30f526f0ea06560fef3724`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0b77eccd5538829e047ae612b66b76a4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ad7b9a182da83d7b4f3db01182093b967`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac3aed6a829f009e3b82e84a90dc492c3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a418b910c14f22c51f09224b0b5b8897d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6db93ab24ebed670cd2a039350906744`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aad2b22ead6cc4dd2326b1e07fbd9a0e4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1adf8d2ab801d7cabb617ef95fe2346772`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a08659d03f2d3c193a4a29ad64ed5b2ab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a055cd957f9eeece918efd6aeac46e55b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0b468cc9891219de7934784a9c925e23`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa01fb986261df6407432d76739134ee1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab399ac3be9a089e30a15502bf58c38b9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a00da41091abc4253b7f7c50816157f4a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9a8592e8a00c0d7a195be80fb3bbd0ea`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1ff5364df2c3ea0e40d06a096bfde511`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2b53172b5b4103d7742ccf83fdb6e5b6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a15e49a02b122486b1eba9c47193a9a7f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afa1e5d62f4439f243a382d7a8cf09ce8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae94ff95331b2a7d7582d833e57e1a730`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4b956df3f1004dc6c367398fa3881724`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d08887dbffc07eb48888c65399b1df9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa351f08e3c67aaf89372bb6458977b7b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9a1b0cff031b0138fad4fba5dd78fb28`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a668ee5dc9c5ceb4e2012bd86327c3f82`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac022ef72b9ce182dc98297e3046bcf35`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a93d5d63f4cd6b286b87140d0c3cd84ae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aefd1940621859b33b496f59439b9a629`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7a397803096c0fa76aa8db724640a33e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af6aed704c528f33d41a3c8974f73933d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6a80fb42ebc7edfd76662bee54b73717`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6210949d0c67ed65d2eeaea4ae8591b5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d54034749c5ef29fa9d9902540aa1bf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afbeec27b9ba065ae00e4491b856e151a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a29d4cca2d7ad9972c8ae888f309ef52c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1c0f647f35ab7fd10a1a228f19df83a2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2bea2d6240c5f253e14587ab83a5d9dd`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a97e6fa3e95914a16d365a38fad6bf168`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa4e13d53a459d93019650b9bf0f64a58`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aea3e2f38c359b9861ebc8e6f8efc0292`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a43fc7ab5cf543daec745b0f6d033ffc5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af5ae441ae60111ff2860513ccf26148c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4ba269ea8b6a2e9c61df0785448a5778`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3c7bf43770a6435564e402ede936b8a8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2f3ffdd94d2b604fbffc55d77b944ef5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae76853a759ec019120382cd19a0e2d29`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a42856d19949953db8b9963a32fec27dc`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d3f70e323ad33a72441e7bc597491c2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6e1056154af784737309be994c116ca0`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a766e3dfc45273f3b325b7b47d83c8fa3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac6b5b1c66dc83827b0cc8971c0a89c5b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa3390aa653fcf192610379faf4cbadb8`

.. _exhale_function_namespacelibecpint_1_1qgen_1ab020c384dfc8c0f23cf165448b10216e:

Function libecpint::qgen::rolled_up_special
===========================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::rolled_up_special(int, int, int, const ThreeIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1df8ea2e2fe35050d24bd0541119fa29:

Function libecpint::qgen::Q3_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp:

File radial_quad.cpp
====================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/radial_quad.cpp``)
---------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1ab67f57b4dcbf7d27e721e40909390e0c:

Function libecpint::qgen::Q4_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5aa67d887d7014b406df808637d97331:

Function libecpint::qgen::Q1_1_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1acd0676a7915b0a5e72926d61e3827eae:

Function libecpint::qgen::Q0_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_variable_namespaceunrol__radial_1a582dde0241adf8b3a95b4459b4d49b2b:

Variable unrol_radial::f
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Variable Documentation
----------------------


.. doxygenvariable:: unrol_radial::f
.. _exhale_variable_namespacelibecpint_1a6305f5251f77037717df018fd2e56700:

Variable libecpint::SINH_1
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::SINH_1
.. _exhale_variable_namespacelibecpint_1a35fea7df6515abbb84fc029150055a28:

Variable libecpint::MAX_POW
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::MAX_POW
.. _exhale_struct_structlibecpint_1_1_sum_term:

Struct SumTerm
==============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::SumTerm
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1ac539befd8e56f73c61f5a32909e357da:

Function libecpint::qgen::Q1_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a029bfa957a1438d6be8340a178fa668d:

Function libecpint::qgen::Q1_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae761a79d75fd6b29c1d7460c5032a2b1:

Function libecpint::qgen::Q1_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a42856d19949953db8b9963a32fec27dc:

Function libecpint::qgen::Q5_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_struct_structlibecpint_1_1_radial_integral_1_1_parameters:

Struct RadialIntegral::Parameters
=================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`


Nested Relationships
--------------------

This struct is a nested type of :ref:`exhale_class_classlibecpint_1_1_radial_integral`.


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::RadialIntegral::Parameters
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1a4f3562bdf89c17a5fcd755bc68268194:

Function libecpint::qgen::Q4_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ade873e867bdb6757b88643c0958ab880:

Function libecpint::qgen::Q2_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_generate.cpp:

Program Listing for File generate.cpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_generate.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/generate.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   
   #include "generate.hpp"
   
   void generate_lists(int LA, int LB, int lam, libecpint::AngularIntegral& angInts) { 
       using namespace libecpint;
       
       // Create the code file
       std::string ofname = "generated/Q" + std::to_string(LA) + std::to_string(LB) + std::to_string(lam) + ".cpp"; 
       std::ofstream outfile(ofname); 
       
       if (!outfile.is_open())
           std::cerr << "Problems writing to file!" << std::endl; 
       else {
           
           std::cout << "Generating Q(" << LA << ", " << LB << ", " << lam << ")... " << std::flush; 
           
           // Top matter
           outfile << "// Generated as part of Libecpint, Copyright 2017 Robert A Shaw" << std::endl; 
           outfile << "#include \"qgen.hpp\"" << std::endl; 
           outfile << "namespace libecpint {" << std::endl << "namespace qgen {" << std::endl;
           outfile << "void Q" << LA << "_" << LB << "_" << lam << "(const ECP& U, const GaussianShell& shellA, const GaussianShell& shellB, "
               << "const FiveIndex<double> &CA, const FiveIndex<double> &CB, const TwoIndex<double> &SA, const TwoIndex<double> &SB, const double Am, const double Bm, "
                   << "const RadialIntegral &radint, const AngularIntegral& angint, const RadialIntegral::Parameters& parameters, ThreeIndex<double> &values) {" << std::endl << std::endl;
           
           double prefac = 16.0 * M_PI * M_PI;
           int na = 0; 
           int z1, z2;
           double ang_alpha, ang_beta, ang; 
           
           // Do we need to unrol the angular integrals too? 
           bool unrolling = LA <= maxUnrol && LB <= maxUnrol && (LA + LB + lam) <= 3*maxUnrol;
           
           // Store the terms and radials if unrolling, just radial indices if not
           std::vector<SumTerm> terms; 
           std::vector<Triple> radial_triples; 
           
           // Loop over cartesian functions in alpha order
           for (int x1 = LA; x1 >= 0; x1--) {
               for (int r1 = LA-x1; r1 >= 0; r1--) {
                   z1 = LA - x1 - r1; 
           
                   int nb = 0;
                   for (int x2 = LB; x2 >= 0; x2--) {
                       for (int y2 = LB - x2; y2 >= 0; y2--) {
                           z2 = LB - x2 - y2; 
                   
                           for (int alpha_x = 0; alpha_x <= x1; alpha_x++) {
                               for (int alpha_y = 0; alpha_y <= r1; alpha_y++) {
                                   for (int alpha_z = 0; alpha_z <= z1; alpha_z++) {
                                       int alpha = alpha_x + alpha_y + alpha_z; 
                               
                                       for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                           for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                               for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                                   int beta = beta_x + beta_y + beta_z; 
                                                   int N = alpha + beta;               
                                           
                                                   for (int lam1 = 0; lam1 <= lam + alpha; lam1++) {
                                                       int lam2start = (lam1 + N) % 2; 
                                                       for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                   
                                                           for (int mu1 = -lam1; mu1 <= lam1; mu1++) {
                                                               for (int mu2 = -lam2; mu2 <= lam2; mu2++) {
                                                                                                                                                                                       
                                                                   for (int mu = -lam; mu <= lam; mu++) {
                                                                       ang_alpha = angInts.getIntegral(alpha_x, alpha_y, alpha_z, lam, mu, lam1, mu1);
                                                                       ang_beta = angInts.getIntegral(beta_x, beta_y, beta_z, lam, mu, lam2, mu2); 
                                                                       ang = ang_alpha * ang_beta; 
                                                                       
                                                                       // Screen based on the angular integrals
                                                                       if (fabs(ang) > 1e-15) {
                                                                           if (unrolling) {
                                                                               SumTerm newTerm; 
                                                                               newTerm.SA = Pair(lam1, lam1+mu1); 
                                                                               newTerm.SB = Pair(lam2, lam2+mu2);
                                                                               newTerm.radial = Triple(N, lam1, lam2);
                                                                               newTerm.CA = Quintuple(0, na, alpha_x, alpha_y, alpha_z); 
                                                                               newTerm.CB = Quintuple(0, nb, beta_x, beta_y, beta_z); 
                                                                               newTerm.ang = prefac * ang;  
                                                                               newTerm.mu = lam+mu; 
                                                                               newTerm.na = na;
                                                                               newTerm.nb = nb;
                                                                   
                                                                               terms.push_back(newTerm); 
                                                                           }
                                                                           radial_triples.push_back({N, lam1, lam2}); 
                                                                       } 
                                                                   }
                                                                   
                                                               }
                                                           }
                                                       }
                                                   }
                                           
                                           
                                               }
                                           }
                                       }
                                   }
                               }
                           }
                   
                           nb++;
                       }
                   }
           
                   na++; 
               }
           }
           
           // Sort the radial triples and eliminate repeats
           std::sort(radial_triples.begin(), radial_triples.end()); 
           radial_triples.erase(std::unique(radial_triples.begin(), radial_triples.end()), radial_triples.end()); 
           
           // Determine the maximum number of base integrals needed across the set of all radial integrals
           int nbase = 0; 
           if (radial_triples.size() > 0) {
               Triple& tmax = radial_triples[radial_triples.size()-1]; 
               nbase = std::get<0>(tmax) + std::get<1>(tmax) - 1; 
               nbase = nbase < 0 ? 0 : nbase; 
           }
           
           // Sort the radials into two lists, depending on whether l1 <= l2 (radial_A), or l2 > l1 (radial_B)
           // swapping the order of l1/l2 in the latter case
           std::vector<Triple> radial_A, radial_B; 
           for (Triple& t : radial_triples) {
               if (std::get<1>(t) <= std::get<2>(t)) radial_A.push_back(t);  
               else radial_B.push_back({std::get<0>(t), std::get<2>(t), std::get<1>(t)});
           }
           
           // Compute the correctly ordered radials first
           outfile << "\tstd::vector<Triple> radial_triples_A = {" << std::endl; 
           bool first = true; 
           for (Triple& t : radial_A) {
               if (!first) outfile << "," << std::endl; 
               else first = false;
               outfile << "\t\t{" + std::to_string(std::get<0>(t)) + ", "
                   + std::to_string(std::get<1>(t)) + ", " 
                       + std::to_string(std::get<2>(t)) + "}"; 
           }
           outfile << "\t};" << std::endl << std::endl;  
           
           outfile << "\tThreeIndex<double> radials(" << lam+LA+LB+1 << ", " << lam+LA+1 << ", " << lam+LB+1 << ");" << std::endl; 
           outfile << "\tradint.type2(radial_triples_A, " << nbase << ", " << lam << ", U, shellA, shellB, Am, Bm, radials);" << std::endl << std::endl;
           
           // Now compute the reverse-ordered radials
           outfile << "\tstd::vector<Triple> radial_triples_B = {" << std::endl; 
           first = true;
           for (Triple& t : radial_B) {
               if (!first) outfile << "," << std::endl; 
               else first = false; 
               outfile << "\t\t{" + std::to_string(std::get<0>(t)) + ", "
                   + std::to_string(std::get<1>(t)) + ", " 
                       + std::to_string(std::get<2>(t)) + "}"; 
           }
           outfile << "\t};" << std::endl << std::endl;  
           
           outfile << "\tThreeIndex<double> radials_B(" << lam+LA+LB+1 << ", " << lam+LB+1 << ", " << lam+LA+1 << ");" << std::endl; 
           outfile << "\tradint.type2(radial_triples_B, " << nbase << ", " << lam << ", U, shellB, shellA, Bm, Am, radials_B);" << std::endl;
           // These need to be compressed into the radials array, with l1/l2 reversed back
           outfile << "\tfor (Triple& t : radial_triples_B) radials(std::get<0>(t), std::get<2>(t), std::get<1>(t)) = radials_B(std::get<0>(t), std::get<1>(t), std::get<2>(t));" << std::endl << std::endl; 
           
           if (unrolling) {
               // Print out the unrolled angular integral code if needed
               std::cout << "unrolling... " << std::flush; 
               for (auto& term : terms) outfile << "\t" << term << std::endl; 
           } else {
               // Just use the generic rolled-up angular integral code
               outfile << "\trolled_up(" << lam << ", " << LA << ", " << LB << ", radials, CA, CB, SA, SB, angint, values);" << std::endl; 
           }
           outfile << "}" << std::endl << "}" << std::endl << "}" << std::endl; 
           
           std::cout << "done." << std::endl; 
           outfile.close();
       }
   }
   
   int main(int argc, char* argv[]) {
       
       // Factorial singletons will not have been initialised
       libecpint::initFactorials();
       int maxL = libecpint::maxL;
       
       libecpint::AngularIntegral angInts(maxL, maxL); 
       angInts.compute(); 
       
       // Generate the qgen.hpp header file
       std::string header_name; 
       if (argc > 1) {
           header_name = argv[1]; 
           header_name += "qgen.hpp"; 
       } else {
           header_name = "generated/qgen"; 
       }
   
       std::ifstream qgen_part("generated/qgen.part");
       std::ofstream qgen_head(header_name); 
       if (!qgen_part.is_open() || !qgen_head.is_open()) 
           std::cerr << "Problem creating qgen header file!" << std::endl; 
       else {
           std::string line; 
           while(!qgen_part.eof()) {
               std::getline(qgen_part, line); 
               qgen_head << line << std::endl;  
           }
           qgen_part.close();
           
           // Loop over all possible (l1, l2, lam) integrals up to l1 = l2 = lam = maxL
           // with l1 <= l2, generating the code and adding the function to the header file.
           for (int j = 0; j <= maxL; j++) {
               for (int i = 0; i <= j; i++) {
                   for (int k = 0; k <= maxL; k++) {
                       generate_lists(i, j, k, angInts); 
                       qgen_head << "\tvoid Q" << i << "_" << j << "_" << k << "("
                                   << "const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, "
                                   << "const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, "
                                   << "const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);" << std::endl;
                   }
               }
           }
           qgen_head << std::endl << "}" << std::endl << "}" << std::endl; 
           qgen_head << "#endif" << std::endl; 
           qgen_head.close(); 
           
           // Now generate the function pointer array in ecpint_gen.cpp
           std::ifstream ecpgen_part("generated/ecpint_gen.part"); 
           std::ofstream ecpgen_head("generated/ecpint_gen.cpp"); 
           
           if (!ecpgen_part.is_open() || !ecpgen_head.is_open())
               std::cerr << "Problem reading/writing ecpgen file!" << std::endl;
           else {
               while(!ecpgen_part.eof()) {
                   std::getline(ecpgen_part, line); 
                   ecpgen_head << line << std::endl;  
               }
               ecpgen_part.close();
               
               for (int i =0; i <= maxL; i++) {
                   ecpgen_head << "\t\t{ "; 
                   
                   for (int j = 0; j<= maxL; j++) {
                       ecpgen_head << "\t\t\t{"; 
                       
                       int I = std::min(i, j);
                       int J = std::max(i, j); 
                       
                       for (int k = 0; k< maxL; k++) 
                           ecpgen_head << "qgen::Q" << I << "_" << J << "_" << k << ", ";
                       
                       ecpgen_head << "qgen::Q" << I << "_" << J << "_" << maxL << "}";
                       if (j != maxL) ecpgen_head << ","; 
                       ecpgen_head << std::endl;
                   }
                   
                   ecpgen_head << "\t\t}";
                   if (i != maxL) ecpgen_head << ","; 
                   ecpgen_head << std::endl; 
               }
               
               ecpgen_head << "\t};" << std::endl << "}" << std::endl;
               ecpgen_head.close();  
           }
       }
       return 0; 
   }

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp:

Program Listing for File gaussquad.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/gaussquad.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GC_QUAD_HEAD
   #define GC_QUAD_HEAD
   
   #include <functional>
   #include <vector>
   
   namespace libecpint {
   
       enum GCTYPE {
           ONEPOINT, 
           TWOPOINT  
       };
   
       class GCQuadrature {
       private:
           int maxN; 
           int M;  
       
           std::vector<double> x; 
           std::vector<double> w; 
    
           double I; 
       
           GCTYPE t; 
       
           double sumTerms(const std::function<double(double, const double*, int)> &f,
                     const double *p, int limit, int start, int end, int shift, int skip) const;
   
       public:
           
           GCQuadrature();
           
           GCQuadrature(const GCQuadrature &other);
       
           void initGrid(int points, GCTYPE t);
       
           std::pair<double, bool> integrate(
               std::function<double(double, const double*, int)> &f,
               const double *params, double tolerance, int start, int end) const;
       
           void transformZeroInf();
           
           void transformRMinMax(double z, double p);  // Transfromation from [-1, 1] to [rmin, rmax] from Flores06
           void untransformRMinMax(double z, double p);
       
           int getN() const { return maxN; }
       
       std::vector<double>& getX() { return x; }
       const std::vector<double>& getX() const { return x; }
       };
   }
   
   #endif

Full API
--------

Namespaces
**********


.. toctree::
   :maxdepth: 5

   namespace_libecpint.rst

.. toctree::
   :maxdepth: 5

   namespace_libecpint__aux.rst

.. toctree::
   :maxdepth: 5

   namespace_libecpint__qgen.rst

.. toctree::
   :maxdepth: 5

   namespace_makelist.rst

.. toctree::
   :maxdepth: 5

   namespace_std.rst

.. toctree::
   :maxdepth: 5

   namespace_sympy.rst

.. toctree::
   :maxdepth: 5

   namespace_unrol_radial.rst

Classes and Structs
*******************


.. toctree::
   :maxdepth: 5

   structlibecpint_1_1aux_1_1gen__seq.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1aux_1_1seq.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_e_c_p.rst

.. toctree::
   :maxdepth: 5

   struct_classlibecpint_1_1_e_c_p_basis.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_e_c_p_integrator.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_five_index.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_gaussian_e_c_p.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_gaussian_shell.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_radial_integral_1_1_parameters.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_seven_index.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_sum_term.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_three_index.rst

.. toctree::
   :maxdepth: 5

   structlibecpint_1_1_two_index.rst

.. toctree::
   :maxdepth: 5

   classlibecpint_1_1_angular_integral.rst

.. toctree::
   :maxdepth: 5

   classlibecpint_1_1_bessel_function.rst

.. toctree::
   :maxdepth: 5

   classlibecpint_1_1_e_c_p_integral.rst

.. toctree::
   :maxdepth: 5

   classlibecpint_1_1_g_c_quadrature.rst

.. toctree::
   :maxdepth: 5

   classlibecpint_1_1_radial_integral.rst

.. toctree::
   :maxdepth: 5

   class_structlibecpint_1_1_shell_pair_data.rst

.. toctree::
   :maxdepth: 5

   classunrol__radial_1_1_qijk.rst

Enums
*****


.. toctree::
   :maxdepth: 5

   enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f.rst

Functions
*********


.. toctree::
   :maxdepth: 5

   function_generate_8cpp_1a45aa3f4947203d38d9cb52b96d002cea.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1aux_1a8e2ec9ac4e466e11814c592a83efb66f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a2c6257f0f39de7233558e384908f1526.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a16e0a77a3022ff74a1fbb6eccba88c4c.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a0d3d7448d52abd739d6d100afa6d4e8a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a3a4ed9b49d76dd6974d2dbc6bb181ab8.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a23ce2cda098d601b0fddfb10b971e33f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a321e63264d2ee5ec80e5aa98ab5f2a31.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1ab8d8f23abac900581a1b074df5151bfa.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a764f6b0f657d4b76cd030593a81f8161.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a17491fad5ad55b86c80bccd068067373.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a274e6578163d01f8c1bd6b24f0f1e061.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1adf95d3c9da1c27fbbbe785fb7d4c3419.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a12c8c970bff9ab1318e774a4637059fb.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a5ebc6e4869b8a3dab9286895629c19fc.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a697a408875eb033819881bc8d5fd3cec.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a60980f8f3c0f2ce3bfa35d1ab1ffe612.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a44095a8d0f5ab3e8bf4770a0ecd39a49.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1ad7792ee9315576df3c805d0d0bbb6144.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1aeea8f0398e91f9c4c0abc5087c68208a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1aa2a7bd43b3c7267b69a5a3faa3adf313.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1adb6835f6678e044793635ea74137610c.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1af1b4030182805b2b87939f0be0bb1f68.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1ae8e9cac2c5167fee6077b8d5b38c879d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a691287591ae556167f12eef21d9605d3.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1afc2d0fbd27b79b1cfb7a933a4f8f86af.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1aceff25bd00ac616a0c1679c43c757c25.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a125307aa5575e22d32bc381c0ddb598d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1af586e0d10f4e89ae23350208eae35381.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1a3d3ec1164653607a1a2a66e71c160905.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ac50f25410860af3e1c8203648ed6c8ae.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a747ea3f093bdc2c16930a9e1573bd396.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a36960c9e50c9fce6a6c57aa8792eba3d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab6099b7e4ee5c323c4ec2c6e939ae699.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a02e67630bc3cc6771a283b931a0d0652.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a109fc4cf994a6ef27bc8377bb1221a6e.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a89f11f190b2770ba1a6cd3bb0e252038.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a7f4b88955a96847da3ebc5c50d56e6d1.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab75f9a0fe020cc5eac1855af0311a1e9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a5582b3de3f3f06a0dd219525f45efb3b.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a3bdb99b42efd94923116ddaf39352437.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a70ec2d64c8c090e8a736825df8ac69d2.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a04ddf7b46cb449284fe3577036c66685.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab6b41ee8966c9f271f301c75a167fc9a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a09ff49cc3eeef8f281974772d5dffc0f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a70a5cf8de05207c9704d69acbfb5c2dd.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6179b5819e8e7e2f0335cfa6f36eb478.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a3be412799b3edfe3eda545484b300a43.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1acd0676a7915b0a5e72926d61e3827eae.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1abdcc453ff2d05d577ea9cf4bce03402f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a832916799425771d4a829de5f488c7ab.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af87f236fd427c9a80540e4117091be15.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a29fd2aafe4d193454e73909dd36e4969.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a1f2fae93db97564c6223f7ab0b3a1345.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a379f0d0f5d764bf07e31a8e3e8156bce.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a299bb6bb7a5287c2773d9f4189a26d69.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6cd9cb22f70aaa25147c43511e335d41.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a93772fb9447d2664d73d8a3902fe1b54.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a99f72ea2f7322f8232307384bd228f5a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a8aa5fff0f4772cffde29ece307abe014.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a3de0194aa3913e0e14a9eedb28f9ef99.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a261faecbcc2aaa80a07749ef804594d9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ad83d47512070305306433992d08d692a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1afa8279cc29fea475b60c95ea30fbcf2a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab1fcb35c6f2cda3a171a75ae36f634d7.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a0d0c8cc09c76e3efd8f1cf130bd7264d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a01be990e258c413c9db8dd5624f0e071.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a7a27208dca8f6953fd31e913e2fff149.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a31e6957c9ced525cbbdba4a9c443c260.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ac9d76855b9f0e07c466603e836fc55cf.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a5aa67d887d7014b406df808637d97331.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a24a7957907649a616a90be7093af0a1e.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a5b65c0e188633d68627478d6dd43a613.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a23265e6ef8db8355d123e8ef88049d01.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ae761a79d75fd6b29c1d7460c5032a2b1.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a47eb555b220e5464d0533a99a06fec5f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a57c8f6c91db56996a928592cd15643d7.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab1fb4b6ce6020d16a6214a109b2f37d9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af900a11994d6f09f0d83cdbc01a6cf3d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a030ab3019b1098321972e7f2aa3654bc.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a141f8229acaf6ffcc69bbf5f25fde085.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a581417956b752bd71c1a66450c2c13a7.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6c9e60c9ff500fb4223a19fa56721bc3.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a9fad4906bd3daa6941148f903ac156df.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ae9a7959c4fbc71226a3cd2a7c4cd1aa8.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a9634adfd5bb091641ec927cb13898103.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a69e412cf2def6bc140846356256e9aec.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a302b0e3066e69adac6e37c16bc223a36.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a10cf00d4a3d89367f96e19216396af68.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a0e4355fdf3c94a702625fb08123cfffb.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a029bfa957a1438d6be8340a178fa668d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6ca3f4990879d69f0947dc320cff7512.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a30db4a3e0d94645ef1061ebe49fdf79d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab0da4c56916b9b9ef3a1e82176429161.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab76bee96421fb775cd2fd16ff036664f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a179f27d18c3e44e4d6d77a0713ffbe2d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aba431d549c947101b9d20b8ae5cb521a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af9a4da1d53cb16463d2d1144809f55c7.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab9eaa8ccb9792d3efb90ed7143af727a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a153993173e1a3f56f30abea2b345db76.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a04b44167d55d965bd4f0b5fca498a4f9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1abe81347b5a52f811b3bac69af1f8f9bb.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2f1b593fe7a6e4e2810e6b989f0e5e0f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a1e41f79e7d2cae760fbb9efe656d79a6.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab5c03c9c7a30f526f0ea06560fef3724.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a0b77eccd5538829e047ae612b66b76a4.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ad7b9a182da83d7b4f3db01182093b967.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ac3aed6a829f009e3b82e84a90dc492c3.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a418b910c14f22c51f09224b0b5b8897d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6db93ab24ebed670cd2a039350906744.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aad2b22ead6cc4dd2326b1e07fbd9a0e4.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1adf8d2ab801d7cabb617ef95fe2346772.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a08659d03f2d3c193a4a29ad64ed5b2ab.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a055cd957f9eeece918efd6aeac46e55b.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a0b468cc9891219de7934784a9c925e23.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aa01fb986261df6407432d76739134ee1.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab399ac3be9a089e30a15502bf58c38b9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a00da41091abc4253b7f7c50816157f4a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a9a8592e8a00c0d7a195be80fb3bbd0ea.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a1ff5364df2c3ea0e40d06a096bfde511.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2b53172b5b4103d7742ccf83fdb6e5b6.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a15e49a02b122486b1eba9c47193a9a7f.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1afa1e5d62f4439f243a382d7a8cf09ce8.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ae94ff95331b2a7d7582d833e57e1a730.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a4b956df3f1004dc6c367398fa3881724.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2d08887dbffc07eb48888c65399b1df9.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aa351f08e3c67aaf89372bb6458977b7b.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a9a1b0cff031b0138fad4fba5dd78fb28.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a668ee5dc9c5ceb4e2012bd86327c3f82.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ac022ef72b9ce182dc98297e3046bcf35.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a93d5d63f4cd6b286b87140d0c3cd84ae.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aefd1940621859b33b496f59439b9a629.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a7a397803096c0fa76aa8db724640a33e.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af6aed704c528f33d41a3c8974f73933d.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6a80fb42ebc7edfd76662bee54b73717.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6210949d0c67ed65d2eeaea4ae8591b5.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2d54034749c5ef29fa9d9902540aa1bf.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1afbeec27b9ba065ae00e4491b856e151a.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a29d4cca2d7ad9972c8ae888f309ef52c.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a1c0f647f35ab7fd10a1a228f19df83a2.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2bea2d6240c5f253e14587ab83a5d9dd.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a97e6fa3e95914a16d365a38fad6bf168.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aa4e13d53a459d93019650b9bf0f64a58.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aea3e2f38c359b9861ebc8e6f8efc0292.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a43fc7ab5cf543daec745b0f6d033ffc5.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af5ae441ae60111ff2860513ccf26148c.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a4ba269ea8b6a2e9c61df0785448a5778.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a3c7bf43770a6435564e402ede936b8a8.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2f3ffdd94d2b604fbffc55d77b944ef5.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ae76853a759ec019120382cd19a0e2d29.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a42856d19949953db8b9963a32fec27dc.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a2d3f70e323ad33a72441e7bc597491c2.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a6e1056154af784737309be994c116ca0.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1a766e3dfc45273f3b325b7b47d83c8fa3.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ac6b5b1c66dc83827b0cc8971c0a89c5b.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1aa3390aa653fcf192610379faf4cbadb8.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1af1816608e31f73731cb510619099400e.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1_1qgen_1ab020c384dfc8c0f23cf165448b10216e.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1ac8004320c2b47b1ce75ab1ccfff376e4.rst

.. toctree::
   :maxdepth: 5

   function_namespacelibecpint_1ad93011f81c46d555725bff0a0fc5aaf6.rst

.. toctree::
   :maxdepth: 5

   function_generate_8cpp_1a0ddf1224851353fc92bfbff6f499fa97.rst

.. toctree::
   :maxdepth: 5

   function_namespaceunrol__radial_1a48a1059eae24c36cd6464073577d147a.rst

.. toctree::
   :maxdepth: 5

   function_namespaceunrol__radial_1a2cd46d9b308d3d493fdd7a516019c717.rst

.. toctree::
   :maxdepth: 5

   function_namespaceunrol__radial_1aff823186ee3dc7e823e3f1a858233df6.rst

.. toctree::
   :maxdepth: 5

   function_namespaceunrol__radial_1afc2f4f223df08979b137c507be4bbd37.rst

Variables
*********


.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a076d4d1e17ab2a37661480ba095329d7.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a02017a941eee202982bab7731ead620d.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1ae0ba3cdb903f3057f168bfaa5495bba0.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1acdba31532082cde9ce50b5c6ecd2b442.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a4ecb557cc8bf8d94cfa80855985007bf.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a975e7b9e0f57709418adede308d80405.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a683275f366eb38bfcc526bf5264d9376.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a4fc3cf89f4b0b1787baabc364a16e377.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a5f751be5271cc840a3025f0e0ee026f2.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a190a564f849660c170e298aba2181d0a.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a6a8879ed7b1d299f2b2e92b105cce919.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a20c4903045164881b8dedf0d6a6ed0fb.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a92d5ae635e6e5d78682fd89ce537a7a3.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a32d2ef087e028b702c316bd2875036ec.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1ae8056358eb2736d93b3a78dd1428555c.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a007003a219fbc1cce6980a389b1013bc.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a069479eb4b49ece5f8f9651b5f87c777.rst

.. toctree::
   :maxdepth: 5

   variable_namespacelibecpint_1a37d6807785ad49c55bbe8b56deab2be8.rst

.. toctree::
   :maxdepth: 5

   variable_namespacemakelist_1a7a96fbd7cb2ac37090089795370aedb7.rst

.. toctree::
   :maxdepth: 5

   variable_namespacemakelist_1a92f763e70ec614d7cc630b6b3afc201e.rst

.. toctree::
   :maxdepth: 5

   variable_namespacemakelist_1ae1a361014e097535367c775cc83758fd.rst

.. toctree::
   :maxdepth: 5

   variable_namespaceunrol__radial_1a582dde0241adf8b3a95b4459b4d49b2b.rst

.. toctree::
   :maxdepth: 5

   variable_namespaceunrol__radial_1a02363db1e3121f4cb64855282f206fff.rst

.. toctree::
   :maxdepth: 5

   variable_namespaceunrol__radial_1a7e0a7548eed4ebb942e94e7b9405f123.rst

.. toctree::
   :maxdepth: 5

   variable_namespaceunrol__radial_1a032ec358895dd239986cf46342a0de86.rst

Defines
*******


.. toctree::
   :maxdepth: 5

   define_mathutil_8cpp_1a9450534f682d7a567d3872551afa2ec4.rst

.. toctree::
   :maxdepth: 5

   define_api_8hpp_1a9c5be1c4ba084c752edba30f62c5da6d.rst

.. toctree::
   :maxdepth: 5

   define_mathutil_8hpp_1a620539bb392918432be69023bb266dfb.rst

.. toctree::
   :maxdepth: 5

   define_mathutil_8hpp_1ae71449b1cc6e6250b91f539153a7a0d3.rst

.. toctree::
   :maxdepth: 5

   define_mathutil_8hpp_1a30bbac291639d5f7d964a92fa8742b94.rst

.. toctree::
   :maxdepth: 5

   define_mathutil_8hpp_1aaf00c7de57af68f4e9d7acc87adb8d87.rst

.. toctree::
   :maxdepth: 5

   define_ecpint_8hpp_1a8546f51f524d0baff0bf3f3b321fbc9b.rst

Typedefs
********


.. toctree::
   :maxdepth: 5

   typedef_namespacelibecpint_1a48b53f3b6bfb449ec300ab57fc03763c.rst

.. toctree::
   :maxdepth: 5

   typedef_namespacelibecpint_1a7676a778fedc78dfdc0495c3319a2730.rst

.. toctree::
   :maxdepth: 5

   typedef_namespacelibecpint_1a4dc36ca1c5a9247d8bfaac304a7df40f.rst

.. toctree::
   :maxdepth: 5

   typedef_namespacelibecpint_1af2651847fa01dec731554db1e7b273fd.rst
.. _exhale_function_namespacelibecpint_1_1qgen_1a713950e1242796aa631a0d0aab602a42:

Function libecpint::qgen::Q0_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af85290fe10772c77a0e271ef9a294439:

Function libecpint::qgen::Q0_1_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1ab8d8f23abac900581a1b074df5151bfa:

Function libecpint::pow_1
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_1(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a0e99841554fc02fa5d534f6314e28134:

Function libecpint::qgen::Q0_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp:

Program Listing for File multiarr.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/multiarr.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef MULTIARR_HEAD
   #define MULTIARR_HEAD
   
   #include <vector>
   #include <tuple> 
   #include <algorithm>
   #include <sstream>
   
   namespace libecpint {
   
       using Pair = std::tuple<int, int>;
       using Triple = std::tuple<int, int, int>;
       using Quintuple = std::tuple<int, int, int, int, int>; 
       using Heptuple = std::tuple<int, int, int, int, int, int, int>; 
       
       namespace aux{
           template<std::size_t...> struct seq{};
           template<std::size_t N, std::size_t... Is>
           struct gen_seq : gen_seq<N-1, N-1, Is...>{};
           template<std::size_t... Is>
           struct gen_seq<0, Is...> : seq<Is...>{};
           template<class Ch, class Tr, class Tuple, std::size_t... Is>
           void print_tuple(std::basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){
               using swallow = int[];
               (void)swallow{0, (void(os << (Is == 0? "" : ", ") << std::get<Is>(t)), 0)...};
           }
       } 
       
       template<class Ch, class Tr, class... Args>
       auto operator<<(std::basic_ostream<Ch, Tr>& os, std::tuple<Args...> const& t)
           -> std::basic_ostream<Ch, Tr>&
       {
           os << "(";
           aux::print_tuple(os, t, aux::gen_seq<sizeof...(Args)>());
           return os << ")";
       }
       
       template<typename T>
       struct TwoIndex {
           int dims[2];
           std::vector<T> data;
           T& operator()(const int i, const int j) { return data[i * dims[1] + j]; }
           T operator()(const int i, const int j) const { return data[i * dims[1] + j]; }
           void assign(int dim1, int dim2, T value) {
               dims[0] = dim1; dims[1] = dim2;
               data.resize(dim1 * dim2);
               std::fill(data.begin(), data.end(), value);
           }
           TwoIndex<T> transpose() const {
               TwoIndex<T> result(dims[1], dims[0]);
               for (int i = 0; i < dims[0]; i++) {
                   for (int j = 0; j < dims[1]; j++)
                       result.data[j * dims[0] + i] = data[i * dims[1] + j];
               }
               return result;
           }
           void add(const TwoIndex<T>& other) {
               std::transform (data.begin(), data.end(), other.data.begin(), data.begin(), std::plus<T>());
           }
           
           void multiply(T k) {
               std::transform(data.begin(), data.end(), data.begin(), [&k](T& c){return c*k;});
           }
           TwoIndex() { dims[0] = dims[1] = 0; }
           TwoIndex(const int dim1, const int dim2) {
               dims[0] = dim1; dims[1] = dim2;
               data.resize(dim1 * dim2);
           }
           TwoIndex(const int dim1, const int dim2, const T value) { assign(dim1, dim2, value); }
           TwoIndex(const TwoIndex<T> &other) { 
               data = other.data;
               dims[0] = other.dims[0]; dims[1] = other.dims[1];
           }
       };
   
       template<typename T>
       struct ThreeIndex {
           int dims[3];
           std::vector<T> data;
           T& operator()(const int i, const int j, const int k) { return data[i*dims[2]*dims[1] + j*dims[2] + k]; }
           T operator()(const int i, const int j, const int k) const { return data[i*dims[2]*dims[1] + j*dims[2] + k]; }
           ThreeIndex(){ dims[0] = 0; dims[1] = 0; dims[2] = 0; }
           ThreeIndex(const int dim1, const int dim2, const int dim3) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3;
               data.resize(dim1 * dim2 * dim3);
           }
           ThreeIndex(const ThreeIndex<T> &other)  { 
               data = other.data;
               for (int n = 0; n < 3; n++) dims[n] = other.dims[n]; 
           }
           void fill(const T value) { std::fill(data.begin(), data.end(), value); }
       };
   
       template<typename T>
       struct FiveIndex {
           int dims[5];
           std::vector<T> data;
           T& operator()(const int i, const int j, const int k, const int l, const int m) {
               return data[m + dims[4] * (l + dims[3] * (k + dims[2] * (j + dims[1] * i)))]; 
           }
           T operator()(const int i, const int j, const int k, const int l, const int m) const {
               return data[m + dims[4] * (l + dims[3] * (k + dims[2] * (j + dims[1] * i)))];
           }
           FiveIndex() { dims[0] = dims[1] = dims[2] = dims[3] = dims[4] = 0; }
           FiveIndex(const int dim1, const int dim2, const int dim3, const int dim4, const int dim5) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3; dims[3] = dim4; dims[4] = dim5;
               data.resize(dim1 * dim2 * dim3 * dim4 * dim5);
           }
           FiveIndex(const FiveIndex<T> &other) { 
               data = other.data;
               for (int n = 0; n < 5; n++) dims[n] = other.dims[n]; 
           }
       };
   
       template<typename T>
       struct SevenIndex {
           int dims[7];
           int mults[6];
           std::vector<T> data;
           T& operator()(const int i, const int j, const int k, const int l, const int m, const int n, const int p) {
               return data[p + mults[5]*n + mults[4]*m + mults[3]*l + mults[2]*k + mults[1]*j + mults[0]*i];
           }
           T operator()(const int i, const int j, const int k, const int l, const int m, const int n, const int p) const {
               return data[p + mults[5]*n + mults[4]*m + mults[3]*l + mults[2]*k + mults[1]*j + mults[0]*i];
           }
           SevenIndex() { dims[0] = dims[1] = dims[2] = dims[3] = dims[4] = dims[5] = dims[6] = 0; 
                          mults[0] = mults[1] = mults[2] = mults[3] = mults[4] = mults[5] = 0; }
           SevenIndex(const int dim1, const int dim2, const int dim3, const int dim4, const int dim5, const int dim6, const int dim7) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3; dims[3] = dim4; dims[4] = dim5; dims[5] = dim6; dims[6] = dim7;
               data.resize(dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7);
               mults[5] = dim7;
               mults[4] = dim7*dim6;
               mults[3] = mults[4]*dim5;
               mults[2] = mults[3]*dim4;
               mults[1] = mults[2]*dim3;
               mults[0] = mults[1]*dim2;
           }
           SevenIndex(const SevenIndex<T> &other) {
               data = other.data;
               for (int n = 0; n < 6; n++) {
                   dims[n] = other.dims[n];
                   mults[n] = other.mults[n];
               }
               dims[6] = other.dims[6];
           }
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a1ff5364df2c3ea0e40d06a096bfde511:

Function libecpint::qgen::Q2_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae25acfbdd96fea07bf14a59e02fc7d54:

Function libecpint::qgen::Q2_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa968da184da74332ebb64840fca37563:

Function libecpint::qgen::Q0_0_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae1ab26e9c37e6099370e5eac81e387bb:

Function libecpint::qgen::Q2_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab3e29d310b8765ca9dc9ae7e881b42bb:

Function libecpint::qgen::Q0_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a10cf00d4a3d89367f96e19216396af68:

Function libecpint::qgen::Q1_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a34b21851b77f09f49aea3c0ca550f9b2:

Function libecpint::qgen::Q5_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1adf8d2ab801d7cabb617ef95fe2346772:

Function libecpint::qgen::Q2_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a764f6b0f657d4b76cd030593a81f8161:

Function libecpint::pow_10
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_10(const double)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp:

File gshell.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/gshell.cpp``)
------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp.rst





Includes
--------


- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1aeea8f0398e91f9c4c0abc5087c68208a:

Function libecpint::pow_2
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_2(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a302b0e3066e69adac6e37c16bc223a36:

Function libecpint::qgen::Q1_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a01be990e258c413c9db8dd5624f0e071:

Function libecpint::qgen::Q1_1_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_struct_structlibecpint_1_1aux_1_1seq:

Template Struct seq
===================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::aux::seq
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1a29fd2aafe4d193454e73909dd36e4969:

Function libecpint::qgen::Q0_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp:

Program Listing for File mathutil.cpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/mathutil.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "mathutil.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       double FAC[MAX_FAC];
       double DFAC[MAX_DFAC];
       
       double pow_m2(const double z) { return 1.0/(z*z); }
       double pow_m1(const double z) { return 1.0/z; }
       double pow_0(const double z) { return 1.0; }
       double pow_1(const double z) { return z; }
       double pow_2(const double z) { return z*z; }
       double pow_3(const double z) { return z*z*z; }
       double pow_4(const double z) { double z2 = z*z; return z2*z2; }
       double pow_5(const double z) { double z2 = z*z; double z3 = z2*z; return z2*z3; };
       double pow_6(const double z) { double z2 = z*z; return z2*z2*z2; }
       double pow_7(const double z) { double z2 = z*z; double z3 = z*z2; return z3*z2*z2; }
       double pow_8(const double z) { double z2 = z*z; double z4 = z2*z2; return z4*z4; }
       double pow_9(const double z) { double z3 = z*z*z; return z3*z3*z3; }
       double pow_10(const double z) { double z2 = z*z; double z3 = z*z2; double z5= z2*z3; return z5*z5; }
       double pow_11(const double z) { double z2 = z*z; double z3 = z*z2; return z3*z3*z3*z2; }
       double pow_12(const double z) { double z3 = z*z*z; double z6 = z3*z3; return z6*z6; }
       double pow_13(const double z) { double z3 = z*z*z; double z6 = z3*z3; return z6*z6*z; }
       double pow_14(const double z) { double z2 = z*z; double z3 = z*z2; double z7 = z2*z2*z3; return z7*z7; }
       double pow_15(const double z) { double z2 = z*z; double z3 = z*z2; double z5 = z2*z3; return z5*z5*z5; }
       double pow_16(const double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8; }
       double pow_17(const double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8*z;}
       double pow_18(const double z) { double z3 = z*z*z; double z9 = z3*z3*z3; return z9*z9; }
       double pow_19(const double z) { double z3 = z*z*z; double z9 = z3*z3*z3; return z9*z9*z; }
       double pow_20(const double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8*z4; }
       
       void initFactorials() {
       #ifndef FAC_INIT
       #define FAC_INIT
               FAC[0] = 1.0;
               DFAC[0] = 1.0;
               DFAC[1] = 1.0;
           
               for (int i = 1; i < MAX_FAC; i++)  FAC[i] = double(i) * FAC[i-1]; 
               for (int i = 2; i < MAX_DFAC; i++) DFAC[i] = double(i) * DFAC[i-2];
       #endif
       }
       
       // Compute all the real spherical harmonics Slm(theta, phi) for l,m up to lmax
       // x = std::cos (theta)
       TwoIndex<double> realSphericalHarmonics(const int lmax, const double x, const double phi){
           TwoIndex<double> rshValues(lmax+1, 2*lmax+1, 0.0);
   
           if (lmax > 0) {
               // First calculate the associated Legendre polynomials, Plm(std::cos theta), ustd::sing the recursion relation
               // (l-m)Plm = x(2l - 1)P{l-1}m - (l+m-1)P{l-2}m
               // along with the zeroth order term
               // Pmm = (-1)^m (2m-1)!!(1-x^2)^{m/2}
               double x2 = x * x;
               double Plm[lmax+1][lmax+1]; 
               // First get all Pmm terms
               Plm[0][0] = 1.0;
               double sox2 = std::sqrt(std::max(0.0, 1.0 - x2));
               double ox2m = 1.0;
               for (int m = 1; m <= lmax; m++) {
                   ox2m *= -sox2;
                   Plm[m][m] = ox2m * DFAC[2*m-1]; 
               }
           
               // Then increment l for each m
               Plm[1][0] = x;
               Plm[0][1] = 0.0;
               for (int l = 2; l <= lmax; l++) {
                   ox2m = x * (2*l - 1);
                   for (int m = 0; m < l; m++) {
                       Plm[l][m] = ox2m * Plm[l-1][m] - (l + m - 1)*Plm[l-2][m];
                       Plm[l][m] /= ((double) (l -m));
                   }
                   Plm[l-1][l] = 0.0;
               }
           
               // Now we compute the spherical harmonics via
               // Slm(theta, phi) = Clm * Plm(std::cos(theta)) * std::cos(m * phi), m > 0
               // Sl{-m}(theta, phi) = Clm * Plm(std::cos(theta)) * std::sin(m * phi)
               // Sl0(theta, phi) = std::sqrt(2) * Cl0 * Pl0(std::cos(theta))
               // where Clm^2 = (2l + 1)*(l - m)! / (8*pi * (l+m)!)
               double osq4pi = 1.0 / std::sqrt(4.0 * M_PI); 
               int sign;
               for (int l = 0; l <= lmax; l++) {
                   rshValues(l, l) = osq4pi * std::sqrt(2.0 * l + 1.0) * Plm[l][0];
                   sign = -1;
                   for (int m = 1; m <= l; m++) {
                       ox2m = (2.0 * l + 1.0) * FAC[l-m] / FAC[l+m];
                       ox2m = sign * osq4pi * std::sqrt(2.0 * ox2m) * Plm[l][m];
                       rshValues(l, l+m) = ox2m * std::cos(m * phi);
                       rshValues(l, l-m) = ox2m * std::sin(m * phi);
                       sign *= -1;
                   }
               }
           
           } else {
               rshValues(0, 0) = 1.0 / std::sqrt(4.0 * M_PI);
           }
           
           return rshValues;
       }
       
       double frobenius_norm(const TwoIndex<double>& mat) {
           return std::sqrt(std::inner_product(mat.data.begin(), mat.data.end(), mat.data.begin(), 0.0));
       }
       
   }
.. _exhale_struct_structlibecpint_1_1_three_index:

Template Struct ThreeIndex
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::ThreeIndex
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp:

File testutil.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include>` (``/Users/robertshaw/devfiles/libecpint_new/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/testutil.hpp``)
------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp.rst





Includes
--------


- ``cmath``

- ``fstream``

- ``iomanip``

- ``iostream``

- ``sstream``

- ``string``

- ``vector``






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a2c6257f0f39de7233558e384908f1526`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp:

Program Listing for File testutil.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/testutil.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef TESTING_HEAD
   #define TESTING_HEAD
   
   #include <iostream>
   #include <iomanip>
   #include <fstream>
   #include <cmath>
   #include <string>
   #include <sstream>
   #include <vector>
   
   namespace libecpint {
   
   template <typename T>
   int check_file(std::string filename, std::vector<T>& results, double thresh=1e-5, double precision=1e-10) {
       std::ifstream input_file(filename); 
       if (input_file.is_open()) {
           
           std::vector<T> benchmark; 
           std::string line;
           while(!input_file.eof()) {
               std::getline(input_file, line); 
               T converted_value; 
               std::stringstream ss(line);
               ss >> converted_value;
               benchmark.push_back(converted_value); 
           }
           
           if (benchmark.size() != results.size()) {
               std::cerr << "Size of output is incorrect!" << std::endl;
               std::cerr << "File has " << benchmark.size() << " records" << std::endl;
               std::cerr << "Results has " << results.size()  << " records" << std::endl;
               return 1;
           } else {
               double error = 0.0;
               for (int i = 0; i < benchmark.size(); i++) {
                   double abserror = std::abs(benchmark[i] - results[i]);
                   if (abserror > precision) {
                       std::cout << std::setw(10) << "Line " << std::setw(5) << i 
                           << std::setw(5) << ":" << std::setw(15) <<  benchmark[i] 
                           << " / " << std::setw(15) << results[i] << std::endl;
                   }
                   if (std::abs(benchmark[i])>precision) error += abserror / std::abs(benchmark[i]);
               }
               error /= double(benchmark.size());
       
               if (error > thresh) {
                   std::cerr << "Average error in output is " << error << " percent!" << std::endl;
                   return 1;
               } else {
                   std::cout << "Test passed!" << std::endl; 
               }
           }
           
       } else {
           std::cerr << "Problem opening results file " << filename << std::endl; 
           return 1; 
       }
       
       return 0;
   }
   
   } // end namespace
   #endif

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp:

Program Listing for File ecpint.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/ecpint.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ECPINT_HEAD
   #define ECPINT_HEAD
   
   #include <vector>
   #include <array>
   #include "multiarr.hpp"
   #include "gaussquad.hpp"
   #include "ecp.hpp"
   #include "bessel.hpp"
   #include "radial.hpp"
   #include "angular.hpp"
   #include "gshell.hpp"
   
   #include "config.hpp"
   
   namespace libecpint {
   
   #define N_INDEX(l, m) (((l+m)*(l+m+1))/2 + m)
   
       class ECPIntegral
       {
       private:
           RadialIntegral radInts; 
           AngularIntegral angInts; 
   
       static constexpr double tolerance = 1e-12;
       
           double calcC(int a, int m, double A) const;
           
           static void(*QGEN[LIBECPINT_MAX_L+1][LIBECPINT_MAX_L+1][LIBECPINT_MAX_L+1])(
               const ECP&, const GaussianShell&, const GaussianShell&,
           const FiveIndex<double>&, const FiveIndex<double>&,
           const TwoIndex<double>&, const TwoIndex<double>&,
           double, double,
           const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&,
           ThreeIndex<double>&);
   
       public:
           int skipped, zero, nonzero;
           
           void makeC(FiveIndex<double> &C, int L, const double *A) const;
           
           ECPIntegral(int maxLB, int maxLU, int deriv=0);
       
           void type1(const ECP& U, const GaussianShell &shellA, const GaussianShell &shellB,
                  const ShellPairData &data, const FiveIndex<double> &CA, const FiveIndex<double> &CB,
                  const RadialIntegral::Parameters & parameters, TwoIndex<double> &values) const;
           
           void type2(int l,
                  const ECP& U, const GaussianShell &shellA, const GaussianShell &shellB,
                  const ShellPairData &data, const FiveIndex<double> &CA, const FiveIndex<double> &CB,
                  const RadialIntegral::Parameters & parameters, ThreeIndex<double> &values) const;
           
           void estimate_type2(
           const ECP& U, const GaussianShell &shellA, const GaussianShell &shellB,
           const ShellPairData &data, double* results) const;
       
           void compute_shell_pair(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           TwoIndex<double> &values, int shiftA = 0, int shiftB = 0) const;
           
           void compute_shell_pair_derivative(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           std::array<TwoIndex<double>, 9> &results) const;
           
           void compute_shell_pair_second_derivative(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           std::array<TwoIndex<double>, 45> &results) const;
           
           void left_shell_derivative(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           std::array<TwoIndex<double>, 3> &results) const;
           
           void left_shell_second_derivative(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           std::array<TwoIndex<double>, 6> &results) const;
           
           void mixed_second_derivative(
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           std::array<TwoIndex<double>, 9> &results) const;
           
       };
   
   }
   #endif

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp:

File multiarr.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Helpful lightweight multi-index arrays and tuples to make the code easier to write and test. 
 

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/multiarr.hpp``)
----------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp.rst



Detailed Description
--------------------

TODO: It is possible these are slowing things down a bit, need to run benchmarks. 



Includes
--------


- ``algorithm``

- ``sstream``

- ``tuple``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__aux`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1seq`

- :ref:`exhale_struct_structlibecpint_1_1_five_index`

- :ref:`exhale_struct_structlibecpint_1_1_seven_index`

- :ref:`exhale_struct_structlibecpint_1_1_three_index`

- :ref:`exhale_struct_structlibecpint_1_1_two_index`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1aux_1a8e2ec9ac4e466e11814c592a83efb66f`

- :ref:`exhale_function_namespacelibecpint_1a23ce2cda098d601b0fddfb10b971e33f`


Typedefs
--------


- :ref:`exhale_typedef_namespacelibecpint_1a48b53f3b6bfb449ec300ab57fc03763c`

- :ref:`exhale_typedef_namespacelibecpint_1a7676a778fedc78dfdc0495c3319a2730`

- :ref:`exhale_typedef_namespacelibecpint_1a4dc36ca1c5a9247d8bfaac304a7df40f`

- :ref:`exhale_typedef_namespacelibecpint_1af2651847fa01dec731554db1e7b273fd`

.. _exhale_function_namespacelibecpint_1_1qgen_1a6cd9cb22f70aaa25147c43511e335d41:

Function libecpint::qgen::Q0_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_generate_8cpp_1a0ddf1224851353fc92bfbff6f499fa97:

Function main
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generate.cpp`


Function Documentation
----------------------


.. doxygenfunction:: main(int, char *)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab91f04eece262074221b150ca5e0e62a:

Function libecpint::qgen::Q0_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5582b3de3f3f06a0dd219525f45efb3b:

Function libecpint::qgen::Q0_1_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_variable_generate_8cpp_1a96e56aec07e9dee3b0b39b2c73c59413:

Variable maxL
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: maxL
.. _exhale_function_namespacelibecpint_1a4c0dd5f75d6fc9b5329c97195b0b5e6c:

Function libecpint::frobenius_norm
==================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::frobenius_norm(TwoIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a97e6fa3e95914a16d365a38fad6bf168:

Function libecpint::qgen::Q4_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1ac6cc42cb342d04a07173673b14e59b5c:

Function libecpint::pow_9
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_9(double)
.. _exhale_function_namespacelibecpint_1a3d3ec1164653607a1a2a66e71c160905:

Function libecpint::pow_m2
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_m2(const double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp:

Program Listing for File mathutil.cpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/mathutil.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "mathutil.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       double FAC[MAX_FAC];
       double DFAC[MAX_DFAC];
       
       double pow_m2(double z) { return 1.0/(z*z); }
       double pow_m1(double z) { return 1.0/z; }
       double pow_0(double z) { return 1.0; }
       double pow_1(double z) { return z; }
       double pow_2(double z) { return z*z; }
       double pow_3(double z) { return z*z*z; } 
       double pow_4(double z) { double z2 = z*z; return z2*z2; }
       double pow_5(double z) { double z2 = z*z; double z3 = z2*z; return z2*z3; };
       double pow_6(double z) { double z2 = z*z; return z2*z2*z2; }
       double pow_7(double z) { double z2 = z*z; double z3 = z*z2; return z3*z2*z2; }
       double pow_8(double z) { double z2 = z*z; double z4 = z2*z2; return z4*z4; }
       double pow_9(double z) { double z3 = z*z*z; return z3*z3*z3; }
       double pow_10(double z) { double z2 = z*z; double z3 = z*z2; double z5= z2*z3; return z5*z5; }
       double pow_11(double z) { double z2 = z*z; double z3 = z*z2; return z3*z3*z3*z2; }
       double pow_12(double z) { double z3 = z*z*z; double z6 = z3*z3; return z6*z6; }
       double pow_13(double z) { double z3 = z*z*z; double z6 = z3*z3; return z6*z6*z; }
       double pow_14(double z) { double z2 = z*z; double z3 = z*z2; double z7 = z2*z2*z3; return z7*z7; }
       double pow_15(double z) { double z2 = z*z; double z3 = z*z2; double z5 = z2*z3; return z5*z5*z5; }
       double pow_16(double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8; }
       double pow_17(double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8*z;}
       double pow_18(double z) { double z3 = z*z*z; double z9 = z3*z3*z3; return z9*z9; }
       double pow_19(double z) { double z3 = z*z*z; double z9 = z3*z3*z3; return z9*z9*z; }
       double pow_20(double z) { double z2 = z*z; double z4 = z2*z2; double z8 = z4*z4; return z8*z8*z4; }
       
       void initFactorials() {
       #ifndef FAC_INIT
       #define FAC_INIT
               FAC[0] = 1.0;
               DFAC[0] = 1.0;
               DFAC[1] = 1.0;
           
               for (int i = 1; i < MAX_FAC; i++)  FAC[i] = double(i) * FAC[i-1]; 
               for (int i = 2; i < MAX_DFAC; i++) DFAC[i] = double(i) * DFAC[i-2];
       #endif
       }
       
       // Compute all the real spherical harmonics Slm(theta, phi) for l,m up to lmax
       // x = std::cos (theta)
       TwoIndex<double> realSphericalHarmonics(int lmax, double x, double phi){
           TwoIndex<double> rshValues(lmax+1, 2*lmax+1, 0.0);
   
           if (lmax > 0) {
               // First calculate the associated Legendre polynomials, Plm(std::cos theta), ustd::sing the recursion relation
               // (l-m)Plm = x(2l - 1)P{l-1}m - (l+m-1)P{l-2}m
               // along with the zeroth order term
               // Pmm = (-1)^m (2m-1)!!(1-x^2)^{m/2}
               double x2 = x * x;
               double Plm[lmax+1][lmax+1]; 
               // First get all Pmm terms
               Plm[0][0] = 1.0;
               double sox2 = std::sqrt(std::max(0.0, 1.0 - x2));
               double ox2m = 1.0;
               for (int m = 1; m <= lmax; m++) {
                   ox2m *= -sox2;
                   Plm[m][m] = ox2m * DFAC[2*m-1]; 
               }
           
               // Then increment l for each m
               Plm[1][0] = x;
               Plm[0][1] = 0.0;
               for (int l = 2; l <= lmax; l++) {
                   ox2m = x * (2*l - 1);
                   for (int m = 0; m < l; m++) {
                       Plm[l][m] = ox2m * Plm[l-1][m] - (l + m - 1)*Plm[l-2][m];
                       Plm[l][m] /= ((double) (l -m));
                   }
                   Plm[l-1][l] = 0.0;
               }
           
               // Now we compute the spherical harmonics via
               // Slm(theta, phi) = Clm * Plm(std::cos(theta)) * std::cos(m * phi), m > 0
               // Sl{-m}(theta, phi) = Clm * Plm(std::cos(theta)) * std::sin(m * phi)
               // Sl0(theta, phi) = std::sqrt(2) * Cl0 * Pl0(std::cos(theta))
               // where Clm^2 = (2l + 1)*(l - m)! / (8*pi * (l+m)!)
               double osq4pi = 1.0 / std::sqrt(4.0 * M_PI); 
               int sign;
               for (int l = 0; l <= lmax; l++) {
                   rshValues(l, l) = osq4pi * std::sqrt(2.0 * l + 1.0) * Plm[l][0];
                   sign = -1;
                   for (int m = 1; m <= l; m++) {
                       ox2m = (2.0 * l + 1.0) * FAC[l-m] / FAC[l+m];
                       ox2m = sign * osq4pi * std::sqrt(2.0 * ox2m) * Plm[l][m];
                       rshValues(l, l+m) = ox2m * std::cos(m * phi);
                       rshValues(l, l-m) = ox2m * std::sin(m * phi);
                       sign *= -1;
                   }
               }
           
           } else {
               rshValues(0, 0) = 1.0 / std::sqrt(4.0 * M_PI);
           }
           
           return rshValues;
       }
       
       double frobenius_norm(TwoIndex<double>& mat) {
           return std::sqrt(std::inner_product(mat.data.begin(), mat.data.end(), mat.data.begin(), 0.0));
       }
       
   }
.. _exhale_function_namespacelibecpint_1a250f67b7a3f611c4b8acdd8d90e0bec6:

Function libecpint::pow_16
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_16(double)
.. _exhale_function_namespacelibecpint_1a5ebc6e4869b8a3dab9286895629c19fc:

Function libecpint::pow_15
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_15(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a3ed03cc7f1a6e5af9a85708f81d80f8a:

Function libecpint::qgen::Q1_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a6c9e60c9ff500fb4223a19fa56721bc3:

Function libecpint::qgen::Q1_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _dir__Users_robertshaw_devfiles_libecpint_new_src_generated_radial:


Directory radial
================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_generated>` (``/Users/robertshaw/devfiles/libecpint_new/src/generated``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_unrol_radial.py`


.. _exhale_function_namespacelibecpint_1_1qgen_1a70a5cf8de05207c9704d69acbfb5c2dd:

Function libecpint::qgen::Q0_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a9a1b0cff031b0138fad4fba5dd78fb28:

Function libecpint::qgen::Q3_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1acf2f1092a3b6f0098de49c3da234df38:

Function libecpint::qgen::Q1_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1ae8056358eb2736d93b3a78dd1428555c:

Variable libecpint::SINH_1
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::SINH_1

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp:

File ecpint.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/ecpint.cpp``)
----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``cassert``

- ``cmath``

- ``ecpint.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`)

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``qgen.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a924e19764d9f679e62ae85fc6cac2410:

Function libecpint::qgen::Q1_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac6b5b1c66dc83827b0cc8971c0a89c5b:

Function libecpint::qgen::Q5_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp:

File generate.cpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src>` (``/Users/robertshaw/devfiles/libecpint_new/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


ECP integral code generator. 
 

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/generate.cpp``)
--------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp.rst





Includes
--------


- ``generate.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp`)






Functions
---------


- :ref:`exhale_function_generate_8cpp_1a45aa3f4947203d38d9cb52b96d002cea`

- :ref:`exhale_function_generate_8cpp_1a0ddf1224851353fc92bfbff6f499fa97`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp:

Program Listing for File libecpint.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef LIBECPINT_HEAD
   #define LIBECPINT_HEAD
   
   #include "libecpint/api.hpp"
   
   #endif LIBECPINT_HEAD

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_makelist.py:

Program Listing for File makelist.py
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_makelist.py>` (``/Users/robertshaw/devfiles/libecpint/src/makelist.py``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: py

   import sys
   max_am = int(sys.argv[1])
   prefix = str(sys.argv[2])
   
   file = open(prefix + "/qlist.txt", "w")
   file.write(prefix + "/generated/ecpint_gen.cpp\n")
   for j in range(max_am+1):
       for i in range(j+1):
           for k in range(max_am+1):
               if j == i == k == max_am:
                   file.write(prefix + "/generated/Q" + str(i) + str(j) + str(k) + ".cpp") 
               else:
                   file.write(prefix + "/generated/Q" + str(i) + str(j) + str(k) + ".cpp\n")
   file.close()

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp:

Program Listing for File radial.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/radial.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef RADIAL_HEAD
   #define RADIAL_HEAD
   
   #include <vector>
   #include "multiarr.hpp"
   #include "gaussquad.hpp"
   #include "ecp.hpp"
   #include "bessel.hpp"
   #include "gshell.hpp"
   
   namespace libecpint {
   
       const double MIN_EXP = 0.002;
       class RadialIntegral
       {
       private:
           GCQuadrature bigGrid;
           GCQuadrature smallGrid;
           GCQuadrature primGrid; 
           BesselFunction bessie;
       
           TwoIndex<double> p, P, P2, K;
       
           double tolerance;
       
           static double integrand(double r, double *p, int ix);
   
           void buildBessel(std::vector<double> &r, int nr, int maxL, TwoIndex<double> &values, double weight = 1.0);
       
           double calcKij(double Na, double Nb, double zeta_a, double zeta_b, double R2) const;
       
           void buildU(ECP &U, int l, int N, GCQuadrature &grid, double *Utab);
       
           void buildF(GaussianShell &shell, double A, int lstart, int lend, std::vector<double> &r, int nr, int start, int end, TwoIndex<double> &F);
       
           int integrate(int maxL, int gridSize, TwoIndex<double> &intValues, GCQuadrature &grid, std::vector<double> &values, int offset = 0, int skip = 1);
           
           void compute_base_integrals(int N_min, int N_max, double p, double o_root_p, double P1,
                                       double P2, double P1_2, double P2_2, double X1, double X2,
                                       double oP1, double oP2, double* values); 
                                       
           std::pair<double, bool> integrate_small(int N, int l1, int l2, double n, double a, double b, double A, double B);
           
       public:
           RadialIntegral();
       
           void init(int maxL, double tol = 1e-15, int small = 256, int large = 1024);
       
           void buildParameters(GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data);
       
           void type1(int maxL, int N, int offset, ECP &U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, TwoIndex<double> &values);
       
           void type2(int lam, int l1start, int l1end, int l2start, int l2end, int N, ECP &U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, TwoIndex<double> &values);    
   
           void type2(std::vector<Triple> &triples, int nbase, int lam, ECP &U, GaussianShell &shellA, GaussianShell &shellB, double A, double B, ThreeIndex<double> &radials); 
       
           double estimate_type2(int N, int l1, int l2, double n, double a, double b, double A, double B);
       };
   
   }
   
   #endif
.. _dir__Users_robertshaw_devfiles_libecpint_new_src:


Directory src
=============


*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/src``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_new_src_generated`
- :ref:`dir__Users_robertshaw_devfiles_libecpint_new_src_lib`


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_makelist.py`


.. _exhale_function_namespacelibecpint_1_1qgen_1a2b53172b5b4103d7742ccf83fdb6e5b6:

Function libecpint::qgen::Q3_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp:

Program Listing for File qgen.cpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/qgen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *       This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #include "qgen.hpp"
   #include <cmath> 
   #include "mathutil.hpp"
   #include <iostream>
   
   namespace libecpint {
       namespace qgen {    
           void rolled_up(int lam, int LA, int LB, ThreeIndex<double> &radials, FiveIndex<double> &CA, FiveIndex<double> &CB, TwoIndex<double> &SA, TwoIndex<double> &SB, AngularIntegral &angint, ThreeIndex<double> &values)
           {
               double prefac = 16.0 * M_PI * M_PI;
               int L = LA + LB;    
           
               int z1, z2, w_m, w_l, w_lm;
               int w_ax, w_ay, w_az, w_l1; 
               int w_bx, w_by, w_bz, w_l2; 
               double C, val;
               int* mults = angint.getOmegaMults();
               std::vector<double>& omega = angint.getOmegaData();
               int w_size = 2*lam+1; 
               double w1_contr[w_size*(lam+LA+1)];
               double w2_contr[w_size*(lam+LB+1)];
               
               int w_lam = lam * mults[3];
               // Loop over cartesian shell functions in alpha order, e.g. {xx xy, xz, yy, yz, zz} for l=2
               int na = 0; // Rows are shellA
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
               
                       int nb = 0; // Cols are shellB
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                       
                               // Begin full ECP integral expansion
                               for (int alpha_x = 0; alpha_x <= x1; alpha_x++) {
                                   w_ax = w_lam + alpha_x*mults[0];
                                   for (int alpha_y = 0; alpha_y <= r1; alpha_y++) {
                                       w_ay = w_ax + alpha_y*mults[1];
                                       for (int alpha_z = 0; alpha_z <= z1; alpha_z++) {
                                           w_az = w_ay + alpha_z*mults[2];
                                           int alpha = alpha_x + alpha_y + alpha_z; 
                                   
                                           for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                               w_bx = w_lam + beta_x*mults[0];
                                               for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                                   w_by = w_bx + beta_y*mults[1];
                                                   for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                                       w_bz = w_by + beta_z*mults[2]; 
                                                       int beta = beta_x + beta_y + beta_z; 
                                                       int N = alpha + beta; 
                                                       C = CA(0, na, alpha_x, alpha_y, alpha_z) * CB(0, nb, beta_x, beta_y, beta_z); 
                                                       
                                                       if (std::abs(C) > 1e-15) {
                                                           
                                                           for (int lam1 = 0; lam1 <= lam + alpha; lam1++) {
                                                               w_l = lam1*w_size+lam; 
                                                               w_l1 = w_az + lam1*(1+mults[5]);
                                                               w_m = w_l1-mults[4];
                                                               for (int mu = -lam; mu <= lam; mu++) {
                                                                   w_m += mults[4];
                                                                   w_lm = lam1*SA.dims[1];
                                                                   w1_contr[w_l+mu] = 0.0;
                                                                   for (int mu1 = -lam1; mu1 <= lam1; mu1++)
                                                                       w1_contr[w_l+mu] += SA.data[w_lm++] * omega[w_m+mu1];
                                                               }
                                                           }
                                           
                                                           for (int lam2 = 0; lam2 <= lam+beta; lam2++) {
                                                               w_l  = lam2*w_size+lam;
                                                               w_l2 = w_bz + lam2*(1+mults[5]);
                                                               w_m = w_l2-mults[4];
                                                               for (int mu = -lam; mu <= lam; mu++) {
                                                                   w_m += mults[4];
                                                                   w_lm = lam2*SB.dims[1];
                                                                   w2_contr[w_l+mu] = 0.0;
                                                                   for (int mu2 = -lam2; mu2 <= lam2; mu2++) 
                                                                       w2_contr[w_l+mu] += SB.data[w_lm++] * omega[w_m+mu2];
                                                               }
                                                           }
                                                               
                                                           for (int lam1=0; lam1 <= lam+alpha; lam1++) {
                                                               w_l1 = lam1*w_size+lam;
                                                               int lam2start = (lam1 + N) % 2; 
                                                               for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                                   w_l2 = lam2*w_size+lam;
   
                                                                   val = prefac * C * radials(N, lam1, lam2);
                                                                   for (int mu = -lam; mu <= lam; mu++) 
                                                                       values(na, nb, lam+mu) += val * w1_contr[w_l1+mu] * w2_contr[w_l2+mu];
   
                                                               }
                                                           }
                                                       }
                                               
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                       
                               nb++;
                           }
                       }
               
                       na++; 
                   }
               }
           }
     
           void rolled_up_special(int lam, int LA, int LB, ThreeIndex<double>& radials, FiveIndex<double>& CB, TwoIndex<double>& SB, AngularIntegral& angint, ThreeIndex<double>& values) {
               double prefac = 8.0 * M_PI * std::sqrt(M_PI);
               int L = LA + LB;    
       
               int z1, z2; 
               double C, val1, val2; 
   
               int w_bx, w_by, w_bz, w_l2, w_m2, w1, w_m; 
               int* mults = angint.getOmegaMults();
               std::vector<double>& omega = angint.getOmegaData();
               int w_lam = lam * mults[3];
               
               // Loop over cartesian shell functions in alpha order, e.g. {xx xy, xz, yy, yz, zz} for l=2
               int na = 0; // Rows are shellA
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
                       w1 = w_lam + x1*mults[0] + r1*mults[1] + z1*mults[2];
           
                       int nb = 0; // Cols are shellB
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                   
                               // Begin full ECP integral expansion
                               int alpha = x1 + r1 + z1; 
                               
                               for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                   w_bx = w_lam + beta_x*mults[0];
                                   for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                       w_by = w_bx + beta_y*mults[1];
                                       for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                           w_bz = w_by + beta_z*mults[2];
                                           int beta = beta_x + beta_y + beta_z; 
                                           int N = alpha + beta; 
                                           C = CB(0, nb, beta_x, beta_y, beta_z); 
                                               
                                           if (std::abs(C) > 1e-15) {
                                                       
                                               int lam2start =  N % 2; 
                                               for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                   w_l2 = w_bz + lam2*(1+mults[5]);
                                                   val1 = prefac * C * radials(N, 0, lam2);
                                                   
                                                           
                                                   for (int mu2 = -lam2; mu2 <= lam2; mu2++) {
                                                       w_m2 = w_l2 + mu2;
                                                       val2 = val1 *  SB(lam2, lam2+mu2);
                                                       w_m = -mults[4];                                                                        
                                                       for (int mu = -lam; mu <= lam; mu++) {
                                                           w_m += mults[4];
                                                           values(na, nb, lam+mu) += val2 * omega[w1+w_m] * omega[w_m2+w_m];
                                                       }
                                                   }
                                               }
                                           }
                                       }
                                   }               
                               }
                               nb++;
                           }
                       }
                       na++;
                   }
               }
           }
       }
   }

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp:

Program Listing for File radial.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/radial.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef RADIAL_HEAD
   #define RADIAL_HEAD
   
   #include <vector>
   #include "multiarr.hpp"
   #include "gaussquad.hpp"
   #include "ecp.hpp"
   #include "bessel.hpp"
   #include "gshell.hpp"
   
   namespace libecpint {
   
       constexpr double MIN_EXP = 0.002;
       class RadialIntegral
       {
       private:
           GCQuadrature bigGrid;
           GCQuadrature smallGrid;
           GCQuadrature primGrid; 
           BesselFunction bessie;
   
           double tolerance;
       
           static double integrand(double r, const double *p, int ix);
   
           void buildBessel(const std::vector<double> &r, int nr, int maxL, TwoIndex<double> &values, double weight = 1.0) const;
       
           double calcKij(double Na, double Nb, double zeta_a, double zeta_b, double R2) const;
       
           void buildU(const ECP &U, const int l, const int N, const GCQuadrature &grid, double *Utab) const;
       
           void buildF(
           const GaussianShell &shell, double A, int lstart, int lend,
           const std::vector<double> &r, int nr, int start, int end,
           TwoIndex<double> &F) const;
       
           int integrate(int maxL, int gridSize, const TwoIndex<double> &intValues, GCQuadrature &grid, std::vector<double> &values,
                   int start, int end, int offset = 0, int skip = 1) const;
           
           void compute_base_integrals(int N_min, int N_max, double p, double o_root_p, double P1,
                                       double P2, double P1_2, double P2_2, double X1, double X2,
                                       double oP1, double oP2, double* values) const;
                                       
           std::pair<double, bool> integrate_small(
               int N, int l1, int l2, double n, double a, double b, double A, double B) const;
           
       public:
           RadialIntegral();
       
           void init(int maxL, double tol = 1e-15, int small = 256, int large = 1024);
   
           struct Parameters {
         TwoIndex<double> p, P, P2, K;
           };
           Parameters buildParameters(
               const GaussianShell &shellA, const GaussianShell &shellB, const ShellPairData &data) const;
       
           void type1(int maxL, int N, int offset,
                  const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
                  const ShellPairData &data, const Parameters & parameters, TwoIndex<double> &values) const;
       
           void type2(int lam, int l1start, int l1end, int l2start, int l2end, int N,
                  const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
                  const ShellPairData &data, const Parameters & parameters, TwoIndex<double> &values) const;
   
           void type2(
           const std::vector<Triple> &triples, int nbase, int lam,
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
           double A, double B, ThreeIndex<double> &radials) const;
       
           double estimate_type2(int N, int l1, int l2, double n, double a, double b, double A, double B) const;
       };
   
   }
   
   #endif

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp:

Program Listing for File multiarr.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/multiarr.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef MULTIARR_HEAD
   #define MULTIARR_HEAD
   
   #include <vector>
   #include <tuple> 
   #include <algorithm>
   #include <sstream>
   
   namespace libecpint {
   
       using Pair = std::tuple<int, int>;
       using Triple = std::tuple<int, int, int>;
       using Quintuple = std::tuple<int, int, int, int, int>; 
       using Heptuple = std::tuple<int, int, int, int, int, int, int>; 
       
       namespace aux{
           template<std::size_t...> struct seq{};
           template<std::size_t N, std::size_t... Is>
           struct gen_seq : gen_seq<N-1, N-1, Is...>{};
           template<std::size_t... Is>
           struct gen_seq<0, Is...> : seq<Is...>{};
           template<class Ch, class Tr, class Tuple, std::size_t... Is>
           void print_tuple(std::basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){
               using swallow = int[];
               (void)swallow{0, (void(os << (Is == 0? "" : ", ") << std::get<Is>(t)), 0)...};
           }
       } 
       
       template<class Ch, class Tr, class... Args>
       auto operator<<(std::basic_ostream<Ch, Tr>& os, std::tuple<Args...> const& t)
           -> std::basic_ostream<Ch, Tr>&
       {
           os << "(";
           aux::print_tuple(os, t, aux::gen_seq<sizeof...(Args)>());
           return os << ")";
       }
       
       template<typename T>
       struct TwoIndex {
           int dims[2];
           std::vector<T> data;
           T& operator()(int i, int j) { return data[i * dims[1] + j]; }
           T operator()(int i, int j) const { return data[i * dims[1] + j]; }
           void assign(int dim1, int dim2, T value) {
               dims[0] = dim1; dims[1] = dim2;
               data.resize(dim1 * dim2);
               std::fill(data.begin(), data.end(), value);
           }
           TwoIndex<T> transpose() {
               TwoIndex<T> result(dims[1], dims[0]);
               for (int i = 0; i < dims[0]; i++) {
                   for (int j = 0; j < dims[1]; j++)
                       result.data[j * dims[0] + i] = data[i * dims[1] + j];
               }
               return result;
           }
           void add(const TwoIndex<T>& other) {
               std::transform (data.begin(), data.end(), other.data.begin(), data.begin(), std::plus<T>());
           }
           
           void multiply(T k) {
               std::transform(data.begin(), data.end(), data.begin(), [&k](T& c){return c*k;});
           }
           TwoIndex() { dims[0] = dims[1] = 0; }
           TwoIndex(int dim1, int dim2) {
               dims[0] = dim1; dims[1] = dim2;
               data.resize(dim1 * dim2);
           }
           TwoIndex(int dim1, int dim2, T value) { assign(dim1, dim2, value); }
           TwoIndex(const TwoIndex<T> &other) { 
               data = other.data;
               dims[0] = other.dims[0]; dims[1] = other.dims[1];
           }
       };
   
       template<typename T>
       struct ThreeIndex {
           int dims[3];
           std::vector<T> data;
           T& operator()(int i, int j, int k) { return data[i*dims[2]*dims[1] + j*dims[2] + k]; }
           T operator()(int i, int j, int k) const { return data[i*dims[2]*dims[1] + j*dims[2] + k]; }
           ThreeIndex(){ dims[0] = 0; dims[1] = 0; dims[2] = 0; }
           ThreeIndex(int dim1, int dim2, int dim3) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3;
               data.resize(dim1 * dim2 * dim3);
           }
           ThreeIndex(const ThreeIndex<T> &other)  { 
               data = other.data;
               for (int n = 0; n < 3; n++) dims[n] = other.dims[n]; 
           }
           void fill(T value) { std::fill(data.begin(), data.end(), value); }
       };
   
       template<typename T>
       struct FiveIndex {
           int dims[5];
           std::vector<T> data;
           T& operator()(int i, int j, int k, int l, int m) { 
               return data[m + dims[4] * (l + dims[3] * (k + dims[2] * (j + dims[1] * i)))]; 
           }
           T operator()(int i, int j, int k, int l, int m) const { 
               return data[m + dims[4] * (l + dims[3] * (k + dims[2] * (j + dims[1] * i)))];
           }
           FiveIndex() { dims[0] = dims[1] = dims[2] = dims[3] = dims[4] = 0; }
           FiveIndex(int dim1, int dim2, int dim3, int dim4, int dim5) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3; dims[3] = dim4; dims[4] = dim5;
               data.resize(dim1 * dim2 * dim3 * dim4 * dim5);
           }
           FiveIndex(const FiveIndex<T> &other) { 
               data = other.data;
               for (int n = 0; n < 5; n++) dims[n] = other.dims[n]; 
           }
       };
   
       template<typename T>
       struct SevenIndex {
           int dims[7];
           int mults[6];
           std::vector<T> data;
           T& operator()(int i, int j, int k, int l, int m, int n, int p) {
               return data[p + mults[5]*n + mults[4]*m + mults[3]*l + mults[2]*k + mults[1]*j + mults[0]*i];
           }
           T operator()(int i, int j, int k, int l, int m, int n, int p) const {
               return data[p + mults[5]*n + mults[4]*m + mults[3]*l + mults[2]*k + mults[1]*j + mults[0]*i];
           }
           SevenIndex() { dims[0] = dims[1] = dims[2] = dims[3] = dims[4] = dims[5] = dims[6] = 0; 
                          mults[0] = mults[1] = mults[2] = mults[3] = mults[4] = mults[5] = 0; }
           SevenIndex(int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7) {
               dims[0] = dim1; dims[1] = dim2; dims[2] = dim3; dims[3] = dim4; dims[4] = dim5; dims[5] = dim6; dims[6] = dim7;
               data.resize(dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7);
               mults[5] = dim7;
               mults[4] = dim7*dim6;
               mults[3] = mults[4]*dim5;
               mults[2] = mults[3]*dim4;
               mults[1] = mults[2]*dim3;
               mults[0] = mults[1]*dim2;
           }
           SevenIndex(const SevenIndex<T> &other) {
               data = other.data;
               for (int n = 0; n < 6; n++) {
                   dims[n] = other.dims[n];
                   mults[n] = other.mults[n];
               }
               dims[6] = other.dims[6];
           }
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1af14b5de42b087d7ed2768844928538c2:

Function libecpint::qgen::Q2_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae6cb9ae3d166614d151089947c8eb841:

Function libecpint::qgen::Q1_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aba194c04414f2de09dbb83bc7a528dfe:

Function libecpint::qgen::Q4_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af85e85322bbdc11c456c2e6cf87e1f03:

Function libecpint::qgen::Q0_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1af44e43779236559458dd5ef1f683ce:

Function libecpint::qgen::Q1_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a5f751be5271cc840a3025f0e0ee026f2:

Variable libecpint::MAX_POW
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::MAX_POW
.. _exhale_variable_namespacelibecpint_1a92d5ae635e6e5d78682fd89ce537a7a3:

Variable libecpint::MIN_EXP
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::MIN_EXP
.. _exhale_struct_structlibecpint_1_1_gaussian_shell:

Struct GaussianShell
====================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::GaussianShell
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp:

File gshell.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/gshell.hpp``)
--------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp.rst





Includes
--------


- ``array``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_gaussian_shell`

- :ref:`exhale_class_structlibecpint_1_1_shell_pair_data`

.. _exhale_variable_namespaceunrol__radial_1a02363db1e3121f4cb64855282f206fff:

Variable unrol_radial::file
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Variable Documentation
----------------------


.. doxygenvariable:: unrol_radial::file
.. _exhale_function_namespacelibecpint_1_1qgen_1a418b910c14f22c51f09224b0b5b8897d:

Function libecpint::qgen::Q2_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aacd750e55133a09211f6abfe0ea4ea3b:

Function libecpint::qgen::Q0_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a24a7957907649a616a90be7093af0a1e:

Function libecpint::qgen::Q1_1_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_define_mathutil_8hpp_1aaf00c7de57af68f4e9d7acc87adb8d87:

Define MAX_FAC
==============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Define Documentation
--------------------


.. doxygendefine:: MAX_FAC

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp:

File qgen.cpp
=============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/qgen.cpp``)
--------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp.rst





Includes
--------


- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``qgen.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__qgen`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa957a79b70df8879d0abbfb12a2ce49b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2746fee105d370ee314fe22e752affeb`

.. _exhale_function_namespacelibecpint_1_1qgen_1af6aed704c528f33d41a3c8974f73933d:

Function libecpint::qgen::Q3_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_define_mathutil_8hpp_1a30bbac291639d5f7d964a92fa8742b94:

Define MAX_DFAC
===============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Define Documentation
--------------------


.. doxygendefine:: MAX_DFAC
.. _exhale_function_namespacelibecpint_1_1qgen_1a013e0cc0f5b8223acc2c0f4877d450b8:

Function libecpint::qgen::Q1_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp:

Program Listing for File generate.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/generate.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GENERATE_HEAD
   #define GENERATE_HEAD
   
   #include <iostream>
   #include <fstream>
   #include <string>
   #include "angular.hpp"
   #include "mathutil.hpp"
   #include "multiarr.hpp"
   #include "config.hpp"
   #include <cmath>
   
   namespace libecpint {
       
       const int maxL = LIBECPINT_MAX_L;
       const int maxUnrol = LIBECPINT_MAX_UNROL; 
       const int maxN = 15; 
       const int CAX1 = maxN + 1;
       const int CAX2 = CAX1 * (maxL + 1);
       const int CAX3 = CAX2 * (maxL + 1);
   
       struct SumTerm {
   
           Pair SA; 
           Pair SB; 
           Triple radial; 
           Quintuple CA; 
           Quintuple CB; 
           double ang;   
           int mu; 
           int na; 
           int nb; 
       
           bool operator<(const SumTerm& s) const {
               bool result = (mu < s.mu);
               if (mu == s.mu) {
                   result = radial < s.radial; 
                   if (radial == s.radial)
                       result = ang < s.ang; 
               }
               return result; 
           }
          
           bool operator<=(const SumTerm& s) const {
               return (*this == s) || (*this < s); 
           }
       
           bool operator==(const SumTerm& s) const {
               return (mu == s.mu) && (radial == s.radial); 
           }
       
           int ca_index() const {
               return std::get<1>(CA) + std::get<2>(CA)*CAX1 
                   + std::get<3>(CA)*CAX2 + std::get<4>(CA)*CAX3; 
           }
       
           int cb_index() const {
               return std::get<1>(CB) + std::get<2>(CB)*CAX1 
                   + std::get<3>(CB)*CAX2 + std::get<4>(CB)*CAX3; 
           }
       
           std::string to_string(bool full = true) {
               std::stringstream ss;
           
               if (full) 
                   ss << "\tvalue" << mu << " += " << ang << " * CA[" << ca_index()
                       << "] * CB[" << cb_index() << "] * radials" << radial << " * SA"
                           << SA << " * SB" << SB << ";"; 
               else
                   ss << "\ttmp += " << "CA[" << ca_index() << "] * CB[" << cb_index() << "] * SA"
                       << SA << " * SB" << SB << ";"; 
            
               return ss.str(); 
           }
       
           Heptuple compare(const SumTerm& s) const {
               int f1 = mu == s.mu ? 1 : 0;
               int f2 = radial == s.radial ? 1 : 0;
               int f3 = SA == s.SA ? 1 : 0;
               int f4 = SB == s.SB ? 1 : 0; 
               int f5 = fabs(ang - s.ang) < 1e-10 ? 1 : 0;
               int f6 = CA == s.CA ? 1 : 0;
               int f7 = CB == s.CB ? 1 : 0; 
           
               return {f1, f2, f3, f4, f5, f6, f7};  
           }
       
           friend std::ostream& operator<<(std::ostream& os, const SumTerm& s); 
   
       };
   
       std::ostream& operator<<(std::ostream& os, const SumTerm& s) {
           os << "values(" << s.na << ", " << s.nb << ", " << s.mu << ") += "
               << s.ang << " * CA" << s.CA << " * CB" << s.CB
                   << " * radials" << s.radial << " * SA" << s.SA << " * SB" << s.SB << ";";
           return os;
       }
   
   } // end namespace
   
   #endif

.. _namespace_std:

Namespace std
=============


STL namespace. 




.. contents:: Contents
   :local:
   :backlinks: none



.. _exhale_function_namespacelibecpint_1ad93011f81c46d555725bff0a0fc5aaf6:

Function libecpint::shell_bound
===============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::shell_bound(const int, const double, const double, const double)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp:

File api.cpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/api.cpp``)
-------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp.rst





Includes
--------


- ``api.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`)

- ``cassert``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a544c252dcf08f3ce5560b8066730601c`

.. _exhale_variable_namespacelibecpint_1a2a771df5ca42d30ffdf70033fbc94770:

Variable libecpint::TWO_C_TOLERANCE
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::TWO_C_TOLERANCE
.. _exhale_function_namespacelibecpint_1a38e7f34b9f4f6181178d70e2d1ebb7df:

Function libecpint::pow_12
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_12(double)
.. _exhale_function_namespaceunrol__radial_1a48a1059eae24c36cd6464073577d147a:

Function unrol_radial::algebraic_unrol
======================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Function Documentation
----------------------


.. doxygenfunction:: unrol_radial::algebraic_unrol(i, j, k)

.. _file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp:

File testutil.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include>` (``/Users/robertshaw/devfiles/libecpint/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/testutil.hpp``)
--------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp.rst





Includes
--------


- ``cmath``

- ``fstream``

- ``iomanip``

- ``iostream``

- ``sstream``

- ``string``

- ``vector``






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a2c6257f0f39de7233558e384908f1526`

.. _exhale_function_namespacelibecpint_1_1qgen_1a6ca3f4990879d69f0947dc320cff7512:

Function libecpint::qgen::Q1_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_generate_8cpp_1a45aa3f4947203d38d9cb52b96d002cea:

Function generate_lists
=======================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generate.cpp`


Function Documentation
----------------------


.. doxygenfunction:: generate_lists(int, int, int, libecpint::AngularIntegral&)

.. _file__Users_robertshaw_devfiles_libecpint_include_generate.hpp:

File generate.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include>` (``/Users/robertshaw/devfiles/libecpint/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/generate.hpp``)
--------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_generate.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`)

- ``cmath``

- ``config.hpp``

- ``fstream``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``string``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generate.cpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_sum_term`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a3a4ed9b49d76dd6974d2dbc6bb181ab8`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a02017a941eee202982bab7731ead620d`

- :ref:`exhale_variable_namespacelibecpint_1ae0ba3cdb903f3057f168bfaa5495bba0`

- :ref:`exhale_variable_namespacelibecpint_1acdba31532082cde9ce50b5c6ecd2b442`

- :ref:`exhale_variable_namespacelibecpint_1a190a564f849660c170e298aba2181d0a`

- :ref:`exhale_variable_namespacelibecpint_1a6a8879ed7b1d299f2b2e92b105cce919`

- :ref:`exhale_variable_namespacelibecpint_1a20c4903045164881b8dedf0d6a6ed0fb`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp:

Program Listing for File ecp.cpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/ecp.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "ecp.hpp"
   
   #include <cmath>
   #include <iostream>
   #include <algorithm>
   #include "pugixml.hpp"
   #include "mathutil.hpp"
   
   namespace libecpint {
   
       // GaussianECP constructor and copy constructor
       GaussianECP::GaussianECP() : n(0), l(0), a(0), d(0) {}
       GaussianECP::GaussianECP(
           const int _n, const int _l, const double _a, const double _d) : n(_n-2), l(_l), a(_a), d(_d) {}
       GaussianECP::GaussianECP(const GaussianECP& other) : n(other.n), l(other.l), a(other.a), d(other.d) {}
   
   
       // class ECP
   
       ECP::ECP() : N(0), L(-1) {
           center_[0] = center_[1] = center_[2] = 0.0;     
           min_exp = 1000.0;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
                min_exp_l[i] = 1000.0;
                l_starts[i] = 0;
           }
           l_starts[LIBECPINT_MAX_L+1] = 0;
       }
       
       ECP::ECP(const double *_center) : N(0), L(-1) {
           center_[0] = _center[0];
           center_[1] = _center[1];
           center_[2] = _center[2];
           min_exp = 1000.0;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
                min_exp_l[i] = 1000.0;
                l_starts[i] = 0;
           }
           l_starts[LIBECPINT_MAX_L+1] = 0;
       }
   
       ECP::ECP(const ECP &other) {
           gaussians = other.gaussians;
           N = other.N;
           L = other.L;
           min_exp = other.min_exp;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
               min_exp_l[i] = other.min_exp_l[i];
               l_starts[i] = other.l_starts[i];
           }
           l_starts[LIBECPINT_MAX_L+1] = other.l_starts[LIBECPINT_MAX_L+1];
           center_ = other.center_;
       }
   
       void ECP::addPrimitive(
         const int n, const int l, const double a, const double d, const bool needSort) {
           GaussianECP newEcp(n, l, a, d);
           gaussians.push_back(newEcp);
           N++;
           L = l > L ? l : L;
           min_exp = a < min_exp ? a : min_exp;
           min_exp_l[l] = a < min_exp_l[l] ? a : min_exp_l[l];
           for (int lx = l+1; lx < LIBECPINT_MAX_L + 2; lx++)
               l_starts[lx] += 1;
           if (needSort) sort();
       }
   
       void ECP::sort() {
           std::sort(gaussians.begin(), gaussians.end(),
           [&] (const GaussianECP& g1, const GaussianECP& g2) {return (g1.l < g2.l);});
       }
       
       bool ECP::noType1() const {
           bool zero = true;
           for (auto& g : gaussians)
               if (g.l == L && fabs(g.d) > 1e-12) zero = false; 
           return zero; 
       }
   
       // Evaluate U_l(r), assuming that gaussians sorted by angular momentum
       double ECP::evaluate(const double r, const int l) const {
           double value = 0.0;
           double r2 = r*r;
           int p;
           for (int i = l_starts[l]; i < l_starts[l+1]; i++) {
               p = gaussians[i].n > -1 ? gaussians[i].n : MAX_POW - gaussians[i].n;
               value += FAST_POW[p](r) * gaussians[i].d * exp(-gaussians[i].a * r2);
           } 
           return value; 
       }
   
       void ECP::setPos(const double x, const double y, const double z) {
           center_[0] = x; center_[1] = y; center_[2] = z;
       }
   
       ECPBasis::ECPBasis() : N(0), maxL(-1) {}
   
       void ECPBasis::addECP(const ECP &U, const int atom) {
           basis.push_back(U);
           atomList.push_back(atom);
           N++;
           maxL = U.getL() > maxL ? U.getL() : maxL;
       }
   
     ECP& ECPBasis::getECP(const int i) { return basis[i]; }
     const ECP& ECPBasis::getECP(const int i) const { return basis[i]; }
   
       int ECPBasis::getECPCore(const int q) const {
           int core = 0;
           auto it = core_electrons.find(q);
           if (it != core_electrons.end()) core = it->second;
           return core;
       }
       
       void ECPBasis::addECP_from_file(
         const int q, const std::array<double, 3> & coords, const std::string & filename) {
           ECP newECP;
           newECP.center_ = coords;
   
           std::string atom_name = q < 1 ? "X" : atom_names[q-1]; 
           pugi::xml_document doc;
           pugi::xml_parse_result result = doc.load_file(filename.c_str());
           pugi::xml_node atom_node = doc.child("root").child(atom_name.c_str()); 
           int maxl = std::stoi(atom_node.attribute("maxl").value());
           int ncore = std::stoi(atom_node.attribute("ncore").value()); 
           
           auto it = core_electrons.find(q);
           if (it == core_electrons.end())
               core_electrons[q] = ncore; 
       
           for (pugi::xml_node shell = atom_node.child("Shell"); shell; shell = shell.next_sibling("Shell")) {
   
               int l = std::stoi(shell.attribute("lval").value());
               
               for (pugi::xml_node nxc = shell.child("nxc"); nxc; nxc = nxc.next_sibling("nxc")) {
                   int n = std::stoi(nxc.attribute("n").value()); 
                   double x = std::stod(nxc.attribute("x").value()); 
                   double c = std::stod(nxc.attribute("c").value()); 
                   newECP.addPrimitive(n, l, x, c); 
               }
           }
           
           newECP.sort();
           addECP(newECP, 0);
       }
   }
:orphan:


Full API
========

Directories
***********


.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_include.rst

.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_include_libecpint.rst

.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_src.rst

.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_src_generated.rst

.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_src_generated_radial.rst

.. toctree::
   :maxdepth: 5

   dir__Users_robertshaw_devfiles_libecpint_src_lib.rst

Files
*****


.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_generate.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_generate.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_makelist.py.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_README.md.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp.rst

.. toctree::
   :maxdepth: 5

   file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py.rst
.. _exhale_function_namespacelibecpint_1_1qgen_1a179f27d18c3e44e4d6d77a0713ffbe2d:

Function libecpint::qgen::Q1_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1afb34239e6c998eae905ec5d398d4b184:

Function libecpint::qgen::Q1_1_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a15cb24b7b0a3530c911ff0c782ef3378:

Function libecpint::pow_18
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_18(double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp:

Program Listing for File angular.cpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/angular.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "angular.hpp"
   #include "bessel.hpp"
   #include "mathutil.hpp"
   #include <cmath>
   
   namespace libecpint {
   
       double AngularIntegral::calcG(const int l, const int m) const {
           double value = 0.0;
           double value1 = FAST_POW[l](2.0) * FAC[l];
           value1 = 1.0 / value1; 
           double value2 = (2.0 * l + 1) * FAC[l - m] / (2.0 * M_PI * FAC[l + m]);
           value2 = std::sqrt(value2); 
           value = value1 * value2;
           return value;
       } 
   
       double AngularIntegral::calcH1(
         const int i, const int j, const int l, const int m) const {
           double value = 0.0; 
   
           value = FAC[l]/(FAC[j]*FAC[l - i]*FAC[i-j]);
           value *= (1 - 2*(i%2)) * FAC[2*(l - i)] / (FAC[l - m - 2*i]);
   
           return value;
       }
   
       double AngularIntegral::calcH2(
         const int i, const int j, const int k, const int m) const {
           double value = 0.0; 
           int ki2 = k - 2*i;
           if ( m >= ki2 && ki2 >= 0 ) {
               value = FAC[j]*FAC[m]/(FAC[i] * FAC[j-i] * FAC[ki2] * FAC[m-ki2]);
               int p = (m - k + 2*i)/2;
               value *= (1.0 - 2.0*(p%2));
           }
           return value;
       }
   
   
       ThreeIndex<double> AngularIntegral::uklm(
         const int lam, const int mu) const {
           ThreeIndex<double> values(lam+1, lam+1, 2);
        
           double or2 = 1.0/std::sqrt(2.0);
           double u = 0.0;
           double um = 0.0;
           double g = calcG(lam, mu);
   
           double u1, h1, h2;
           int j;
           for (int k = 0; k <= lam; k++) {
               for (int l = 0; l <= lam - k; l++) {
                   u = um = 0.0;
                   j = k + l - mu;
                   if (j % 2 == 0 && j > -1) { 
                       u1 = 0.0;
                       j/=2;
                       for (int i = j; i <= (lam - mu)/2; i++) u1 += calcH1(i, j, lam, mu);
               
                       u = g * u1;
                       u1 = 0;
                       for (int i = 0; i <= j; i++) u1 += calcH2(i, j, k, mu);
                       u *= u1;
                       um = u;
               
                       j = l % 2;
                       u *= (1 - j);
                       um *= j;
                       if (mu == 0) {
                           u *= or2;
                           um = u;
                       } 
                   }
                   values(k, l, 0) = u;
                   values(k, l, 1) = um;
               }
           }
           return values;                      
       }
   
   
       ThreeIndex<double> AngularIntegral::Pijk(const int maxI) const {
           int dim = maxI+1;
           ThreeIndex<double> values(dim, dim, dim);
           double pi4 = 4.0*M_PI;
       
           values(0, 0, 0) = pi4;
           for (int i = 1; i <= maxI; i++) {
               values(i, 0, 0) = pi4 / ((double) (2*i+1));
           
               for (int j = 1; j <= i; j++) {
                   values(i, j, 0) = values(i, j-1, 0) * (2.0*j - 1.0) / (2.0 * ((double)(i + j)) + 1.0);
               
                   for (int k = 1; k <= j; k++)
                       values(i, j, k) = values(i, j, k-1) * (2.0*k - 1.0) / (2.0 * ((double)(i + j + k)) + 1.0);
               
               }
           }
           return values;
       }
   
       FiveIndex<double> AngularIntegral::makeU() const {
           int dim = maxL + 1;
   
           FiveIndex<double> values(dim, dim, dim, dim, 2);
           for (int lam = 0; lam <= maxL; lam++) {
               for (int mu = 0; mu <= lam; mu++) {
                   ThreeIndex<double> Uij = uklm(lam, mu);
                   for (int i = 0; i <= lam; i++) {
                       for (int j = 0; j <= lam - i; j++){
                           values(lam, mu, i, j, 0) = Uij(i, j, 0);
                           values(lam, mu, i, j, 1) = Uij(i, j, 1);
                       }
                   }
               }
           }
       
           return values;
       }
   
       void AngularIntegral::makeW(const FiveIndex<double> &U) {
           int LB2 = 2*LB;
           int dim = wDim;
           int maxI = (maxL + dim)/2;
           int maxLam = maxL;
       
           FiveIndex<double> values{dim+1, dim+1, dim+1, maxLam+1, 2*(maxLam + 1)};
           ThreeIndex<double> pijk = Pijk(maxI);
       
           int plam, pmu;
           double smu, w;
           std::vector<int> ix(3);
           for (int k = 0; k <= dim; k++) {    
               for (int l = 0; l <= dim; l++) {    
                   for(int m = 0; m <= dim; m++) {
                       plam = (k + l + m)%2;
                   
                       int limit = maxLam > k+l+m ? k+l+m : maxLam;
                       for(int lam = plam; lam <= limit; lam += 2){
                           smu = 1 - 2*(l%2);
                           pmu = (k+l) % 2;
                       
                           for (int mu = pmu; mu <= lam; mu+=2) {
                               w = 0.0;
                               for (int i = 0; i <= lam; i++) {
                                   for (int j = 0; j <= lam - i; j++) {
                                       ix[0] = k+i;
                                       ix[1] = l+j;
                                       ix[2] = m + lam - i - j; 
                                   
                                       if (ix[0]%2 + ix[1]%2 + ix[2]%2 == 0){
                                           std::sort(ix.begin(), ix.end()); 
                                           w += U(lam, mu, i, j, (1 - (int)(smu))/2)*pijk(ix[2]/2, ix[1]/2, ix[0]/2);
                                       }
                                   
                                   }
                               }
                           
                               values(k, l, m, lam, lam+(int)(smu*mu)) = w;
                           }
                       }   
                   }   
               }   
           }
           W = values;
       }
   
       void AngularIntegral::makeOmega(const FiveIndex<double> &U) {
       
           int lamDim = LE + LB; 
           int muDim = 2*lamDim + 1;
           SevenIndex<double> values{LB+1, LB+1, LB+1, lamDim+1, muDim+1, lamDim+1, muDim+1};
           
           double om_plus=0.0, om_minus=0.0;
           double wval; 
           for (int k = 0; k <= LB; k++) {
               for (int l = 0; l <= LB; l++) {
                   for (int m = 0; m <= LB; m++) {
                       
                       for (int rho = 0; rho <= lamDim; rho++ ) {
                           for (int sigma = -rho; sigma <= rho; sigma++) {
                           
                               for (int lam = 0; lam <= rho; lam++) {
       
                                   for (int mu = 0; mu <= lam; mu++) {
                                   
                                       om_plus = om_minus = 0.0;
                                       for (int i = 0; i<= lam; i++ ) {
                                           for (int j = 0; j <= lam - i; j++) {                                                
                                               wval = W(k+i, l+j, m+lam-i-j, rho, rho+sigma);
                                               om_plus += U(lam, mu, i, j, 0) * wval;
                                               om_minus += U(lam, mu, i, j, 1) * wval;
                                           }
                                       }
                                       if (mu == 0) om_minus = om_plus;
                                       values(k, l, m, rho, sigma+rho, lam, lam+mu) = om_plus;
                                       values(k, l, m, lam, lam+mu, rho, sigma+rho) = om_plus;
                                       values(k, l, m, rho, sigma+rho, lam, lam-mu) = om_minus;
                                       values(k, l, m, lam, lam-mu, rho, sigma+rho) = om_minus;
                                   
                                   }
                               }
                           
                           }
                       }
                       
                   }
               }
           }
       
           omega = values;
       }
   
       AngularIntegral::AngularIntegral() { init(0, 0); }
       AngularIntegral::AngularIntegral(const int _LB, const int _LE) { init(_LB, _LE); }
       void AngularIntegral::init(const int _LB, const int _LE ) {
           LB = _LB;
           LE = _LE;
           wDim = 4*LB > 3*LB + LE ? 4*LB : 3*LB + LE;
           maxL = 2*LB > LB + LE ? 2*LB : LB+LE;
       
       }
   
       void AngularIntegral::compute() {
           FiveIndex<double> U = makeU();
           makeW(U);
           makeOmega(U);
       }
   
       void AngularIntegral::clear() {}
   
       double AngularIntegral::getIntegral(
         const int k, const int l, const int m, const int lam, const int mu) const {
       return W(k, l, m, lam, lam+mu);
       }
       double AngularIntegral::getIntegral(
         const int k, const int l, const int m, const int lam, const int mu, const int rho, const int sigma) const {
         return omega(k, l, m, lam, lam+mu, rho, rho+sigma);
       }
   
       bool AngularIntegral::isZero(
         const int k, const int l, const int m, const int lam, const int mu, const double tolerance) const {
           if (wDim > 0) return std::fabs(W(k, l, m, lam, lam+mu)) < tolerance;
           else return true;
       }
       bool AngularIntegral::isZero(
         const int k, const int l, const int m, const int lam, const int mu, const int rho, const int sigma, const double tolerance) const {
           if (wDim > 0) return std::fabs(omega(k, l, m, lam, lam+mu, rho, rho+sigma)) < tolerance;
           else return true;
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a88f6bba85f7bbfccf8a9ccd31a229c54:

Function libecpint::qgen::Q2_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a544c252dcf08f3ce5560b8066730601c:

Function libecpint::shell_bound
===============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::shell_bound(int, double, double, double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a6a80fb42ebc7edfd76662bee54b73717:

Function libecpint::qgen::Q3_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab6099b7e4ee5c323c4ec2c6e939ae699:

Function libecpint::qgen::Q0_0_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp:

File qgen.hpp
=============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Generated header of generated integral functions. 
 

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/qgen.hpp``)
------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`)

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`)



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp`




Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__qgen`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a93436d53d6ef5500eb458ef11e8043ac`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ad0ca8d8424656a9535a6feadae469fab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a54295e912bd54f3f8c4e67c9d8497b6d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af524f71fe882318cfb0204f01004e173`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a460b4be26220556a7fab6c56fd0798ca`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa968da184da74332ebb64840fca37563`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af85290fe10772c77a0e271ef9a294439`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2cacc14c8239c3f202631e089a75bf8f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a119daa634903dbecf64d19eb5ba15d08`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4102cedccaa2b99ae690e9b8c69551c2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af27c1bf759fb1fcdd066d4631339342f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a15199caa67de1996017f60b214ad3d14`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a151b9ededca4173cafa6df8d87d96fd5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af85e85322bbdc11c456c2e6cf87e1f03`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae06aaa3298e7e07f2a3ac58799292f5a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab42100cc0c65d9f9cd2e667cc81bc808`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac8041349c5e5382f5589ab5556c82060`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7330c93ccc3ee07d2e17264c2f418527`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac47c5efbc05973541703abc8265d2dc6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa4d41ca8cc3ec21577526011329df084`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a61a0d2a085bc8553dd2c9bffc8ad5abf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a999bc28a5d80787f03cc1a3ff1a8c39b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a71c8b6f8381698df16df610a6ef84e72`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5f05d08a900405de7047d06a22e5ba2f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5fc2c9a204e7c97db133573731819a2a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab91f04eece262074221b150ca5e0e62a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab3e29d310b8765ca9dc9ae7e881b42bb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aacd750e55133a09211f6abfe0ea4ea3b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1acc501264ac82792276fdb06aa2e68d28`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a18ae7c31a4c8120fcd149296f8544064`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0e99841554fc02fa5d534f6314e28134`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a38cc09dd01fd2186761a9b42df9e4bb3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afd5e9e8fbfdce4c6713251e1f147e5d6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a713950e1242796aa631a0d0aab602a42`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2dd9ddbb3213eea5af524a6ff34ecd73`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a37f5258284037a0bf3bd897cf2aaf637`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a29754bb55ad841e326de3c986f8e2848`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a58617819fd10d1083afc396fbc79e387`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afb34239e6c998eae905ec5d398d4b184`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a769451399d6f3ecc4f51f12d01e80449`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae04fe02eb63130146d27b9b21029f7a0`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab8fa7b1e013dfc11d1db5095fa31b1f4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a382cf81c48b6fae7aeba3be5ae6e457b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac539befd8e56f73c61f5a32909e357da`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afd292aa3e56e39b254622448c50b1c66`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa362053769b5edcb1ec8552f10d52be6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a013e0cc0f5b8223acc2c0f4877d450b8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a129a37d497b2f5a3a1c3819edbe479df`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a924e19764d9f679e62ae85fc6cac2410`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9893d98cd4ed014e325e9d6392f40ac8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a483926fa6186bbe5c39fdc797ea816b2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a73b671bedf8c4d6dd679961436290720`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3ed03cc7f1a6e5af9a85708f81d80f8a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae9258caecf0017cc7782591e0f75b61e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af7a7b5fedc7e77a0a124d2d8d94caef1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4e660a607aefaeda5a7b0aff0921c062`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a90ba6aa515ccce14c9f5e63b24be86aa`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae6cb9ae3d166614d151089947c8eb841`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4fe80a30975e5d5c8af497fd15a760e4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1acf2f1092a3b6f0098de49c3da234df38`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a700b1c6b4c5327e2f395e38c0cac99ba`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1af44e43779236559458dd5ef1f683ce`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5f8d53e84a9fc1a22075e13987d9608e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae4734bbfb388d811ede625b79a188e62`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1acac155055f27ee3111437ed638b1c600`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3e60d04afe7a4e07551c971a040eeaba`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac6caab55a19cf3268cf3c56d3575034b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae25acfbdd96fea07bf14a59e02fc7d54`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1d4e032617fe380182fe6046722aff4a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae1ab26e9c37e6099370e5eac81e387bb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a67e080a65877ef94a995b6375c8f813a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2861e6d26d3067ac962e777a165cf432`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1d96905f9de2c9caaba87c3790f6d30b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af14b5de42b087d7ed2768844928538c2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0415776547539e74b707bb57a725a26e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a21be6a1d89b69da23eb7b760e4beabd3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a65d824b28264272e12f6b2487b639711`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ade873e867bdb6757b88643c0958ab880`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2c596f5f83378630677beef4ae8f43cf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a463f70942e5de5172504d92ec6cc9616`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae71431041dc69e2d429acbf54f03464d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7e6a3a6f82a7b50654fd980987749345`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a88f6bba85f7bbfccf8a9ccd31a229c54`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af087e0cdf5de3780ae754e9c6f657198`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abba30dd871f615eb80d23752522d6de1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a42f16a690d170eb768ff7d5dd750c063`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a72f978eff7e1d723f1107a637a6b580b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0bcc591d16e3a934158e56cd0ded726d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3608b27342d00fa484af93de4a9e146d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af7feca81393dc22989d13c41975ae8b3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0c98c29930ffdb324f6df35cc1f9544c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac0c591b25ebe3779266e40f02e37125c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4fb015300d593d8ee8166eb84afacb32`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7e4b20f55e6c486cca3d72e08d159b97`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aaa40ba470be53681e75b124354b40c2c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9e2847158ffcacd0a6fc12a455e63309`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a704923aff02da8fec8e6586d2023f8b2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2752f2e9ae667bd4ce018630be1e9c13`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5e894ba7de331a41aaa57f9136024631`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab8ec2d5a9021a4daaf5ad8b94db84cf2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a8b1013e12370dc883604a9d26f8d7155`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5a713efe907c5b99f9149dd14b2c749b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a11ea2c964fa710815e0bb651095b978b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a09e068e7ce72609cffab0a5aaf998137`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a804aaa1e22a0d6ad6da870c708054007`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abf0f13ffec33887ba20dfde547d1acaa`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1df8ea2e2fe35050d24bd0541119fa29`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a85275daf2de3182417a0f5a3ffac47c5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5febb3c055ce4769bc1a750f98758aab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa3d5947febd6747a1936eb7228e486e5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4f3562bdf89c17a5fcd755bc68268194`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a785079edd6208c7b4f42d9bbed24b8a6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5d4d33e9ee0c2a5d2c70296a32ad3eb8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aae455a07b0f1ce8adcd58402bea39b9a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a966d79e1526e747a20f26196ed2bd2bc`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a17ab9d6e76588a000009bd6140f80914`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab67f57b4dcbf7d27e721e40909390e0c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aba194c04414f2de09dbb83bc7a528dfe`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac9d4bb955ad433fe833a829b93a77792`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0c072abf561409c52e122563986c170b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3cf2623a8ae1e20ff29a8bc1b11b9565`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac1323c46145017941ea6c3937d114742`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae9d2f56806b38c9ea0b1c3d8af64c9f4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a85e0f26686e72471e0f9eacffb1c75c9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a76b4f2b3f83e17a3f3b81962f2061e4b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a34b21851b77f09f49aea3c0ca550f9b2`

.. _exhale_function_namespacelibecpint_1a697a408875eb033819881bc8d5fd3cec:

Function libecpint::pow_16
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_16(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac50f25410860af3e1c8203648ed6c8ae:

Function libecpint::qgen::Q0_0_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp:

Program Listing for File ecp.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/ecp.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ECP_HEAD
   #define ECP_HEAD
   
   #include <vector>
   #include <array>
   #include <map>
   #include <string>
   #include "config.hpp"
   
   namespace libecpint {
       
       const std::string atom_names[109] = {"h", "he", "li", "be", "b", "c", "n",
           "o", "f", "ne", "na", "mg", "al", "si", "p", "s", "cl", "ar",
           "k", "ca", "sc", "ti", "v", "cr", "mn", "fe", "co", "ni", "cu",
           "zn", "ga", "ge", "as", "se", "br", "kr", "rb", "sr", "y", "zr",
           "nb", "mo", "tc", "ru", "rh", "pd", "ag", "cd", "in", "sn", "sb",
           "te", "i", "xe", "cs", "ba", "la", "ce", "pr", "nd", "pm", "sm",
           "eu", "gd", "tb", "dy", "ho", "er", "tm", "yb", "lu", "hf", "ta",
           "w", "re", "os", "ir", "pt", "au", "hg", "tl", "pb", "bi", "po",
           "at", "rn", "fr", "ra", "ac", "th", "pa", "u", "np", "pu", "am",
           "cm", "bk", "cf", "es", "fm", "md", "no", "lr", "rf", "db", "sg",
           "bh", "hs", "mt" };
       
       struct GaussianECP {
           int n; 
           int l; 
           double a; 
           double d; 
       
           GaussianECP(); 
           
           GaussianECP(const int n, const int l, const double a, const double d);
           
           GaussianECP(const GaussianECP& other);
       };
   
       struct ECP {
           std::vector<GaussianECP> gaussians; 
           int N; 
           int L; 
           int atom_id; 
           double min_exp; 
           double min_exp_l[LIBECPINT_MAX_L+1]; 
           int    l_starts[LIBECPINT_MAX_L+2]; 
           
           std::array<double, 3> center_; 
       
           ECP();
           
           ECP(const double *_center);
           
           ECP(const ECP &other);
       
           void addPrimitive(const int n, const int l, const double a, const double d, const bool needSort = true);
           
           const double* center() const { return &center_[0]; }
           
           void setPos(const double x, const double y, const double z);
           
           void sort(); 
           
           GaussianECP& getGaussian(int i) { return gaussians[i]; }
       const GaussianECP& getGaussian(int i) const { return gaussians[i]; }
           int getN() const { return N; }
           
       bool noType1() const;
       
           double evaluate(const double r, const int l) const;
     
           int getL() const { return L; }
       
       };
   
       class ECPBasis {
       private:
           std::vector<ECP> basis;    
           std::vector<int> atomList; 
           int N; 
           int maxL; 
       
       public:
           ECPBasis(); 
           
           std::map<int, int> core_electrons;
           
           void addECP(const ECP &U, const int atom);
           
           ECP& getECP(const int i);
       const ECP& getECP(const int i) const;
           int getECPCore(const int q) const;
           
           int getAtom(int i) const { return atomList[i]; }
           
           int getMaxL() const { return maxL; }
           
           int getN() const { return N; }
           
           void addECP_from_file(
               const int q, const std::array<double, 3> & coords, const std::string & filename);
       };
   
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a7f4b88955a96847da3ebc5c50d56e6d1:

Function libecpint::qgen::Q0_1_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a8b1013e12370dc883604a9d26f8d7155:

Function libecpint::qgen::Q3_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_generate_8cpp_1abefb1d8e3468d04e0e82fd81b63169f7:

Variable CAX3
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: CAX3
.. _exhale_variable_namespaceunrol__radial_1a032ec358895dd239986cf46342a0de86:

Variable unrol_radial::q
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Variable Documentation
----------------------


.. doxygenvariable:: unrol_radial::q
.. _exhale_function_namespacelibecpint_1_1qgen_1a4ba269ea8b6a2e9c61df0785448a5778:

Function libecpint::qgen::Q4_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a4fe80a30975e5d5c8af497fd15a760e4:

Function libecpint::qgen::Q1_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a069479eb4b49ece5f8f9651b5f87c777:

Variable libecpint::TAYLOR_CUT
==============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::TAYLOR_CUT
.. _exhale_function_namespacelibecpint_1_1qgen_1ae94ff95331b2a7d7582d833e57e1a730:

Function libecpint::qgen::Q3_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp:

File radial_gen.cpp
===================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/radial_gen.cpp``)
----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1aba431d549c947101b9d20b8ae5cb521a:

Function libecpint::qgen::Q2_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp:

Program Listing for File ecpint.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/ecpint.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ECPINT_HEAD
   #define ECPINT_HEAD
   
   #include <vector>
   #include <array>
   #include "multiarr.hpp"
   #include "gaussquad.hpp"
   #include "ecp.hpp"
   #include "bessel.hpp"
   #include "radial.hpp"
   #include "angular.hpp"
   #include "gshell.hpp"
   
   #include "config.hpp"
   
   namespace libecpint {
   
   #define N_INDEX(l, m) (((l+m)*(l+m+1))/2 + m)
   
       class ECPIntegral
       {
       private:
           RadialIntegral radInts; 
           AngularIntegral angInts; 
                   
           double tolerance = 1e-12;
       
           double calcC(int a, int m, double A) const;
           
           static void(*QGEN[LIBECPINT_MAX_L+1][LIBECPINT_MAX_L+1][LIBECPINT_MAX_L+1])(ECP&, GaussianShell&, GaussianShell&,
            FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double,
            RadialIntegral&, AngularIntegral&, ThreeIndex<double>&);
   
       public:
           int skipped, zero, nonzero;
           
           void makeC(FiveIndex<double> &C, int L, double *A);
           
           ECPIntegral(int maxLB, int maxLU, int deriv=0);
       
           void type1(ECP& U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, FiveIndex<double> &CA, FiveIndex<double> &CB, TwoIndex<double> &values);
           
           void type2(int l, ECP& U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, FiveIndex<double> &CA, FiveIndex<double> &CB, ThreeIndex<double> &values);
           
           void estimate_type2(ECP& U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, double* results);
       
           void compute_shell_pair(ECP &U, GaussianShell &shellA, GaussianShell &shellB, TwoIndex<double> &values, int shiftA = 0, int shiftB = 0);
           
           void compute_shell_pair_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 9> &results);
           
           void compute_shell_pair_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 45> &results);
           
           void left_shell_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 3> &results); 
           
           void left_shell_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 6> &results); 
           
           void mixed_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 9> &results); 
           
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a18ae7c31a4c8120fcd149296f8544064:

Function libecpint::qgen::Q0_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af9a4da1d53cb16463d2d1144809f55c7:

Function libecpint::qgen::Q2_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2d3f70e323ad33a72441e7bc597491c2:

Function libecpint::qgen::Q5_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1ac8004320c2b47b1ce75ab1ccfff376e4:

Function libecpint::realSphericalHarmonics
==========================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::realSphericalHarmonics(int, double, double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5e894ba7de331a41aaa57f9136024631:

Function libecpint::qgen::Q3_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af7feca81393dc22989d13c41975ae8b3:

Function libecpint::qgen::Q2_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_struct_structlibecpint_1_1aux_1_1gen__seq:

Template Struct gen_seq
=======================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::aux::gen_seq
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp:

File radial_gen.cpp
===================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_generated_radial>` (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial/radial_gen.cpp``)
---------------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a3bdb99b42efd94923116ddaf39352437:

Function libecpint::qgen::Q0_1_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2746fee105d370ee314fe22e752affeb:

Function libecpint::qgen::rolled_up_special
===========================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::rolled_up_special(int, int, int, ThreeIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1afd292aa3e56e39b254622448c50b1c66:

Function libecpint::qgen::Q1_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac3aed6a829f009e3b82e84a90dc492c3:

Function libecpint::qgen::Q2_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _namespace_sympy:

Namespace sympy
===============


.. contents:: Contents
   :local:
   :backlinks: none



.. _exhale_function_namespacelibecpint_1_1qgen_1a769451399d6f3ecc4f51f12d01e80449:

Function libecpint::qgen::Q1_1_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacemakelist_1a92f763e70ec614d7cc630b6b3afc201e:

Variable makelist::max_am
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_makelist.py`


Variable Documentation
----------------------


.. doxygenvariable:: makelist::max_am
.. _exhale_function_namespacelibecpint_1aceff25bd00ac616a0c1679c43c757c25:

Function libecpint::pow_8
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_8(const double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp:

Program Listing for File gaussquad.cpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/gaussquad.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "gaussquad.hpp"
   #include <cmath>
   #include <iostream>
   
   namespace libecpint {
   
       // Constructor
       GCQuadrature::GCQuadrature() {
           // Currently does nothing
       }
   
   
       GCQuadrature::GCQuadrature(const GCQuadrature &other) {
           maxN = other.maxN;
           M = other.M;
           I = other.I;
           start = other.start;
           end = other.end; 
           t = other.t;
           x = other.x;
           w = other.w;
       }
   
       // Initialise the quadrature grid
       // As described in both Perez92 and Perez93
       void GCQuadrature::initGrid(int points, GCTYPE _t) {
           t = _t;
       
           // Initialise parameters for grid
           int p;
           if (t == ONEPOINT) { // Perez92 one point method
               // We need the number of points to be of the form
               // 2^p - 1 for some power p. 
               p = (int) floor(log(points + 1)/log(2));
               maxN = pow(2, p) - 1;
           } else if (t == TWOPOINT) { // Perez93 two point method
               // Here we need it instead to be of the form
               // 3 * 2^p - 1 for some p.
               p = (int) floor(log((points + 2)/3.0)/log(2));
               maxN = 3*pow(2, p) - 1;
           }
           M = (maxN-1)/2; // Midpoint
           start = 0;
           end = maxN - 1;
       
           // initialise arrays
           x.assign(maxN, 0.0);
           w.assign(maxN, 0.0);
       
           // At the midpoint, M, x[M] = 0 and w[M] = 1
           x[M] = 0.0; w[M] = 1.0;
           // The rest of the abscissae and weights are then given by:
           // z_i = i*Pi / (maxN + 1), s_i = sin(z_i), c_i = cos(z_i)
           // x_i = 1 + 2/(3*pi) * [ (3 + 2*s_i^2) * c_i * s_i - 3z_i]
           // (3(maxN + 1)/16) * w_i = s_i^4
           // We then note that s_(i+1) = c_1 s_i + s_1 c_i
           // and c_(i+1) = c_1 c_i - s_1 s_i
           // with z_(i+1) = z_i + z_1
           // Clearly s_(maxN + 1 - i) = s_i
           // and c_(maxN + 1 - i) = -c_i
           // Therefore x_(maxN + 1 - i) = -x_i
           // and w_(maxN + 1 - i) = w_i
           // Meaning that we only have to calculate half the weights and abscissae
           double z1 = M_PI / ((double)(maxN + 1));
           double c1 = cos(z1); double s1 = sin(z1);
           double zi, si, ci, zi1, si1, ci1; //z_i, s_i, c_i, z_(i+1), s_(i+1), c_(i+1)
           zi1 = z1; si1 = s1; ci1 = c1;
           double o23pi = 2.0 / (3.0 * M_PI); // Convenient
           double s2; //si * si
           for (int n = 0; n < M; n++) {
               // First update zi, si, ci
               zi = zi1;
               si = si1;
               ci = ci1;
               s2 = si * si;
           
               // Now determine the w and x values
               w[maxN - 1 - n] = w[n] = s2 * s2;
               x[n] = 1 + o23pi * ( (3.0 + 2.0 * s2) * ci * si - 3.0*zi );
               x[maxN - 1 - n] = x[n];
               x[n] = -x[n];
           
               // Then update zi1, si1, ci1
               zi1 = zi + z1;
               si1 = c1 * si + s1 * ci;
               ci1 = c1 * ci - s1 * si;
           }
       
           /*std::cout << maxN << " " << M << " " << start << " " << end << "\n";
           for (int q = 0; q < maxN; q++) std::cout << x[q] << " " << w[q] << "\n";*/
       }
   
       // Perform the GC integration on the function f
       bool GCQuadrature::integrate(std::function<double(double, double*, int)> &f, double *params, const double tolerance) {
           bool converged = false; // 0 for converged, -1 for not converged
       
           if (t == ONEPOINT) {
               // Perez92 Case
               // Integration proceeds in the sequence T_1, T_3, T_7, ..., T_{maxN}
               // where T_m = (3(m+1)/16)I_m
               // by using the fact that T_{2m + 1} = T_{m} + sum_{k = 0}^m w_{2k+1}f(x_{2k+1})
               // The indices in terms of the maxN indices are given by 
               // 2k + 1 = (2k + 1) * M / 2^n = (2k + 1) * p
               // and checking convergence via whether
               // (T_{2m + 1} - 2T_m)^2 <= |T_{2m+1} - 4T_{(m-1)/2}| x tolerance
               double Tn, T2n1, Tn12; // T_n, T_{2n+1} and 4T_{(n-1)/2}
           
               // Initialise values, 
               // Single point integration would use midpoint, M
               Tn = w[M]*f(x[M], params, M);
               Tn12 = 2.0 * Tn;
           
               // Main loop
               int n = 1;
               double dT; // T_{2n+1} - 2T_n
               int ix; // Index needs to be calculated to know which points to use
               int p = (M+1) / 2; // M / 2^n 
               while (n < maxN && !converged) {
                   // Compute T_{2n+1}
                   T2n1 = Tn + sumTerms(f, params, n, p, 2);
               
                   // Check convergence
                   dT = T2n1 - 2.0*Tn;
                   n = 2*n + 1;
                   if (dT*dT <= fabs(T2n1 - Tn12)*tolerance) {
                       converged = true;  
                   } else {
                       Tn12 = 4.0 * Tn; 
                       Tn = T2n1;
                       p /= 2; 
                   }
               }
               // Finalise the integral
               I = 16.0 * T2n1 / (3.0*(n + 1.0));
           
           } else if (t == TWOPOINT) {
               // Perez93 case
               // We instead proceed along T_2, T_5, T_11, ..., T_{2m + 1} where maxN = 2m+1
               // but also compute T_1, T_3, ..., T_n, T_{2n+1} etc. as before,
               // where m + 1 = 3/2(n+1), so as to get better error control
               // To do this, we use that 
               // T_{2m+1} = T_m + T_n - T_{(n-1)/2} + sum_{i=0}^{(m-2)/3} [w_{6i+1}f(x_{6i+1}) + w_{6i+5}f(x_{6i+5})]
               // along with the same results as before. 
               // The algorithm proceeds by calculating one in the two-point sequence,
               // using an error of |I_{2m+1} - I_m|, then calculates one in the one-point sequence
               // and uses an error of |I_m - I_n|, to check convergence.
               double Tn, Tm, T2n1, T2m1, Tn12;
           
               // Initialise values
               Tn12 = 0.0; 
               Tn = w[M]*f(x[M], params, M);
               int M2 = (maxN - 2)/3; //Index of first point in twopoint sequence
               Tm = w[M2]*f(x[M2], params, M2) + w[maxN - M2 - 1]*f(x[maxN - M2 - 1], params, maxN - M2 - 1);
               int p = (M+1) / 2; // as before
               M2 = (M2 + 1)/2; 
               int ix; 
               int n = 1; int m = 2;
               double error;
            
               while(m < maxN && !converged) {
                   // Propagate the two-point sequence first 
                   T2m1 = Tm + Tn - Tn12 + sumTerms(f, params, (2*m - 1)/3, M2, 3);
               
                   // Check convergence
                   error = 16.0 * fabs(0.5*T2m1 - Tm) / (3.0 * (m + 1)); 
                   if (error > tolerance) {
                       // Propagate the one-point sequence
                       T2n1 = Tn + sumTerms(f, params, n, p, 2); 
                   
                       // Check convergence again
                       error = 16.0 * fabs(2.0*T2m1 - 3.0*T2n1) / (18.0 * (n+1) );
                       m = 2 * m + 1;
                       n = 2 * n + 1;
                       if ( error < tolerance) {
                           converged = true; 
                       } else {
                           Tn12 = Tn;
                           Tn = T2n1;
                           Tm = T2m1; 
                           p /= 2;
                           M2 /= 2; 
                       }
                   } else {
                       m = 2 * m + 1;
                       converged = true; 
                   }
               }
               // Finalise the integral
               I = 16.0 * T2m1 / (3.0 * (m + 1.0));
           }
       
           return converged;
       }
   
       // Worker function to do the additional sum terms when going from I_n to I_{2n+1}
       double GCQuadrature::sumTerms(std::function<double(double, double*, int)> &f, double *p, int limit, int shift, int skip) {
           double value = 0.0;
           int ix; 
           for (int i = 0; i <= limit; i+=2) { 
               ix = (skip*i + 1)*shift - 1;
               if (ix >= start)
                   value += w[ix] * f(x[ix], p, ix);
           
               ix = maxN - ix - 1; 
               if (ix <= end)
                   value += w[ix] * f(x[ix], p, ix);
           }
           return value;
       }
   
       // The GC integrations above are over the interval [-1, 1] and thus need to be transformed
       // to the interval[0, infty), or [rmin, rmax]. We do this by the logarithmic transformation from Krack98
       // or the linear mapping of Flores06, respectively.  
       void GCQuadrature::transformZeroInf() {
           double ln2 = log(2.0);
           double xt;
       
           for (int i = 0; i < maxN; i++) {
               xt = 1.0 - log(1.0-x[i])/ln2;
               w[i] = w[i]/(ln2 * (1.0 - x[i]));
               x[i] = xt;
           }
       }
   
       void GCQuadrature::transformRMinMax(double z, double p) {
           double osz = 1.0 / sqrt(z);
       
           // Determine interval
           double rmin = p - 7.0 * osz;
           rmin = rmin > 0 ? rmin : 0.0;
           double rmax = p + 9.0 * osz;
       
           // Find the relative and absolute midpoints 
           double rmid = 0.5*(rmax - rmin); // Midpoint of interval relative to rmin
           double amid = rmid + rmin; // Midpoint of interval
       
           // Transform weights and abscissae by linearly transforming
           // both are scaled by rmid, and the abscissae are translated by amid
           for (int i = 0; i < maxN; i++) {
               x[i] = rmid * x[i] + amid;
               w[i] *= rmid;
           }
       }
       
       void GCQuadrature::untransformRMinMax(double z, double p) {
           double osz = 1.0 / sqrt(z);
       
           // Determine interval
           double rmin = p - 7.0 * osz;
           rmin = rmin > 0 ? rmin : 0.0;
           double rmax = p + 9.0 * osz;
       
           // Find the relative and absolute midpoints 
           double rmid = 0.5*(rmax - rmin); // Midpoint of interval relative to rmin
           double amid = rmid + rmin; // Midpoint of interval
       
           // Transform weights and abscissae by linearly transforming
           // both are scaled by rmid, and the abscissae are translated by amid
           for (int i = 0; i < maxN; i++) {
               x[i] = (x[i] - amid) / rmid;
               w[i] /= rmid;
           }
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1ac022ef72b9ce182dc98297e3046bcf35:

Function libecpint::qgen::Q3_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac9d4bb955ad433fe833a829b93a77792:

Function libecpint::qgen::Q4_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1c0f647f35ab7fd10a1a228f19df83a2:

Function libecpint::qgen::Q4_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a37f5258284037a0bf3bd897cf2aaf637:

Function libecpint::qgen::Q0_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5a713efe907c5b99f9149dd14b2c749b:

Function libecpint::qgen::Q3_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a38cc09dd01fd2186761a9b42df9e4bb3:

Function libecpint::qgen::Q0_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_class_classunrol__radial_1_1_qijk:

Class Qijk
==========

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Class Documentation
-------------------


.. doxygenclass:: unrol_radial::Qijk
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_src_generate.cpp:

File generate.cpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src>` (``/Users/robertshaw/devfiles/libecpint/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


ECP integral code generator. 



.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/generate.cpp``)
----------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_generate.cpp.rst





Includes
--------


- ``generate.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`)






Functions
---------


- :ref:`exhale_function_generate_8cpp_1a45aa3f4947203d38d9cb52b96d002cea`

- :ref:`exhale_function_generate_8cpp_1a0ddf1224851353fc92bfbff6f499fa97`

.. _exhale_function_namespacelibecpint_1_1qgen_1a766e3dfc45273f3b325b7b47d83c8fa3:

Function libecpint::qgen::Q5_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a3a4ed9b49d76dd6974d2dbc6bb181ab8:

Function libecpint::operator<<(std::ostream&, const SumTerm&)
=============================================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::operator<<(std::ostream&, const SumTerm&)
.. _exhale_struct_structlibecpint_1_1_gaussian_e_c_p:

Struct GaussianECP
==================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::GaussianECP
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp:

File libecpint.hpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include>` (``/Users/robertshaw/devfiles/libecpint/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint.hpp``)
---------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp.rst





Includes
--------


- ``libecpint/api.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`)





.. _exhale_variable_namespacelibecpint_1a451c1c2142ac7d2cbf57f3fcba419373:

Variable libecpint::ROOT_PI
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::ROOT_PI
.. _exhale_function_namespacelibecpint_1_1qgen_1a04b44167d55d965bd4f0b5fca498a4f9:

Function libecpint::qgen::Q2_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a04ddf7b46cb449284fe3577036c66685:

Function libecpint::qgen::Q0_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_README.md:

Program Listing for File README.md
==================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_README.md>` (``/Users/robertshaw/devfiles/libecpint_new/README.md``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: markdown

   ## Libecpint
   
   [![Build Status](https://dev.azure.com/robertshaw383/libecpint/_apis/build/status/robashaw.libecpint?branchName=readecp)](https://dev.azure.com/robertshaw383/libecpint/_build/latest?definitionId=2&branchName=readecp)
   [![codecov](https://codecov.io/gh/robashaw/libecpint/branch/readecp/graph/badge.svg)](https://codecov.io/gh/robashaw/libecpint)
   
   Libecpint is a C++ library for the efficient evaluation of integrals over ab initio effective core potentials, using a mixture of generated, recursive code and Gauss-Chebyshev quadrature. It is designed to be standalone and generic, but is currently in development and may not be completely stable. If you experience any problems please raise an issue here; contributions and suggestions are also welcome.
   
   ### Applications
   
   This assumes ECPs and basis sets of the form usually seen in electronic structure calculations, namely those expanded in terms of Gaussian functions. The angular momentum of function that can be treated is in theory arbitrary, but is limited by your choice of maximum when the library is built.
   
   
   ## Building and testing
   
   ### Dependencies
   
   - A modern C++ compiler, at least C++11 standard library is required. This has currently only been tested with GCC (6.3.0 and above, but will in theory work with any > 4.9) and clang (9.0.0 and above). Intel compilers have been known to cause issues.
   - CMake/CTest build tools
   - Python (2.7 or above, including 3 and higher)
   
   Additionally, if you wish to regenerate the radial code (see below),  Python3 is required with numpy and sympy.
   
   ### Build instructions
   
   To build the library, fork the repo locally and do the following in the top of the source tree (out-of-source build is required!):
   
   ```
   mkdir build
   cd build
   cmake [options] ..
   make [-jn]
   ```
   
   The `-jn` flag tells make to use `n` threads while compiling (e.g. `-j4` would use four threads), and is highly recommended if your computer can cope, as the generated code files can all be compiled independently of one another.
   
   The options after cmake above can be included using the syntax `-DOPTION=value`. The pertinent options are as follows:
   - `LIBECPINT_MAX_L` = the maximum angular momentum (in both orbital and ECP basis) required. The default is 5 (i.e. h-type functions), but this can easily be increased. Note that the higher this value, the longer the code generation will take (especially if optimization flags have not been added - see below), but it will not greatly affect compilation time.
   - `CMAKE_CXX_FLAGS` = any additional flags to be passed to the compiler. It is _strongly recommended_ that you provide optimization flags, e.g. at least `-O2` if not `-O3` for gcc/clang.
   - `LIBECPINT_MAX_UNROL` = the maximum angular momentum for which the whole integral is unrolled. The default is 2. It is _strongly recommended_ that you do not increase this past 4, as the compilation time and file sizes increase significantly. For reference, the following table gives compilation times and max. file sizes with `-O3` optimization flags and GCC 6.3.0:
   
   |  LIBECPINT_MAX_UNROL |  Compilation time (minutes)  | Max. file size (MB)  |
   |---|---|---|
   |  1  |  2  |  0.02  |
   |  2  |  10  | 1.0  |
   |  3  |  54  |  24.1  |
   |  4  |  191  |  556.2  |
   
   
   ### Testing and installation
   
   To test and install the build, do
   ```
   make test
   make install
   ```
   
   ## Documentation
   
   Code documentation can be generated using doxygen in the folder `doc/doxygen`. Examples of how to use the library can be found in the `tests` directory.
   
   The usage documentation is currently spare and under development - apologies, we hope to rectify this soon, along with providing a better API!
   
   ## Performance
   
   The angular momenta that have been fully unrolled will evaluate very rapidly, but the higher angular momenta will be noticeably slower. We are currently looking at ways to reduce this cost, but as these only make up a very small amount of the total number of integrals (which in turn are only a fraction of the total computation time in an actual calculation), it is very unlikely the ECP integrals will ever become a bottleneck.
   
   
   ## Acknowledging usage
   
   If you use this library in your program and find it helpful, that's great! Any feedback would be much appreciated. If you publish results using this library, please consider citing the following paper detailing the implementation:
   
   R. A. Shaw, J. G. Hill, J. Chem. Phys. 147, 074108 (2017); doi: [10.1063/1.4986887](http://dx.doi.org/10.1063/1.4986887)
   
   A full bibtex citation can be found in CITATION in the main directory.
   
   ## Work in progress
   
   ### Currently in the development version but not yet stable
   - First and second derivatives
   - GoogleTest unit testing suite, to work with continuous integration
   
   ### In the near future
   - An improved API
   - A built in ECP library
   
   ## Regenerating the radial code
   
   The recursive radial integral code has been pre-generated, as the current setting has been calibrated to balance accuracy and efficiency. If you would like to experiment (warning: after reading the paper cited above), go into the directory `src/generated/radial`. Edit the top line of  `unrol_radial.py` to change `MAX_UNROL_AM`, the maximum angular momentum to be unrolled. Then do the following:
   
   ```
   python3 unrol_radial.py
   ./generate.sh
   ```
   
   This will generate the simplified recursive integrals and then piece together the `radial_gen.cpp` file and place it in the correct location. It should be very safe (but not very efficient) to decrease `MAX_UNROL_AM`, but be prepared for things to break if you increase it too much. 

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp:

File gshell.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/gshell.hpp``)
----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp.rst





Includes
--------


- ``array``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_gaussian_shell`

- :ref:`exhale_class_structlibecpint_1_1_shell_pair_data`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp:

Program Listing for File radial_quad.cpp
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/radial_quad.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   #include <cmath>
   
   namespace libecpint {
   
       RadialIntegral::RadialIntegral() {}
   
       void RadialIntegral::init(int maxL, double tol, int small, int large) {
           bigGrid.initGrid(large, ONEPOINT);
           primGrid.initGrid(128, ONEPOINT); 
           smallGrid.initGrid(small, TWOPOINT);
           smallGrid.transformZeroInf();
       
           bessie.init(maxL, 1600, 200, tol);
       
           tolerance = tol;
       }
   
       void RadialIntegral::buildBessel(
           const std::vector<double> &r, const int nr, const int maxL, TwoIndex<double> &values, const double weight) const {
           std::vector<double> besselValues(maxL+1, 0.0);
           if (std::abs(weight) < 1e-15) {
               for (int i = 0; i < nr; i++) {
                   values(0, i) = 1.0;
                   for (int l = 1; l <= maxL; l++) values(l, i) = 0.0;
               }
           } else {
               for (int i = 0; i < nr; i++) {
                   bessie.calculate(weight * r[i], maxL, besselValues);
                   for (int l = 0; l <= maxL; l++) values(l, i) = besselValues[l];
               }
           }
       }
   
       double RadialIntegral::calcKij(
           const double Na, const double Nb, const double zeta_a, const double zeta_b, const double R2) const {
           double muij = zeta_a * zeta_b / (zeta_a + zeta_b);
           return Na * Nb * std::exp(-muij * R2);
       }
   
       // Assumes that p is the pretabulated integrand at the abscissae
       double RadialIntegral::integrand(const double r, const double *p, const int ix) {
           return p[ix];
       }
   
       RadialIntegral::Parameters RadialIntegral::buildParameters(
           const GaussianShell &shellA, const GaussianShell &shellB, const ShellPairData &data) const {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
   
           // Initialise result object
           Parameters result;
           auto & p = result.p;
           auto & P = result.P;
           auto & P2 = result.P2;
           auto & K = result.K;
   
           p.assign(npA, npB, 0.0);
           P.assign(npA, npB, 0.0);
           P2.assign(npA, npB, 0.0);
           K.assign(npA, npB, 0.0);
   
           double Pvec[3];
           double zetaA, zetaB;
           for (int a = 0; a < npA; a++) {
               zetaA = shellA.exp(a);
           
               for (int b = 0; b < npB; b++) {
                   zetaB = shellB.exp(b);
               
                   p(a, b) = zetaA + zetaB;
                   for (int n = 0; n < 3; n++) 
                       Pvec[n] = (zetaA * data.A[n] + zetaB * data.B[n])/p(a, b);
               
                   P2(a, b) = Pvec[0]*Pvec[0] + Pvec[1]*Pvec[1] + Pvec[2]*Pvec[2];
                   P(a, b) = std::sqrt(P2(a, b));
                   K(a, b) = calcKij(1.0, 1.0, zetaA, zetaB, data.RAB2);
               
               }
           }
           return result;
       }
   
       void RadialIntegral::buildU(
           const ECP &U, const int l, const int N, const GCQuadrature &grid, double *Utab) const {
           int gridSize = grid.getN();
       const std::vector<double> &gridPoints = grid.getX();
       
           // Tabulate weighted ECP values
           double r;
           for (int i = 0; i < gridSize; i++) {
               r = gridPoints[i];
               Utab[i] = FAST_POW[N+2](r) * U.evaluate(r, l);
           }
       }
   
       int RadialIntegral::integrate(
         const int maxL, const int gridSize, const TwoIndex<double> &intValues, GCQuadrature &grid,
         std::vector<double> &values, const int start, const int end, const int offset, const int skip) const {
           std::function<double(double, const double*, int)> intgd = integrand;
           values.assign(maxL+1, 0.0);
           int test;
           double params[gridSize];
           for (int i = 0; i < start; i++) params[i] = 0.0;
           for (int i = end+1; i < gridSize; i++) params[i] = 0.0;
           for (int l = offset; l <= maxL; l+=skip) {
               for (int i = start; i <= end; i++) params[i] = intValues(l, i);
               const auto integral_and_test =
                   grid.integrate(intgd, params, tolerance, start, end);
               values[l] = integral_and_test.first;
               test = integral_and_test.second;
               if (test == 0) break;
           }
           return test;
       }
   
       void RadialIntegral::type1(
         const int maxL, const int N, const int offset,
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         const ShellPairData &data, const Parameters & parameters, TwoIndex<double> &values) const {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
       
           int gridSize = bigGrid.getN();
   
           const auto & p = parameters.p;
           const auto & P = parameters.P;
           const auto & P2 = parameters.P2;
           const auto & K = parameters.K;
   
           // Now pretabulate integrand
           TwoIndex<double> intValues(maxL+1, gridSize, 0.0);
           // and bessel function
           TwoIndex<double> besselValues(maxL+1, gridSize, 0.0);
           // Calculate type1 integrals
           double da, db, za, zb, val;
           double A = data.Am;
           double B = data.Bm;
           std::vector<double> tempValues;
           values.assign(maxL+1, 2*maxL + 1, 0.0);
       
           // Tabulate integrand
           double x, phi, Px, Py;
           for (int a = 0; a < npA; a++) {
               da = shellA.coef(a);
               za = shellA.exp(a);
           
               for (int b = 0; b < npB; b++) {
                   db = shellB.coef(b);
                   zb = shellB.exp(b);
               
                   // Reset grid starting points
                   GCQuadrature newGrid = bigGrid;
                   newGrid.transformRMinMax(p(a, b), (za * A + zb * B)/p(a, b));
                   std::vector<double> &gridPoints = newGrid.getX();
                   auto start = 0;
                   auto end = gridSize - 1;
               
                   // Build U and bessel tabs
                   double Utab[gridSize];
                   buildU(U, U.getL(), N, newGrid, Utab);
                   buildBessel(gridPoints, gridSize, maxL, besselValues, 2.0*p(a,b)*P(a,b));
               
                   // Start building intvalues, and prescreen
                   bool foundStart = false, tooSmall = false;
                   for (int i = 0; i < gridSize; i++) {
                       for (int l = offset; l <= maxL; l+=2) {
                           intValues(l, i) = Utab[i] * besselValues(l, i); 
                           tooSmall = tooSmall || (intValues(l, i) < tolerance);
                       }
                       if (!tooSmall && !foundStart) {
                           foundStart = true; 
                           start = i;
                       }
                       if (tooSmall && foundStart) {
                           end = i-1;
                           break;
                       }
                   }
               
                   for (int i = start; i <= end; i++) {
                       val = -p(a, b) * (gridPoints[i]*(gridPoints[i] - 2*P(a, b)) + P2(a, b));
                       val = std::exp(val);
                       for (int l = offset; l <= maxL; l+=2)
                           intValues(l, i) *= val;
                   }
   
                   int test = integrate(maxL, gridSize, intValues, newGrid, tempValues, start, end, offset, 2);
                   if (test == 0)
                       std::cerr << "Failed to converge: " << U.atom_id << std::endl;
                   
                   // Calculate real spherical harmonic
                   x = std::abs(P(a, b)) < 1e-12 ? 0.0 : (za * data.A[2] + zb * data.B[2]) / (p(a, b) * P(a, b));
                   Py = (za * data.A[1] + zb * data.B[1]) / p(a, b);
                   Px = (za * data.A[0] + zb * data.B[0]) / p(a, b);
                   phi = std::atan2(Py, Px);
   
                   TwoIndex<double> harmonics = realSphericalHarmonics(maxL, x, phi);
                   for (int l = offset; l <= maxL; l+=2) {
                       for (int mu = -l; mu <= l; mu++)
                           values(l, l+mu) += da * db * harmonics(l, l+mu) * K(a, b) * tempValues[l];
                   }
               }
           }
           //std::cout << "\n\n";
       }
   
       // F_a(lam, r) = sum_{i in a} d_i K_{lam}(2 zeta_a A r)*std::exp(-zeta_a(r - A)^2)
       void RadialIntegral::buildF(
         const GaussianShell &shell, const double A, const int lstart, const int lend,
         const std::vector<double> &r, const int nr, const int start, const int end,
         TwoIndex<double> &F) const {
           int np = shell.nprimitive();
           
           double weight, zeta, c;
           TwoIndex<double> besselValues(lend+1, nr, 0.0);
       
           F.assign(lend + 1, nr, 0.0);
           for (int a = 0; a < np; a++) {
               zeta = shell.exp(a);
               c = shell.coef(a);
               weight = 2.0 * zeta * A;
           
               buildBessel(r, nr, lend, besselValues, weight);
           
               for (int i = start; i <= end; i++) {
                   weight = r[i] - A;
                   weight = c * std::exp(-zeta * weight * weight);
               
                   for (int l = lstart; l <= lend; l++) 
                       F(l, i) += weight * besselValues(l, i); 
               }
           }
       }
       
       double RadialIntegral::estimate_type2(
         const int N, const int l1, const int l2, const double n,
         const double a, const double b, const double A, const double B) const {
           double kA = 2.0*a*A;
           double kB = 2.0*b*B;
           double c0 = std::max(N - l1 - l2, 0);
           double c1_min = kA + kB;
           double p = a + b + n;
   
           double P = c1_min + std::sqrt(c1_min*c1_min + 8.0*p*c0);
           P /= (4.0*p);
   
           double zA = P - A; 
           double zB = P - B;
           double besselValue1 = bessie.upper_bound(kA * P, l1);
           double besselValue2 = bessie.upper_bound(kB * P, l2);
           double Fres = FAST_POW[N](P) * std::exp(-n * P * P - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
           return (0.5 * std::sqrt(M_PI/p) * Fres * (1.0 + Faddeeva::erf(std::sqrt(p)*P)));
       }
   
       void RadialIntegral::type2(
         const int l, const int l1start, int l1end, const int l2start, int l2end,
         const int N, const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         const ShellPairData &data, const Parameters & parameters, TwoIndex<double> &values) const {
       
           std::function<double(double, const double*, int)> intgd = integrand;
   
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
       
           double A = data.Am;
           double B = data.Bm;
   
           const auto & p = parameters.p;
           const auto & P = parameters.P;
           const auto & P2 = parameters.P2;
           const auto & K = parameters.K;
   
           // Start with the small grid
           // Pretabulate U
           int gridSize = smallGrid.getN();
           const std::vector<double> &gridPoints = smallGrid.getX();
       
           // Reset grid starting points
           const auto start = 0;
           const auto end = gridSize-1;
       
           double Utab[gridSize];
           buildU(U, l, N, smallGrid, Utab);
           values.assign(l1end+1, l2end+1, 0.0);
       
           // Build the F matrices
           if (A < 1e-15) l1end = 0; 
           if (B < 1e-15) l2end = 0; 
           TwoIndex<double> Fa;
           TwoIndex<double> Fb;
           buildF(shellA, data.Am, l1start, l1end, gridPoints, gridSize, start, end, Fa);
           buildF(shellB, data.Bm, l2start, l2end, gridPoints, gridSize, start, end, Fb);
       
           // Build the integrals
           bool foundStart, tooSmall;
           std::vector<int> tests((l1end +1) * (l2end+1));
           double params[gridSize]; 
           bool failed = false;
           int ix = 0;
           for (int l1 = 0; l1 <= l1end; l1++) {
               int l2start = (l1 + N) % 2;
               for (int l2 = l2start; l2 <= l2end; l2+=2) {
                   
                   for (int i = 0; i < gridSize; i++) params[i] = Utab[i] * Fa(l1, i) * Fb(l2, i);
                   const auto this_integral_and_test = smallGrid.integrate(intgd, params, tolerance, start, end);
                   tests[ix] = this_integral_and_test.second;
                   failed = failed || (tests[ix] == 0);
                   values(l1, l2) = tests[ix] == 0 ? 0.0 : this_integral_and_test.first;
                   ix++;
               }
           }
       
           if (failed) {
               // Not converged, switch to big grid
               double zeta_a, zeta_b, c_a, c_b;
                   
               gridSize = bigGrid.getN();
               Fa.assign(l1end+1, gridSize, 0.0);
               Fb.assign(l2end+1, gridSize, 0.0);
           
               for (int a = 0; a < npA; a++) {
                   c_a = shellA.coef(a);
                   zeta_a = shellA.exp(a);
               
                   for (int b = 0; b < npB; b++) {
                       c_b = shellB.coef(b);
                       zeta_b = shellB.exp(b);
                   
                       GCQuadrature newGrid = bigGrid;
                       newGrid.transformRMinMax(p(a, b), (zeta_a * A + zeta_b * B)/p(a, b));
                       std::vector<double> &gridPoints2 = newGrid.getX();
                       const auto start = 0;
                       const auto end = gridSize - 1;
               
                       // Build U and bessel tabs
                       double Utab2[gridSize];
                       buildU(U, l, N, newGrid, Utab2);
                       buildBessel(gridPoints2, gridSize, l1end, Fa, 2.0*zeta_a*A);
                       buildBessel(gridPoints2, gridSize, l2end, Fb, 2.0*zeta_b*B);
                   
                       double Xvals[gridSize];
                       double ria, rib;
                       for (int i = 0; i < gridSize; i++) {
                           ria = gridPoints2[i] - A;
                           rib = gridPoints2[i] - B;
                           Xvals[i] = std::exp(-zeta_a*ria*ria -zeta_b*rib*rib) * Utab2[i];
                       }
                   
                       double params2[gridSize]; 
                       ix = 0;
                       for (int l1 = 0; l1 <= l1end; l1++) {
                           int l2start = (l1 + N) % 2; 
                           
                           for (int l2 = l2start; l2 <= l2end; l2+=2) {
                           
                               if (tests[ix] == 0) {
                                   for (int i = 0; i < gridSize; i++)
                                       params2[i] = Xvals[i] * Fa(l1, i) * Fb(l2, i);
                                   const auto integral_and_test =
                                       newGrid.integrate(intgd, params2, tolerance, start, end);
                                   if (!integral_and_test.second) std::cerr << "Failed at second attempt" << std::endl;
                                   values(l1, l2) += c_a * c_b * integral_and_test.first;
                               }
                               ix++; 
                           
                           }
                       }
                   
                   }
               }
           
           }
       }
   
   }
.. _exhale_variable_generate_8cpp_1afb5b7ba33f80b513ca99f1de6f77c5b0:

Variable maxUnrol
=================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: maxUnrol
.. _exhale_function_namespacelibecpint_1_1qgen_1ab8fa7b1e013dfc11d1db5095fa31b1f4:

Function libecpint::qgen::Q1_1_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a151b9ededca4173cafa6df8d87d96fd5:

Function libecpint::qgen::Q0_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp:

File radial_gen.cpp
===================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/radial_gen.cpp``)
--------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp:

File ecp.hpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/ecp.hpp``)
-----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp.rst





Includes
--------


- ``array``

- ``config.hpp``

- ``map``

- ``string``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_e_c_p`

- :ref:`exhale_struct_classlibecpint_1_1_e_c_p_basis`

- :ref:`exhale_struct_structlibecpint_1_1_gaussian_e_c_p`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a076d4d1e17ab2a37661480ba095329d7`

.. _exhale_class_classlibecpint_1_1_e_c_p_integral:

Class ECPIntegral
=================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`


Class Documentation
-------------------


.. doxygenclass:: libecpint::ECPIntegral
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespaceunrol__radial_1afc2f4f223df08979b137c507be4bbd37:

Function unrol_radial::unrol
============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Function Documentation
----------------------


.. doxygenfunction:: unrol_radial::unrol(q)

.. _namespace_libecpint__aux:

Namespace libecpint::aux
========================


.. contents:: Contents
   :local:
   :backlinks: none





Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1seq`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1aux_1a8e2ec9ac4e466e11814c592a83efb66f`
.. _exhale_function_namespacelibecpint_1_1qgen_1ae04fe02eb63130146d27b9b21029f7a0:

Function libecpint::qgen::Q1_1_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_generate_8cpp_1a224a61a8e26d33e9d9089b86b86b3fba:

Variable CAX1
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: CAX1
.. _exhale_function_namespacelibecpint_1_1qgen_1a71c8b6f8381698df16df610a6ef84e72:

Function libecpint::qgen::Q0_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp:

File gaussquad.hpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/gaussquad.hpp``)
-----------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp.rst





Includes
--------


- ``functional``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_g_c_quadrature`


Enums
-----


- :ref:`exhale_enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f`


.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp:

File bessel.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/bessel.cpp``)
----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp.rst





Includes
--------


- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`)

- ``cassert``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a0415776547539e74b707bb57a725a26e:

Function libecpint::qgen::Q2_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a975e7b9e0f57709418adede308d80405:

Variable libecpint::FAC
=======================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::FAC

.. _file__Users_robertshaw_devfiles_libecpint_new_src_makelist.py:

File makelist.py
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src>` (``/Users/robertshaw/devfiles/libecpint_new/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/makelist.py``)
-------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_makelist.py.rst










Namespaces
----------


- :ref:`namespace_makelist`


Variables
---------


- :ref:`exhale_variable_namespacemakelist_1a7a96fbd7cb2ac37090089795370aedb7`

- :ref:`exhale_variable_namespacemakelist_1a92f763e70ec614d7cc630b6b3afc201e`

- :ref:`exhale_variable_namespacemakelist_1ae1a361014e097535367c775cc83758fd`

.. _exhale_function_namespacelibecpint_1_1qgen_1a460b4be26220556a7fab6c56fd0798ca:

Function libecpint::qgen::Q0_0_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a7e6a3a6f82a7b50654fd980987749345:

Function libecpint::qgen::Q2_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp:

File qgen.cpp
=============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/qgen.cpp``)
----------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp.rst





Includes
--------


- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``qgen.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__qgen`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af1816608e31f73731cb510619099400e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab020c384dfc8c0f23cf165448b10216e`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp:

Program Listing for File angular.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/angular.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ANGULAR_HEAD
   #define ANGULAR_HEAD
   
   #include <vector>
   #include "multiarr.hpp"
   
   namespace libecpint {
       
       class AngularIntegral 
       {
       private: 
           int LB; 
           int LE; 
   
           int wDim; 
           int maxL; 
       
           FiveIndex<double> W; 
           SevenIndex<double> omega; 
       
           double calcG(int l, int m) const;
           double calcH1(int i, int j, int l, int m) const;
           double calcH2(int i, int j, int k, int m) const;
       
           ThreeIndex<double> Pijk(int maxI) const; 
       
           void makeW( FiveIndex<double> &U);
           void makeOmega(FiveIndex<double> &U);
       
       public:
       
           ThreeIndex<double> uklm(int lam, int mu) const;
       
           FiveIndex<double> makeU();
       
           AngularIntegral(); 
           
           AngularIntegral(int LB, int LE); 
           
           void init(int LB, int LE);
           
           void compute();
       
           void clear();
       
           double getIntegral(int k, int l, int m, int lam, int mu) const; 
           
           double getIntegral(int k, int l, int m, int lam, int mu, int rho, int sigma) const;
           
           int* getOmegaMults() { return omega.mults; }
           int* getOmegaDims() { return omega.dims; }
           std::vector<double>& getOmegaData() { return omega.data; }
           
           
           bool isZero(int k, int l, int m, int lam, int mu, double tolerance) const;
           
           bool isZero(int k, int l, int m, int lam, int mu, int rho, int sigma, double tolerance) const;  
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1ab399ac3be9a089e30a15502bf58c38b9:

Function libecpint::qgen::Q2_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a055cd957f9eeece918efd6aeac46e55b:

Function libecpint::qgen::Q2_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a7ecd27cd3ddff36e2a2e0ebeffa3d303:

Function libecpint::pow_6
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_6(double)
.. _exhale_function_namespacelibecpint_1aea1a1b36dedb45829a2cdb5ee133b6ca:

Function libecpint::pow_11
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_11(double)
.. _exhale_typedef_namespacelibecpint_1a48b53f3b6bfb449ec300ab57fc03763c:

Typedef libecpint::Heptuple
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Typedef Documentation
---------------------


.. doxygentypedef:: libecpint::Heptuple
.. _exhale_function_namespacelibecpint_1_1qgen_1a3c7bf43770a6435564e402ede936b8a8:

Function libecpint::qgen::Q4_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a6e1056154af784737309be994c116ca0:

Function libecpint::qgen::Q5_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a007003a219fbc1cce6980a389b1013bc:

Variable libecpint::SMALL
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::SMALL

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp:

File api.hpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/api.hpp``)
-----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp.rst





Includes
--------


- ``array``

- ``ecpint.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`)

- ``memory``

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``string``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_e_c_p_integrator`


Defines
-------


- :ref:`exhale_define_api_8hpp_1a9c5be1c4ba084c752edba30f62c5da6d`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a2a771df5ca42d30ffdf70033fbc94770`

.. _exhale_variable_namespacelibecpint_1a02017a941eee202982bab7731ead620d:

Variable libecpint::CAX1
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::CAX1
.. _exhale_function_namespacelibecpint_1_1qgen_1ac1323c46145017941ea6c3937d114742:

Function libecpint::qgen::Q5_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_define_mathutil_8cpp_1a9450534f682d7a567d3872551afa2ec4:

Define FAC_INIT
===============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Define Documentation
--------------------


.. doxygendefine:: FAC_INIT
.. _exhale_function_namespaceunrol__radial_1aff823186ee3dc7e823e3f1a858233df6:

Function unrol_radial::parse
============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Function Documentation
----------------------


.. doxygenfunction:: unrol_radial::parse(term)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp:

Program Listing for File ecpint.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/ecpint.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "ecpint.hpp"
   #include <iostream>
   #include <cmath>
   #include <cassert>
   #include "Faddeeva.hpp"
   #include "mathutil.hpp"
   #include "qgen.hpp"
   #include <cassert>
   
   namespace libecpint {
   
       ECPIntegral::ECPIntegral(const int maxLB, const int maxLU, const int deriv) {
           // Make sure library can perform requested integrals
           assert(maxLB+deriv <= LIBECPINT_MAX_L); 
           assert(maxLU <= LIBECPINT_MAX_L);
           
           // Initialise singletons
           initFactorials();
           zero = nonzero = skipped = 0;
           
           // Initialise angular and radial integrators
           angInts.init(maxLB + deriv, maxLU);
           angInts.compute();
           radInts.init(2*(maxLB+deriv) + maxLU, 1e-15, 256, 512);
       };
   
       double ECPIntegral::calcC(const int a, const int m, const double A) const {
           double value = 1.0 - 2*((a-m) % 2);
           value *= std::pow(A, a-m);
           value *= FAC[a]/(FAC[m] * FAC[a-m]);
           return value;
       }
   
       void ECPIntegral::makeC(FiveIndex<double> &C, const int L, const double *A) const {
           int z; double Ck, Cl;
           int na = 0;
           for (int x = L; x >= 0; x--) {
               for (int y = L-x; y >= 0; y--) {
                   z = L - x - y;
               
                   for (int k = 0; k<= x; k++) {
                       Ck = calcC(x, k, A[0]);
                       for (int l = 0; l <= y; l++) {
                           Cl = calcC(y, l, A[1]);
                           for (int m = 0; m <= z; m++) C(0, na, k, l, m) = Ck * Cl * calcC(z, m, A[2]);
                       }
                   }
                   na++;
               }
           }
       }
   
       void ECPIntegral::type1(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         const ShellPairData &data, const FiveIndex<double> &CA, const FiveIndex<double> &CB,
         const RadialIntegral::Parameters & parameters, TwoIndex<double> &values) const {
   
           int LA = data.LA; int LB = data.LB;
           int maxLBasis = data.maxLBasis;
       
           // Build radial integrals
           int L = LA + LB;
           TwoIndex<double> temp;
           ThreeIndex<double> radials(L+1, L+1, 2*L+1);
           for (int ix = 0; ix <= L; ix++) {
               radInts.type1(ix, ix, ix % 2, U, shellA, shellB, data, parameters, temp);
               for(int l = 0; l <= ix; l++) {
                   for (int m = -l; m <= l; m++) radials(ix, l, l+m) = temp(l, l+m);
               }
           }
       
           // Unpack positions
           double Ax = data.A[0]; double Ay = data.A[1]; double Az = data.A[2];
           double Bx = data.B[0]; double By = data.B[1]; double Bz = data.B[2];
       
           // Calculate chi_ab for all ab in shells
           int z1, z2, lparity, mparity, msign, ix, k, l, m;
           double C;
           int na = 0, nb = 0;
           for (int x1 = LA; x1 >= 0; x1--) {
               for (int y1 = LA-x1; y1 >= 0; y1--) {
                   z1 = LA - x1 - y1;
                   nb = 0;
               
                   for (int x2 = LB; x2 >= 0; x2--) {
                       for (int y2 = LB-x2; y2 >= 0; y2--) {
                           z2 = LB - x2 - y2;
                       
                           for (int k1 = 0; k1 <= x1; k1++) {
                               for (int k2 = 0; k2 <= x2; k2++) {
                                   k = k1 + k2;
                               
                                   for (int l1 = 0; l1 <= y1; l1++) {
                                       for (int l2 = 0; l2 <= y2; l2++) {
                                           l = l1 + l2;
                                       
                                           for (int m1 = 0; m1 <= z1; m1++) {
                                               for (int m2 = 0; m2 <= z2; m2++){
                                                   m = m1 + m2;
                                                   C = CA(0, na, k1, l1, m1) * CB(0, nb, k2, l2, m2);
                                                   if ( fabs(C) > 1e-14 ) {
                                                       // Build radial integrals
                                                       ix = k + l + m;
                                                       
                                                       // Certain terms can be neglected as the angular integrals will always be zero
                                                       // See Flores06 appendix for details. 
                                                       lparity = ix % 2; 
                                                       msign = 1 - 2*(l%2);
                                                       mparity = (lparity + m) % 2;
                                                   
                                                       for (int lam = lparity; lam <= ix; lam+=2) {
                                                           for (int mu = mparity; mu <= lam; mu+=2)
                                                               values(na, nb) += C * angInts.getIntegral(k, l, m, lam, msign*mu) * radials(ix, lam, lam+msign*mu);
                                                       }
                                   
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }
                       
                           values(na, nb) *= 4.0 * M_PI;
                           nb++;
                       }
                   }
               
                   na++;
               }
           }
       
       }
   
       void ECPIntegral::type2(
         const int lam, const ECP& U, const GaussianShell &shellA, const GaussianShell &shellB,
         const ShellPairData &data, const FiveIndex<double> &CA, const FiveIndex<double> &CB,
         const RadialIntegral::Parameters & parameters, ThreeIndex<double> &values) const {
       
           // Unpack some data for convenience
           int LA = data.LA;
           int LB = data.LB;
           int L = LA + LB;    
           int maxLBasis = data.maxLBasis;
       
           double Am = data.Am; double Bm = data.Bm;
   
           if (data.A_on_ecp && data.B_on_ecp) {
               
               // Both on ECP, simplest case - see Shaw2017 supplementary material
               double prefactor = 4.0 * M_PI; 
               int npA = shellA.nprimitive();
               int npB = shellB.nprimitive();
               int npC = U.getN(); 
           
               double zA, zB, zC, dA, dB, dC, p; 
               int nC, z1, z2;
               
               int na = 0;
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
               
                       int nb = 0;
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                           
                               double value = 0.0;
                               for (int c = 0; c < npC; c++) {
                   const GaussianECP& g = U.getGaussian(c);
                                   if (g.l == lam) {
                                       zC = g.a;
                                       dC = g.d;
                                       nC = g.n; 
    
                                       for (int a = 0; a < npA; a++) {
                                           zA = shellA.exp(a);
                                           dA = shellA.coef(a);
                                       
                                           for (int b = 0; b < npB; b++) {
                                               zB = shellB.exp(b);
                                               dB = shellB.coef(b); 
                                           
                                               p = zA + zB + zC;
                                           
                                               double o_root_p = 1.0 / sqrt(p);
                                               int N = 2 + LA + LB + nC;
                                               value += 0.5*dA*dB*dC*GAMMA[N]*FAST_POW[N+1](o_root_p);
                                           }
                                       }
                                   }
                               }
                               
                               for (int mu = -lam; mu <= lam; mu++) {
                           
                                   double angular = prefactor * angInts.getIntegral(x1, r1, z1, lam, mu, 0, 0) * angInts.getIntegral(x2, y2, z2, lam, mu, 0, 0); 
                                   values(na, nb, lam+mu) = angular * value; 
                               }
                               nb++; 
                           }
                       }
                   
                       na++;
                   }
               }
               
           } else {
               
               // At least one of the shells is not on the ECP, so spherical harmonics will be required
               
               double xA = Am > 0 ? data.A[2] / Am : 0.0;
               double xB = Bm > 0 ? data.B[2] / Bm : 0.0;
               double phiA = atan2(data.A[1], data.A[0]);
               double phiB = atan2(data.B[1], data.B[0]);
               TwoIndex<double> SA = realSphericalHarmonics(lam+LA, xA, phiA);
               TwoIndex<double> SB = realSphericalHarmonics(lam+LB, xB, phiB);
           
               if (data.A_on_ecp) {
                   // Radial integrals need to be calculated by a different recursive scheme, or by quadrature
                   ThreeIndex<double> radials(L+1, lam + LA + 1, lam + LB + 1); 
                   TwoIndex<double> temp;
                   std::fill(values.data.begin(), values.data.end(), 0.0);
   
                   for (int N = 0; N < L+1; N++) {
                       radInts.type2(lam, 0, lam + LA, 0, lam + LB, N, U, shellA, shellB, data, parameters, temp);
                       for (int l1 = 0; l1 < lam + LA + 1; l1++)
                           for (int l2 = 0; l2 < lam + LB + 1; l2++)
                               radials(N, l1, l2) = temp(l1, l2);
                   }
                   
                   // a significant number of terms can be neglected a priori - see Shaw2017 supplementary material. 
                   qgen::rolled_up_special(lam, LA, LB, radials, CB, SB, angInts, values);
                   
               } else if (data.B_on_ecp){
                   // Same as above with A and B reversed
                   ThreeIndex<double> radials(L+1, lam + LB + 1, lam + LA + 1); 
                   ThreeIndex<double> tmpValues(values.dims[1], values.dims[0], values.dims[2]);
                   std::fill(tmpValues.data.begin(), tmpValues.data.end(), 0.0);
                   TwoIndex<double> temp;
   
                   for (int N = 0; N < L+1; N++) {
                       radInts.type2(lam, 0, lam + LA, 0, lam + LB, N, U, shellA, shellB, data, parameters, temp);
                       for (int l1 = 0; l1 < lam + LB + 1; l1++)
                           for (int l2 = 0; l2 < lam + LA + 1; l2++)
                               radials(N, l1, l2) = temp(l2, l1);
                   }
                   
                   // a significant number of terms can be neglected a priori - see Shaw2017 supplementary material. 
                   qgen::rolled_up_special(lam, LB, LA, radials, CA, SA, angInts, tmpValues);
                   // transcribe back into values
                   for (int na = 0; na < values.dims[0]; na++)
                       for (int nb = 0; nb < values.dims[1]; nb++)
                           for (int nc = 0; nc < values.dims[2]; nc++)
                               values(na, nb, nc) = tmpValues(nb, na, nc);
               } else {
                   
                   // Neither is on the ECP, the full recursive scheme with generated integrals can be used
                   // Need LA <= LB, but symmetry means we can just swap the arguments if LB > LA. 
                   if (LA <= LB) 
                       QGEN[LA][LB][lam](U, shellA, shellB, CA, CB, SA, SB, Am, Bm, radInts, angInts, parameters, values);
                   else {
                       ThreeIndex<double> temp_values(data.ncartB, data.ncartA, 2*U.getL() + 1); 
                       QGEN[LB][LA][lam](U, shellB, shellA, CB, CA, SB, SA, Bm, Am, radInts, angInts, parameters, temp_values);
                       for (int na = 0; na < data.ncartA; na++)
                           for (int nb = 0; nb < data.ncartB; nb++)
                               for (int nu = 0; nu < 2*U.getL() + 1; nu++)
                                   values(na, nb, nu) = temp_values(nb, na, nu); 
                   }
                       
               }           
           }
       }
   
       void ECPIntegral::estimate_type2(
         const ECP& U, const GaussianShell &shellA, const GaussianShell &shellB,
         const ShellPairData &data, double* results) const {
           double sigma_a, sigma_b, min_eta, n2, an, bn, a_bound, b_bound, ab_bound;
           double atilde, btilde, ztilde, Tk, Tk_0, xp;
           
           double Na_0 = 0.5 * data.LA / M_EULER;
           double Nb_0 = 0.5 * data.LB / M_EULER;
           
           for (int l = 0; l <= U.getL(); l++) {
               min_eta = U.min_exp_l[l];
               n2 = min_eta * min_eta;
               an = shellA.min_exp + min_eta;
               bn = shellB.min_exp + min_eta;
               if (data.A2 < 1e-6) sigma_a = 0.5 * an / shellA.min_exp;
               else sigma_a = 0.5 * data.LA * an * an / (shellA.min_exp * (n2*data.A2 + data.LA * an));
               if (data.B2 < 1e-6) sigma_b = 0.5 * bn / shellB.min_exp;
               else sigma_b = 0.5 * data.LB * bn * bn / (shellB.min_exp * (n2*data.B2 + data.LB * bn));
               
               atilde = (1.0 - sigma_a) * shellA.min_exp;
               btilde = (1.0 - sigma_b) * shellB.min_exp;
               
               a_bound = 0.0;
               for (int i = 0; i < shellA.exps.size(); i++)
                   a_bound += FAST_POW[data.LA](std::sqrt(Na_0 / (shellA.exps[i] * sigma_a))) * std::abs(shellA.coeffs[i]); 
               
               b_bound = 0.0;
               for (int i = 0; i < shellB.exps.size(); i++)
                   b_bound += FAST_POW[data.LB](std::sqrt(Nb_0 / (shellB.exps[i] * sigma_b))) * std::abs(shellB.coeffs[i]);
               
               double Tk_0 = 2.0 * atilde * btilde * data.Am * data.Bm; 
               ab_bound = 0.0;
               xp = atilde*atilde*data.A2 + btilde*btilde*data.B2;
               for (int k = U.l_starts[l]; k < U.l_starts[l+1]; k++) {
           const GaussianECP& g = U.getGaussian(k);
                   ztilde = atilde + btilde + g.a;
                   Tk = Tk_0 / ztilde;
                   Tk = Tk > 1 ? 0.5 * std::exp(Tk) / Tk : SINH_1;
                   ab_bound += std::abs(g.d) * FAST_POW[3](std::sqrt(M_PI/g.a)) * std::exp(xp / ztilde) * Tk;
               }
               ab_bound *= std::exp(-atilde*data.A2 -btilde*data.B2);
               results[l] = (2*l+1)*(2*l+1)* a_bound * b_bound * ab_bound;
           }
       }
   
       void ECPIntegral::compute_shell_pair(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         TwoIndex<double> &values, const int shiftA, const int shiftB) const {
       
           ShellPairData data;
           
           // Shift A and B to be relative to U
           const double* C = U.center();
           data.A[0] = shellA.center()[0] - C[0]; 
           data.A[1] = shellA.center()[1] - C[1];
           data.A[2] = shellA.center()[2] - C[2]; 
           data.B[0] = shellB.center()[0] - C[0]; 
           data.B[1] = shellB.center()[1] - C[1];
           data.B[2] = shellB.center()[2] - C[2]; 
       
           // Construct data that will be reused everywhere, and takes account of derivative shifts
           data.LA = shellA.am() + shiftA; 
           data.LB = shellB.am() + shiftB;
           data.maxLBasis = data.LA > data.LB ? data.LA : data.LB;
           data.ncartA = (data.LA+1)*(data.LA+2)/2;
           data.ncartB = (data.LB+1)*(data.LB+2)/2;
       
           data.A2 = data.A[0]*data.A[0] + data.A[1]*data.A[1] + data.A[2]*data.A[2];
           data.Am = sqrt(data.A2);
           data.A_on_ecp = (data.Am < 1e-6); 
           data.B2 = data.B[0]*data.B[0] + data.B[1]*data.B[1] + data.B[2]*data.B[2];
           data.Bm = sqrt(data.B2);
           data.B_on_ecp = (data.Bm < 1e-6);
           double RAB[3] = {data.A[0] - data.B[0], data.A[1] - data.B[1], data.A[2] - data.B[2]};
           data.RAB2 = RAB[0]*RAB[0] + RAB[1]*RAB[1] + RAB[2]*RAB[2];
           data.RABm = sqrt(data.RAB2);
           
           // Prepare the radial integrator
           const auto radIntParameters = radInts.buildParameters(shellA, shellB, data);
       
           // Construct coefficients 
           FiveIndex<double> CA(1, data.ncartA, data.LA+1, data.LA+1, data.LA+1);
           FiveIndex<double> CB(1, data.ncartB, data.LB+1, data.LB+1, data.LB+1);
           makeC(CA, data.LA, data.A);
           makeC(CB, data.LB, data.B);
           
           double screens[U.getL() + 1];
           estimate_type2(U, shellA, shellB, data, screens);
       
           // Calculate type1 integrals, if necessary
           values.assign(data.ncartA, data.ncartB, 0.0);
           if (!U.noType1() && screens[U.getL()] > tolerance)
               type1(U, shellA, shellB, data, CA, CB, radIntParameters, values);
           
           std::vector<int> l_list; 
           for (int l = 0; l < U.getL(); l++) 
               if (screens[l] > tolerance) l_list.push_back(l); 
           
           // Now all the type2 integrals
           ThreeIndex<double> t2vals(data.ncartA, data.ncartB, 2*U.getL() + 1);
           for (int l : l_list) {
               t2vals.fill(0.0);
               type2(l, U, shellA, shellB, data, CA, CB, radIntParameters, t2vals);
   
               for (int m = -l; m <= l; m++) {
                   for(int na = 0; na < data.ncartA; na++) {
                       for (int nb = 0; nb < data.ncartB; nb++) {
                           values(na, nb) += t2vals(na, nb, l+m);
                       }
                   }
               }
           }
       }
       
       void ECPIntegral::left_shell_derivative(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         std::array<TwoIndex<double>, 3> &results) const {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartA_minus = LA * (LA+1) / 2;
           TwoIndex<double> Q_minus, Q_plus; 
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           if (LA != 0)
               compute_shell_pair(U, shellA, shellB, Q_minus, -1, 0); 
           
           // hack in the exponents to the coefficients
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_plus, 1, 0); 
           
           // Now compile the derivatives
           if (LA != 0) {
               int nA = 0;
               int nA_minus, nA_plus;
               for (int k=LA; k >= 0; k--) {
                   for (int l=LA-k; l>=0; l--) {
                       int m = LA - k - l;
                           
                       for (int nB = 0; nB < ncartB; nB++) {
                           nA_plus = N_INDEX(l, m);
                           nA_minus = std::min(nA_plus, Q_minus.dims[0]-1);
                           results[0](nA, nB) = -k*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                           
                           nA_minus = l > 0 ? N_INDEX(l-1, m) : 0;
                           nA_plus  = N_INDEX(l+1, m);
                           results[1](nA, nB) = -l*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                           
                           nA_minus = m > 0 ? N_INDEX(l, m-1) : 0;
                           nA_plus  = N_INDEX(l, m+1);
                           results[2](nA, nB) = -m*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                       }
                       nA += 1;
                   }
               }
           } else {
               for (int nB = 0; nB < ncartB; nB++) {
                   results[0](0, nB) = 2.0*Q_plus(0, nB);
                   results[1](0, nB) = 2.0*Q_plus(1, nB);
                   results[2](0, nB) = 2.0*Q_plus(2, nB);
               }
           }
       }
       
       void ECPIntegral::left_shell_second_derivative(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         std::array<TwoIndex<double>, 6> &results) const {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartA_minus = std::max(1, (LA-1) * (LA) / 2);
           TwoIndex<double> Q_minus, Q_plus, Q_0;
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           if (LA > 1)
               compute_shell_pair(U, shellA, shellB, Q_minus, -2, 0); 
           else
               Q_minus.assign(ncartA_minus, ncartB, 0.0);
           
           // hack in the exponents to the coefficients
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_0, 0, 0); 
           
           // and for the l+2
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_plus, 2, 0); 
   
           // Now compile the derivatives
           int nA = 0;
           int nA_mm, nA_pp, nA_mp, nA_pm;
           for (int k=LA; k >= 0; k--) {
               for (int l=LA-k; l>=0; l--) {
                   int m = LA - k - l;
                       
                   for (int nB = 0; nB < ncartB; nB++) {
                       nA_mp = nA_pp = N_INDEX(l, m); //dxx
                       nA_mm = std::min(nA_mp, Q_minus.dims[0]-1);
                       results[0](nA, nB) = k*(k-1)*Q_minus(nA_mm, nB) - 2.0*(2*k+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
                       
                       nA_pm = l > 0 ? N_INDEX(l-1, m) : 0;
                       nA_mm = k > 0 ? nA_pm : 0; //dxy
                       nA_pp = N_INDEX(l+1, m); 
                       nA_mp  = k > 0 ? nA_pp : 0;
                       results[1](nA, nB) = k*l*Q_minus(nA_mm, nB) - 2.0*k*Q_0(nA_mp, nB)
                                           - 2.0*l*Q_0(nA_pm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_pm = m > 0 ? N_INDEX(l, m-1) : 0;
                       nA_mm = k > 0 ? nA_pm : 0; //dxz
                       nA_pp = N_INDEX(l, m+1);
                       nA_mp  = k > 0 ? nA_pp : 0;
                       results[2](nA, nB) = k*m*Q_minus(nA_mm, nB) - 2.0*k*Q_0(nA_mp, nB)
                                           - 2.0*m*Q_0(nA_pm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = l > 1 ? N_INDEX(l-2, m) : 0; //dyy
                       nA_mp = N_INDEX(l, m);
                       nA_pp  = N_INDEX(l+2,m);
                       results[3](nA, nB) = l*(l-1)*Q_minus(nA_mm, nB) - 2.0*(2*l+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = l*m > 0 ? N_INDEX(l-1, m-1) : 0; //dyz
                       nA_mp = l > 0 ? N_INDEX(l-1, m+1) : 0; 
                       nA_pm = m > 0 ? N_INDEX(l+1, m-1) : 0; 
                       nA_pp  = N_INDEX(l+1, m+1);
                       results[4](nA, nB) = l*m*Q_minus(nA_mm, nB) - 2.0*l*Q_0(nA_mp, nB)
                                           - 2.0*m*Q_0(nA_pm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_mm =  m > 1 ? N_INDEX(l, m-2) : 0; //dzz
                       nA_mp = N_INDEX(l, m);
                       nA_pp  = N_INDEX(l,m+2);
                       results[5](nA, nB) = m*(m-1)*Q_minus(nA_mm, nB) - 2.0*(2*m+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
   
                   }
                   nA += 1;
               }
           }
       }
       
       void ECPIntegral::mixed_second_derivative(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         std::array<TwoIndex<double>, 9> &results) const {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartB_minus = std::max(1, (LB) * (LB+1) / 2);
           int ncartA_minus = std::max(1, (LA) * (LA+1) / 2);
           int ncartB_plus = (LB+2) * (LB+3) / 2;
           int ncartA_plus = (LA+2) * (LA+3) / 2;
           TwoIndex<double> Q_mm, Q_mp, Q_pm, Q_pp;
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           GaussianShell tempB = shellB.copy();
           for (int i = 0; i < tempB.nprimitive(); i++) 
               tempB.coeffs[i] *= tempB.exps[i];
           
           if (LA > 0) {
               if (LB > 0) {
                   compute_shell_pair(U, shellA, shellB, Q_mm, -1, -1); 
                   compute_shell_pair(U, tempA, shellB, Q_pm, 1, -1);
               } else {
                   Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
                   Q_pm.assign(ncartA_plus, ncartB_minus, 0.0);
               }
               compute_shell_pair(U, shellA, tempB, Q_mp, -1, 1);
           } else if (LB > 0) {
               compute_shell_pair(U, tempA, shellB, Q_pm, 1, -1);
               Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
               Q_mp.assign(ncartA_minus, ncartB_plus, 0.0);
           } else {
               Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
               Q_mp.assign(ncartA_minus, ncartB_plus, 0.0);
               Q_pm.assign(ncartA_plus, ncartB_minus, 0.0);
           }
           compute_shell_pair(U, tempA, tempB, Q_pp, 1, 1); 
   
           // Now compile the derivatives
           int nA = 0;
           int nB = 0;
           int nA_m[3], nA_p[3], nB_m[3], nB_p[3], AL[3], BL[3];
           for (int ka=LA; ka >= 0; ka--) {
               for (int la=LA-ka; la>=0; la--) {
                   int ma = LA - ka - la;
                   AL[0]=ka; AL[1]=la; AL[2]=ma;
                   nA_p[0] = N_INDEX(la, ma);
                   nA_m[0] = std::min(nA_p[0], Q_mm.dims[0]-1);
                   nA_m[1] = la > 0 ? N_INDEX(la-1, ma) : 0; 
                   nA_m[2] = ma > 0 ? N_INDEX(la, ma-1) : 0;
                   nA_p[1] = N_INDEX(la+1,ma);
                   nA_p[2] = N_INDEX(la, ma+1);
                   
                   nB = 0;
                   for (int kb=LB; kb >= 0; kb--) {
                       for (int lb=LB-kb; lb>=0; lb--) {
                           int mb = LB - kb - lb;
                           nB_p[0] = N_INDEX(lb, mb);
                           nB_m[0] = std::min(nB_p[0], Q_mm.dims[1]-1);
                           nB_m[1] = lb > 0 ? N_INDEX(lb-1, mb) : 0; 
                           nB_m[2] = mb > 0 ? N_INDEX(lb, mb-1) : 0;
                           nB_p[1] = N_INDEX(lb+1,mb);
                           nB_p[2] = N_INDEX(lb, mb+1);
                           BL[0]=kb; BL[1]=lb; BL[2]=mb;
   
                           for (int p = 0; p < 3; p++) {
                               for (int q = 0; q < 3; q++) {
                                   results[3*p+q](nA, nB) = AL[p]*BL[q]*Q_mm(nA_m[p], nB_m[q]) - 2.0*BL[q]*Q_pm(nA_p[p], nB_m[q])
                                       - 2.0*AL[p]*Q_mp(nA_m[p], nB_p[q]) + 4.0*Q_pp(nA_p[p], nB_p[q]);
                               }
                           }
                           
                           nB += 1;
                       }
                   }
                   nA += 1;
               }
           }
       }
       
       void ECPIntegral::compute_shell_pair_derivative(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         std::array<TwoIndex<double>, 9> &results) const {
           // First we check centres
           double A[3], B[3], C[3];
           for (int i = 0; i < 3; i++) {
               A[i] = shellA.center()[i];
               B[i] = shellB.center()[i];
               C[i] = U.center()[i];
           }
           
           double dAC = std::abs(A[0] - C[0]) + std::abs(A[1] - C[1]) + std::abs(A[2] - C[2]);
           double dBC = std::abs(B[0] - C[0]) + std::abs(B[1] - C[1]) + std::abs(B[2] - C[2]);
           
           // Calculate shell derivatives
           std::array<TwoIndex<double>, 3> QA, QB;
           if (dAC > 1e-6) 
               left_shell_derivative(U, shellA, shellB, QA);
           if (dBC > 1e-6)
               left_shell_derivative(U, shellB, shellA, QB);
           
           // initialise results matrices
           int ncartA = (shellA.am()+1) * (shellA.am()+2) / 2;
           int ncartB = (shellB.am()+1) * (shellB.am()+2) / 2;
           
           // Now construct the nuclear derivs
           if (dAC > 1e-6) {
               results[0] = QA[0];
               results[1] = QA[1];
               results[2] = QA[2];
               if (dBC > 1e-6) {
                   results[3] = QB[0].transpose();
                   results[4] = QB[1].transpose();
                   results[5] = QB[2].transpose();
                   for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
                   for (int nA = 0; nA < ncartA; nA++) {
                       for (int nB = 0; nB < ncartB; nB++){
                           results[6](nA, nB) = -1.0 * (results[0](nA, nB) + results[3](nA, nB));
                           results[7](nA, nB) = -1.0 * (results[1](nA, nB) + results[4](nA, nB));
                           results[8](nA, nB) = -1.0 * (results[2](nA, nB) + results[5](nA, nB));
                       }
                   }
               } else {
                  results[3] = results[0]; results[3].multiply(-1.0);
                  results[4] = results[1]; results[4].multiply(-1.0);
                  results[5] = results[2]; results[5].multiply(-1.0);
                  for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
               }
           } else if (dBC > 1e-6) {
               results[3] = QB[0].transpose();
               results[4] = QB[1].transpose();
               results[5] = QB[2].transpose();
               results[0] = results[3]; results[0].multiply(-1.0);
               results[1] = results[4]; results[1].multiply(-1.0);
               results[2] = results[5]; results[2].multiply(-1.0);
               for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
           } else {
               // else everything is zero
               for (auto& r : results) r.assign(ncartA, ncartB, 0.0);
           }
       }
   
       void ECPIntegral::compute_shell_pair_second_derivative(
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         std::array<TwoIndex<double>, 45> &results) const {
           // First we check centres
           double A[3], B[3], C[3];
           for (int i = 0; i < 3; i++) {
               A[i] = shellA.center()[i];
               B[i] = shellB.center()[i];
               C[i] = U.center()[i];
           }
           
           double dAC = std::abs(A[0] - C[0]) + std::abs(A[1] - C[1]) + std::abs(A[2] - C[2]);
           double dBC = std::abs(B[0] - C[0]) + std::abs(B[1] - C[1]) + std::abs(B[2] - C[2]);
           
           // Calculate shell derivatives
           std::array<TwoIndex<double>, 6> QAA, QBB;
           std::array<TwoIndex<double>, 9> QAB;
   
           if (dAC > 1e-6) {
               left_shell_second_derivative(U, shellA, shellB, QAA);
               if (dBC > 1e-6) {
                   left_shell_second_derivative(U, shellB, shellA, QBB);
                   mixed_second_derivative(U, shellA, shellB, QAB);
               }
           } else if (dBC > 1e-6) {
               left_shell_second_derivative(U, shellB, shellA, QBB);
           }
           
           // initialise results matrices
           int ncartA = (shellA.am()+1) * (shellA.am()+2) / 2;
           int ncartB = (shellB.am()+1) * (shellB.am()+2) / 2;
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0);
           
           // Now construct the nuclear derivs
           int jaas[9] = {0, 1, 2, 1, 3, 4, 2, 4, 5};
           int jbbs[9] = {0, 3, 6, 1, 4, 7, 2, 5, 8};
           int jaa, jbb;
           if (dAC > 1e-6) {
               //AA (xx, xy, xz, yy, yz, zz)
               for (int i = 0; i < 6; i++) results[i] = QAA[i]; 
               
               if (dBC > 1e-6) {   
                   // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                   for (int i = 6; i < 15; i++) results[i] = QAB[i-6];
                    //BB (xx, xy, xz, yy, yz, zz) 
                   for (int i = 24; i < 30; i++) results[i] = QBB[i-24].transpose();
   
                   for (int nA = 0; nA < ncartA; nA++) {
                       for (int nB = 0; nB < ncartB; nB++){
                           for (int j = 0; j < 9; j++) {
                               jaa = jaas[j];
                               jbb = jbbs[j];
                               
                               // AC (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                               results[15+j](nA, nB) = -1.0*(QAA[jaa](nA, nB) + QAB[j](nA, nB));
                               
                               // BC (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                               results[30+j](nA, nB) = -1.0*(QBB[jaa](nB, nA) + QAB[jbb](nA, nB));
                               
                               // CC (xx, xy, xz, yy, yz, zz)
                               results[39+jaa](nA, nB) = -results[30+j](nA, nB) -results[15+j](nA, nB); 
                           }
                       }
                   }
               } else {
                   // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                   for (int i = 6; i < 15; i++) {
                       results[i] = QAA[jaas[i-6]];
                       results[i].multiply(-1.0);
                   }
                    //BB (xx, xy, xz, yy, yz, zz) 
                   for (int i = 24; i < 30; i++) results[i] = QAA[i-24];
               }
           } else if (dBC > 1e-6) {
               //BB (xx, xy, xz, yy, yz, zz)
               for (int i = 24; i < 30; i++) results[i] = QBB[i-24].transpose(); 
               // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
               for (int i = 6; i < 15; i++) {
                   results[i] = QBB[jaas[i-6]].transpose();
                   results[i].multiply(-1.0);
               }
                //AA (xx, xy, xz, yy, yz, zz) 
               for (int i = 0; i < 6; i++) results[i] = QBB[i].transpose();
           } 
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a36960c9e50c9fce6a6c57aa8792eba3d:

Function libecpint::qgen::Q0_0_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1f2fae93db97564c6223f7ab0b3a1345:

Function libecpint::qgen::Q0_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae4734bbfb388d811ede625b79a188e62:

Function libecpint::qgen::Q1_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp:

Program Listing for File libecpint.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef LIBECPINT_HEAD
   #define LIBECPINT_HEAD
   
   #include "libecpint/api.hpp"
   
   #endif LIBECPINT_HEAD
.. _exhale_function_namespacelibecpint_1_1qgen_1a9fad4906bd3daa6941148f903ac156df:

Function libecpint::qgen::Q1_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

Class Hierarchy
---------------


.. raw:: html

   <ul class="treeView" id="class-treeView">
     <li>
       <ul class="collapsibleList">
         <li>Namespace <a href="namespace_libecpint.html#namespace-libecpint">libecpint</a><ul><li>Namespace <a href="namespace_libecpint__aux.html#namespace-libecpint-aux">libecpint::aux</a><ul><li>Template Struct <a href="structlibecpint_1_1aux_1_1gen__seq.html#exhale-struct-structlibecpint-1-1aux-1-1gen-seq">gen_seq</a></li><li>Template Struct <a href="structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4.html#exhale-struct-structlibecpint-1-1aux-1-1gen-seq-3-010-00-01-is-8-8-8-01-4">gen_seq&lt; 0, Is... &gt;</a></li><li class="lastChild">Template Struct <a href="structlibecpint_1_1aux_1_1seq.html#exhale-struct-structlibecpint-1-1aux-1-1seq">seq</a></li></ul></li><li>Struct <a href="structlibecpint_1_1_e_c_p.html#exhale-struct-structlibecpint-1-1-e-c-p">ECP</a></li><li>Struct <a href="struct_classlibecpint_1_1_e_c_p_basis.html#exhale-struct-classlibecpint-1-1-e-c-p-basis">ECPBasis</a></li><li>Struct <a href="structlibecpint_1_1_e_c_p_integrator.html#exhale-struct-structlibecpint-1-1-e-c-p-integrator">ECPIntegrator</a></li><li>Template Struct <a href="structlibecpint_1_1_five_index.html#exhale-struct-structlibecpint-1-1-five-index">FiveIndex</a></li><li>Struct <a href="structlibecpint_1_1_gaussian_e_c_p.html#exhale-struct-structlibecpint-1-1-gaussian-e-c-p">GaussianECP</a></li><li>Struct <a href="structlibecpint_1_1_gaussian_shell.html#exhale-struct-structlibecpint-1-1-gaussian-shell">GaussianShell</a></li><li>Template Struct <a href="structlibecpint_1_1_seven_index.html#exhale-struct-structlibecpint-1-1-seven-index">SevenIndex</a></li><li>Struct <a href="structlibecpint_1_1_sum_term.html#exhale-struct-structlibecpint-1-1-sum-term">SumTerm</a></li><li>Template Struct <a href="structlibecpint_1_1_three_index.html#exhale-struct-structlibecpint-1-1-three-index">ThreeIndex</a></li><li>Template Struct <a href="structlibecpint_1_1_two_index.html#exhale-struct-structlibecpint-1-1-two-index">TwoIndex</a></li><li>Class <a href="classlibecpint_1_1_angular_integral.html#exhale-class-classlibecpint-1-1-angular-integral">AngularIntegral</a></li><li>Class <a href="classlibecpint_1_1_bessel_function.html#exhale-class-classlibecpint-1-1-bessel-function">BesselFunction</a></li><li>Class <a href="classlibecpint_1_1_e_c_p_integral.html#exhale-class-classlibecpint-1-1-e-c-p-integral">ECPIntegral</a></li><li>Class <a href="classlibecpint_1_1_g_c_quadrature.html#exhale-class-classlibecpint-1-1-g-c-quadrature">GCQuadrature</a></li><li>Class <a href="classlibecpint_1_1_radial_integral.html#exhale-class-classlibecpint-1-1-radial-integral">RadialIntegral</a><ul><li class="lastChild">Struct <a href="structlibecpint_1_1_radial_integral_1_1_parameters.html#exhale-struct-structlibecpint-1-1-radial-integral-1-1-parameters">RadialIntegral::Parameters</a></li></ul></li><li>Class <a href="class_structlibecpint_1_1_shell_pair_data.html#exhale-class-structlibecpint-1-1-shell-pair-data">ShellPairData</a></li><li class="lastChild">Enum <a href="enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f.html#exhale-enum-namespacelibecpint-1a61c66c38649b648ca25caaff9ebc6c3f">GCTYPE</a></li></ul></li><li class="lastChild">Namespace <a href="namespace_unrol_radial.html#namespace-unrol-radial">unrol_radial</a><ul><li class="lastChild">Class <a href="classunrol__radial_1_1_qijk.html#exhale-class-classunrol-radial-1-1-qijk">Qijk</a></li></ul></li>
       </ul>
     </li><!-- only tree view element -->
   </ul><!-- /treeView class-treeView -->

.. end raw html for treeView


.. _exhale_function_namespacelibecpint_1_1qgen_1ab75f9a0fe020cc5eac1855af0311a1e9:

Function libecpint::qgen::Q0_1_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _dir__Users_robertshaw_devfiles_libecpint_include:


Directory include
=================


*Directory path:* ``/Users/robertshaw/devfiles/libecpint/include``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_include_libecpint`


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp`



.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp:

File radial.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/radial.hpp``)
--------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp.rst





Includes
--------


- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`)

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp`)

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_radial_integral`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a0084068573b7163775f478479de24255`

.. _exhale_variable_namespacelibecpint_1a0084068573b7163775f478479de24255:

Variable libecpint::MIN_EXP
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::MIN_EXP
.. _exhale_function_namespacelibecpint_1_1qgen_1a119daa634903dbecf64d19eb5ba15d08:

Function libecpint::qgen::Q0_1_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1abdcc453ff2d05d577ea9cf4bce03402f:

Function libecpint::qgen::Q0_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ad83d47512070305306433992d08d692a:

Function libecpint::qgen::Q0_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a02e67630bc3cc6771a283b931a0d0652:

Function libecpint::qgen::Q0_0_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ad0ca8d8424656a9535a6feadae469fab:

Function libecpint::qgen::Q0_0_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp:

Program Listing for File testutil.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/testutil.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef TESTING_HEAD
   #define TESTING_HEAD
   
   #include <iostream>
   #include <iomanip>
   #include <fstream>
   #include <cmath>
   #include <string>
   #include <sstream>
   #include <vector>
   
   namespace libecpint {
   
   template <typename T>
   int check_file(std::string filename, std::vector<T>& results, double thresh=1e-5, double precision=1e-10) {
       std::ifstream input_file(filename); 
       if (input_file.is_open()) {
           
           std::vector<T> benchmark; 
           std::string line;
           while(!input_file.eof()) {
               std::getline(input_file, line); 
               T converted_value; 
               std::stringstream ss(line);
               ss >> converted_value;
               benchmark.push_back(converted_value); 
           }
           
           if (benchmark.size() != results.size()) {
               std::cerr << "Size of output is incorrect!" << std::endl;
               std::cerr << "File has " << benchmark.size() << " records" << std::endl;
               std::cerr << "Results has " << results.size()  << " records" << std::endl;
               return 1;
           } else {
               double error = 0.0;
               for (int i = 0; i < benchmark.size(); i++) {
                   double abserror = std::abs(benchmark[i] - results[i]);
                   if (abserror > precision) {
                       std::cout << std::setw(10) << "Line " << std::setw(5) << i 
                           << std::setw(5) << ":" << std::setw(15) <<  benchmark[i] 
                           << " / " << std::setw(15) << results[i] << std::endl;
                   }
                   if (std::abs(benchmark[i])>precision) error += abserror / std::abs(benchmark[i]);
               }
               error /= double(benchmark.size());
       
               if (error > thresh) {
                   std::cerr << "Average error in output is " << error << " percent!" << std::endl;
                   return 1;
               } else {
                   std::cout << "Test passed!" << std::endl; 
               }
           }
           
       } else {
           std::cerr << "Problem opening results file " << filename << std::endl; 
           return 1; 
       }
       
       return 0;
   }
   
   } // end namespace
   #endif

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py:

Program Listing for File unrol_radial.py
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py>` (``/Users/robertshaw/devfiles/libecpint/src/generated/radial/unrol_radial.py``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: py

   MAX_UNROL_AM = 4
   
   # DO NOT EDIT BELOW HERE
   
   from sympy import *
   
   class Qijk:
       def __init__(self, Ival = 0, Jval = 0, Kval = 0):
           self.i = Ival
           self.j = Jval
           self.k = Kval
           self.size = 2*self.i + self.j + 1
           self.start = self.k-self.i-self.j
           self.end = self.k+self.i
           self.subq = []
           self.terms = []
           self.bases = []
           self.f = []
           self.ga = []
           self.gb = []
           self.h = []
           for i in range(self.size):
               self.bases.append([])
       
       def print(self):
           print("Q", self.i, self.j, self.k)
           for i in range(len(self.bases)):
               print(i+self.start, ":")
               for j in range(len(self.bases[i])):
                   print(self.bases[i][j])
       
       def print_simple(self):
            print("Q", self.i, self.j, self.k)
            for i in range(len(self.bases)):
               print(i+self.start, ":", simplify(self.bases[i]))
               
       def print_fgh(self):
           print("Q", self.i, self.j, self.k)
           for i in range(len(self.f)):
               ix = 2*i+self.start
               if ix > 0:
                   print("F", ix, ":", simplify(self.f[i]))
           for i in range(len(self.gb)):
               ix = 2*i + self.start + 1
               if ix > 0:
                   print("GB", ix, ":", simplify(self.gb[i]))
           for i in range(len(self.ga)):
               ix = 2*i + self.start + 1
               if ix > 0:
                   print("GA", ix, ":", simplify(self.ga[i]))
           for i in range(len(self.h)):
               ix = 2*i+self.start + 2
               if ix > 0:
                   print("H", ix, ":", simplify(self.h[i]))
       
       def write_code(self, f):
           print("\t\t\t\t\t\t\t\t\tcase", self.i*10000+self.j*100+self.k, ": {", file=f)
   
           for i in range(len(self.f)):
               ix = 2*i+self.start
               if ix == 2:
                   simp = simplify(self.f[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult = (", simp, ") * values[0];", file=f)
               elif ix > 2:
                   simp = simplify(self.f[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * values[", ix-2, "];", file=f)
                   
           for i in range(len(self.gb)):
               ix = 2*i + self.start + 1
               if ix == 1:
                   simp = simplify(self.gb[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * G1B;", file=f)
               elif ix > 1:
                   simp = simplify(self.gb[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * values[", ix-2, "];", file=f)
   
           for i in range(len(self.ga)):
               ix = 2*i + self.start + 1
               if ix == 1:
                   simp = simplify(self.ga[i])
                   if simp != 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * G1A;", file=f)
   
           for i in range(len(self.h)):
               ix = 2*i+self.start + 2
               if ix == 2:
                   simp = simplify(self.h[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * H2;", file=f)
                       
           print("\t\t\t\t\t\t\t\t\t\tbreak;", file=f)
           print("\t\t\t\t\t\t\t\t\t}", file=f)
   
       def simplify(self):
           simple_bases = []
           for i in range(len(self.bases)):
               x = Symbol('x')
               y = Symbol('y')
               z = Symbol('z')
               z = 0
               for j in range(len(self.bases[i])):
                   z = z + parse(self.bases[i][j])
               simple_bases.append(z)
           self.bases = simple_bases
           
       def sort(self):
           for i in range(len(self.bases)):
               if i % 2 == 0:
                   self.f.append(self.bases[i])
               else:
                   self.gb.append(self.bases[i])
                   
       def eliminate(self):
           x = Symbol('x')
           y = Symbol('y')
           z = Symbol('z')
           p = Symbol('p')
           z = 0
           
           if self.start < 1:
               if self.end < 1:
                   self.bases.append(z)
               if self.end < 2:
                   self.bases.append(z)
                   
               w = Symbol('w')
               
               N = self.start
               ix = 0
               gaix = -1
               hix  = -1
               
               while (N < 1):
                   z = self.bases[ix]
                   w = self.bases[ix+2]
                   w = w + (2 * p / (N-1))*z
                   self.bases[ix+2] = w
               
                   w = self.bases[ix+1]
                   w = w - (2 * y / (N-1))*z
                   self.bases[ix+1] = w
                   
                   if ix % 2 == 0:
                       if gaix > -1:
                           w = self.ga[gaix]
                           w = w - (2*x / (N-1))*z
                           self.ga[gaix] = w
                       else:
                           w = -(2*x / (N-1))*z
                           self.ga.append(w)
                           gaix += 1
                           
                       if hix > -1:
                           z = self.h[hix]
                           w = (2 * p / (N-1))*z
                           self.h.append(w)
                           hix += 1
                           
                           w = self.ga[gaix]
                           w = w - (2 * y / (N-1))*z
                           self.ga[gaix] = w
                           
                           w = self.bases[ix+1]
                           w = w - (2 * x / (N-1))*z
                           self.bases[ix+1] = w
                   else:
                       if hix > -1:
                           w = self.h[hix]
                           w = w - (2*x / (N-1))*z
                           self.h[hix] = w
                       else:
                           w = - (2*x / (N-1))*z
                           self.h.append(w)
                           hix += 1
                       
                       if gaix > -1:
                           z = self.ga[gaix]
                           w = (2 * p /(N-1)) * z
                           self.ga.append(w)
                           gaix += 1
                           
                           w = self.h[hix]
                           w = w - (2 * y / (N-1))*z
                           self.h[hix] = w
                           
                           w = self.bases[ix+1]
                           w = w - (2*x / (N-1))*z
                           self.bases[ix+1] = w
                       
                   N += 1
                   ix += 1
   
   def parse(term):
       x = Symbol('x')
       y = Symbol('y')
       p = Symbol('p')
       bits = term.split(',')
       z = Symbol('z')
       z = 1
       for bit in bits:
           bi = bit[:2]
           if bi == "mu":
               ix = 2
               i = 0
               j = 0
               k = 0
   
               I = bit[ix]
               if I == "-":
                   ix += 1
                   i = -int(bit[ix])
               else:
                   i = int(I)
                   
               ix += 1
               J = bit[ix]
               if J == "-":
                   ix += 1
                   j = -int(bit[ix])
               else:
                   j = int(J)
   
               ix += 1
               K = bit[ix]
               if K == "-":
                   ix += 1
                   k = -int(bit[ix])
               else:
                   k = int(K)
   
               z = z * (2 + j - i - k)/(2*x)
           elif bi == "nu":
               z = z * (-y/x)
           elif bi == "xi":
               z = z * p/x
           elif bi == "rh":
               j = int(bit[3])
               z = z * (1 - 2*j)/(2*y)
           elif bi == "om":
               z = z * -1 / (2*y)
       return z
               
   def unrol(q):
       if (q.i == 0 and q.j == 0):
           return
       elif (q.i > 0):
           q1 = Qijk(Ival = q.i-1, Jval = q.j, Kval = q.k-1)
           q.subq.append(q1)
           q.terms.append("mu" + str(q.i) + str(q.j) + str(q.k))
   
           q2 = Qijk(Ival = q.i-1, Jval = q.j-1, Kval = q.k)
           q.subq.append(q2)
           q.terms.append("nu")
       
           q3 = Qijk(Ival = q.i-1, Jval = q.j, Kval = q.k+1)
           q.subq.append(q3)
           q.terms.append("xi")
       elif(q.j > 1):
           q1 = Qijk(Ival = 0, Jval = q.j-2, Kval = q.k)
           q.subq.append(q1)
           q.terms.append("sigma")
           
           q2 = Qijk(Ival = 0, Jval = q.j-1, Kval = q.k-1)
           q.subq.append(q2)
           q.terms.append("rho" + str(q.j))
       else:
           q1 = Qijk(Ival = 0, Jval = 0, Kval = q.k)
           q.subq.append(q1)
           q.terms.append("ups")
           
           q2 = Qijk(Ival = 0, Jval = 0, Kval = q.k-1)
           q.subq.append(q2)
           q.terms.append("om")
   
       for i in range(len(q.subq)):
           unrol(q.subq[i])
       
       return
   
   def collect(q, Q, term):
       if (q.i == 0 and q.j == 0):
           Q.bases[q.k-Q.start].append(term)
       else:
           for i in range(len(q.subq)):
               collect(q.subq[i], Q, term + q.terms[i] + ",")
   
   def algebraic_unrol(i, j, k):
       q = Qijk(Ival = i, Jval = j, Kval = k)
       unrol(q)
       collect(q, q, "")
       q.simplify()
       return q
   
   
   f = open('radial_gen.part2', 'w')
   print("", file=f)
   for j in range(MAX_UNROL_AM+1):
       for i in range(j+1):
           for k in range(1, 3*MAX_UNROL_AM+1-i-j):
               if (i + j + k) % 2 == 0: 
                   q = algebraic_unrol(i, j, k)
                   q.eliminate()
                   q.sort()
                   q.write_code(f)
                   print("", file=f)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp:

Program Listing for File angular.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/angular.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ANGULAR_HEAD
   #define ANGULAR_HEAD
   
   #include <vector>
   #include "multiarr.hpp"
   
   namespace libecpint {
       
       class AngularIntegral 
       {
       private: 
           int LB; 
           int LE; 
   
           int wDim; 
           int maxL; 
       
           FiveIndex<double> W; 
           SevenIndex<double> omega; 
       
           double calcG(int l, int m) const;
           double calcH1(int i, int j, int l, int m) const;
           double calcH2(int i, int j, int k, int m) const;
       
           ThreeIndex<double> Pijk(int maxI) const; 
       
           void makeW(const FiveIndex<double> &U);
           void makeOmega(const FiveIndex<double> &U);
       
       public:
       
           ThreeIndex<double> uklm(int lam, int mu) const;
       
           FiveIndex<double> makeU() const;
       
           AngularIntegral(); 
           
           AngularIntegral(int LB, int LE); 
           
           void init(int LB, int LE);
           
           void compute();
       
           void clear();
       
           double getIntegral(int k, int l, int m, int lam, int mu) const; 
           
           double getIntegral(int k, int l, int m, int lam, int mu, int rho, int sigma) const;
           
           int* getOmegaMults() { return omega.mults; }
       const int* getOmegaMults() const { return omega.mults; }
           int* getOmegaDims() { return omega.dims; }
       const int* getOmegaDims() const { return omega.dims; }
           std::vector<double>& getOmegaData() { return omega.data; }
       const std::vector<double>& getOmegaData() const { return omega.data; }
   
           
           bool isZero(int k, int l, int m, int lam, int mu, double tolerance) const;
           
           bool isZero(int k, int l, int m, int lam, int mu, int rho, int sigma, double tolerance) const;  
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1ae9a7959c4fbc71226a3cd2a7c4cd1aa8:

Function libecpint::qgen::Q1_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a30db4a3e0d94645ef1061ebe49fdf79d:

Function libecpint::qgen::Q1_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp:

File radial.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/radial.hpp``)
----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp.rst





Includes
--------


- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`)

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`)

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_radial_integral_1_1_parameters`

- :ref:`exhale_class_classlibecpint_1_1_radial_integral`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a92d5ae635e6e5d78682fd89ce537a7a3`

.. _exhale_function_namespacelibecpint_1_1qgen_1a0e4355fdf3c94a702625fb08123cfffb:

Function libecpint::qgen::Q1_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a4fc3cf89f4b0b1787baabc364a16e377:

Variable libecpint::GAMMA
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::GAMMA
.. _exhale_function_namespacelibecpint_1_1qgen_1a72f978eff7e1d723f1107a637a6b580b:

Function libecpint::qgen::Q2_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a89f11f190b2770ba1a6cd3bb0e252038:

Function libecpint::qgen::Q0_1_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_define_api_8hpp_1a9c5be1c4ba084c752edba30f62c5da6d:

Define H_START
==============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`


Define Documentation
--------------------


.. doxygendefine:: H_START
.. _exhale_function_namespacelibecpint_1a25b52c5d023603d9fb96ea30fc36a4ef:

Template Function libecpint::check_file
=======================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::check_file(std::string, std::vector<T>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1afbeec27b9ba065ae00e4491b856e151a:

Function libecpint::qgen::Q3_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1aad2f9701f24b74e7db5f8d1098b48cf5:

Function libecpint::pow_15
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_15(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a6db93ab24ebed670cd2a039350906744:

Function libecpint::qgen::Q2_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab6b41ee8966c9f271f301c75a167fc9a:

Function libecpint::qgen::Q0_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a463f70942e5de5172504d92ec6cc9616:

Function libecpint::qgen::Q2_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _dir__Users_robertshaw_devfiles_libecpint_include_libecpint:


Directory libecpint
===================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include>` (``/Users/robertshaw/devfiles/libecpint/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint/include/libecpint``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`


.. _exhale_function_namespacelibecpint_1_1qgen_1a668ee5dc9c5ceb4e2012bd86327c3f82:

Function libecpint::qgen::Q3_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_generate.hpp:

Program Listing for File generate.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_generate.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/generate.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GENERATE_HEAD
   #define GENERATE_HEAD
   
   #include <iostream>
   #include <fstream>
   #include <string>
   #include "angular.hpp"
   #include "mathutil.hpp"
   #include "multiarr.hpp"
   #include "config.hpp"
   #include <cmath>
   
   namespace libecpint {
       
       const int maxL = LIBECPINT_MAX_L;
       const int maxUnrol = LIBECPINT_MAX_UNROL; 
       const int maxN = 15; 
       const int CAX1 = maxN + 1;
       const int CAX2 = CAX1 * (maxL + 1);
       const int CAX3 = CAX2 * (maxL + 1);
   
       struct SumTerm {
   
           Pair SA; 
           Pair SB; 
           Triple radial; 
           Quintuple CA; 
           Quintuple CB; 
           double ang;   
           int mu; 
           int na; 
           int nb; 
       
           bool operator<(const SumTerm& s) const {
               bool result = (mu < s.mu);
               if (mu == s.mu) {
                   result = radial < s.radial; 
                   if (radial == s.radial)
                       result = ang < s.ang; 
               }
               return result; 
           }
          
           bool operator<=(const SumTerm& s) const {
               return (*this == s) || (*this < s); 
           }
       
           bool operator==(const SumTerm& s) const {
               return (mu == s.mu) && (radial == s.radial); 
           }
       
           int ca_index() const {
               return std::get<1>(CA) + std::get<2>(CA)*CAX1 
                   + std::get<3>(CA)*CAX2 + std::get<4>(CA)*CAX3; 
           }
       
           int cb_index() const {
               return std::get<1>(CB) + std::get<2>(CB)*CAX1 
                   + std::get<3>(CB)*CAX2 + std::get<4>(CB)*CAX3; 
           }
       
           std::string to_string(bool full = true) {
               std::stringstream ss;
           
               if (full) 
                   ss << "\tvalue" << mu << " += " << ang << " * CA[" << ca_index()
                       << "] * CB[" << cb_index() << "] * radials" << radial << " * SA"
                           << SA << " * SB" << SB << ";"; 
               else
                   ss << "\ttmp += " << "CA[" << ca_index() << "] * CB[" << cb_index() << "] * SA"
                       << SA << " * SB" << SB << ";"; 
            
               return ss.str(); 
           }
       
           Heptuple compare(const SumTerm& s) const {
               int f1 = mu == s.mu ? 1 : 0;
               int f2 = radial == s.radial ? 1 : 0;
               int f3 = SA == s.SA ? 1 : 0;
               int f4 = SB == s.SB ? 1 : 0; 
               int f5 = fabs(ang - s.ang) < 1e-10 ? 1 : 0;
               int f6 = CA == s.CA ? 1 : 0;
               int f7 = CB == s.CB ? 1 : 0; 
           
               return {f1, f2, f3, f4, f5, f6, f7};  
           }
       
           friend std::ostream& operator<<(std::ostream& os, const SumTerm& s); 
   
       };
   
       std::ostream& operator<<(std::ostream& os, const SumTerm& s) {
           os << "values(" << s.na << ", " << s.nb << ", " << s.mu << ") += "
               << s.ang << " * CA" << s.CA << " * CB" << s.CB
                   << " * radials" << s.radial << " * SA" << s.SA << " * SB" << s.SB << ";";
           return os;
       }
   
   } // end namespace
   
   #endif

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_README.md:

Program Listing for File README.md
==================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_README.md>` (``/Users/robertshaw/devfiles/libecpint/README.md``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: markdown

   ## Libecpint 1.0.2
   
   [![Build Status](https://dev.azure.com/robertshaw383/libecpint/_apis/build/status/robashaw.libecpint?branchName=master)](https://dev.azure.com/robertshaw383/libecpint/_build/latest?definitionId=2&branchName=master)
   [![codecov](https://codecov.io/gh/robashaw/libecpint/branch/master/graph/badge.svg)](https://codecov.io/gh/robashaw/libecpint)
   [![Documentation Status](https://readthedocs.org/projects/libecpint/badge/?version=latest)](https://libecpint.readthedocs.io/en/latest/index.html)
   [![Code Quality](https://www.code-inspector.com/project/15206/status/svg)]()
   
   Libecpint is a C++ library for the efficient evaluation of integrals over ab initio effective core potentials, using a mixture of generated, recursive code and Gauss-Chebyshev quadrature. It is designed to be standalone and generic, and is now in its first stable release. If you experience any problems please raise an issue here; contributions and suggestions are also welcome.
   
   ## New in first full release
   
   - Analytical 1st and 2nd derivatives;
   - Integration now >10x faster;
   - New, high level API, with ECP library;
   - Automated testing suite.
   
   ### Patch 1
   
   - Bug fix in screening of on-ECP type 2 integrals
   - Improvements in CMake build steps, thanks to nabbelbabbel/moritzBens
   
   ### Patch 2
   
   - Fix for memory leaks in derivative routines
   - Minor changes to CMake files
   
   ## Dependencies
   
   - A modern C++ compiler, at least C++11 standard library is required. This has been tested with:
     * gcc (v6.3.0 and above)
     * clang (v10.0.0 and above), you may need the CXX flag "-std=c++14"
     * icpc (v20.2.1), may also need the CXX flag "-std=c++14"
   - CMake/CTest build tools (v3.12 and higher)
   - Python (2.7 or above, including 3 and higher)
   
   Additionally, if you wish to regenerate the radial code (see below),  Python >=3.6 is required with numpy and sympy.
   
   ## Documentation
   
   Please refer to the main documentation [here](https://libecpint.readthedocs.io/en/latest/index.html).
   
   ## Acknowledging usage
   
   If you use this library in your program and find it helpful, that's great! Any feedback would be much appreciated. If you publish results using this library, please consider citing the following paper detailing the implementation:
   
   R. A. Shaw, J. G. Hill, J. Chem. Phys. 147, 074108 (2017); doi: [10.1063/1.4986887](http://dx.doi.org/10.1063/1.4986887)
   
   A full bibtex citation can be found in CITATION in the main directory.

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp:

File mathutil.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Mathematical constants, special function tables, and utility functions. 
 

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/mathutil.hpp``)
----------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp.rst





Includes
--------


- ``cmath``

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``numeric``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Defines
-------


- :ref:`exhale_define_mathutil_8hpp_1a620539bb392918432be69023bb266dfb`

- :ref:`exhale_define_mathutil_8hpp_1ae71449b1cc6e6250b91f539153a7a0d3`

- :ref:`exhale_define_mathutil_8hpp_1a30bbac291639d5f7d964a92fa8742b94`

- :ref:`exhale_define_mathutil_8hpp_1aaf00c7de57af68f4e9d7acc87adb8d87`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a683275f366eb38bfcc526bf5264d9376`

- :ref:`exhale_variable_namespacelibecpint_1a4fc3cf89f4b0b1787baabc364a16e377`

- :ref:`exhale_variable_namespacelibecpint_1a35fea7df6515abbb84fc029150055a28`

- :ref:`exhale_variable_namespacelibecpint_1a451c1c2142ac7d2cbf57f3fcba419373`

- :ref:`exhale_variable_namespacelibecpint_1a6305f5251f77037717df018fd2e56700`

.. _dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint:


Directory libecpint
===================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include>` (``/Users/robertshaw/devfiles/libecpint_new/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`


.. _exhale_variable_namespacelibecpint_1a6a8879ed7b1d299f2b2e92b105cce919:

Variable libecpint::maxN
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::maxN
.. _exhale_function_namespacelibecpint_1_1qgen_1a2cacc14c8239c3f202631e089a75bf8f:

Function libecpint::qgen::Q0_1_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a93772fb9447d2664d73d8a3902fe1b54:

Function libecpint::qgen::Q0_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a7b6040a6e46c20d2e23b692e0fbffdf7:

Function libecpint::pow_2
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_2(double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp:

Program Listing for File mathutil.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/mathutil.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef MATHUTILHEADERDEF
   #define MATHUTILHEADERDEF
   
   #include <vector>
   #include <numeric>
   #include <cmath>
   #include "multiarr.hpp"
   
   #ifndef M_PI
   #define M_PI 3.14159265358979323846
   #endif
   
   #ifndef M_EULER
   #define M_EULER 2.71828182845904523536
   #endif
   
   #define MAX_FAC 100 
   #define MAX_DFAC 200 
   
   namespace libecpint {
       
       constexpr double ROOT_PI = 1.772453850905516; 
       constexpr double SINH_1 = 1.1752011936;
       constexpr int MAX_POW = 20;
   
       extern double FAC[MAX_FAC];     
       extern double DFAC[MAX_DFAC];   
       
       double pow_m2(double);
       double pow_m1(double);
       double pow_0(double);
       double pow_1(double);
       double pow_2(double);
       double pow_3(double);
       double pow_4(double);
       double pow_5(double);
       double pow_6(double);
       double pow_7(double);
       double pow_8(double);
       double pow_9(double);
       double pow_10(double);
       double pow_11(double);
       double pow_12(double);
       double pow_13(double);
       double pow_14(double);
       double pow_15(double);
       double pow_16(double);
       double pow_17(double);
       double pow_18(double);
       double pow_19(double);
       double pow_20(double);
       
       static double (*FAST_POW[23])(double) {pow_0, pow_1, pow_2, pow_3, pow_4, pow_5,
                                         pow_6, pow_7, pow_8, pow_9, pow_10, pow_11,
                                         pow_12, pow_13, pow_14, pow_15, pow_16, pow_17,
                                         pow_18, pow_19, pow_20, pow_m1, pow_m2};
       
       
       const double GAMMA[30] = {
           1.7724538509055,
           1.0,
           0.88622692545275,
           1.0,
           1.3293403881791,
           2.0,
           3.3233509704478,
           6.0,
           11.631728396567,
           24.0,
           52.342777784553,
           120.0,
           287.88527781504,
           720.0,
           1871.2543057978,
           5040.0,
           14034.407293483,
           40320.0,
           1.1929246199461e5,
           3.62880e5,
           1.1332783889488e6,
           3.628800e6,
           1.1899423083962e7,
           3.9916800e7,
           1.3684336546556e8, 
           4.79001600e8, 
           1.7105420683196e9, 
           6.227020800e9, 
           2.3092317922314e10,
           8.7178291200e10
       };
       
       TwoIndex<double> realSphericalHarmonics(int lmax, double x, double phi);  
       
       double frobenius_norm(const TwoIndex<double>& mat);
       
       void initFactorials(); 
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1abf0f13ffec33887ba20dfde547d1acaa:

Function libecpint::qgen::Q3_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp:

File radial_gen.cpp
===================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_generated_radial>` (``/Users/robertshaw/devfiles/libecpint/src/generated/radial``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/generated/radial/radial_gen.cpp``)
-----------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp:

Program Listing for File radial_quad.cpp
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/radial_quad.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   #include <cmath>
   
   namespace libecpint {
   
       RadialIntegral::RadialIntegral() {}
   
       void RadialIntegral::init(int maxL, double tol, int small, int large) {
           bigGrid.initGrid(large, ONEPOINT);
           primGrid.initGrid(128, ONEPOINT); 
           smallGrid.initGrid(small, TWOPOINT);
           smallGrid.transformZeroInf();
       
           bessie.init(maxL, 1600, 200, tol);
       
           tolerance = tol;
       }
   
       void RadialIntegral::buildBessel(std::vector<double> &r, int nr, int maxL, TwoIndex<double> &values, double weight) {
           std::vector<double> besselValues(maxL+1, 0.0);
           if (std::abs(weight) < 1e-15) {
               for (int i = 0; i < nr; i++) {
                   values(0, i) = 1.0;
                   for (int l = 1; l <= maxL; l++) values(l, i) = 0.0;
               }
           } else {
               for (int i = 0; i < nr; i++) {
                   bessie.calculate(weight * r[i], maxL, besselValues);
                   for (int l = 0; l <= maxL; l++) values(l, i) = besselValues[l];
               }
           }
       }
   
       double RadialIntegral::calcKij(double Na, double Nb, double zeta_a, double zeta_b, double R2) const {
           double muij = zeta_a * zeta_b / (zeta_a + zeta_b);
           return Na * Nb * std::exp(-muij * R2);
       }
   
       // Assumes that p is the pretabulated integrand at the abscissae
       double RadialIntegral::integrand(double r, double *p, int ix) {
           return p[ix];
       }
   
       void RadialIntegral::buildParameters(GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data) {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
   
           p.assign(npA, npB, 0.0);
           P.assign(npA, npB, 0.0);
           P2.assign(npA, npB, 0.0);
           K.assign(npA, npB, 0.0);
   
           double Pvec[3];
           double zetaA, zetaB;
           for (int a = 0; a < npA; a++) {
               zetaA = shellA.exp(a);
           
               for (int b = 0; b < npB; b++) {
                   zetaB = shellB.exp(b);
               
                   p(a, b) = zetaA + zetaB;
                   for (int n = 0; n < 3; n++) 
                       Pvec[n] = (zetaA * data.A[n] + zetaB * data.B[n])/p(a, b);
               
                   P2(a, b) = Pvec[0]*Pvec[0] + Pvec[1]*Pvec[1] + Pvec[2]*Pvec[2];
                   P(a, b) = std::sqrt(P2(a, b));
                   K(a, b) = calcKij(1.0, 1.0, zetaA, zetaB, data.RAB2);
               
               }
           }
       }
   
       void RadialIntegral::buildU(ECP &U, int l, int N, GCQuadrature &grid, double *Utab) {
           int gridSize = grid.getN();
           std::vector<double> &gridPoints = grid.getX();
       
           // Tabulate weighted ECP values
           double r;
           for (int i = 0; i < gridSize; i++) {
               r = gridPoints[i];
               Utab[i] = FAST_POW[N+2](r) * U.evaluate(r, l);
           }
       }
   
       int RadialIntegral::integrate(int maxL, int gridSize, TwoIndex<double> &intValues, GCQuadrature &grid, std::vector<double> &values, int offset, int skip) {
           std::function<double(double, double*, int)> intgd = integrand; 
           values.assign(maxL+1, 0.0);
           int test;
           double params[gridSize];
           for (int i = 0; i < grid.start; i++) params[i] = 0.0;
           for (int i = grid.end+1; i < gridSize; i++) params[i] = 0.0;
           for (int l = offset; l <= maxL; l+=skip) {
               for (int i = grid.start; i <= grid.end; i++) params[i] = intValues(l, i); 
               test = grid.integrate(intgd, params, tolerance);
               values[l] = grid.getI();
               if (test == 0) break;
           }
           return test;
       }
   
       void RadialIntegral::type1(int maxL, int N, int offset, ECP &U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, TwoIndex<double> &values) {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
       
           int gridSize = bigGrid.getN();
   
           // Now pretabulate integrand
           TwoIndex<double> intValues(maxL+1, gridSize, 0.0);
           // and bessel function
           TwoIndex<double> besselValues(maxL+1, gridSize, 0.0);
           // Calculate type1 integrals
           double da, db, za, zb, val;
           double A = data.Am;
           double B = data.Bm;
           std::vector<double> tempValues;
           values.assign(maxL+1, 2*maxL + 1, 0.0);
       
           // Tabulate integrand
           double x, phi, Px, Py;
           double weightedTolerance = tolerance / gridSize;
           for (int a = 0; a < npA; a++) {
               da = shellA.coef(a);
               za = shellA.exp(a);
           
               for (int b = 0; b < npB; b++) {
                   db = shellB.coef(b);
                   zb = shellB.exp(b);
               
                   // Reset grid starting points
                   GCQuadrature newGrid = bigGrid;
                   newGrid.transformRMinMax(p(a, b), (za * A + zb * B)/p(a, b));
                   std::vector<double> &gridPoints = newGrid.getX();
                   newGrid.start = 0;
                   newGrid.end = gridSize - 1;
               
                   // Build U and bessel tabs
                   double Utab[gridSize];
                   buildU(U, U.getL(), N, newGrid, Utab);
                   buildBessel(gridPoints, gridSize, maxL, besselValues, 2.0*p(a,b)*P(a,b));
               
                   // Start building intvalues, and prescreen
                   bool foundStart = false, tooSmall = false;
                   for (int i = 0; i < gridSize; i++) {
                       for (int l = offset; l <= maxL; l+=2) {
                           intValues(l, i) = Utab[i] * besselValues(l, i); 
                           tooSmall = intValues(l, i) < tolerance;
                       }
                       if (!tooSmall && !foundStart) {
                           foundStart = true; 
                           newGrid.start = i;
                       }
                       if (tooSmall && foundStart) {
                           newGrid.end = i-1;
                           break;
                       }
                   }
               
                   for (int i = newGrid.start; i <= newGrid.end; i++) {
                       val = -p(a, b) * (gridPoints[i]*(gridPoints[i] - 2*P(a, b)) + P2(a, b));
                       val = std::exp(val);
                       for (int l = offset; l <= maxL; l+=2)
                           intValues(l, i) *= val;
                   }
   
                   int test = integrate(maxL, gridSize, intValues, newGrid, tempValues, offset, 2);
                   if (test == 0) std::cerr << "Failed to converge: \n";
                   
                   // Calculate real spherical harmonic
                   x = std::abs(P(a, b)) < 1e-12 ? 0.0 : (za * data.A[2] + zb * data.B[2]) / (p(a, b) * P(a, b));
                   Py = (za * data.A[1] + zb * data.B[1]) / p(a, b);
                   Px = (za * data.A[0] + zb * data.B[0]) / p(a, b);
                   phi = std::atan2(Py, Px);
   
                   TwoIndex<double> harmonics = realSphericalHarmonics(maxL, x, phi);
                   for (int l = offset; l <= maxL; l+=2) {
                       for (int mu = -l; mu <= l; mu++)
                           values(l, l+mu) += da * db * harmonics(l, l+mu) * K(a, b) * tempValues[l];
                   }
               }
           }
           //std::cout << "\n\n";
       }
   
       // F_a(lam, r) = sum_{i in a} d_i K_{lam}(2 zeta_a A r)*std::exp(-zeta_a(r - A)^2)
       void RadialIntegral::buildF(GaussianShell &shell, double A, int lstart, int lend, std::vector<double> &r, int nr, int start, int end, TwoIndex<double> &F) {
           int np = shell.nprimitive();
           
           double weight, zeta, c;
           TwoIndex<double> besselValues(lend+1, nr, 0.0);
       
           F.assign(lend + 1, nr, 0.0);
           for (int a = 0; a < np; a++) {
               zeta = shell.exp(a);
               c = shell.coef(a);
               weight = 2.0 * zeta * A;
           
               buildBessel(r, nr, lend, besselValues, weight);
           
               for (int i = start; i <= end; i++) {
                   weight = r[i] - A;
                   weight = c * std::exp(-zeta * weight * weight);
               
                   for (int l = lstart; l <= lend; l++) 
                       F(l, i) += weight * besselValues(l, i); 
               }
           }
       }
       
       double RadialIntegral::estimate_type2(int N, int l1, int l2, double n, double a, double b, double A, double B) {
           double kA = 2.0*a*A;
           double kB = 2.0*b*B;
           double c0 = std::max(N - l1 - l2, 0);
           double c1_min = kA + kB;
           double p = a + b + n;
   
           double P = c1_min + std::sqrt(c1_min*c1_min + 8.0*p*c0);
           P /= (4.0*p);
   
           double zA = P - A; 
           double zB = P - B;
           double besselValue1 = bessie.upper_bound(kA * P, l1);
           double besselValue2 = bessie.upper_bound(kB * P, l2);
           double Fres = FAST_POW[N](P) * std::exp(-n * P * P - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
           return (0.5 * std::sqrt(M_PI/p) * Fres * (1.0 + Faddeeva::erf(std::sqrt(p)*P)));
       }
   
       void RadialIntegral::type2(int l, int l1start, int l1end, int l2start, int l2end, int N, ECP &U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, TwoIndex<double> &values) {
       
           std::function<double(double, double*, int)> intgd = integrand; 
   
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
       
           double A = data.Am;
           double B = data.Bm;
   
           // Start with the small grid
           // Pretabulate U
           int gridSize = smallGrid.getN();
           std::vector<double> &gridPoints = smallGrid.getX();
       
           // Reset grid starting points
           smallGrid.start = 0;
           smallGrid.end = gridSize-1;
       
           double Utab[gridSize];
           buildU(U, l, N, smallGrid, Utab);
           values.assign(l1end+1, l2end+1, 0.0);
       
           // Build the F matrices
           if (A < 1e-15) l1end = 0; 
           if (B < 1e-15) l2end = 0; 
           TwoIndex<double> Fa;
           TwoIndex<double> Fb;
           buildF(shellA, data.Am, l1start, l1end, gridPoints, gridSize, smallGrid.start, smallGrid.end, Fa);
           buildF(shellB, data.Bm, l2start, l2end, gridPoints, gridSize, smallGrid.start, smallGrid.end, Fb);
       
           // Build the integrals
           bool foundStart, tooSmall;
           std::vector<int> tests((l1end +1) * (l2end+1));
           double params[gridSize]; 
           bool failed = false;
           int ix = 0;
           for (int l1 = 0; l1 <= l1end; l1++) {
               int l2start = (l1 + N) % 2;
               for (int l2 = l2start; l2 <= l2end; l2+=2) {
                   
                   for (int i = 0; i < gridSize; i++) params[i] = Utab[i] * Fa(l1, i) * Fb(l2, i);
                   tests[ix] = smallGrid.integrate(intgd, params, tolerance);
                   failed = failed || (tests[ix] == 0); 
                   values(l1, l2) = tests[ix] == 0 ? 0.0 : smallGrid.getI();
                   ix++; 
               
               }
           }
       
           if (failed) {
               // Not converged, switch to big grid
               double zeta_a, zeta_b, c_a, c_b;
                   
               gridSize = bigGrid.getN();
               Fa.assign(l1end+1, gridSize, 0.0);
               Fb.assign(l2end+1, gridSize, 0.0);
           
               for (int a = 0; a < npA; a++) {
                   c_a = shellA.coef(a);
                   zeta_a = shellA.exp(a);
               
                   for (int b = 0; b < npB; b++) {
                       c_b = shellB.coef(b);
                       zeta_b = shellB.exp(b);
                   
                       GCQuadrature newGrid = bigGrid;
                       newGrid.transformRMinMax(p(a, b), (zeta_a * A + zeta_b * B)/p(a, b));
                       std::vector<double> &gridPoints2 = newGrid.getX();
                       newGrid.start = 0;
                       newGrid.end = gridSize - 1;
               
                       // Build U and bessel tabs
                       double Utab2[gridSize];
                       buildU(U, l, N, newGrid, Utab2);
                       buildBessel(gridPoints2, gridSize, l1end, Fa, 2.0*zeta_a*A);
                       buildBessel(gridPoints2, gridSize, l2end, Fb, 2.0*zeta_b*B);
                   
                       double Xvals[gridSize];
                       double ria, rib;
                       for (int i = 0; i < gridSize; i++) {
                           ria = gridPoints2[i] - A;
                           rib = gridPoints2[i] - B;
                           Xvals[i] = std::exp(-zeta_a*ria*ria -zeta_b*rib*rib) * Utab2[i];
                       }
                   
                       double params2[gridSize]; 
                       int test;
                       ix = 0;
                       for (int l1 = 0; l1 <= l1end; l1++) {
                           int l2start = (l1 + N) % 2; 
                           
                           for (int l2 = l2start; l2 <= l2end; l2+=2) {
                           
                               if (tests[ix] == 0) {
                                   for (int i = 0; i < gridSize; i++)
                                       params2[i] = Xvals[i] * Fa(l1, i) * Fb(l2, i);
                                   test = newGrid.integrate(intgd, params2, tolerance); 
                                   if (test == 0) std::cerr << "Failed at second attempt" << std::endl;
                                   values(l1, l2) += c_a * c_b * newGrid.getI(); 
                               }
                               ix++; 
                           
                           }
                       }
                   
                   }
               }
           
           }
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a57c8f6c91db56996a928592cd15643d7:

Function libecpint::qgen::Q1_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp:

Program Listing for File gaussquad.cpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/gaussquad.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "gaussquad.hpp"
   #include <cmath>
   #include <cassert>
   #include <iostream>
   
   namespace libecpint {
   
       // Constructor
       GCQuadrature::GCQuadrature() {
           // Currently does nothing
       }
   
   
       GCQuadrature::GCQuadrature(const GCQuadrature &other) {
           maxN = other.maxN;
           M = other.M;
           I = other.I;
           t = other.t;
           x = other.x;
           w = other.w;
       }
   
       // Initialise the quadrature grid
       // As described in both Perez92 and Perez93
       void GCQuadrature::initGrid(const int points, const GCTYPE _t) {
           t = _t;
       
           // Initialise parameters for grid
           int p;
           if (t == ONEPOINT) { // Perez92 one point method
               // We need the number of points to be of the form
               // 2^p - 1 for some power p. 
               p = (int) floor(log(points + 1)/log(2));
               maxN = pow(2, p) - 1;
           } else if (t == TWOPOINT) { // Perez93 two point method
               // Here we need it instead to be of the form
               // 3 * 2^p - 1 for some p.
               p = (int) floor(log((points + 2)/3.0)/log(2));
               maxN = 3*pow(2, p) - 1;
           }
           M = (maxN-1)/2; // Midpoint
       
           // initialise arrays
           x.assign(maxN, 0.0);
           w.assign(maxN, 0.0);
       
           // At the midpoint, M, x[M] = 0 and w[M] = 1
           x[M] = 0.0; w[M] = 1.0;
           // The rest of the abscissae and weights are then given by:
           // z_i = i*Pi / (maxN + 1), s_i = sin(z_i), c_i = cos(z_i)
           // x_i = 1 + 2/(3*pi) * [ (3 + 2*s_i^2) * c_i * s_i - 3z_i]
           // (3(maxN + 1)/16) * w_i = s_i^4
           // We then note that s_(i+1) = c_1 s_i + s_1 c_i
           // and c_(i+1) = c_1 c_i - s_1 s_i
           // with z_(i+1) = z_i + z_1
           // Clearly s_(maxN + 1 - i) = s_i
           // and c_(maxN + 1 - i) = -c_i
           // Therefore x_(maxN + 1 - i) = -x_i
           // and w_(maxN + 1 - i) = w_i
           // Meaning that we only have to calculate half the weights and abscissae
           double z1 = M_PI / ((double)(maxN + 1));
           double c1 = cos(z1); double s1 = sin(z1);
           double zi, si, ci, zi1, si1, ci1; //z_i, s_i, c_i, z_(i+1), s_(i+1), c_(i+1)
           zi1 = z1; si1 = s1; ci1 = c1;
           double o23pi = 2.0 / (3.0 * M_PI); // Convenient
           double s2; //si * si
           for (int n = 0; n < M; n++) {
               // First update zi, si, ci
               zi = zi1;
               si = si1;
               ci = ci1;
               s2 = si * si;
           
               // Now determine the w and x values
               w[maxN - 1 - n] = w[n] = s2 * s2;
               x[n] = 1 + o23pi * ( (3.0 + 2.0 * s2) * ci * si - 3.0*zi );
               x[maxN - 1 - n] = x[n];
               x[n] = -x[n];
           
               // Then update zi1, si1, ci1
               zi1 = zi + z1;
               si1 = c1 * si + s1 * ci;
               ci1 = c1 * ci - s1 * si;
           }
       
           /*std::cout << maxN << " " << M << " " << start << " " << end << "\n";
           for (int q = 0; q < maxN; q++) std::cout << x[q] << " " << w[q] << "\n";*/
       }
   
       // Perform the GC integration on the function f
       std::pair<double, bool> GCQuadrature::integrate(
           std::function<double(double, const double*, int)> &f, const double *params,
           const double tolerance, const int start, const int end) const {
           bool converged = false; // 0 for converged, -1 for not converged
   
           double I = 0;
           if (t == ONEPOINT) {
               // Perez92 Case
               // Integration proceeds in the sequence T_1, T_3, T_7, ..., T_{maxN}
               // where T_m = (3(m+1)/16)I_m
               // by using the fact that T_{2m + 1} = T_{m} + sum_{k = 0}^m w_{2k+1}f(x_{2k+1})
               // The indices in terms of the maxN indices are given by 
               // 2k + 1 = (2k + 1) * M / 2^n = (2k + 1) * p
               // and checking convergence via whether
               // (T_{2m + 1} - 2T_m)^2 <= |T_{2m+1} - 4T_{(m-1)/2}| x tolerance
               double Tn, T2n1, Tn12; // T_n, T_{2n+1} and 4T_{(n-1)/2}
           
               // Initialise values, 
               // Single point integration would use midpoint, M
               Tn = w[M]*f(x[M], params, M);
               Tn12 = 2.0 * Tn;
           
               // Main loop
               int n = 1;
               double dT; // T_{2n+1} - 2T_n
               int ix; // Index needs to be calculated to know which points to use
               int p = (M+1) / 2; // M / 2^n 
               while (n < maxN && !converged) {
                   // Compute T_{2n+1}
                   T2n1 = Tn + sumTerms(f, params, n, start, end, p, 2);
               
                   // Check convergence
                   dT = T2n1 - 2.0*Tn;
                   n = 2*n + 1;
                   if (dT*dT <= fabs(T2n1 - Tn12)*tolerance) {
                       converged = true;  
                   } else {
                       Tn12 = 4.0 * Tn; 
                       Tn = T2n1;
                       p /= 2; 
                   }
               }
               // Finalise the integral
               I = 16.0 * T2n1 / (3.0*(n + 1.0));
           
           } else if (t == TWOPOINT) {
               // Perez93 case
               // We instead proceed along T_2, T_5, T_11, ..., T_{2m + 1} where maxN = 2m+1
               // but also compute T_1, T_3, ..., T_n, T_{2n+1} etc. as before,
               // where m + 1 = 3/2(n+1), so as to get better error control
               // To do this, we use that 
               // T_{2m+1} = T_m + T_n - T_{(n-1)/2} + sum_{i=0}^{(m-2)/3} [w_{6i+1}f(x_{6i+1}) + w_{6i+5}f(x_{6i+5})]
               // along with the same results as before. 
               // The algorithm proceeds by calculating one in the two-point sequence,
               // using an error of |I_{2m+1} - I_m|, then calculates one in the one-point sequence
               // and uses an error of |I_m - I_n|, to check convergence.
               double Tn, Tm, T2n1, T2m1, Tn12;
           
               // Initialise values
               Tn12 = 0.0; 
               Tn = w[M]*f(x[M], params, M);
               int M2 = (maxN - 2)/3; //Index of first point in twopoint sequence
               Tm = w[M2]*f(x[M2], params, M2) + w[maxN - M2 - 1]*f(x[maxN - M2 - 1], params, maxN - M2 - 1);
               int p = (M+1) / 2; // as before
               M2 = (M2 + 1)/2; 
               int ix; 
               int n = 1; int m = 2;
               double error;
            
               while(m < maxN && !converged) {
                   // Propagate the two-point sequence first 
                   T2m1 = Tm + Tn - Tn12 + sumTerms(f, params, (2*m - 1)/3, start, end, M2, 3);
               
                   // Check convergence
                   error = 16.0 * fabs(0.5*T2m1 - Tm) / (3.0 * (m + 1)); 
                   if (error > tolerance) {
                       // Propagate the one-point sequence
                       T2n1 = Tn + sumTerms(f, params, n, start, end, p, 2);
                   
                       // Check convergence again
                       error = 16.0 * fabs(2.0*T2m1 - 3.0*T2n1) / (18.0 * (n+1) );
                       m = 2 * m + 1;
                       n = 2 * n + 1;
                       if ( error < tolerance) {
                           converged = true; 
                       } else {
                           Tn12 = Tn;
                           Tn = T2n1;
                           Tm = T2m1; 
                           p /= 2;
                           M2 /= 2; 
                       }
                   } else {
                       m = 2 * m + 1;
                       converged = true; 
                   }
               }
               // Finalise the integral
               I = 16.0 * T2m1 / (3.0 * (m + 1.0));
           }
       
           return {I, converged};
       }
   
       // Worker function to do the additional sum terms when going from I_n to I_{2n+1}
       double GCQuadrature::sumTerms(
           const std::function<double(double, const double*, int)> &f,
           const double *p, const int limit, const int start, const int end,
           const int shift, const int skip) const {
           assert(start >= 0 && start < maxN);
           assert(end >= 0 && end < maxN);
           assert(end >= start);
   
           double value = 0.0;
           int ix; 
           for (int i = 0; i <= limit; i+=2) { 
               ix = (skip*i + 1)*shift - 1;
               if (ix >= start)
                   value += w[ix] * f(x[ix], p, ix);
           
               ix = maxN - ix - 1; 
               if (ix <= end)
                   value += w[ix] * f(x[ix], p, ix);
           }
           return value;
       }
   
       // The GC integrations above are over the interval [-1, 1] and thus need to be transformed
       // to the interval[0, infty), or [rmin, rmax]. We do this by the logarithmic transformation from Krack98
       // or the linear mapping of Flores06, respectively.  
       void GCQuadrature::transformZeroInf() {
           double ln2 = log(2.0);
           double xt;
       
           for (int i = 0; i < maxN; i++) {
               xt = 1.0 - log(1.0-x[i])/ln2;
               w[i] = w[i]/(ln2 * (1.0 - x[i]));
               x[i] = xt;
           }
       }
   
       void GCQuadrature::transformRMinMax(const double z, const double p) {
           double osz = 1.0 / sqrt(z);
       
           // Determine interval
           double rmin = p - 7.0 * osz;
           rmin = rmin > 0 ? rmin : 0.0;
           double rmax = p + 9.0 * osz;
       
           // Find the relative and absolute midpoints 
           double rmid = 0.5*(rmax - rmin); // Midpoint of interval relative to rmin
           double amid = rmid + rmin; // Midpoint of interval
       
           // Transform weights and abscissae by linearly transforming
           // both are scaled by rmid, and the abscissae are translated by amid
           for (int i = 0; i < maxN; i++) {
               x[i] = rmid * x[i] + amid;
               w[i] *= rmid;
           }
       }
       
       void GCQuadrature::untransformRMinMax(const double z, const double p) {
           double osz = 1.0 / sqrt(z);
       
           // Determine interval
           double rmin = p - 7.0 * osz;
           rmin = rmin > 0 ? rmin : 0.0;
           double rmax = p + 9.0 * osz;
       
           // Find the relative and absolute midpoints 
           double rmid = 0.5*(rmax - rmin); // Midpoint of interval relative to rmin
           double amid = rmid + rmin; // Midpoint of interval
       
           // Transform weights and abscissae by linearly transforming
           // both are scaled by rmid, and the abscissae are translated by amid
           for (int i = 0; i < maxN; i++) {
               x[i] = (x[i] - amid) / rmid;
               w[i] /= rmid;
           }
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1ab1fcb35c6f2cda3a171a75ae36f634d7:

Function libecpint::qgen::Q0_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a0b468cc9891219de7934784a9c925e23:

Function libecpint::qgen::Q2_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1acac155055f27ee3111437ed638b1c600:

Function libecpint::qgen::Q1_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa3d5947febd6747a1936eb7228e486e5:

Function libecpint::qgen::Q4_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a4fb015300d593d8ee8166eb84afacb32:

Function libecpint::qgen::Q3_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp:

Program Listing for File qgen.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/qgen.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *         This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #ifndef QGEN_HEAD
   #define QGEN_HEAD
   
   #include "multiarr.hpp"
   #include "radial.hpp"
   #include "angular.hpp"
   #include "gshell.hpp"
   #include "ecp.hpp"
   
   namespace libecpint {
       namespace qgen {
   
           void rolled_up(int lam, int LA, int LB, const ThreeIndex<double>& radials, const FiveIndex<double>& CA, const FiveIndex<double>& CB, const TwoIndex<double>& SA, const TwoIndex<double>& SB, const AngularIntegral& angints, ThreeIndex<double>& values);
   
           void rolled_up_special(int lam, int LA, int LB, const ThreeIndex<double>& radials, const FiveIndex<double>& CB, const TwoIndex<double>& SB, const AngularIntegral& angints, ThreeIndex<double>& values);
           
       void Q0_0_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_0_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_0_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_0_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_0_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_0_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_1_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_1_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q0_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q1_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q2_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q3_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q4_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
       void Q5_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&);
   
   }
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a5fc2c9a204e7c97db133573731819a2a:

Function libecpint::qgen::Q0_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a6210949d0c67ed65d2eeaea4ae8591b5:

Function libecpint::qgen::Q3_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac47c5efbc05973541703abc8265d2dc6:

Function libecpint::qgen::Q0_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f:

Enum GCTYPE
===========

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`


Enum Documentation
------------------


.. doxygenenum:: libecpint::GCTYPE

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp:

Program Listing for File ecp.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/ecp.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef ECP_HEAD
   #define ECP_HEAD
   
   #include <vector>
   #include <array>
   #include <map>
   #include <string>
   #include "config.hpp"
   
   namespace libecpint {
       
       const std::string atom_names[109] = {"h", "he", "li", "be", "b", "c", "n",
           "o", "f", "ne", "na", "mg", "al", "si", "p", "s", "cl", "ar",
           "k", "ca", "sc", "ti", "v", "cr", "mn", "fe", "co", "ni", "cu",
           "zn", "ga", "ge", "as", "se", "br", "kr", "rb", "sr", "y", "zr",
           "nb", "mo", "tc", "ru", "rh", "pd", "ag", "cd", "in", "sn", "sb",
           "te", "i", "xe", "cs", "ba", "la", "ce", "pr", "nd", "pm", "sm",
           "eu", "gd", "tb", "dy", "ho", "er", "tm", "yb", "lu", "hf", "ta",
           "w", "re", "os", "ir", "pt", "au", "hg", "tl", "pb", "bi", "po",
           "at", "rn", "fr", "ra", "ac", "th", "pa", "u", "np", "pu", "am",
           "cm", "bk", "cf", "es", "fm", "md", "no", "lr", "rf", "db", "sg",
           "bh", "hs", "mt" };
       
       struct GaussianECP {
           int n; 
           int l; 
           double a; 
           double d; 
       
           GaussianECP(); 
           
           GaussianECP(int n, int l, double a, double d);
           
           GaussianECP(const GaussianECP& other);
       };
   
       struct ECP {
           std::vector<GaussianECP> gaussians; 
           int N; 
           int L; 
           int atom_id; 
           double min_exp; 
           double min_exp_l[LIBECPINT_MAX_L+1]; 
           int    l_starts[LIBECPINT_MAX_L+2]; 
           
           std::array<double, 3> center_; 
       
           ECP();
           
           ECP(const double *_center);
           
           ECP(const ECP &other);
       
           void addPrimitive(int n, int l, double a, double d, bool needSort = true);
           
           const double* center() const { return &center_[0]; }
           
           void setPos(double x, double y, double z);
           
           void sort(); 
           
           GaussianECP& getGaussian(int i) { return gaussians[i]; }
           
           int getN() const { return N; }
           
           bool noType1() const; 
       
           double evaluate(double r, int l);
     
           int getL() const { return L; }
       
       };
   
       class ECPBasis {
       private:
           std::vector<ECP> basis;    
           std::vector<int> atomList; 
           int N; 
           int maxL; 
       
       public:
           ECPBasis(); 
           
           std::map<int, int> core_electrons;
           
           void addECP(ECP &U, int atom);
           
           ECP& getECP(int i);
           
           int getECPCore(int q); 
           
           int getAtom(int i) { return atomList[i]; }
           
           int getMaxL() const { return maxL; }
           
           int getN() const { return N; }
           
           void addECP_from_file(int q, std::array<double, 3> coords, std::string filename);
       };
   
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a0b77eccd5538829e047ae612b66b76a4:

Function libecpint::qgen::Q2_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp:

File api.hpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/api.hpp``)
-------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp.rst





Includes
--------


- ``array``

- ``ecpint.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`)

- ``memory``

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``string``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_e_c_p_integrator`


Defines
-------


- :ref:`exhale_define_api_8hpp_1a9c5be1c4ba084c752edba30f62c5da6d`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a37d6807785ad49c55bbe8b56deab2be8`

.. _exhale_function_namespacelibecpint_1_1qgen_1a2bea2d6240c5f253e14587ab83a5d9dd:

Function libecpint::qgen::Q4_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp:

File mathutil.cpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/mathutil.cpp``)
--------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp.rst





Includes
--------


- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a16e0a77a3022ff74a1fbb6eccba88c4c`

- :ref:`exhale_function_namespacelibecpint_1a0d3d7448d52abd739d6d100afa6d4e8a`

- :ref:`exhale_function_namespacelibecpint_1a321e63264d2ee5ec80e5aa98ab5f2a31`

- :ref:`exhale_function_namespacelibecpint_1ab8d8f23abac900581a1b074df5151bfa`

- :ref:`exhale_function_namespacelibecpint_1a764f6b0f657d4b76cd030593a81f8161`

- :ref:`exhale_function_namespacelibecpint_1a17491fad5ad55b86c80bccd068067373`

- :ref:`exhale_function_namespacelibecpint_1a274e6578163d01f8c1bd6b24f0f1e061`

- :ref:`exhale_function_namespacelibecpint_1adf95d3c9da1c27fbbbe785fb7d4c3419`

- :ref:`exhale_function_namespacelibecpint_1a12c8c970bff9ab1318e774a4637059fb`

- :ref:`exhale_function_namespacelibecpint_1a5ebc6e4869b8a3dab9286895629c19fc`

- :ref:`exhale_function_namespacelibecpint_1a697a408875eb033819881bc8d5fd3cec`

- :ref:`exhale_function_namespacelibecpint_1a60980f8f3c0f2ce3bfa35d1ab1ffe612`

- :ref:`exhale_function_namespacelibecpint_1a44095a8d0f5ab3e8bf4770a0ecd39a49`

- :ref:`exhale_function_namespacelibecpint_1ad7792ee9315576df3c805d0d0bbb6144`

- :ref:`exhale_function_namespacelibecpint_1aeea8f0398e91f9c4c0abc5087c68208a`

- :ref:`exhale_function_namespacelibecpint_1aa2a7bd43b3c7267b69a5a3faa3adf313`

- :ref:`exhale_function_namespacelibecpint_1adb6835f6678e044793635ea74137610c`

- :ref:`exhale_function_namespacelibecpint_1af1b4030182805b2b87939f0be0bb1f68`

- :ref:`exhale_function_namespacelibecpint_1ae8e9cac2c5167fee6077b8d5b38c879d`

- :ref:`exhale_function_namespacelibecpint_1a691287591ae556167f12eef21d9605d3`

- :ref:`exhale_function_namespacelibecpint_1afc2d0fbd27b79b1cfb7a933a4f8f86af`

- :ref:`exhale_function_namespacelibecpint_1aceff25bd00ac616a0c1679c43c757c25`

- :ref:`exhale_function_namespacelibecpint_1a125307aa5575e22d32bc381c0ddb598d`

- :ref:`exhale_function_namespacelibecpint_1af586e0d10f4e89ae23350208eae35381`

- :ref:`exhale_function_namespacelibecpint_1a3d3ec1164653607a1a2a66e71c160905`

- :ref:`exhale_function_namespacelibecpint_1ac8004320c2b47b1ce75ab1ccfff376e4`


Defines
-------


- :ref:`exhale_define_mathutil_8cpp_1a9450534f682d7a567d3872551afa2ec4`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a4ecb557cc8bf8d94cfa80855985007bf`

- :ref:`exhale_variable_namespacelibecpint_1a975e7b9e0f57709418adede308d80405`

.. _exhale_function_namespacelibecpint_1_1qgen_1a7a27208dca8f6953fd31e913e2fff149:

Function libecpint::qgen::Q1_1_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1af1b4030182805b2b87939f0be0bb1f68:

Function libecpint::pow_4
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_4(const double)
.. _exhale_variable_namespacelibecpint_1a20c4903045164881b8dedf0d6a6ed0fb:

Variable libecpint::maxUnrol
============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::maxUnrol

.. _file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_unrol_radial.py:

File unrol_radial.py
====================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_generated_radial>` (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial/unrol_radial.py``)
----------------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_unrol_radial.py.rst










Namespaces
----------


- :ref:`namespace_sympy`

- :ref:`namespace_unrol_radial`


Classes
-------


- :ref:`exhale_class_classunrol__radial_1_1_qijk`


Functions
---------


- :ref:`exhale_function_namespaceunrol__radial_1a48a1059eae24c36cd6464073577d147a`

- :ref:`exhale_function_namespaceunrol__radial_1a2cd46d9b308d3d493fdd7a516019c717`

- :ref:`exhale_function_namespaceunrol__radial_1aff823186ee3dc7e823e3f1a858233df6`

- :ref:`exhale_function_namespaceunrol__radial_1afc2f4f223df08979b137c507be4bbd37`


Variables
---------


- :ref:`exhale_variable_namespaceunrol__radial_1a582dde0241adf8b3a95b4459b4d49b2b`

- :ref:`exhale_variable_namespaceunrol__radial_1a02363db1e3121f4cb64855282f206fff`

- :ref:`exhale_variable_namespaceunrol__radial_1a7e0a7548eed4ebb942e94e7b9405f123`

- :ref:`exhale_variable_namespaceunrol__radial_1a032ec358895dd239986cf46342a0de86`


.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp:

File ecp.cpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/ecp.cpp``)
-------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp.rst





Includes
--------


- ``algorithm``

- ``cmath``

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp`)

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``pugixml.hpp``






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1a321e63264d2ee5ec80e5aa98ab5f2a31:

Function libecpint::pow_0
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_0(const double)
.. _exhale_function_namespacelibecpint_1a0d3d7448d52abd739d6d100afa6d4e8a:

Function libecpint::initFactorials
==================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::initFactorials()

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp:

Program Listing for File angular.cpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/angular.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "angular.hpp"
   #include "bessel.hpp"
   #include "mathutil.hpp"
   #include <cmath>
   
   namespace libecpint {
   
       double AngularIntegral::calcG(int l, int m) const {
           double value = 0.0;
           double value1 = FAST_POW[l](2.0) * FAC[l];
           value1 = 1.0 / value1; 
           double value2 = (2.0 * l + 1) * FAC[l - m] / (2.0 * M_PI * FAC[l + m]);
           value2 = std::sqrt(value2); 
           value = value1 * value2;
           return value;
       } 
   
       double AngularIntegral::calcH1(int i, int j, int l, int m) const {
           double value = 0.0; 
   
           value = FAC[l]/(FAC[j]*FAC[l - i]*FAC[i-j]);
           value *= (1 - 2*(i%2)) * FAC[2*(l - i)] / (FAC[l - m - 2*i]);
   
           return value;
       }
   
       double AngularIntegral::calcH2(int i, int j, int k, int m) const {
           double value = 0.0; 
           int ki2 = k - 2*i;
           if ( m >= ki2 && ki2 >= 0 ) {
               value = FAC[j]*FAC[m]/(FAC[i] * FAC[j-i] * FAC[ki2] * FAC[m-ki2]);
               int p = (m - k + 2*i)/2;
               value *= (1.0 - 2.0*(p%2));
           }
           return value;
       }
   
   
       ThreeIndex<double> AngularIntegral::uklm(int lam, int mu) const {
           ThreeIndex<double> values(lam+1, lam+1, 2);
        
           double or2 = 1.0/std::sqrt(2.0);
           double u = 0.0;
           double um = 0.0;
           double g = calcG(lam, mu);
   
           double u1, h1, h2;
           int j;
           for (int k = 0; k <= lam; k++) {
               for (int l = 0; l <= lam - k; l++) {
                   u = um = 0.0;
                   j = k + l - mu;
                   if (j % 2 == 0 && j > -1) { 
                       u1 = 0.0;
                       j/=2;
                       for (int i = j; i <= (lam - mu)/2; i++) u1 += calcH1(i, j, lam, mu);
               
                       u = g * u1;
                       u1 = 0;
                       for (int i = 0; i <= j; i++) u1 += calcH2(i, j, k, mu);
                       u *= u1;
                       um = u;
               
                       j = l % 2;
                       u *= (1 - j);
                       um *= j;
                       if (mu == 0) {
                           u *= or2;
                           um = u;
                       } 
                   }
                   values(k, l, 0) = u;
                   values(k, l, 1) = um;
               }
           }
           return values;                      
       }
   
   
       ThreeIndex<double> AngularIntegral::Pijk(int maxI) const {
           int dim = maxI+1;
           ThreeIndex<double> values(dim, dim, dim);
           double pi4 = 4.0*M_PI;
       
           values(0, 0, 0) = pi4;
           for (int i = 1; i <= maxI; i++) {
               values(i, 0, 0) = pi4 / ((double) (2*i+1));
           
               for (int j = 1; j <= i; j++) {
                   values(i, j, 0) = values(i, j-1, 0) * (2.0*j - 1.0) / (2.0 * ((double)(i + j)) + 1.0);
               
                   for (int k = 1; k <= j; k++)
                       values(i, j, k) = values(i, j, k-1) * (2.0*k - 1.0) / (2.0 * ((double)(i + j + k)) + 1.0);
               
               }
           }
           return values;
       }
   
       FiveIndex<double> AngularIntegral::makeU() {
           int dim = maxL + 1;
   
           FiveIndex<double> values(dim, dim, dim, dim, 2);
           for (int lam = 0; lam <= maxL; lam++) {
               for (int mu = 0; mu <= lam; mu++) {
                   ThreeIndex<double> Uij = uklm(lam, mu);
                   for (int i = 0; i <= lam; i++) {
                       for (int j = 0; j <= lam - i; j++){
                           values(lam, mu, i, j, 0) = Uij(i, j, 0);
                           values(lam, mu, i, j, 1) = Uij(i, j, 1);
                       }
                   }
               }
           }
       
           return values;
       }
   
       void AngularIntegral::makeW(FiveIndex<double> &U) {
           int LB2 = 2*LB;
           int dim = wDim;
           int maxI = (maxL + dim)/2;
           int maxLam = maxL;
       
           FiveIndex<double> values{dim+1, dim+1, dim+1, maxLam+1, 2*(maxLam + 1)};
           ThreeIndex<double> pijk = Pijk(maxI);
       
           int plam, pmu;
           double smu, w;
           std::vector<int> ix(3);
           for (int k = 0; k <= dim; k++) {    
               for (int l = 0; l <= dim; l++) {    
                   for(int m = 0; m <= dim; m++) {
                       plam = (k + l + m)%2;
                   
                       int limit = maxLam > k+l+m ? k+l+m : maxLam;
                       for(int lam = plam; lam <= limit; lam += 2){
                           smu = 1 - 2*(l%2);
                           pmu = (k+l) % 2;
                       
                           for (int mu = pmu; mu <= lam; mu+=2) {
                               w = 0.0;
                               for (int i = 0; i <= lam; i++) {
                                   for (int j = 0; j <= lam - i; j++) {
                                       ix[0] = k+i;
                                       ix[1] = l+j;
                                       ix[2] = m + lam - i - j; 
                                   
                                       if (ix[0]%2 + ix[1]%2 + ix[2]%2 == 0){
                                           std::sort(ix.begin(), ix.end()); 
                                           w += U(lam, mu, i, j, (1 - (int)(smu))/2)*pijk(ix[2]/2, ix[1]/2, ix[0]/2);
                                       }
                                   
                                   }
                               }
                           
                               values(k, l, m, lam, lam+(int)(smu*mu)) = w;
                           }
                       }   
                   }   
               }   
           }
           W = values;
       }
   
       void AngularIntegral::makeOmega(FiveIndex<double> &U) {
       
           int lamDim = LE + LB; 
           int muDim = 2*lamDim + 1;
           SevenIndex<double> values{LB+1, LB+1, LB+1, lamDim+1, muDim+1, lamDim+1, muDim+1};
           
           double om_plus=0.0, om_minus=0.0;
           double wval; 
           for (int k = 0; k <= LB; k++) {
               for (int l = 0; l <= LB; l++) {
                   for (int m = 0; m <= LB; m++) {
                       
                       for (int rho = 0; rho <= lamDim; rho++ ) {
                           for (int sigma = -rho; sigma <= rho; sigma++) {
                           
                               for (int lam = 0; lam <= rho; lam++) {
       
                                   for (int mu = 0; mu <= lam; mu++) {
                                   
                                       om_plus = om_minus = 0.0;
                                       for (int i = 0; i<= lam; i++ ) {
                                           for (int j = 0; j <= lam - i; j++) {                                                
                                               wval = W(k+i, l+j, m+lam-i-j, rho, rho+sigma);
                                               om_plus += U(lam, mu, i, j, 0) * wval;
                                               om_minus += U(lam, mu, i, j, 1) * wval;
                                           }
                                       }
                                       if (mu == 0) om_minus = om_plus;
                                       values(k, l, m, rho, sigma+rho, lam, lam+mu) = om_plus;
                                       values(k, l, m, lam, lam+mu, rho, sigma+rho) = om_plus;
                                       values(k, l, m, rho, sigma+rho, lam, lam-mu) = om_minus;
                                       values(k, l, m, lam, lam-mu, rho, sigma+rho) = om_minus;
                                   
                                   }
                               }
                           
                           }
                       }
                       
                   }
               }
           }
       
           omega = values;
       }
   
       AngularIntegral::AngularIntegral() { init(0, 0); }
       AngularIntegral::AngularIntegral(int _LB, int _LE) { init(_LB, _LE); }
       void AngularIntegral::init(int _LB, int _LE ) {
           LB = _LB;
           LE = _LE;
           wDim = 4*LB > 3*LB + LE ? 4*LB : 3*LB + LE;
           maxL = 2*LB > LB + LE ? 2*LB : LB+LE;
       
       }
   
       void AngularIntegral::compute() {
           FiveIndex<double> U = makeU();
           makeW(U);
           makeOmega(U);
       }
   
       void AngularIntegral::clear() {}
   
       double AngularIntegral::getIntegral(int k, int l, int m, int lam, int mu) const { return W(k, l, m, lam, lam+mu); }
       double AngularIntegral::getIntegral(int k, int l, int m, int lam, int mu, int rho, int sigma) const { return omega(k, l, m, lam, lam+mu, rho, rho+sigma); }
   
       bool AngularIntegral::isZero(int k, int l, int m, int lam, int mu, double tolerance) const {
           if (wDim > 0) return std::fabs(W(k, l, m, lam, lam+mu)) < tolerance;
           else return true;
       }
       bool AngularIntegral::isZero(int k, int l, int m, int lam, int mu, int rho, int sigma, double tolerance) const {
           if (wDim > 0) return std::fabs(omega(k, l, m, lam, lam+mu, rho, rho+sigma)) < tolerance;
           else return true;
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1abba30dd871f615eb80d23752522d6de1:

Function libecpint::qgen::Q2_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a9893d98cd4ed014e325e9d6392f40ac8:

Function libecpint::qgen::Q1_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp:

File multiarr.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Helpful lightweight multi-index arrays and tuples to make the code easier to write and test. 



.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/multiarr.hpp``)
------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp.rst



Detailed Description
--------------------

TODO: It is possible these are slowing things down a bit, need to run benchmarks. 




Includes
--------


- ``algorithm``

- ``sstream``

- ``tuple``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`

- :ref:`namespace_libecpint__aux`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4`

- :ref:`exhale_struct_structlibecpint_1_1aux_1_1seq`

- :ref:`exhale_struct_structlibecpint_1_1_five_index`

- :ref:`exhale_struct_structlibecpint_1_1_seven_index`

- :ref:`exhale_struct_structlibecpint_1_1_three_index`

- :ref:`exhale_struct_structlibecpint_1_1_two_index`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1aux_1a8e2ec9ac4e466e11814c592a83efb66f`

- :ref:`exhale_function_namespacelibecpint_1a23ce2cda098d601b0fddfb10b971e33f`


Typedefs
--------


- :ref:`exhale_typedef_namespacelibecpint_1a48b53f3b6bfb449ec300ab57fc03763c`

- :ref:`exhale_typedef_namespacelibecpint_1a7676a778fedc78dfdc0495c3319a2730`

- :ref:`exhale_typedef_namespacelibecpint_1a4dc36ca1c5a9247d8bfaac304a7df40f`

- :ref:`exhale_typedef_namespacelibecpint_1af2651847fa01dec731554db1e7b273fd`


.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp:

File angular.hpp
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/angular.hpp``)
-----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp.rst





Includes
--------


- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_angular_integral`


.. _file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp:

File ecp.cpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/ecp.cpp``)
---------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp.rst





Includes
--------


- ``algorithm``

- ``cmath``

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`)

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``pugixml.hpp``






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a93436d53d6ef5500eb458ef11e8043ac:

Function libecpint::qgen::Q0_0_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a4ecb557cc8bf8d94cfa80855985007bf:

Variable libecpint::DFAC
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::DFAC
.. _exhale_function_namespacelibecpint_1_1qgen_1a6179b5819e8e7e2f0335cfa6f36eb478:

Function libecpint::qgen::Q0_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp:

File mathutil.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS


Mathematical constants, special function tables, and utility functions. 



.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/mathutil.hpp``)
------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp.rst





Includes
--------


- ``cmath``

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``numeric``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Defines
-------


- :ref:`exhale_define_mathutil_8hpp_1a620539bb392918432be69023bb266dfb`

- :ref:`exhale_define_mathutil_8hpp_1ae71449b1cc6e6250b91f539153a7a0d3`

- :ref:`exhale_define_mathutil_8hpp_1a30bbac291639d5f7d964a92fa8742b94`

- :ref:`exhale_define_mathutil_8hpp_1aaf00c7de57af68f4e9d7acc87adb8d87`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a683275f366eb38bfcc526bf5264d9376`

- :ref:`exhale_variable_namespacelibecpint_1a4fc3cf89f4b0b1787baabc364a16e377`

- :ref:`exhale_variable_namespacelibecpint_1a5f751be5271cc840a3025f0e0ee026f2`

- :ref:`exhale_variable_namespacelibecpint_1a32d2ef087e028b702c316bd2875036ec`

- :ref:`exhale_variable_namespacelibecpint_1ae8056358eb2736d93b3a78dd1428555c`

.. _exhale_function_namespacelibecpint_1_1qgen_1a2861e6d26d3067ac962e777a165cf432:

Function libecpint::qgen::Q2_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a3de0194aa3913e0e14a9eedb28f9ef99:

Function libecpint::qgen::Q0_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a125307aa5575e22d32bc381c0ddb598d:

Function libecpint::pow_9
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_9(const double)
.. _dir__Users_robertshaw_devfiles_libecpint_new_include:


Directory include
=================


*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/include``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint`


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_testutil.hpp`


.. _exhale_function_namespacelibecpint_1_1qgen_1a030ab3019b1098321972e7f2aa3654bc:

Function libecpint::qgen::Q1_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp:

File libecpint.hpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include>` (``/Users/robertshaw/devfiles/libecpint_new/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint.hpp``)
-------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint.hpp.rst





Includes
--------


- ``libecpint/api.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`)





.. _exhale_function_namespacelibecpint_1_1qgen_1a747ea3f093bdc2c16930a9e1573bd396:

Function libecpint::qgen::Q0_0_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af900a11994d6f09f0d83cdbc01a6cf3d:

Function libecpint::qgen::Q1_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac0c591b25ebe3779266e40f02e37125c:

Function libecpint::qgen::Q3_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2f3ffdd94d2b604fbffc55d77b944ef5:

Function libecpint::qgen::Q4_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a7330c93ccc3ee07d2e17264c2f418527:

Function libecpint::qgen::Q0_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa01fb986261df6407432d76739134ee1:

Function libecpint::qgen::Q2_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp:

Program Listing for File api.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/api.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef API_HEAD
   #define API_HEAD
   
   #include <vector>
   #include <array>
   #include <string>
   #include <memory>
   #include "ecpint.hpp"
   #include "multiarr.hpp"
   
   namespace libecpint {
   
   #define H_START(i, j, N) (9*j + 3*(3*N-1)*i - (9*i*(i+1))/2 - 3)
       
       const double TWO_C_TOLERANCE = 1E-12;
       
       struct ECPIntegrator {
           std::vector<GaussianShell> shells; 
           ECPBasis ecps; 
           std::shared_ptr<ECPIntegral> ecpint; 
           int maxLB; 
           int deriv; 
           int ncart; 
           int natoms; 
           double min_alpha; 
           
           bool ecp_is_set; 
           bool basis_is_set; 
           
           TwoIndex<double> integrals; 
           
           std::vector<TwoIndex<double>> first_derivs;
           
           std::vector<TwoIndex<double>> second_derivs; 
           
           ECPIntegrator() { ecp_is_set = basis_is_set = false; maxLB = ncart = 0; }
           
           void set_gaussian_basis(int nshells, double* coords, double* exponents, double* coefs, int* ams, int* shell_lengths);
           
           void set_ecp_basis(int necps, double* coords, double* exponents, double* coefs, int* ams, int* ns, int* shell_lengths);
           
           void set_ecp_basis_from_library(int necps, double* coords, int* charges, std::vector<std::string> names, std::string share_dir);
           
           void update_gaussian_basis_coords(int nshells, double* coords);
           
           void update_ecp_basis_coords(int necps, double* coords);
           
           void init(int deriv_ = 0);
           
           void compute_integrals();
           
           void compute_first_derivs();
           
           void compute_second_derivs();
           
           std::shared_ptr<std::vector<double>> get_integrals() { return std::make_shared<std::vector<double>>(integrals.data); }
           
           std::vector<std::shared_ptr<std::vector<double>>> get_first_derivs() {
               std::vector<std::shared_ptr<std::vector<double>>> results;
               for (auto& v : first_derivs) results.push_back(std::make_shared<std::vector<double>>(v.data));
               return results;
           }
           
           std::vector<std::shared_ptr<std::vector<double>>> get_second_derivs() {
               std::vector<std::shared_ptr<std::vector<double>>> results;
               for (auto& v : second_derivs) results.push_back(std::make_shared<std::vector<double>>(v.data));
               return results;
           }
       };
       
       double shell_bound(int la, double alpha, double A2, double eta);
       
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a9a8592e8a00c0d7a195be80fb3bbd0ea:

Function libecpint::qgen::Q2_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a8aa5fff0f4772cffde29ece307abe014:

Function libecpint::qgen::Q0_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp:

File gaussquad.hpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/gaussquad.hpp``)
-------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp.rst





Includes
--------


- ``functional``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_g_c_quadrature`


Enums
-----


- :ref:`exhale_enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f`

.. _dir__Users_robertshaw_devfiles_libecpint_new_src_lib:


Directory lib
=============


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src>` (``/Users/robertshaw/devfiles/libecpint_new/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/src/lib``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_gen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_radial_quad.cpp`



.. _file__Users_robertshaw_devfiles_libecpint_new_README.md:

File README.md
==============

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/README.md``)
-------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_README.md.rst










.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp:

Program Listing for File radial_gen.cpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/generated/radial/radial_gen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file was generated as a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       void RadialIntegral::compute_base_integrals(
         const int N_min, const int N_max, const double p, const double o_root_p, const double P1,
         const double P2, const double P1_2, const double P2_2, const double X1, const double X2,
         const double oP1, const double oP2, double* values) {
       
           // Recursively construct the base integrals in order F2, G3, F4, G5, etc... as described in Shaw2017
           
           int imax = N_max / 2;
           int imin = (N_min + 1) / 2;
           int gmax = (N_max - 1) / 2;
           int gmin = N_min / 2;
       
           double P1_2k = 1.0;
           double P2_2k = 1.0; 
       
           for (int k = 2; k < imin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           double ck, dk, ek, val; 
           double C0 = o_root_p * ROOT_PI;
           for (int n = imin; n <= imax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);   
           
               for (int k = n - 1; k > 1; k--) {
                   ck *= 2*k*(2*k - 1)*(n-k-0.5) / ((2*n - 2*k) * (2*n - 2*k - 1) * p);
                   dk *= oP1;
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               if (n > 1) {
                   ck *= 2*(n-1.5) / ((2*n - 2) * (2*n - 3) * p);
                   val += ck * (X1 - X2); 
               }
           
               values[2*n - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           P1_2k = P1;
           P2_2k = P2;
           for (int k = 1; k < gmin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           } 
       
       
           for (int n = gmin; n <= gmax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);
           
               for (int k = n-1; k >0; k--) {
                   ck *= 2*k*(2*k+1)*(n-k-0.5) / ((2*n-2*k) * (2*n - 1 - 2*k) * p);
                   dk *= oP1; 
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               values[2*n + 1 - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2; 
           } 
       
       }
   
       std::pair<double, bool> RadialIntegral::integrate_small(
         const int N, const int l1, const int l2, const double n,
         const double a, const double b, const double A, const double B) {
           int gridSize = smallGrid.getN();
           std::vector<double> &gridPoints = smallGrid.getX();
       
           double Ftab[gridSize]; 
           std::vector<double> besselValues1, besselValues2; 
       
           double z, zA, zB;
           double aA = 2.0 * a * A;
           double bB = 2.0 * b * B;
           for (int i = 0; i < gridSize; i++) {
               z = gridPoints[i];
               zA = z - A; 
               zB = z - B; 
               
               // TODO: Efficiencies could be found here by calculating Bessel function for only l1/l2, not all l up to l1/l2
               bessie.calculate(aA * z, l1, besselValues1);
               bessie.calculate(bB * z, l2, besselValues2);  
               
               Ftab[i] = pow(z, N) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValues1[l1] * besselValues2[l2];
           }
       
           std::function<double(double, double*, int)> intgd = RadialIntegral::integrand;
           
           // There should be no instances where this fails, so no backup plan to large grid, but return check just in case 
           bool success = smallGrid.integrate(intgd, Ftab, 1e-12); 
           std::pair<double, bool> rval = {smallGrid.getI(), success};  
           return rval; 
       }
       
       void RadialIntegral::type2(
         const std::vector<Triple>& triples, const int nbase, const int lam,
         const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         const double A, const double B, ThreeIndex<double> &radials)
       {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
           
           // Loop over primitives in ECP, only considering correct ang. momentum
           for(const auto& u : U.gaussians) { 
               if (u.l == lam) {
                   
                   // Loop over primitives in orbital basis shellß
                   for(int na = 0; na < npA; na++) {
                       double a = shellA.exp(na);
                       double da = shellA.coef(na); 
               
                       for (int nb = 0; nb < npB; nb++) {
                           double b = shellB.exp(nb);
                           double db = shellB.coef(nb); 
                           
                           // Construct values that will be reused across all radial integrals
                           double p = u.a + a + b;
                           double x = a * A;
                           double y = b * B;
       
                           double P1 = (x + y) / p;
                           double P2 = (y - x) / p;
                           double P1_2 = P1 * P1;
                           double P2_2 = P2 * P2;
                           double oP1 = 1.0 / P1_2;
                           double oP2 = std::abs(P2) < 1e-7 ? 0.0 : 1.0 / P2_2;
                           double root_p = sqrt(p);
                           double o_root_p = 1.0 / root_p; 
                           double aAbB = a*A*A + b*B*B;
                           double Kab = 1.0 / (16.0 * x * y); 
                           double X1 = exp(p * P1_2 - aAbB) * Kab;
                           double X2 = exp(p * P2_2 - aAbB) * Kab;
       
                           double x2 = x * x;
                           double y2 = y * y; 
                           double p2 = p * p; 
       
                           double result = 0.0;
                           
                           // G1A, G1B may not be required, but it seems to be quicker to calculate than to check if needed
                           double daw1 = X1 * Faddeeva::Dawson(root_p * P1);
                           double daw2 = X2 * Faddeeva::Dawson(root_p * P2);   
                           double G1B = 2.0 * ROOT_PI * (daw1 - daw2);
                           double G1A = 2.0 * ROOT_PI * (daw1 + daw2);
                           double H2 =  ROOT_PI * ( X1 + X2 ) * o_root_p; 
   
                           // Compute base integrals
                           double *values = new double[nbase+2]; 
                           compute_base_integrals(2, 3+nbase, p, o_root_p, P1, P2, P1_2, P2_2, X1, X2, oP1, oP2, values); 
                           
                           // Loop over all radial integrals required, divert to generated code
                           for (const Triple& triple : triples ) {
                               int i = std::get<1>(triple);
                               int j = std::get<2>(triple);
                               int k = std::get<0>(triple) + u.n + 2; 
                               
                               int ijk = i*10000 + j*100 + k; 
                               double result = 0.0;
                               if (a > 0.1 && b > 0.1) { 
                                   switch(ijk) {
                                       case 2 : {
                                           result = ( 1 ) * values[0];
                                           break;
                                       }
   
                                       case 4 : {
                                           result += ( 1 ) * values[ 2 ];
                                           break;
                                       }
   
                                       case 6 : {
                                           result += ( 1 ) * values[ 4 ];
                                           break;
                                       }
   
                                       case 8 : {
                                           result += ( 1 ) * values[ 6 ];
                                           break;
                                       }
   
                                       case 10 : {
                                           result += ( 1 ) * values[ 8 ];
                                           break;
                                       }
   
                                       case 12 : {
                                           result += ( 1 ) * values[ 10 ];
                                           break;
                                       }
   
                                       case 101 : {
                                           result = ( p/y ) * values[0];
                                           result += ( -x/y ) * G1A;
                                           break;
                                       }
   
                                       case 103 : {
                                           result = ( -1/(2*y) ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 105 : {
                                           result += ( -1/(2*y) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 107 : {
                                           result += ( -1/(2*y) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 109 : {
                                           result += ( -1/(2*y) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 111 : {
                                           result += ( -1/(2*y) ) * values[ 8 ];
                                           result += ( 1 ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 10102 : {
                                           result = ( -(p/2 + y2)/(x*y) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10104 : {
                                           result = ( 1/(2*x*y) ) * values[0];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 2 ];
                                           result += ( -1/x ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10106 : {
                                           result += ( 1/(x*y) ) * values[ 2 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -2/x ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10108 : {
                                           result += ( 3/(2*x*y) ) * values[ 4 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -3/x ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10110 : {
                                           result += ( -1/(4*x*y) ) * values[ 6 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 8 ];
                                           result += ( 1/(2*x) ) * values[ 7 ];
                                           result += ( p/x ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 202 : {
                                           result = ( -3*p/(2*y2) + 1 ) * values[0];
                                           result += ( 3*x/(2*y2) ) * G1A;
                                           break;
                                       }
   
                                       case 204 : {
                                           result = ( 3/(4*y2) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -3/(2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 206 : {
                                           result += ( 3/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -3/(2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 208 : {
                                           result += ( 3/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -3/(2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 210 : {
                                           result += ( 3/(4*y2) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 8 ];
                                           result += ( -3/(2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10201 : {
                                           result = ( -p*(p + 2*x2)/(2*x*y2) ) * values[0];
                                           result += ( x2/y2 ) * G1A;
                                           result += ( p/y ) * H2;
                                           break;
                                       }
   
                                       case 10203 : {
                                           result = ( (3*p + 2*y2)/(4*x*y2) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10205 : {
                                           result = ( -3/(4*x*y2) ) * values[0];
                                           result += ( (3*p - 2*y2)/(4*x*y2) ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( 3/(2*x*y) ) * values[ 1 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10207 : {
                                           result += ( -3/(2*x*y2) ) * values[ 2 ];
                                           result += ( 3*(p - 2*y2)/(4*x*y2) ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 3/(x*y) ) * values[ 3 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10209 : {
                                           result += ( -9/(4*x*y2) ) * values[ 4 ];
                                           result += ( (3*p - 10*y2)/(4*x*y2) ) * values[ 6 ];
                                           result += ( p/x ) * values[ 8 ];
                                           result += ( 9/(2*x*y) ) * values[ 5 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20202 : {
                                           result = ( (3*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 20204 : {
                                           result = ( -(3*p/2 + y2)/(x2*y2) ) * values[0];
                                           result += ( (3*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( (3*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20206 : {
                                           result = ( 3/(2*x2*y2) ) * values[0];
                                           result += ( -3*p/(x2*y2) ) * values[ 2 ];
                                           result += ( (3*p2 + 4*y2*(-3*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( -3/(x2*y) ) * values[ 1 ];
                                           result += ( 2*(3*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20208 : {
                                           result += ( 9/(2*x2*y2) ) * values[ 2 ];
                                           result += ( 3*(-3*p + 2*y2)/(2*x2*y2) ) * values[ 4 ];
                                           result += ( (3*p2 + 4*y2*(-5*p + y2))/(4*x2*y2) ) * values[ 6 ];
                                           result += ( p2/x2 ) * values[ 8 ];
                                           result += ( -9/(x2*y) ) * values[ 3 ];
                                           result += ( 3*(3*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 301 : {
                                           result = ( p*(-5*p + 5*x2 + 2*y2)/(2*(y2*y)) ) * values[0];
                                           result += ( x*(15*p - 10*x2 + 6*y2)/(4*(y2*y)) ) * G1A;
                                           result += ( -5*p*x/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 303 : {
                                           result = ( 15*p/(4*(y2*y)) - 3/y ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           result += ( -15*x/(4*(y2*y)) ) * G1A;
                                           break;
                                       }
   
                                       case 305 : {
                                           result = ( -15/(8*(y2*y)) ) * values[0];
                                           result += ( -3/y ) * values[ 2 ];
                                           result += ( 15/(4*y2) ) * values[ 1 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 307 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 2 ];
                                           result += ( -3/y ) * values[ 4 ];
                                           result += ( 15/(4*y2) ) * values[ 3 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 309 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 4 ];
                                           result += ( -3/y ) * values[ 6 ];
                                           result += ( 15/(4*y2) ) * values[ 5 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10302 : {
                                           result = ( (5*p2 + 10*p*x2 - 2*p*y2 - 4*(y2*y2))/(4*x*(y2*y)) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           result += ( -5*x2/(2*(y2*y)) ) * G1A;
                                           result += ( -5*p/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 10304 : {
                                           result = ( -(15*p + 6*y2)/(8*x*(y2*y)) ) * values[0];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 2 ];
                                           result += ( 3*(5*p + 2*y2)/(4*x*y2) ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10306 : {
                                           result = ( 15/(8*x*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p + 6*y2)/(8*x*(y2*y)) ) * values[ 2 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -15/(4*x*y2) ) * values[ 1 ];
                                           result += ( (15*p + 2*y2)/(4*x*y2) ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10308 : {
                                           result += ( 15/(4*x*(y2*y)) ) * values[ 2 ];
                                           result += ( 3*(-5*p + 14*y2)/(8*x*(y2*y)) ) * values[ 4 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -15/(2*x*y2) ) * values[ 3 ];
                                           result += ( (15*p - 2*y2)/(4*x*y2) ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20301 : {
                                           result = ( p*(3*p2 + 2*p*x2 + 4*(x2*x2) + 4*x2*y2 - 4*(y2*y2))/(4*x2*(y2*y)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 1 ];
                                           result += ( -(x2*x)/(y2*y) ) * G1A;
                                           result += ( -p*(3*p + 2*x2 + 2*y2)/(2*x*y2) ) * H2;
                                           break;
                                       }
   
                                       case 20303 : {
                                           result = ( -(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[0];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 2 ];
                                           result += ( (15*p2 + 4*y2*(3*p + y2))/(4*x2*y2) ) * values[ 1 ];
                                           result += ( p2/x2 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20305 : {
                                           result = ( 3*(5*p + 2*y2)/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 4 ];
                                           result += ( -(15*p + 6*y2)/(2*x2*y2) ) * values[ 1 ];
                                           result += ( (15*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[ 3 ];
                                           result += ( p2/x2 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20307 : {
                                           result = ( -15/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(5*p - 2*y2)/(2*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*p2 + 84*p*y2 + 28*(y2*y2))/(8*x2*(y2*y)) ) * values[ 4 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 6 ];
                                           result += ( 15/(2*x2*y2) ) * values[ 1 ];
                                           result += ( -(15*p + 4*y2)/(x2*y2) ) * values[ 3 ];
                                           result += ( (15*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 5 ];
                                           result += ( p2/x2 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 30302 : {
                                           result = ( -(15*(p2*p) + 18*p2*y2 + 12*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 2 ];
                                           result += ( 3*p*(5*p2 + 6*p*y2 + 4*(y2*y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30304 : {
                                           result = ( 3*(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( (-15*(p2*p) + 54*p2*y2 + 4*(y2*y2)*(9*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 4 ];
                                           result += ( -(45*p2 + 12*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(p + 2*y2))/(4*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30306 : {
                                           result = ( -(45*p + 18*y2)/(4*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( 3*(15*p2 - 12*p*y2 - 4*(y2*y2))/(4*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*(p2*p) + 126*p2*y2 + 4*(y2*y2)*(21*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 4 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 6 ];
                                           result += ( 9*(5*p + 2*y2)/(2*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( -(45*p2 + 12*y2*(2*p + y2))/(2*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(-p + 2*y2))/(4*(x2*x)*y2) ) * values[ 5 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 402 : {
                                           result = ( (-5*p*(-7*p + 7*x2 + 4*y2)/4 + (y2*y2))/(y2*y2) ) * values[0];
                                           result += ( 5*x*(-21*p + 14*x2 - 6*y2)/(8*(y2*y2)) ) * G1A;
                                           result += ( 35*p*x/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 404 : {
                                           result = ( 15*(-7*p + 6*y2)/(8*(y2*y2)) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -5/y ) * values[ 1 ];
                                           result += ( 105*x/(8*(y2*y2)) ) * G1A;
                                           break;
                                       }
   
                                       case 406 : {
                                           result = ( 105/(16*(y2*y2)) ) * values[0];
                                           result += ( 45/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 1 ];
                                           result += ( -5/y ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 408 : {
                                           result += ( 105/(16*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 3 ];
                                           result += ( -5/y ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10401 : {
                                           result = ( -p*(-7*p2 - 28*p*x2 + 2*p*y2 + 14*(x2*x2) + 4*x2*y2)/(4*x*(y2*y2)) ) * values[0];
                                           result += ( x2*(-35*p + 14*x2 - 10*y2)/(4*(y2*y2)) ) * G1A;
                                           result += ( p*(-7*p + 7*x2 + 2*y2)/(2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10403 : {
                                           result = ( -(35*p2 + 70*p*x2 - 20*p*y2 - 32*(y2*y2))/(8*x*(y2*y2)) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 1 ];
                                           result += ( 35*x2/(4*(y2*y2)) ) * G1A;
                                           result += ( 35*p/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10405 : {
                                           result = ( 15*(7*p + 2*y2)/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 45*p/(4*x*y2) + 3/x ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( -(105*p + 30*y2)/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10407 : {
                                           result = ( -105/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 15*(7*p - 10*y2)/(16*x*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45*p/(4*x*y2) + 2/x ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 105/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( 5*(-21*p + 2*y2)/(8*x*(y2*y)) ) * values[ 3 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20402 : {
                                           result = ( -(21*(p2*p) + 14*p2*x2 - 6*p2*y2 + 28*p*(x2*x2) + 28*p*x2*y2 - 36*p*(y2*y2) - 8*(y2*y2*y2))/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( 7*(x2*x)/(2*(y2*y2)) ) * G1A;
                                           result += ( 7*p*(3*p + 2*x2 + 2*y2)/(4*x*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 20404 : {
                                           result = ( 3*(35*p2 + 20*p*y2 + 4*(y2*y2))/(16*x2*(y2*y2)) ) * values[0];
                                           result += ( (45*p2 + 4*y2*(6*p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( -(105*p2 + 60*p*y2 + 12*(y2*y2))/(8*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20406 : {
                                           result = ( -(105*p + 30*y2)/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( 3*(35*p2 - 100*p*y2 - 28*(y2*y2))/(16*x2*(y2*y2)) ) * values[ 2 ];
                                           result += ( (45*p2 + 4*y2*(4*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( 15*(7*p + 2*y2)/(4*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*p2 + 20*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 3 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30401 : {
                                           result = ( -p*(15*(p2*p) + 6*p2*x2 + 4*p*(x2*x2) + 24*p*x2*y2 - 36*p*(y2*y2) + 8*(x2*x2*x2) + 8*(x2*x2)*y2 + 8*x2*(y2*y2) - 16*(y2*y2*y2))/(8*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( (p2*p)/(x2*x) ) * values[ 2 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 1 ];
                                           result += ( (x2*x2)/(y2*y2) ) * G1A;
                                           result += ( p*(15*p2 + 6*p*x2 + 20*p*y2 + 4*(x2*x2) + 4*x2*y2 + 4*(y2*y2))/(4*x2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 30403 : {
                                           result = ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( 3*p*(15*p2 + 4*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 2 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 4 ];
                                           result += ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30405 : {
                                           result = ( -(315*p2 + 180*p*y2 + 36*(y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( -(-105*(p2*p) + 450*p2*y2 + 252*p*(y2*y2) + 40*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[ 2 ];
                                           result += ( 3*p*(15*p2 + 4*y2*(2*p + y2))/(4*(x2*x)*y2) ) * values[ 4 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 6 ];
                                           result += ( 9*(35*p2 + 20*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*(p2*p) + 30*p2*y2 + 4*(y2*y2)*(3*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 3 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 40402 : {
                                           result = ( (105*(p2*p2) + 120*(p2*p)*y2 + 72*p2*(y2*y2) + 32*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( 3*p2*(15*p2 + 8*y2*(2*p + y2))/(4*(x2*x2)*y2) ) * values[ 2 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 4 ];
                                           result += ( -p*(105*(p2*p) + 120*p2*y2 + 72*p*(y2*y2) + 32*(y2*y2*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 40404 : {
                                           result = ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(4*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( (105*(p2*p2) - 600*(p2*p)*y2 - 504*p2*(y2*y2) - 160*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[ 2 ];
                                           result += ( p2*(45*p2 + 32*p*y2 + 24*(y2*y2))/(4*(x2*x2)*y2) ) * values[ 4 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 6 ];
                                           result += ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(2*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( p*(-105*(p2*p) + 40*p2*y2 + (y2*y2)*(24*p - 32*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 3 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       default: {
                                           std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                           result = quadval.first; 
                                           if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                       }
                                   }
                               } else {
                                   std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                   result = quadval.first; 
                                   if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                               } 
                               
                               radials(k-2-u.n, i, j) += da * db * u.d * result;
                           }
                           
                           delete[] values; 
                       }
                   }
               }
           }
       }
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a15e49a02b122486b1eba9c47193a9a7f:

Function libecpint::qgen::Q3_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

Library API
===========

.. include:: class_view_hierarchy.rst

.. include:: file_view_hierarchy.rst

.. include:: unabridged_api.rst

.. _exhale_function_namespacelibecpint_1af586e0d10f4e89ae23350208eae35381:

Function libecpint::pow_m1
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_m1(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae71431041dc69e2d429acbf54f03464d:

Function libecpint::qgen::Q2_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a5bd73223ef2829c4d4e8f1fb68b7bcbb:

Function libecpint::pow_7
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_7(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a4102cedccaa2b99ae690e9b8c69551c2:

Function libecpint::qgen::Q0_1_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af087e0cdf5de3780ae754e9c6f657198:

Function libecpint::qgen::Q2_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a299bb6bb7a5287c2773d9f4189a26d69:

Function libecpint::qgen::Q0_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _dir__Users_robertshaw_devfiles_libecpint_src_lib:


Directory lib
=============


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src>` (``/Users/robertshaw/devfiles/libecpint/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint/src/lib``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp`


.. _exhale_function_namespacelibecpint_1afc2d0fbd27b79b1cfb7a933a4f8f86af:

Function libecpint::pow_7
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_7(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a00da41091abc4253b7f7c50816157f4a:

Function libecpint::qgen::Q2_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp:

File gshell.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/gshell.cpp``)
----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp.rst





Includes
--------


- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1aux_1a8e2ec9ac4e466e11814c592a83efb66f:

Template Function libecpint::aux::print_tuple
=============================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::aux::print_tuple(std::basic_ostream<Ch, Tr>&, Tuple const&, seq<Is...>)

.. _file__Users_robertshaw_devfiles_libecpint_README.md:

File README.md
==============

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/README.md``)
---------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_README.md.rst









.. _exhale_struct_structlibecpint_1_1_five_index:

Template Struct FiveIndex
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::FiveIndex
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1aad2b22ead6cc4dd2326b1e07fbd9a0e4:

Function libecpint::qgen::Q2_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp:

File angular.cpp
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/angular.cpp``)
-----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`)

- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`)

- ``cmath``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp:

File gaussquad.cpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/gaussquad.cpp``)
-------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_gaussquad.cpp.rst





Includes
--------


- ``cmath``

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp`)

- ``iostream``






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_variable_namespacelibecpint_1ae0ba3cdb903f3057f168bfaa5495bba0:

Variable libecpint::CAX2
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::CAX2
.. _dir__Users_robertshaw_devfiles_libecpint_new_src_generated:


Directory generated
===================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src>` (``/Users/robertshaw/devfiles/libecpint_new/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint_new/src/generated``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_new_src_generated_radial`



.. _exhale_function_namespacelibecpint_1_1qgen_1a832916799425771d4a829de5f488c7ab:

Function libecpint::qgen::Q0_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1adf95d3c9da1c27fbbbe785fb7d4c3419:

Function libecpint::pow_13
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_13(const double)
.. _exhale_variable_namespacelibecpint_1a683275f366eb38bfcc526bf5264d9376:

Variable libecpint::FAST_POW
============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::FAST_POW
.. _exhale_function_namespacelibecpint_1_1qgen_1a85275daf2de3182417a0f5a3ffac47c5:

Function libecpint::qgen::Q3_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp:

Program Listing for File bessel.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/bessel.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "bessel.hpp"
   #include "mathutil.hpp"
   #include <cmath>
   #include <cassert>
   #include <iostream>
   
   namespace libecpint {
   
       // Constructor
       BesselFunction::BesselFunction() {}
       BesselFunction::BesselFunction(const int _lMax, const int _N, const int _order, const double accuracy)
       {
           init(_lMax, _N, _order, accuracy);
       }
   
       void BesselFunction::init(const int _lMax, const int _N, const int _order, const double accuracy) {
           // Check parameters
           lMax = _lMax > -1 ? _lMax : 0;
           N = _N > 0 ? _N : 1;
           order = _order > 0 ? _order : 1;
           scale = N/16.0;
       
           // Allocate arrays
           K = new double*[N+1];
           dK = new double**[N+1];
           for (int i = 0; i < N+1; i++) {
               K[i] = new double[lMax + TAYLOR_CUT + 1];
               dK[i] = new double*[TAYLOR_CUT + 1];
               for (int j = 0; j < TAYLOR_CUT + 1; j++)
                   dK[i][j] = new double[lMax + TAYLOR_CUT + 1];
           }
           C = new double[lMax+TAYLOR_CUT];
       
           // Tabulate values
           tabulate(accuracy);
       }
   
       BesselFunction::~BesselFunction() {
           free(K);
           free(dK);
           free(C);
       }
   
       // Tabulate the bessel function values
       int BesselFunction::tabulate(const double accuracy) {
           int retval = 0; // 0 for success, -1 for not converged
           // Series expansion for bessel function, K, is given by:
           // K_l(z) ~ z^l sum_{j=0 to infty} F_j(z) / (2j + 2l + 1)!! 
           // where F_j(z) = e^(-z) * (z^2/2)^j / j!
           int lmax = lMax + TAYLOR_CUT;
       
           double F[order + 1]; // F_j above
       
           K[0][0] = 1.0;
           double z, z2; // z and z^2 / 2
           double ratio; // F_j(z) / (2j+1)!!
           for (int i = 0; i <= N; i++) {
               // Calculate K(z) at equally spaced points z = 16/N to 16
               z = i / (N/16.0);
               z2 = z * z / 2.0;
           
               F[0] = exp(-z);
               ratio = F[0] / DFAC[0];
               K[i][0] = ratio;
           
               // Series expansion for K_0(z)
               int l = order;
               int j;
               for (j = 1; j <= l; j++) {
               
                   if (ratio < accuracy) {
                       // Reached convergence
                       break;
                   } 
               
                   F[j] = F[j-1] * z2 / ((double)j);
                   ratio = F[j] / DFAC[2*j+1];
                   K[i][0] += ratio;
               }
               //if ( ratio > accuracy ) { retval = -1; break; } // Not converged
   
               // Calculate K_l from K_0
               z2 = z;
               for (l=1; l<=lmax; l++) {
                   ratio = 0;
                   for (int m=0; m < j; m++) ratio += F[m]/DFAC[2*l + 2*m + 1]; 
                   K[i][l] = z2 * ratio;
                   z2 *= z; 
               }
       
           }
       
           // Determine coefficients for derivative recurrence
           for (int i = 1; i<lmax; i++) C[i] = i/(2.0*i + 1.0);
           
           // Determine the necessary derivatives from
           // K_l^(n+1) = C_l K_(l-1)^(n) + (C_l + 1/(2l+1))K_(l+1)^(n) - K_l^(n)
           for (int ix = 0; ix < N+1; ix++) {
               // Copy K values into dK
               for (int l = 0; l <= lMax+TAYLOR_CUT; l++)
                   dK[ix][0][l] = K[ix][l];
               
               // Then the rest
               for (int n = 1; n < TAYLOR_CUT+1; n++) { 
                   dK[ix][n][0] = dK[ix][n-1][1] - dK[ix][n-1][0];
                   for (int l = 1; l <= lMax + TAYLOR_CUT - n; l++) 
                       dK[ix][n][l] = C[l]*dK[ix][n-1][l-1] + (C[l] + 1.0/(2.0*l + 1.0))*dK[ix][n-1][l+1] - dK[ix][n-1][l];
               }
           }
       
           return retval;
       }   
   
       // Get an upper bound for M_l(z)
       double BesselFunction::upper_bound(const double z, const int L) const {
           // find nearest point (on left) in tabulated values
           int ix = std::floor(N*z/16.0);
           int minix = L > 0 ? 1 : 0;
           ix = std::min(N, std::max(minix, ix));
           int lx = std::min(L, lMax);
           return K[ix][lx];
       }
   
       // Calculate modified spherical Bessel function K_l(z), weighted with an exponential factor e^(-z)
       // for l = 0 to lMax. This restricts K(z) to the interval [0,1].
       void BesselFunction::calculate(const double z, int maxL, std::vector<double> &values) const {
           if (lMax < maxL) {
               std::cout << "Asked for " << maxL << " but only initialised to maximum L = " << lMax << "\n";
               maxL = lMax;
           }
       
           // Set K_0(z) = 1.0, and K_l(z) = 0.0 (for l != 0) if z <= 0
           if (z <= 0) values[0] = 1.0;
           // Zeroth order case
           // K_l(z) ~ (1-z)*z^l / (2l + 1)!!
           else if (z < SMALL) { 
               values[0] = 1.0 - z;
               for (int l = 1; l <= maxL; l++) values[l] = values[l-1]*z/(2.0*l+1.0);
           } 
           // Large z case
           // K_l(z) ~ R_l(-z)/(2z)
           // where R_l(z) = sum_{k=0 to l} T_l,k(z)
           // where T_l,k(z) = (l+k)!/[k!(l-k)!] * (2z)^{-k}
           else if (z > 16.0) {
               values[0] = 0.5/z;
               for (int l = 1; l <= maxL; l++) {
                   values[l] = values[0];
                   double Rl = 1.0;
                   double Tlk = 1.0;
                   double cof = 1.0;
                   for (int k = 1; k <= l; k++) {
                       cof = (l-k+1)*(l+k)/((double)k);
                       Tlk *= - cof * values[0];
                       Rl += Tlk;
                   }
                   values[l] *= Rl;
               }
           } 
           // SMALL < z < 16 
           // Use Taylor series around pretabulated values in class
           // 5 terms is usually sufficient for machine accuracy
           else {
               // Index of abscissa z in table
               int ix = std::floor(z * scale + 0.5);
               double dz = z - ix/scale; // z - z0
           
               if (fabs(dz) < 1e-12) { // z is one of the tabulated points
                   for (int l = 0; l <= maxL; l++) values[l] = K[ix][l];
               } else {
           
                   // Calculate (dz)^n/n! terms just once
                   double dzn[TAYLOR_CUT+1];
                   dzn[0] = 1.0;
                   for (int n = 1; n < TAYLOR_CUT + 1; n++)
                       dzn[n] = dzn[n-1] * dz / ((double) n);
           
                   // Now tabulate the values through Taylor seris
                   // K(z) ~ sum_{n=0 to 5} K^(n)(z0)(z-z0)^n / n!
                   for (int l = 0; l <= maxL; l++) {
                       values[l] = 0.0;
                       for (int n = 0; n < TAYLOR_CUT+1; n++)
                           values[l] += dzn[n] * dK[ix][n][l]; 
                   }
               }
           }
       }
       
       // Calculate a modified spherical bessel function value at a point for only a single L
       // method the same as in calculate for multiple L, but with efficiencies
       double BesselFunction::calculate(const double z, const int L) const {
           double value = 0.0;
           
           if (z <= 0) value = 1.0;
           else if (z < SMALL) {
               value = 1.0 - z;
               for (int k = 1; k < L+1; k++)
                   value *= z/(2.0*L+1.0);
           } else if (z > 16.0) {
               double v0 = 0.5/z;
               value = 1.0;
               double Tlk = 1.0;
               for (int k = 1; k < L+1; k++) {
                   Tlk *= -v0 * (L - k +1)*(L+k)/(double(k));
                   value += Tlk;
               }
               value = v0 * value;
           } else {
               int ix = std::floor(z * scale + 0.5);
               double dz = z - ix/scale; // z - z0
               double dzn = 1.0;
               for (int n = 0; n < TAYLOR_CUT+1; n++) {
                   value += dzn * dK[ix][n][L]; 
                   dzn *= dz / (n+1);
               }
           }
           
           return value;
       }
   }
.. _exhale_struct_structlibecpint_1_1aux_1_1gen__seq_3_010_00_01_is_8_8_8_01_4:

Template Struct gen_seq< 0, Is... >
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Inheritance Relationships
-------------------------

Base Type
*********

- ``public libecpint::aux::seq< Is... >`` (:ref:`exhale_struct_structlibecpint_1_1aux_1_1seq`)


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::aux::gen_seq< 0, Is... >
   :members:
   :protected-members:
   :undoc-members:
.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp:

File ecpint.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/ecpint.hpp``)
----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`)

- ``array``

- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`)

- ``config.hpp``

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`)

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_e_c_p_integral`


Defines
-------


- :ref:`exhale_define_ecpint_8hpp_1a8546f51f524d0baff0bf3f3b321fbc9b`

.. _exhale_function_namespacelibecpint_1_1qgen_1a483926fa6186bbe5c39fdc797ea816b2:

Function libecpint::qgen::Q1_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a61a0d2a085bc8553dd2c9bffc8ad5abf:

Function libecpint::qgen::Q0_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a61d1d1633673052f4bdf09074343672c:

Function libecpint::pow_3
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_3(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a581417956b752bd71c1a66450c2c13a7:

Function libecpint::qgen::Q1_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1d4e032617fe380182fe6046722aff4a:

Function libecpint::qgen::Q2_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a0c072abf561409c52e122563986c170b:

Function libecpint::qgen::Q4_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp:

File ecp.hpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/ecp.hpp``)
-------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp.rst





Includes
--------


- ``array``

- ``config.hpp``

- ``map``

- ``string``

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_e_c_p`

- :ref:`exhale_struct_classlibecpint_1_1_e_c_p_basis`

- :ref:`exhale_struct_structlibecpint_1_1_gaussian_e_c_p`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a076d4d1e17ab2a37661480ba095329d7`

.. _exhale_function_namespacelibecpint_1_1qgen_1a0d0c8cc09c76e3efd8f1cf130bd7264d:

Function libecpint::qgen::Q0_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a785079edd6208c7b4f42d9bbed24b8a6:

Function libecpint::qgen::Q4_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespaceunrol__radial_1a7e0a7548eed4ebb942e94e7b9405f123:

Variable unrol_radial::MAX_UNROL_AM
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Variable Documentation
----------------------


.. doxygenvariable:: unrol_radial::MAX_UNROL_AM
.. _exhale_function_namespacelibecpint_1a17491fad5ad55b86c80bccd068067373:

Function libecpint::pow_11
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_11(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1e41f79e7d2cae760fbb9efe656d79a6:

Function libecpint::qgen::Q2_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab42100cc0c65d9f9cd2e667cc81bc808:

Function libecpint::qgen::Q0_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a2c6257f0f39de7233558e384908f1526:

Template Function libecpint::check_file
=======================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::check_file(std::string, std::vector<T>&, double, double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a0c98c29930ffdb324f6df35cc1f9544c:

Function libecpint::qgen::Q3_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2c596f5f83378630677beef4ae8f43cf:

Function libecpint::qgen::Q2_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a09ff49cc3eeef8f281974772d5dffc0f:

Function libecpint::qgen::Q0_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp:

Program Listing for File bessel.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/bessel.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef BESSEL_FUNCTION_HEAD
   #define BESSEL_FUNCTION_HEAD
   
   #include <vector>
   
   namespace libecpint {
   
       constexpr double SMALL = 1.0E-7; 
       constexpr int TAYLOR_CUT = 5; 
   
       class BesselFunction 
       {
       private:
           int lMax; 
           int N; 
           int order; 
           double scale; 
       
           double **K; 
           double ***dK; 
           double *C; 
       
           int tabulate(double accuracy);
       
       public:
           BesselFunction();
           
           BesselFunction(int lMax, int N, int order, double accuracy);
           
           ~BesselFunction();
       
           void init(int lMax, int N, int order, double accuracy);
       
           void calculate(double z, int maxL, std::vector<double> &values) const;
           
           double calculate(double z, int L) const;
           
           double upper_bound(double z, int L) const;
       };
   
   }
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1ab5c03c9c7a30f526f0ea06560fef3724:

Function libecpint::qgen::Q2_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a9e2847158ffcacd0a6fc12a455e63309:

Function libecpint::qgen::Q3_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a141f8229acaf6ffcc69bbf5f25fde085:

Function libecpint::qgen::Q1_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_makelist.py:

Program Listing for File makelist.py
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_makelist.py>` (``/Users/robertshaw/devfiles/libecpint_new/src/makelist.py``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: py

   import sys
   max_am = int(sys.argv[1])
   prefix = str(sys.argv[2])
   
   file = open(prefix + "/qlist.txt", "w")
   file.write(prefix + "/generated/ecpint_gen.cpp\n")
   for j in range(max_am+1):
       for i in range(j+1):
           for k in range(max_am+1):
               if j == i == k == max_am:
                   file.write(prefix + "/generated/Q" + str(i) + str(j) + str(k) + ".cpp") 
               else:
                   file.write(prefix + "/generated/Q" + str(i) + str(j) + str(k) + ".cpp\n")
   file.close()
.. _exhale_function_namespacelibecpint_1aa2a7bd43b3c7267b69a5a3faa3adf313:

Function libecpint::pow_20
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_20(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1acc501264ac82792276fdb06aa2e68d28:

Function libecpint::qgen::Q0_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a1d3c6308d05c89cb1f49ca5049ab3fd1:

Function libecpint::generate_lists
==================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::generate_lists(int, int, int, AngularIntegral&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a70ec2d64c8c090e8a736825df8ac69d2:

Function libecpint::qgen::Q0_1_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _namespace_unrol_radial:

Namespace unrol_radial
======================


.. contents:: Contents
   :local:
   :backlinks: none





Classes
-------


- :ref:`exhale_class_classunrol__radial_1_1_qijk`


Functions
---------


- :ref:`exhale_function_namespaceunrol__radial_1a48a1059eae24c36cd6464073577d147a`

- :ref:`exhale_function_namespaceunrol__radial_1a2cd46d9b308d3d493fdd7a516019c717`

- :ref:`exhale_function_namespaceunrol__radial_1aff823186ee3dc7e823e3f1a858233df6`

- :ref:`exhale_function_namespaceunrol__radial_1afc2f4f223df08979b137c507be4bbd37`


Variables
---------


- :ref:`exhale_variable_namespaceunrol__radial_1a582dde0241adf8b3a95b4459b4d49b2b`

- :ref:`exhale_variable_namespaceunrol__radial_1a02363db1e3121f4cb64855282f206fff`

- :ref:`exhale_variable_namespaceunrol__radial_1a7e0a7548eed4ebb942e94e7b9405f123`

- :ref:`exhale_variable_namespaceunrol__radial_1a032ec358895dd239986cf46342a0de86`
.. _exhale_function_namespacelibecpint_1_1qgen_1a21be6a1d89b69da23eb7b760e4beabd3:

Function libecpint::qgen::Q2_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_struct_structlibecpint_1_1_e_c_p_integrator:

Struct ECPIntegrator
====================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::ECPIntegrator
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1ae06aaa3298e7e07f2a3ac58799292f5a:

Function libecpint::qgen::Q0_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af27c1bf759fb1fcdd066d4631339342f:

Function libecpint::qgen::Q0_1_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5b65c0e188633d68627478d6dd43a613:

Function libecpint::qgen::Q1_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a691287591ae556167f12eef21d9605d3:

Function libecpint::pow_6
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_6(const double)
.. _exhale_function_namespacelibecpint_1abda78a2e83d967ee3da8b2fa7bff6ad0:

Function libecpint::pow_4
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_4(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a700b1c6b4c5327e2f395e38c0cac99ba:

Function libecpint::qgen::Q1_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a382cf81c48b6fae7aeba3be5ae6e457b:

Function libecpint::qgen::Q1_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp:

Program Listing for File radial_gen.cpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_radial_gen.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial/radial_gen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file was generated as a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       void RadialIntegral::compute_base_integrals(int N_min, int N_max, double p, double o_root_p, double P1,
       double P2, double P1_2, double P2_2, double X1, double X2,
       double oP1, double oP2, double* values) {
       
           // Recursively construct the base integrals in order F2, G3, F4, G5, etc... as described in Shaw2017
           
           int imax = N_max / 2;
           int imin = (N_min + 1) / 2;
           int gmax = (N_max - 1) / 2;
           int gmin = N_min / 2;
       
           double P1_2k = 1.0;
           double P2_2k = 1.0; 
       
           for (int k = 2; k < imin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           double ck, dk, ek, val; 
           double C0 = o_root_p * ROOT_PI;
           for (int n = imin; n <= imax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);   
           
               for (int k = n - 1; k > 1; k--) {
                   ck *= 2*k*(2*k - 1)*(n-k-0.5) / ((2*n - 2*k) * (2*n - 2*k - 1) * p);
                   dk *= oP1;
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               if (n > 1) {
                   ck *= 2*(n-1.5) / ((2*n - 2) * (2*n - 3) * p);
                   val += ck * (X1 - X2); 
               }
           
               values[2*n - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           P1_2k = P1;
           P2_2k = P2;
           for (int k = 1; k < gmin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           } 
       
       
           for (int n = gmin; n <= gmax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);
           
               for (int k = n-1; k >0; k--) {
                   ck *= 2*k*(2*k+1)*(n-k-0.5) / ((2*n-2*k) * (2*n - 1 - 2*k) * p);
                   dk *= oP1; 
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               values[2*n + 1 - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2; 
           } 
       
       }
   
       std::pair<double, bool> RadialIntegral::integrate_small(int N, int l1, int l2, double n, double a, double b, double A, double B) {
           int gridSize = smallGrid.getN();
           std::vector<double> &gridPoints = smallGrid.getX();
       
           double Ftab[gridSize]; 
           std::vector<double> besselValues1, besselValues2; 
       
           double z, zA, zB;
           double aA = 2.0 * a * A;
           double bB = 2.0 * b * B;
           for (int i = 0; i < gridSize; i++) {
               z = gridPoints[i];
               zA = z - A; 
               zB = z - B; 
               
               // TODO: Efficiencies could be found here by calculating Bessel function for only l1/l2, not all l up to l1/l2
               bessie.calculate(aA * z, l1, besselValues1);
               bessie.calculate(bB * z, l2, besselValues2);  
               
               Ftab[i] = pow(z, N) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValues1[l1] * besselValues2[l2];
           }
       
           std::function<double(double, double*, int)> intgd = RadialIntegral::integrand;
           
           // There should be no instances where this fails, so no backup plan to large grid, but return check just in case 
           bool success = smallGrid.integrate(intgd, Ftab, 1e-12); 
           std::pair<double, bool> rval = {smallGrid.getI(), success};  
           return rval; 
       }
       
       void RadialIntegral::type2(std::vector<Triple>& triples, int nbase, int lam, ECP &U, GaussianShell &shellA, GaussianShell &shellB,
       double A, double B, ThreeIndex<double> &radials)
       {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
           
           // Loop over primitives in ECP, only considering correct ang. momentum
           for(const auto& u : U.gaussians) { 
               if (u.l == lam) {
                   
                   // Loop over primitives in orbital basis shellß
                   for(int na = 0; na < npA; na++) {
                       double a = shellA.exp(na);
                       double da = shellA.coef(na); 
               
                       for (int nb = 0; nb < npB; nb++) {
                           double b = shellB.exp(nb);
                           double db = shellB.coef(nb); 
                           
                           // Construct values that will be reused across all radial integrals
                           double p = u.a + a + b;
                           double x = a * A;
                           double y = b * B;
       
                           double P1 = (x + y) / p;
                           double P2 = (y - x) / p;
                           double P1_2 = P1 * P1;
                           double P2_2 = P2 * P2;
                           double oP1 = 1.0 / P1_2;
                           double oP2 = std::abs(P2) < 1e-7 ? 0.0 : 1.0 / P2_2;
                           double root_p = sqrt(p);
                           double o_root_p = 1.0 / root_p; 
                           double aAbB = a*A*A + b*B*B;
                           double Kab = 1.0 / (16.0 * x * y); 
                           double X1 = exp(p * P1_2 - aAbB) * Kab;
                           double X2 = exp(p * P2_2 - aAbB) * Kab;
       
                           double x2 = x * x;
                           double y2 = y * y; 
                           double p2 = p * p; 
       
                           double result = 0.0;
                           
                           // G1A, G1B may not be required, but it seems to be quicker to calculate than to check if needed
                           double daw1 = X1 * Faddeeva::Dawson(root_p * P1);
                           double daw2 = X2 * Faddeeva::Dawson(root_p * P2);   
                           double G1B = 2.0 * ROOT_PI * (daw1 - daw2);
                           double G1A = 2.0 * ROOT_PI * (daw1 + daw2);
                           double H2 =  ROOT_PI * ( X1 + X2 ) * o_root_p; 
   
                           // Compute base integrals
                           double *values = new double[nbase+2]; 
                           compute_base_integrals(2, 3+nbase, p, o_root_p, P1, P2, P1_2, P2_2, X1, X2, oP1, oP2, values); 
                           
                           // Loop over all radial integrals required, divert to generated code
                           for (const Triple& triple : triples ) {
                               int i = std::get<1>(triple);
                               int j = std::get<2>(triple);
                               int k = std::get<0>(triple) + u.n + 2; 
                               
                               int ijk = i*10000 + j*100 + k; 
                               double result = 0.0;
                               if (a > 0.1 && b > 0.1) { 
                                   switch(ijk) {
                                       case 2 : {
                                           result = ( 1 ) * values[0];
                                           break;
                                       }
   
                                       case 4 : {
                                           result += ( 1 ) * values[ 2 ];
                                           break;
                                       }
   
                                       case 6 : {
                                           result += ( 1 ) * values[ 4 ];
                                           break;
                                       }
   
                                       case 8 : {
                                           result += ( 1 ) * values[ 6 ];
                                           break;
                                       }
   
                                       case 10 : {
                                           result += ( 1 ) * values[ 8 ];
                                           break;
                                       }
   
                                       case 12 : {
                                           result += ( 1 ) * values[ 10 ];
                                           break;
                                       }
   
                                       case 101 : {
                                           result = ( p/y ) * values[0];
                                           result += ( -x/y ) * G1A;
                                           break;
                                       }
   
                                       case 103 : {
                                           result = ( -1/(2*y) ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 105 : {
                                           result += ( -1/(2*y) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 107 : {
                                           result += ( -1/(2*y) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 109 : {
                                           result += ( -1/(2*y) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 111 : {
                                           result += ( -1/(2*y) ) * values[ 8 ];
                                           result += ( 1 ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 10102 : {
                                           result = ( -(p/2 + y2)/(x*y) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10104 : {
                                           result = ( 1/(2*x*y) ) * values[0];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 2 ];
                                           result += ( -1/x ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10106 : {
                                           result += ( 1/(x*y) ) * values[ 2 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -2/x ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10108 : {
                                           result += ( 3/(2*x*y) ) * values[ 4 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -3/x ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10110 : {
                                           result += ( -1/(4*x*y) ) * values[ 6 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 8 ];
                                           result += ( 1/(2*x) ) * values[ 7 ];
                                           result += ( p/x ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 202 : {
                                           result = ( -3*p/(2*y2) + 1 ) * values[0];
                                           result += ( 3*x/(2*y2) ) * G1A;
                                           break;
                                       }
   
                                       case 204 : {
                                           result = ( 3/(4*y2) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -3/(2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 206 : {
                                           result += ( 3/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -3/(2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 208 : {
                                           result += ( 3/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -3/(2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 210 : {
                                           result += ( 3/(4*y2) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 8 ];
                                           result += ( -3/(2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10201 : {
                                           result = ( -p*(p + 2*x2)/(2*x*y2) ) * values[0];
                                           result += ( x2/y2 ) * G1A;
                                           result += ( p/y ) * H2;
                                           break;
                                       }
   
                                       case 10203 : {
                                           result = ( (3*p + 2*y2)/(4*x*y2) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10205 : {
                                           result = ( -3/(4*x*y2) ) * values[0];
                                           result += ( (3*p - 2*y2)/(4*x*y2) ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( 3/(2*x*y) ) * values[ 1 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10207 : {
                                           result += ( -3/(2*x*y2) ) * values[ 2 ];
                                           result += ( 3*(p - 2*y2)/(4*x*y2) ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 3/(x*y) ) * values[ 3 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10209 : {
                                           result += ( -9/(4*x*y2) ) * values[ 4 ];
                                           result += ( (3*p - 10*y2)/(4*x*y2) ) * values[ 6 ];
                                           result += ( p/x ) * values[ 8 ];
                                           result += ( 9/(2*x*y) ) * values[ 5 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20202 : {
                                           result = ( (3*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 20204 : {
                                           result = ( -(3*p/2 + y2)/(x2*y2) ) * values[0];
                                           result += ( (3*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( (3*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20206 : {
                                           result = ( 3/(2*x2*y2) ) * values[0];
                                           result += ( -3*p/(x2*y2) ) * values[ 2 ];
                                           result += ( (3*p2 + 4*y2*(-3*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( -3/(x2*y) ) * values[ 1 ];
                                           result += ( 2*(3*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20208 : {
                                           result += ( 9/(2*x2*y2) ) * values[ 2 ];
                                           result += ( 3*(-3*p + 2*y2)/(2*x2*y2) ) * values[ 4 ];
                                           result += ( (3*p2 + 4*y2*(-5*p + y2))/(4*x2*y2) ) * values[ 6 ];
                                           result += ( p2/x2 ) * values[ 8 ];
                                           result += ( -9/(x2*y) ) * values[ 3 ];
                                           result += ( 3*(3*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 301 : {
                                           result = ( p*(-5*p + 5*x2 + 2*y2)/(2*(y2*y)) ) * values[0];
                                           result += ( x*(15*p - 10*x2 + 6*y2)/(4*(y2*y)) ) * G1A;
                                           result += ( -5*p*x/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 303 : {
                                           result = ( 15*p/(4*(y2*y)) - 3/y ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           result += ( -15*x/(4*(y2*y)) ) * G1A;
                                           break;
                                       }
   
                                       case 305 : {
                                           result = ( -15/(8*(y2*y)) ) * values[0];
                                           result += ( -3/y ) * values[ 2 ];
                                           result += ( 15/(4*y2) ) * values[ 1 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 307 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 2 ];
                                           result += ( -3/y ) * values[ 4 ];
                                           result += ( 15/(4*y2) ) * values[ 3 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 309 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 4 ];
                                           result += ( -3/y ) * values[ 6 ];
                                           result += ( 15/(4*y2) ) * values[ 5 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10302 : {
                                           result = ( (5*p2 + 10*p*x2 - 2*p*y2 - 4*(y2*y2))/(4*x*(y2*y)) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           result += ( -5*x2/(2*(y2*y)) ) * G1A;
                                           result += ( -5*p/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 10304 : {
                                           result = ( -(15*p + 6*y2)/(8*x*(y2*y)) ) * values[0];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 2 ];
                                           result += ( 3*(5*p + 2*y2)/(4*x*y2) ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10306 : {
                                           result = ( 15/(8*x*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p + 6*y2)/(8*x*(y2*y)) ) * values[ 2 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -15/(4*x*y2) ) * values[ 1 ];
                                           result += ( (15*p + 2*y2)/(4*x*y2) ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10308 : {
                                           result += ( 15/(4*x*(y2*y)) ) * values[ 2 ];
                                           result += ( 3*(-5*p + 14*y2)/(8*x*(y2*y)) ) * values[ 4 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -15/(2*x*y2) ) * values[ 3 ];
                                           result += ( (15*p - 2*y2)/(4*x*y2) ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20301 : {
                                           result = ( p*(3*p2 + 2*p*x2 + 4*(x2*x2) + 4*x2*y2 - 4*(y2*y2))/(4*x2*(y2*y)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 1 ];
                                           result += ( -(x2*x)/(y2*y) ) * G1A;
                                           result += ( -p*(3*p + 2*x2 + 2*y2)/(2*x*y2) ) * H2;
                                           break;
                                       }
   
                                       case 20303 : {
                                           result = ( -(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[0];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 2 ];
                                           result += ( (15*p2 + 4*y2*(3*p + y2))/(4*x2*y2) ) * values[ 1 ];
                                           result += ( p2/x2 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20305 : {
                                           result = ( 3*(5*p + 2*y2)/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 4 ];
                                           result += ( -(15*p + 6*y2)/(2*x2*y2) ) * values[ 1 ];
                                           result += ( (15*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[ 3 ];
                                           result += ( p2/x2 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20307 : {
                                           result = ( -15/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(5*p - 2*y2)/(2*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*p2 + 84*p*y2 + 28*(y2*y2))/(8*x2*(y2*y)) ) * values[ 4 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 6 ];
                                           result += ( 15/(2*x2*y2) ) * values[ 1 ];
                                           result += ( -(15*p + 4*y2)/(x2*y2) ) * values[ 3 ];
                                           result += ( (15*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 5 ];
                                           result += ( p2/x2 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 30302 : {
                                           result = ( -(15*(p2*p) + 18*p2*y2 + 12*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 2 ];
                                           result += ( 3*p*(5*p2 + 6*p*y2 + 4*(y2*y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30304 : {
                                           result = ( 3*(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( (-15*(p2*p) + 54*p2*y2 + 4*(y2*y2)*(9*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 4 ];
                                           result += ( -(45*p2 + 12*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(p + 2*y2))/(4*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30306 : {
                                           result = ( -(45*p + 18*y2)/(4*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( 3*(15*p2 - 12*p*y2 - 4*(y2*y2))/(4*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*(p2*p) + 126*p2*y2 + 4*(y2*y2)*(21*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 4 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 6 ];
                                           result += ( 9*(5*p + 2*y2)/(2*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( -(45*p2 + 12*y2*(2*p + y2))/(2*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(-p + 2*y2))/(4*(x2*x)*y2) ) * values[ 5 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 402 : {
                                           result = ( (-5*p*(-7*p + 7*x2 + 4*y2)/4 + (y2*y2))/(y2*y2) ) * values[0];
                                           result += ( 5*x*(-21*p + 14*x2 - 6*y2)/(8*(y2*y2)) ) * G1A;
                                           result += ( 35*p*x/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 404 : {
                                           result = ( 15*(-7*p + 6*y2)/(8*(y2*y2)) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -5/y ) * values[ 1 ];
                                           result += ( 105*x/(8*(y2*y2)) ) * G1A;
                                           break;
                                       }
   
                                       case 406 : {
                                           result = ( 105/(16*(y2*y2)) ) * values[0];
                                           result += ( 45/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 1 ];
                                           result += ( -5/y ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 408 : {
                                           result += ( 105/(16*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 3 ];
                                           result += ( -5/y ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10401 : {
                                           result = ( -p*(-7*p2 - 28*p*x2 + 2*p*y2 + 14*(x2*x2) + 4*x2*y2)/(4*x*(y2*y2)) ) * values[0];
                                           result += ( x2*(-35*p + 14*x2 - 10*y2)/(4*(y2*y2)) ) * G1A;
                                           result += ( p*(-7*p + 7*x2 + 2*y2)/(2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10403 : {
                                           result = ( -(35*p2 + 70*p*x2 - 20*p*y2 - 32*(y2*y2))/(8*x*(y2*y2)) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 1 ];
                                           result += ( 35*x2/(4*(y2*y2)) ) * G1A;
                                           result += ( 35*p/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10405 : {
                                           result = ( 15*(7*p + 2*y2)/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 45*p/(4*x*y2) + 3/x ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( -(105*p + 30*y2)/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10407 : {
                                           result = ( -105/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 15*(7*p - 10*y2)/(16*x*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45*p/(4*x*y2) + 2/x ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 105/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( 5*(-21*p + 2*y2)/(8*x*(y2*y)) ) * values[ 3 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20402 : {
                                           result = ( -(21*(p2*p) + 14*p2*x2 - 6*p2*y2 + 28*p*(x2*x2) + 28*p*x2*y2 - 36*p*(y2*y2) - 8*(y2*y2*y2))/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( 7*(x2*x)/(2*(y2*y2)) ) * G1A;
                                           result += ( 7*p*(3*p + 2*x2 + 2*y2)/(4*x*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 20404 : {
                                           result = ( 3*(35*p2 + 20*p*y2 + 4*(y2*y2))/(16*x2*(y2*y2)) ) * values[0];
                                           result += ( (45*p2 + 4*y2*(6*p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( -(105*p2 + 60*p*y2 + 12*(y2*y2))/(8*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20406 : {
                                           result = ( -(105*p + 30*y2)/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( 3*(35*p2 - 100*p*y2 - 28*(y2*y2))/(16*x2*(y2*y2)) ) * values[ 2 ];
                                           result += ( (45*p2 + 4*y2*(4*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( 15*(7*p + 2*y2)/(4*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*p2 + 20*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 3 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30401 : {
                                           result = ( -p*(15*(p2*p) + 6*p2*x2 + 4*p*(x2*x2) + 24*p*x2*y2 - 36*p*(y2*y2) + 8*(x2*x2*x2) + 8*(x2*x2)*y2 + 8*x2*(y2*y2) - 16*(y2*y2*y2))/(8*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( (p2*p)/(x2*x) ) * values[ 2 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 1 ];
                                           result += ( (x2*x2)/(y2*y2) ) * G1A;
                                           result += ( p*(15*p2 + 6*p*x2 + 20*p*y2 + 4*(x2*x2) + 4*x2*y2 + 4*(y2*y2))/(4*x2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 30403 : {
                                           result = ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( 3*p*(15*p2 + 4*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 2 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 4 ];
                                           result += ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30405 : {
                                           result = ( -(315*p2 + 180*p*y2 + 36*(y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( -(-105*(p2*p) + 450*p2*y2 + 252*p*(y2*y2) + 40*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[ 2 ];
                                           result += ( 3*p*(15*p2 + 4*y2*(2*p + y2))/(4*(x2*x)*y2) ) * values[ 4 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 6 ];
                                           result += ( 9*(35*p2 + 20*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*(p2*p) + 30*p2*y2 + 4*(y2*y2)*(3*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 3 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 40402 : {
                                           result = ( (105*(p2*p2) + 120*(p2*p)*y2 + 72*p2*(y2*y2) + 32*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( 3*p2*(15*p2 + 8*y2*(2*p + y2))/(4*(x2*x2)*y2) ) * values[ 2 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 4 ];
                                           result += ( -p*(105*(p2*p) + 120*p2*y2 + 72*p*(y2*y2) + 32*(y2*y2*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 40404 : {
                                           result = ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(4*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( (105*(p2*p2) - 600*(p2*p)*y2 - 504*p2*(y2*y2) - 160*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[ 2 ];
                                           result += ( p2*(45*p2 + 32*p*y2 + 24*(y2*y2))/(4*(x2*x2)*y2) ) * values[ 4 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 6 ];
                                           result += ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(2*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( p*(-105*(p2*p) + 40*p2*y2 + (y2*y2)*(24*p - 32*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 3 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       default: {
                                           std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                           result = quadval.first; 
                                           if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                       }
                                   }
                               } else {
                                   std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                   result = quadval.first; 
                                   if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                               } 
                               
                               radials(k-2-u.n, i, j) += da * db * u.d * result;
                           }
                           
                           delete[] values; 
                       }
                   }
               }
           }
       }
   }
.. _exhale_function_namespacelibecpint_1af2fa15848e7d9cfe1e61fc579a94080d:

Function libecpint::realSphericalHarmonics
==========================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::realSphericalHarmonics(int, double, double)
.. _exhale_define_mathutil_8hpp_1ae71449b1cc6e6250b91f539153a7a0d3:

Define M_PI
===========

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Define Documentation
--------------------


.. doxygendefine:: M_PI

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp:

Program Listing for File ecp.cpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecp.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/ecp.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "ecp.hpp"
   
   #include <cmath>
   #include <iostream>
   #include <algorithm>
   #include "pugixml.hpp"
   #include "mathutil.hpp"
   
   namespace libecpint {
   
       // GaussianECP constructor and copy constructor
       GaussianECP::GaussianECP() : n(0), l(0), a(0), d(0) {}
       GaussianECP::GaussianECP(int _n, int _l, double _a, double _d) : n(_n-2), l(_l), a(_a), d(_d) {}
       GaussianECP::GaussianECP(const GaussianECP& other) : n(other.n), l(other.l), a(other.a), d(other.d) {}
   
   
       // class ECP
   
       ECP::ECP() : N(0), L(-1) {
           center_[0] = center_[1] = center_[2] = 0.0;     
           min_exp = 1000.0;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
                min_exp_l[i] = 1000.0;
                l_starts[i] = 0;
           }
           l_starts[LIBECPINT_MAX_L+1] = 0;
       }
       
       ECP::ECP(const double *_center) : N(0), L(-1) {
           center_[0] = _center[0];
           center_[1] = _center[1];
           center_[2] = _center[2];
           min_exp = 1000.0;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
                min_exp_l[i] = 1000.0;
                l_starts[i] = 0;
           }
           l_starts[LIBECPINT_MAX_L+1] = 0;
       }
   
       ECP::ECP(const ECP &other) {
           gaussians = other.gaussians;
           N = other.N;
           L = other.L;
           min_exp = other.min_exp;
           for (int i = 0; i < LIBECPINT_MAX_L + 1; i++) {
               min_exp_l[i] = other.min_exp_l[i];
               l_starts[i] = other.l_starts[i];
           }
           l_starts[LIBECPINT_MAX_L+1] = other.l_starts[LIBECPINT_MAX_L+1];
           center_ = other.center_;
       }
   
       void ECP::addPrimitive(int n, int l, double a, double d, bool needSort) {
           GaussianECP newEcp(n, l, a, d);
           gaussians.push_back(newEcp);
           N++;
           L = l > L ? l : L;
           min_exp = a < min_exp ? a : min_exp;
           min_exp_l[l] = a < min_exp_l[l] ? a : min_exp_l[l];
           for (int lx = l+1; lx < LIBECPINT_MAX_L + 2; lx++)
               l_starts[lx] += 1;
           if (needSort) sort();
       }
   
       void ECP::sort() {
           std::sort(gaussians.begin(), gaussians.end(),
           [&] (const GaussianECP& g1, const GaussianECP& g2) {return (g1.l < g2.l);});
       }
       
       bool ECP::noType1() const {
           bool zero = true;
           for (auto& g : gaussians)
               if (g.l == L && fabs(g.d) > 1e-12) zero = false; 
           return zero; 
       }
   
       // Evaluate U_l(r), assuming that gaussians sorted by angular momentum
       double ECP::evaluate(double r, int l) {
           double value = 0.0;
           double r2 = r*r;
           int p;
           for (int i = l_starts[l]; i < l_starts[l+1]; i++) {
               p = gaussians[i].n > -1 ? gaussians[i].n : MAX_POW - gaussians[i].n;
               value += FAST_POW[p](r) * gaussians[i].d * exp(-gaussians[i].a * r2);
           } 
           return value; 
       }
   
       void ECP::setPos(double x, double y, double z) {
           center_[0] = x; center_[1] = y; center_[2] = z;
       }
   
       ECPBasis::ECPBasis() : N(0), maxL(-1) {}
   
       void ECPBasis::addECP(ECP &U, int atom) {
           basis.push_back(U);
           atomList.push_back(atom);
           N++;
           maxL = U.getL() > maxL ? U.getL() : maxL;
       }
   
       ECP& ECPBasis::getECP(int i) { return basis[i]; }
   
       int ECPBasis::getECPCore(int q) {
           int core = 0;
           auto it = core_electrons.find(q);
           if (it != core_electrons.end()) core = it->second;
           return core;
       }
       
       void ECPBasis::addECP_from_file(int q, std::array<double, 3> coords, std::string filename) {
           ECP newECP;
           newECP.center_ = coords;
   
           std::string atom_name = q < 1 ? "X" : atom_names[q-1]; 
           pugi::xml_document doc;
           pugi::xml_parse_result result = doc.load_file(filename.c_str());
           pugi::xml_node atom_node = doc.child("root").child(atom_name.c_str()); 
           int maxl = std::stoi(atom_node.attribute("maxl").value());
           int ncore = std::stoi(atom_node.attribute("ncore").value()); 
           
           auto it = core_electrons.find(q);
           if (it == core_electrons.end())
               core_electrons[q] = ncore; 
       
           for (pugi::xml_node shell = atom_node.child("Shell"); shell; shell = shell.next_sibling("Shell")) {
   
               int l = std::stoi(shell.attribute("lval").value());
               
               for (pugi::xml_node nxc = shell.child("nxc"); nxc; nxc = nxc.next_sibling("nxc")) {
                   int n = std::stoi(nxc.attribute("n").value()); 
                   double x = std::stod(nxc.attribute("x").value()); 
                   double c = std::stod(nxc.attribute("c").value()); 
                   newECP.addPrimitive(n, l, x, c); 
               }
           }
           
           newECP.sort();
           addECP(newECP, 0);
       }
   }

.. _file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp:

File mathutil.cpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_src_lib>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/src/lib/mathutil.cpp``)
------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp.rst





Includes
--------


- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a4c0dd5f75d6fc9b5329c97195b0b5e6c`

- :ref:`exhale_function_namespacelibecpint_1a0d3d7448d52abd739d6d100afa6d4e8a`

- :ref:`exhale_function_namespacelibecpint_1a34d3b9ccb2d69e977f74ff88524cf856`

- :ref:`exhale_function_namespacelibecpint_1a1addfbe82d0601ae0f2392e952e58dda`

- :ref:`exhale_function_namespacelibecpint_1a8d415487a348138eae566f7b8ee4ce24`

- :ref:`exhale_function_namespacelibecpint_1aea1a1b36dedb45829a2cdb5ee133b6ca`

- :ref:`exhale_function_namespacelibecpint_1a38e7f34b9f4f6181178d70e2d1ebb7df`

- :ref:`exhale_function_namespacelibecpint_1afd6b073b13a5cc8ddb89a4d331dae638`

- :ref:`exhale_function_namespacelibecpint_1ad62d70ca1e4137214af96b66ba9e50f8`

- :ref:`exhale_function_namespacelibecpint_1aad2f9701f24b74e7db5f8d1098b48cf5`

- :ref:`exhale_function_namespacelibecpint_1a250f67b7a3f611c4b8acdd8d90e0bec6`

- :ref:`exhale_function_namespacelibecpint_1aa93c5edc1ed250d59cfb1687865c7af3`

- :ref:`exhale_function_namespacelibecpint_1a15cb24b7b0a3530c911ff0c782ef3378`

- :ref:`exhale_function_namespacelibecpint_1a02aadabb1b7fceb975aa42706bb2be8d`

- :ref:`exhale_function_namespacelibecpint_1a7b6040a6e46c20d2e23b692e0fbffdf7`

- :ref:`exhale_function_namespacelibecpint_1a5d0157ab6282709bcec5e37a841e8fbf`

- :ref:`exhale_function_namespacelibecpint_1a61d1d1633673052f4bdf09074343672c`

- :ref:`exhale_function_namespacelibecpint_1abda78a2e83d967ee3da8b2fa7bff6ad0`

- :ref:`exhale_function_namespacelibecpint_1a86323740854f95e4faa929dc192aea06`

- :ref:`exhale_function_namespacelibecpint_1a7ecd27cd3ddff36e2a2e0ebeffa3d303`

- :ref:`exhale_function_namespacelibecpint_1a5bd73223ef2829c4d4e8f1fb68b7bcbb`

- :ref:`exhale_function_namespacelibecpint_1a2419326594e0adba8c22660003cee2ce`

- :ref:`exhale_function_namespacelibecpint_1ac6cc42cb342d04a07173673b14e59b5c`

- :ref:`exhale_function_namespacelibecpint_1a36d15d50e1c9979ab73acf66f1019304`

- :ref:`exhale_function_namespacelibecpint_1a11466fdaf07952a659fe9ab5cd634743`

- :ref:`exhale_function_namespacelibecpint_1af2fa15848e7d9cfe1e61fc579a94080d`


Defines
-------


- :ref:`exhale_define_mathutil_8cpp_1a9450534f682d7a567d3872551afa2ec4`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a4ecb557cc8bf8d94cfa80855985007bf`

- :ref:`exhale_variable_namespacelibecpint_1a975e7b9e0f57709418adede308d80405`

.. _exhale_function_namespacelibecpint_1_1qgen_1a15199caa67de1996017f60b214ad3d14:

Function libecpint::qgen::Q0_1_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_1_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacelibecpint_1a37d6807785ad49c55bbe8b56deab2be8:

Variable libecpint::TWO_C_TOLERANCE
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::TWO_C_TOLERANCE
.. _exhale_function_namespacelibecpint_1afd6b073b13a5cc8ddb89a4d331dae638:

Function libecpint::pow_13
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_13(double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp:

Program Listing for File api.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint/api.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef API_HEAD
   #define API_HEAD
   
   #include <vector>
   #include <array>
   #include <string>
   #include <memory>
   #include "ecpint.hpp"
   #include "multiarr.hpp"
   
   namespace libecpint {
   
   #define H_START(i, j, N) (9*j + 3*(3*N-1)*i - (9*i*(i+1))/2 - 3)
       
       constexpr double TWO_C_TOLERANCE = 1E-12;
       
       struct ECPIntegrator {
           std::vector<GaussianShell> shells; 
           ECPBasis ecps; 
           std::shared_ptr<ECPIntegral> ecpint; 
           int maxLB; 
           int deriv; 
           int ncart; 
           int natoms; 
           double min_alpha; 
           
           bool ecp_is_set; 
           bool basis_is_set; 
           
           TwoIndex<double> integrals; 
           
           std::vector<TwoIndex<double>> first_derivs;
           
           std::vector<TwoIndex<double>> second_derivs; 
           
           ECPIntegrator() { ecp_is_set = basis_is_set = false; maxLB = ncart = 0; }
           
           void set_gaussian_basis(int nshells, const double* coords, const double* exponents, const double* coefs, const int* ams, const int* shell_lengths);
           
           void set_ecp_basis(int necps, const double* coords, const double* exponents, const double* coefs, const int* ams, const int* ns, const int* shell_lengths);
           
           void set_ecp_basis_from_library(int necps, const double* coords, const int* charges, const std::vector<std::string> & names, const std::string & share_dir);
           
           void update_gaussian_basis_coords(int nshells, const double* coords);
           
           void update_ecp_basis_coords(int necps, const double* coords);
           
           void init(int deriv_ = 0);
           
           void compute_integrals();
           
           void compute_first_derivs();
           
           void compute_second_derivs();
           
           std::shared_ptr<std::vector<double>> get_integrals() { return std::make_shared<std::vector<double>>(integrals.data); }
           
           std::vector<std::shared_ptr<std::vector<double>>> get_first_derivs() {
               std::vector<std::shared_ptr<std::vector<double>>> results;
               for (auto& v : first_derivs) results.push_back(std::make_shared<std::vector<double>>(v.data));
               return results;
           }
           
           std::vector<std::shared_ptr<std::vector<double>>> get_second_derivs() {
               std::vector<std::shared_ptr<std::vector<double>>> results;
               for (auto& v : second_derivs) results.push_back(std::make_shared<std::vector<double>>(v.data));
               return results;
           }
       };
       
       double shell_bound(int la, double alpha, double A2, double eta);
       
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a9634adfd5bb091641ec927cb13898103:

Function libecpint::qgen::Q1_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a379f0d0f5d764bf07e31a8e3e8156bce:

Function libecpint::qgen::Q0_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_makelist.py:

File makelist.py
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src>` (``/Users/robertshaw/devfiles/libecpint/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/makelist.py``)
---------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_makelist.py.rst










Namespaces
----------


- :ref:`namespace_makelist`


Variables
---------


- :ref:`exhale_variable_namespacemakelist_1a7a96fbd7cb2ac37090089795370aedb7`

- :ref:`exhale_variable_namespacemakelist_1a92f763e70ec614d7cc630b6b3afc201e`

- :ref:`exhale_variable_namespacemakelist_1ae1a361014e097535367c775cc83758fd`

.. _exhale_variable_namespacelibecpint_1a32d2ef087e028b702c316bd2875036ec:

Variable libecpint::ROOT_PI
===========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::ROOT_PI
.. _exhale_class_classlibecpint_1_1_g_c_quadrature:

Class GCQuadrature
==================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`


Class Documentation
-------------------


.. doxygenclass:: libecpint::GCQuadrature
   :members:
   :protected-members:
   :undoc-members:
.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp:

Program Listing for File radial_gen.cpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/radial_gen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file was generated as a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "radial.hpp"
   #include "mathutil.hpp"
   #include "Faddeeva.hpp"
   #include <iostream>
   
   namespace libecpint {
       
       void RadialIntegral::compute_base_integrals(
         const int N_min, const int N_max, const double p, const double o_root_p, const double P1,
         const double P2, const double P1_2, const double P2_2, const double X1, const double X2,
         const double oP1, const double oP2, double* values) const {
       
           // Recursively construct the base integrals in order F2, G3, F4, G5, etc... as described in Shaw2017
           
           int imax = N_max / 2;
           int imin = (N_min + 1) / 2;
           int gmax = (N_max - 1) / 2;
           int gmin = N_min / 2;
       
           double P1_2k = 1.0;
           double P2_2k = 1.0; 
       
           for (int k = 2; k < imin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           double ck, dk, ek, val; 
           double C0 = o_root_p * ROOT_PI;
           for (int n = imin; n <= imax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);   
           
               for (int k = n - 1; k > 1; k--) {
                   ck *= 2*k*(2*k - 1)*(n-k-0.5) / ((2*n - 2*k) * (2*n - 2*k - 1) * p);
                   dk *= oP1;
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               if (n > 1) {
                   ck *= 2*(n-1.5) / ((2*n - 2) * (2*n - 3) * p);
                   val += ck * (X1 - X2); 
               }
           
               values[2*n - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           }
       
           P1_2k = P1;
           P2_2k = P2;
           for (int k = 1; k < gmin; k++) {
               P1_2k *= P1_2;
               P2_2k *= P2_2;
           } 
       
       
           for (int n = gmin; n <= gmax; n++) {
               ck = C0; 
               dk = P1_2k * X1;
               ek = P2_2k * X2; 
               val = ck * (dk - ek);
           
               for (int k = n-1; k >0; k--) {
                   ck *= 2*k*(2*k+1)*(n-k-0.5) / ((2*n-2*k) * (2*n - 1 - 2*k) * p);
                   dk *= oP1; 
                   ek *= oP2; 
                   val += ck * (dk - ek);
               }
           
               values[2*n + 1 - N_min] = val;
           
               P1_2k *= P1_2;
               P2_2k *= P2_2; 
           } 
       
       }
   
       std::pair<double, bool> RadialIntegral::integrate_small(
         const int N, const int l1, const int l2, const double n,
         const double a, const double b, const double A, const double B) const {
           int gridSize = primGrid.getN();
           double zt = n+a+b;
           double pt = (a*A + b*B)/zt;
           auto transformedGrid = primGrid;
           transformedGrid.transformRMinMax(zt, pt);
           std::vector<double> &gridPoints = transformedGrid.getX();
       
           double Ftab[gridSize]; 
       
           double z, zA, zB, besselValue1, besselValue2;
           double aA = 2.0 * a * A;
           double bB = 2.0 * b * B;
           
           z = gridPoints[0];
           zA = z-A; zB = z-B;
           besselValue1 = bessie.calculate(aA * z, l1);
           besselValue2 = bessie.calculate(bB * z, l2);
           Ftab[0] = FAST_POW[N](z) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
           
           int i = 1;
           double TOL = tolerance; 
           bool not_in_tail = true;
           double delta=1.0;
           while (not_in_tail && i < gridSize) {
               z = gridPoints[i];
               zA = z - A; 
               zB = z - B; 
               
               besselValue1 = bessie.calculate(aA * z, l1);
               besselValue2 = bessie.calculate(bB * z, l2);        
               Ftab[i] = FAST_POW[N](z) * exp(-n * z * z - a * zA * zA - b * zB * zB) * besselValue1 * besselValue2;
   
               delta = Ftab[i] - Ftab[i-1];
               not_in_tail = (Ftab[i] > TOL) || (delta > 0);
               i++; 
           }
           
           for (int j = i; j < gridSize; j++)
               Ftab[j] = 0.0;
       
           std::function<double(double, const double*, int)> intgd = RadialIntegral::integrand;
           
           // There should be no instances where this fails, so no backup plan to large grid, but return check just in case 
           return transformedGrid.integrate(intgd, Ftab, 1e-12, 0, primGrid.getN() - 1);
       }
       
       void RadialIntegral::type2(
           const std::vector<Triple>& triples, const int nbase, const int lam,
           const ECP &U, const GaussianShell &shellA, const GaussianShell &shellB,
         const double A, const double B, ThreeIndex<double> &radials) const
       {
           int npA = shellA.nprimitive();
           int npB = shellB.nprimitive();
           
           // Loop over primitives in ECP, only considering correct ang. momentum
           for(const auto& u : U.gaussians) { 
               if (u.l == lam) {
                   
                   // Loop over primitives in orbital basis shellß
                   for(int na = 0; na < npA; na++) {
                       double a = shellA.exp(na);
                       double da = shellA.coef(na); 
               
                       for (int nb = 0; nb < npB; nb++) {
                           double b = shellB.exp(nb);
                           double db = shellB.coef(nb); 
                           
                           // Construct values that will be reused across all radial integrals
                           double p = u.a + a + b;
                           double x = a * A;
                           double y = b * B;
       
                           double P1 = (x + y) / p;
                           double P2 = (y - x) / p;
                           double P1_2 = P1 * P1;
                           double P2_2 = P2 * P2;
                           double oP1 = 1.0 / P1_2;
                           double oP2 = std::abs(P2) < 1e-7 ? 0.0 : 1.0 / P2_2;
                           double root_p = sqrt(p);
                           double o_root_p = 1.0 / root_p; 
                           double aAbB = a*A*A + b*B*B;
                           double Kab = 1.0 / (16.0 * x * y); 
                           double X1 = exp(p * P1_2 - aAbB) * Kab;
                           double X2 = exp(p * P2_2 - aAbB) * Kab;
       
                           double x2 = x * x;
                           double y2 = y * y; 
                           double p2 = p * p; 
       
                           double result = 0.0;
                           
                           // G1A, G1B may not be required, but it seems to be quicker to calculate than to check if needed
                           double daw1 = X1 * Faddeeva::Dawson(root_p * P1);
                           double daw2 = X2 * Faddeeva::Dawson(root_p * P2);   
                           double G1B = 2.0 * ROOT_PI * (daw1 - daw2);
                           double G1A = 2.0 * ROOT_PI * (daw1 + daw2);
                           double H2 =  ROOT_PI * ( X1 + X2 ) * o_root_p; 
   
                           // Compute base integrals
                           double *values = new double[nbase+2]; 
                           compute_base_integrals(2, 3+nbase, p, o_root_p, P1, P2, P1_2, P2_2, X1, X2, oP1, oP2, values); 
                           
                           // Loop over all radial integrals required, divert to generated code
                           for (const Triple& triple : triples ) {
                               int i = std::get<1>(triple);
                               int j = std::get<2>(triple);
                               int k = std::get<0>(triple) + u.n + 2; 
                               
                               int ijk = i*10000 + j*100 + k; 
                               double result = 0.0;
                               if (a * b > MIN_EXP) {// && b > MIN_EXP) { 
                                   switch(ijk) {
                                       case 2 : {
                                           result = ( 1 ) * values[0];
                                           break;
                                       }
   
                                       case 4 : {
                                           result += ( 1 ) * values[ 2 ];
                                           break;
                                       }
   
                                       case 6 : {
                                           result += ( 1 ) * values[ 4 ];
                                           break;
                                       }
   
                                       case 8 : {
                                           result += ( 1 ) * values[ 6 ];
                                           break;
                                       }
   
                                       case 10 : {
                                           result += ( 1 ) * values[ 8 ];
                                           break;
                                       }
   
                                       case 12 : {
                                           result += ( 1 ) * values[ 10 ];
                                           break;
                                       }
   
                                       case 101 : {
                                           result = ( p/y ) * values[0];
                                           result += ( -x/y ) * G1A;
                                           break;
                                       }
   
                                       case 103 : {
                                           result = ( -1/(2*y) ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 105 : {
                                           result += ( -1/(2*y) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 107 : {
                                           result += ( -1/(2*y) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 109 : {
                                           result += ( -1/(2*y) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 111 : {
                                           result += ( -1/(2*y) ) * values[ 8 ];
                                           result += ( 1 ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 10102 : {
                                           result = ( -(p/2 + y2)/(x*y) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10104 : {
                                           result = ( 1/(2*x*y) ) * values[0];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 2 ];
                                           result += ( -1/x ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10106 : {
                                           result += ( 1/(x*y) ) * values[ 2 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -2/x ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10108 : {
                                           result += ( 3/(2*x*y) ) * values[ 4 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -3/x ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10110 : {
                                           result += ( -1/(4*x*y) ) * values[ 6 ];
                                           result += ( -(p/2 + y2)/(x*y) ) * values[ 8 ];
                                           result += ( 1/(2*x) ) * values[ 7 ];
                                           result += ( p/x ) * values[ 9 ];
                                           break;
                                       }
   
                                       case 202 : {
                                           result = ( -3*p/(2*y2) + 1 ) * values[0];
                                           result += ( 3*x/(2*y2) ) * G1A;
                                           break;
                                       }
   
                                       case 204 : {
                                           result = ( 3/(4*y2) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -3/(2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 206 : {
                                           result += ( 3/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -3/(2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 208 : {
                                           result += ( 3/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -3/(2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 210 : {
                                           result += ( 3/(4*y2) ) * values[ 6 ];
                                           result += ( 1 ) * values[ 8 ];
                                           result += ( -3/(2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10201 : {
                                           result = ( -p*(p + 2*x2)/(2*x*y2) ) * values[0];
                                           result += ( x2/y2 ) * G1A;
                                           result += ( p/y ) * H2;
                                           break;
                                       }
   
                                       case 10203 : {
                                           result = ( (3*p + 2*y2)/(4*x*y2) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 10205 : {
                                           result = ( -3/(4*x*y2) ) * values[0];
                                           result += ( (3*p - 2*y2)/(4*x*y2) ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( 3/(2*x*y) ) * values[ 1 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10207 : {
                                           result += ( -3/(2*x*y2) ) * values[ 2 ];
                                           result += ( 3*(p - 2*y2)/(4*x*y2) ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 3/(x*y) ) * values[ 3 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10209 : {
                                           result += ( -9/(4*x*y2) ) * values[ 4 ];
                                           result += ( (3*p - 10*y2)/(4*x*y2) ) * values[ 6 ];
                                           result += ( p/x ) * values[ 8 ];
                                           result += ( 9/(2*x*y) ) * values[ 5 ];
                                           result += ( -(3*p/2 + y2)/(x*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20202 : {
                                           result = ( (3*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 1 ];
                                           break;
                                       }
   
                                       case 20204 : {
                                           result = ( -(3*p/2 + y2)/(x2*y2) ) * values[0];
                                           result += ( (3*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( (3*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20206 : {
                                           result = ( 3/(2*x2*y2) ) * values[0];
                                           result += ( -3*p/(x2*y2) ) * values[ 2 ];
                                           result += ( (3*p2 + 4*y2*(-3*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( -3/(x2*y) ) * values[ 1 ];
                                           result += ( 2*(3*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20208 : {
                                           result += ( 9/(2*x2*y2) ) * values[ 2 ];
                                           result += ( 3*(-3*p + 2*y2)/(2*x2*y2) ) * values[ 4 ];
                                           result += ( (3*p2 + 4*y2*(-5*p + y2))/(4*x2*y2) ) * values[ 6 ];
                                           result += ( p2/x2 ) * values[ 8 ];
                                           result += ( -9/(x2*y) ) * values[ 3 ];
                                           result += ( 3*(3*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           result += ( -p*(3*p + 4*y2)/(2*x2*y) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 301 : {
                                           result = ( p*(-5*p + 5*x2 + 2*y2)/(2*(y2*y)) ) * values[0];
                                           result += ( x*(15*p - 10*x2 + 6*y2)/(4*(y2*y)) ) * G1A;
                                           result += ( -5*p*x/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 303 : {
                                           result = ( 15*p/(4*(y2*y)) - 3/y ) * values[0];
                                           result += ( 1 ) * values[ 1 ];
                                           result += ( -15*x/(4*(y2*y)) ) * G1A;
                                           break;
                                       }
   
                                       case 305 : {
                                           result = ( -15/(8*(y2*y)) ) * values[0];
                                           result += ( -3/y ) * values[ 2 ];
                                           result += ( 15/(4*y2) ) * values[ 1 ];
                                           result += ( 1 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 307 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 2 ];
                                           result += ( -3/y ) * values[ 4 ];
                                           result += ( 15/(4*y2) ) * values[ 3 ];
                                           result += ( 1 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 309 : {
                                           result += ( -15/(8*(y2*y)) ) * values[ 4 ];
                                           result += ( -3/y ) * values[ 6 ];
                                           result += ( 15/(4*y2) ) * values[ 5 ];
                                           result += ( 1 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 10302 : {
                                           result = ( (5*p2 + 10*p*x2 - 2*p*y2 - 4*(y2*y2))/(4*x*(y2*y)) ) * values[0];
                                           result += ( p/x ) * values[ 1 ];
                                           result += ( -5*x2/(2*(y2*y)) ) * G1A;
                                           result += ( -5*p/(2*y2) ) * H2;
                                           break;
                                       }
   
                                       case 10304 : {
                                           result = ( -(15*p + 6*y2)/(8*x*(y2*y)) ) * values[0];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 2 ];
                                           result += ( 3*(5*p + 2*y2)/(4*x*y2) ) * values[ 1 ];
                                           result += ( p/x ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10306 : {
                                           result = ( 15/(8*x*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p + 6*y2)/(8*x*(y2*y)) ) * values[ 2 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 4 ];
                                           result += ( -15/(4*x*y2) ) * values[ 1 ];
                                           result += ( (15*p + 2*y2)/(4*x*y2) ) * values[ 3 ];
                                           result += ( p/x ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10308 : {
                                           result += ( 15/(4*x*(y2*y)) ) * values[ 2 ];
                                           result += ( 3*(-5*p + 14*y2)/(8*x*(y2*y)) ) * values[ 4 ];
                                           result += ( -(3*p + y2)/(x*y) ) * values[ 6 ];
                                           result += ( -15/(2*x*y2) ) * values[ 3 ];
                                           result += ( (15*p - 2*y2)/(4*x*y2) ) * values[ 5 ];
                                           result += ( p/x ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 20301 : {
                                           result = ( p*(3*p2 + 2*p*x2 + 4*(x2*x2) + 4*x2*y2 - 4*(y2*y2))/(4*x2*(y2*y)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 1 ];
                                           result += ( -(x2*x)/(y2*y) ) * G1A;
                                           result += ( -p*(3*p + 2*x2 + 2*y2)/(2*x*y2) ) * H2;
                                           break;
                                       }
   
                                       case 20303 : {
                                           result = ( -(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[0];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 2 ];
                                           result += ( (15*p2 + 4*y2*(3*p + y2))/(4*x2*y2) ) * values[ 1 ];
                                           result += ( p2/x2 ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20305 : {
                                           result = ( 3*(5*p + 2*y2)/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(-5*p2 + 12*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 4 ];
                                           result += ( -(15*p + 6*y2)/(2*x2*y2) ) * values[ 1 ];
                                           result += ( (15*p2 + 4*y2*(p + y2))/(4*x2*y2) ) * values[ 3 ];
                                           result += ( p2/x2 ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20307 : {
                                           result = ( -15/(4*x2*(y2*y)) ) * values[0];
                                           result += ( 3*(5*p - 2*y2)/(2*x2*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*p2 + 84*p*y2 + 28*(y2*y2))/(8*x2*(y2*y)) ) * values[ 4 ];
                                           result += ( -p*(3*p + 2*y2)/(x2*y) ) * values[ 6 ];
                                           result += ( 15/(2*x2*y2) ) * values[ 1 ];
                                           result += ( -(15*p + 4*y2)/(x2*y2) ) * values[ 3 ];
                                           result += ( (15*p2 + 4*y2*(-p + y2))/(4*x2*y2) ) * values[ 5 ];
                                           result += ( p2/x2 ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 30302 : {
                                           result = ( -(15*(p2*p) + 18*p2*y2 + 12*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 2 ];
                                           result += ( 3*p*(5*p2 + 6*p*y2 + 4*(y2*y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30304 : {
                                           result = ( 3*(15*p2 + 12*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( (-15*(p2*p) + 54*p2*y2 + 4*(y2*y2)*(9*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 4 ];
                                           result += ( -(45*p2 + 12*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(p + 2*y2))/(4*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30306 : {
                                           result = ( -(45*p + 18*y2)/(4*(x2*x)*(y2*y)) ) * values[0];
                                           result += ( 3*(15*p2 - 12*p*y2 - 4*(y2*y2))/(4*(x2*x)*(y2*y)) ) * values[ 2 ];
                                           result += ( (-15*(p2*p) + 126*p2*y2 + 4*(y2*y2)*(21*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 4 ];
                                           result += ( -3*p2*(p + y2)/((x2*x)*y) ) * values[ 6 ];
                                           result += ( 9*(5*p + 2*y2)/(2*(x2*x)*y2) ) * values[ 1 ];
                                           result += ( -(45*p2 + 12*y2*(2*p + y2))/(2*(x2*x)*y2) ) * values[ 3 ];
                                           result += ( 3*p*(5*p2 + 2*y2*(-p + 2*y2))/(4*(x2*x)*y2) ) * values[ 5 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 7 ];
                                           break;
                                       }
   
                                       case 402 : {
                                           result = ( (-5*p*(-7*p + 7*x2 + 4*y2)/4 + (y2*y2))/(y2*y2) ) * values[0];
                                           result += ( 5*x*(-21*p + 14*x2 - 6*y2)/(8*(y2*y2)) ) * G1A;
                                           result += ( 35*p*x/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 404 : {
                                           result = ( 15*(-7*p + 6*y2)/(8*(y2*y2)) ) * values[0];
                                           result += ( 1 ) * values[ 2 ];
                                           result += ( -5/y ) * values[ 1 ];
                                           result += ( 105*x/(8*(y2*y2)) ) * G1A;
                                           break;
                                       }
   
                                       case 406 : {
                                           result = ( 105/(16*(y2*y2)) ) * values[0];
                                           result += ( 45/(4*y2) ) * values[ 2 ];
                                           result += ( 1 ) * values[ 4 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 1 ];
                                           result += ( -5/y ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 408 : {
                                           result += ( 105/(16*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45/(4*y2) ) * values[ 4 ];
                                           result += ( 1 ) * values[ 6 ];
                                           result += ( -105/(8*(y2*y)) ) * values[ 3 ];
                                           result += ( -5/y ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 10401 : {
                                           result = ( -p*(-7*p2 - 28*p*x2 + 2*p*y2 + 14*(x2*x2) + 4*x2*y2)/(4*x*(y2*y2)) ) * values[0];
                                           result += ( x2*(-35*p + 14*x2 - 10*y2)/(4*(y2*y2)) ) * G1A;
                                           result += ( p*(-7*p + 7*x2 + 2*y2)/(2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10403 : {
                                           result = ( -(35*p2 + 70*p*x2 - 20*p*y2 - 32*(y2*y2))/(8*x*(y2*y2)) ) * values[0];
                                           result += ( p/x ) * values[ 2 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 1 ];
                                           result += ( 35*x2/(4*(y2*y2)) ) * G1A;
                                           result += ( 35*p/(4*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 10405 : {
                                           result = ( 15*(7*p + 2*y2)/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 45*p/(4*x*y2) + 3/x ) * values[ 2 ];
                                           result += ( p/x ) * values[ 4 ];
                                           result += ( -(105*p + 30*y2)/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 10407 : {
                                           result = ( -105/(16*x*(y2*y2)) ) * values[0];
                                           result += ( 15*(7*p - 10*y2)/(16*x*(y2*y2)) ) * values[ 2 ];
                                           result += ( 45*p/(4*x*y2) + 2/x ) * values[ 4 ];
                                           result += ( p/x ) * values[ 6 ];
                                           result += ( 105/(8*x*(y2*y)) ) * values[ 1 ];
                                           result += ( 5*(-21*p + 2*y2)/(8*x*(y2*y)) ) * values[ 3 ];
                                           result += ( -(5*p + y2)/(x*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 20402 : {
                                           result = ( -(21*(p2*p) + 14*p2*x2 - 6*p2*y2 + 28*p*(x2*x2) + 28*p*x2*y2 - 36*p*(y2*y2) - 8*(y2*y2*y2))/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( p2/x2 ) * values[ 2 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 1 ];
                                           result += ( 7*(x2*x)/(2*(y2*y2)) ) * G1A;
                                           result += ( 7*p*(3*p + 2*x2 + 2*y2)/(4*x*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 20404 : {
                                           result = ( 3*(35*p2 + 20*p*y2 + 4*(y2*y2))/(16*x2*(y2*y2)) ) * values[0];
                                           result += ( (45*p2 + 4*y2*(6*p + y2))/(4*x2*y2) ) * values[ 2 ];
                                           result += ( p2/x2 ) * values[ 4 ];
                                           result += ( -(105*p2 + 60*p*y2 + 12*(y2*y2))/(8*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 20406 : {
                                           result = ( -(105*p + 30*y2)/(8*x2*(y2*y2)) ) * values[0];
                                           result += ( 3*(35*p2 - 100*p*y2 - 28*(y2*y2))/(16*x2*(y2*y2)) ) * values[ 2 ];
                                           result += ( (45*p2 + 4*y2*(4*p + y2))/(4*x2*y2) ) * values[ 4 ];
                                           result += ( p2/x2 ) * values[ 6 ];
                                           result += ( 15*(7*p + 2*y2)/(4*x2*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*p2 + 20*p*y2 + 4*(y2*y2))/(8*x2*(y2*y)) ) * values[ 3 ];
                                           result += ( -p*(5*p + 2*y2)/(x2*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 30401 : {
                                           result = ( -p*(15*(p2*p) + 6*p2*x2 + 4*p*(x2*x2) + 24*p*x2*y2 - 36*p*(y2*y2) + 8*(x2*x2*x2) + 8*(x2*x2)*y2 + 8*x2*(y2*y2) - 16*(y2*y2*y2))/(8*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( (p2*p)/(x2*x) ) * values[ 2 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 1 ];
                                           result += ( (x2*x2)/(y2*y2) ) * G1A;
                                           result += ( p*(15*p2 + 6*p*x2 + 20*p*y2 + 4*(x2*x2) + 4*x2*y2 + 4*(y2*y2))/(4*x2*(y2*y)) ) * H2;
                                           break;
                                       }
   
                                       case 30403 : {
                                           result = ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( 3*p*(15*p2 + 4*y2*(3*p + y2))/(4*(x2*x)*y2) ) * values[ 2 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 4 ];
                                           result += ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 30405 : {
                                           result = ( -(315*p2 + 180*p*y2 + 36*(y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[0];
                                           result += ( -(-105*(p2*p) + 450*p2*y2 + 252*p*(y2*y2) + 40*(y2*y2*y2))/(16*(x2*x)*(y2*y2)) ) * values[ 2 ];
                                           result += ( 3*p*(15*p2 + 4*y2*(2*p + y2))/(4*(x2*x)*y2) ) * values[ 4 ];
                                           result += ( (p2*p)/(x2*x) ) * values[ 6 ];
                                           result += ( 9*(35*p2 + 20*p*y2 + 4*(y2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 1 ];
                                           result += ( (-105*(p2*p) + 30*p2*y2 + 4*(y2*y2)*(3*p - 2*y2))/(8*(x2*x)*(y2*y)) ) * values[ 3 ];
                                           result += ( -p2*(5*p + 3*y2)/((x2*x)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       case 40402 : {
                                           result = ( (105*(p2*p2) + 120*(p2*p)*y2 + 72*p2*(y2*y2) + 32*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( 3*p2*(15*p2 + 8*y2*(2*p + y2))/(4*(x2*x2)*y2) ) * values[ 2 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 4 ];
                                           result += ( -p*(105*(p2*p) + 120*p2*y2 + 72*p*(y2*y2) + 32*(y2*y2*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 3 ];
                                           break;
                                       }
   
                                       case 40404 : {
                                           result = ( -(105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(4*(x2*x2)*(y2*y2)) ) * values[0];
                                           result += ( (105*(p2*p2) - 600*(p2*p)*y2 - 504*p2*(y2*y2) - 160*p*(y2*y2*y2) + 16*(y2*y2*y2*y2))/(16*(x2*x2)*(y2*y2)) ) * values[ 2 ];
                                           result += ( p2*(45*p2 + 32*p*y2 + 24*(y2*y2))/(4*(x2*x2)*y2) ) * values[ 4 ];
                                           result += ( (p2*p2)/(x2*x2) ) * values[ 6 ];
                                           result += ( (105*(p2*p) + 90*p2*y2 + 36*p*(y2*y2) + 8*(y2*y2*y2))/(2*(x2*x2)*(y2*y)) ) * values[ 1 ];
                                           result += ( p*(-105*(p2*p) + 40*p2*y2 + (y2*y2)*(24*p - 32*y2))/(8*(x2*x2)*(y2*y)) ) * values[ 3 ];
                                           result += ( -(p2*p)*(5*p + 4*y2)/((x2*x2)*y) ) * values[ 5 ];
                                           break;
                                       }
   
                                       default: {
                                           if (estimate_type2(k, i, j, u.a, a, b, A, B) > tolerance){ 
                                               std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                               result = quadval.first; 
                                               if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                           }
                                       }
                                   }
                               } else {
                                   if (estimate_type2(k, i, j, u.a, a, b, A, B) > tolerance){ 
                                       std::pair<double, bool> quadval = integrate_small(k, i, j, u.a, a, b, A, B);
                                       result = quadval.first; 
                                       if (!quadval.second) std::cout << "Quadrature failed" << std::endl; 
                                   }
                               } 
                               
                               radials(k-2-u.n, i, j) += da * db * u.d * result;
                           }
                           
                           delete[] values; 
                       }
                   }
               }
           }
       }
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a93d5d63f4cd6b286b87140d0c3cd84ae:

Function libecpint::qgen::Q3_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp:

Program Listing for File bessel.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/bessel.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef BESSEL_FUNCTION_HEAD
   #define BESSEL_FUNCTION_HEAD
   
   #include <vector>
   
   namespace libecpint {
   
       const double SMALL = 1.0E-7; 
       const int TAYLOR_CUT = 5; 
   
       class BesselFunction 
       {
       private:
           int lMax; 
           int N; 
           int order; 
           double scale; 
       
           double **K; 
           double ***dK; 
           double *C; 
       
           int tabulate(const double accuracy);
       
       public:
           BesselFunction();
           
           BesselFunction(int lMax, int N, int order, const double accuracy);
           
           ~BesselFunction();
       
           void init(int lMax, int N, int order, const double accuracy);
       
           void calculate(const double z, int maxL, std::vector<double> &values);
           
           double calculate(const double z, int L);
           
           double upper_bound(const double z, int L);
       };
   
   }
   #endif
.. _exhale_struct_classlibecpint_1_1_e_c_p_basis:

Struct ECPBasis
===============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::ECPBasis
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1af7a7b5fedc7e77a0a124d2d8d94caef1:

Function libecpint::qgen::Q1_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp:

Program Listing for File qgen.cpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/qgen.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *       This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #include "qgen.hpp"
   #include <cmath> 
   #include "mathutil.hpp"
   #include <iostream>
   
   namespace libecpint {
       namespace qgen {    
           void rolled_up(const int lam, const int LA, const int LB, const ThreeIndex<double> &radials, const FiveIndex<double> &CA, const FiveIndex<double> &CB, const TwoIndex<double> &SA, const TwoIndex<double> &SB, const AngularIntegral &angint, ThreeIndex<double> &values)
           {
               double prefac = 16.0 * M_PI * M_PI;
               int L = LA + LB;    
           
               int z1, z2, w_m, w_l, w_lm;
               int w_ax, w_ay, w_az, w_l1; 
               int w_bx, w_by, w_bz, w_l2; 
               double C, val;
         const int* mults = angint.getOmegaMults();
         const std::vector<double>& omega = angint.getOmegaData();
               int w_size = 2*lam+1; 
               double w1_contr[w_size*(lam+LA+1)];
               double w2_contr[w_size*(lam+LB+1)];
               
               int w_lam = lam * mults[3];
               // Loop over cartesian shell functions in alpha order, e.g. {xx xy, xz, yy, yz, zz} for l=2
               int na = 0; // Rows are shellA
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
               
                       int nb = 0; // Cols are shellB
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                       
                               // Begin full ECP integral expansion
                               for (int alpha_x = 0; alpha_x <= x1; alpha_x++) {
                                   w_ax = w_lam + alpha_x*mults[0];
                                   for (int alpha_y = 0; alpha_y <= r1; alpha_y++) {
                                       w_ay = w_ax + alpha_y*mults[1];
                                       for (int alpha_z = 0; alpha_z <= z1; alpha_z++) {
                                           w_az = w_ay + alpha_z*mults[2];
                                           int alpha = alpha_x + alpha_y + alpha_z; 
                                   
                                           for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                               w_bx = w_lam + beta_x*mults[0];
                                               for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                                   w_by = w_bx + beta_y*mults[1];
                                                   for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                                       w_bz = w_by + beta_z*mults[2]; 
                                                       int beta = beta_x + beta_y + beta_z; 
                                                       int N = alpha + beta; 
                                                       C = CA(0, na, alpha_x, alpha_y, alpha_z) * CB(0, nb, beta_x, beta_y, beta_z); 
                                                       
                                                       if (std::abs(C) > 1e-15) {
                                                           
                                                           for (int lam1 = 0; lam1 <= lam + alpha; lam1++) {
                                                               w_l = lam1*w_size+lam; 
                                                               w_l1 = w_az + lam1*(1+mults[5]);
                                                               w_m = w_l1-mults[4];
                                                               for (int mu = -lam; mu <= lam; mu++) {
                                                                   w_m += mults[4];
                                                                   w_lm = lam1*SA.dims[1];
                                                                   w1_contr[w_l+mu] = 0.0;
                                                                   for (int mu1 = -lam1; mu1 <= lam1; mu1++)
                                                                       w1_contr[w_l+mu] += SA.data[w_lm++] * omega[w_m+mu1];
                                                               }
                                                           }
                                           
                                                           for (int lam2 = 0; lam2 <= lam+beta; lam2++) {
                                                               w_l  = lam2*w_size+lam;
                                                               w_l2 = w_bz + lam2*(1+mults[5]);
                                                               w_m = w_l2-mults[4];
                                                               for (int mu = -lam; mu <= lam; mu++) {
                                                                   w_m += mults[4];
                                                                   w_lm = lam2*SB.dims[1];
                                                                   w2_contr[w_l+mu] = 0.0;
                                                                   for (int mu2 = -lam2; mu2 <= lam2; mu2++) 
                                                                       w2_contr[w_l+mu] += SB.data[w_lm++] * omega[w_m+mu2];
                                                               }
                                                           }
                                                               
                                                           for (int lam1=0; lam1 <= lam+alpha; lam1++) {
                                                               w_l1 = lam1*w_size+lam;
                                                               int lam2start = (lam1 + N) % 2; 
                                                               for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                                   w_l2 = lam2*w_size+lam;
   
                                                                   val = prefac * C * radials(N, lam1, lam2);
                                                                   for (int mu = -lam; mu <= lam; mu++) 
                                                                       values(na, nb, lam+mu) += val * w1_contr[w_l1+mu] * w2_contr[w_l2+mu];
   
                                                               }
                                                           }
                                                       }
                                               
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                       
                               nb++;
                           }
                       }
               
                       na++; 
                   }
               }
           }
     
           void rolled_up_special(const int lam, const int LA, const int LB, const ThreeIndex<double>& radials, const FiveIndex<double>& CB, const TwoIndex<double>& SB, const AngularIntegral& angint, ThreeIndex<double>& values) {
               double prefac = 8.0 * M_PI * std::sqrt(M_PI);
               int L = LA + LB;    
       
               int z1, z2; 
               double C, val1, val2; 
   
               int w_bx, w_by, w_bz, w_l2, w_m2, w1, w_m;
         const int* mults = angint.getOmegaMults();
         const std::vector<double>& omega = angint.getOmegaData();
               int w_lam = lam * mults[3];
               
               // Loop over cartesian shell functions in alpha order, e.g. {xx xy, xz, yy, yz, zz} for l=2
               int na = 0; // Rows are shellA
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
                       w1 = w_lam + x1*mults[0] + r1*mults[1] + z1*mults[2];
           
                       int nb = 0; // Cols are shellB
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                   
                               // Begin full ECP integral expansion
                               int alpha = x1 + r1 + z1; 
                               
                               for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                   w_bx = w_lam + beta_x*mults[0];
                                   for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                       w_by = w_bx + beta_y*mults[1];
                                       for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                           w_bz = w_by + beta_z*mults[2];
                                           int beta = beta_x + beta_y + beta_z; 
                                           int N = alpha + beta; 
                                           C = CB(0, nb, beta_x, beta_y, beta_z); 
                                               
                                           if (std::abs(C) > 1e-15) {
                                                       
                                               int lam2start =  N % 2; 
                                               for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                   w_l2 = w_bz + lam2*(1+mults[5]);
                                                   val1 = prefac * C * radials(N, 0, lam2);
                                                   
                                                           
                                                   for (int mu2 = -lam2; mu2 <= lam2; mu2++) {
                                                       w_m2 = w_l2 + mu2;
                                                       val2 = val1 *  SB(lam2, lam2+mu2);
                                                       w_m = -mults[4];                                                                        
                                                       for (int mu = -lam; mu <= lam; mu++) {
                                                           w_m += mults[4];
                                                           values(na, nb, lam+mu) += val2 * omega[w1+w_m] * omega[w_m2+w_m];
                                                       }
                                                   }
                                               }
                                           }
                                       }
                                   }               
                               }
                               nb++;
                           }
                       }
                       na++;
                   }
               }
           }
       }
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a2f1b593fe7a6e4e2810e6b989f0e5e0f:

Function libecpint::qgen::Q2_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5d4d33e9ee0c2a5d2c70296a32ad3eb8:

Function libecpint::qgen::Q4_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af5ae441ae60111ff2860513ccf26148c:

Function libecpint::qgen::Q4_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a4b956df3f1004dc6c367398fa3881724:

Function libecpint::qgen::Q3_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a08659d03f2d3c193a4a29ad64ed5b2ab:

Function libecpint::qgen::Q2_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab76bee96421fb775cd2fd16ff036664f:

Function libecpint::qgen::Q1_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a23265e6ef8db8355d123e8ef88049d01:

Function libecpint::qgen::Q1_2_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa4d41ca8cc3ec21577526011329df084:

Function libecpint::qgen::Q0_3_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_class_structlibecpint_1_1_shell_pair_data:

Class ShellPairData
===================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp`


Class Documentation
-------------------


.. doxygenclass:: libecpint::ShellPairData
   :members:
   :protected-members:
   :undoc-members:
.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp:

Program Listing for File api.cpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_api.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/api.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *       This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #include "api.hpp"
   #include <iostream>
   #include <cmath>
   #include <cassert>
   #include "mathutil.hpp"
   
   namespace libecpint {
       
       void ECPIntegrator::set_gaussian_basis (int nshells, double* coords, double* exponents, double* coefs, int* ams, int* shell_lengths) {
           int ctr = 0;
           min_alpha = 100.0;
           for (int i = 0; i < nshells; i++) {
               ncart += (ams[i]+1)*(ams[i]+2)/2;
               std::array<double, 3> cvec = {coords[3*i], coords[3*i+1], coords[3*i+2]};
               GaussianShell newShell(cvec, ams[i]);
               if (ams[i] > maxLB) maxLB = ams[i];
               for (int n = 0; n < shell_lengths[i]; n++) {
                   newShell.addPrim(exponents[ctr], coefs[ctr]);
                   ctr++;
               }
               min_alpha = newShell.min_exp < min_alpha ? newShell.min_exp : min_alpha;
               shells.push_back(newShell);
           } 
           basis_is_set = true;
       }
       
       void ECPIntegrator::set_ecp_basis(int necps, double* coords, double* exponents, double* coefs, int* ams, int* ns, int* shell_lengths) {
           int ctr = 0;
           for (int i = 0; i < necps; i++) {
               ECP newU(&coords[3*i]);
               for (int n = 0; n < shell_lengths[i]; n++) {
                   newU.addPrimitive(ns[ctr], ams[ctr], exponents[ctr], coefs[ctr]); 
                   ctr++;
               }
               newU.sort();
               ecps.addECP(newU, 0);
           }
           ecp_is_set = true;
       }
       
       void ECPIntegrator::set_ecp_basis_from_library(int necps, double* coords, int* charges, std::vector<std::string> names, std::string share_dir) {
           for (int i = 0; i < necps; i++) {
               std::array<double, 3> center = {coords[3*i], coords[3*i+1], coords[3*i+2]};
               int q = charges[i];
               std::string filename = share_dir + "/xml/" + names[i] + ".xml"; 
               ecps.addECP_from_file(q, center, filename);
           }
           ecp_is_set = true;
       }
       
       void ECPIntegrator::update_gaussian_basis_coords(int nshells, double* coords) {
           assert(nshells = shells.size());
           
           for (int i = 0; i < nshells; i++){
               shells[i].localCenter[0] = coords[3*i];
               shells[i].localCenter[1] = coords[3*i+1];
               shells[i].localCenter[2] = coords[3*i+2];
           }
       }
       
       void ECPIntegrator::update_ecp_basis_coords(int necps, double* coords) {
           assert(necps = ecps.getN());
           
           for (int i = 0; i < necps; i++) 
               ecps.getECP(i).setPos(coords[3*i], coords[3*i+1], coords[3*i+2]);
       }
       
       void ECPIntegrator::init(int deriv_) {
           assert(ecp_is_set);
           assert(basis_is_set);
           deriv = std::max(0, std::min(2, deriv_));
           ecpint = std::make_shared<ECPIntegral>(maxLB, ecps.getMaxL(), deriv);
           
           // Determine the internal atom ids
           natoms = 0;
           std::vector<std::array<double, 3>> centers;
           for (auto& s : shells) {
               int i = 0;
               bool found = false;
               while ( !found && (i < centers.size()) ) {
                   double diff = std::abs(centers[i][0] - s.centerVec[0]);
                   diff += std::abs(centers[i][1] - s.centerVec[1]);
                   diff += std::abs(centers[i][2] - s.centerVec[2]);
                   if (diff < 1e-4) {
                       s.atom_id = i;
                       found = true;
                   }
                   i++;
               }
               if (!found) {
                   s.atom_id = natoms;
                   natoms++;
                   centers.push_back({s.centerVec[0], s.centerVec[1], s.centerVec[2]});
               }
           }
           
           for (int n = 0; n < ecps.getN(); n++) {
               ECP& U = ecps.getECP(n);
               int i = 0;
               bool found = false;
               while ( !found && (i < centers.size()) ) {
                   double diff = std::abs(centers[i][0] - U.center_[0]);
                   diff += std::abs(centers[i][1] - U.center_[1]);
                   diff += std::abs(centers[i][2] - U.center_[2]);
                   if (diff < 1e-4) {
                       U.atom_id = i;
                       found = true;
                   }
                   i++;
               }
               if (!found) {
                   U.atom_id = natoms;
                   natoms++;
                   centers.push_back({U.center_[0], U.center_[1], U.center_[2]});
               }
           }
       }
       
       double shell_bound(int la, double alpha, double A2, double eta) {
           double sigma;
           if (A2 < 1e-6) {
               sigma = 0.5 * (1.0 + eta/alpha);
           } else {
               sigma = 1.0/(2.0*alpha*(eta*eta*A2 + la*(alpha + eta)));
               sigma = sigma * la * (alpha + eta) * (alpha + eta);
           }
           
           double atilde = (1.0 - sigma) * alpha;
           double Na = la / (2*M_EULER*alpha*sigma);
           Na = FAST_POW[la](std::sqrt(Na));
           double result = atilde * eta * A2 / (atilde + eta);
           result = std::exp(-result) * Na;
           return result;
       }
       
       void ECPIntegrator::compute_integrals() {
           // initialise all to zero
           integrals.assign(ncart, ncart, 0.0);
           
           // loop over shells
           TwoIndex<double> tempValues;
           int nshells = shells.size();
       
           double thresh = FAST_POW[maxLB+3]((maxLB+3.0)/min_alpha)*FAST_POW[3](M_PI/(2*maxLB+3.0));
           thresh /= FAST_POW[maxLB](2.0*M_EULER);
           thresh = TWO_C_TOLERANCE / std::sqrt(thresh);
           
           int n1 = 0;
           double acx, acy, acz, A2, sb;
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               std::vector<int> ns;
               
               for (int i = 0; i < ecps.getN(); i++) {
                   ECP& U = ecps.getECP(i);    
                   
                   acx = shellA.center()[0] - U.center_[0]; 
                   acy = shellA.center()[1] - U.center_[1];
                   acz = shellA.center()[2] - U.center_[2];
                   A2 = acx*acx + acy*acy + acz*acz;
                   sb = shell_bound(shellA.l, shellA.min_exp, A2, U.min_exp);
                   if (sb > thresh) ns.push_back(i);
               }
               
               if (ns.size() > 0) {
                   int n2 = 0;
                   for(auto s2=0; s2<=s1; ++s2) {
                       GaussianShell& shellB = shells[s2];
                       int ncartB = shellB.ncartesian();
               
                       TwoIndex<double> shellPairInts(ncartA, ncartB, 0.0);
                   
                       for (auto i : ns) {
                           ECP& U = ecps.getECP(i);
                           ecpint->compute_shell_pair(U, shellA, shellB, tempValues);
                           shellPairInts.add(tempValues);
                       }
   
                       for (int i = n1; i < n1 + ncartA; i++) {
                           for (int j = n2; j < n2 + ncartB; j++) {
                               integrals(i, j) = shellPairInts(i-n1, j-n2);
                               integrals(j, i) = integrals(i, j);
                           }
                       }
                  
                       n2 += ncartB;
                   }
               }
               n1 += ncartA;
           } 
           
           //std::cout << "Total: " << ecpint->skipped + ecpint->zero + ecpint->nonzero << std::endl;
           //std::cout << "Skipped: " << ecpint->skipped << std::endl;
           //std::cout << "Zero: " << ecpint->zero << std::endl;
           //std::cout << "Non-zero: " << ecpint->nonzero << std::endl;
           
       }
       
       void ECPIntegrator::compute_first_derivs() {
           assert(deriv > 0);
           
           for (int n = 0; n < 3*natoms; n++)
               first_derivs.push_back(TwoIndex<double>(ncart, ncart, 0.0));
           
           // loop over shells
           std::array<TwoIndex<double>, 9> tempValues;
           int nshells = shells.size();
           
           int n1 = 0;
           int Aix, Bix, Cix;
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               Aix = shellA.atom_id;
               
               int n2 = 0;
               for(auto s2=0; s2<=s1; ++s2) {
                   GaussianShell& shellB = shells[s2];
                   int ncartB = shellB.ncartesian();
                   Bix = shellB.atom_id;
                   
                   for (int i = 0; i < ecps.getN(); i++) {
                       ECP& U = ecps.getECP(i);
                       Cix = U.atom_id;
                       ecpint->compute_shell_pair_derivative(U, shellA, shellB, tempValues);
                       
                       // work out where to put them
                       for (int n = 0; n < 3; n++) {
                           for (int k = n1; k < n1 + ncartA; k++) {
                               for (int l = n2; l < n2 + ncartB; l++) {
                                   first_derivs[3*Aix+n](k, l) += tempValues[n](k-n1, l-n2);
                                   first_derivs[3*Bix+n](k, l) += tempValues[n+3](k-n1, l-n2);
                                   first_derivs[3*Cix+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                   
                                   if (s2 < s1) {
                                       first_derivs[3*Aix+n](l, k) = first_derivs[3*Aix+n](k, l);
                                       first_derivs[3*Bix+n](l, k) = first_derivs[3*Bix+n](k, l);
                                       first_derivs[3*Cix+n](l, k) = first_derivs[3*Cix+n](k, l);
                                   }
   
                               }
                           }
                       }       
                   }
               
                   n2 += ncartB;
               }
           
               n1 += ncartA; 
           }
       }
       
       void ECPIntegrator::compute_second_derivs() {
           assert(deriv > 1);
           
           int nhess = (3*natoms*(3*natoms+1))/2;
           for (int n = 0; n < nhess; n++)
               second_derivs.push_back(TwoIndex<double>(ncart, ncart, 0.0));
           
           // loop over shells
           std::array<TwoIndex<double>, 45> tempValues;
           int nshells = shells.size();
           
           int n1 = 0;
           int Aix, Bix, Cix;
           int saa, sab, sac, sbb, sbc, scc;
           int ixes[6] = {0, 1, 2, 4, 5, 8};
           int back_ixes[6] = {0, 3, 6, 4, 7, 8};
           int jxes[9] = {0, 3, 6, 1, 4, 7, 2, 5, 8};
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               Aix = shellA.atom_id;
               
               int n2 = 0;
               for(auto s2=0; s2<=s1; ++s2) {
                   GaussianShell& shellB = shells[s2];
                   int ncartB = shellB.ncartesian();
                   Bix = shellB.atom_id;
                   
                   saa = H_START(Aix, Aix, natoms) + 3;
                   sbb = H_START(Bix, Bix, natoms) + 3;
                   sab = H_START(std::min(Aix, Bix), std::max(Aix, Bix), natoms);
                   sab = Aix == Bix ? sab + 3 : sab;
                   
                   for (int i = 0; i < ecps.getN(); i++) {
                       ECP& U = ecps.getECP(i);
                       Cix = U.atom_id;
                       ecpint->compute_shell_pair_second_derivative(U, shellA, shellB, tempValues);
                   
                       // work out where to put them
                       scc = H_START(Cix, Cix, natoms) + 3;
                       sac = H_START(std::min(Aix, Cix), std::max(Aix, Cix), natoms);
                       sac = Aix == Cix ? sac + 3 : sac;
                       sbc = H_START(std::min(Bix, Cix), std::max(Bix, Cix), natoms);
                       sbc = Bix == Cix ? sbc + 3 : sbc;
                       
                       if ((Aix == Cix) || (Bix == Cix)) {
                           if (Bix != Aix) {
                               // two distinct atoms
                               // only need to worry about AA, AB, and BB blocks
                               for (int n = 0; n < 6; n++) {
                                   for (int k = n1; k < n1 + ncartA; k++) {
                                       for (int l = n2; l < n2 + ncartB; l++) {
                                           second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2);
                                           second_derivs[sbb+n](k, l) += tempValues[n+24](k-n1, l-n2);
                                   
                                           if (s1 != s2) {
                                               second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                               second_derivs[sbb+n](l, k) = second_derivs[sbb+n](k, l);
                                           }
                                       }
                                   }
                               }
                               
                               for (int n = 0; n < 9; n++) {
                                   for (int k = n1; k < n1 + ncartA; k++) {
                                       for (int l = n2; l < n2 + ncartB; l++) {
                                           if (Aix > Bix) {
                                               second_derivs[sab+n](k, l) += tempValues[jxes[n]+6](k-n1, l-n2);
                                               if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                           } else {
                                               second_derivs[sab+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                               if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                           }
                                       }
                                   }
                               }
                           } // else everything is zero
                       } else if (Aix == Bix) {
                           // two distinct atoms, need to worry about everything
                           for (int n = 0; n < 6; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2); // aa
                                       second_derivs[saa+n](k, l) += tempValues[n+24](k-n1, l-n2); // bb = aa
                                       second_derivs[scc+n](k, l) += tempValues[n+39](k-n1, l-n2); // cc
                                       second_derivs[saa+n](k, l) += tempValues[ixes[n]+6](k-n1, l-n2); // ab = aa
                                       second_derivs[saa+n](k, l) += tempValues[back_ixes[n]+6](k-n1, l-n2); // ba = aa
                                       
                                       if (s1 != s2) {
                                           second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                           second_derivs[scc+n](l, k) = second_derivs[scc+n](k, l);
                                       }
                                   }
                               }
                           }
                       
                           for (int n = 0; n < 9; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {                        
                                       if (Aix > Cix) {
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+15](k-n1, l-n2);
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+30](k-n1, l-n2); // bc = ac
                                           
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       } else {
                                           second_derivs[sac+n](k, l) += tempValues[n+15](k-n1, l-n2);
                                           second_derivs[sac+n](k, l) += tempValues[n+30](k-n1, l-n2); // bc = ac
                                           
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       }
                                   }
                               }
                           }
                       } else {
                           for (int n = 0; n < 6; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2);
                                       second_derivs[sbb+n](k, l) += tempValues[n+24](k-n1, l-n2);
                                       second_derivs[scc+n](k, l) += tempValues[n+39](k-n1, l-n2);
                                   
                                       if (s1 != s2) {
                                           second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                           second_derivs[sbb+n](l, k) = second_derivs[sbb+n](k, l);
                                           second_derivs[scc+n](l, k) = second_derivs[scc+n](k, l);
                                       }
                                   }
                               }
                           }
                       
                           for (int n = 0; n < 9; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       if (Aix > Bix) {
                                           second_derivs[sab+n](k, l) += tempValues[jxes[n]+6](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                       } else {
                                           second_derivs[sab+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                       }
                                   
                                       if (Aix > Cix) {
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+15](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       } else {
                                           second_derivs[sac+n](k, l) += tempValues[n+15](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       }
                                   
                                       if (Bix > Cix) {
                                           second_derivs[sbc+n](k, l) += tempValues[jxes[n]+30](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       } else {
                                           second_derivs[sbc+n](k, l) += tempValues[n+30](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       }
                                   }
                               }
                           }
                       }
                       
                   }
               
                   n2 += ncartB;
               }
           
               n1 += ncartA; 
           }
       }
   }
.. _exhale_function_namespacelibecpint_1a60980f8f3c0f2ce3bfa35d1ab1ffe612:

Function libecpint::pow_17
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_17(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a3cf2623a8ae1e20ff29a8bc1b11b9565:

Function libecpint::qgen::Q5_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

File Hierarchy
--------------


.. raw:: html

   <ul class="treeView" id="file-treeView">
     <li>
       <ul class="collapsibleList">
         <li>Directory <a href="dir__Users_robertshaw_devfiles_libecpint_include.html#dir-Users-robertshaw-devfiles-libecpint-include">include</a><ul><li>Directory <a href="dir__Users_robertshaw_devfiles_libecpint_include_libecpint.html#dir-Users-robertshaw-devfiles-libecpint-include-libecpint">libecpint</a><ul><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-angular.hpp">angular.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-api.hpp">api.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-bessel.hpp">bessel.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-ecp.hpp">ecp.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-ecpint.hpp">ecpint.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-gaussquad.hpp">gaussquad.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_gshell.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-gshell.hpp">gshell.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-mathutil.hpp">mathutil.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-multiarr.hpp">multiarr.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-qgen.hpp">qgen.hpp</a></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint-radial.hpp">radial.hpp</a></li></ul></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_generate.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-generate.hpp">generate.hpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_include_libecpint.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-libecpint.hpp">libecpint.hpp</a></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_include_testutil.hpp.html#file-Users-robertshaw-devfiles-libecpint-include-testutil.hpp">testutil.hpp</a></li></ul></li><li>Directory <a href="dir__Users_robertshaw_devfiles_libecpint_src.html#dir-Users-robertshaw-devfiles-libecpint-src">src</a><ul><li>Directory <a href="dir__Users_robertshaw_devfiles_libecpint_src_generated.html#dir-Users-robertshaw-devfiles-libecpint-src-generated">generated</a><ul><li class="lastChild">Directory <a href="dir__Users_robertshaw_devfiles_libecpint_src_generated_radial.html#dir-Users-robertshaw-devfiles-libecpint-src-generated-radial">radial</a><ul><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-generated-radial-radial-gen.cpp">radial_gen.cpp</a></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py.html#file-Users-robertshaw-devfiles-libecpint-src-generated-radial-unrol-radial.py">unrol_radial.py</a></li></ul></li></ul></li><li>Directory <a href="dir__Users_robertshaw_devfiles_libecpint_src_lib.html#dir-Users-robertshaw-devfiles-libecpint-src-lib">lib</a><ul><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-angular.cpp">angular.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-api.cpp">api.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-bessel.cpp">bessel.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_ecp.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-ecp.cpp">ecp.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_ecpint.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-ecpint.cpp">ecpint.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-gaussquad.cpp">gaussquad.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_gshell.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-gshell.cpp">gshell.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-mathutil.cpp">mathutil.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-qgen.cpp">qgen.cpp</a></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_radial_gen.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-radial-gen.cpp">radial_gen.cpp</a></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-lib-radial-quad.cpp">radial_quad.cpp</a></li></ul></li><li>File <a href="file__Users_robertshaw_devfiles_libecpint_src_generate.cpp.html#file-Users-robertshaw-devfiles-libecpint-src-generate.cpp">generate.cpp</a></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_src_makelist.py.html#file-Users-robertshaw-devfiles-libecpint-src-makelist.py">makelist.py</a></li></ul></li><li class="lastChild">File <a href="file__Users_robertshaw_devfiles_libecpint_README.md.html#file-Users-robertshaw-devfiles-libecpint-README.md">README.md</a></li>
       </ul>
     </li><!-- only tree view element -->
   </ul><!-- /treeView file-treeView -->

.. end raw html for treeView


.. _exhale_function_namespacelibecpint_1_1qgen_1a7e4b20f55e6c486cca3d72e08d159b97:

Function libecpint::qgen::Q3_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2752f2e9ae667bd4ce018630be1e9c13:

Function libecpint::qgen::Q3_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a29754bb55ad841e326de3c986f8e2848:

Function libecpint::qgen::Q1_1_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a7a397803096c0fa76aa8db724640a33e:

Function libecpint::qgen::Q3_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a804aaa1e22a0d6ad6da870c708054007:

Function libecpint::qgen::Q3_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp:

Program Listing for File mathutil.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/mathutil.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef MATHUTILHEADERDEF
   #define MATHUTILHEADERDEF
   
   #include <vector>
   #include <numeric>
   #include <cmath>
   #include "multiarr.hpp"
   
   #ifndef M_PI
   #define M_PI 3.14159265358979323846
   #endif
   
   #ifndef M_EULER
   #define M_EULER 2.71828182845904523536
   #endif
   
   #define MAX_FAC 100 
   #define MAX_DFAC 200 
   
   namespace libecpint {
       
       const double ROOT_PI = 1.772453850905516; 
       const double SINH_1 = 1.1752011936;
       const int MAX_POW = 20;
   
       extern double FAC[MAX_FAC];     
       extern double DFAC[MAX_DFAC];   
       
       double pow_m2(double);
       double pow_m1(double);
       double pow_0(double);
       double pow_1(double);
       double pow_2(double);
       double pow_3(double);
       double pow_4(double);
       double pow_5(double);
       double pow_6(double);
       double pow_7(double);
       double pow_8(double);
       double pow_9(double);
       double pow_10(double);
       double pow_11(double);
       double pow_12(double);
       double pow_13(double);
       double pow_14(double);
       double pow_15(double);
       double pow_16(double);
       double pow_17(double);
       double pow_18(double);
       double pow_19(double);
       double pow_20(double);
       
       static double (*FAST_POW[23])(double) {pow_0, pow_1, pow_2, pow_3, pow_4, pow_5,
                                         pow_6, pow_7, pow_8, pow_9, pow_10, pow_11,
                                         pow_12, pow_13, pow_14, pow_15, pow_16, pow_17,
                                         pow_18, pow_19, pow_20, pow_m1, pow_m2};
       
       
       const double GAMMA[30] = {
           1.7724538509055,
           1.0,
           0.88622692545275,
           1.0,
           1.3293403881791,
           2.0,
           3.3233509704478,
           6.0,
           11.631728396567,
           24.0,
           52.342777784553,
           120.0,
           287.88527781504,
           720.0,
           1871.2543057978,
           5040.0,
           14034.407293483,
           40320.0,
           1.1929246199461e5,
           3.62880e5,
           1.1332783889488e6,
           3.628800e6,
           1.1899423083962e7,
           3.9916800e7,
           1.3684336546556e8, 
           4.79001600e8, 
           1.7105420683196e9, 
           6.227020800e9, 
           2.3092317922314e10,
           8.7178291200e10
       };
       
       TwoIndex<double> realSphericalHarmonics(int lmax, double x, double phi);  
       
       double frobenius_norm(TwoIndex<double>& mat);
       
       void initFactorials(); 
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1ac9d76855b9f0e07c466603e836fc55cf:

Function libecpint::qgen::Q1_1_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_class_classlibecpint_1_1_angular_integral:

Class AngularIntegral
=====================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`


Class Documentation
-------------------


.. doxygenclass:: libecpint::AngularIntegral
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1aa3390aa653fcf192610379faf4cbadb8:

Function libecpint::qgen::Q5_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_class_classlibecpint_1_1_radial_integral:

Class RadialIntegral
====================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`


Nested Relationships
--------------------


Nested Types
************

- :ref:`exhale_struct_structlibecpint_1_1_radial_integral_1_1_parameters`


Class Documentation
-------------------


.. doxygenclass:: libecpint::RadialIntegral
   :members:
   :protected-members:
   :undoc-members:.. _dir__Users_robertshaw_devfiles_libecpint_src:


Directory src
=============


*Directory path:* ``/Users/robertshaw/devfiles/libecpint/src``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_src_generated`
- :ref:`dir__Users_robertshaw_devfiles_libecpint_src_lib`


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generate.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_makelist.py`


.. _exhale_function_namespacelibecpint_1_1qgen_1aea3e2f38c359b9861ebc8e6f8efc0292:

Function libecpint::qgen::Q4_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _dir__Users_robertshaw_devfiles_libecpint_src_generated_radial:


Directory radial
================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_generated>` (``/Users/robertshaw/devfiles/libecpint/src/generated``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint/src/generated/radial``


Files
-----

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_radial_gen.cpp`
- :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`



.. _file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py:

File unrol_radial.py
====================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_generated_radial>` (``/Users/robertshaw/devfiles/libecpint/src/generated/radial``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/generated/radial/unrol_radial.py``)
------------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py.rst










Namespaces
----------


- :ref:`namespace_sympy`

- :ref:`namespace_unrol_radial`


Classes
-------


- :ref:`exhale_class_classunrol__radial_1_1_qijk`


Functions
---------


- :ref:`exhale_function_namespaceunrol__radial_1a48a1059eae24c36cd6464073577d147a`

- :ref:`exhale_function_namespaceunrol__radial_1a2cd46d9b308d3d493fdd7a516019c717`

- :ref:`exhale_function_namespaceunrol__radial_1aff823186ee3dc7e823e3f1a858233df6`

- :ref:`exhale_function_namespaceunrol__radial_1afc2f4f223df08979b137c507be4bbd37`


Variables
---------


- :ref:`exhale_variable_namespaceunrol__radial_1a582dde0241adf8b3a95b4459b4d49b2b`

- :ref:`exhale_variable_namespaceunrol__radial_1a02363db1e3121f4cb64855282f206fff`

- :ref:`exhale_variable_namespaceunrol__radial_1a7e0a7548eed4ebb942e94e7b9405f123`

- :ref:`exhale_variable_namespaceunrol__radial_1a032ec358895dd239986cf46342a0de86`

.. _exhale_function_namespacelibecpint_1_1qgen_1aa351f08e3c67aaf89372bb6458977b7b:

Function libecpint::qgen::Q3_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2dd9ddbb3213eea5af524a6ff34ecd73:

Function libecpint::qgen::Q0_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1af524f71fe882318cfb0204f01004e173:

Function libecpint::qgen::Q0_0_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a1d96905f9de2c9caaba87c3790f6d30b:

Function libecpint::qgen::Q2_3_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_define_mathutil_8hpp_1a620539bb392918432be69023bb266dfb:

Define M_EULER
==============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`


Define Documentation
--------------------


.. doxygendefine:: M_EULER
.. _exhale_function_namespacelibecpint_1a44095a8d0f5ab3e8bf4770a0ecd39a49:

Function libecpint::pow_18
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_18(const double)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp:

File bessel.cpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/bessel.cpp``)
------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp.rst





Includes
--------


- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`)

- ``cassert``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_struct_structlibecpint_1_1_two_index:

Template Struct TwoIndex
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::TwoIndex
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1a17ab9d6e76588a000009bd6140f80914:

Function libecpint::qgen::Q4_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a67e080a65877ef94a995b6375c8f813a:

Function libecpint::qgen::Q2_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1ae8e9cac2c5167fee6077b8d5b38c879d:

Function libecpint::pow_5
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_5(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a11ea2c964fa710815e0bb651095b978b:

Function libecpint::qgen::Q3_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a109fc4cf994a6ef27bc8377bb1221a6e:

Function libecpint::qgen::Q0_0_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a5d0157ab6282709bcec5e37a841e8fbf:

Function libecpint::pow_20
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_20(double)
.. _exhale_function_namespacelibecpint_1a16e0a77a3022ff74a1fbb6eccba88c4c:

Function libecpint::frobenius_norm
==================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::frobenius_norm(const TwoIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ad7b9a182da83d7b4f3db01182093b967:

Function libecpint::qgen::Q2_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_unrol_radial.py:

Program Listing for File unrol_radial.py
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_generated_radial_unrol_radial.py>` (``/Users/robertshaw/devfiles/libecpint_new/src/generated/radial/unrol_radial.py``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: py

   MAX_UNROL_AM = 4
   
   # DO NOT EDIT BELOW HERE
   
   from sympy import *
   
   class Qijk:
       def __init__(self, Ival = 0, Jval = 0, Kval = 0):
           self.i = Ival
           self.j = Jval
           self.k = Kval
           self.size = 2*self.i + self.j + 1
           self.start = self.k-self.i-self.j
           self.end = self.k+self.i
           self.subq = []
           self.terms = []
           self.bases = []
           self.f = []
           self.ga = []
           self.gb = []
           self.h = []
           for i in range(self.size):
               self.bases.append([])
       
       def print(self):
           print("Q", self.i, self.j, self.k)
           for i in range(len(self.bases)):
               print(i+self.start, ":")
               for j in range(len(self.bases[i])):
                   print(self.bases[i][j])
       
       def print_simple(self):
            print("Q", self.i, self.j, self.k)
            for i in range(len(self.bases)):
               print(i+self.start, ":", simplify(self.bases[i]))
               
       def print_fgh(self):
           print("Q", self.i, self.j, self.k)
           for i in range(len(self.f)):
               ix = 2*i+self.start
               if ix > 0:
                   print("F", ix, ":", simplify(self.f[i]))
           for i in range(len(self.gb)):
               ix = 2*i + self.start + 1
               if ix > 0:
                   print("GB", ix, ":", simplify(self.gb[i]))
           for i in range(len(self.ga)):
               ix = 2*i + self.start + 1
               if ix > 0:
                   print("GA", ix, ":", simplify(self.ga[i]))
           for i in range(len(self.h)):
               ix = 2*i+self.start + 2
               if ix > 0:
                   print("H", ix, ":", simplify(self.h[i]))
       
       def write_code(self, f):
           print("\t\t\t\t\t\t\t\t\tcase", self.i*10000+self.j*100+self.k, ": {", file=f)
   
           for i in range(len(self.f)):
               ix = 2*i+self.start
               if ix == 2:
                   simp = simplify(self.f[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult = (", simp, ") * values[0];", file=f)
               elif ix > 2:
                   simp = simplify(self.f[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * values[", ix-2, "];", file=f)
                   
           for i in range(len(self.gb)):
               ix = 2*i + self.start + 1
               if ix == 1:
                   simp = simplify(self.gb[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * G1B;", file=f)
               elif ix > 1:
                   simp = simplify(self.gb[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * values[", ix-2, "];", file=f)
   
           for i in range(len(self.ga)):
               ix = 2*i + self.start + 1
               if ix == 1:
                   simp = simplify(self.ga[i])
                   if simp != 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * G1A;", file=f)
   
           for i in range(len(self.h)):
               ix = 2*i+self.start + 2
               if ix == 2:
                   simp = simplify(self.h[i])
                   if simp!= 0:
                       print("\t\t\t\t\t\t\t\t\t\tresult += (", simp, ") * H2;", file=f)
                       
           print("\t\t\t\t\t\t\t\t\t\tbreak;", file=f)
           print("\t\t\t\t\t\t\t\t\t}", file=f)
   
       def simplify(self):
           simple_bases = []
           for i in range(len(self.bases)):
               x = Symbol('x')
               y = Symbol('y')
               z = Symbol('z')
               z = 0
               for j in range(len(self.bases[i])):
                   z = z + parse(self.bases[i][j])
               simple_bases.append(z)
           self.bases = simple_bases
           
       def sort(self):
           for i in range(len(self.bases)):
               if i % 2 == 0:
                   self.f.append(self.bases[i])
               else:
                   self.gb.append(self.bases[i])
                   
       def eliminate(self):
           x = Symbol('x')
           y = Symbol('y')
           z = Symbol('z')
           p = Symbol('p')
           z = 0
           
           if self.start < 1:
               if self.end < 1:
                   self.bases.append(z)
               if self.end < 2:
                   self.bases.append(z)
                   
               w = Symbol('w')
               
               N = self.start
               ix = 0
               gaix = -1
               hix  = -1
               
               while (N < 1):
                   z = self.bases[ix]
                   w = self.bases[ix+2]
                   w = w + (2 * p / (N-1))*z
                   self.bases[ix+2] = w
               
                   w = self.bases[ix+1]
                   w = w - (2 * y / (N-1))*z
                   self.bases[ix+1] = w
                   
                   if ix % 2 == 0:
                       if gaix > -1:
                           w = self.ga[gaix]
                           w = w - (2*x / (N-1))*z
                           self.ga[gaix] = w
                       else:
                           w = -(2*x / (N-1))*z
                           self.ga.append(w)
                           gaix += 1
                           
                       if hix > -1:
                           z = self.h[hix]
                           w = (2 * p / (N-1))*z
                           self.h.append(w)
                           hix += 1
                           
                           w = self.ga[gaix]
                           w = w - (2 * y / (N-1))*z
                           self.ga[gaix] = w
                           
                           w = self.bases[ix+1]
                           w = w - (2 * x / (N-1))*z
                           self.bases[ix+1] = w
                   else:
                       if hix > -1:
                           w = self.h[hix]
                           w = w - (2*x / (N-1))*z
                           self.h[hix] = w
                       else:
                           w = - (2*x / (N-1))*z
                           self.h.append(w)
                           hix += 1
                       
                       if gaix > -1:
                           z = self.ga[gaix]
                           w = (2 * p /(N-1)) * z
                           self.ga.append(w)
                           gaix += 1
                           
                           w = self.h[hix]
                           w = w - (2 * y / (N-1))*z
                           self.h[hix] = w
                           
                           w = self.bases[ix+1]
                           w = w - (2*x / (N-1))*z
                           self.bases[ix+1] = w
                       
                   N += 1
                   ix += 1
   
   def parse(term):
       x = Symbol('x')
       y = Symbol('y')
       p = Symbol('p')
       bits = term.split(',')
       z = Symbol('z')
       z = 1
       for bit in bits:
           bi = bit[:2]
           if bi == "mu":
               ix = 2
               i = 0
               j = 0
               k = 0
   
               I = bit[ix]
               if I == "-":
                   ix += 1
                   i = -int(bit[ix])
               else:
                   i = int(I)
                   
               ix += 1
               J = bit[ix]
               if J == "-":
                   ix += 1
                   j = -int(bit[ix])
               else:
                   j = int(J)
   
               ix += 1
               K = bit[ix]
               if K == "-":
                   ix += 1
                   k = -int(bit[ix])
               else:
                   k = int(K)
   
               z = z * (2 + j - i - k)/(2*x)
           elif bi == "nu":
               z = z * (-y/x)
           elif bi == "xi":
               z = z * p/x
           elif bi == "rh":
               j = int(bit[3])
               z = z * (1 - 2*j)/(2*y)
           elif bi == "om":
               z = z * -1 / (2*y)
       return z
               
   def unrol(q):
       if (q.i == 0 and q.j == 0):
           return
       elif (q.i > 0):
           q1 = Qijk(Ival = q.i-1, Jval = q.j, Kval = q.k-1)
           q.subq.append(q1)
           q.terms.append("mu" + str(q.i) + str(q.j) + str(q.k))
   
           q2 = Qijk(Ival = q.i-1, Jval = q.j-1, Kval = q.k)
           q.subq.append(q2)
           q.terms.append("nu")
       
           q3 = Qijk(Ival = q.i-1, Jval = q.j, Kval = q.k+1)
           q.subq.append(q3)
           q.terms.append("xi")
       elif(q.j > 1):
           q1 = Qijk(Ival = 0, Jval = q.j-2, Kval = q.k)
           q.subq.append(q1)
           q.terms.append("sigma")
           
           q2 = Qijk(Ival = 0, Jval = q.j-1, Kval = q.k-1)
           q.subq.append(q2)
           q.terms.append("rho" + str(q.j))
       else:
           q1 = Qijk(Ival = 0, Jval = 0, Kval = q.k)
           q.subq.append(q1)
           q.terms.append("ups")
           
           q2 = Qijk(Ival = 0, Jval = 0, Kval = q.k-1)
           q.subq.append(q2)
           q.terms.append("om")
   
       for i in range(len(q.subq)):
           unrol(q.subq[i])
       
       return
   
   def collect(q, Q, term):
       if (q.i == 0 and q.j == 0):
           Q.bases[q.k-Q.start].append(term)
       else:
           for i in range(len(q.subq)):
               collect(q.subq[i], Q, term + q.terms[i] + ",")
   
   def algebraic_unrol(i, j, k):
       q = Qijk(Ival = i, Jval = j, Kval = k)
       unrol(q)
       collect(q, q, "")
       q.simplify()
       return q
   
   
   f = open('radial_gen.part2', 'w')
   print("", file=f)
   for j in range(MAX_UNROL_AM+1):
       for i in range(j+1):
           for k in range(1, 3*MAX_UNROL_AM+1-i-j):
               if (i + j + k) % 2 == 0: 
                   q = algebraic_unrol(i, j, k)
                   q.eliminate()
                   q.sort()
                   q.write_code(f)
                   print("", file=f)
.. _exhale_function_namespacelibecpint_1_1qgen_1aaa40ba470be53681e75b124354b40c2c:

Function libecpint::qgen::Q3_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a261faecbcc2aaa80a07749ef804594d9:

Function libecpint::qgen::Q0_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_1(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a274e6578163d01f8c1bd6b24f0f1e061:

Function libecpint::pow_12
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_12(const double)
.. _exhale_variable_namespacelibecpint_1acdba31532082cde9ce50b5c6ecd2b442:

Variable libecpint::CAX3
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::CAX3
.. _exhale_function_namespacelibecpint_1_1qgen_1a5f8d53e84a9fc1a22075e13987d9608e:

Function libecpint::qgen::Q1_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aae455a07b0f1ce8adcd58402bea39b9a:

Function libecpint::qgen::Q4_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_typedef_namespacelibecpint_1af2651847fa01dec731554db1e7b273fd:

Typedef libecpint::Triple
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Typedef Documentation
---------------------


.. doxygentypedef:: libecpint::Triple
.. _exhale_function_namespacelibecpint_1_1qgen_1afa8279cc29fea475b60c95ea30fbcf2a:

Function libecpint::qgen::Q0_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a76b4f2b3f83e17a3f3b81962f2061e4b:

Function libecpint::qgen::Q5_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a8d415487a348138eae566f7b8ee4ce24:

Function libecpint::pow_10
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_10(double)

.. _namespace_libecpint:

Namespace libecpint
===================


.. contents:: Contents
   :local:
   :backlinks: none





Namespaces
----------


- :ref:`namespace_libecpint__aux`

- :ref:`namespace_libecpint__qgen`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_e_c_p`

- :ref:`exhale_struct_classlibecpint_1_1_e_c_p_basis`

- :ref:`exhale_struct_structlibecpint_1_1_e_c_p_integrator`

- :ref:`exhale_struct_structlibecpint_1_1_five_index`

- :ref:`exhale_struct_structlibecpint_1_1_gaussian_e_c_p`

- :ref:`exhale_struct_structlibecpint_1_1_gaussian_shell`

- :ref:`exhale_struct_structlibecpint_1_1_radial_integral_1_1_parameters`

- :ref:`exhale_struct_structlibecpint_1_1_seven_index`

- :ref:`exhale_struct_structlibecpint_1_1_sum_term`

- :ref:`exhale_struct_structlibecpint_1_1_three_index`

- :ref:`exhale_struct_structlibecpint_1_1_two_index`

- :ref:`exhale_class_classlibecpint_1_1_angular_integral`

- :ref:`exhale_class_classlibecpint_1_1_bessel_function`

- :ref:`exhale_class_classlibecpint_1_1_e_c_p_integral`

- :ref:`exhale_class_classlibecpint_1_1_g_c_quadrature`

- :ref:`exhale_class_classlibecpint_1_1_radial_integral`

- :ref:`exhale_class_structlibecpint_1_1_shell_pair_data`


Enums
-----


- :ref:`exhale_enum_namespacelibecpint_1a61c66c38649b648ca25caaff9ebc6c3f`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a2c6257f0f39de7233558e384908f1526`

- :ref:`exhale_function_namespacelibecpint_1a16e0a77a3022ff74a1fbb6eccba88c4c`

- :ref:`exhale_function_namespacelibecpint_1a0d3d7448d52abd739d6d100afa6d4e8a`

- :ref:`exhale_function_namespacelibecpint_1a3a4ed9b49d76dd6974d2dbc6bb181ab8`

- :ref:`exhale_function_namespacelibecpint_1a23ce2cda098d601b0fddfb10b971e33f`

- :ref:`exhale_function_namespacelibecpint_1a321e63264d2ee5ec80e5aa98ab5f2a31`

- :ref:`exhale_function_namespacelibecpint_1ab8d8f23abac900581a1b074df5151bfa`

- :ref:`exhale_function_namespacelibecpint_1a764f6b0f657d4b76cd030593a81f8161`

- :ref:`exhale_function_namespacelibecpint_1a17491fad5ad55b86c80bccd068067373`

- :ref:`exhale_function_namespacelibecpint_1a274e6578163d01f8c1bd6b24f0f1e061`

- :ref:`exhale_function_namespacelibecpint_1adf95d3c9da1c27fbbbe785fb7d4c3419`

- :ref:`exhale_function_namespacelibecpint_1a12c8c970bff9ab1318e774a4637059fb`

- :ref:`exhale_function_namespacelibecpint_1a5ebc6e4869b8a3dab9286895629c19fc`

- :ref:`exhale_function_namespacelibecpint_1a697a408875eb033819881bc8d5fd3cec`

- :ref:`exhale_function_namespacelibecpint_1a60980f8f3c0f2ce3bfa35d1ab1ffe612`

- :ref:`exhale_function_namespacelibecpint_1a44095a8d0f5ab3e8bf4770a0ecd39a49`

- :ref:`exhale_function_namespacelibecpint_1ad7792ee9315576df3c805d0d0bbb6144`

- :ref:`exhale_function_namespacelibecpint_1aeea8f0398e91f9c4c0abc5087c68208a`

- :ref:`exhale_function_namespacelibecpint_1aa2a7bd43b3c7267b69a5a3faa3adf313`

- :ref:`exhale_function_namespacelibecpint_1adb6835f6678e044793635ea74137610c`

- :ref:`exhale_function_namespacelibecpint_1af1b4030182805b2b87939f0be0bb1f68`

- :ref:`exhale_function_namespacelibecpint_1ae8e9cac2c5167fee6077b8d5b38c879d`

- :ref:`exhale_function_namespacelibecpint_1a691287591ae556167f12eef21d9605d3`

- :ref:`exhale_function_namespacelibecpint_1afc2d0fbd27b79b1cfb7a933a4f8f86af`

- :ref:`exhale_function_namespacelibecpint_1aceff25bd00ac616a0c1679c43c757c25`

- :ref:`exhale_function_namespacelibecpint_1a125307aa5575e22d32bc381c0ddb598d`

- :ref:`exhale_function_namespacelibecpint_1af586e0d10f4e89ae23350208eae35381`

- :ref:`exhale_function_namespacelibecpint_1a3d3ec1164653607a1a2a66e71c160905`

- :ref:`exhale_function_namespacelibecpint_1ac8004320c2b47b1ce75ab1ccfff376e4`

- :ref:`exhale_function_namespacelibecpint_1ad93011f81c46d555725bff0a0fc5aaf6`


Typedefs
--------


- :ref:`exhale_typedef_namespacelibecpint_1a48b53f3b6bfb449ec300ab57fc03763c`

- :ref:`exhale_typedef_namespacelibecpint_1a7676a778fedc78dfdc0495c3319a2730`

- :ref:`exhale_typedef_namespacelibecpint_1a4dc36ca1c5a9247d8bfaac304a7df40f`

- :ref:`exhale_typedef_namespacelibecpint_1af2651847fa01dec731554db1e7b273fd`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a076d4d1e17ab2a37661480ba095329d7`

- :ref:`exhale_variable_namespacelibecpint_1a02017a941eee202982bab7731ead620d`

- :ref:`exhale_variable_namespacelibecpint_1ae0ba3cdb903f3057f168bfaa5495bba0`

- :ref:`exhale_variable_namespacelibecpint_1acdba31532082cde9ce50b5c6ecd2b442`

- :ref:`exhale_variable_namespacelibecpint_1a4ecb557cc8bf8d94cfa80855985007bf`

- :ref:`exhale_variable_namespacelibecpint_1a975e7b9e0f57709418adede308d80405`

- :ref:`exhale_variable_namespacelibecpint_1a683275f366eb38bfcc526bf5264d9376`

- :ref:`exhale_variable_namespacelibecpint_1a4fc3cf89f4b0b1787baabc364a16e377`

- :ref:`exhale_variable_namespacelibecpint_1a5f751be5271cc840a3025f0e0ee026f2`

- :ref:`exhale_variable_namespacelibecpint_1a190a564f849660c170e298aba2181d0a`

- :ref:`exhale_variable_namespacelibecpint_1a6a8879ed7b1d299f2b2e92b105cce919`

- :ref:`exhale_variable_namespacelibecpint_1a20c4903045164881b8dedf0d6a6ed0fb`

- :ref:`exhale_variable_namespacelibecpint_1a92d5ae635e6e5d78682fd89ce537a7a3`

- :ref:`exhale_variable_namespacelibecpint_1a32d2ef087e028b702c316bd2875036ec`

- :ref:`exhale_variable_namespacelibecpint_1ae8056358eb2736d93b3a78dd1428555c`

- :ref:`exhale_variable_namespacelibecpint_1a007003a219fbc1cce6980a389b1013bc`

- :ref:`exhale_variable_namespacelibecpint_1a069479eb4b49ece5f8f9651b5f87c777`

- :ref:`exhale_variable_namespacelibecpint_1a37d6807785ad49c55bbe8b56deab2be8`
.. _exhale_function_namespacelibecpint_1_1qgen_1a966d79e1526e747a20f26196ed2bd2bc:

Function libecpint::qgen::Q4_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp:

File bessel.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/include/libecpint/bessel.hpp``)
----------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp.rst





Includes
--------


- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_bessel.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_bessel_function`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a007003a219fbc1cce6980a389b1013bc`

- :ref:`exhale_variable_namespacelibecpint_1a069479eb4b49ece5f8f9651b5f87c777`


.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp:

File bessel.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/bessel.hpp``)
--------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp.rst





Includes
--------


- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_angular.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_bessel_function`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1ae671d7a17c7b2fc7ebf29b27fa266421`

- :ref:`exhale_variable_namespacelibecpint_1a6d710d758ea6c068b95c21ce439ecb21`

.. _exhale_function_namespacelibecpint_1a1addfbe82d0601ae0f2392e952e58dda:

Function libecpint::pow_1
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_1(double)
.. _exhale_function_namespacelibecpint_1a2419326594e0adba8c22660003cee2ce:

Function libecpint::pow_8
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_8(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a704923aff02da8fec8e6586d2023f8b2:

Function libecpint::qgen::Q3_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_define_ecpint_8hpp_1a8546f51f524d0baff0bf3f3b321fbc9b:

Define N_INDEX
==============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecpint.hpp`


Define Documentation
--------------------


.. doxygendefine:: N_INDEX

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp:

Program Listing for File generate.cpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/generate.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   
   #include "generate.hpp"
   
   void generate_lists(int LA, int LB, int lam, libecpint::AngularIntegral& angInts) { 
       using namespace libecpint;
       
       // Create the code file
       std::string ofname = "generated/Q" + std::to_string(LA) + std::to_string(LB) + std::to_string(lam) + ".cpp"; 
       std::ofstream outfile(ofname); 
       
       if (!outfile.is_open())
           std::cerr << "Problems writing to file!" << std::endl; 
       else {
           
           std::cout << "Generating Q(" << LA << ", " << LB << ", " << lam << ")... " << std::flush; 
           
           // Top matter
           outfile << "// Generated as part of Libecpint, Copyright 2017 Robert A Shaw" << std::endl; 
           outfile << "#include \"qgen.hpp\"" << std::endl; 
           outfile << "namespace libecpint {" << std::endl << "namespace qgen {" << std::endl;
           outfile << "void Q" << LA << "_" << LB << "_" << lam << "(ECP& U, GaussianShell& shellA, GaussianShell& shellB, "
               << "FiveIndex<double> &CA, FiveIndex<double> &CB, TwoIndex<double> &SA, TwoIndex<double> &SB, double Am, double Bm, "
                   << "RadialIntegral &radint, AngularIntegral& angint, ThreeIndex<double> &values) {" << std::endl << std::endl; 
           
           double prefac = 16.0 * M_PI * M_PI;
           int na = 0; 
           int z1, z2;
           double ang_alpha, ang_beta, ang; 
           
           // Do we need to unrol the angular integrals too? 
           bool unrolling = LA <= maxUnrol && LB <= maxUnrol && (LA + LB + lam) <= 3*maxUnrol;
           
           // Store the terms and radials if unrolling, just radial indices if not
           std::vector<SumTerm> terms; 
           std::vector<Triple> radial_triples; 
           
           // Loop over cartesian functions in alpha order
           for (int x1 = LA; x1 >= 0; x1--) {
               for (int r1 = LA-x1; r1 >= 0; r1--) {
                   z1 = LA - x1 - r1; 
           
                   int nb = 0;
                   for (int x2 = LB; x2 >= 0; x2--) {
                       for (int y2 = LB - x2; y2 >= 0; y2--) {
                           z2 = LB - x2 - y2; 
                   
                           for (int alpha_x = 0; alpha_x <= x1; alpha_x++) {
                               for (int alpha_y = 0; alpha_y <= r1; alpha_y++) {
                                   for (int alpha_z = 0; alpha_z <= z1; alpha_z++) {
                                       int alpha = alpha_x + alpha_y + alpha_z; 
                               
                                       for (int beta_x = 0; beta_x <= x2; beta_x++) {
                                           for (int beta_y = 0; beta_y <= y2; beta_y++) {
                                               for (int beta_z = 0; beta_z <= z2; beta_z++) {
                                                   int beta = beta_x + beta_y + beta_z; 
                                                   int N = alpha + beta;               
                                           
                                                   for (int lam1 = 0; lam1 <= lam + alpha; lam1++) {
                                                       int lam2start = (lam1 + N) % 2; 
                                                       for (int lam2 = lam2start; lam2 <= lam + beta; lam2+=2) {
                                                   
                                                           for (int mu1 = -lam1; mu1 <= lam1; mu1++) {
                                                               for (int mu2 = -lam2; mu2 <= lam2; mu2++) {
                                                                                                                                                                                       
                                                                   for (int mu = -lam; mu <= lam; mu++) {
                                                                       ang_alpha = angInts.getIntegral(alpha_x, alpha_y, alpha_z, lam, mu, lam1, mu1);
                                                                       ang_beta = angInts.getIntegral(beta_x, beta_y, beta_z, lam, mu, lam2, mu2); 
                                                                       ang = ang_alpha * ang_beta; 
                                                                       
                                                                       // Screen based on the angular integrals
                                                                       if (fabs(ang) > 1e-15) {
                                                                           if (unrolling) {
                                                                               SumTerm newTerm; 
                                                                               newTerm.SA = Pair(lam1, lam1+mu1); 
                                                                               newTerm.SB = Pair(lam2, lam2+mu2);
                                                                               newTerm.radial = Triple(N, lam1, lam2);
                                                                               newTerm.CA = Quintuple(0, na, alpha_x, alpha_y, alpha_z); 
                                                                               newTerm.CB = Quintuple(0, nb, beta_x, beta_y, beta_z); 
                                                                               newTerm.ang = prefac * ang;  
                                                                               newTerm.mu = lam+mu; 
                                                                               newTerm.na = na;
                                                                               newTerm.nb = nb;
                                                                   
                                                                               terms.push_back(newTerm); 
                                                                           }
                                                                           radial_triples.push_back({N, lam1, lam2}); 
                                                                       } 
                                                                   }
                                                                   
                                                               }
                                                           }
                                                       }
                                                   }
                                           
                                           
                                               }
                                           }
                                       }
                                   }
                               }
                           }
                   
                           nb++;
                       }
                   }
           
                   na++; 
               }
           }
           
           // Sort the radial triples and eliminate repeats
           std::sort(radial_triples.begin(), radial_triples.end()); 
           radial_triples.erase(std::unique(radial_triples.begin(), radial_triples.end()), radial_triples.end()); 
           
           // Determine the maximum number of base integrals needed across the set of all radial integrals
           int nbase = 0; 
           if (radial_triples.size() > 0) {
               Triple& tmax = radial_triples[radial_triples.size()-1]; 
               nbase = std::get<0>(tmax) + std::get<1>(tmax) - 1; 
               nbase = nbase < 0 ? 0 : nbase; 
           }
           
           // Sort the radials into two lists, depending on whether l1 <= l2 (radial_A), or l2 > l1 (radial_B)
           // swapping the order of l1/l2 in the latter case
           std::vector<Triple> radial_A, radial_B; 
           for (Triple& t : radial_triples) {
               if (std::get<1>(t) <= std::get<2>(t)) radial_A.push_back(t);  
               else radial_B.push_back({std::get<0>(t), std::get<2>(t), std::get<1>(t)});
           }
           
           // Compute the correctly ordered radials first
           outfile << "\tstd::vector<Triple> radial_triples_A = {" << std::endl; 
           bool first = true; 
           for (Triple& t : radial_A) {
               if (!first) outfile << "," << std::endl; 
               else first = false; 
               outfile << "\t\t{" + std::to_string(std::get<0>(t)) + ", "
                   + std::to_string(std::get<1>(t)) + ", " 
                       + std::to_string(std::get<2>(t)) + "}"; 
           }
           outfile << "\t};" << std::endl << std::endl;  
           
           outfile << "\tThreeIndex<double> radials(" << lam+LA+LB+1 << ", " << lam+LA+1 << ", " << lam+LB+1 << ");" << std::endl; 
           outfile << "\tradint.type2(radial_triples_A, " << nbase << ", " << lam << ", U, shellA, shellB, Am, Bm, radials);" << std::endl << std::endl; 
           
           // Now compute the reverse-ordered radials
           outfile << "\tstd::vector<Triple> radial_triples_B = {" << std::endl; 
           first = true;
           for (Triple& t : radial_B) {
               if (!first) outfile << "," << std::endl; 
               else first = false; 
               outfile << "\t\t{" + std::to_string(std::get<0>(t)) + ", "
                   + std::to_string(std::get<1>(t)) + ", " 
                       + std::to_string(std::get<2>(t)) + "}"; 
           }
           outfile << "\t};" << std::endl << std::endl;  
           
           outfile << "\tThreeIndex<double> radials_B(" << lam+LA+LB+1 << ", " << lam+LB+1 << ", " << lam+LA+1 << ");" << std::endl; 
           outfile << "\tradint.type2(radial_triples_B, " << nbase << ", " << lam << ", U, shellB, shellA, Bm, Am, radials_B);" << std::endl;
           // These need to be compressed into the radials array, with l1/l2 reversed back
           outfile << "\tfor (Triple& t : radial_triples_B) radials(std::get<0>(t), std::get<2>(t), std::get<1>(t)) = radials_B(std::get<0>(t), std::get<1>(t), std::get<2>(t));" << std::endl << std::endl; 
           
           if (unrolling) {
               // Print out the unrolled angular integral code if needed
               std::cout << "unrolling... " << std::flush; 
               for (auto& term : terms) outfile << "\t" << term << std::endl; 
           } else {
               // Just use the generic rolled-up angular integral code
               outfile << "\trolled_up(" << lam << ", " << LA << ", " << LB << ", radials, CA, CB, SA, SB, angint, values);" << std::endl; 
           }
           outfile << "}" << std::endl << "}" << std::endl << "}" << std::endl; 
           
           std::cout << "done." << std::endl; 
           outfile.close();
       }
   }
   
   int main(int argc, char* argv[]) {
       
       // Factorial singletons will not have been initialised
       libecpint::initFactorials();
       int maxL = libecpint::maxL;
       
       libecpint::AngularIntegral angInts(maxL, maxL); 
       angInts.compute(); 
       
       // Generate the qgen.hpp header file
       std::string header_name; 
       if (argc > 1) {
           header_name = argv[1]; 
           header_name += "qgen.hpp"; 
       } else {
           header_name = "generated/qgen"; 
       }
   
       std::ifstream qgen_part("generated/qgen.part");
       std::ofstream qgen_head(header_name); 
       if (!qgen_part.is_open() || !qgen_head.is_open()) 
           std::cerr << "Problem creating qgen header file!" << std::endl; 
       else {
           std::string line; 
           while(!qgen_part.eof()) {
               std::getline(qgen_part, line); 
               qgen_head << line << std::endl;  
           }
           qgen_part.close();
           
           // Loop over all possible (l1, l2, lam) integrals up to l1 = l2 = lam = maxL
           // with l1 <= l2, generating the code and adding the function to the header file.
           for (int j = 0; j <= maxL; j++) {
               for (int i = 0; i <= j; i++) {
                   for (int k = 0; k <= maxL; k++) {
                       generate_lists(i, j, k, angInts); 
                       qgen_head << "\tvoid Q" << i << "_" << j << "_" << k << "("
                                   << "ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, "
                                   << "TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, "
                                   << "AngularIntegral&, ThreeIndex<double>&);" << std::endl; 
                   }
               }
           }
           qgen_head << std::endl << "}" << std::endl << "}" << std::endl; 
           qgen_head << "#endif" << std::endl; 
           qgen_head.close(); 
           
           // Now generate the function pointer array in ecpint_gen.cpp
           std::ifstream ecpgen_part("generated/ecpint_gen.part"); 
           std::ofstream ecpgen_head("generated/ecpint_gen.cpp"); 
           
           if (!ecpgen_part.is_open() || !ecpgen_head.is_open())
               std::cerr << "Problem reading/writing ecpgen file!" << std::endl;
           else {
               while(!ecpgen_part.eof()) {
                   std::getline(ecpgen_part, line); 
                   ecpgen_head << line << std::endl;  
               }
               ecpgen_part.close();
               
               for (int i =0; i <= maxL; i++) {
                   ecpgen_head << "\t\t{ "; 
                   
                   for (int j = 0; j<= maxL; j++) {
                       ecpgen_head << "\t\t\t{"; 
                       
                       int I = std::min(i, j);
                       int J = std::max(i, j); 
                       
                       for (int k = 0; k< maxL; k++) 
                           ecpgen_head << "qgen::Q" << I << "_" << J << "_" << k << ", ";
                       
                       ecpgen_head << "qgen::Q" << I << "_" << J << "_" << maxL << "}";
                       if (j != maxL) ecpgen_head << ","; 
                       ecpgen_head << std::endl;
                   }
                   
                   ecpgen_head << "\t\t}";
                   if (i != maxL) ecpgen_head << ","; 
                   ecpgen_head << std::endl; 
               }
               
               ecpgen_head << "\t};" << std::endl << "}" << std::endl;
               ecpgen_head.close();  
           }
       }
       return 0; 
   }
.. _exhale_typedef_namespacelibecpint_1a7676a778fedc78dfdc0495c3319a2730:

Typedef libecpint::Pair
=======================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Typedef Documentation
---------------------


.. doxygentypedef:: libecpint::Pair
.. _exhale_variable_generate_8cpp_1ac7ae95c5f32933895a50c459d5d03304:

Variable CAX2
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: CAX2
.. _exhale_function_namespacelibecpint_1_1qgen_1a129a37d497b2f5a3a1c3819edbe479df:

Function libecpint::qgen::Q1_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aefd1940621859b33b496f59439b9a629:

Function libecpint::qgen::Q3_4_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a4e660a607aefaeda5a7b0aff0921c062:

Function libecpint::qgen::Q1_4_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa4e13d53a459d93019650b9bf0f64a58:

Function libecpint::qgen::Q4_4_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_variable_namespacemakelist_1ae1a361014e097535367c775cc83758fd:

Variable makelist::prefix
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_makelist.py`


Variable Documentation
----------------------


.. doxygenvariable:: makelist::prefix
.. _exhale_function_namespacelibecpint_1_1qgen_1ae76853a759ec019120382cd19a0e2d29:

Function libecpint::qgen::Q4_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1adb6835f6678e044793635ea74137610c:

Function libecpint::pow_3
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_3(const double)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp:

Program Listing for File gaussquad.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/gaussquad.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GC_QUAD_HEAD
   #define GC_QUAD_HEAD
   
   #include <functional>
   #include <vector>
   
   namespace libecpint {
   
       enum GCTYPE {
           ONEPOINT, 
           TWOPOINT  
       };
   
       class GCQuadrature {
       private:
           int maxN; 
           int M;  
       
           std::vector<double> x; 
           std::vector<double> w; 
    
           double I; 
       
           GCTYPE t; 
       
           double sumTerms(std::function<double(double, double*, int)> &f, double *p, int limit, int shift, int skip);
   
       public:
           
           int start; 
           int end;   
       
           GCQuadrature();
           
           GCQuadrature(const GCQuadrature &other);
       
           void initGrid(int points, GCTYPE t);
       
           bool integrate(std::function<double(double, double*, int)> &f, double *params, const double tolerance);
       
           void transformZeroInf();
           
           void transformRMinMax(double z, double p);  // Transfromation from [-1, 1] to [rmin, rmax] from Flores06
           void untransformRMinMax(double z, double p);
       
           double getI() const { return I; }
       
           int getN() const { return maxN; }
       
           std::vector<double>& getX() { return x; }
       };
   }
   
   #endif
.. _exhale_variable_namespacelibecpint_1a6d710d758ea6c068b95c21ce439ecb21:

Variable libecpint::TAYLOR_CUT
==============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::TAYLOR_CUT
.. _exhale_function_namespacelibecpint_1_1qgen_1a153993173e1a3f56f30abea2b345db76:

Function libecpint::qgen::Q2_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a9630ee3fefeb8b74101ee1a6b9678a54:

Function libecpint::print_lists
===============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::print_lists(std::vector<SumTerm>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1abe81347b5a52f811b3bac69af1f8f9bb:

Function libecpint::qgen::Q2_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp:

File generate.hpp
=================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include>` (``/Users/robertshaw/devfiles/libecpint_new/include``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/generate.hpp``)
------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_generate.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`)

- ``cmath``

- ``config.hpp``

- ``fstream``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_mathutil.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``string``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_struct_structlibecpint_1_1_sum_term`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1a3a4ed9b49d76dd6974d2dbc6bb181ab8`


Variables
---------


- :ref:`exhale_variable_namespacelibecpint_1a02017a941eee202982bab7731ead620d`

- :ref:`exhale_variable_namespacelibecpint_1ae0ba3cdb903f3057f168bfaa5495bba0`

- :ref:`exhale_variable_namespacelibecpint_1acdba31532082cde9ce50b5c6ecd2b442`

- :ref:`exhale_variable_namespacelibecpint_1a190a564f849660c170e298aba2181d0a`

- :ref:`exhale_variable_namespacelibecpint_1a6a8879ed7b1d299f2b2e92b105cce919`

- :ref:`exhale_variable_namespacelibecpint_1a20c4903045164881b8dedf0d6a6ed0fb`


.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp:

Program Listing for File gshell.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/gshell.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #ifndef GSHELL_HEAD
   #define GSHELL_HEAD
   
   #include <vector>
   #include <array>
   
   namespace libecpint {
   
       struct GaussianShell {
           std::vector<double> exps; 
           std::vector<double> coeffs; 
           
           double* centerVec; 
           bool local_ptr; 
           
           double localCenter[3];
           
           double min_exp; 
           
           int l; 
           int atom_id; 
           
           GaussianShell(double* A, int l);
           
           GaussianShell(std::array<double, 3> A, int l);
           
           GaussianShell(const GaussianShell& other) { 
               exps = other.exps;
               coeffs = other.coeffs;
               centerVec = other.centerVec;
               l = other.l;
               min_exp = other.min_exp;
               
               local_ptr = other.local_ptr;
               if (local_ptr) {
                   localCenter[0] = other.localCenter[0];
                   localCenter[1] = other.localCenter[1];
                   localCenter[2] = other.localCenter[2];
                   centerVec = localCenter;
               }
           } 
           
           void addPrim(double exp, double c);
           
           int nprimitive() const { return exps.size(); }
           
           int ncartesian() const { return ((l+1)*(l+2))/2; }
           
           double* center() const { return centerVec; };
           
           double exp(int i) const { return exps[i]; }
           
           double coef(int i) const { return coeffs[i]; }
           
           int am() const { return l; }
           
           GaussianShell copy() const {
               GaussianShell result(centerVec, l);
               result.min_exp = min_exp;
               result.local_ptr = local_ptr;
               if (local_ptr) {
                   result.localCenter[0] = localCenter[0];
                   result.localCenter[1] = localCenter[1];
                   result.localCenter[2] = localCenter[2];
                   result.centerVec = result.localCenter;
               }
               result.exps = exps;
               result.coeffs = coeffs;
               return result;
           }
       };
   
       struct ShellPairData {
           int LA;         
           int LB;         
           int maxLBasis;  
           int ncartA;     
           int ncartB;     
           double A[3];    
           double B[3];    
           double A2;      
           double Am;      
           double B2;      
           double Bm;      
           double RAB2;    
           double RABm;    
           bool A_on_ecp;  
           bool B_on_ecp;  
       };
   
   }
   
   #endif
.. _exhale_function_namespacelibecpint_1_1qgen_1a73b671bedf8c4d6dd679961436290720:

Function libecpint::qgen::Q1_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a5f05d08a900405de7047d06a22e5ba2f:

Function libecpint::qgen::Q0_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1afa1e5d62f4439f243a382d7a8cf09ce8:

Function libecpint::qgen::Q3_3_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _namespace_libecpint__qgen:

Namespace libecpint::qgen
=========================


.. contents:: Contents
   :local:
   :backlinks: none





Functions
---------


- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac50f25410860af3e1c8203648ed6c8ae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a747ea3f093bdc2c16930a9e1573bd396`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a36960c9e50c9fce6a6c57aa8792eba3d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab6099b7e4ee5c323c4ec2c6e939ae699`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a02e67630bc3cc6771a283b931a0d0652`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a109fc4cf994a6ef27bc8377bb1221a6e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a89f11f190b2770ba1a6cd3bb0e252038`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7f4b88955a96847da3ebc5c50d56e6d1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab75f9a0fe020cc5eac1855af0311a1e9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5582b3de3f3f06a0dd219525f45efb3b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3bdb99b42efd94923116ddaf39352437`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a70ec2d64c8c090e8a736825df8ac69d2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a04ddf7b46cb449284fe3577036c66685`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab6b41ee8966c9f271f301c75a167fc9a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a09ff49cc3eeef8f281974772d5dffc0f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a70a5cf8de05207c9704d69acbfb5c2dd`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6179b5819e8e7e2f0335cfa6f36eb478`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3be412799b3edfe3eda545484b300a43`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1acd0676a7915b0a5e72926d61e3827eae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abdcc453ff2d05d577ea9cf4bce03402f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a832916799425771d4a829de5f488c7ab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af87f236fd427c9a80540e4117091be15`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a29fd2aafe4d193454e73909dd36e4969`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1f2fae93db97564c6223f7ab0b3a1345`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a379f0d0f5d764bf07e31a8e3e8156bce`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a299bb6bb7a5287c2773d9f4189a26d69`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6cd9cb22f70aaa25147c43511e335d41`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a93772fb9447d2664d73d8a3902fe1b54`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a99f72ea2f7322f8232307384bd228f5a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a8aa5fff0f4772cffde29ece307abe014`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3de0194aa3913e0e14a9eedb28f9ef99`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a261faecbcc2aaa80a07749ef804594d9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ad83d47512070305306433992d08d692a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afa8279cc29fea475b60c95ea30fbcf2a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab1fcb35c6f2cda3a171a75ae36f634d7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0d0c8cc09c76e3efd8f1cf130bd7264d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a01be990e258c413c9db8dd5624f0e071`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7a27208dca8f6953fd31e913e2fff149`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a31e6957c9ced525cbbdba4a9c443c260`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac9d76855b9f0e07c466603e836fc55cf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5aa67d887d7014b406df808637d97331`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a24a7957907649a616a90be7093af0a1e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a5b65c0e188633d68627478d6dd43a613`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a23265e6ef8db8355d123e8ef88049d01`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae761a79d75fd6b29c1d7460c5032a2b1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a47eb555b220e5464d0533a99a06fec5f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a57c8f6c91db56996a928592cd15643d7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab1fb4b6ce6020d16a6214a109b2f37d9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af900a11994d6f09f0d83cdbc01a6cf3d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a030ab3019b1098321972e7f2aa3654bc`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a141f8229acaf6ffcc69bbf5f25fde085`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a581417956b752bd71c1a66450c2c13a7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6c9e60c9ff500fb4223a19fa56721bc3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9fad4906bd3daa6941148f903ac156df`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae9a7959c4fbc71226a3cd2a7c4cd1aa8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9634adfd5bb091641ec927cb13898103`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a69e412cf2def6bc140846356256e9aec`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a302b0e3066e69adac6e37c16bc223a36`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a10cf00d4a3d89367f96e19216396af68`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0e4355fdf3c94a702625fb08123cfffb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a029bfa957a1438d6be8340a178fa668d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6ca3f4990879d69f0947dc320cff7512`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a30db4a3e0d94645ef1061ebe49fdf79d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab0da4c56916b9b9ef3a1e82176429161`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab76bee96421fb775cd2fd16ff036664f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a179f27d18c3e44e4d6d77a0713ffbe2d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aba431d549c947101b9d20b8ae5cb521a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af9a4da1d53cb16463d2d1144809f55c7`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab9eaa8ccb9792d3efb90ed7143af727a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a153993173e1a3f56f30abea2b345db76`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a04b44167d55d965bd4f0b5fca498a4f9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1abe81347b5a52f811b3bac69af1f8f9bb`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2f1b593fe7a6e4e2810e6b989f0e5e0f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1e41f79e7d2cae760fbb9efe656d79a6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab5c03c9c7a30f526f0ea06560fef3724`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0b77eccd5538829e047ae612b66b76a4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ad7b9a182da83d7b4f3db01182093b967`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac3aed6a829f009e3b82e84a90dc492c3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a418b910c14f22c51f09224b0b5b8897d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6db93ab24ebed670cd2a039350906744`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aad2b22ead6cc4dd2326b1e07fbd9a0e4`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1adf8d2ab801d7cabb617ef95fe2346772`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a08659d03f2d3c193a4a29ad64ed5b2ab`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a055cd957f9eeece918efd6aeac46e55b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a0b468cc9891219de7934784a9c925e23`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa01fb986261df6407432d76739134ee1`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab399ac3be9a089e30a15502bf58c38b9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a00da41091abc4253b7f7c50816157f4a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9a8592e8a00c0d7a195be80fb3bbd0ea`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1ff5364df2c3ea0e40d06a096bfde511`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2b53172b5b4103d7742ccf83fdb6e5b6`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a15e49a02b122486b1eba9c47193a9a7f`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afa1e5d62f4439f243a382d7a8cf09ce8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae94ff95331b2a7d7582d833e57e1a730`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4b956df3f1004dc6c367398fa3881724`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d08887dbffc07eb48888c65399b1df9`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa351f08e3c67aaf89372bb6458977b7b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a9a1b0cff031b0138fad4fba5dd78fb28`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a668ee5dc9c5ceb4e2012bd86327c3f82`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac022ef72b9ce182dc98297e3046bcf35`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a93d5d63f4cd6b286b87140d0c3cd84ae`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aefd1940621859b33b496f59439b9a629`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a7a397803096c0fa76aa8db724640a33e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af6aed704c528f33d41a3c8974f73933d`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6a80fb42ebc7edfd76662bee54b73717`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6210949d0c67ed65d2eeaea4ae8591b5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d54034749c5ef29fa9d9902540aa1bf`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1afbeec27b9ba065ae00e4491b856e151a`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a29d4cca2d7ad9972c8ae888f309ef52c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a1c0f647f35ab7fd10a1a228f19df83a2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2bea2d6240c5f253e14587ab83a5d9dd`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a97e6fa3e95914a16d365a38fad6bf168`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa4e13d53a459d93019650b9bf0f64a58`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aea3e2f38c359b9861ebc8e6f8efc0292`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a43fc7ab5cf543daec745b0f6d033ffc5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af5ae441ae60111ff2860513ccf26148c`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a4ba269ea8b6a2e9c61df0785448a5778`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a3c7bf43770a6435564e402ede936b8a8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2f3ffdd94d2b604fbffc55d77b944ef5`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ae76853a759ec019120382cd19a0e2d29`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a42856d19949953db8b9963a32fec27dc`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a2d3f70e323ad33a72441e7bc597491c2`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a6e1056154af784737309be994c116ca0`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1a766e3dfc45273f3b325b7b47d83c8fa3`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ac6b5b1c66dc83827b0cc8971c0a89c5b`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1aa3390aa653fcf192610379faf4cbadb8`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1af1816608e31f73731cb510619099400e`

- :ref:`exhale_function_namespacelibecpint_1_1qgen_1ab020c384dfc8c0f23cf165448b10216e`
.. _exhale_function_namespacelibecpint_1a02aadabb1b7fceb975aa42706bb2be8d:

Function libecpint::pow_19
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_19(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab1fb4b6ce6020d16a6214a109b2f37d9:

Function libecpint::qgen::Q1_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp:

Program Listing for File gshell.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_gshell.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/gshell.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "gshell.hpp"
   
   namespace libecpint {
   
       GaussianShell::GaussianShell(double *A, int _l) : centerVec(A), l(_l), local_ptr(false), min_exp(100.0) {}
       GaussianShell::GaussianShell(std::array<double, 3> A, int _l) : l(_l) {
           centerVec = localCenter;
           local_ptr = true;
           localCenter[0] = A[0];
           localCenter[1] = A[1];
           localCenter[2] = A[2];
           min_exp = 100.0;
       }
   
       void GaussianShell::addPrim(double e, double c) {
           exps.push_back(e);
           coeffs.push_back(c);
           min_exp = e < min_exp ? e : min_exp;
       }
   
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a5febb3c055ce4769bc1a750f98758aab:

Function libecpint::qgen::Q4_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_struct_structlibecpint_1_1_seven_index:

Template Struct SevenIndex
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::SevenIndex
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1aa93c5edc1ed250d59cfb1687865c7af3:

Function libecpint::pow_17
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_17(double)
.. _exhale_variable_namespacelibecpint_1ae671d7a17c7b2fc7ebf29b27fa266421:

Variable libecpint::SMALL
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::SMALL
.. _exhale_function_namespacelibecpint_1_1qgen_1af1816608e31f73731cb510619099400e:

Function libecpint::qgen::rolled_up
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_qgen.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::rolled_up(int, int, int, const ThreeIndex<double>&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, const AngularIntegral&, ThreeIndex<double>&)
.. _exhale_class_classlibecpint_1_1_bessel_function:

Class BesselFunction
====================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`


Class Documentation
-------------------


.. doxygenclass:: libecpint::BesselFunction
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1_1qgen_1a69e412cf2def6bc140846356256e9aec:

Function libecpint::qgen::Q1_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a90ba6aa515ccce14c9f5e63b24be86aa:

Function libecpint::qgen::Q1_4_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_4_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp:

Program Listing for File ecpint.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/ecpint.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "ecpint.hpp"
   #include <iostream>
   #include <cmath>
   #include <cassert>
   #include "Faddeeva.hpp"
   #include "mathutil.hpp"
   #include "qgen.hpp"
   #include <cassert>
   
   namespace libecpint {
   
       ECPIntegral::ECPIntegral(int maxLB, int maxLU, int deriv) { 
           // Make sure library can perform requested integrals
           assert(maxLB+deriv <= LIBECPINT_MAX_L); 
           assert(maxLU <= LIBECPINT_MAX_L);
           
           // Initialise singletons
           initFactorials();
           zero = nonzero = skipped = 0;
           
           // Initialise angular and radial integrators
           angInts.init(maxLB + deriv, maxLU);
           angInts.compute();
           radInts.init(2*(maxLB+deriv) + maxLU, 1e-15, 256, 512);
       };
   
       double ECPIntegral::calcC(int a, int m, double A) const {
           double value = 1.0 - 2*((a-m) % 2);
           value *= std::pow(A, a-m);
           value *= FAC[a]/(FAC[m] * FAC[a-m]);
           return value;
       }
   
       void ECPIntegral::makeC(FiveIndex<double> &C, int L, double *A) {
           int z; double Ck, Cl;
           int na = 0;
           for (int x = L; x >= 0; x--) {
               for (int y = L-x; y >= 0; y--) {
                   z = L - x - y;
               
                   for (int k = 0; k<= x; k++) {
                       Ck = calcC(x, k, A[0]);
                       for (int l = 0; l <= y; l++) {
                           Cl = calcC(y, l, A[1]);
                           for (int m = 0; m <= z; m++) C(0, na, k, l, m) = Ck * Cl * calcC(z, m, A[2]);
                       }
                   }
                   na++;
               }
           }
       }
   
       void ECPIntegral::type1(ECP &U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, FiveIndex<double> &CA, FiveIndex<double> &CB, TwoIndex<double> &values) { 
   
           int LA = data.LA; int LB = data.LB;
           int maxLBasis = data.maxLBasis;
       
           // Build radial integrals
           int L = LA + LB;
           TwoIndex<double> temp;
           ThreeIndex<double> radials(L+1, L+1, 2*L+1);
           for (int ix = 0; ix <= L; ix++) {
               radInts.type1(ix, ix, ix % 2, U, shellA, shellB, data, temp);
               for(int l = 0; l <= ix; l++) {
                   for (int m = -l; m <= l; m++) radials(ix, l, l+m) = temp(l, l+m);
               }
           }
       
           // Unpack positions
           double Ax = data.A[0]; double Ay = data.A[1]; double Az = data.A[2];
           double Bx = data.B[0]; double By = data.B[1]; double Bz = data.B[2];
       
           // Calculate chi_ab for all ab in shells
           int z1, z2, lparity, mparity, msign, ix, k, l, m;
           double C;
           int na = 0, nb = 0;
           for (int x1 = LA; x1 >= 0; x1--) {
               for (int y1 = LA-x1; y1 >= 0; y1--) {
                   z1 = LA - x1 - y1;
                   nb = 0;
               
                   for (int x2 = LB; x2 >= 0; x2--) {
                       for (int y2 = LB-x2; y2 >= 0; y2--) {
                           z2 = LB - x2 - y2;
                       
                           for (int k1 = 0; k1 <= x1; k1++) {
                               for (int k2 = 0; k2 <= x2; k2++) {
                                   k = k1 + k2;
                               
                                   for (int l1 = 0; l1 <= y1; l1++) {
                                       for (int l2 = 0; l2 <= y2; l2++) {
                                           l = l1 + l2;
                                       
                                           for (int m1 = 0; m1 <= z1; m1++) {
                                               for (int m2 = 0; m2 <= z2; m2++){
                                                   m = m1 + m2;
                                                   C = CA(0, na, k1, l1, m1) * CB(0, nb, k2, l2, m2);
                                                   if ( fabs(C) > 1e-14 ) {
                                                       // Build radial integrals
                                                       ix = k + l + m;
                                                       
                                                       // Certain terms can be neglected as the angular integrals will always be zero
                                                       // See Flores06 appendix for details. 
                                                       lparity = ix % 2; 
                                                       msign = 1 - 2*(l%2);
                                                       mparity = (lparity + m) % 2;
                                                   
                                                       for (int lam = lparity; lam <= ix; lam+=2) {
                                                           for (int mu = mparity; mu <= lam; mu+=2)
                                                               values(na, nb) += C * angInts.getIntegral(k, l, m, lam, msign*mu) * radials(ix, lam, lam+msign*mu);
                                                       }
                                   
                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }
                       
                           values(na, nb) *= 4.0 * M_PI;
                           nb++;
                       }
                   }
               
                   na++;
               }
           }
       
       }
   
       void ECPIntegral::type2(int lam, ECP& U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, FiveIndex<double> &CA, FiveIndex<double> &CB, ThreeIndex<double> &values) {
       
           // Unpack some data for convenience
           int LA = data.LA;
           int LB = data.LB;
           int L = LA + LB;    
           int maxLBasis = data.maxLBasis;
       
           double Am = data.Am; double Bm = data.Bm;
   
           if (data.A_on_ecp && data.B_on_ecp) {
               
               // Both on ECP, simplest case - see Shaw2017 supplementary material
               double prefactor = 4.0 * M_PI; 
               int npA = shellA.nprimitive();
               int npB = shellB.nprimitive();
               int npC = U.getN(); 
           
               double zA, zB, zC, dA, dB, dC, p; 
               int nC, z1, z2;
               
               int na = 0;
               for (int x1 = LA; x1 >= 0; x1--) {
                   for (int r1 = LA-x1; r1 >= 0; r1--) {
                       z1 = LA - x1 - r1; 
               
                       int nb = 0;
                       for (int x2 = LB; x2 >= 0; x2--) {
                           for (int y2 = LB - x2; y2 >= 0; y2--) {
                               z2 = LB - x2 - y2; 
                           
                               double value = 0.0;
                               for (int c = 0; c < npC; c++) {
                                   GaussianECP& g = U.getGaussian(c);
                                   if (g.l == lam) {
                                       zC = g.a;
                                       dC = g.d;
                                       nC = g.n; 
    
                                       for (int a = 0; a < npA; a++) {
                                           zA = shellA.exp(a);
                                           dA = shellA.coef(a);
                                       
                                           for (int b = 0; b < npB; b++) {
                                               zB = shellB.exp(b);
                                               dB = shellB.coef(b); 
                                           
                                               p = zA + zB + zC;
                                           
                                               double o_root_p = 1.0 / sqrt(p);
                                               int N = 2 + LA + LB + nC;
                                               value += 0.5*dA*dB*dC*GAMMA[N]*FAST_POW[N+1](o_root_p);
                                           }
                                       }
                                   }
                               }
                               
                               for (int mu = -lam; mu <= lam; mu++) {
                           
                                   double angular = prefactor * angInts.getIntegral(x1, r1, z1, lam, mu, 0, 0) * angInts.getIntegral(x2, y2, z2, lam, mu, 0, 0); 
                                   values(na, nb, lam+mu) = angular * value; 
                               }
                               nb++; 
                           }
                       }
                   
                       na++;
                   }
               }
               
           } else {
               
               // At least one of the shells is not on the ECP, so spherical harmonics will be required
               
               double xA = Am > 0 ? data.A[2] / Am : 0.0;
               double xB = Bm > 0 ? data.B[2] / Bm : 0.0;
               double phiA = atan2(data.A[1], data.A[0]);
               double phiB = atan2(data.B[1], data.B[0]);
               TwoIndex<double> SA = realSphericalHarmonics(lam+LA, xA, phiA);
               TwoIndex<double> SB = realSphericalHarmonics(lam+LB, xB, phiB);
           
               if (data.A_on_ecp) {
                   // Radial integrals need to be calculated by a different recursive scheme, or by quadrature
                   ThreeIndex<double> radials(L+1, lam + LA + 1, lam + LB + 1); 
                   TwoIndex<double> temp;
                   std::fill(values.data.begin(), values.data.end(), 0.0);
   
                   for (int N = 0; N < L+1; N++) {
                       radInts.type2(lam, 0, lam + LA, 0, lam + LB, N, U, shellA, shellB, data, temp); 
                       for (int l1 = 0; l1 < lam + LA + 1; l1++)
                           for (int l2 = 0; l2 < lam + LB + 1; l2++)
                               radials(N, l1, l2) = temp(l1, l2);
                   }
                   
                   // a significant number of terms can be neglected a priori - see Shaw2017 supplementary material. 
                   qgen::rolled_up_special(lam, LA, LB, radials, CB, SB, angInts, values);
                   
               } else if (data.B_on_ecp){
                   // Same as above with A and B reversed
                   ThreeIndex<double> radials(L+1, lam + LB + 1, lam + LA + 1); 
                   ThreeIndex<double> tmpValues(values.dims[1], values.dims[0], values.dims[2]);
                   std::fill(tmpValues.data.begin(), tmpValues.data.end(), 0.0);
                   TwoIndex<double> temp;
   
                   for (int N = 0; N < L+1; N++) {
                       radInts.type2(lam, 0, lam + LA, 0, lam + LB, N, U, shellA, shellB, data, temp); 
                       for (int l1 = 0; l1 < lam + LB + 1; l1++)
                           for (int l2 = 0; l2 < lam + LA + 1; l2++)
                               radials(N, l1, l2) = temp(l2, l1);
                   }
                   
                   // a significant number of terms can be neglected a priori - see Shaw2017 supplementary material. 
                   qgen::rolled_up_special(lam, LB, LA, radials, CA, SA, angInts, tmpValues);
                   // transcribe back into values
                   for (int na = 0; na < values.dims[0]; na++)
                       for (int nb = 0; nb < values.dims[1]; nb++)
                           for (int nc = 0; nc < values.dims[2]; nc++)
                               values(na, nb, nc) = tmpValues(nb, na, nc);
               } else {
                   
                   // Neither is on the ECP, the full recursive scheme with generated integrals can be used
                   // Need LA <= LB, but symmetry means we can just swap the arguments if LB > LA. 
                   if (LA <= LB) 
                       QGEN[LA][LB][lam](U, shellA, shellB, CA, CB, SA, SB, Am, Bm, radInts, angInts, values);
                   else {
                       ThreeIndex<double> temp_values(data.ncartB, data.ncartA, 2*U.getL() + 1); 
                       QGEN[LB][LA][lam](U, shellB, shellA, CB, CA, SB, SA, Bm, Am, radInts, angInts, temp_values);
                       for (int na = 0; na < data.ncartA; na++)
                           for (int nb = 0; nb < data.ncartB; nb++)
                               for (int nu = 0; nu < 2*U.getL() + 1; nu++)
                                   values(na, nb, nu) = temp_values(nb, na, nu); 
                   }
                       
               }           
           }
       }
   
       void ECPIntegral::estimate_type2(ECP& U, GaussianShell &shellA, GaussianShell &shellB, ShellPairData &data, double* results) {
           double sigma_a, sigma_b, min_eta, n2, an, bn, a_bound, b_bound, ab_bound;
           double atilde, btilde, ztilde, Tk, Tk_0, xp;
           
           double Na_0 = 0.5 * data.LA / M_EULER;
           double Nb_0 = 0.5 * data.LB / M_EULER;
           
           for (int l = 0; l <= U.getL(); l++) {
               min_eta = U.min_exp_l[l];
               n2 = min_eta * min_eta;
               an = shellA.min_exp + min_eta;
               bn = shellB.min_exp + min_eta;
               if (data.A2 < 1e-6) sigma_a = 0.5 * an / shellA.min_exp;
               else sigma_a = 0.5 * data.LA * an * an / (shellA.min_exp * (n2*data.A2 + data.LA * an));
               if (data.B2 < 1e-6) sigma_b = 0.5 * bn / shellB.min_exp;
               else sigma_b = 0.5 * data.LB * bn * bn / (shellB.min_exp * (n2*data.B2 + data.LB * bn));
               
               atilde = (1.0 - sigma_a) * shellA.min_exp;
               btilde = (1.0 - sigma_b) * shellB.min_exp;
               
               a_bound = 0.0;
               for (int i = 0; i < shellA.exps.size(); i++)
                   a_bound += FAST_POW[data.LA](std::sqrt(Na_0 / (shellA.exps[i] * sigma_a))) * std::abs(shellA.coeffs[i]); 
               
               b_bound = 0.0;
               for (int i = 0; i < shellB.exps.size(); i++)
                   b_bound += FAST_POW[data.LB](std::sqrt(Nb_0 / (shellB.exps[i] * sigma_b))) * std::abs(shellB.coeffs[i]);
               
               double Tk_0 = 2.0 * atilde * btilde * data.Am * data.Bm; 
               ab_bound = 0.0;
               xp = atilde*atilde*data.A2 + btilde*btilde*data.B2;
               for (int k = U.l_starts[l]; k < U.l_starts[l+1]; k++) {
                   GaussianECP& g = U.getGaussian(k);
                   ztilde = atilde + btilde + g.a;
                   Tk = Tk_0 / ztilde;
                   Tk = Tk > 1 ? 0.5 * std::exp(Tk) / Tk : SINH_1;
                   ab_bound += std::abs(g.d) * FAST_POW[3](std::sqrt(M_PI/g.a)) * std::exp(xp / ztilde) * Tk;
               }
               ab_bound *= std::exp(-atilde*data.A2 -btilde*data.B2);
               results[l] = (2*l+1)*(2*l+1)* a_bound * b_bound * ab_bound;
           }
       }
   
       void ECPIntegral::compute_shell_pair(ECP &U, GaussianShell &shellA, GaussianShell &shellB, TwoIndex<double> &values, int shiftA, int shiftB) {
       
           ShellPairData data;
           
           // Shift A and B to be relative to U
           const double* C = U.center();
           data.A[0] = shellA.center()[0] - C[0]; 
           data.A[1] = shellA.center()[1] - C[1];
           data.A[2] = shellA.center()[2] - C[2]; 
           data.B[0] = shellB.center()[0] - C[0]; 
           data.B[1] = shellB.center()[1] - C[1];
           data.B[2] = shellB.center()[2] - C[2]; 
       
           // Construct data that will be reused everywhere, and takes account of derivative shifts
           data.LA = shellA.am() + shiftA; 
           data.LB = shellB.am() + shiftB;
           data.maxLBasis = data.LA > data.LB ? data.LA : data.LB;
           data.ncartA = (data.LA+1)*(data.LA+2)/2;
           data.ncartB = (data.LB+1)*(data.LB+2)/2;
       
           data.A2 = data.A[0]*data.A[0] + data.A[1]*data.A[1] + data.A[2]*data.A[2];
           data.Am = sqrt(data.A2);
           data.A_on_ecp = (data.Am < 1e-6); 
           data.B2 = data.B[0]*data.B[0] + data.B[1]*data.B[1] + data.B[2]*data.B[2];
           data.Bm = sqrt(data.B2);
           data.B_on_ecp = (data.Bm < 1e-6);
           double RAB[3] = {data.A[0] - data.B[0], data.A[1] - data.B[1], data.A[2] - data.B[2]};
           data.RAB2 = RAB[0]*RAB[0] + RAB[1]*RAB[1] + RAB[2]*RAB[2];
           data.RABm = sqrt(data.RAB2);
           
           // Prepare the radial integrator
           radInts.buildParameters(shellA, shellB, data);
       
           // Construct coefficients 
           FiveIndex<double> CA(1, data.ncartA, data.LA+1, data.LA+1, data.LA+1);
           FiveIndex<double> CB(1, data.ncartB, data.LB+1, data.LB+1, data.LB+1);
           makeC(CA, data.LA, data.A);
           makeC(CB, data.LB, data.B);
           
           double screens[U.getL() + 1];
           estimate_type2(U, shellA, shellB, data, screens);
       
           // Calculate type1 integrals, if necessary
           values.assign(data.ncartA, data.ncartB, 0.0);
           if (!U.noType1() && screens[U.getL()] > tolerance)
               type1(U, shellA, shellB, data, CA, CB, values);
           
           std::vector<int> l_list; 
           if (data.A_on_ecp && data.B_on_ecp) {
               if (data.LA == data.LB && screens[data.LA] > tolerance && data.LA < U.getL())
                    l_list.push_back(data.LA);
           } else if (data.A_on_ecp && screens[data.LA] > tolerance && data.LA < U.getL()) {
               l_list.push_back(data.LA); 
           } else if (data.B_on_ecp && screens[data.LB] > tolerance && data.LB < U.getL()) {
               l_list.push_back(data.LB); 
           } else {
               for (int l = 0; l < U.getL(); l++) 
                   if (screens[l] > tolerance) l_list.push_back(l); 
           }
           
           // Now all the type2 integrals
           ThreeIndex<double> t2vals(data.ncartA, data.ncartB, 2*U.getL() + 1);
           for (int l : l_list) {
               t2vals.fill(0.0);
               type2(l, U, shellA, shellB, data, CA, CB, t2vals);
   
               for (int m = -l; m <= l; m++) {
                   for(int na = 0; na < data.ncartA; na++) {
                       for (int nb = 0; nb < data.ncartB; nb++) {
                           values(na, nb) += t2vals(na, nb, l+m);
                       }
                   }
               }
           }
       }
       
       void ECPIntegral::left_shell_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 3> &results) {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartA_minus = LA * (LA+1) / 2;
           TwoIndex<double> Q_minus, Q_plus; 
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           if (LA != 0)
               compute_shell_pair(U, shellA, shellB, Q_minus, -1, 0); 
           
           // hack in the exponents to the coefficients
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_plus, 1, 0); 
           
           // Now compile the derivatives
           if (LA != 0) {
               int nA = 0;
               int nA_minus, nA_plus;
               for (int k=LA; k >= 0; k--) {
                   for (int l=LA-k; l>=0; l--) {
                       int m = LA - k - l;
                           
                       for (int nB = 0; nB < ncartB; nB++) {
                           nA_minus = nA_plus = N_INDEX(l, m);
                           results[0](nA, nB) = -k*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                           
                           nA_minus = std::max(0, N_INDEX(l-1, m));
                           nA_plus  = N_INDEX(l+1, m);
                           results[1](nA, nB) = -l*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                           
                           nA_minus = std::max(0, N_INDEX(l, m-1));
                           nA_plus  = N_INDEX(l, m+1);
                           results[2](nA, nB) = -m*Q_minus(nA_minus, nB) + 2.0*Q_plus(nA_plus, nB);
                       }
                       nA += 1;
                   }
               }
           } else {
               for (int nB = 0; nB < ncartB; nB++) {
                   results[0](0, nB) = 2.0*Q_plus(0, nB);
                   results[1](0, nB) = 2.0*Q_plus(1, nB);
                   results[2](0, nB) = 2.0*Q_plus(2, nB);
               }
           }
       }
       
       void ECPIntegral::left_shell_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 6> &results) {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartA_minus = std::max(1, (LA-1) * (LA) / 2);
           TwoIndex<double> Q_minus, Q_plus, Q_0;
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           if (LA > 1)
               compute_shell_pair(U, shellA, shellB, Q_minus, -2, 0); 
           else
               Q_minus.assign(ncartA_minus, ncartB, 0.0);
           
           // hack in the exponents to the coefficients
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_0, 0, 0); 
           
           // and for the l+2
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           compute_shell_pair(U, tempA, shellB, Q_plus, 2, 0); 
   
           // Now compile the derivatives
           int nA = 0;
           int nA_mm, nA_pp, nA_mp, nA_pm;
           for (int k=LA; k >= 0; k--) {
               for (int l=LA-k; l>=0; l--) {
                   int m = LA - k - l;
                       
                   for (int nB = 0; nB < ncartB; nB++) {
                       nA_mm = nA_mp = nA_pp = N_INDEX(l, m); //dxx
                       results[0](nA, nB) = k*(k-1)*Q_minus(nA_mm, nB) - 2.0*(2*k+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
                       
                       nA_mm = std::max(0, N_INDEX(l-1, m)); //dxy
                       nA_pp  = N_INDEX(l+1, m);
                       results[1](nA, nB) = k*l*Q_minus(nA_mm, nB) - 2.0*k*Q_0(nA_pp, nB)
                                           - 2.0*l*Q_0(nA_mm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = std::max(0, N_INDEX(l, m-1)); //dxz
                       nA_pp  = N_INDEX(l, m+1);
                       results[2](nA, nB) = k*m*Q_minus(nA_mm, nB) - 2.0*k*Q_0(nA_pp, nB)
                                           - 2.0*m*Q_0(nA_mm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = std::max(0, N_INDEX(l-2, m)); //dyy
                       nA_mp = N_INDEX(l, m);
                       nA_pp  = N_INDEX(l+2,m);
                       results[3](nA, nB) = l*(l-1)*Q_minus(nA_mm, nB) - 2.0*(2*l+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = std::max(0, N_INDEX(l-1, m-1)); //dyz
                       nA_mp = std::max(0, N_INDEX(l-1, m+1));
                       nA_pm = std::max(0, N_INDEX(l+1, m-1)); 
                       nA_pp  = N_INDEX(l+1, m+1);
                       results[4](nA, nB) = l*m*Q_minus(nA_mm, nB) - 2.0*l*Q_0(nA_mp, nB)
                                           - 2.0*m*Q_0(nA_pm, nB) + 4.0*Q_plus(nA_pp, nB);
   
                       nA_mm = std::max(0, N_INDEX(l, m-2)); //dzz
                       nA_mp = N_INDEX(l, m);
                       nA_pp  = N_INDEX(l,m+2);
                       results[5](nA, nB) = m*(m-1)*Q_minus(nA_mm, nB) - 2.0*(2*m+1)*Q_0(nA_mp, nB)
                                           +4.0*Q_plus(nA_pp, nB);
   
                   }
                   nA += 1;
               }
           }
       }
       
       void ECPIntegral::mixed_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 9> &results) {
           int LA = shellA.am();
           int LB = shellB.am();
           
           int ncartB = (LB+1) * (LB+2) / 2;
           int ncartA = (LA+1) * (LA+2) / 2;
           int ncartB_minus = std::max(1, (LB) * (LB+1) / 2);
           int ncartA_minus = std::max(1, (LA) * (LA+1) / 2);
           int ncartB_plus = (LB+2) * (LB+3) / 2;
           int ncartA_plus = (LA+2) * (LA+3) / 2;
           TwoIndex<double> Q_mm, Q_mp, Q_pm, Q_pp;
           
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0); 
           
           GaussianShell tempA = shellA.copy();
           for (int i = 0; i < tempA.nprimitive(); i++) 
               tempA.coeffs[i] *= tempA.exps[i];
           GaussianShell tempB = shellB.copy();
           for (int i = 0; i < tempB.nprimitive(); i++) 
               tempB.coeffs[i] *= tempB.exps[i];
           
           if (LA > 0) {
               if (LB > 0) {
                   compute_shell_pair(U, shellA, shellB, Q_mm, -1, -1); 
                   compute_shell_pair(U, tempA, shellB, Q_pm, 1, -1);
               } else {
                   Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
                   Q_pm.assign(ncartA_plus, ncartB_minus, 0.0);
               }
               compute_shell_pair(U, shellA, tempB, Q_mp, -1, 1);
           } else if (LB > 0) {
               compute_shell_pair(U, tempA, shellB, Q_pm, 1, -1);
               Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
               Q_mp.assign(ncartA_minus, ncartB_plus, 0.0);
           } else {
               Q_mm.assign(ncartA_minus, ncartB_minus, 0.0);
               Q_mp.assign(ncartA_minus, ncartB_plus, 0.0);
               Q_pm.assign(ncartA_plus, ncartB_minus, 0.0);
           }
           compute_shell_pair(U, tempA, tempB, Q_pp, 1, 1); 
   
           // Now compile the derivatives
           int nA = 0;
           int nB = 0;
           int nA_m[3], nA_p[3], nB_m[3], nB_p[3], AL[3], BL[3];
           for (int ka=LA; ka >= 0; ka--) {
               for (int la=LA-ka; la>=0; la--) {
                   int ma = LA - ka - la;
                   AL[0]=ka; AL[1]=la; AL[2]=ma;
                   nA_m[0] = nA_p[0] = N_INDEX(la, ma);
                   nA_m[1] = std::max(0, N_INDEX(la-1, ma));
                   nA_m[2] = std::max(0, N_INDEX(la, ma-1));
                   nA_p[1] = N_INDEX(la+1,ma);
                   nA_p[2] = N_INDEX(la, ma+1);
                   
                   nB = 0;
                   for (int kb=LB; kb >= 0; kb--) {
                       for (int lb=LB-kb; lb>=0; lb--) {
                           int mb = LB - kb - lb;
                           nB_m[0] = nB_p[0] = N_INDEX(lb, mb);
                           nB_m[1] = std::max(0, N_INDEX(lb-1, mb));
                           nB_m[2] = std::max(0, N_INDEX(lb, mb-1));
                           nB_p[1] = N_INDEX(lb+1,mb);
                           nB_p[2] = N_INDEX(lb, mb+1);
                           BL[0]=kb; BL[1]=lb; BL[2]=mb;
   
                           for (int p = 0; p < 3; p++) {
                               for (int q = 0; q < 3; q++) {
                                   results[3*p+q](nA, nB) = AL[p]*BL[q]*Q_mm(nA_m[p], nB_m[q]) - 2.0*BL[q]*Q_pm(nA_p[p], nB_m[q])
                                       - 2.0*AL[p]*Q_mp(nA_m[p], nB_p[q]) + 4.0*Q_pp(nA_p[p], nB_p[q]);
                               }
                           }
                           
                           nB += 1;
                       }
                   }
                   nA += 1;
               }
           }
       }
       
       void ECPIntegral::compute_shell_pair_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 9> &results) {       
           // First we check centres
           double A[3], B[3], C[3];
           for (int i = 0; i < 3; i++) {
               A[i] = shellA.center()[i];
               B[i] = shellB.center()[i];
               C[i] = U.center()[i];
           }
           
           double dAC = std::abs(A[0] - C[0]) + std::abs(A[1] - C[1]) + std::abs(A[2] - C[2]);
           double dBC = std::abs(B[0] - C[0]) + std::abs(B[1] - C[1]) + std::abs(B[2] - C[2]);
           
           // Calculate shell derivatives
           std::array<TwoIndex<double>, 3> QA, QB;
           if (dAC > 1e-6) 
               left_shell_derivative(U, shellA, shellB, QA);
           if (dBC > 1e-6)
               left_shell_derivative(U, shellB, shellA, QB);
           
           // initialise results matrices
           int ncartA = (shellA.am()+1) * (shellA.am()+2) / 2;
           int ncartB = (shellB.am()+1) * (shellB.am()+2) / 2;
           
           // Now construct the nuclear derivs
           if (dAC > 1e-6) {
               results[0] = QA[0];
               results[1] = QA[1];
               results[2] = QA[2];
               if (dBC > 1e-6) {
                   results[3] = QB[0].transpose();
                   results[4] = QB[1].transpose();
                   results[5] = QB[2].transpose();
                   for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
                   for (int nA = 0; nA < ncartA; nA++) {
                       for (int nB = 0; nB < ncartB; nB++){
                           results[6](nA, nB) = -1.0 * (results[0](nA, nB) + results[3](nA, nB));
                           results[7](nA, nB) = -1.0 * (results[1](nA, nB) + results[4](nA, nB));
                           results[8](nA, nB) = -1.0 * (results[2](nA, nB) + results[5](nA, nB));
                       }
                   }
               } else {
                  results[3] = results[0]; results[3].multiply(-1.0);
                  results[4] = results[1]; results[4].multiply(-1.0);
                  results[5] = results[2]; results[5].multiply(-1.0);
                  for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
               }
           } else if (dBC > 1e-6) {
               results[3] = QB[0].transpose();
               results[4] = QB[1].transpose();
               results[5] = QB[2].transpose();
               results[0] = results[3]; results[0].multiply(-1.0);
               results[1] = results[4]; results[1].multiply(-1.0);
               results[2] = results[5]; results[2].multiply(-1.0);
               for (int i = 6; i < 9; i++) results[i].assign(ncartA, ncartB, 0.0);
           } else {
               // else everything is zero
               for (auto& r : results) r.assign(ncartA, ncartB, 0.0);
           }
       }
   
       void ECPIntegral::compute_shell_pair_second_derivative(ECP &U, GaussianShell &shellA, GaussianShell &shellB, std::array<TwoIndex<double>, 45> &results) {       
           // First we check centres
           double A[3], B[3], C[3];
           for (int i = 0; i < 3; i++) {
               A[i] = shellA.center()[i];
               B[i] = shellB.center()[i];
               C[i] = U.center()[i];
           }
           
           double dAC = std::abs(A[0] - C[0]) + std::abs(A[1] - C[1]) + std::abs(A[2] - C[2]);
           double dBC = std::abs(B[0] - C[0]) + std::abs(B[1] - C[1]) + std::abs(B[2] - C[2]);
           
           // Calculate shell derivatives
           std::array<TwoIndex<double>, 6> QAA, QBB;
           std::array<TwoIndex<double>, 9> QAB;
   
           if (dAC > 1e-6) {
               left_shell_second_derivative(U, shellA, shellB, QAA);
               if (dBC > 1e-6) {
                   left_shell_second_derivative(U, shellB, shellA, QBB);
                   mixed_second_derivative(U, shellA, shellB, QAB);
               }
           } else if (dBC > 1e-6) {
               left_shell_second_derivative(U, shellB, shellA, QBB);
           }
           
           // initialise results matrices
           int ncartA = (shellA.am()+1) * (shellA.am()+2) / 2;
           int ncartB = (shellB.am()+1) * (shellB.am()+2) / 2;
           for (auto& r : results) r.assign(ncartA, ncartB, 0.0);
           
           // Now construct the nuclear derivs
           int jaas[9] = {0, 1, 2, 1, 3, 4, 2, 4, 5};
           int jbbs[9] = {0, 3, 6, 1, 4, 7, 2, 5, 8};
           int jaa, jbb;
           if (dAC > 1e-6) {
               //AA (xx, xy, xz, yy, yz, zz)
               for (int i = 0; i < 6; i++) results[i] = QAA[i]; 
               
               if (dBC > 1e-6) {   
                   // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                   for (int i = 6; i < 15; i++) results[i] = QAB[i-6];
                    //BB (xx, xy, xz, yy, yz, zz) 
                   for (int i = 24; i < 30; i++) results[i] = QBB[i-24].transpose();
   
                   for (int nA = 0; nA < ncartA; nA++) {
                       for (int nB = 0; nB < ncartB; nB++){
                           for (int j = 0; j < 9; j++) {
                               jaa = jaas[j];
                               jbb = jbbs[j];
                               
                               // AC (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                               results[15+j](nA, nB) = -1.0*(QAA[jaa](nA, nB) + QAB[j](nA, nB));
                               
                               // BC (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                               results[30+j](nA, nB) = -1.0*(QBB[jaa](nB, nA) + QAB[jbb](nA, nB));
                               
                               // CC (xx, xy, xz, yy, yz, zz)
                               results[39+jaa](nA, nB) = -results[30+j](nA, nB) -results[15+j](nA, nB); 
                           }
                       }
                   }
               } else {
                   // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
                   for (int i = 6; i < 15; i++) {
                       results[i] = QAA[jaas[i-6]];
                       results[i].multiply(-1.0);
                   }
                    //BB (xx, xy, xz, yy, yz, zz) 
                   for (int i = 24; i < 30; i++) results[i] = QAA[i-24];
               }
           } else if (dBC > 1e-6) {
               //BB (xx, xy, xz, yy, yz, zz)
               for (int i = 24; i < 30; i++) results[i] = QBB[i-24].transpose(); 
               // AB (xx, xy, xz, yx, yy, yz, zx, zy, zz)
               for (int i = 6; i < 15; i++) {
                   results[i] = QBB[jaas[i-6]].transpose();
                   results[i].multiply(-1.0);
               }
                //AA (xx, xy, xz, yy, yz, zz) 
               for (int i = 0; i < 6; i++) results[i] = QBB[i].transpose();
           } 
       }
   
   }
.. _exhale_variable_namespacelibecpint_1a190a564f849660c170e298aba2181d0a:

Variable libecpint::maxL
========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_generate.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::maxL
.. _exhale_function_namespacelibecpint_1_1qgen_1af87f236fd427c9a80540e4117091be15:

Function libecpint::qgen::Q0_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1afd5e9e8fbfdce4c6713251e1f147e5d6:

Function libecpint::qgen::Q0_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp:

Program Listing for File api.cpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp>` (``/Users/robertshaw/devfiles/libecpint/src/lib/api.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
   *      Copyright (c) 2020 Robert Shaw
   *       This file is a part of Libecpint.
   *
   *      Permission is hereby granted, free of charge, to any person obtaining
   *      a copy of this software and associated documentation files (the
   *      "Software"), to deal in the Software without restriction, including
   *      without limitation the rights to use, copy, modify, merge, publish,
   *      distribute, sublicense, and/or sell copies of the Software, and to
   *      permit persons to whom the Software is furnished to do so, subject to
   *      the following conditions:
   *
   *      The above copyright notice and this permission notice shall be
   *      included in all copies or substantial portions of the Software.
   *
   *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
   
   #include "api.hpp"
   #include <iostream>
   #include <cmath>
   #include <cassert>
   #include "mathutil.hpp"
   
   namespace libecpint {
       
       void ECPIntegrator::set_gaussian_basis (
         const int nshells, const double* coords, const double* exponents, const double* coefs, const int* ams, const int* shell_lengths) {
           int ctr = 0;
           min_alpha = 100.0;
           for (int i = 0; i < nshells; i++) {
               ncart += (ams[i]+1)*(ams[i]+2)/2;
               std::array<double, 3> cvec = {coords[3*i], coords[3*i+1], coords[3*i+2]};
               GaussianShell newShell(cvec, ams[i]);
               if (ams[i] > maxLB) maxLB = ams[i];
               for (int n = 0; n < shell_lengths[i]; n++) {
                   newShell.addPrim(exponents[ctr], coefs[ctr]);
                   ctr++;
               }
               min_alpha = newShell.min_exp < min_alpha ? newShell.min_exp : min_alpha;
               shells.push_back(newShell);
           } 
           basis_is_set = true;
       }
       
       void ECPIntegrator::set_ecp_basis(
         const int necps, const double* coords, const double* exponents, const double* coefs, const int* ams, const int* ns, const int* shell_lengths) {
           int ctr = 0;
           for (int i = 0; i < necps; i++) {
               ECP newU(&coords[3*i]);
               for (int n = 0; n < shell_lengths[i]; n++) {
                   newU.addPrimitive(ns[ctr], ams[ctr], exponents[ctr], coefs[ctr]); 
                   ctr++;
               }
               newU.sort();
               ecps.addECP(newU, 0);
           }
           ecp_is_set = true;
       }
       
       void ECPIntegrator::set_ecp_basis_from_library(
         const int necps, const double* coords, const int* charges, const std::vector<std::string> & names, const std::string & share_dir) {
           for (int i = 0; i < necps; i++) {
               std::array<double, 3> center = {coords[3*i], coords[3*i+1], coords[3*i+2]};
               int q = charges[i];
               std::string filename = share_dir + "/xml/" + names[i] + ".xml"; 
               ecps.addECP_from_file(q, center, filename);
           }
           ecp_is_set = true;
       }
       
       void ECPIntegrator::update_gaussian_basis_coords(const int nshells, const double* coords) {
           assert(nshells == shells.size());
           
           for (int i = 0; i < nshells; i++){
               shells[i].localCenter[0] = coords[3*i];
               shells[i].localCenter[1] = coords[3*i+1];
               shells[i].localCenter[2] = coords[3*i+2];
           }
       }
       
       void ECPIntegrator::update_ecp_basis_coords(const int necps, const double* coords) {
           assert(necps == ecps.getN());
           
           for (int i = 0; i < necps; i++) 
               ecps.getECP(i).setPos(coords[3*i], coords[3*i+1], coords[3*i+2]);
       }
       
       void ECPIntegrator::init(const int deriv_) {
           assert(ecp_is_set);
           assert(basis_is_set);
           deriv = std::max(0, std::min(2, deriv_));
           ecpint = std::make_shared<ECPIntegral>(maxLB, ecps.getMaxL(), deriv);
           
           // Determine the internal atom ids
           natoms = 0;
           std::vector<std::array<double, 3>> centers;
           for (auto& s : shells) {
               int i = 0;
               bool found = false;
               while ( !found && (i < centers.size()) ) {
                   double diff = std::abs(centers[i][0] - s.centerVec[0]);
                   diff += std::abs(centers[i][1] - s.centerVec[1]);
                   diff += std::abs(centers[i][2] - s.centerVec[2]);
                   if (diff < 1e-4) {
                       s.atom_id = i;
                       found = true;
                   }
                   i++;
               }
               if (!found) {
                   s.atom_id = natoms;
                   natoms++;
                   centers.push_back({s.centerVec[0], s.centerVec[1], s.centerVec[2]});
               }
           }
           
           for (int n = 0; n < ecps.getN(); n++) {
               ECP& U = ecps.getECP(n);
               int i = 0;
               bool found = false;
               while ( !found && (i < centers.size()) ) {
                   double diff = std::abs(centers[i][0] - U.center_[0]);
                   diff += std::abs(centers[i][1] - U.center_[1]);
                   diff += std::abs(centers[i][2] - U.center_[2]);
                   if (diff < 1e-4) {
                       U.atom_id = i;
                       found = true;
                   }
                   i++;
               }
               if (!found) {
                   U.atom_id = natoms;
                   natoms++;
                   centers.push_back({U.center_[0], U.center_[1], U.center_[2]});
               }
           }
       }
       
       double shell_bound(const int la, const double alpha, const double A2, const double eta) {
           double sigma;
           if (A2 < 1e-6) {
               sigma = 0.5 * (1.0 + eta/alpha);
           } else {
               sigma = 1.0/(2.0*alpha*(eta*eta*A2 + la*(alpha + eta)));
               sigma = sigma * la * (alpha + eta) * (alpha + eta);
           }
           
           double atilde = (1.0 - sigma) * alpha;
           double Na = la / (2*M_EULER*alpha*sigma);
           Na = FAST_POW[la](std::sqrt(Na));
           double result = atilde * eta * A2 / (atilde + eta);
           result = std::exp(-result) * Na;
           return result;
       }
       
       void ECPIntegrator::compute_integrals() {
           // initialise all to zero
           integrals.assign(ncart, ncart, 0.0);
           
           // loop over shells
           TwoIndex<double> tempValues;
           int nshells = shells.size();
       
           double thresh = FAST_POW[maxLB+3]((maxLB+3.0)/min_alpha)*FAST_POW[3](M_PI/(2*maxLB+3.0));
           thresh /= FAST_POW[maxLB](2.0*M_EULER);
           thresh = TWO_C_TOLERANCE / std::sqrt(thresh);
           
           int n1 = 0;
           double acx, acy, acz, A2, sb;
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               std::vector<int> ns;
               
               for (int i = 0; i < ecps.getN(); i++) {
                   ECP& U = ecps.getECP(i);    
                   
                   acx = shellA.center()[0] - U.center_[0]; 
                   acy = shellA.center()[1] - U.center_[1];
                   acz = shellA.center()[2] - U.center_[2];
                   A2 = acx*acx + acy*acy + acz*acz;
                   sb = shell_bound(shellA.l, shellA.min_exp, A2, U.min_exp);
                   if (sb > thresh) ns.push_back(i);
               }
               
               if (ns.size() > 0) {
                   int n2 = 0;
                   for(auto s2=0; s2<=s1; ++s2) {
                       GaussianShell& shellB = shells[s2];
                       int ncartB = shellB.ncartesian();
               
                       TwoIndex<double> shellPairInts(ncartA, ncartB, 0.0);
                   
                       for (auto i : ns) {
                           ECP& U = ecps.getECP(i);
                           ecpint->compute_shell_pair(U, shellA, shellB, tempValues);
                           shellPairInts.add(tempValues);
                       }
   
                       for (int i = n1; i < n1 + ncartA; i++) {
                           for (int j = n2; j < n2 + ncartB; j++) {
                               integrals(i, j) = shellPairInts(i-n1, j-n2);
                               integrals(j, i) = integrals(i, j);
                           }
                       }
                  
                       n2 += ncartB;
                   }
               }
               n1 += ncartA;
           } 
           
           //std::cout << "Total: " << ecpint->skipped + ecpint->zero + ecpint->nonzero << std::endl;
           //std::cout << "Skipped: " << ecpint->skipped << std::endl;
           //std::cout << "Zero: " << ecpint->zero << std::endl;
           //std::cout << "Non-zero: " << ecpint->nonzero << std::endl;
           
       }
       
       void ECPIntegrator::compute_first_derivs() {
           assert(deriv > 0);
           
           for (int n = 0; n < 3*natoms; n++)
               first_derivs.push_back(TwoIndex<double>(ncart, ncart, 0.0));
           
           // loop over shells
           std::array<TwoIndex<double>, 9> tempValues;
           int nshells = shells.size();
           
           int n1 = 0;
           int Aix, Bix, Cix;
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               Aix = shellA.atom_id;
               
               int n2 = 0;
               for(auto s2=0; s2<=s1; ++s2) {
                   GaussianShell& shellB = shells[s2];
                   int ncartB = shellB.ncartesian();
                   Bix = shellB.atom_id;
                   
                   for (int i = 0; i < ecps.getN(); i++) {
                       ECP& U = ecps.getECP(i);
                       Cix = U.atom_id;
                       ecpint->compute_shell_pair_derivative(U, shellA, shellB, tempValues);
                       
                       // work out where to put them
                       for (int n = 0; n < 3; n++) {
                           for (int k = n1; k < n1 + ncartA; k++) {
                               for (int l = n2; l < n2 + ncartB; l++) {
                                   first_derivs[3*Aix+n](k, l) += tempValues[n](k-n1, l-n2);
                                   first_derivs[3*Bix+n](k, l) += tempValues[n+3](k-n1, l-n2);
                                   first_derivs[3*Cix+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                   
                                   if (s2 < s1) {
                                       first_derivs[3*Aix+n](l, k) = first_derivs[3*Aix+n](k, l);
                                       first_derivs[3*Bix+n](l, k) = first_derivs[3*Bix+n](k, l);
                                       first_derivs[3*Cix+n](l, k) = first_derivs[3*Cix+n](k, l);
                                   }
   
                               }
                           }
                       }       
                   }
               
                   n2 += ncartB;
               }
           
               n1 += ncartA; 
           }
       }
       
       void ECPIntegrator::compute_second_derivs() {
           assert(deriv > 1);
           
           int nhess = (3*natoms*(3*natoms+1))/2;
           for (int n = 0; n < nhess; n++)
               second_derivs.push_back(TwoIndex<double>(ncart, ncart, 0.0));
           
           // loop over shells
           std::array<TwoIndex<double>, 45> tempValues;
           int nshells = shells.size();
           
           int n1 = 0;
           int Aix, Bix, Cix;
           int saa, sab, sac, sbb, sbc, scc;
           int ixes[6] = {0, 1, 2, 4, 5, 8};
           int back_ixes[6] = {0, 3, 6, 4, 7, 8};
           int jxes[9] = {0, 3, 6, 1, 4, 7, 2, 5, 8};
           for(auto s1=0; s1<nshells; ++s1) {
               GaussianShell& shellA = shells[s1];
               int ncartA = shellA.ncartesian();
               Aix = shellA.atom_id;
               
               int n2 = 0;
               for(auto s2=0; s2<=s1; ++s2) {
                   GaussianShell& shellB = shells[s2];
                   int ncartB = shellB.ncartesian();
                   Bix = shellB.atom_id;
                   
                   saa = H_START(Aix, Aix, natoms) + 3;
                   sbb = H_START(Bix, Bix, natoms) + 3;
                   sab = H_START(std::min(Aix, Bix), std::max(Aix, Bix), natoms);
                   sab = Aix == Bix ? sab + 3 : sab;
                   
                   for (int i = 0; i < ecps.getN(); i++) {
                       ECP& U = ecps.getECP(i);
                       Cix = U.atom_id;
                       ecpint->compute_shell_pair_second_derivative(U, shellA, shellB, tempValues);
                   
                       // work out where to put them
                       scc = H_START(Cix, Cix, natoms) + 3;
                       sac = H_START(std::min(Aix, Cix), std::max(Aix, Cix), natoms);
                       sac = Aix == Cix ? sac + 3 : sac;
                       sbc = H_START(std::min(Bix, Cix), std::max(Bix, Cix), natoms);
                       sbc = Bix == Cix ? sbc + 3 : sbc;
                       
                       if ((Aix == Cix) || (Bix == Cix)) {
                           if (Bix != Aix) {
                               // two distinct atoms
                               // only need to worry about AA, AB, and BB blocks
                               for (int n = 0; n < 6; n++) {
                                   for (int k = n1; k < n1 + ncartA; k++) {
                                       for (int l = n2; l < n2 + ncartB; l++) {
                                           second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2);
                                           second_derivs[sbb+n](k, l) += tempValues[n+24](k-n1, l-n2);
                                   
                                           if (s1 != s2) {
                                               second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                               second_derivs[sbb+n](l, k) = second_derivs[sbb+n](k, l);
                                           }
                                       }
                                   }
                               }
                               
                               for (int n = 0; n < 9; n++) {
                                   for (int k = n1; k < n1 + ncartA; k++) {
                                       for (int l = n2; l < n2 + ncartB; l++) {
                                           if (Aix > Bix) {
                                               second_derivs[sab+n](k, l) += tempValues[jxes[n]+6](k-n1, l-n2);
                                               if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                           } else {
                                               second_derivs[sab+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                               if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                           }
                                       }
                                   }
                               }
                           } // else everything is zero
                       } else if (Aix == Bix) {
                           // two distinct atoms, need to worry about everything
                           for (int n = 0; n < 6; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2); // aa
                                       second_derivs[saa+n](k, l) += tempValues[n+24](k-n1, l-n2); // bb = aa
                                       second_derivs[scc+n](k, l) += tempValues[n+39](k-n1, l-n2); // cc
                                       second_derivs[saa+n](k, l) += tempValues[ixes[n]+6](k-n1, l-n2); // ab = aa
                                       second_derivs[saa+n](k, l) += tempValues[back_ixes[n]+6](k-n1, l-n2); // ba = aa
                                       
                                       if (s1 != s2) {
                                           second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                           second_derivs[scc+n](l, k) = second_derivs[scc+n](k, l);
                                       }
                                   }
                               }
                           }
                       
                           for (int n = 0; n < 9; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {                        
                                       if (Aix > Cix) {
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+15](k-n1, l-n2);
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+30](k-n1, l-n2); // bc = ac
                                           
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       } else {
                                           second_derivs[sac+n](k, l) += tempValues[n+15](k-n1, l-n2);
                                           second_derivs[sac+n](k, l) += tempValues[n+30](k-n1, l-n2); // bc = ac
                                           
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       }
                                   }
                               }
                           }
                       } else {
                           for (int n = 0; n < 6; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       second_derivs[saa+n](k, l) += tempValues[n](k-n1, l-n2);
                                       second_derivs[sbb+n](k, l) += tempValues[n+24](k-n1, l-n2);
                                       second_derivs[scc+n](k, l) += tempValues[n+39](k-n1, l-n2);
                                   
                                       if (s1 != s2) {
                                           second_derivs[saa+n](l, k) = second_derivs[saa+n](k, l);
                                           second_derivs[sbb+n](l, k) = second_derivs[sbb+n](k, l);
                                           second_derivs[scc+n](l, k) = second_derivs[scc+n](k, l);
                                       }
                                   }
                               }
                           }
                       
                           for (int n = 0; n < 9; n++) {
                               for (int k = n1; k < n1 + ncartA; k++) {
                                   for (int l = n2; l < n2 + ncartB; l++) {
                                       if (Aix > Bix) {
                                           second_derivs[sab+n](k, l) += tempValues[jxes[n]+6](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                       } else {
                                           second_derivs[sab+n](k, l) += tempValues[n+6](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sab+n](l, k) = second_derivs[sab+n](k, l);
                                       }
                                   
                                       if (Aix > Cix) {
                                           second_derivs[sac+n](k, l) += tempValues[jxes[n]+15](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       } else {
                                           second_derivs[sac+n](k, l) += tempValues[n+15](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sac+n](l, k) = second_derivs[sac+n](k, l);
                                       }
                                   
                                       if (Bix > Cix) {
                                           second_derivs[sbc+n](k, l) += tempValues[jxes[n]+30](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       } else {
                                           second_derivs[sbc+n](k, l) += tempValues[n+30](k-n1, l-n2);
                                           if (s1 != s2) second_derivs[sbc+n](l, k) = second_derivs[sbc+n](k, l);
                                       }
                                   }
                               }
                           }
                       }
                       
                   }
               
                   n2 += ncartB;
               }
           
               n1 += ncartA; 
           }
       }
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a3be412799b3edfe3eda545484b300a43:

Function libecpint::qgen::Q0_2_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a999bc28a5d80787f03cc1a3ff1a8c39b:

Function libecpint::qgen::Q0_3_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_3_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_typedef_namespacelibecpint_1a4dc36ca1c5a9247d8bfaac304a7df40f:

Typedef libecpint::Quintuple
============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Typedef Documentation
---------------------


.. doxygentypedef:: libecpint::Quintuple
.. _exhale_variable_namespacelibecpint_1a076d4d1e17ab2a37661480ba095329d7:

Variable libecpint::atom_names
==============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`


Variable Documentation
----------------------


.. doxygenvariable:: libecpint::atom_names
.. _exhale_function_namespacelibecpint_1_1qgen_1ac6caab55a19cf3268cf3c56d3575034b:

Function libecpint::qgen::Q2_2_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_0(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a0bcc591d16e3a934158e56cd0ded726d:

Function libecpint::qgen::Q2_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a31e6957c9ced525cbbdba4a9c443c260:

Function libecpint::qgen::Q1_1_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a12c8c970bff9ab1318e774a4637059fb:

Function libecpint::pow_14
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_14(const double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a09e068e7ce72609cffab0a5aaf998137:

Function libecpint::qgen::Q3_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_generate_8cpp_1aab0234bf29568417ed693e6f0e10e76c:

Variable maxN
=============

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_generate.cpp`


Variable Documentation
----------------------


.. doxygenvariable:: maxN
.. _dir__Users_robertshaw_devfiles_libecpint_src_generated:


Directory generated
===================


|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src>` (``/Users/robertshaw/devfiles/libecpint/src``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

*Directory path:* ``/Users/robertshaw/devfiles/libecpint/src/generated``

Subdirectories
--------------

- :ref:`dir__Users_robertshaw_devfiles_libecpint_src_generated_radial`



.. _exhale_function_namespacelibecpint_1_1qgen_1ab8ec2d5a9021a4daaf5ad8b94db84cf2:

Function libecpint::qgen::Q3_4_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_4_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a3608b27342d00fa484af93de4a9e146d:

Function libecpint::qgen::Q2_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a85e0f26686e72471e0f9eacffb1c75c9:

Function libecpint::qgen::Q5_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_3(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp:

File radial_quad.cpp
====================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/radial_quad.cpp``)
-----------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_radial_quad.cpp.rst





Includes
--------


- ``Faddeeva.hpp``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_radial.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a43fc7ab5cf543daec745b0f6d033ffc5:

Function libecpint::qgen::Q4_5_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_5_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespaceunrol__radial_1a2cd46d9b308d3d493fdd7a516019c717:

Function unrol_radial::collect
==============================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_generated_radial_unrol_radial.py`


Function Documentation
----------------------


.. doxygenfunction:: unrol_radial::collect(q, Q, term)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp:

File gaussquad.cpp
==================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/gaussquad.cpp``)
---------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_gaussquad.cpp.rst





Includes
--------


- ``cassert``

- ``cmath``

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_gaussquad.hpp`)

- ``iostream``






Namespaces
----------


- :ref:`namespace_libecpint`


.. _namespace_makelist:

Namespace makelist
==================


.. contents:: Contents
   :local:
   :backlinks: none





Variables
---------


- :ref:`exhale_variable_namespacemakelist_1a7a96fbd7cb2ac37090089795370aedb7`

- :ref:`exhale_variable_namespacemakelist_1a92f763e70ec614d7cc630b6b3afc201e`

- :ref:`exhale_variable_namespacemakelist_1ae1a361014e097535367c775cc83758fd`
.. _exhale_struct_structlibecpint_1_1_e_c_p:

Struct ECP
==========

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_ecp.hpp`


Struct Documentation
--------------------


.. doxygenstruct:: libecpint::ECP
   :members:
   :protected-members:
   :undoc-members:.. _exhale_function_namespacelibecpint_1a34d3b9ccb2d69e977f74ff88524cf856:

Function libecpint::pow_0
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_0(double)

.. _file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp:

File ecpint.hpp
===============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_new_include_libecpint>` (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint_new/include/libecpint/ecpint.hpp``)
--------------------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecpint.hpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_angular.hpp`)

- ``array``

- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_bessel.hpp`)

- ``config.hpp``

- ``ecp.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_ecp.hpp`)

- ``gaussquad.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gaussquad.hpp`)

- ``gshell.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_gshell.hpp`)

- ``multiarr.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_multiarr.hpp`)

- ``radial.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_radial.hpp`)

- ``vector``



Included By
-----------


- :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_ecpint.cpp`

- :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_api.hpp`




Namespaces
----------


- :ref:`namespace_libecpint`


Classes
-------


- :ref:`exhale_class_classlibecpint_1_1_e_c_p_integral`


Defines
-------


- :ref:`exhale_define_ecpint_8hpp_1a8546f51f524d0baff0bf3f3b321fbc9b`

.. _exhale_function_namespacelibecpint_1_1qgen_1ae9258caecf0017cc7782591e0f75b61e:

Function libecpint::qgen::Q1_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_3_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2d08887dbffc07eb48888c65399b1df9:

Function libecpint::qgen::Q3_3_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_3_5(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ab0da4c56916b9b9ef3a1e82176429161:

Function libecpint::qgen::Q1_5_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp:

File api.cpp
============

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/api.cpp``)
---------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_api.cpp.rst





Includes
--------


- ``api.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_api.hpp`)

- ``cassert``

- ``cmath``

- ``iostream``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`


Functions
---------


- :ref:`exhale_function_namespacelibecpint_1ad93011f81c46d555725bff0a0fc5aaf6`

.. _exhale_function_namespacelibecpint_1a23ce2cda098d601b0fddfb10b971e33f:

Template Function libecpint::operator<<(std::basic_ostream<Ch, Tr>&, std::tuple<Args...> const&)
================================================================================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_multiarr.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::operator<<(std::basic_ostream<Ch, Tr>&, std::tuple<Args...> const&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a42f16a690d170eb768ff7d5dd750c063:

Function libecpint::qgen::Q2_5_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_5_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a2d54034749c5ef29fa9d9902540aa1bf:

Function libecpint::qgen::Q3_5_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q3_5_4(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)

.. _file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp:

File angular.cpp
================

|exhale_lsh| :ref:`Parent directory <dir__Users_robertshaw_devfiles_libecpint_src_lib>` (``/Users/robertshaw/devfiles/libecpint/src/lib``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. contents:: Contents
   :local:
   :backlinks: none

Definition (``/Users/robertshaw/devfiles/libecpint/src/lib/angular.cpp``)
-------------------------------------------------------------------------


.. toctree::
   :maxdepth: 1

   program_listing_file__Users_robertshaw_devfiles_libecpint_src_lib_angular.cpp.rst





Includes
--------


- ``angular.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_angular.hpp`)

- ``bessel.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_bessel.hpp`)

- ``cmath``

- ``mathutil.hpp`` (:ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_mathutil.hpp`)






Namespaces
----------


- :ref:`namespace_libecpint`

.. _exhale_function_namespacelibecpint_1_1qgen_1a47eb555b220e5464d0533a99a06fec5f:

Function libecpint::qgen::Q1_2_3
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_2_3(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a86323740854f95e4faa929dc192aea06:

Function libecpint::pow_5
=========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_5(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a3e60d04afe7a4e07551c971a040eeaba:

Function libecpint::qgen::Q1_5_5
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_5_5(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)

.. _program_listing_file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp:

Program Listing for File bessel.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__Users_robertshaw_devfiles_libecpint_new_src_lib_bessel.cpp>` (``/Users/robertshaw/devfiles/libecpint_new/src/lib/bessel.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* 
    *      Copyright (c) 2020 Robert Shaw
    *      This file is a part of Libecpint.
    *
    *      Permission is hereby granted, free of charge, to any person obtaining
    *      a copy of this software and associated documentation files (the
    *      "Software"), to deal in the Software without restriction, including
    *      without limitation the rights to use, copy, modify, merge, publish,
    *      distribute, sublicense, and/or sell copies of the Software, and to
    *      permit persons to whom the Software is furnished to do so, subject to
    *      the following conditions:
    *
    *      The above copyright notice and this permission notice shall be
    *      included in all copies or substantial portions of the Software.
    *
    *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    *      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    *      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    *      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    *      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    *      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    *      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
   
   #include "bessel.hpp"
   #include "mathutil.hpp"
   #include <cmath>
   #include <cassert>
   #include <iostream>
   
   namespace libecpint {
   
       // Constructor
       BesselFunction::BesselFunction() {}
       BesselFunction::BesselFunction(int _lMax, int _N, int _order, const double accuracy)
       {
           init(_lMax, _N, _order, accuracy);
       }
   
       void BesselFunction::init(int _lMax, int _N, int _order, const double accuracy) {
           // Check parameters
           lMax = _lMax > -1 ? _lMax : 0;
           N = _N > 0 ? _N : 1;
           order = _order > 0 ? _order : 1;
           scale = N/16.0;
       
           // Allocate arrays
           K = new double*[N+1];
           dK = new double**[N+1];
           for (int i = 0; i < N+1; i++) {
               K[i] = new double[lMax + TAYLOR_CUT + 1];
               dK[i] = new double*[TAYLOR_CUT + 1];
               for (int j = 0; j < TAYLOR_CUT + 1; j++)
                   dK[i][j] = new double[lMax + TAYLOR_CUT];
           }
           C = new double[lMax+TAYLOR_CUT];
       
           // Tabulate values
           tabulate(accuracy);
       }
   
       BesselFunction::~BesselFunction() {
           free(K);
           free(dK);
           free(C);
       }
   
       // Tabulate the bessel function values
       int BesselFunction::tabulate(const double accuracy) {
           int retval = 0; // 0 for success, -1 for not converged
           // Series expansion for bessel function, K, is given by:
           // K_l(z) ~ z^l sum_{j=0 to infty} F_j(z) / (2j + 2l + 1)!! 
           // where F_j(z) = e^(-z) * (z^2/2)^j / j!
           int lmax = lMax + TAYLOR_CUT;
       
           double F[order + 1]; // F_j above
       
           K[0][0] = 1.0;
           double z, z2; // z and z^2 / 2
           double ratio; // F_j(z) / (2j+1)!!
           for (int i = 0; i <= N; i++) {
               // Calculate K(z) at equally spaced points z = 16/N to 16
               z = i / (N/16.0);
               z2 = z * z / 2.0;
           
               F[0] = exp(-z);
               ratio = F[0] / DFAC[0];
               K[i][0] = ratio;
           
               // Series expansion for K_0(z)
               int l = order;
               int j;
               for (j = 1; j <= l; j++) {
               
                   if (ratio < accuracy) {
                       // Reached convergence
                       break;
                   } 
               
                   F[j] = F[j-1] * z2 / ((double)j);
                   ratio = F[j] / DFAC[2*j+1];
                   K[i][0] += ratio;
               }
               //if ( ratio > accuracy ) { retval = -1; break; } // Not converged
   
               // Calculate K_l from K_0
               z2 = z;
               for (l=1; l<=lmax; l++) {
                   ratio = 0;
                   for (int m=0; m < j; m++) ratio += F[m]/DFAC[2*l + 2*m + 1]; 
                   K[i][l] = z2 * ratio;
                   z2 *= z; 
               }
       
           }
       
           // Determine coefficients for derivative recurrence
           for (int i = 1; i<lmax; i++) C[i] = i/(2.0*i + 1.0);
           
           // Determine the necessary derivatives from
           // K_l^(n+1) = C_l K_(l-1)^(n) + (C_l + 1/(2l+1))K_(l+1)^(n) - K_l^(n)
           for (int ix = 0; ix < N+1; ix++) {
               // Copy K values into dK
               for (int l = 0; l < lMax+TAYLOR_CUT; l++)
                   dK[ix][0][l] = K[ix][l];
               
               // Then the rest
               for (int n = 1; n < TAYLOR_CUT+1; n++) { 
                   dK[ix][n][0] = dK[ix][n-1][1] - dK[ix][n-1][0];
                   for (int l = 1; l <= lMax + TAYLOR_CUT - n; l++) 
                       dK[ix][n][l] = C[l]*dK[ix][n-1][l-1] + (C[l] + 1.0/(2.0*l + 1.0))*dK[ix][n-1][l+1] - dK[ix][n-1][l];
               }
           }
       
           return retval;
       }   
   
       // Get an upper bound for M_l(z)
       double BesselFunction::upper_bound(const double z, int L) { 
           // find nearest point (on left) in tabulated values
           int ix = std::floor(N*z/16.0);
           int minix = L > 0 ? 1 : 0;
           ix = std::min(N, std::max(minix, ix));
           int lx = std::min(L, lMax);
           return K[ix][lx];
       }
   
       // Calculate modified spherical Bessel function K_l(z), weighted with an exponential factor e^(-z)
       // for l = 0 to lMax. This restricts K(z) to the interval [0,1].
       void BesselFunction::calculate(const double z, int maxL, std::vector<double> &values) {
           if (lMax < maxL) {
               std::cout << "Asked for " << maxL << " but only initialised to maximum L = " << lMax << "\n";
               maxL = lMax;
           }
       
           // Set K_0(z) = 1.0, and K_l(z) = 0.0 (for l != 0) if z <= 0
           if (z <= 0) values[0] = 1.0;
           // Zeroth order case
           // K_l(z) ~ (1-z)*z^l / (2l + 1)!!
           else if (z < SMALL) { 
               values[0] = 1.0 - z;
               for (int l = 1; l <= maxL; l++) values[l] = values[l-1]*z/(2.0*l+1.0);
           } 
           // Large z case
           // K_l(z) ~ R_l(-z)/(2z)
           // where R_l(z) = sum_{k=0 to l} T_l,k(z)
           // where T_l,k(z) = (l+k)!/[k!(l-k)!] * (2z)^{-k}
           else if (z > 16.0) {
               values[0] = 0.5/z;
               for (int l = 1; l <= maxL; l++) {
                   values[l] = values[0];
                   double Rl = 1.0;
                   double Tlk = 1.0;
                   double cof = 1.0;
                   for (int k = 1; k <= l; k++) {
                       cof = (l-k+1)*(l+k)/((double)k);
                       Tlk *= - cof * values[0];
                       Rl += Tlk;
                   }
                   values[l] *= Rl;
               }
           } 
           // SMALL < z < 16 
           // Use Taylor series around pretabulated values in class
           // 5 terms is usually sufficient for machine accuracy
           else {
               // Index of abscissa z in table
               int ix = std::floor(z * scale + 0.5);
               double dz = z - ix/scale; // z - z0
           
               if (fabs(dz) < 1e-12) { // z is one of the tabulated points
                   for (int l = 0; l <= maxL; l++) values[l] = K[ix][l];
               } else {
           
                   // Calculate (dz)^n/n! terms just once
                   double dzn[TAYLOR_CUT+1];
                   dzn[0] = 1.0;
                   for (int n = 1; n < TAYLOR_CUT + 1; n++)
                       dzn[n] = dzn[n-1] * dz / ((double) n);
           
                   // Now tabulate the values through Taylor seris
                   // K(z) ~ sum_{n=0 to 5} K^(n)(z0)(z-z0)^n / n!
                   for (int l = 0; l <= maxL; l++) {
                       values[l] = 0.0;
                       for (int n = 0; n < TAYLOR_CUT+1; n++)
                           values[l] += dzn[n] * dK[ix][n][l]; 
                   }
               }
           }
       }
       
       // Calculate a modified spherical bessel function value at a point for only a single L
       // method the same as in calculate for multiple L, but with efficiencies
       double BesselFunction::calculate(const double z, int L) {
           double value = 0.0;
           
           if (z <= 0) value = 1.0;
           else if (z < SMALL) {
               value = 1.0 - z;
               for (int k = 1; k < L+1; k++)
                   value *= z/(2.0*L+1.0);
           } else if (z > 16.0) {
               double v0 = 0.5/z;
               value = 1.0;
               double Tlk = 1.0;
               for (int k = 1; k < L+1; k++) {
                   Tlk *= -v0 * (L - k +1)*(L+k)/(double(k));
                   value += Tlk;
               }
               value = v0 * value;
           } else {
               int ix = std::floor(z * scale + 0.5);
               double dz = z - ix/scale; // z - z0
               double dzn = 1.0;
               for (int n = 0; n < TAYLOR_CUT+1; n++) {
                   value += dzn * dK[ix][n][L]; 
                   dzn *= dz / (n+1);
               }
           }
           
           return value;
       }
   }
.. _exhale_function_namespacelibecpint_1_1qgen_1a54295e912bd54f3f8c4e67c9d8497b6d:

Function libecpint::qgen::Q0_0_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_0_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a36d15d50e1c9979ab73acf66f1019304:

Function libecpint::pow_m1
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_m1(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1a58617819fd10d1083afc396fbc79e387:

Function libecpint::qgen::Q1_1_1
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q1_1_1(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1aa957a79b70df8879d0abbfb12a2ce49b:

Function libecpint::qgen::rolled_up
===================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_qgen.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::rolled_up(int, int, int, ThreeIndex<double>&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a29d4cca2d7ad9972c8ae888f309ef52c:

Function libecpint::qgen::Q4_4_0
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q4_4_0(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1ac8041349c5e5382f5589ab5556c82060:

Function libecpint::qgen::Q0_2_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q0_2_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_variable_namespacemakelist_1a7a96fbd7cb2ac37090089795370aedb7:

Variable makelist::file
=======================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_src_makelist.py`


Variable Documentation
----------------------


.. doxygenvariable:: makelist::file
.. _exhale_function_namespacelibecpint_1_1qgen_1ab9eaa8ccb9792d3efb90ed7143af727a:

Function libecpint::qgen::Q2_2_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_2_2(const ECP&, const GaussianShell&, const GaussianShell&, const FiveIndex<double>&, const FiveIndex<double>&, const TwoIndex<double>&, const TwoIndex<double>&, double, double, const RadialIntegral&, const AngularIntegral&, const RadialIntegral::Parameters&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1_1qgen_1a65d824b28264272e12f6b2487b639711:

Function libecpint::qgen::Q2_3_4
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q2_3_4(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
.. _exhale_function_namespacelibecpint_1a11466fdaf07952a659fe9ab5cd634743:

Function libecpint::pow_m2
==========================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_src_lib_mathutil.cpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::pow_m2(double)
.. _exhale_function_namespacelibecpint_1_1qgen_1ae9d2f56806b38c9ea0b1c3d8af64c9f4:

Function libecpint::qgen::Q5_5_2
================================

- Defined in :ref:`file__Users_robertshaw_devfiles_libecpint_new_include_libecpint_qgen.hpp`


Function Documentation
----------------------


.. doxygenfunction:: libecpint::qgen::Q5_5_2(ECP&, GaussianShell&, GaussianShell&, FiveIndex<double>&, FiveIndex<double>&, TwoIndex<double>&, TwoIndex<double>&, double, double, RadialIntegral&, AngularIntegral&, ThreeIndex<double>&)
