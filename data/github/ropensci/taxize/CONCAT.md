taxize
======



[![Project Status: Active – The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)
[![cran checks](https://cranchecks.info/badges/worst/taxize)](https://cranchecks.info/pkgs/taxize)
[![R-CMD-check](https://github.com/ropensci/taxize/workflows/R-CMD-check/badge.svg)](https://github.com/ropensci/taxize/actions/)
[![codecov](https://codecov.io/gh/ropensci/taxize/branch/master/graph/badge.svg)](https://codecov.io/gh/ropensci/taxize)
[![rstudio mirror downloads](https://cranlogs.r-pkg.org/badges/taxize)](https://github.com/r-hub/cranlogs.app)
[![cran version](https://www.r-pkg.org/badges/version/taxize)](https://cran.r-project.org/package=taxize)


`taxize` allows users to search over many taxonomic data sources for species names (scientific and common) and download up and downstream taxonomic hierarchical information - among other things.

The taxize book: https://taxize.dev

Package documentation: https://docs.ropensci.org/taxize/


## Installation

### Stable version from CRAN


```r
install.packages("taxize")
```

### Development version from GitHub

Windows users install Rtools first.


```r
install.packages("remotes")
remotes::install_github("ropensci/taxize")
```


```r
library('taxize')
```

## Screencast

<a href="https://vimeo.com/92883063"><img src="man/figures/screencast.png" width="400"></a>

## Contributing

See our [CONTRIBUTING](https://github.com/ropensci/taxize/blob/master/.github/CONTRIBUTING.md) document.

## Contributors

Collected via GitHub Issues: honors all contributors in alphabetical order. Code contributors are in bold.

[afkoeppel](https://github.com/afkoeppel) - [afredstonhermann](https://github.com/afredstonhermann) - [ahhurlbert](https://github.com/ahhurlbert) - [albnd](https://github.com/albnd) - [Alectoria](https://github.com/Alectoria) - [andzandz11](https://github.com/andzandz11) - **[anirvan](https://github.com/anirvan)** - [antagomir](https://github.com/antagomir) - **[arendsee](https://github.com/arendsee)** - [ArielGreiner](https://github.com/ArielGreiner) - [arw36](https://github.com/arw36) - [ashenkin](https://github.com/ashenkin) - **[ashiklom](https://github.com/ashiklom)** - [benjaminschwetz](https://github.com/benjaminschwetz) - **[benmarwick](https://github.com/benmarwick)** - [bienflorencia](https://github.com/bienflorencia) - [binkySallly](https://github.com/binkySallly) - [bomeara](https://github.com/bomeara) - [BridgettCollis](https://github.com/BridgettCollis) - [bw4sz](https://github.com/bw4sz) - **[cboettig](https://github.com/cboettig)** - [cdeterman](https://github.com/cdeterman) - [ChrKoenig](https://github.com/ChrKoenig) - [chuckrp](https://github.com/chuckrp) - [clarson2191](https://github.com/clarson2191) - [claudenozeres](https://github.com/claudenozeres) - [cmzambranat](https://github.com/cmzambranat) - [cparsania](https://github.com/cparsania) - [daattali](https://github.com/daattali) - [DanielGMead](https://github.com/DanielGMead) - [DarrenObbard](https://github.com/DarrenObbard) - [davharris](https://github.com/davharris) - [davidvilanova](https://github.com/davidvilanova) - [diogoprov](https://github.com/diogoprov) - **[dlebauer](https://github.com/dlebauer)** - [dlenz1](https://github.com/dlenz1) - [dougwyu](https://github.com/dougwyu) - [dschlaep](https://github.com/dschlaep) - **[EDiLD](https://github.com/EDiLD)** - [edwbaker](https://github.com/edwbaker) - [emhart](https://github.com/emhart) - [eregenyi](https://github.com/eregenyi) - [fdschneider](https://github.com/fdschneider) - [fgabriel1891](https://github.com/fgabriel1891) - [fischhoff](https://github.com/fischhoff) - **[fmichonneau](https://github.com/fmichonneau)** - **[fozy81](https://github.com/fozy81)** - **[gedankenstuecke](https://github.com/gedankenstuecke)** - [gimoya](https://github.com/gimoya) - [GISKid](https://github.com/GISKid) - [git-og](https://github.com/git-og) - [glaroc](https://github.com/glaroc) - **[gpli](https://github.com/gpli)** - [gustavobio](https://github.com/gustavobio) - [hlapp](https://github.com/hlapp) - **[ibartomeus](https://github.com/ibartomeus)** - **[Ironholds](https://github.com/Ironholds)** - [jabard89](https://github.com/jabard89) - [jangorecki](https://github.com/jangorecki) - **[jarioksa](https://github.com/jarioksa)** - [jebyrnes](https://github.com/jebyrnes) - **[jeroen](https://github.com/jeroen)** - **[jimmyodonnell](https://github.com/jimmyodonnell)** - [joelnitta](https://github.com/joelnitta) - [johnbaums](https://github.com/johnbaums) - [jonmcalder](https://github.com/jonmcalder) - [jordancasey](https://github.com/jordancasey) - **[josephwb](https://github.com/josephwb)** - [jsgosnell](https://github.com/jsgosnell) - [JulietteLgls](https://github.com/JulietteLgls) - **[jwilk](https://github.com/jwilk)** - [kamapu](https://github.com/kamapu) - **[karthik](https://github.com/karthik)** - **[katrinleinweber](https://github.com/katrinleinweber)** - [KevCaz](https://github.com/KevCaz) - [kgturner](https://github.com/kgturner) - [kmeverson](https://github.com/kmeverson) - [Koalha](https://github.com/Koalha) - **[ljvillanueva](https://github.com/ljvillanueva)** - **[maelle](https://github.com/maelle)** - [Markus2015](https://github.com/Markus2015) - [matutosi](https://github.com/matutosi) - [mcsiple](https://github.com/mcsiple) - [MikkoVihtakari](https://github.com/MikkoVihtakari) - [millerjef](https://github.com/millerjef) - [miriamgrace](https://github.com/miriamgrace) - [MK212](https://github.com/MK212) - [mpnelsen](https://github.com/mpnelsen) - [MUSEZOOLVERT](https://github.com/MUSEZOOLVERT) - [nate-d-olson](https://github.com/nate-d-olson) - [nmatzke](https://github.com/nmatzke) - [npch](https://github.com/npch) - [ocstringham](https://github.com/ocstringham) - [p-neves](https://github.com/p-neves) - [p-schaefer](https://github.com/p-schaefer) - [padpadpadpad](https://github.com/padpadpadpad) - [paternogbc](https://github.com/paternogbc) - **[patperu](https://github.com/patperu)** - [pederengelstad](https://github.com/pederengelstad) - [philippi](https://github.com/philippi) - [Phylloxera](https://github.com/Phylloxera) - **[pmarchand1](https://github.com/pmarchand1)** - [pozsgaig](https://github.com/pozsgaig) - [PrincessPi314](https://github.com/PrincessPi314) - [pssguy](https://github.com/pssguy) - **[raredd](https://github.com/raredd)** - [rec3141](https://github.com/rec3141) - **[Rekyt](https://github.com/Rekyt)** - [RodgerG](https://github.com/RodgerG) - [rossmounce](https://github.com/rossmounce) - [sariya](https://github.com/sariya) - [sastoudt](https://github.com/sastoudt) - [scelmendorf](https://github.com/scelmendorf) - **[sckott](https://github.com/sckott)** - [SimonGoring](https://github.com/SimonGoring) - [snsheth](https://github.com/snsheth) - [snubian](https://github.com/snubian) - [Squiercg](https://github.com/Squiercg) - [sunray1](https://github.com/sunray1) - **[taddallas](https://github.com/taddallas)** - [tdjames1](https://github.com/tdjames1) - [tmkurobe](https://github.com/tmkurobe) - [toczydlowski](https://github.com/toczydlowski) - [tpaulson1](https://github.com/tpaulson1) - [tpoisot](https://github.com/tpoisot) - **[TrashBirdEcology](https://github.com/TrashBirdEcology)** - **[trvinh](https://github.com/trvinh)** - **[vijaybarve](https://github.com/vijaybarve)** - [wcornwell](https://github.com/wcornwell) - [willpearse](https://github.com/willpearse) - [wpetry](https://github.com/wpetry) - [yhg926](https://github.com/yhg926) - **[zachary-foster](https://github.com/zachary-foster)**

## Road map

Check out our [milestones](https://github.com/ropensci/taxize/milestones) to see what we plan to get done for each version.

## Meta

* Please [report any issues or bugs](https://github.com/ropensci/taxize/issues).
* License: MIT
* Get citation information for `taxize` in R doing `citation(package = 'taxize')`
* Please note that this package is released with a [Contributor Code of Conduct](https://ropensci.org/code-of-conduct/). By contributing to this project, you agree to abide by its terms.

[![rofooter](https://ropensci.org/public_images/github_footer.png)](https://ropensci.org)
taxize 0.9.99
=============

### DEFUNCT

* `tnrs()` and `tnrs_sources()` functions are defunct. The service has been unreliable for years now, and AFAICT is down for good. Associated changes have been made throughout the package, eg. `resolve()` no longer has an option for tnrs, etc. (#841) (#842)

### MINOR IMPROVEMENTS

* new article/vignette added on issues with taxonomic ranks, e.g., "NCBI is weird", and how rank information is maintained and used within taxize (#852)
* vignettes are no longer on cran - find them at the docs site linked in DESCRIPTION (#855)
* re-instate a `tol_resolve()` test following new version of `rotl` package on cran (#816)
* improve `class2tree()` function documentation regarding how the function works in more detail (#849) (#851)
* improvements for WORMS, applies to functions `worms_downstream()`, `children(..., db="worms")` and `downstream(..., db="worms")`: now paginate automatically for the user to get all results, and allow parameter `marine_only` to be passed through the high level functions `children()`/`downstream()` down to `worrms::wm_children()` where it toggles whether marine only results are returned (#848) thanks @oharac !

### BUG FIXES

* fix to `ncbi_downstream()` (which cascades up to `downstream(..., db="ncbi")`): an unneeded line of code was removed that was also throwing an error in some cases (#850)
* fixes for WORMS ranks, applies to functions `worms_downstream()`, `children(..., db="worms")` and `downstream(..., db="worms")`: added ranks `epifamily` and `infraphylum`. In addition, when a rank is missing in data returned from WORMS, we'll change the missing rank to "no rank" (#847)


taxize 0.9.98
=============

### MINOR IMPROVEMENTS

* improve `worms_downstream()` docs: make it clear that users can use parameters passed down to `worrms::wm_children()` (#831)
* improve `get_pow_()` docs: add section on rate limits, what are rate limits for KEW POW and a user facing resolution (#836)
* add 8 new rank names (via NCBI) to the reference rank data.frame (`rank_ref`) in the package: biotype, forma specialis, isolate, pathogroup, series, serogroup, serotype, and strain - queries from `downstream()` and other functions that rely on relative rank information should not fail anymore when they contain these 8 rank names  (#830)

### BUG FIXES

* new `rank_ref_zoo` reference data.frame specfically for zoological rank types - right now only used for WORMS. main difference is section/subsection in `rank_ref_zoo` are nested between the order and family, whereas in `rank_ref` (used for all other data sources) section/subsection are on the genus rank level (#833)
* NCBI introduced a new rank "clade", or at least are using it a lot more often - often used instead of "no rank". This was causing some problems in `class2tree()`. Problem sorted out now (#835) (#838) (#839) (#840)


taxize 0.9.97
=============

### NEW FEATURES

* Many of the functions in taxize share similar types of inputs (e.g., scientific names, or common names), but many different parameter names are used to refer to the same thing. We've standardized parameter names to make user understanding easier as the user uses different functions. TLDR: `sci` will always only accept a scientific name; `com` accdepts only a common name; `id` accepts a taxonomic identifier; `sci_com` accepts or scientific or common name; `sci_id` accepts a scientific name or taxonomic identifier. In most cases we have retained the old parameter name and you can still use it but you get a warning with information. In a future package version the replaced parameters will be removed completely. See https://github.com/ropensci/taxize/issues/723 for tables covering the functions affected, their old and new parameter names (#723) (#829)

### MINOR IMPROVEMENTS

* upgraded APG datasets (`apg_families` and `apg_order`) to v14 (from July 2017) (#827)

### BUG FIXES

* fix to `worrms_downstream()`: three rank names were not accounted for in our internal set of ranks (suptertribe, subterclass, parvorder) (#824)
* `classification.gbifid` was returning a duplicate last taxon, i.e., the last two rows in the output data.frame were the same. fixed. (#825)
* fixed issue in `lowest_common()` due to problem in `classification.uid()` when a taxon UID was merged into another taxon (#828)


taxize 0.9.96
=============

### NEW FEATURES

* NatureServe has a new API version; the package natserv (https://docs.ropensci.org/natserv/) has a complete overhaul for the new API - taxize interfaces to NatureServe updated. Only user facing change should be that we've moved to using just the final numeric part of the NatureServe taxonomic identifiers as `ELEMENT_GLOBAL.2.` part is redundant for every identifier (#823)

### MINOR IMPROVEMENTS

* `rankagg()` and `tax_agg()` fixes: `rankagg()` examples now conditional on availability of `vegan` as it should be, and now real abundance data are used in the example. `tax_agg()` fixes species name ordering in `dune` data  (#822) work by @jarioksa

### BUG FIXES

* fixed a bug in `class2tree()` (#818) (#820) thx to @adriangeerre for the report & the fix by @trvinh
* fix to `worms_downstream()`: user encountered a rank name ("phylum (division)") we hadn't dealt with yet for worms (#821) thx @msweetlove for the report


taxize 0.9.95
=============

### NEW FEATURES

* gains new functions: `bold_children()`, `bold_downstream()` and new S3 methods for `boldid`: `children.boldid` and `downstream.boldid`. Beware that these new methods are built on top of a function that scrapes BOLD's website - their API doesn't provide access to taxonomic children (only parents) - so we've taken the liberty of trying to liberate that data and make it easy to access (#817)

### MINOR IMPROVEMENTS

* fix to a failing `tol_resolve()` test - upstream package rotl had the bug; told maintainer about it and he'll submit a new version soon; affected commented out for now  (#814)


taxize 0.9.94
=============

### NEW FEATURES

* `synonyms()` gains a method for Plants of the World Online (`synonyms.pow`); and new associated helper function `pow_synonyms()` used within `synonyms.pow` (#812)

### MINOR IMPROVEMENTS

* change to `iucn_summary()` to allow `get_iucn()` failures and the function to still proceed - to make a better experience when passing in more than 1 name (#810)
* fixed non-ASCII string in the `species_plantarum_binomials` dataset

### BUG FIXES

* `classification()` for data source GBIF wasn't working when the queried taxon rank was below species (e.g., subspecies or variety); GBIF didn't return the same fields for ranks below species, so we tack on that information with a bit of extra code (#809)
* fix sorting of results in `classification()` with data source GBIF; at some point introduced bug in how results were sorted  (#811)


taxize 0.9.93
=============

### DEFUNCT

* `use_eol()` is now defunct; EOL no longer requires an API key (#749) (#803) thanks @padpadpadpad

### NEW FEATURES

* http to https upgrades for the following functions: `vascan_search()`, `taxize_cite()`, all `*_ping()` functions, `get_wormsid()`, `get_pow()`, `get_eolid()`, `get_gbifid()`, `get_boldid()`, `gbif_name_usage()`; and in various places in documentation (#799)

### MINOR IMPROVEMENTS

* `classification.uid()` now does batch HTTP requests. NCBI Entrez web service allows requests with up to 50 identifiers; @zachary-foster did the work to make this method now use batch queries so its much faster (#678) (#798)
* `class2tree()` improvement in taxonomy rank indexing (#805) work by @trvinh
* fix to description of `taxon_state_messages` parameter in the `taxize_options` help file  (#806)
* taxize package datasets now loaded into a package environment (#792)

### BUG FIXES

* `ncbi_children()` now accepts numeric and character class ids (#800)
* fix `classification.gbifid()`, was failing because GBIF changed the order of results (#802)
* `class2tree()` fix: problem was due ultimately to a bug in `classification.gbifid()` (see line above)  (#801)
* `tax_rank()` fix - for `db="ncbi"` was not giving correct ranks for queried names - was due to a change in `classification.uid` (#804)
* fix bug in `get_eolid()` when filtering by data source lead to no results (#808)
* fix for `ncbi_downstream` (and thereby fix for `downstream()` with `db="ncbi"`): for some taxa a query to NCBI resulted in children as well the queried name itself, and the next query would give the same results, leading to an endless while loop - now we remove the taxon itself that was queried to prevent this (#807)


taxize 0.9.92
=============

### DEFUNCT

COL introduced rate limiting recently in 2019 - which has made the API
essentially unusable - CoL+ is coming soon and we'll incorporate it here when it's stable. see https://github.com/ropensci/colpluz for the in development R client (#796)

### NEW FEATURES

* gains new function `gn_parse()` to access the Global Names scientific name parser. it's a super fast parser. see the section on name parsers (https://docs.ropensci.org/taxize/reference/index.html#section-name-parsers) for the 3 functions that do name parsing  (#794)
* dropped packages from imports: reshape2, stringr, plyr (#795)
* `get_wormsid()` gains two new parameters: `fuzzy` and `marine_only`; both are passed through to `worrms::wm_records_name()`/`worrms::wm_records_name()` (#790)

### MINOR IMPROVEMENTS

* no longer running taxon state examples on check (#791)
* vignettes have names now in the pkg docs site (#772)
* update docs for new roxygen2 version that suppoprts R6 (#793)
* gains dataset `worrms_ranks` to apply rank names in cases where WORMS fails to return rank names in their data
* remove a `get_tpsid()` example that passes in names as factors; `get_*` functions no longer accept factors

### BUG FIXES

* fix to `classification.tpsid()`: change to an internal fxn changed its output; fix for that (#797)
* fix `get_boldid()`: when filtering (e.g., w/ `rank`, `division`, `parent`) returned no match, `get_boldid` was failing on downstream parsing; return NA now
* fix `get_wormsid_()`: was missing `marine_only` and `fuzzy` parameters
* fix `pow_search()`: an if statement was leading to length > 1 booleans
* fix `synonyms()`: an if statement in internal fxn `process_syn_ids` was leading to length > 1 booleans
* fix `classification.gbifid`: select columns only if they exist instead of failing on plucking non-existtent columns


taxize 0.9.91
=============

### NEW FEATURES

* `get_ids()` gains a new parameter `suppress` (default:`FALSE`) to toggle pakage `cli` messages stating which database is being worked on (#719)

### MINOR IMPROVEMENTS

* the following datasets are now available when the package is not loaded, so functions that use these datasets can now be called with package namespace like `taxize::downstream()`: `rank_ref`, `theplantlist`, `apg_families`, `apg_orders`  (#777) (#781)
* add new documentation site url (https://docs.ropensci.org/taxize/) to DESCRITPION file (#774) (@jeroen)
* fix links in README to issues label of new potential data sources (#782) (@katrinleinweber)
* more or less all functions that take as input the output of `get_*` functions have S3 methods that dispatch on those `get_*` output classes. however, you can still pass in a `db` parameter, which is IGNORED when dispatching on the input class. the `db` parameter is used (not ignored) when passing in a taxon id as character/numeric/etc. now these functions (children, classification, comm2sci, sci2comm, downstream, id2name, synonyms, upstream) warn when the user passes a `db` value which will be ignored (#780)
* The NCBI Entrez API often throws errors for users of this and other packages related to HTTP version used by the client; we now hard code the http version to HTTP/1.1 via the curl option `http_version=2L` across all Entrez requests (#783)

### BUG FIXES

* fixes to `col_search()`: COL now does rate limiting (if you make too many requests within a time period they will stop allowing requests from your IP address/your computer); documented rate limiting, what I know at least; changed `checklist` parameter behavior: years 2014 and back dont provide JSON, so we return `xml_document` objects now for those years that the user can parse themselves (#786)
* `tax_rank` somehow (my bad) had two `.default` methods. previous behavior is the same as current behavior (this version) (#784)
* fix `ncbi_children()`: fixed regex that was supposed to flag ambiguous taxa only, it was supposed to flag `sp.` and `spp.`, but was including `subsp.`, which we didn't want included (#777) (#781)
* another fix to `ncbi_children()`: when ID is passed rather than a name, we need to then set `id=NULL` after switching to the equivalent taxononmic name internally to avoid getting duplicate data back (#777) (#781)


taxize 0.9.9
============

### NEW FEATURES

* update all EUBON functions to use their new API version; `eubon_search()` gains new params `limit` and `page`; other eubon functions have no pagination  (#766)
* change base url in `ipni_search()` from http to https, via (#773)

### MINOR IMPROVEMENTS

* change `synonyms()` to always return `NA` for name not found, and always return a zero row data.frame when name found BUT no synonyms found; updated docs to indicate better what's returned (#763) (#765)
* COL sometimes returns control characters in the XML payload; these can't be parsed by the `xml2` package, so we have to remove them using regex; we throw a message when we're doing this so the user knows (#768)
* docs typos fixes (#770)
* update `classification()` docs with a new `EOL` section discussing that EOL does not have good failure behavior, and what to expect from them (#775)
* the following datasets are now available when the package is not loaded, so functions that use these datasets can now be called with package namespace like `taxize::downstream()`: `rank_ref`, `theplantlist`, `apg_families`, `apg_orders`  (#777)
* `sci2comm()` and `comm2sci()` improvements: for `db="ncbi"` we no longer stop with error when when there's no results for a query; instead we return `character(0)`. In addition, now all data source options for both functions now return `character(0)` when there's no results for a query (#778)
* `id2name.uid()` now actually passes on `...` internally for curl options

### BUG FIXES

* fix `get_nbnid()`: was returning non-taxon entities, have ot add `idxtype:TAXON` to the `fq` query (#761)
* fixes for `as.eolid()` and `as.colid()` - don't run through helper function that was raising error on HTTP 404/etc., dont want to fail  (#762)
* fix to `class2tree()`: set root node name to NA if it does not exist, ITIS does not set a root node (#767) (#769) work by @gpli
* fix to `ipni_search()`: IPNI changed parameter names, fixes for that; and now returning tibble's instead of data.frame's (#773) thanks @joelnitta !
* fix `ncbi_children()`: fixed regex that was supposed to flag ambiguous taxa only, it was supposed to flag `sp.` and `spp.`, but was including `subsp.`, which we didn't want included (#777)
* another fix to `ncbi_children()`: when ID is passed rather than a name, we need to then set `id=NULL` after switching to the equivalent taxononmic name internally to avoid getting duplicate data back (#777)


taxize 0.9.8
============

### NEW FEATURES

* all `get_*` functions gain some new features (associated new fxns are `taxon_last` and `taxon_clear`): a) nicer messages printed to the console when iterating through taxa, and a summary at the end of what was done; and b) state is now saved when running `get_*` functions. That is, in an object external to the `get_*` function call we keep track of what happened, so that if an error is encountered, you can easily restart where you left off; this is especially useful when dealing with a large number of inputs to a `get_*` function. To utilize, pass the output of `taxon_last()` to a `get_*` function call. Associated with these changes are new package imports: R6, crayon and cli (#736) (#757)
* gains a new function `taxize_options()` to set options when using taxize. the first reason for the function is to set two options for the above item for `get_*` functions: `taxon_state_messages` to allow taxon state tracking messages in `get_*` functions or not, and `quiet=TRUE` quiets output from the `taxize_options()` function itself

### MINOR IMPROVEMENTS

* in `id2name()` and `worms_downstream()` use `worrms::wm_record` instead of `worrms::wm_record_` for newest version of `worrms` (#760)
* many `get_*` functions and `col_downstream()` parameter `verbose` changed to `messages` to not conflict with a `verbose` curl options parameter passed in to `crul`

### BUG FIXES

* fix to http request processing for COL - sometimes errors, and gives a message in the response body, but DOES NOT give the appropriate error HTTP status code - need to always do a check for COL responses (#755) (#756) thanks @dougwyu
* fix to `gbif_downstream()` - GBIF in some cases returns a rank of "unranked", which we hadn't accounted for in internal rank processing code (#758) thanks @ocstringham


taxize 0.9.7
============

### MINOR IMPROVEMENTS

* `class2tree()` gains node labels when present (#644) (#748) thanks @gpli
* change documentation to use markdown (#658) (#746) thanks @Rekyt


taxize 0.9.6
============

### NEW FEATURES

* gains new functions for Kew's Plants of the World: `get_pow()`, `get_pow_()`, `as.pow()`, `classification.pow()`, `pow_search()`, and `pow_lookup()` (#598) (#739)
* we now pass a user agent string in all HTTP requests to the various data sources so they know its coming from `taxize`. the string will look something like `r-curl/3.3 crul/0.7.0 rOpenSci(taxize/0.9.6)`, including the versions of the `curl` R pkg, the `crul` package, and the `taxize` package (#662)
* change to `get_colid` functionality: we weren't paginating for the user when there were more than 50 results for a query; we now paginate for the user using async HTTP requests; this means that some requests will take longer than they did before if they have more than 50 results; this is a good change given that you get all the results for your query now (#743)
* change across most `get_*` functions: in some of the `get_*` functions we tried for a direct match (e.g., `"Poa" == "Poa"`) and if one was found, then we were done and returned that record. however, we didn't deploy the same logic across all `get_*` functions. Now all `get_*` functions check for a direct match. Of course if there is a direct match with more than 1 result, you still get the prompt asking you which name you want. (#631) (#734)

### MINOR IMPROVEMENTS

* Make separate `taxize-authentication` manual file covering authentication information across the package (#681)
* new case study vignette added (#544) (#721) thanks @fozy81
* add note to `gnr_resolve()` docs about age of datasets used in the Global Names Resolver, and how to access age of datasets (#737)
* `get_eolid()` fixes: gains new attribute `pageid`; `uri`'s given are updated to EOL's new URL format; `rank` and `datasource` parameters were not documented, now are; we no longer use short names for data sources within EOL, but instead use their full names  (#702) (#742)
* `col_search()` now returns attributes on the output data.frame's with number of results found and returned, and other metadata about the search 
* `gnr_datasources()` loses the `todf` parameter; now always returns a data.frame and the data.frame has all the columns, whereas the default call returned a limited set of columns in previous versions

### BUG FIXES

* fix bug in `get_wormsid()`, was failing when there was a direct match found with more than 1 result (#740)
* fix across all `get_*` functions: linting of the input to the `rows` parmeter was failing with a vector of values in some cases (#741)
* fix to `iucn_summary()`; we weren't passing on the API key internally correctly (#735) thanks @PrincessPi314 for the report

taxize 0.9.5
============

### DEFUNCT

* `iucn_summary_id()` is defunct, use `iucn_summary()` instead

### NEW FEATURES

* `col_downstream()` gains parameter `extant_only` (logical) to optionally keep extant taxa only (#714) thanks @ArielGreiner for the inquiry
* `downstream()` gains another `db` options: Worms. You can now set `db="worms"` to use Worms to get taxa downstream from a target taxon. In addition, `taxize` gains new function `worms_downstream()`, which is used under the hood in `downstream(..., db="worms")` (#713) (#715)
* gains new function `id2name()` with `db` options for tol, itis, ncbi, worms, gbif, col, and bold. the function converts taxonomid IDs to names. It's sort of the inverse of the `get_*()` family of functions. (#712) (#716)
* `tax_rank()` gains new parameter `rows` so that one can pass `rows` down to `get_*()` functions

### MINOR IMPROVEMENTS

* `synonyms()` warning from an internal `cbind()` call now fixed (#704) (#705) thanks @vijaybarve
* namespace `taxize` function calls thrown when notifying users about API keys (e.g., `taxize::use_tropicos()`) to make it very clear where the functions live (to avoid confusion with `usethis`) (#724) (#725) thanks @maelle
* changed `iucn_summary()` to output the same structure when no match is found as when a match is found so that when output is passed to `iucn_status()` behavior is the same (#708) thanks @Rekyt
* skip `tax_name()` tests on CRAN (#728)
* `httr` replaced by `crul` throughout (#590)
* most unit tests that make HTTP requests now cached with `vcr`, making tests much faster and not prone to errors to remote services being down (#729)
* EOL: The EOL API underwent major changes, and we've attempted to get things in working order. `eol_dataobjects()` gains new parameter `language`. `eol_pages()` loses `iucn`, `images`, `videos`, `sounds`, `maps`, and `text` parameters, and gains `images_per_page`, `videos_per_page`, `sounds_per_page`, `maps_per_page`, `texts_per_page`, and `texts_page`. Please do let us know if you find any problems with any EOL functions (#717) (#718)
* As part of EOL changes, the default `db` value for `comm2sci()` and `sci2comm()` is now `ncbi` instead of `eol`
* EUBON base URL now https instead of http
* A number of `get_*()` functions changed parameter `verbose` to `messages` to not conflict with `verbose` passed down to `crul::HttpClient`
* ping functions: `ncbi_ping()` reworked to allow use of your api key as a parameter or pulled from your environemnt; `eol_ping()` using https instead of http, and parsing JSON instead of XML.

### BUG FIXES

* `get_eolid()` was erroring when no results found for a query due to not assigning an internal variable (#701) (#709) thanks for the fix @taddallas
* `get_tolid()` was erroring when values were `NULL` - now replacing all `NULLL` with `NA_character_` to make `data.table::rbindlist()` happy (#710) (#711) thanks @gpli for the fix
* add additional rows to the `rank_ref` data.frame of taxonomic ranks: species subgroup, forma, varietas, clade, megacohort, supercohort, cohort, subcohort, infracohort. when there's no matched rank errors can result in many of the downstream functions. The data.frame now has 43 rows. (#720) (#727)
* fix to `downstream()` and `ncbi_get_taxon_summary()`: change in `ncbi_get_taxon_summary` to break up queries into smaller chunks to avoid HTTP 414 errors ("URI too long") (#727) (#730) thanks for reporting @fischhoff and  @benjaminschwetz 
* a number of fixes internally (not user facing) to comply with upcoming R-devel changes for checking length greater than 1 in logical statements (#731)


taxize 0.9.4
============

### NEW FEATURES

* new contributor: [Gaopeng Li](https://github.com/gpli)
* gains new functions for helping the user get authentication keys/tokens: `use_entrez()`, `use_eol()`, `use_iucn()` (which uses internally `rredlist::rl_use_iucn()`), and `use_tropicos()` (#682) (#691) (#693) By @maelle
 
### MINOR IMPROVEMENTS

* remove commented out code

### BUG FIXES

* fix `tropicos_ping()`
* fixed `downstream()` and `gbif_downstream()`: some of the results don't have a `canonicalName`, so now safely try to get that field  (#673)
* fixed `as.uid()`, was erroring when passing in a taxon ID (#674) (#675) by @zachary-foster
* fix in `get_boldid()` (and by extension `classification(..., db = "bold")`): was failing when no parent taxon found, just fill in with NA now (#680)
* fix to `synonyms()`: was failing for some TSNs for `db="itis"` (#685)
* fix to `tax_name()`: `rows` arg wasn't being passed on internally (#686)
* fix to `gnr_resolve()` and `gnr_datasources()`: problems were caused by http scheme, switched to use https instead of http (#687)
* fix to `class2tree()`: organisms with unique rank lower than non-unique ranks will give extra wrong rows (#689) (#690) thanks @gpli
* fix in `ncbi_get_taxon_summary()`: changes in the NCBI API most likely lead to HTTP 414 (URI Too Long) errors. we now loop internally for the user. By extension this helps problems upsteam in `downstream()`/`ncbi_downstream()`/`ncbi_children()` (#698)
* fix in `class2tree()`: was erroring when name strings contained pound signs (e.g., `#`) (#699) (#700) thanks @gpli


taxize 0.9.3
============

### MINOR IMPROVEMENTS

* package gains three new authors: Bastian Greshake Tzovaras, Philippe Marchand, and Vinh Tran
* Don't enforce rate limiting via `Sys.sleep` for NCBI requests if the user has an API key (#667)
* Fix to all functions that do NCBI requests to work whether or not a user has an NCBI API key (#668)
* Increased documentation on authentication, see `?taxize-authentication`
* Further conversion of `verbose` to `messages` across the package so that supressing calls to `message()` do not conflict with curl options passed in
* Converted `genbank2uid()` and `ncbi_get_taxon_summary()` to use `crul` instead of `httr` for HTTP requests

### BUG FIXES

* Fix to `get_tolid()`: it was missing assignment of the `att` attribute internally, causing failures in some cases (#663) (#672)
* Fix to `ncbi_children()` (and thus `children()` when requesting NCBI data) to not fail when there is an empty result from the internal call to `classification()` (#664) thanks @arendsee



taxize 0.9.2
===================

### NEW FEATURES

* `class2tree()` gets a major overhaul thanks to @gedankenstuecke and @trvinh (!!). The function now takes unnamed ranks into account when clustering, which fixes problem where trees were unresolved for many splits as the named taxonomy levels were shared between them. Now it makes full use of the NCBI Taxonomy string, including the unnamed ranks, leading to higher resolution trees that have less multifurcations (#611) (#634)
* Added support throughout package for use of NCBI Entrez API keys - NCBI now strongly encourages their use and you get a higher rate limit when you use one. See `?taxize-authentication` for help. Importantly, note that API key names (both R options and environment variables) have changed. They are now the same for R options and env vars: TROPICOS_KEY, EOL_KEY, PLANTMINER_KEY, ENTREZ_KEY. You no longer need an API key for Plantminer. (#640) (#646)
* New author Zebulun Arendsee (@arendsee)
* New package dependencies: `crul` and `zoo`

### MINOR IMPROVEMENTS

* In `downstream()` we now pass on `limit` and `start` parameters to `gbif_downstream()`; we weren't doing that before; the two parameters control pagination (#638)
*  `genbank2uid()` now returns the correct ID when there are multiple possibilities and invalid IDs no longer make whole batches fail (#642) thanks @zachary-foster
* `children()` outputs made more consistent for certain cases when no results found for searches (#648) (#649) thanks @arendsee
* Improve `downstream()` by passing `...` (additional parameters) down to `ncbi_children()` used internally. allows e.g., use of `ambiguous` parameter in `ncbi_children()` allows you to remove ambiguousl named nodes (#653) (#654) thanks @arendsee
* swapped out use of `httr` for `crul` in EOL and Tropics functions - note that this won't affect you unless you're passing curl options. see package `crul` for help on curl options. Along with this change, the parameter `verbose` has changed to `messages` (for toggling printing of information messages)

### DOCUMENTATION

* Added additional text to the `CONTRIBUTING.md` file for how to contribute to the test suite (#635)

### BUG FIXES

* `genbank2uid` now returns the correct ID when there are multiple possibilities and invalid IDs no longer make whole batches fail.
* Fix to `downstream()`: passing numeric taxon ids to the function while using `db="ncbi"` wasn't working (#641) thanks @arendsee
* Fix to `children()`: passing numeric taxon ids to the function while using `db="worms"` wasn't working (#650) (#651) thanks @arendsee
* `synonyms_df()` - that attemps to combine many outputs from the `synonyms()` function -  now removes NA/NULL/empy outputs before attempting the combination (#636)
* Fix to `gnr_resolve()`: before if `preferred_data_sources` was used, you would get the preferred data but only a few columns of the response. We now return all fields; however, we only return the preferred data part when that parameter is used  (#656)
* Fixes to `children()`. It was returning unexpected results for amgiguous taxonomic names (e.g., there's some insects that are returned when searching within Bacteria). It was also failing when one tried to get the children of a root taxon (e.g., the children of the NCBI id 131567). (#639) (#647) fixed via PR (#659) thanks @arendsee and @zachary-foster


taxize 0.9.0
============

### Changes to `get_*()` functions

* Added separate documentation file for all get* functions 
describing attributes and various exception behaviors
* Some `get*()` functions had `NaN` as default `rows` parameter
value. Those all changed to `NA`
* Better failure behavior now when non-acceptable `rows` 
parameter value given
* Added in all type checks for parameters across `get_*()` functions
* Changed behavior across all `get_*()` functions to behave the 
same when `ask = FALSE, rows = 1` and `ask = TRUE, rows = 1` as these
should result in the same outcome. (#627) thanks @zachary-foster !
* Fixed direct match behavior so that when there's multiple results 
from the data provider, but no direct match, that the functions don't 
give back just `NA` with no inication that there were multiple matches.
* Please let me know if any of these changes cause problems for your
code or package.

### NEW FEATURES

* Change `comm2sci()` to S3 setup with methods for `character`, `uid`, 
and `tsn` (#621)
* `iucn_status()` now has S3 setup with a single method that only handles
output from the `iucn_summary()` function.

### MINOR IMPROVEMENTS

* Add required `key` parameter to fxn `iucn_id()` (#633)
* imrove docs for `sci2comm()`: to indicate how to get non-simplified
output (which includes what language the common name is from) vs. 
getting simplified output (#623) thanks @glaroc !
* Fix to `sci2comm()` to not be case sensitive when looking for matches 
(#625) thanks @glaroc !
* Two additional columns now returned with `eol_search()`: `link` and `content`
* Improve docs in `eol_search()` to describe returned `data.frame`
* Fix `bold_bing()` to use new base URL for their API
* Improved description of the dataset `rank_ref`, see `?rank_ref`

### BUG FIXES

* Fix to `downstream()` via fix to `rank_ref` dataset to include
"infraspecies" and make "unspecified" and "no rank" requivalent.
Fix to `col_downstream()` to remove properly ranks lower than 
allowed. (#620) thanks @cdeterman !
* `iucn_summary`: changed to using `rredlist` package internally.
`sciname` param changed to `x`. `iucn_summary_id()` now is 
deprecated in favor of `iucn_summary()`. `iucn_summary()` now has a
S3 setup, with methods for `character` and `iucn` (#622)
* Added "cohort" to `rank_ref` dataset as that rank sometimes used 
at NCBI (from bug reported in `ncbi_downstream()`) (#626)
* Fix to `sci2comm()`, add `tryCatch()` to internals to catch 
failed requests for specific pageid's (#624) thanks @glaroc !
* Fix URL for taxa for NBN taxonomic ids retrieved via 
`get_nbnid()` (#632)


taxize 0.8.9
============

### BUG FIXES

* Remove `ape::neworder_phylo` object, which is not used anymore in `taxize`  
(#618) (#619) thanks @ashiklom


taxize 0.8.8
============

### NEW FEATURES

* New function `ncbi_downstream()` and now NCBI is an option in 
the function `downstream()` (#583) thanks for the push @andzandz11
* New data source: Wiki*, which includes Wikipedia, Wikispecies, and 
Wikidata - you can choose which you'd like to search. Uses new package
`wikitaxa`, with contributions from @ezwelty (#317)
* `scrapenames()` gains a parameter `return_content`, a boolean, to 
optionally return the OCR content as a text string with the results. (#614)
thanks @fgabriel1891
* New function `get_iucn()` - to get IUCN Red List ids for taxa. In addition,
new S3 methods `synonyms.iucn` and `sci2comm.iucn` - no other methods could 
be made to work with IUCN Red List ids as they do no share their taxonomic
classification data (#578) thanks @diogoprov 

### MINOR IMPROVEMENTS

* `bold` now an option in `classification()` function (#588)
* fix to NBN to use new base URL (#582) ($597)
* `genbank2uid()` can give back more than 1 taxon matched to a given
Genbank accession number. Now the function can return more than one 
match for each query, e.g., try `genbank2uid(id = "AM420293")` (#602)
 thanks @sariya
* had to modify `cbind()` usage to incclude `...` for method 
consistency (#612)
* `tax_rank()` used to be able to do only ncbi and itis. Can now do a 
lot more data sources: ncbi, itis, eol, col, tropicos, gbif, nbn,
worms, natserv, bold  (#587)
* Added to `classification()` docs in a section `Lots of results` a 
note about how to deal with results when there are A LOT of them. (#596)
thanks @ahhurlbert for raising the issue
* `tnrs()` now returns the resulting data.frame in the oder of the 
names passed in by the user (#613) thanks @wpetry
* Changes to `gnr_resolve()` to now strip out taxonomic names submitted 
by user that are NA, or zero length strings, or are not of class 
character (#606)
* Added description of the columns of the data.frame output in 
`gnr_resolve()` (#610) thanks @kamapu 
* Added noted in `tnrs()` docs that the service doesn't provide any
information about homonyms. (#610) thanks @kamapu 
* Added `parvorder` to the `taxize` `rank_ref` dataset - used by NCBI - 
if tax returned with that rank, some functions in `taxize` were failing 
due to that rank missing in our reference dataset `rank_ref` (#615)

### BUG FIXES

* Fix to `get_colid()` via problem in parsing within `col_search()` (#585)
* Fix to `gbif_downstream` (and thus fix in `downstream()`): there 
was two rows with form in our `rank_ref` reference dataset of rank names, 
causing > 1 result in some cases, then causing `vapply` to fail as it's 
expecting length 1 result (#599) thanks @andzandz11
* Fix `genbank2uid()`: was failing when getting more than 1 result back, 
works now (#603) and fails better now, giving back warnings/error messages
that are more informative (see also #602) thanks @sariya
* Fix to `synonyms.tsn()`: in some cases a TSN has > 1 accepted name. We 
get accepted names first from the TSN, then look for synonyms, and hadn't 
accounted for > 1 accepted name. Fixed now (#607) thanks @tdjames
* Fixed bug in `sci2comm()` - was not dealing internally with passing 
the `simplify` parameter (#616)


taxize 0.8.4
============

### NEW FEATURES

* Added WoRMS integration via the new `worrms` package on CRAN.
Adds functions `as.wormsid()`, `get_wormsid()`, `get_wormsid_()`,
`children.wormsid()`, `classification.wormsid()`, `sci2comm.wormsid()`,
`comm2sci.wormsid()`, and `synonyms.wormsid()` (#574) (#579)
* New functions for NatureServe data, including `as.natservid`,
`get_natservid`, `get_natservid_`, and `classification.natservid`
(#126)

### BUG FIXES

* EOL API keys were not passed on to internal functions. fixed now.
thanks @dschlaep ! (#576)
* Fix in `rankagg()` with respect to `vegan` package to work with
older and new version of `vegan` - thank @jarioksa (#580) (#581)

taxize 0.8.0
============

### NEW FEATURES

* New data source added: Open Tree of Life. New functions for the data source
added: `get_tolid()`, `get_tolid_()`, and `as.tolid()` (#517)
* related to above `classification()` gains new method for TOL data
* related to above `lowest_common()` gains new method for TOL data
* Now using `ritis` package, an external dependency for ITIS taxonomy
data. Note that a large number of ITIS functions were removed, and are
now available via the package `ritis`. However, there are still many
high level functions for working with ITIS data (see functions prefixed
with `itis_`), and `get_tsn()`, `classification.tsn()`, and similar
high level functions remain unchanged. (#525)
* EUBON has a new API (v1.2). We now interact with that new API version.
In addition, `eubon()` fxn is now `eubon_search()`, although either still
work - though `eubon()` will be made defunct in the next version of
this package. Additional new functions were added: `eubon_capabilities()`,
`eubon_children()`, and `eubon_hierarchy()` (#567)
* `lowest_common()` function gains two new data source options: COL (Catalogue
of Life) and TOL (Tree of Life) (#505)
* Addded new function `synonyms_df()` as a slim wrapper around
`data.table::rbindlist()` to make it easy to combine many outputs
from `synonyms()` for a single data source - there is a lot of heterogeneity
among data sources in how they report synonyms data, so we don't attempt
to combine data across sources (#533)

### MINOR IMPROVEMENTS

* Change NCBI URLs to `https` from `http` (#571)

### BUG FIXES

* Fixed bug in `tax_name()` in which when an invalid taxon was searched
for then `classification()` returned no data and caused an error.
Fixed now. (#560) thanks @ljvillanueva for reporting it!
* Fixed bug in `gnr_resolve()` in which order of input names to the function
was not retained. fixed now. (#561) thanks @bomeara for reporting it!
* Fixed bug in `gbif_parse()` - data format changed coming back from
GBIF - needed to replace `NULL` with `NA` (#568)  thanks @ChrKoenig for
reporting it!


taxize 0.7.9
============

### NEW FEATURES

* New vignette: "Strategies for programmatic name cleaning" (#549)

### MINOR IMPROVEMENTS

* `get_*()` functions now have new attributes to further help the user:
`multiple_matches` (logical) indicating whether there were multiple
matches or not, and `pattern_match` (logical) indicating whether a
pattern match was made, or not. (#550) from (#547) discussion,
thanks @ahhurlbert ! see also (#551)
* Change all `xml2::xml_find_one()` to `xml2::xml_find_first()`
for new `xml2` version (#546)
* `gnr_resolve()` now retains user supplied taxa that had no matches -
this could affect your code, make sure to check your existing code (#558)
* `gnr_resolve()` - stop sorting output data.frame, so order of rows
in output data.frame now same as user input vector/list (#559)

### BUG FIXES

* Fixed internal fxn `sub_rows()` inside of most `get_*()` functions
to not fail when the data.frame rows were less than that requested by
the user in `rows` parameter (#556)
* Fixed `get_gbifid()`, as sometimes calls failed because we now
return numberic IDs but used to return character IDs (#555)
* Fix to all `get_()` functions to call the internal `sub_rows()`
function later in the function flow so as not to interfere with
taxonomic based filtering (e.g., user filtering by a taxonomic rank)
(#555)
* Fix to `gnr_resolve()`, to not fail on parsing when no data
returned when a preferred data source specified (#557)

taxize 0.7.8
============

### MINOR IMPROVEMENTS

* Fix to `iucn_summary()` (#543) thanks @mcsiple
* Added message for when too many Ids passed in to `ncbi_get_taxon_summary()`
suggesting to break up the ids into chunks (#541) thanks @daattali
* Fix to `itis_acceptname()` to accept multiple names (#534) and now
gives back same output regardless of whether match found or not (#531)

### BUG FIXES

* Fix to `tax_name()` for some queries that return no classification data
via internal call to `classification()` (#542) thanks @daattali
* Another fix for `tax_name()` (#530) thanks @ibartomeus
* Fixed docs for `rankagg()` function, use `requireNamespace()` in examples
to make sure user has `vegan` installed (#529)

taxize 0.7.6
============

### MINOR IMPROVEMENTS

* Changed defunct messages in `eol_invasive()` and `gisd_invasive()`
to point to new location in the [originr](https://github.com/ropensci/originr)
package. Also, cleaned out code in those functions as not avail.
anymore (#494)
* Access to IUCN taxonomy information is now provided through the newish
[rredlist](https://github.com/ropensci/rredlist) package. (Two issues
dealing with IUCN problems (#475) (#492))

### BUG FIXES

* Fix to `get_gbifid()` to use new internal code to provide two
ways to search GBIF taxonomy API, either via `/species/match` or via
`/species/search`, instead of `/species/suggest`, which we used previously.
The suggest route was too coarse. `get_gbifid()` also gains a parameter
`method` to toggle whether you search for names using `/species/match` or
`/species/search`.  (#528)
* Fix for `col_search()` to handle when COL can return a value of
`missapplied name`, which a `switch()` statement didn't handle yet (#511)
thanks @JoStaerk !
* Fixes for `get_colid()` and `col_search()` (#523) thanks @zachary-foster !

taxize 0.7.5
============

### BUG FIXES

* Fixed bug in the package dependency `bold`, which fixes
`taxize::bold_search()`, so no actual changes in `taxize` for
this, but take note (#521)
* Fixed problem in `gnr_resolve()` where we indexed to data
incorrectly. And added tests to account for this problem.
Thanks @raredd ! (#519) (#520)
* Fixed bug in `iucn_summary()` introduced in last version.
`iucn_summary()` now uses the package `rredlist`, which requires
an API key, and I didn't document how to use the key. Function
now allows user to pass the key in as a parameter, and documents
how to get a key and save it in either `.Renviron` or in
`.Rprofile` (#522)


taxize 0.7.4
===============

### NEW FEATURES

* New function `lowest_common()` for obtaining the lowest common taxon and
rank for a given taxon name or ID. Methods so far for ITIS, NCBI, and GBIF (#505)
* New contributor James O'Donnell (@jimmyodonnell) (via #505)
* Now importing `rredlist` [rredlist](https://github.com/ropensci/rredlist)
* New function `iucn_summary_id()` - same as `iucn_summary()`, except takes
IUCN IDs as input instead of taxonomic names (#493)
* All taxonomic rank columns in data.frame's now given back as lower case.
This provides consistency, which is important, and many functions use ranks
to determine what to do next, so using a consistent case is good.

### MINOR IMPROVEMENTS

* `iucn_summary()` fixes, long story short: a number of bug fixes, and uses
the new IUCN API via the newish package `rredlist` when IDs are given as input,
but uses the old IUCN API when taxonomic names given. Also: gains new parameter `distr_details`
(#174) (#472) (#487) (#488)
* Replaced `XML` with `xml2` for XML parsing (#499)
* Fixes to internal use of `httr::content` to explicitly state `encoding="UTF-8"` (#498)
* `gnr_resolve()` now outputs a column (`user_supplied_name`) for the exact input taxon
name - facilitates merging data back to original data inputs (#486) thanks @Alectoria
* `eol_dataobjects()` gains new parameter `taxonomy` to toggle whether to return
any taxonomy details from different data providers (#497)
* Catalogue of Life URLs changed - updated all appropriate COL functions to use
the new URLs (#501)
* `classification()` was giving back rank values in mixed case from different data
providers (e.g., `class` vs. `Class`). All rank values are now all lowercase (#504)
* Changed number of results returned from internal GBIF search in `get_gbfid` to
50 from 20. Gives back more results, so more likely to get the thing searched for (#513)
* Fix to `gni_search()` to make all output columns `character` class
* `iucn_id()`, `tpl_families()`, and `tpl_get()` all gain a new parameter `...` to
pass on curl options to `httr::GET()`

### BUG FIXES

* Fixes to `get_eolid()`: URI returned now always has the pageid, and goes to the
right place; API key if passed in now actually used, woopsy (#484)
* Fixes to `get_uid()`: when a taxon not found, the "match" attribute was saying
found sometimes anyway - that is now fixed; additionally, fixed docs to correctly
state that we give back `'NA due to ask=FALSE'` when `ask = FALSE` (#489) Additionally,
made this doc fix in other `get_*()` function docs
* Fix to `apgOrders()` function (#490)
* Fixes to `tp_search()` which fixes `get_tpsid()`: Tropicos doesn't allow periods (`.`) in
query strings, so those are URL encoded now; Tropicos doesn't like sub-specific rank names
in name query strings, so we warn when those are found, but don't alter user inputs; and
improved docs to be more clear about how the function fails (#491) thanks @scelmendorf !
* Fix to `classification(db = "itis")` to fail better when no taxa found (#495) thanks @ashenkin !
* `eol_pages()` fixes: the EOL API route for this method gained a new parameter `taxonomy`,
this function gains that parameter. That change caused this fxn to fail. Now fixed. Also,
parameter `subject` changed to `subjects` (#500)
* Fix to `col_search()` due to when `misapplied name` come back as a data slot. There
was previously no parser for that type. Now there is, and it works (#512)

taxize 0.7.0
===============

### NEW FEATURES

* Now requires `R >= 3.2.1`. Good idea to update your R installation anyway (#476)
* New function `ion()` for obtaining data from Index of Organism Names (#345)
* New function `eubon()` for obtaining data from EU (European Union) BON
taxonomy (#466) Note that you may onloy get partial results for some requests
as paging isn't implemented yet in the EU BON API (#481)
* New suite of functions, with prefix `fg_*()` for obtaining data from Index
Fungorum. More work has to be done yet on this data source, but these initial
functions allow some Index Fungorum data access (#471)
* New function `gbif_downstream()` for obtaining downstream names from
GBIF's backbone taxonomy. Also available in `downstream()`, where you can
request downstream names from GBIF, along with other data sources (#414)

### MINOR IMPROVEMENTS

* Note added in docs for all `db` parameters to warn users that if they
provide the wrong `db` value for the given taxon ID, they can get data
back, but it would be wrong. That is, all taxonomic data sources available
in `taxize` use their own unique IDs, so a single ID value can be in multiple
data sources, even though the ID refers to different taxa in each data source.
There is no way we can think of to prevent this from happening, so be cautious.
(#465)
* A note added to all IUCN functions to warn users that sometimes incorrect
data is returned. This is beyond our control, as sometimes IUCN itself gives
back incorrect data, and sometimes EOL/Global Names (which we use in some of
the IUCN functions) give back incorrect data. (#468) (#473) (#174) (472) (#475)

### BUG FIXES

* Fix to `gnr_resolve()` to by default capitalize first name of a name string
passed to the function. GNR is case sensitive, so case matters (#469)

### DEFUNCT

* `phylomatic_tree()` and `phylomatic_format()` are defunct. They were deprecated
in recent versions, but are now gone. See the new package `brranching` for
Phylomatic data (#479)

taxize 0.6.6
===============

### MINOR IMPROVEMENTS

* `stripauthority` argument in `gnr_resolve()` has been renamed to `canonical`
to better match what it actually does (#451)
* `gnr_resolve()` now returns a single data.frame in output, or `NULL`
when no data found. The input taxa that have no match at all are returned in
an attribute with name `not_known` (#448)
* updated some functions to work with to R >3.2.x
* In `vascan_search()` changed `callopts` parameter to `...` to pass in curl
options to the request.
* In `ipni_search()` changed `callopts` parameter to `...` to pass in curl
options to the request. In addition, better http error handling, and
added a test suite for this function. (#458)
* `stringsAsFactors=FALSE` now used for `gibf_parse()` (https://github.com/ropensci/taxize/commit/c0c4175d3a0b24d403f18c057258b67d3fbf17f0)
* Made nearly all column headers and list names lowercase to simplify
indexing to elements, as well as combining outputs. (#462)
* Plantminer API updated to use a new API. Option to search ThePlantList or
the Brazilian Flora Checklist (#464)
* Added more details to the documentation for `get_uid()` to make more clear
how to use the varoious parameters to get the desired result, and how to
avoid certain pitfalls (#436)
* Removed the parameter `asdf` from the function `eol_dataobjects()` - now
returning data.frame's only.
* Added some error catching to `get_eolid()` via `tryCatch()` to fail better
when names not found.
* Dropped `openssl` as a package dependency. Not needed anymore because uBio
dropped.

### BUG FIXES

* `gnr_resolve()` failed when no canonical form was found.
* Fixed `gnr_resolve()` when no results found when `best_match_only=TRUE` (#432)
* Fixed bug in internal function `itisdf()` to give back an empty data.frame
when no results found, often with subspecific taxa. Helps solve errors reported
in use of `downstream()`, `itis_downstream()`, and `gethierarchydownfromtsn()` (#459)

### NEW FEATURES

* `gnr_resolve()` gains new parameter `with_canonical_ranks` (logical) to choose
whether infraspecific ranks are returned or not.
* New function `iucn_id()` to get the IUCN ID for a taxon from it's name. (#431)

### DEFUNCT

* All functions that interacted with the taxonomy service uBio are now
defunct. Of course we would deprecate first, then make defunct later, to
make transition easier, but that is out of our hands. The functions
that are defunct are: `ubio_classification()`, `ubio_classification_search()`,
`ubio_id()`, `ubio_search()`, `ubio_synonyms()`, `get_ubioid()`, `ubio_ping()`.
In addition, ubio has been removed as an option in the `synonyms()` function,
and references for uBio have been removed from the `taxize_cite()` utility
function. (#449)

taxize 0.6.2
===============

### MINOR IMPROVEMENTS

* `rankagg()` doesn't depend on `data.table` anymore (fixes issue with CRAN checks)
* Replaced `RCurl::base64Decode()` with `openssl::base64_decode()`, needed for
`ubio_*()` functions (#447)
* Importing only functions (via `importFrom`) used across all imports now (#446).
In addition, `importFrom` for all non-base R pkgs, including `graphics`, `methods`,
`stats` and `utils` packages (#441)
* Fixes to prevent problems with httr v1, where you can't pass a zero length
list to the `query` parameter in `GET()`, but can pass `NULL` (#445)
* Fixes to all of the `gni_*()` functions, including code tidying, some
DRYing out, and ability to pass in curl options (#444)

### BUG FIXES

* Fixed typo in `taxize_cite()`
* Fixed a bug in `classification()` where numeric IDs as input got
converted to itis ids just because they were numeric. Fixed now. (#434)
* Catalogue of Life (COL) changed from using short numeric codes for taxa to
long alphanumeric UUID type ids. This required fixing functions using COL
web services (#435)


taxize 0.6.0
===============

### NEW FEATURES

* Added a method for Catalogue of Life for the `synonyms` function to get
name synonyms. (#430)
* Added datasets `apgFamilies` and `apgOrders`. (#418)
* `col_search()` gains parameters `response` to get a terse or full response, and
`...` to pass in curl options.
* `eol_dataobjects()` gains parameter `...` to pass in curl options, and parameter
`returntype` renamed to `asdf` (for "as data.frame").
* `ncb_get_taxon_summary()` gains parameter `...` to pass in curl options.
* The `children()` function gains the `rows` parameter passed on to `get_*()` functions,
supported for data sources ITIS and Catalogue of Life, but not for NCBI.
* The `upstream()` function gains the `rows` parameter passed on to `get_*()` functions,
supported for both data sources ITIS and Catalogue of Life.
* The `classification()` function gains the `rows` parameter passed on to `get_*()`
functions, for all sources used in the function.
* The `downstream()` function gains the `rows` parameter passed on to `get_*()`
functions, for all sources used in the function.
* Nearly all taxonomic ID retrieveal functions (i.e., `get_*()`) gain new parameters to
help filter results (e.g., `division`, `phylum`, `class`, `family`, `parent`, `rank`, etc.).
These parameters allow direct matching or regex filters (e.g., `.a` to match any character
followed by an `a`). (#410) (#385)
* Nearly all taxonomic ID retrieveal functions (i.e., `get_*()`) now give back more
information (mostly higher taxonomic data) to help in the interactive decision
process. (#327)
* New data source added to `synonyms()` function: Catalogue of Life. (#430)

### MINOR IMPROVEMENTS

* `vegan` package, used in `class2tree()` function, moved from Imports to Suggests. (#392)
* Improved `taxize_cite()` a lot - get URLs and sometimes citation information
for data sources available in taxize. (#270)
* Fixed typo in `apg_lookup()` function. (#422)
* Fixed documentation in `apg_families()` function. (#418)
* Across many functions, fixed support for passing in curl options, and added
examples of curl option use.
* `callopts` parameter in `eol_pages()`, `eol_search()`, `gnr_resolve()`,
`tp_accnames()`, `tp_dist()`, `tp_search()`, `tp_summary()`, `tp_synonyms()`,
`ubio_search()` changed to `...`
* `accepted` parameter in `get_tsn()` changed to `FALSE` by default. (#425)
* Default value of `db` parameter in `resolve()` changed to `gnr` as `tnrs` is
often quite slow.
* General code tidying across the package to make code easier to read.

### BUG FIXES

* Fixed encoding issues in `tpl_families()` and `tpl_get()`. (#424)

### DEPRECATED AND DEFUNCT

* The following functions that were deprecated are now defunct (no longer available):
`ncbi_getbyname()`, `ncbi_getbyid()`, `ncbi_search()`, `eol_invasive()`,
`gisd_isinvasive()`. These functions are available in the `traits` package. (#382)
* `phylomatic_tree()` is deprecated, but will be defunct in a upcoming version.

taxize 0.5.2
===============

### NEW FEATURES

* New set of functions to ping each of the APIs used in `taxize`. E.g., `itis_ping()` pings ITIS and returns a logical, indicating if the ITIS API is working or not. You can also do a very basic test to see whether content returned matches what's expected. (#394)
* New function `status_codes()` to get vector of HTTP status codes. (#394)

### MINOR IMPROVEMENTS

* Removed startup message.
* Now can pass in curl options to `itis_ping()`, and all `*_ping()` functions.

### BUG FIXES

* Moved examples that were in `\donttest` into `\dontrun`.

taxize 0.5.0
===============

### NEW FEATURES

* New function `genbank2uid()` to get a NCBI taxonomic id (i.e., a _uid_) from a either a GenBank accession number of GI number. (#375)
* New function `get_nbnid()` to get a UK National Biodiversity Network taxonomic id (i.e., a _nbnid_). (#332)
* New function `nbn_classification()` to get a taxonomic classification for a UK National Biodiversity Network taxonomic id. Using this new function, generic method `classification()` gains method for `nbnid`. (#332)
* New function `nbn_synonyms()` to get taxonomic synonyms for a UK National Biodiversity Network taxonomic id. Using this new function, generic method `synonyms()` gains method for `nbnid`. (#332)
* New function `nbn_search()` to search for taxa in the UK National Biodiversity Network. (#332)
* New function `ncbi_children()` to get direct taxonomic children for a NCBI taxonomic id. Using this new function, generic method `children()` gains method for `ncbi`. (#348) (#351) (#354)
* New function `upstream()` to get taxa upstream of a taxon. E.g., getting families upstream from a genus gets all families within the one level higher up taxonomic class than family. (#343)
* New suite of functions `as.*()` to coerce numeric/alphanumeric codes to taxonomic identifiers for various databases. There are methods on this function for each of itis, ncbi, tropicos, gbif, nbn, bold, col, eol, and ubio. By default `as.*()` funtions make a quick check that the identifier is a real one by making a GET request against the identifier URI - this can be toggle off by setting `check=FALSE`. There are methods for returning itself, character, numeric, list, and data.frame. In addition, if the `as.*.data.frame()` function is used, a generic method exists to coerce the `data.frame` back to a identifier object. (#362)
* New suite of functions named, for example, `get_tsn_()` (the underscore is the only different from the previous function name). These functions don't do the normal interactive process of prompts that e.g., `get_tsn()` do, but instead returned a list of all ids, or a subset via the `rows` parameter. (#237)
* New function `ncbi_get_taxon_summary()` to get taxonomic name and rank for 1 or more NCBI uid's. (#348)

### MINOR IMPROVEMENTS

* `assertthat` removed from package imports, replaced with `stopifnot()`, to reduce dependency load. (#387)
* `eol_hierarchy()` now defunct (no longer available) (#228) (#381)
* `tp_classifcation()` now defunct (no longer available) (#228) (#381)
* `col_classification()` now defunct (no longer available) (#228) (#381)
* New manual page listing all the low level ITIS functions for which their manual pages are not shown in the package index, but are available if you to `?fxn-name`.
* All `get_*()` functions gain a new parameter `rows` to allow selection of particular rows. For example, `rows=1` to select the first row, or `rows=1:3` to select rows 1 through 3. (#347)
* `classification()` now by default returns taxonomic identifiers for each of the names. This can be toggled off by the `return_id=FALSE`. (#359) (#360)
* Simplification of many higher level functions to use `switch()` on the `db` parameter, which helps give better error message when a `db` value is not possible or spelled incorrectly. (#379)

### BUG FIXES

* Lots of reduction of redundancy in internal functions. (#378)

taxize 0.4.0
===============

### NEW FEATURES

* New data sources added to taxize: BOLD (Biodiversity of Life Database). Three more data sources were added (World Register of Marine Species (WoRMS), Pan-European Species directories Infrastructure (PESI), and Mycobank), but are not available on CRAN. Those three data sources provide data via SOAP web services protocol, which is hard to support in R. Thus, those sources are available on Github. See https://github.com/ropensci/taxize#version-with-soap-data-sources
* New function `children()`, which is a single interface to various data sources to get immediate children from a given taxonomic name. (#304)
* New functions added to search BOLD data" `bold_search()` that searches for taxa in the BOLD database of barcode data; `get_boldid()` to search for a BOLD taxon identifier. (#301)
* New function `get_ubioid()` to get a uBio taxon identifier. (#318)
* New function started (not complete yet) to get suggested citations for the various data sources available in `taxize`: `taxize_cite()`. (#270)

### MINOR IMPROVEMENTS

* Using `jsonlite` instead of `RJSONIO` throughout the `taxize`.
* `get_ids()` gains new option to search for a uBio ID, in addition to the others, itis, ncbi, eol, col, tropicos, and gbif.
* Fixed documentation for `stripauthority` parameter `gnr_resolve()`. (#325)
* `iplant_resolve()` now outputs data.frame structure instead of a list. (#306)
* Clarified parameter `seqrange` in `ncbi_getbyname()` and `ncbi_search()` (#328)
* `synonyms()` gains new data source, can now get synonyms from uBio data source (#319)
* `vascan_search()` giving back more useful results now.

### BUG FIXES

* Added error catching for when URI is too long, i.e., when too many names provided (#329) (#330)
* Various fixes to `tnrs()` function, including more meaningful error messages on failures (#323) (#331)
* Fixed bug in `getpublicationsfromtsn()` that caused function to fail on data.frame's with no data on name assignment (#297)
* Fixed bug in `sci2comm()` that caused fxn to fail when using `db=itis` sometimes (#293)
* Fixes to `scrapenames()`. Sending a text blob via the `text` parameter now works.
* Fixes to `resolve()` so that function now works for all 3 data sources. (#337)

taxize 0.3.0
===============

### NEW FEATURES

* New function `iplant_resolve()` to do name resolution using the iPlant name resolution service. Note, this is different from http://taxosaurus.org/ that is wrapped in the `tnrs()` function.
* New function `ipni_search()` to search for names in the International Plant Names Index (IPNI).
* New function `resolve()` that unifies name resolution services from iPlant's name resolution service (via `iplant_resolve()`), Taxosaurus' TNRS (via `tnrs()`), and GNR's name resolution service (via `gnr_resolve()`).
* All `get_*()` functions how returning a new _uri_ attribute that is a link to the taxon on on the web. If NA is given back (e.g. nothing found), the uri attribute is blank. You can go directly to the uri in your default browser by doing, for example: `browseURL(attr(result, "uri"))`.
* `get_eolid()` now returns an attribute _provider_ because EOL collates taxonomic data form a lot of sources, then gives back IDs that are internal EOL ids, not those matching the id of the source they pull from. This should help with provenance, and should help if there is confusion about why the id givenb back by this function does not match that from the original source.
* Within the `get_tsn()` function, now using the function `itis_terms()`, which gives back the accepted status of the taxa. This allows a new parameter in the function (`accepted`, logical) that allows user to say give back only accepted status names (`accepted=TRUE`), or to give back all names (`accepted=FALSE`).
* `gnr_resolve()` gains two new parameters `best_match_only` (logical, to return best match only) and `preferred_data_sources` (to return preferred data sources) and `callopts` to pass in curl options.
* `tnrs()`, `tp_accnames()`, `tp_refs()`, `tp_summary()`, and `tp_synonyms()` gain new parameter `callopts` to pass in curl options.

### MINOR IMPROVEMENTS

* `class2tree()` can now handle NA in classification objects.
* `classification.eolid()` and `classification.colid()` now return the submitted name along with the classification.
* Changed from CC0 to MIT license.
* Updated citation to have both the taxize paper in F1000 Research and the package citation.
* Sped up some functions by removing internal use of `plyr` functions, see #275.
* Removed dependency on rgbif - copied into this package a few functions needed internally. This avoids users having to install GDAL binary.
* Added in `verbose` parameter to many more functions to allow suppression of help messages.
* In most functions when using `httr`, now manually parsing JSON to a list then to another data format instead of allowing internal `httr` parsing - in addition added checks on content type and encoding in many functions.
* Added `match.arg` iternally to `get_ids()` for the `db` parameter so that a) unique short abbreviations of possible values are possible, and b) gives a meaningful warning if unsupported values are given.
* Most long-named ITIS functions (e.g., `getexpertsfromtsn`, `getgeographicdivisionsfromtsn`) gain parameter `curlopts` to pass in curl options.
* Added `stringsAsFactors=FALSE` to all `data.frame` creations to eliminate factor variables.

### BUG FIXES

* `classification.gbifid()` did not return the correct result when taxon not found.
* Fixed bugs in many functions, see #245, #248, #254, #277.
* `classification()` used to fail when it was passed a subset of a vector of ids, in which case the class information was stripped off. Now works (#284)

taxize 0.2.2
===============

### NEW FEATURES

* itis_downstream() and col_downstream() functions accessible now from a single function downstream() (https://github.com/ropensci/taxize/issues/238)

### MINOR IMPROVEMENTS

* Added a extension function classification() for the gbif id class, classification.gbifid() (https://github.com/ropensci/taxize/issues/241)

### BUG FIXES

* Added some error catching to class2tree function. (https://github.com/ropensci/taxize/issues/240)
* Fixed problems in cbind.classification() and rbind.classification() where the first column of the ouput was a useless column name, and all column names now lower case for consistency. (https://github.com/ropensci/taxize/issues/243)
* classification() was giving back IDS instead of taxon names on the list element names, fixed this so hopefully all are giving back names. (https://github.com/ropensci/taxize/issues/243)
* Fixed bugs in col_*() functions so they give back data.frame's now with character class columns instead of factors, damned stringsAsFactors!  (https://github.com/ropensci/taxize/issues/246)


taxize 0.2.0
===============

### MINOR IMPROVEMENTS

* New dataset: Lookup-table for family, genus, and species names for ThePlantList under dataset name "theplantlist".
* get_ids() now accepts "gbif" as an option via use of get_gbifid().
* Changed function itis_phymat_format() to phylomatic_format() - this function gets the typical Phylomatic format name string "family/genus/genus_epithet"

### BUG FIXES

* Updated gbif_parse() base url to the new one (http://api.gbif.org/v1/parser/name).
* Fixes to phylomatic_tree().

### NEW FEATURES

* New function class2tree() to convert list of classifications to a tree. For example, go from a list of classifications from the function classification() to this function to get a taxonomy tree in ape phylo format.
* New function get_gbfid() to get a Global Biodiversity Information Facility identifier. This is the ID GBIF uses in their backbone taxonomy.
* classification() outputs gain rbind() and cbind() generic methods that act on the various outputs of classification() to bind data width-wise, or column-wise, respectively.

taxize 0.1.9
===============

### MINOR IMPROVEMENTS

* Updated ncbi_search() to retrieve more than a max of 500, slightly changed column headers in output data files, and if didn't before, now accepts a vector/list of taxonomic names instead of just one name.

taxize 0.1.8
===============

### NEW FEATURES

* We attempted to make all ouput column names lowercase, and to increase consistency across column names in outputs from similar functions.
* New function scrapenames() uses the Global Names Recognition and Discovery service to extract taxonomic names from a web page, pdf, or other document.
* New function vascan_search() to search the CANADENSYS Vascan names database.

### BUG FIXES

* Fixed bugs in get_tpsid(), get_eolid() and eol_pages().
* phylomatic_tree() bugs fixed.

### MINOR IMPROVEMENTS

* classification() methods were simplified. Now classification() is the workhorse for every data-source. col_classification(), eol_hierarchy(), and tp_classification() are now deprecated and will be removed in the next taxize version.
* classification() gains four new arguments: start, checklist, key, and callopts.
* comm2sci() gains argument simplify to optionally simplify output to a vector of names (TRUE by default).
* get_eolid() and get_tpsid() both gain new arguments key to specify an API key, and ... to pass on arguments to eol_search().
* Added ncbi as a data source (db="ncbi") in sci2comm().
* tax_agg() now accepts a matrix in addition to a data.frame. Thanks to @tpoi
* tnrs() changes: Using httr instead of RCurl; now forcing splitting up name vector when long. Still issues when using POST requests (getpost="POST") wherein a request sent with 100 names only returns 30 for example. Investigating this now.

### NOTES

* Function name change: tp_acceptednames() now tp_accnames().
* Function name change: tp_namedistributions() now tp_dist().
* Function name change: tp_namereferences() now tp_refs().
* Internal ldfast() function changed name to taxize_ldfast() to avoid namespace conflicts with similar function in another package.
* Three functions now with ncbi_* prefix: get_seqs() is now ncbi_getbyname(); get_genes() is now ncbi_getbyid(); and get_genes_avail() is now ncbi_search().

taxize 0.1.5
===============

### NEW FEATURES

* classification() gains extension method classification.ids() to accept output from get_ids() - which attempts to get a taxonomic hierarchy from each of the taxon identifiers with the output from get_ids().
* synonyms() gains extension method synonyms.ids() to accept output from get_ids() - which attempts to get synonyms from each of the taxon identifiers with the output from get_ids().

taxize 0.1.4
===============

### NEW FEATURES

* Reworked functions that interact with the ITIS API so that lower level functions were grouped together into higher level functions. All the approximately 50 lower level functions are still exported but are not included in the index help file (due to @keywords internal for each fxn) - but can still be used normally, and man files are avaialable at ?functionName.
* New function itis_ping() to check if the ITIS API service is up, similar to eol_ping() for the EOL API.
* New function itis_getrecord() to get a partial or full record, using a TSN or lsid.
* New function itis_refs() to get references associated with a TSN.
* New function itis_kingdomnames() to get all kingdom names, or kingdom name for a TSN.
* New function itis_lsid() to get a TSN from an lsid, get a partial or full record from an lsid.
* New function itis_native() to get status as native, exotic, etc. in various geographic regions.
* New function itis_hierarchy() to get full hierarchy, or immediate up or downstream hierarchy.
* New function itis_terms() to get tsn's, authors, common names, and scientific names from a given query.
* New function sci2comm() to get common (vernacular) names from input scientific names from various data sources.
* New function comm2sci() to get scientific names from input common (vernacular) names from various data sources.
* New function get_ids() to get taxonomic identifiers across all sources.

### MINOR IMPROVEMENTS

* itis_taxrank() now outputs a character, not a factor; loses parameter verbose, and gains ..., which passes on further arguments to gettaxonomicranknamefromtsn.
* tp_synonyms(), tp_summary(), plantminer(), itis_downstream(), gisd_isinvasive(), get_genes_avail(), get_genes(), eol_invasive(), eol_dataobjects(), andn tnrs() gain parameter verbose to optionally suppress messages.
* phylomatic_tree() format changed so that names are passed in normall (e.g., Poa annua) instead of the slashpath format (family/genus/genus_species). Also, taxaformat parameter dropped.
* itis_acceptname() gains ... to pass in further arguments to getacceptednamesfromtsn()
* tp_namedistributions() loses parameter format.
* get_tsn() and get_uid() return infomation about match as attribute.
* clarified iucn-documentation

### BUG FIXES

* Fixed bug in synonyms() so that further arguments can be passed on to get_tsn() to suppress messages.
* Removed test for ubio_classification_search(), a function that isn't operational yet.

taxize 0.1.1
===============

### NEW FEATURES

* New functions added just like get_uid()/get_tsn() but for EOL, Catalogue of Life, and Tropicos, see get_eolid(), get_colid(), and get_tpsid(), respectively.
* classification() methods added for EOL, Catalogue of Life, and Tropicos, see functions classification.eolid(), classification.colid(), and classification.tpsid() respectively.
* New function col_search() to search for names in the Catalogue of Life.
* User can turn off interactive mode in get_* functions. All get_* functions gain an ask argument, if TRUE (default) a user prompt is used for user to select which row they want, if FALSE, NA is returned when many results available; and added tests for the new argument. Affects downstream functions too.
* New function eol_invasive() to search EOL collections of invasive species lists.
* New function tp_search() to search for a taxonomic IDs from Tropicos.
* New function tp_classification() to get a taxonomic hierarchy from Tropicos.
* New function gbif_parse() to parse scientific names into their components, using the GBIF name parser API.
* New function itis_searchcommon() to search for common names across both searchbycommonnamebeginswith, and searchbycommonnameendswith.


### BUG FIXES

* tax_name() and other function broke, because get_tsn() and get_uid() returned wrong value when a taxon was not found. Fixed.


### MINOR IMPROVEMENTS

* Added tests for new classification() methods for EOL, COL, and Tropicos.
* Added tests for new functions tp_search() and tp_classification().

### NOTES

* Moved tests from inst/tests to tests/testthat according to new preferred location of tests.
* Updated CITATION in inst/ with our F1000Research paper info.
* Package repo name on Github changed from taxize_ to taxize - remember to use "taxize" in install_github() calls now instead of "taxize_"


taxize 0.1.0
===============

### NEW FEATURES

* New function tpl_families() to get data.frame of families from The Plantlist.org site.
* New function names_list() to get a random vector of species names using the
* Added two new data sets, plantGenusNames.RData and plantNames.RData, to be used in names_list().
* New function ldfast(), a replacement function for plyr::ldply that should be faster in all cases.
* Changed API key names to be more consistent, now tropicosApiKey, eolApiKey, ubioApiKey, and pmApiKey - do change these in your .Rprofile if you store them there.
* Added a startup message.

### MINOR IMPROVEMENTS

* Across most functions, removed dependencies on plyr, using ldfast() instead, for increased speed.
* Across most functions, changed from using RCurl to using httr.
* Across most functions, stop_for_status() now used directly after Curl call to check the http status code, stoping the function if appropriate code found.
* Many functions changed parameter ... to callopts, which passes on additional Curl options, with default an empty list (list()), which makes function testing easier.
* eol_search() gains parameters page, exact, filter_tid, filter_heid, filter_by_string, matching, cache_ttl, and callopts.
* eol_hierarchy() gains parameter callopts, and loses parameter usekey (always using API key now).
* eol_pages() gains parameters images, videos, sounds, maps, text, subject, licenses, details, common_names, synonyms, references, vetted, cache_ttl, and callopts.
* gni_search(): parameter url lost, is defined inside the function now, and .Rd file gains url references.
* phylomatic_tree() now checks to make sure family names were found for input taxa. If not, the function stops with message informing this.
* tpl_get() updated with fixes/improvements by John Baumgartner - now gets taxa from all groups, whereas only retrieved from Angiosperms before. In addition, csv files from The Plantlist.org are downloaded directly rather than read into R and written out again.
* tpl_search() now checks for missing data or errors, and stops function with error message.

### BUG FIXES

* capwords() fxn changed to taxize_capwords() to avoid namespace conflicts with other packages with a similar function.
* ubio_namebank() was giving back base64 encoded data, now decoded appropriately.

### NOTES

* Added John Baumgartner as an author.

taxize 0.0.6
===============

### NEW FEATURES
* tax_name() accepts multiple ranks to query.
* tax_name() accepts vectors as input.
* tax_name() has an option to query both, NCBI and ITIS, in one call and return the union of both.
* new extractor function for iucn_summary(): iucn_status(), to extract status from iucn-objects.
* tax_agg(): A function to aggregate species data to given taxonomic rank.
* tax_rank(): Get taxonomic rank for a given taxon name.
* classification() accepts taxon names as input and returns a named list.
* new function apg_lookup() looks up APGIII taxonomy and replaces family names
* new function gni_parse() parses scientific names using EOl's name parser API
* new function iucn_getname() is a utility to find IUCN names using the EOL API
* new function rank_agg() aggregates data by a given taxonomic rank
* new data table apg_families
* new data table apg_orders
* gnr_resolve() gains new arguments gnr_resolvee_once, with_context, stripauthority, highestscore, and http, and loses returndf (that is, a data.frame is returned by default)
* gni_search() gains parameter parse_names

### MINOR IMPROVEMENTS
* tnrs() parameter getpost changed from default of 'GET' to 'POST'
* Across all functions, the url parameter specifying an API endpoint was moved inside of functions (i.e., not available as a parameter in the function call)
* gnr_datasources() parameter todf=TRUE by default now, returning a data.frame
* col_classification() minor formatting improvements

### BUG FIXES
* iucn_summary() returns no information about population estimates.
* get_tsn() raised a warning in specific situations.
* tax_name() did not work for multiple ranks with ITIS.
* fixed errors in getfullhierarchyfromtsn()
* fixed errors in gethierarchydownfromtsn()
* fixed errors in getsynonymnamesfromtsn()
* fixed errors in searchforanymatch()
* fixed errors in searchforanymatchedpage()

### NOTES
* Removed dependency to NCBI2R
* Improvements of documentation
* Citation added

taxize 0.0.5
===============

### BUG FIXES
* removed tests for now until longer term fix is made so that web APIs that are temporarily down don't cause tests to fail.

taxize 0.0.4
===============

### BUG FIXES
* added R (>= 2.15.0) so that package tests don't fail on some systems due to paste0()
* remove test for ubio_namebank() function as it sometimes fails

taxize 0.0.3
===============

### BUG FIXES
* iucn_summary() does not break when API returns no information.
* tax_name() returns NA when taxon is not found on API.
* get_uid() asks for user input when more then one UID is found for a taxon.
* changed base URL for phylomatic_tree(), and associated parameter changes

### NEW FEATURES
* added check for invasive species status for a set of species from GISD database via gisd_isinvasive().
* Further development with the EOL-API: eol_dataobjects().
* added Catalogue of Life: col_classification(), col_children(), and col_downstream().
* new fxn get_genes(), retrieve gene sequences from NCBI by accession number.
* new functions to interact with the Phylotastic name resolution service: tnrs_sources() and tnrs()
* Added unit tests

### DEPRECATED AND DEFUNCT
* itis_name() fxn deprecated - use tax_name() instead


taxize 0.0.2
===============

### BUG FIXES

* changed paste0 to paste to avoid problems on certain platforms.
* removed all tests until the next version so that tests will not fail on any platforms.
* plyr was missing as import for iucn_summary fxn.

### NEW FEATURES

* added NEWS file.


taxize 0.0.1
===============

### NEW FEATURES

* released to CRAN
## Test environments

* local macOS, R 4.0.3
* ubuntu 16.04 (on travis-ci), R 4.0.3
* win-builder (devel and release)

## R CMD check results

0 errors | 0 warnings | 0 notes

## Reverse dependencies

* I have run R CMD check on the 23 downstream dependencies; there were no errors related to taxize.

------

This version makes a few functions defunct for a web service that is no longer up, improves some docs, and fixes a few bugs. In addition, this fixes a failing test due to the latest rredlist on CRAN (an import here).

Thanks!
Scott Chamberlain
<!--- Provide a general summary of your changes in the Title above -->

<!-- IF THIS INVOLVES AUTHENTICATION: DO NOT SHARE YOUR USERNAME/PASSWORD, OR API KEYS/TOKENS IN THIS ISSUE - MOST LIKELY THE MAINTAINER WILL HAVE THEIR OWN EQUIVALENT KEY -->

## Description
<!--- Describe your changes in detail -->

## Related Issue
<!--- if this closes an issue make sure include e.g., "fix #4"
or similar - or if just relates to an issue make sure to mention
it like "#4" -->

## Example
<!--- if introducing a new feature or changing behavior of existing
methods/functions, include an example if possible to do in brief form -->

<!--- Did you remember to include tests? Unless you're just changing
grammar, please include new tests for your change -->
# CONTRIBUTING #

## Bugs?

* Submit an issue on the [Issues page](https://github.com/ropensci/taxize/issues) - be sure to include R session information and a reproducible example.
* Prefer email? Please don't. It benefits everyone for discussions to happen in public where they're indexed by search engines, enabling users to find solutions to their problems from previous public discussions. 

## Code contributions

### Broad overview of contributing workflow

* Fork this repo to your Github account
* Clone your version on your account down to your machine from your account, e.g,. `git clone https://github.com/<yourgithubusername>/taxize.git`
* Make sure to track progress upstream (i.e., on our version of `taxize` at `ropensci/taxize`) by doing `git remote add upstream https://github.com/ropensci/taxize.git`. Before making changes make sure to pull changes in from upstream by doing either `git fetch upstream` then merge later or `git pull upstream` to fetch and merge in one step
* Make your changes (bonus points for making changes on a new feature branch)
* Please do write a test(s) for your changes if they affect code and not just docs (see Tests below)
* Push up to your account
* Submit a pull request to home base at `ropensci/taxize`

### Tests

To add tests, go to the folder `tests/testthat/`. Tests are generally organized as individual files for each exported function from the package (that is, listed as an export in the `NAMESPACE` file). If you are adding a new exported function, add a new test file. If you are changing an existing function, work in the tests file for that function, unless it doesn't have tests, in which case make a new test file.

The book R packages book provides [a chapter on testing in general](http://r-pkgs.had.co.nz/tests.html). Do consult that first if you aren't familiar with testing in R.

The easiest set up to run tests is from within an R session:

```r
library(devtools)
library(testthat)
# loads the package
load_all()
```

To test an individual test file

```r
test_file("tests/testthat/test-foobar.R")
```

To run all tests

```r
devtools::test()
```

If you are running tests that have `skip_on_cran()` in them, set `Sys.setenv(NOT_CRAN = "true")` prior to running tests.


### Making changes

In addition to changing the code, do make sure to udpate the documentation if applicable. The R packages book book has a [chapter on documentation](http://r-pkgs.had.co.nz/man.html) you should read if you aren't familiar.

After code and documentation has been changed, update documentation by running either `devtools::document()` or `roxygen2::roxygenise()`.

Make sure if you change what packages or even functions within packages are imported, most likely add the package to Imports in the DESCRIPTION file and list what functions are imported in the `taxize-package.R` file.

Be conservative about adding new dependencies.


### Style

* Make sure code, documentation, and comments are no more than 80 characters in width.
* Use `<-` instead of `=` for assignment
* Always use `snake_case` (and all lowercase) instead of `camelCase`

## Also, check out our [discussion forum](https://discuss.ropensci.org)
<!-- IF THIS INVOLVES AUTHENTICATION: DO NOT SHARE YOUR USERNAME/PASSWORD, OR API KEYS/TOKENS IN THIS ISSUE - MOST LIKELY THE MAINTAINER WILL HAVE THEIR OWN EQUIVALENT KEY -->

<!-- If this issue relates to usage of the package, whether a question, bug or similar, along with your query, please paste your devtools::session_info() or sessionInfo() into the code block below. If not, delete all this and proceed :) -->

<details> <summary><strong>Session Info</strong></summary>

```r

```
</details>
taxize
======

```{r echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

[![Project Status: Active – The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)
[![cran checks](https://cranchecks.info/badges/worst/taxize)](https://cranchecks.info/pkgs/taxize)
[![R-CMD-check](https://github.com/ropensci/taxize/workflows/R-CMD-check/badge.svg)](https://github.com/ropensci/taxize/actions/)
[![codecov](https://codecov.io/gh/ropensci/taxize/branch/master/graph/badge.svg)](https://codecov.io/gh/ropensci/taxize)
[![rstudio mirror downloads](https://cranlogs.r-pkg.org/badges/taxize)](https://github.com/r-hub/cranlogs.app)
[![cran version](https://www.r-pkg.org/badges/version/taxize)](https://cran.r-project.org/package=taxize)


`taxize` allows users to search over many taxonomic data sources for species names (scientific and common) and download up and downstream taxonomic hierarchical information - among other things.

The taxize book: https://taxize.dev

Package documentation: https://docs.ropensci.org/taxize/


## Installation

### Stable version from CRAN

```{r eval=FALSE}
install.packages("taxize")
```

### Development version from GitHub

Windows users install Rtools first.

```{r eval=FALSE}
install.packages("remotes")
remotes::install_github("ropensci/taxize")
```

```{r}
library('taxize')
```

## Screencast

<a href="https://vimeo.com/92883063"><img src="man/figures/screencast.png" width="400"></a>

## Contributing

See our [CONTRIBUTING](https://github.com/ropensci/taxize/blob/master/.github/CONTRIBUTING.md) document.

## Contributors

Collected via GitHub Issues: honors all contributors in alphabetical order. Code contributors are in bold.

[afkoeppel](https://github.com/afkoeppel) - [afredstonhermann](https://github.com/afredstonhermann) - [ahhurlbert](https://github.com/ahhurlbert) - [albnd](https://github.com/albnd) - [Alectoria](https://github.com/Alectoria) - [andzandz11](https://github.com/andzandz11) - **[anirvan](https://github.com/anirvan)** - [antagomir](https://github.com/antagomir) - **[arendsee](https://github.com/arendsee)** - [ArielGreiner](https://github.com/ArielGreiner) - [arw36](https://github.com/arw36) - [ashenkin](https://github.com/ashenkin) - **[ashiklom](https://github.com/ashiklom)** - [benjaminschwetz](https://github.com/benjaminschwetz) - **[benmarwick](https://github.com/benmarwick)** - [bienflorencia](https://github.com/bienflorencia) - [binkySallly](https://github.com/binkySallly) - [bomeara](https://github.com/bomeara) - [BridgettCollis](https://github.com/BridgettCollis) - [bw4sz](https://github.com/bw4sz) - **[cboettig](https://github.com/cboettig)** - [cdeterman](https://github.com/cdeterman) - [ChrKoenig](https://github.com/ChrKoenig) - [chuckrp](https://github.com/chuckrp) - [clarson2191](https://github.com/clarson2191) - [claudenozeres](https://github.com/claudenozeres) - [cmzambranat](https://github.com/cmzambranat) - [cparsania](https://github.com/cparsania) - [daattali](https://github.com/daattali) - [DanielGMead](https://github.com/DanielGMead) - [DarrenObbard](https://github.com/DarrenObbard) - [davharris](https://github.com/davharris) - [davidvilanova](https://github.com/davidvilanova) - [diogoprov](https://github.com/diogoprov) - **[dlebauer](https://github.com/dlebauer)** - [dlenz1](https://github.com/dlenz1) - [dougwyu](https://github.com/dougwyu) - [dschlaep](https://github.com/dschlaep) - **[EDiLD](https://github.com/EDiLD)** - [edwbaker](https://github.com/edwbaker) - [emhart](https://github.com/emhart) - [eregenyi](https://github.com/eregenyi) - [fdschneider](https://github.com/fdschneider) - [fgabriel1891](https://github.com/fgabriel1891) - [fischhoff](https://github.com/fischhoff) - **[fmichonneau](https://github.com/fmichonneau)** - **[fozy81](https://github.com/fozy81)** - **[gedankenstuecke](https://github.com/gedankenstuecke)** - [gimoya](https://github.com/gimoya) - [GISKid](https://github.com/GISKid) - [git-og](https://github.com/git-og) - [glaroc](https://github.com/glaroc) - **[gpli](https://github.com/gpli)** - [gustavobio](https://github.com/gustavobio) - [hlapp](https://github.com/hlapp) - **[ibartomeus](https://github.com/ibartomeus)** - **[Ironholds](https://github.com/Ironholds)** - [jabard89](https://github.com/jabard89) - [jangorecki](https://github.com/jangorecki) - **[jarioksa](https://github.com/jarioksa)** - [jebyrnes](https://github.com/jebyrnes) - **[jeroen](https://github.com/jeroen)** - **[jimmyodonnell](https://github.com/jimmyodonnell)** - [joelnitta](https://github.com/joelnitta) - [johnbaums](https://github.com/johnbaums) - [jonmcalder](https://github.com/jonmcalder) - [jordancasey](https://github.com/jordancasey) - **[josephwb](https://github.com/josephwb)** - [jsgosnell](https://github.com/jsgosnell) - [JulietteLgls](https://github.com/JulietteLgls) - **[jwilk](https://github.com/jwilk)** - [kamapu](https://github.com/kamapu) - **[karthik](https://github.com/karthik)** - **[katrinleinweber](https://github.com/katrinleinweber)** - [KevCaz](https://github.com/KevCaz) - [kgturner](https://github.com/kgturner) - [kmeverson](https://github.com/kmeverson) - [Koalha](https://github.com/Koalha) - **[ljvillanueva](https://github.com/ljvillanueva)** - **[maelle](https://github.com/maelle)** - [Markus2015](https://github.com/Markus2015) - [matutosi](https://github.com/matutosi) - [mcsiple](https://github.com/mcsiple) - [MikkoVihtakari](https://github.com/MikkoVihtakari) - [millerjef](https://github.com/millerjef) - [miriamgrace](https://github.com/miriamgrace) - [MK212](https://github.com/MK212) - [mpnelsen](https://github.com/mpnelsen) - [MUSEZOOLVERT](https://github.com/MUSEZOOLVERT) - [nate-d-olson](https://github.com/nate-d-olson) - [nmatzke](https://github.com/nmatzke) - [npch](https://github.com/npch) - [ocstringham](https://github.com/ocstringham) - [p-neves](https://github.com/p-neves) - [p-schaefer](https://github.com/p-schaefer) - [padpadpadpad](https://github.com/padpadpadpad) - [paternogbc](https://github.com/paternogbc) - **[patperu](https://github.com/patperu)** - [pederengelstad](https://github.com/pederengelstad) - [philippi](https://github.com/philippi) - [Phylloxera](https://github.com/Phylloxera) - **[pmarchand1](https://github.com/pmarchand1)** - [pozsgaig](https://github.com/pozsgaig) - [PrincessPi314](https://github.com/PrincessPi314) - [pssguy](https://github.com/pssguy) - **[raredd](https://github.com/raredd)** - [rec3141](https://github.com/rec3141) - **[Rekyt](https://github.com/Rekyt)** - [RodgerG](https://github.com/RodgerG) - [rossmounce](https://github.com/rossmounce) - [sariya](https://github.com/sariya) - [sastoudt](https://github.com/sastoudt) - [scelmendorf](https://github.com/scelmendorf) - **[sckott](https://github.com/sckott)** - [SimonGoring](https://github.com/SimonGoring) - [snsheth](https://github.com/snsheth) - [snubian](https://github.com/snubian) - [Squiercg](https://github.com/Squiercg) - [sunray1](https://github.com/sunray1) - **[taddallas](https://github.com/taddallas)** - [tdjames1](https://github.com/tdjames1) - [tmkurobe](https://github.com/tmkurobe) - [toczydlowski](https://github.com/toczydlowski) - [tpaulson1](https://github.com/tpaulson1) - [tpoisot](https://github.com/tpoisot) - **[TrashBirdEcology](https://github.com/TrashBirdEcology)** - **[trvinh](https://github.com/trvinh)** - **[vijaybarve](https://github.com/vijaybarve)** - [wcornwell](https://github.com/wcornwell) - [willpearse](https://github.com/willpearse) - [wpetry](https://github.com/wpetry) - [yhg926](https://github.com/yhg926) - **[zachary-foster](https://github.com/zachary-foster)**

## Road map

Check out our [milestones](https://github.com/ropensci/taxize/milestones) to see what we plan to get done for each version.

## Meta

* Please [report any issues or bugs](https://github.com/ropensci/taxize/issues).
* License: MIT
* Get citation information for `taxize` in R doing `citation(package = 'taxize')`
* Please note that this package is released with a [Contributor Code of Conduct](https://ropensci.org/code-of-conduct/). By contributing to this project, you agree to abide by its terms.

[![rofooter](https://ropensci.org/public_images/github_footer.png)](https://ropensci.org)
---
title: Introduction to taxize
author: Scott Chamberlain
date: "2020-09-17"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Introduction to taxize}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



`taxize` is a taxonomic toolbelt for R. `taxize` wraps APIs for a large suite of taxonomic databases availab on the web.

## Installation

First, install and load `taxize` into the R session.


```r
install.packages("taxize")
```


```r
library("taxize")
```

Advanced users can also download and install the latest development copy from GitHub (https://github.com/ropensci/taxize)

## Resolve taxonomic name

This is a common task in biology. We often have a list of species names and we want to know a) if we have the most up to date names, b) if our names are spelled correctly, and c) the scientific name for a common name. One way to resolve names is via the Global Names Resolver (GNR) service provided by the Encyclopedia of Life. Here, we are searching for two misspelled names:


```r
temp <- gnr_resolve(c("Helianthos annus", "Homo saapiens"))
head(temp)
#> # A tibble: 6 x 5
#>   user_supplied_name submitted_name  matched_name     data_source_title    score
#>   <chr>              <chr>           <chr>            <chr>                <dbl>
#> 1 Helianthos annus   Helianthos ann… Helianthus annus uBio NameBank         0.75
#> 2 Helianthos annus   Helianthos ann… Helianthus annu… Catalogue of Life     0.75
#> 3 Helianthos annus   Helianthos ann… Helianthus annu… ITIS                  0.75
#> 4 Helianthos annus   Helianthos ann… Helianthus annu… NCBI                  0.75
#> 5 Helianthos annus   Helianthos ann… Helianthus annu… GRIN Taxonomy for P…  0.75
#> 6 Helianthos annus   Helianthos ann… Helianthus annu… Union 4               0.75
```

The correct spellings are *Helianthus annuus* and *Homo sapiens*.

taxize takes the approach that the user should be able to make decisions about what resource to trust, rather than making the decision. The GNR service provides data from a variety of data sources. The user may trust a specific data source, thus may want to use the names from that data source. In the future, we may provide the ability for taxize to suggest the best match from a variety of sources.

Another common use case is when there are many synonyms for a species. In this example, we have three synonyms of the currently accepted name for a species.


```r
mynames <- c("Helianthus annuus ssp. jaegeri", "Helianthus annuus ssp. lenticularis", "Helianthus annuus ssp. texanus")
(tsn <- get_tsn(mynames, accepted = FALSE))
══  3 queries  ═══════════════
✔  Found:  Helianthus annuus ssp. jaegeri
✔  Found:  Helianthus annuus ssp. lenticularis
✔  Found:  Helianthus annuus ssp. texanus
══  Results  ═════════════════

● Total: 3 
● Found: 3 
● Not Found: 0
[1] "525928" "525929" "525930"
attr(,"class")
[1] "tsn"
attr(,"match")
[1] "found" "found" "found"
attr(,"multiple_matches")
[1] FALSE FALSE FALSE
attr(,"pattern_match")
[1] FALSE FALSE FALSE
attr(,"uri")
[1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=525928"
[2] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=525929"
[3] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=525930"
lapply(tsn, itis_acceptname)
[[1]]
  submittedtsn      acceptedname acceptedtsn author
1       525928 Helianthus annuus       36616     L.

[[2]]
  submittedtsn      acceptedname acceptedtsn author
1       525929 Helianthus annuus       36616     L.

[[3]]
  submittedtsn      acceptedname acceptedtsn author
1       525930 Helianthus annuus       36616     L.
```

## Retrieve higher taxonomic names

Another task biologists often face is getting higher taxonomic names for a taxa list. Having the higher taxonomy allows you to put into context the relationships of your species list. For example, you may find out that species A and species B are in Family C, which may lead to some interesting insight, as opposed to not knowing that Species A and B are closely related. This also makes it easy to aggregate/standardize data to a specific taxonomic level (e.g., family level) or to match data to other databases with different taxonomic resolution (e.g., trait databases).

A number of data sources in taxize provide the capability to retrieve higher taxonomic names, but we will highlight two of the more useful ones: Integrated Taxonomic Information System (ITIS) and National Center for Biotechnology Information (NCBI). First, we'll search for two species, *Abies procera} and *Pinus contorta* within ITIS.


```r
specieslist <- c("Abies procera","Pinus contorta")
classification(specieslist, db = 'itis')
#> ══  2 queries  ═══════════════
#> ✔  Found:  Abies procera
#> ✔  Found:  Pinus contorta
#> ══  Results  ═════════════════
#> 
#> ● Total: 2 
#> ● Found: 2 
#> ● Not Found: 0
#> $`Abies procera`
#>               name          rank     id
#> 1          Plantae       kingdom 202422
#> 2    Viridiplantae    subkingdom 954898
#> 3     Streptophyta  infrakingdom 846494
#> 4      Embryophyta superdivision 954900
#> 5     Tracheophyta      division 846496
#> 6  Spermatophytina   subdivision 846504
#> 7        Pinopsida         class 500009
#> 8          Pinidae      subclass 954916
#> 9          Pinales         order 500028
#> 10        Pinaceae        family  18030
#> 11           Abies         genus  18031
#> 12   Abies procera       species 181835
#> 
#> $`Pinus contorta`
#>               name          rank     id
#> 1          Plantae       kingdom 202422
#> 2    Viridiplantae    subkingdom 954898
#> 3     Streptophyta  infrakingdom 846494
#> 4      Embryophyta superdivision 954900
#> 5     Tracheophyta      division 846496
#> 6  Spermatophytina   subdivision 846504
#> 7        Pinopsida         class 500009
#> 8          Pinidae      subclass 954916
#> 9          Pinales         order 500028
#> 10        Pinaceae        family  18030
#> 11           Pinus         genus  18035
#> 12  Pinus contorta       species 183327
#> 
#> attr(,"class")
#> [1] "classification"
#> attr(,"db")
#> [1] "itis"
```

It turns out both species are in the family Pinaceae. You can also get this type of information from the NCBI by doing `classification(specieslist, db = 'ncbi')`.

Instead of a full classification, you may only want a single name, say a family name for your species of interest. The function `tax_name` is built just for this purpose. As with the `classification` function you can specify the data source with the `db` argument, either ITIS or NCBI.


```r
tax_name("Helianthus annuus", get = "family", db = "ncbi")
#> ══  1 queries  ═══════════════
#> ✔  Found:  Helianthus+annuus
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
#>     db             query     family
#> 1 ncbi Helianthus annuus Asteraceae
```

It may happen that a data source does not provide information on the queried species, than one could take the result from another source and union the results from the different sources.

## Interactive name selection

As mentioned most databases use a numeric code to reference a species. A general workflow in taxize is: Retrieve Code for the queried species and then use this code to query more data/information.

Below are a few examples. When you run these examples in R, you are presented with a command prompt asking for the row that contains the name you would like back; that output is not printed below for brevity. In this example, the search term has many matches. The function returns a data frame of the matches, and asks for the user to input what row number to accept.


```r
get_uid("Pinus")
#> ══  1 queries  ═══════════════
#> ✔  Found:  Pinus
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
#> [1] "3337"
#> attr(,"class")
#> [1] "uid"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.ncbi.nlm.nih.gov/taxonomy/3337"
```

In another example, you can pass in a long character vector of taxonomic names (although this one is rather short for demo purposes):


```r
splist <- c("annona cherimola", 'annona muricata', "quercus robur")
get_tsn(splist, searchtype = "scientific")
#> ══  3 queries  ═══════════════
#> ✔  Found:  annona cherimola
#> ✔  Found:  annona muricata
#> ✔  Found:  quercus robur
#> ══  Results  ═════════════════
#> 
#> ● Total: 3 
#> ● Found: 3 
#> ● Not Found: 0
#> [1] "506198" "18098"  "19405" 
#> attr(,"class")
#> [1] "tsn"
#> attr(,"match")
#> [1] "found" "found" "found"
#> attr(,"multiple_matches")
#> [1] FALSE FALSE  TRUE
#> attr(,"pattern_match")
#> [1] FALSE FALSE  TRUE
#> attr(,"uri")
#> [1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=506198"
#> [2] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=18098" 
#> [3] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=19405"
```

There are functions for many other sources

* `get_boldid()`
* `get_eolid()`
* `get_gbifid()`
* `get_nbnid()`
* `get_tpsid()`

Sometimes with these functions you get a lot of data back. In these cases you may want to limit your choices. Soon we will incorporate the ability to filter using `regex` to limit matches, but for now, we have a new parameter, `rows`, which lets you select certain rows. For example, you can select the first row of each given name, which means there is no interactive component:


```r
get_nbnid(c("Zootoca vivipara","Pinus contorta"), rows = 1)
#> ══  2 queries  ═══════════════
#> ✔  Found:  Zootoca vivipara
#> ✔  Found:  Pinus contorta
#> ══  Results  ═════════════════
#> 
#> ● Total: 2 
#> ● Found: 2 
#> ● Not Found: 0
#> [1] "NHMSYS0001706186" "NBNSYS0000004786"
#> attr(,"class")
#> [1] "nbnid"
#> attr(,"match")
#> [1] "found" "found"
#> attr(,"multiple_matches")
#> [1] TRUE TRUE
#> attr(,"pattern_match")
#> [1] FALSE FALSE
#> attr(,"uri")
#> [1] "https://species.nbnatlas.org/species/NHMSYS0001706186"
#> [2] "https://species.nbnatlas.org/species/NBNSYS0000004786"
```

Or you can select a range of rows


```r
get_nbnid(c("Zootoca vivipara","Pinus contorta"), rows = 1:3)
#> ══  2 queries  ═══════════════
#> ✔  Found:  Zootoca vivipara
#> ✔  Found:  Pinus contorta
#> ══  Results  ═════════════════
#> 
#> ● Total: 2 
#> ● Found: 2 
#> ● Not Found: 0
#> [1] "NHMSYS0001706186" "NBNSYS0000004786"
#> attr(,"class")
#> [1] "nbnid"
#> attr(,"match")
#> [1] "found" "found"
#> attr(,"multiple_matches")
#> [1] TRUE TRUE
#> attr(,"pattern_match")
#> [1] TRUE TRUE
#> attr(,"uri")
#> [1] "https://species.nbnatlas.org/species/NHMSYS0001706186"
#> [2] "https://species.nbnatlas.org/species/NBNSYS0000004786"
```

In addition, in case you don't want to do interactive name selection in the case where there are a lot of names, you can get all data back with functions of the form, e.g., `get_tsn_()`, and likewise for other data sources. For example:


```r
out <- get_nbnid_("Poa annua")
NROW(out$`Poa annua`)
#> [1] 25
```

That's a lot of data, so we can get only certain rows back


```r
get_nbnid_("Poa annua", rows = 1:10)
#> $`Poa annua`
#>                guid     scientificName    rank taxonomicStatus
#> 1  NBNSYS0000002544          Poa annua species        accepted
#> 2  NBNSYS0200001901       Bellis annua species        accepted
#> 3  NBNSYS0200003392   Triumfetta annua species        accepted
#> 4  NBNSYS0200002555        Lonas annua species        accepted
#> 5  NHMSYS0000456951  Carrichtera annua species        accepted
#> 6  NHMSYS0000461807 Poa labillardierei species        accepted
#> 7  NHMSYS0000461808      Poa ligularis species        accepted
#> 8  NHMSYS0000461817     Poa sieberiana species        accepted
#> 9  NHMSYS0000461805         Poa gunnii species        accepted
#> 10 NHMSYS0000461801     Poa costiniana species        accepted
```

## Coerce numerics/alphanumerics to taxon IDs

We've also introduced in `v0.5` the ability to coerce numerics and alphanumerics to taxonomic ID classes that are usually only retrieved via `get_*()` functions.

For example, adfafd


```r
as.gbifid(get_gbifid("Poa annua")) # already a uid, returns the same
#> ══  1 queries  ═══════════════
#>    gbifid             scientificname    rank   status matchtype
#> 1 2704179               Poa annua L. species ACCEPTED     EXACT
#> 2 8422205 Poa annua Cham. & Schltdl. species  SYNONYM     EXACT
#> 3 7730008           Poa annua Steud. species DOUBTFUL     EXACT
#> ✖  Not Found:  Poa annua
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 0 
#> ● Not Found: 1
#> [1] NA
#> attr(,"class")
#> [1] "gbifid"
#> attr(,"match")
#> [1] "not found"
#> attr(,"multiple_matches")
#> [1] TRUE
#> attr(,"pattern_match")
#> [1] FALSE
as.gbifid(2704179) # numeric
#> [1] "2704179"
#> attr(,"class")
#> [1] "gbifid"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.gbif.org/species/2704179"
as.gbifid("2704179") # character
#> [1] "2704179"
#> attr(,"class")
#> [1] "gbifid"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.gbif.org/species/2704179"
as.gbifid(list("2704179","2435099","3171445")) # list, either numeric or character
#> [1] "2704179" "2435099" "3171445"
#> attr(,"class")
#> [1] "gbifid"
#> attr(,"match")
#> [1] "found" "found" "found"
#> attr(,"multiple_matches")
#> [1] FALSE FALSE FALSE
#> attr(,"pattern_match")
#> [1] FALSE FALSE FALSE
#> attr(,"uri")
#> [1] "https://www.gbif.org/species/2704179"
#> [2] "https://www.gbif.org/species/2435099"
#> [3] "https://www.gbif.org/species/3171445"
```

These `as.*()` functions do a quick check of the web resource to make sure it's a real ID. However, you can turn this check off, making this coercion much faster:


```r
system.time( replicate(3, as.gbifid(c("2704179","2435099","3171445"), check=TRUE)) )
#>    user  system elapsed 
#>   0.092   0.003   4.850
system.time( replicate(3, as.gbifid(c("2704179","2435099","3171445"), check=FALSE)) )
#>    user  system elapsed 
#>   0.002   0.000   0.002
```

## What taxa are downstream of my taxon of interest?

If someone is not a taxonomic specialist on a particular taxon he likely does not know what children taxa are within a family, or within a genus. This task becomes especially unwieldy when there are a large number of taxa downstream. You can of course go to a website like Wikispecies or Encyclopedia of Life to get downstream names. However, taxize provides an easy way to programatically search for downstream taxa for the Integrated Taxonomic Information System.


```r
apis_itis_id <- 154395 # id for Apis, fetched beforehand to save time here
downstream(apis_itis_id, downto = "species", db = "itis")
#> $`154395`
#>       tsn parentname parenttsn rankname          taxonname rankid
#> 1 1128092       Apis    154395  species     Apis laboriosa    220
#> 2  154396       Apis    154395  species     Apis mellifera    220
#> 3  763550       Apis    154395  species Apis andreniformis    220
#> 4  763551       Apis    154395  species        Apis cerana    220
#> 5  763552       Apis    154395  species       Apis dorsata    220
#> 6  763553       Apis    154395  species        Apis florea    220
#> 7  763554       Apis    154395  species Apis koschevnikovi    220
#> 8  763555       Apis    154395  species   Apis nigrocincta    220
#> 
#> attr(,"class")
#> [1] "downstream"
#> attr(,"db")
#> [1] "itis"
```

## Direct children

You may sometimes only want the direct children. We got you covered on that front, with methods for ITIS and NCBI.

The direct children (genera in this case) of _Pinaceae_ using NCBI data:


```r
children("Pinaceae", db = "ncbi")
#> $Pinaceae
#>    childtaxa_id childtaxa_name childtaxa_rank
#> 1        123600     Nothotsuga          genus
#> 2         64685        Cathaya          genus
#> 3          3358          Tsuga          genus
#> 4          3356    Pseudotsuga          genus
#> 5          3354    Pseudolarix          genus
#> 6          3337          Pinus          genus
#> 7          3328          Picea          genus
#> 8          3325          Larix          genus
#> 9          3323     Keteleeria          genus
#> 10         3321         Cedrus          genus
#> 11         3319          Abies          genus
#> 
#> attr(,"class")
#> [1] "children"
#> attr(,"db")
#> [1] "ncbi"
```

## Get NCBI ID from GenBank Ids

With accession numbers


```r
genbank2uid(id = 'AJ748748')
#> [[1]]
#> [1] "282199"
#> attr(,"class")
#> [1] "uid"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.ncbi.nlm.nih.gov/taxonomy/282199"
#> attr(,"name")
#> [1] "Nereida ignava 16S rRNA gene, type strain 2SM4T"
```

With gi numbers


```r
genbank2uid(id = 62689767)
#> [[1]]
#> [1] "282199"
#> attr(,"class")
#> [1] "uid"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.ncbi.nlm.nih.gov/taxonomy/282199"
#> attr(,"name")
#> [1] "Nereida ignava 16S rRNA gene, type strain 2SM4T"
```

## Matching species tables with different taxonomic resolution

Biologist often need to match different sets of data tied to species. For example, trait-based approaches are a promising tool in ecology. One problem is that abundance data must be matched with trait databases. These two data tables may contain species information on different taxonomic levels and possibly data must be aggregated to a joint taxonomic level, so that the data can be merged. taxize can help in this data-cleaning step, providing a reproducible workflow:

We can use the mentioned `classification`-function to retrieve the taxonomic hierarchy and then search the hierarchies up- and downwards for matches. Here is an example to match a species with names on three different taxonomic levels.


```r
A <- "gammarus roeseli"

B1 <- "gammarus roeseli"
B2 <- "gammarus"
B3 <- "gammaridae"

A_clas <- classification(A, db = 'ncbi')
#> ══  1 queries  ═══════════════
#> ✔  Found:  gammarus+roeseli
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
B1_clas <- classification(B1, db = 'ncbi')
#> ══  1 queries  ═══════════════
#> ✔  Found:  gammarus+roeseli
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
B2_clas <- classification(B2, db = 'ncbi')
#> ══  1 queries  ═══════════════
#> ✔  Found:  gammarus
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
B3_clas <- classification(B3, db = 'ncbi')
#> ══  1 queries  ═══════════════
#> ✔  Found:  gammaridae
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0

B1[match(A, B1)]
#> [1] "gammarus roeseli"
A_clas[[1]]$rank[tolower(A_clas[[1]]$name) %in% B2]
#> [1] "genus"
A_clas[[1]]$rank[tolower(A_clas[[1]]$name) %in% B3]
#> [1] "family"
```

If we find a direct match (here *Gammarus roeseli*), we are lucky. But we can also match Gammaridae with *Gammarus roeseli*, but on a lower taxonomic level. A more comprehensive and realistic example (matching a trait table with an abundance table) is given in the vignette on matching.
---
title: Strategies for programmatic name cleaning
author: Scott Chamberlain
date: "2020-09-16"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Strategies for programmatic name cleaning}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



`taxize` offers interactive prompts when using `get_*()` functions (e.g., `get_tsn()`).
These prompts make it easy in interactive use to select choices when there are more
than one match found.

However, to make your code reproducible you don't want interactive prompts.

This vignette covers some options for programmatic name cleaning.


```r
library("taxize")
```

## get_* functions

When using `get_*()` functions programatically, you have a few options.

### rows parameter

Normally, if you get more than one result, you get a prompt asking you
to select which taxon you want.


```r
get_tsn("Quercus b")
#>       tsn                       target             commonnames    nameusage
#> 1   19298             Quercus beebiana                         not accepted
#> 2  507263       Quercus berberidifolia               scrub oak     accepted
#> 3   19300              Quercus bicolor         swamp white oak     accepted
#> 4   19303             Quercus borealis                         not accepted
#> 5  195131 Quercus borealis var. maxima                         not accepted
#> 6  195166            Quercus boyntonii Boynton's sand post oak     accepted
#> 7  506533              Quercus brantii             Brant's oak     accepted
#> 8  195150            Quercus breviloba                         not accepted
#> 9  195099              Quercus breweri                         not accepted
#> 10 195168             Quercus buckleyi               Texas oak     accepted
#>
#> More than one TSN found for taxon 'Quercus b'!
#>
#>             Enter rownumber of taxon (other inputs will return 'NA'):
#>
#> 1:
```

Instead, we can use the rows parameter to specify which records we want
by number only (not by a name itself). Here, we want the first 3 records:


```r
get_tsn('Quercus b', rows = 1:3)
#>     tsn           target     commonnames    nameusage
#> 1 19298 Quercus beebiana                 not accepted
#> 2 19300  Quercus bicolor swamp white oak     accepted
#> 3 19303 Quercus borealis                 not accepted
#>
#> More than one TSN found for taxon 'Quercus b'!
#>
#>             Enter rownumber of taxon (other inputs will return 'NA'):
#>
#> 1:
```

However, you still get a prompt as there is more than one result.

Thus, for full programmatic usage, you can specify a single row, if you happen
to know which one you want:


```r
get_tsn('Quercus b', rows = 3)
#> ══  1 queries  ═══════════════
#> ✔  Found:  Quercus b
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
#> [1] "19303"
#> attr(,"class")
#> [1] "tsn"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] TRUE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=19303"
```

In reality it is unlikely you'll know which row you want, unless perhaps you
just want one result from each query, regardless of what it is.

### underscore methods

A better fit for programmatic use are underscore methods. Each `get_*()` function
has a sister method with and trailing underscore, e.g., `get_tsn()` and `get_tsn_()`.


```r
get_tsn_("Quercus b")
#> $`Quercus b`
#> # A tibble: 5 x 4
#>   tsn    scientificName         commonNames                           nameUsage
#>   <chr>  <chr>                  <chr>                                 <chr>    
#> 1 19300  Quercus bicolor        swamp white oak,chêne bicolore        accepted 
#> 2 195166 Quercus boyntonii      Boynton's sand post oak,Boynton's oak accepted 
#> 3 195168 Quercus buckleyi       Texas oak,Buckley's oak               accepted 
#> 4 506533 Quercus brantii        Brant's oak                           accepted 
#> 5 507263 Quercus berberidifolia scrub oak                             accepted
```

The result is a single data.frame for each taxon queried, which can be
processed downstream with whatever logic is required in your workflow.

You can also combine `rows` parameter with underscore functions, as a single
number of a range of numbers:


```r
get_tsn_("Quercus b", rows = 1)
#> $`Quercus b`
#> # A tibble: 1 x 4
#>   tsn   scientificName  commonNames                    nameUsage
#>   <chr> <chr>           <chr>                          <chr>    
#> 1 19300 Quercus bicolor swamp white oak,chêne bicolore accepted
```


```r
get_tsn_("Quercus b", rows = 1:2)
#> $`Quercus b`
#> # A tibble: 2 x 4
#>   tsn    scientificName    commonNames                           nameUsage
#>   <chr>  <chr>             <chr>                                 <chr>    
#> 1 19300  Quercus bicolor   swamp white oak,chêne bicolore        accepted 
#> 2 195166 Quercus boyntonii Boynton's sand post oak,Boynton's oak accepted
```

## as.* methods

All `get_*()` functions have associated `as.*()` functions (e.g., `get_tsn()` and `as.tsn()`).

Many `taxize` functions use taxonomic identifier classes (S3 objects) that are the output
of `get_*()` functions. `as.*()` methods make it easy to make the required S3 taxonomic
identifier classes if you already know the identifier. For example:

Already a tsn, returns the same


```r
as.tsn(get_tsn("Quercus douglasii"))
#> ══  1 queries  ═══════════════
#> ✔  Found:  Quercus douglasii
#> ══  Results  ═════════════════
#> 
#> ● Total: 1 
#> ● Found: 1 
#> ● Not Found: 0
#> [1] "19322"
#> attr(,"class")
#> [1] "tsn"
#> attr(,"match")
#> [1] "found"
#> attr(,"multiple_matches")
#> [1] FALSE
#> attr(,"pattern_match")
#> [1] FALSE
#> attr(,"uri")
#> [1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=19322"
```

numeric


```r
as.tsn(c(19322, 129313, 506198))
#> [1] "19322"  "129313" "506198"
#> attr(,"class")
#> [1] "tsn"
#> attr(,"match")
#> [1] "found" "found" "found"
#> attr(,"multiple_matches")
#> [1] FALSE FALSE FALSE
#> attr(,"pattern_match")
#> [1] FALSE FALSE FALSE
#> attr(,"uri")
#> [1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=19322" 
#> [2] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=129313"
#> [3] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=506198"
```

And you can do the same for character, or list inputs - depending on the data source.

The above `as.tsn()` examples have the parameter `check = TRUE`, meaning we ping the 
data source web service to make sure the identifier exists. You can skip that check 
if you like by setting `check = FALSE`, and the result is returned much faster:


```r
as.tsn(c("19322","129313","506198"), check = FALSE)
#> [1] "19322"  "129313" "506198"
#> attr(,"class")
#> [1] "tsn"
#> attr(,"match")
#> [1] "found" "found" "found"
#> attr(,"multiple_matches")
#> [1] FALSE FALSE FALSE
#> attr(,"pattern_match")
#> [1] FALSE FALSE FALSE
#> attr(,"uri")
#> [1] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=19322" 
#> [2] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=129313"
#> [3] "https://www.itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=506198"
```

With the output of `as.*()` methods, you can then proceed with other `taxize` functions.

## gnr_resolve

Some functions in `taxize` are meant specifically for name cleaning. One of those
is `gnr_resolve()`.

`gnr_resolve()` doesn't provide prompts as do `get_*()` functions, but instead
return data.frame's. So we don't face the same problem, and can use `gnr_resolve()`
in a programmatic workflow straight away.


```r
spp <- names_list(rank = "species", size = 10)
gnr_resolve(spp, preferred_data_sources = 11)
#> # A tibble: 13 x 5
#>    user_supplied_na… submitted_name   matched_name        data_source_tit… score
#>  * <chr>             <chr>            <chr>               <chr>            <dbl>
#>  1 Astragalus radka… Astragalus radk… Astragalus radkane… GBIF Backbone T… 0.988
#>  2 Montanoa gigas    Montanoa gigas   Montanoa gigas Rze… GBIF Backbone T… 0.988
#>  3 Serratula semise… Serratula semis… Serratula semiserr… GBIF Backbone T… 0.988
#>  4 Serratula semise… Serratula semis… Serratula semiserr… GBIF Backbone T… 0.988
#>  5 Delosperma pagea… Delosperma page… Delosperma pageanu… GBIF Backbone T… 0.988
#>  6 Delosperma pagea… Delosperma page… Delosperma pageanu… GBIF Backbone T… 0.988
#>  7 Zieria hydroscop… Zieria hydrosco… Zieria hydroscopic… GBIF Backbone T… 0.988
#>  8 Baccharis flabel… Baccharis flabe… Baccharis flabella… GBIF Backbone T… 0.988
#>  9 Piper gonocarpum  Piper gonocarpum Piper gonocarpum T… GBIF Backbone T… 0.988
#> 10 Lathraea japonica Lathraea japoni… Lathraea japonica … GBIF Backbone T… 0.988
#> 11 Lathraea japonica Lathraea japoni… Lathraea japonica … GBIF Backbone T… 0.988
#> 12 Lathraea japonica Lathraea japoni… Lathraea japonica … GBIF Backbone T… 0.988
#> 13 Verbesina tachir… Verbesina tachi… Verbesina tachiren… GBIF Backbone T… 0.988
```

## Other functions

Some other functions in `taxize` use `get_*()` functions internally (e.g., `classification()`),
but you can can generally pass on parameters to the `get_*()` functions internally.


## Feedback?

Let us know if you have ideas for better ways to do programmatic name cleaning at 
https://github.com/ropensci/taxize/issues or https://discuss.ropensci.org/ !
---
title: Case study - resolving Species Plantarum names
author: Tim (@fozy81)
date: "2020-09-16"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Case study}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



*Species Plantarum* by Carl Linnaeus originally published in 1753 and was the first work to consistently describe species using binominal names. It provides a reference point to chart how the usage of 5940 taxa (a subset of 500 used below) described within have changed over time. So let's use the taxize package see if we can resolve these names and see their current status. 

Firstly, let's see how many of the names still exist in modern species catologues today. We can use the `resolve` function to query the Global Name Resolver.


```r
library("taxize")
library("knitr")
# load a subset of Species Plantarum names from the taxize package
names <- species_plantarum_binomials[1:500,]
# Species Plantarum names are split into Genus and Species qualifier so need to be paste them
# together to allow the full binominal names to be sent to the global name resolver
names$species <- paste(names$genus, names$epithet)
# use resolve function to send binominal names to resolver (this may take some time)
resolved_names <- resolve(names$species)
# select only the dataframe column from the list send back from gnr
resolved_names <- resolved_names$gnr
# count the distinct names resolved per dataset source
resolved_names_source <- resolved_names[, 
  c("submitted_name", "data_source_title")
]
resolved_names_source <- unique(resolved_names_source)
resolved_names_source$count <- 1
summary_resolved <- aggregate(resolved_names_source$count,
    list(data_source = resolved_names_source$data_source_title), FUN = "sum")
summary_resolved <- summary_resolved[with(summary_resolved, order(-x)), ]
kable(head(summary_resolved, 20))
```



|   |data_source                                         |   x|
|:--|:---------------------------------------------------|---:|
|40 |uBio NameBank                                       | 499|
|19 |GBIF Backbone Taxonomy                              | 491|
|5  |Catalogue of Life                                   | 481|
|1  |Arctos                                              | 465|
|36 |The International Plant Names Index                 | 460|
|39 |Tropicos - Missouri Botanical Garden                | 422|
|21 |GRIN Taxonomy for Plants                            | 319|
|4  |BioLib.cz                                           | 288|
|11 |Encyclopedia of Life                                | 259|
|33 |Open Tree of Life Reference Taxonomy                | 249|
|35 |The Interim Register of Marine and Nonmarine Genera | 245|
|27 |ITIS                                                | 239|
|12 |EUNIS                                               | 222|
|30 |NCBI                                                | 218|
|31 |nlbif                                               | 184|
|42 |USDA NRCS PLANTS Database                           | 176|
|23 |iNaturalist                                         | 141|
|16 |Freebase                                            | 135|
|41 |Union 4                                             | 133|
|10 |Database of Vascular Plants of Canada (VASCAN)      | 123|

The table above shows none of the data sources provided can resolve all of the names in the *Species Plantarum*. Let's see if between all the data sources we can resolve all the names.


```r
gnr_names <- resolved_names[, c("submitted_name", "score")] 
gnr_names <- unique(gnr_names)

merge_gnr_plantarum <- merge(names, gnr_names,
  by.x = "species", by.y = "submitted_name", all.x = TRUE)

merge_gnr_plantarum <- aggregate(merge_gnr_plantarum$score,
  list(data_source = merge_gnr_plantarum$species), FUN = "mean")

length(merge_gnr_plantarum$data_source)
#> [1] 500
min(merge_gnr_plantarum$x, na.rm = TRUE)
#> [1] 0.75
max(merge_gnr_plantarum$x, na.rm = TRUE)
#> [1] 0.9915
```

Even though no individual name data source can resolve all the names, taken together all names in *Species Plantarum* can be resolved using modern sources. Noting that some names score poorly in terms of fuzzy matching. The poor matching could indicate imperfect matches and perhaps some matches are due to species identified after 1752 sharing similar names. There are lots of questions regarding the history of many of these original binominals and their journey into present day taxonomy.  

For example, let's see how many of these names are still the 'accepted' names according to ITIS. Not all the data providers give an accepted name. So lets use ITIS as the `get_tsn_` function returns a `nameUsage` variable which indicates if a name is still accepted or not.


```r
# find resolved species Plantarum names returned from ITIS
itis_resolved <- resolved_names$submitted_name[resolved_names$data_source_title == "ITIS"]
# select random sub-selection to save time
set.seed(42) 
itis_sample <- itis_resolved[sample(rep(1:length(unique(itis_resolved))), 200)]
# query ITIS (this may take some time)
its_names <- get_tsn_(itis_sample)
its_names_bind <- do.call("rbind", its_names)
its_names_bind$n <- 1
# count the number of names in each nameUsage category 
its_names_agg <- aggregate(its_names_bind$n,
  list(data_source = its_names_bind$nameUsage), FUN = "sum")

kable(its_names_agg)
```



|data_source |   x|
|:-----------|---:|
|accepted    | 195|
|valid       |   3|

Of all the *Species Plantarum* names found in the ITIS data source, a high number (of 200 randomly selected names) are still the 'accepted' name. This indicates Carl Linnaeus, as widely acknowledged, identified well-thought-out and pragmatic taxonomic concepts which have proved useful until the present day. 

Further research may discover why some names appear not to be used today in some data sources and where they are used, why some are no longer the accepted name.
---
title: taxize data sources
author: Scott Chamberlain
date: "2020-09-23"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{taxize data sources}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



Data sources currently implemented in taxize

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
  <th style="text-align:left;">Souce</th>
  <th style="text-align:left;">Function prefix</th>
  <th style="text-align:left;">API Docs</th>
  <th style="text-align:left;">API key</th>
</tr>
</thead>

<tbody>
<tr>
  <td style="text-align:left;">Encylopedia of Life</td>
  <td style="text-align:left;"><code>eol</code></td>
  <td style="text-align:left;"><a href="https://eol.org/docs/what-is-eol/data-services">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Integrated Taxonomic Information Service</td>
  <td style="text-align:left;"><code>itis</code></td>
  <td style="text-align:left;"><a href="https://www.itis.gov/ws_description.html">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Global Names Resolver</td>
  <td style="text-align:left;"><code>gnr</code></td>
  <td style="text-align:left;"><a href="http://resolver.globalnames.org/api">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Global Names Index</td>
  <td style="text-align:left;"><code>gni</code></td>
  <td style="text-align:left;"><a href="https://github.com/dimus/gni/wiki/api">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">IUCN Red List</td>
  <td style="text-align:left;"><code>iucn</code></td>
  <td style="text-align:left;"><a href="https://apiv3.iucnredlist.org/api/v3/docs">link</a></td>
  <td style="text-align:left;"><a href="https://apiv3.iucnredlist.org/api/v3/token">link</a></td>
</tr>
<tr>
  <td style="text-align:left;">Tropicos</td>
  <td style="text-align:left;"><code>tp</code></td>
  <td style="text-align:left;"><a href="http://services.tropicos.org/help">link</a></td>
  <td style="text-align:left;"><a href="http://services.tropicos.org/help?requestkey">link</a></td>
</tr>
<tr>
  <td style="text-align:left;">Theplantlist dot org</td>
  <td style="text-align:left;"><code>tpl</code></td>
  <td style="text-align:left;">**</td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">National Center for Biotechnology Information</td>
  <td style="text-align:left;"><code>ncbi</code></td>
  <td style="text-align:left;">none</td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">CANADENSYS Vascan name search API</td>
  <td style="text-align:left;"><code>vascan</code></td>
  <td style="text-align:left;"><a href="https://data.canadensys.net/vascan/api">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">International Plant Names Index (IPNI)</td>
  <td style="text-align:left;"><code>ipni</code></td>
  <td style="text-align:left;">none</td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Barcode of Life Data Systems (BOLD)</td>
  <td style="text-align:left;"><code>bold</code></td>
  <td style="text-align:left;"><a href="http://www.boldsystems.org/index.php/Resources">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">National Biodiversity Network (UK)</td>
  <td style="text-align:left;"><code>nbn</code></td>
  <td style="text-align:left;"><a href="https://data.nbn.org.uk/Documentation/Web_Services/Web_Services-REST/resources/restapi/rest.html">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Index Fungorum</td>
  <td style="text-align:left;"><code>fg</code></td>
  <td style="text-align:left;">none</td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">EU BON</td>
  <td style="text-align:left;"><code>eubon</code></td>
  <td style="text-align:left;"><a href="https://cybertaxonomy.eu/eubon-utis/doc.html">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Index of Names (ION)</td>
  <td style="text-align:left;"><code>ion</code></td>
  <td style="text-align:left;"><a href="http://www.organismnames.com/">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Open Tree of Life (TOL)</td>
  <td style="text-align:left;"><code>tol</code></td>
  <td style="text-align:left;"><a href="https://github.com/OpenTreeOfLife/germinator/wiki/Open-Tree-of-Life-Web-APIs">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">World Register of Marine Species (WoRMS)</td>
  <td style="text-align:left;"><code>worms</code></td>
  <td style="text-align:left;"><a href="https://www.marinespecies.org/aphia.php?p=webservice">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">NatureServe</td>
  <td style="text-align:left;"><code>natserv</code></td>
  <td style="text-align:left;"><a href="https://services.natureserve.org/BrowseServices/getSpeciesData/getSpeciesListREST.jsp">link</a></td>
  <td style="text-align:left;"><a href="https://services.natureserve.org/developer/index.jsp">link</a></td>
</tr>
<tr>
  <td style="text-align:left;">Wikipedia</td>
  <td style="text-align:left;"><code>wiki</code></td>
  <td style="text-align:left;"><a href="https://www.mediawiki.org/wiki/API:Main_page">link</a></td>
  <td style="text-align:left;">none</td>
</tr>
<tr>
  <td style="text-align:left;">Kew's Plants of the World</td>
  <td style="text-align:left;"><code>pow</code></td>
  <td style="text-align:left;">none</td>
  <td style="text-align:left;">none</td>
</tr>
</tbody>
</table>

**: There are none! We suggest using `TPL` and `TPLck` functions in the [taxonstand package](https://cran.r-project.org/package=Taxonstand). We provide two functions to get bulk data: `tpl_families` and `tpl_get`.

\***: There are none! The function scrapes the web directly.


May be in taxize in the future: See the `datasources` label (https://github.com/ropensci/taxize/labels/datasources) in the issue tracker
---
title: Key functions in taxize
author: Scott Chamberlain
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Key functions in taxize}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

Function name | What it does | Source |
----------- | ----------- | ----------- |
`children` | Get direct children | NCBI, ITIS |
`classification` | Upstream classification | NCBI, ITIS, Tropicos, EOL, GBIF, NBN |
`comm2sci` | Get scientific from common names | EOL, NCBI, ITIS, Tropicos |
`downstream` | Downstream taxa to specified rank | ITIS, GBIF |
`get_ids` | Get taxonomic identifiers | NCBI, ITIS, Tropicos, EOL, GBIF, NBN |
`resolve` | Resolve names using many resolvers | GNR, iPlant |
`gnr_resolve` | Resolve names using Global Names Resolver | GNR |
`tol_resolve` | Resolve names using any resolver | TOL |
`iplant_resolve` | iPlant name resolution| iPlant |
`sci2comm` | Get common from scientific names | EOL, NCBI, ITIS |
`synonyms` | Retrieve synonyms given input names/identifiers | NCBI, ITIS, Tropicos |
`upstream` | Retrieve upstream taxa given names/identifiers | ITIS |
`lowest_common` | Retrieve the lowest common taxon and rank for a given taxon name or ID | ITIS, GBIF, TOL, NCBI |
`genbank2uid` | Get NCBI taxonomy UID from GenBankID | NCBI |
`tax_name` | Get taxonomic names for a given rank | NCBI, ITIS |
`tax_rank` | Get rank for a given taxonomic name | BOLD, EOL, GBIF, NATSERV, NBN, TOL, TROPICOS, ITIS, NCBI, WORMS |
`tpl_get` | Get The Plant List csv files | TPL |

### Acronyms

* NCBI: National Center for Biotechnology Information
* ITIS: Integrated Taxonomic Information Service
* EOL: Encylopedia of Life
* GBIF: Global Biodiversity Information Facility
* NBN: National Biodiversity Network (UK)
* iPlant: iPlant Name Resolution Service
* GNR: Global Names Resolver
* TOL: Open Tree of Life
* MSW3: Mammal Species of the World, 3rd Edition
* TPL: The Plant List
* BOLD: Barcode of Life
* NATSERV: Natureserve
* TROPICOS: Tropicos plant database
* WORMS: World Register of Marine Species
---
title: taxonomic ranks
author: Scott Chamberlain
date: "2020-10-21"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{taxonomic ranks}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



Taxonomic ranks are "whole thing", as I like to say when something is complicated/messy. Taxonomic ranks are the relative placement of a taxon in a taxonomic hierarchy. If there was only one taxonomic hierarchy with the same taxonomic rank names life would be so much easier for all of us. Unfortunately, this is not the case. Nearly every source of taxonomic information has slightly different taxonomic rank names they use, even if many are the same across sources. This article highlights some of the sticky messes in taxonomic ranks.


## NCBI is weird

NCBI taxonomy (https://www.ncbi.nlm.nih.gov/taxonomy) is an outlier among the taxonomic data sources. They use a lot of rank names that hold no information as to the placement of that taxon within a taxonomic hierarchy. The most common of these is **no rank**. If you've retrieved taxonomic information from NCBI you may have noticed this supposed rank name. When you get data from NCBI in taxize you will most certainly run into this rank; just know that it doesn't tell you where it falls within a taxonomic hierarchy. You can however use `classification()` to hopefully get other rank names that do hold actual information. 

Another one that holds no information which has started to become more common with NCBI is **clade**. It's started to replace **no rank** in at least some cases. As far as we can tell this rank name also holds no information about it's placement within a taxonomic hierarchy.


## Downstream

`downstream()` and related functions in taxize require a rank to be given to the `downto` parameter, which says you want taxonomic names down to a particular rank. 

Some ranks are not useful for the `downto` parameter. They include "no rank", "unspecified", "unranked", and "clade"; there are possibly more. They can't be used because they have no rank placement in a hierarchy - they can be anywhere in the hierarchy.

As a work around, try looking at the taxonomic hierarchy for your taxa of interest using `classification()` or on the data providers website and see if there's a taxonomic rank below the rank you want, and use that rank in combination with setting `intermediate=TRUE` in your `downstream()` function call. From the intermediate data you can fetch data you need.


## Rank information within taxize

taxize maintains a taxonomic hierarchy reference within the package. There are two:

- `rank_ref`: data.frame with two columns and around 45 rows (may increase or decrease through time as we incorporate or take away some ranks). `?rank_ref` for more information
- `rank_ref_zoo`: same as above but more specifically for zoological rank systems; as of this writing only used for WoRMS; `rank_ref` is used for all other data sources. `?rank_ref_zoo` for more information


```r
head(rank_ref)
#>   rankid                    ranks
#> 1     01                   domain
#> 2     05             superkingdom
#> 3     10                  kingdom
#> 4     20               subkingdom
#> 5     25 infrakingdom,superphylum
#> 6     30          phylum,division
```

We reference this rank information in `classification()`, `tax_name()`, and all of the exported `downstream` functions. We use the `rankid` numeric column to be able to filter data using `<`/`>`/etc.

We often reference rank information inside the helper functions `which_rank()` and `prune_too_low()`, utility functions to help filter results from data providers by rank information.

We manage these two datasets using the script at `inst/ignore/rank_ref_script.R` in the package, which ends with updating each dataset in the `data/` folder of the package. 

### Let us know

Let us know by opening an issue (https://github.com/ropensci/taxize/issues) if you think you have run into any issues with rank information. The most common issues we see with ranks is with the `downstream()` function and the data source specific functions that support it. 
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_getbyname.R
\name{get_seqs}
\alias{get_seqs}
\title{Retrieve gene sequences from NCBI by accession number.}
\usage{
get_seqs(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ubio_synonyms.R
\name{ubio_synonyms}
\alias{ubio_synonyms}
\title{Search uBio for taxonomic synonyms by hierarchiesID.}
\usage{
ubio_synonyms(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gni_parse.R
\name{gni_parse}
\alias{gni_parse}
\title{Parse scientific names using EOL's name parser.}
\usage{
gni_parse(names, ...)
}
\arguments{
\item{names}{A vector of length 1 or more of taxonomic names}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame with results, the submitted names, and the
parsed names with additional information.
}
\description{
Parse scientific names using EOL's name parser.
}
\examples{
\dontrun{
gni_parse("Cyanistes caeruleus")
gni_parse("Plantago minor")
gni_parse("Plantago minor minor")
gni_parse(c("Plantago minor minor","Helianthus annuus texanus"))

# pass on curl options
gni_parse("Cyanistes caeruleus", verbose = TRUE)
}
}
\references{
http://gni.globalnames.org/
}
\seealso{
\code{\link[=gbif_parse]{gbif_parse()}}, \code{\link[=gn_parse]{gn_parse()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tpl_get.r
\name{tpl_get}
\alias{tpl_get}
\title{Get The Plant List csv files.}
\usage{
tpl_get(x, family = NULL, ...)
}
\arguments{
\item{x}{Directory to write csv files to.}

\item{family}{If you want just one, or >1 family, but not all, list
them in a vector.}

\item{...}{(list) Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
Returns nothing to console, except a message and progress bar.
Writes csv files to x.
}
\description{
Get The Plant List csv files.
}
\details{
Throws a warning if you already have a directory of the one
provided, but still works. Writes to your home directory, change x
as needed.
}
\examples{
\dontrun{
# Get a few families
dir <- file.path(tempdir(), "abc")
tpl_get(dir, family = c("Platanaceae","Winteraceae"))
readLines(file.path(dir, "Platanaceae.csv"), n = 5)

# You can now get Gymnosperms as well
dir1 <- file.path(tempdir(), "def")
tpl_get(dir1, family = c("Pinaceae","Taxaceae"))

# You can get mosses too!
dir2 <- file.path(tempdir(), "ghi")
tpl_get(dir2, family = "Echinodiaceae")

# Get all families
## Beware, will take a while
## dir3 <- file.path(tempdir(), "jkl")
## tpl_get("dir3)
}
}
\references{
The Plant List http://www.theplantlist.org
}
\seealso{
\code{\link[=tpl_families]{tpl_families()}}
}
\author{
John Baumgartner \email{johnbb@student.unimelb.edu.au}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_tsn.R
\name{get_tsn}
\alias{get_tsn}
\alias{as.tsn}
\alias{as.tsn.tsn}
\alias{as.tsn.character}
\alias{as.tsn.list}
\alias{as.tsn.numeric}
\alias{as.tsn.data.frame}
\alias{as.data.frame.tsn}
\alias{get_tsn_}
\title{Get the TSN code for a search term.}
\usage{
get_tsn(
  sci_com,
  searchtype = "scientific",
  accepted = FALSE,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  searchterm = NULL,
  ...
)

as.tsn(x, check = TRUE)

\method{as.tsn}{tsn}(x, check = TRUE)

\method{as.tsn}{character}(x, check = TRUE)

\method{as.tsn}{list}(x, check = TRUE)

\method{as.tsn}{numeric}(x, check = TRUE)

\method{as.tsn}{data.frame}(x, check = TRUE)

\method{as.data.frame}{tsn}(x, ...)

get_tsn_(
  sci_com,
  messages = TRUE,
  searchtype = "scientific",
  accepted = TRUE,
  rows = NA,
  searchterm = NULL,
  ...
)
}
\arguments{
\item{sci_com}{character; A vector of common or scientific names.
Or, a \code{taxon_state} object (see \link{taxon-state})}

\item{searchtype}{character; One of 'scientific' or 'common', or any
unique abbreviation}

\item{accepted}{logical; If TRUE, removes names that are not accepted valid
names by ITIS. Set to \code{FALSE} (default) to give back both accepted
and unaccepted names.}

\item{ask}{logical; should get_tsn be run in interactive mode?
If \code{TRUE} and more than one TSN is found for the species, the user is
asked for input. If \code{FALSE} NA is returned for multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a tsn
class object with one to many identifiers. See
\code{\link[=get_tsn_]{get_tsn_()}} to get back all, or a subset, of the raw
data that you are presented during the ask process.}

\item{searchterm}{Deprecated, see \code{sci_com}}

\item{...}{Ignored}

\item{x}{Input to as.tsn}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.tsn]{as.tsn()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Retrieve the taxonomic serial numbers (TSN) of a taxon from ITIS.
}
\examples{
\dontrun{
get_tsn("Quercus douglasii")
get_tsn("Chironomus riparius")
get_tsn(c("Chironomus riparius","Quercus douglasii"))
splist <- c("annona cherimola", 'annona muricata', "quercus robur",
		"shorea robusta", "pandanus patina", "oryza sativa", "durio zibethinus")
get_tsn(splist, messages=FALSE)

# specify rows to limit choices available
get_tsn('Arni')
get_tsn('Arni', rows=1)
get_tsn('Arni', rows=1:2)

# When not found
get_tsn("howdy")
get_tsn(c("Chironomus riparius", "howdy"))

# Using common names
get_tsn("black bear", searchtype="common")

# Convert a tsn without class information to a tsn class
as.tsn(get_tsn("Quercus douglasii")) # already a tsn, returns the same
as.tsn(get_tsn(c("Chironomus riparius","Pinus contorta"))) # same
as.tsn(19322) # numeric
as.tsn(c(19322,129313,506198)) # numeric vector, length > 1
as.tsn("19322") # character
as.tsn(c("19322","129313","506198")) # character vector, length > 1
as.tsn(list("19322","129313","506198")) # list, either numeric or character
## dont check, much faster
as.tsn("19322", check=FALSE)
as.tsn(19322, check=FALSE)
as.tsn(c("19322","129313","506198"), check=FALSE)
as.tsn(list("19322","129313","506198"), check=FALSE)

(out <- as.tsn(c(19322,129313,506198)))
data.frame(out)
as.tsn( data.frame(out) )

# Get all data back
get_tsn_("Arni")
get_tsn_("Arni", rows=1)
get_tsn_("Arni", rows=1:2)
get_tsn_(c("asdfadfasd","Pinus contorta"), rows=1:5)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tnrs_sources.r
\name{tnrs_sources}
\alias{tnrs_sources}
\title{TNRS sources}
\usage{
tnrs_sources(...)
}
\arguments{
\item{...}{ignored}
}
\description{
Defunct - service was down far too much to be reliable
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_gbifid.R
\name{get_gbifid}
\alias{get_gbifid}
\alias{as.gbifid}
\alias{as.gbifid.gbifid}
\alias{as.gbifid.character}
\alias{as.gbifid.list}
\alias{as.gbifid.numeric}
\alias{as.gbifid.data.frame}
\alias{as.data.frame.gbifid}
\alias{get_gbifid_}
\title{Get the GBIF backbone taxon ID from taxonomic names.}
\usage{
get_gbifid(
  sci,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  phylum = NULL,
  class = NULL,
  order = NULL,
  family = NULL,
  rank = NULL,
  method = "backbone",
  sciname = NULL,
  ...
)

as.gbifid(x, check = FALSE)

\method{as.gbifid}{gbifid}(x, check = FALSE)

\method{as.gbifid}{character}(x, check = TRUE)

\method{as.gbifid}{list}(x, check = TRUE)

\method{as.gbifid}{numeric}(x, check = TRUE)

\method{as.gbifid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{gbifid}(x, ...)

get_gbifid_(
  sci,
  messages = TRUE,
  rows = NA,
  method = "backbone",
  sciname = NULL
)
}
\arguments{
\item{sci}{(character) one or more scientific names. Or, a \code{taxon_state}
object (see \link{taxon-state})}

\item{ask}{logical; should get_gbifid be run in interactive mode?
If TRUE and more than one ID is found for the species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; If TRUE the actual taxon queried is printed on the console.}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all rows are considered.
Note that this function still only gives back a gbifid class object with one to many identifiers.
See \code{\link[=get_gbifid_]{get_gbifid_()}} to get back all, or a subset, of the raw data that you are
presented during the ask process.}

\item{phylum}{(character) A phylum (aka division) name. Optional. See \code{Filtering}
below.}

\item{class}{(character) A class name. Optional. See \code{Filtering} below.}

\item{order}{(character) An order name. Optional. See \code{Filtering} below.}

\item{family}{(character) A family name. Optional. See \code{Filtering} below.}

\item{rank}{(character) A taxonomic rank name. See \link{rank_ref} for possible
options. Though note that some data sources use atypical ranks, so inspect the
data itself for options. Optional. See \code{Filtering} below.}

\item{method}{(character) one of "backbone" or "lookup". See Details.}

\item{sciname}{Deprecated, see \code{sci}}

\item{...}{Ignored}

\item{x}{Input to \code{\link[=as.gbifid]{as.gbifid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only used in
\code{\link[=as.gbifid]{as.gbifid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get the GBIF backbone taxon ID from taxonomic names.
}
\details{
Internally in this function we use a function to search GBIF's taxonomy,
and if we find an exact match we return the ID for that match. If there isn't an
exact match we return the options to you to pick from.
}
\section{method parameter}{

"backbone" uses the \verb{/species/match} GBIF API route, matching against their
backbone taxonomy. We turn on fuzzy matching by default, as the search without
fuzzy against backbone is quite narrow. "lookup" uses the \verb{/species/search}
GBIF API route, doing a full text search of name usages covering scientific
and vernacular named, species descriptions, distributions and the entire
classification.
}

\section{Filtering}{

The parameters \code{phylum}, \code{class}, \code{order}, \code{family}, and \code{rank} are not used
in the search to the data provider, but are used in filtering the data down
to a subset that is closer to the target you want.  For all these parameters,
you can use regex strings since we use \code{\link[=grep]{grep()}} internally to match.
Filtering narrows down to the set that matches your query, and removes the rest.
}

\examples{
\dontrun{
get_gbifid(sci='Poa annua')
get_gbifid(sci='Pinus contorta')
get_gbifid(sci='Puma concolor')

#lots of queries
spp <- names_list("species", 10)
res <- get_gbifid(spp)
res
xx <- taxon_last()
xx

# multiple names
get_gbifid(c("Poa annua", "Pinus contorta"))

# specify rows to limit choices available
get_gbifid(sci='Pinus')
get_gbifid(sci='Pinus', rows=10)
get_gbifid(sci='Pinus', rows=1:3)

# When not found, NA given
get_gbifid(sci="uaudnadndj")
get_gbifid(c("Chironomus riparius", "uaudnadndj"))

# Narrow down results to a division or rank, or both
## Satyrium example
### Results w/o narrowing
get_gbifid("Satyrium")
### w/ phylum
get_gbifid("Satyrium", phylum = "Tracheophyta")
get_gbifid("Satyrium", phylum = "Arthropoda")
### w/ phylum & rank
get_gbifid("Satyrium", phylum = "Arthropoda", rank = "genus")

## Rank example
get_gbifid("Poa", method = "lookup")
get_gbifid("Poa", method = "lookup", rank = "genus")
get_gbifid("Poa", method = "lookup", family = "Thripidae")

# Fuzzy filter on any filtering fields
## uses grep on the inside
get_gbifid("Satyrium", phylum = "arthropoda")
get_gbifid("A*", method = "lookup", order = "*tera")
get_gbifid("A*", method = "lookup", order = "*ales")

# Convert a uid without class information to a uid class
as.gbifid(get_gbifid("Poa annua")) # already a uid, returns the same
as.gbifid(get_gbifid(c("Poa annua","Puma concolor"))) # same
as.gbifid(2704179) # numeric
as.gbifid(c(2704179,2435099,3171445)) # numeric vector, length > 1
as.gbifid("2704179") # character
as.gbifid(c("2704179","2435099","3171445")) # character vector, length > 1
as.gbifid(list("2704179","2435099","3171445")) # list, either numeric or character
## dont check, much faster
as.gbifid("2704179", check=FALSE)
as.gbifid(2704179, check=FALSE)
as.gbifid(2704179, check=FALSE)
as.gbifid(c("2704179","2435099","3171445"), check=FALSE)
as.gbifid(list("2704179","2435099","3171445"), check=FALSE)

(out <- as.gbifid(c(2704179,2435099,3171445)))
data.frame(out)
as.uid( data.frame(out) )

# Get all data back
get_gbifid_("Puma concolor")
get_gbifid_(c("Pinus", "uaudnadndj"))
get_gbifid_(c("Pinus", "Puma"), rows=5)
get_gbifid_(c("Pinus", "Puma"), rows=1:5)

# use curl options
invisible(get_gbifid("Quercus douglasii", verbose = TRUE))
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\author{
Scott Chamberlain,
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iucn_getname.R
\name{iucn_getname}
\alias{iucn_getname}
\title{Get any matching IUCN species names}
\usage{
iucn_getname(name, verbose = TRUE, ...)
}
\arguments{
\item{name}{character; taxon name}

\item{verbose}{logical; should messages be printed?}

\item{...}{Further arguments passed on to \code{\link[=iucn_summary]{iucn_summary()}}, note
that you'll need an API key.}
}
\value{
Character vector of names that matched in IUCN
}
\description{
Get any matching IUCN species names
}
\details{
Beware: IUCN functions can give back incorrect data. This isn't
our fault. We do our best to get you the correct data quickly, but sometimes
IUCN gives back the wrong data, and sometimes Global Names gives back the
wrong data. We will fix these as soon as possible. In the meantime, just
make sure that the data you get back is correct.
}
\examples{
\dontrun{
iucn_getname(name = "Cyanistes caeruleus")
iucn_getname(name = "Panthera uncia")

# not found in global names
# iucn_getname(name = "Abronia pinsapo")

# not found in IUCN search
iucn_getname(name = "Acacia allenii")
}
}
\seealso{
\code{\link[=iucn_summary]{iucn_summary()}} \code{\link[=iucn_status]{iucn_status()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_terms.R
\name{itis_terms}
\alias{itis_terms}
\title{Get ITIS terms, i.e., tsn's, authors, common names, and scientific names.}
\usage{
itis_terms(query, what = "both", ...)
}
\arguments{
\item{query}{One or more common or scientific names, or partial names}

\item{what}{One of both (search common and scientific names), common
(search just common names), or scientific (search just scientific names)}

\item{...}{Further arguments passed on to \code{\link[ritis:terms]{ritis::terms()}}}
}
\description{
Get ITIS terms, i.e., tsn's, authors, common names, and scientific names.
}
\examples{
\dontrun{
# Get terms searching both common and scientific names
itis_terms(query='bear')

# Get terms searching just common names
itis_terms(query='tarweed', "common")

# Get terms searching just scientific names
itis_terms(query='Poa annua', "scientific")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\name{taxize-defunct}
\alias{taxize-defunct}
\alias{defunct}
\title{Defunct functions in taxize}
\description{
The following functions are now defunct (no longer available):
\itemize{
\item All COL functions are defunct: \verb{as.colid, }col_children\verb{, }col_classification\verb{, }col_downstream\verb{, }col_search\verb{, }get_colid\verb{, }get_colid_\verb{, }as.data.frame.colid\verb{, }children.colid\verb{, }classification.colid\verb{, }downstream.colid\verb{, }id2name.colid\verb{, }lowest_common.colid\verb{, }synonyms.colid\verb{, }upstream.colid`
\item \code{col_classification()}: See\code{classification()}
\item \code{tp_classification()}: See\code{classification()}
\item \code{eol_hierarchy()}: See\code{classification()}
\item \code{\link[=eol_invasive]{eol_invasive()}}: See \code{eol} in the \pkg{originr} package.
\item \code{\link[=use_eol]{use_eol()}}: EOL no longer requires an API key
\item \code{\link[=tpl_search]{tpl_search()}}: Use the \pkg{Taxonstand} functions \code{TPL} or \code{TPLck} directly.
\item \code{\link[=get_seqs]{get_seqs()}}: This function changed name to\code{ncbi_getbyname()}()].
\item \code{\link[=get_genes]{get_genes()}}: This function changed name to\code{ncbi_getbyid()}()].
\item \code{\link[=get_genes_avail]{get_genes_avail()}}: This function changed name to\code{ncbi_search()}()].
\item \code{\link[=ncbi_getbyname]{ncbi_getbyname()}}: See \code{ncbi_byname} in the \pkg{traits} package.
\item \code{\link[=ncbi_getbyid]{ncbi_getbyid()}}: See \code{ncbi_byid} in the \pkg{traits} package.
\item \code{\link[=ncbi_search]{ncbi_search()}}: See \code{ncbi_searcher} in the \pkg{traits} package.
\item \code{\link[=gisd_isinvasive]{gisd_isinvasive()}}: See \code{gisd} in the \pkg{originr} package.
\item \code{\link[=ubio_classification]{ubio_classification()}}:  The uBio web services was down for quite a while, is
now (as of 2016-05-09) back up, but we don't trust that it will stay up and available.
\item \code{\link[=ubio_classification_search]{ubio_classification_search()}}: The uBio web services was down for quite
a while, is now (as of 2016-05-09) back up, but we don't trust that it will stay up
and available.
\item \code{\link[=ubio_id]{ubio_id()}}: The uBio web services was down for quite a while, is
now (as of 2016-05-09) back up, but we don't trust that it will stay up and available.
\item \code{\link[=ubio_ping]{ubio_ping()}}:  The uBio web services was down for quite a while, is
now (as of 2016-05-09) back up, but we don't trust that it will stay up and available.
\item \code{\link[=ubio_search]{ubio_search()}}:  The uBio web services was down for quite a while, is
now (as of 2016-05-09) back up, but we don't trust that it will stay up and available.
\item \code{\link[=ubio_synonyms]{ubio_synonyms()}}:  The uBio web services was down for quite a while, is
now (as of 2016-05-09) back up, but we don't trust that it will stay up and available.
\item \code{\link[=get_ubioid]{get_ubioid()}}: The uBio web services are apparently down indefinitely.
\item \code{\link[=phylomatic_tree]{phylomatic_tree()}}: This function is defunct. See
\code{phylomatic} in the package \pkg{brranching}
\item \code{\link[=phylomatic_format]{phylomatic_format()}}: This function is defunct. See
\code{phylomatic_names} in the package \pkg{brranching}
\item \code{\link[=iucn_summary_id]{iucn_summary_id()}}: This function is defunct. Use \code{\link[=iucn_summary]{iucn_summary()}}
\item \code{\link[=eubon]{eubon()}}: This function is defunct. Use \code{\link[=eubon_search]{eubon_search()}}
\item \code{\link[=tnrs]{tnrs()}}: This function is defunct. Was too unreliable
\item \code{\link[=tnrs_sources]{tnrs_sources()}}: This function is defunct. Was too unreliable
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_accnames.R
\name{tp_accnames}
\alias{tp_accnames}
\title{Return all accepted names for a taxon name with a given id.}
\usage{
tp_accnames(id, key = NULL, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
List or dataframe.
}
\description{
Return all accepted names for a taxon name with a given id.
}
\examples{
\dontrun{
tp_accnames(id = 25503923)
tp_accnames(id = 25538750)

# No accepted names found
tp_accnames(id = 25509881)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tax_agg.R
\name{tax_agg}
\alias{tax_agg}
\alias{print.tax_agg}
\title{Aggregate species data to given taxonomic rank}
\usage{
tax_agg(x, rank, db = "ncbi", messages = FALSE, ...)

\method{print}{tax_agg}(x, ...)
}
\arguments{
\item{x}{Community data matrix. Taxa in columns, samples in rows.}

\item{rank}{character; Taxonomic rank to aggregate by.}

\item{db}{character; taxonomic API to use, 'ncbi, 'itis' or both, see
\code{\link[=tax_name]{tax_name()}}. Note that each taxonomic data source has
their own identifiers, so that if you provide the wrong \code{db} value
for the identifier you could get a result, but it will likely be wrong (not
what you were expecting). If using ncbi we recommend getting an API key;
see \link{taxize-authentication}}

\item{messages}{(logical) If FALSE (Default) suppress messages}

\item{...}{Other arguments passed to \code{\link[=get_tsn]{get_tsn()}} or \code{\link[=get_uid]{get_uid()}}}
}
\value{
A list of class \code{tax_agg} with the following items:
\itemize{
\item \code{x} Community data matrix with aggregated data.
\item \code{by} A lookup-table showing which taxa were aggregated.
\item \code{n_pre} Number of taxa before aggregation.
\item \code{rank} Rank at which taxa have been aggregated.
}
}
\description{
Aggregate species data to given taxonomic rank
}
\details{
\code{tax_agg} aggregates (sum) taxa to a specific taxonomic level.
If a taxon is not found in the database (ITIS or NCBI) or the supplied taxon
is on higher taxonomic level this taxon is not aggregated.
}
\examples{
\dontrun{
if (requireNamespace("vegan", quietly = TRUE)) {
  # use dune dataset
  data(dune, package='vegan')
  species <- c("Achillea millefolium", "Agrostis stolonifera",
    "Aira praecox", "Alopecurus geniculatus", "Anthoxanthum odoratum",
    "Bellis perennis", "Bromus hordeaceus", "Chenopodium album",
    "Cirsium arvense", "Comarum palustre", "Eleocharis palustris",
    "Elymus repens", "Empetrum nigrum", "Hypochaeris radicata",
    "Juncus articulatus", "Juncus bufonius", "Lolium perenne",
    "Plantago lanceolata", "Poa pratensis", "Poa trivialis",
    "Ranunculus flammula", "Rumex acetosa", "Sagina procumbens",
    "Salix repens", "Scorzoneroides autumnalis", "Trifolium pratense",
    "Trifolium repens", "Vicia lathyroides", "Brachythecium rutabulum",
    "Calliergonella cuspidata")
  colnames(dune) <- species

  # aggregate sample to families
  (agg <- tax_agg(dune, rank = 'family', db = 'ncbi'))

  # extract aggregated community data matrix for further usage
  agg$x
  # check which taxa have been aggregated
  agg$by
}

# A use case where there are different taxonomic levels in the same dataset
spnames <- c('Puma','Ursus americanus','Ursidae')
df <- data.frame(c(1,2,3), c(11,12,13), c(1,4,50))
names(df) <- spnames
out <- tax_agg(x=df, rank = 'family', db='itis')
out$x

# You can input a matrix too
mat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3,
 dimnames=list(NULL, c('Puma concolor','Ursus americanus','Ailuropoda melanoleuca')))
tax_agg(mat, rank = 'family', db='itis')
}
}
\seealso{
\link{tax_name}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_search.R
\name{tp_search}
\alias{tp_search}
\title{Search Tropicos by scientific name, common name, or Tropicos ID.}
\usage{
tp_search(
  sci = NULL,
  com = NULL,
  nameid = NULL,
  orderby = NULL,
  sortorder = NULL,
  pagesize = NULL,
  startrow = NULL,
  type = NULL,
  key = NULL,
  name = NULL,
  commonname = NULL,
  ...
)
}
\arguments{
\item{sci}{A scientific name, e.g., "poa annua". See Details.}

\item{com}{A common name, e.g., "annual blue grass"}

\item{nameid}{Your search string. e.g., "25509881"}

\item{orderby}{Your search string. e.g., "1"}

\item{sortorder}{Your search string. e.g., "ascending"}

\item{pagesize}{Your search string. e.g., "100"}

\item{startrow}{Your search string. e.g., "1"}

\item{type}{Type of search, "wildcard" (default) will add a wildcard to
the end of your search string. "exact" will use your search string exactly.}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{name}{Deprecated, see \code{sci}}

\item{commonname}{Deprecated, see \code{com}}

\item{...}{Further args passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
List or dataframe.
}
\description{
Search Tropicos by scientific name, common name, or Tropicos ID.
}
\details{
More details on the \code{name} parameter: Tropicos will fail
if you include a period (\code{.}) in your name string, e.g., \code{var.},
so we replace periods before the request is made to the Tropicos web service.
In addition, Tropicos for some reason doesn't want to see sub-specific rank
names like \code{var}/\code{subsp}, so remove those from your query.
}
\examples{
\dontrun{
tp_search(sci = 'Poa annua')
tp_search(sci = 'Poa annua subsp. annua')
tp_search(sci = 'Poa annua var. annua')
tp_search(sci = 'Poa annua var annua')
tp_search(sci = 'Poa annua annua')
}
}
\references{
http://services.tropicos.org/help?method=SearchNameXml
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eol_hierarchy.R
\name{eol_hierarchy}
\alias{eol_hierarchy}
\title{Retrieve the taxonomic hierarchy from given EOL taxonID.}
\usage{
eol_hierarchy(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gnr_datasources.R
\name{gnr_datasources}
\alias{gnr_datasources}
\title{Global Names Resolver Data Sources}
\usage{
gnr_datasources(..., todf)
}
\arguments{
\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}

\item{todf}{defunct, always get a data.frame back now}
}
\value{
data.frame/tibble
}
\description{
Retrieve data sources used in the Global Names Resolver
}
\examples{
\dontrun{
# all data sources
gnr_datasources()

# give me the id for EOL
out <- gnr_datasources()
out[out$title == "EOL", "id"]

# Fuzzy search for sources with the word zoo
out <- gnr_datasources()
out[agrep("zoo", out$title, ignore.case = TRUE), ]
}
}
\references{
https://resolver.globalnames.org/data_sources
}
\seealso{
\code{\link[=gnr_resolve]{gnr_resolve()}}, \code{\link[=gni_search]{gni_search()}}
}
\keyword{names}
\keyword{resolve}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nbn_search.R
\name{nbn_search}
\alias{nbn_search}
\title{Search UK National Biodiversity Network}
\usage{
nbn_search(
  sci_com,
  fq = NULL,
  order = NULL,
  sort = NULL,
  start = 0,
  rows = 25,
  facets = NULL,
  q = NULL,
  ...
)
}
\arguments{
\item{sci_com}{(character) The query terms(s), a scientific or common name}

\item{fq}{(character) Filters to be applied to the original query. These
are additional params of the form fq=INDEXEDFIELD:VALUE e.g.
fq=rank:kingdom. See https://species-ws.nbnatlas.org/indexFields for all
the fields that are queryable.}

\item{order}{(character) Supports "asc" or "desc"}

\item{sort}{(character) The indexed field to sort by}

\item{start}{(integer) Record offset, to enable paging}

\item{rows}{(integer) Number of records to return}

\item{facets}{(list) Comma separated list of the fields to create facets
on e.g. facets=basis_of_record.}

\item{q}{Deprecated, see \code{sci}}

\item{...}{Further args passed on to \link[crul:HttpClient]{crul::HttpClient}.}
}
\value{
a list with slots for metadata (\code{meta}) with list of response
attributes, and data (\code{data}) with a data.frame of results
}
\description{
Search UK National Biodiversity Network
}
\examples{
\dontrun{
x <- nbn_search(sci_com = "Vulpes")
x$meta$totalRecords
x$meta$pageSize
x$meta$urlParameters
x$meta$queryTitle
head(x$data)

nbn_search(sci_com = "blackbird", start = 4)

# debug curl stuff
nbn_search(sci_com = "blackbird", verbose = TRUE)
}
}
\references{
https://api.nbnatlas.org/
}
\seealso{
Other nbn: 
\code{\link{get_nbnid}()},
\code{\link{nbn_classification}()},
\code{\link{nbn_synonyms}()}
}
\author{
Scott Chamberlain,
}
\concept{nbn}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get-id-details.R
\name{get_id_details}
\alias{get_id_details}
\title{Details on \verb{get_*()} functions}
\description{
Including outputs from \verb{get_*()} functions, as well as their
attributes, and all exception behaviors.
}
\details{
This document applies to the following functions:
\itemize{
\item \code{\link[=get_boldid]{get_boldid()}}
\item \code{\link[=get_eolid]{get_eolid()}}
\item \code{\link[=get_gbifid]{get_gbifid()}}
\item \code{\link[=get_ids]{get_ids()}}
\item \code{\link[=get_iucn]{get_iucn()}}
\item \code{\link[=get_natservid]{get_natservid()}}
\item \code{\link[=get_nbnid]{get_nbnid()}}
\item \code{\link[=get_tolid]{get_tolid()}}
\item \code{\link[=get_tpsid]{get_tpsid()}}
\item \code{\link[=get_tsn]{get_tsn()}}
\item \code{\link[=get_ubioid]{get_ubioid()}}
\item \code{\link[=get_uid]{get_uid()}}
\item \code{\link[=get_wiki]{get_wiki()}}
\item \code{\link[=get_wormsid]{get_wormsid()}}
}
}
\section{attributes}{

Each output from \verb{get_*()} functions have the following attributes:
\itemize{
\item \emph{match} (character) - the reason for NA, either 'not found', 'found' or
if \code{ask = FALSE} then 'NA due to ask=FALSE')
\item \emph{multiple_matches} (logical) - Whether multiple matches were returned by
the data source.
This can be \code{TRUE}, even if you get 1 name back because we try to pattern
match the name to see if there's any direct matches. So sometimes this
attribute is \code{TRUE}, as well as \code{pattern_match}, which then returns 1
resulting name without user prompt.
\item \emph{pattern_match} (logical) - Whether a pattern match was made.
If \code{TRUE} then\code{multiple_matches} must be \code{TRUE}, and we found a perfect match
to your name, ignoring case. If \code{FALSE}, there wasn't a direct match, and
likely you need to pick from many choices or further parameters can be used
to limit results
\item \emph{uri} (character) - The URI where more information can be read on the taxon
}
\itemize{
\item includes the taxonomic identifier in the URL somewhere. This may be missing
if the value returned is \code{NA}
}
}

\section{exceptions}{

The following are the various ways in which \verb{get_*()} functions behave:
\itemize{
\item success - the value returned is a character string or numeric
\item no matches found - you'll get an NA, refine your search or possible the
taxon searched for does not exist in the database you're using
\item more than on match and \code{ask = FALSE} - if there's more than one matching
result, and you have set \code{ask = FALSE}, then we can't determine the single
match to return, so we give back \code{NA}. However, in this case we do set the
\code{match} attribute to say \verb{NA due to ask=FALSE & > 1 result} so it's very
clear what happened - and you can even programatically check this as well
\item NA due to some other reason - some \verb{get_*()} functions have additional
parameters for filtering taxa. It's possible that even though there's
results (that is, \code{found} will say \code{TRUE}), you can get back an NA. This is
most likely if the parameter filters taxa after they are returned from the
data provider and the value passed to the parameter leads to no matches.
}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/synonyms.R
\name{synonyms}
\alias{synonyms}
\alias{synonyms.default}
\alias{synonyms.tsn}
\alias{synonyms.tpsid}
\alias{synonyms.nbnid}
\alias{synonyms.wormsid}
\alias{synonyms.iucn}
\alias{synonyms.pow}
\alias{synonyms.ids}
\alias{synonyms_df}
\title{Retrieve synonyms from various sources given input taxonomic
names or identifiers}
\usage{
synonyms(...)

\method{synonyms}{default}(sci_id, db = NULL, rows = NA, x = NULL, ...)

\method{synonyms}{tsn}(id, ...)

\method{synonyms}{tpsid}(id, ...)

\method{synonyms}{nbnid}(id, ...)

\method{synonyms}{wormsid}(id, ...)

\method{synonyms}{iucn}(id, ...)

\method{synonyms}{pow}(id, ...)

\method{synonyms}{ids}(id, ...)

synonyms_df(x)
}
\arguments{
\item{...}{Other passed arguments to internal functions \verb{get_*()} and
functions to gather synonyms.}

\item{sci_id}{Vector of taxa names (character) or IDs (character or numeric)}

\item{db}{character; database to query. either \code{itis}, \code{tropicos},
\code{nbn}, \code{worms}, or \code{pow}. Note that each taxonomic data source has their own
identifiers, so that if you provide the wrong \code{db} value for the identifier
you could get a result, but it will likely be wrong (not what you were
expecting). If using tropicos, we  recommend getting an API key;
see \link{taxize-authentication}}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this parameter is ignored if you pass in a
taxonomic id of any of the acceptable classes: tsn, tpsid, nbnid, ids.}

\item{x}{For \code{synonyms()}: deprecated, see \code{sci_id}. For \code{synonyms_df()},
the output of \code{synonyms()}}

\item{id}{character; identifiers, returned by \code{\link[=get_tsn]{get_tsn()}}, \code{\link[=get_tpsid]{get_tpsid()}},
\code{\link[=get_nbnid]{get_nbnid()}}, \code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_pow]{get_pow()}}}
}
\value{
A named list of results with three types of output in each slot:
\itemize{
\item if the name was not found: \code{NA_character_}
\item if the name was found but no synonyms found, an empty data.frame (0 rows)
\item if the name was found, and synonyms found, a data.frames with the
synonyms - the column names vary by data source
}
}
\description{
Retrieve synonyms from various sources given input taxonomic
names or identifiers
}
\details{
If IDs are supplied directly (not from the \verb{get_*()} functions)
you must specify the type of ID.

For \code{db = "itis"} you can pass in a parameter \code{accepted} to
toggle whether only accepted names are used \code{accepted = TRUE}, or if
all are used \code{accepted = FALSE}. The default is \code{accepted = FALSE}

Note that IUCN requires an API key. See \link[rredlist:rredlist-package]{rredlist::rredlist-package}
for help on authentiating with IUCN Redlist
}
\examples{
\dontrun{
# Plug in taxon IDs
synonyms(183327, db="itis")
synonyms("25509881", db="tropicos")
synonyms("NBNSYS0000004629", db='nbn')
synonyms(105706, db='worms')
synonyms(12392, db='iucn')
synonyms('urn:lsid:ipni.org:names:358881-1', db='pow')

# Plug in taxon names directly
synonyms("Pinus contorta", db="itis")
synonyms("Puma concolor", db="itis")
synonyms(c("Poa annua",'Pinus contorta','Puma concolor'), db="itis")
synonyms("Poa annua", db="tropicos")
synonyms("Pinus contorta", db="tropicos")
synonyms(c("Poa annua",'Pinus contorta'), db="tropicos")
synonyms("Pinus sylvestris", db='nbn')
synonyms('Pomatomus', db='worms')
synonyms('Pomatomus saltatrix', db='worms')
synonyms('Lithocarpus mindanaensis', db='pow')
synonyms('Poa annua', db='pow')
synonyms(c('Poa annua', 'Pinus contorta', 'foo bar'), db='pow')

# not accepted names, with ITIS
## looks for whether the name given is an accepted name,
## and if not, uses the accepted name to look for synonyms
synonyms("Acer drummondii", db="itis")
synonyms("Spinus pinus", db="itis")

# Use get_* methods
synonyms(get_tsn("Poa annua"))
synonyms(get_tpsid("Poa annua"))
synonyms(get_nbnid("Carcharodon carcharias"))
synonyms(get_iucn('Loxodonta africana'))
synonyms(get_pow('Lithocarpus mindanaensis'))

# Pass many ids from class "ids"
out <- get_ids(names="Poa annua", db = c('itis','tropicos'))
synonyms(out)

# Use the rows parameter to select certain rows
synonyms("Poa annua", db='tropicos', rows=1)
synonyms("Poa annua", db='tropicos', rows=1:3)
synonyms("Pinus sylvestris", db='nbn', rows=1:3)

# Use curl options
synonyms("Poa annua", db='tropicos', rows=1, verbose = TRUE)
synonyms("Poa annua", db='itis', rows=1, verbose = TRUE)


# combine many outputs together
x <- synonyms(c("Osmia bicornis", "Osmia rufa", "Osmia"), db = "itis")
synonyms_df(x)

## note here how Pinus contorta is dropped due to no synonyms found
synonyms_df(x)

## note here that ids are taxon identifiers b/c you start with them
x <- synonyms(c(25509881, 13100094), db="tropicos")
synonyms_df(x)

## NBN
x <- synonyms(c('Aglais io', 'Usnea hirta', 'Arctostaphylos uva-ursi'),
  db="nbn")
synonyms_df(x)
}
}
\seealso{
\code{\link[=get_tsn]{get_tsn()}} \code{\link[=get_tpsid]{get_tpsid()}} \code{\link[=get_nbnid]{get_nbnid()}}
\code{\link[=get_wormsid]{get_wormsid()}} \code{\link[=get_iucn]{get_iucn()}} \code{\link[=get_pow]{get_pow()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/upstream.R
\name{upstream}
\alias{upstream}
\alias{upstream.default}
\alias{upstream.tsn}
\alias{upstream.ids}
\title{Retrieve the upstream taxa for a given taxon name or ID.}
\usage{
upstream(...)

\method{upstream}{default}(sci_id, db = NULL, upto = NULL, rows = NA, x = NULL, ...)

\method{upstream}{tsn}(sci_id, db = NULL, upto = NULL, ...)

\method{upstream}{ids}(sci_id, db = NULL, upto = NULL, ...)
}
\arguments{
\item{...}{Further args passed on to \code{\link[=itis_downstream]{itis_downstream()}}}

\item{sci_id}{Vector of taxa names (character) or IDs (character or numeric) to
query.}

\item{db}{character; database to query. One or both of \code{itis}. Note
that each taxonomic data source has their own identifiers, so that if you
provide the wrong \code{db} value for the identifier you could get a result, but
it will likely be wrong (not what you were expecting).}

\item{upto}{What taxonomic rank to go down to. One of: 'superkingdom',
'kingdom', 'subkingdom','infrakingdom','phylum','division','subphylum',
'subdivision','infradivision', 'superclass','class','subclass','infraclass',
'superorder','order','suborder','infraorder','superfamily','family',
'subfamily','tribe','subtribe','genus','subgenus', 'section','subsection',
'species','subspecies','variety','form','subvariety','race', 'stirp',
'morph','aberration','subform', or 'unspecified'}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this parameter is ignored if you pass in a
taxonomic id of any of the acceptable classes: tsn.}

\item{x}{Deprecated, see \code{sci_id}}
}
\value{
A named list of data.frames with the upstream names of every
supplied taxa. You get an NA if there was no match in the database.
}
\description{
This function uses a while loop to continually collect taxa up to the
taxonomic rank that you specify in the \code{upto} parameter. You can get data
from ITIS (itis) only currently. There is no method exposed by itis
for getting taxa at a specific taxonomic rank, so we do it ourselves inside
the function.
}
\examples{
\dontrun{
upstream('Pinus contorta', db = 'itis', upto = 'genus')
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_wiki.R
\name{get_wiki}
\alias{get_wiki}
\alias{as.wiki}
\alias{as.wiki.wiki}
\alias{as.wiki.character}
\alias{as.wiki.list}
\alias{as.wiki.numeric}
\alias{as.wiki.data.frame}
\alias{as.data.frame.wiki}
\alias{get_wiki_}
\title{Get the page name for a Wiki taxon}
\usage{
get_wiki(
  sci_com,
  wiki_site = "species",
  wiki = "en",
  ask = TRUE,
  messages = TRUE,
  limit = 100,
  rows = NA,
  x = NULL,
  ...
)

as.wiki(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.wiki}{wiki}(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.wiki}{character}(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.wiki}{list}(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.wiki}{numeric}(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.wiki}{data.frame}(x, check = TRUE, wiki_site = "species", wiki = "en")

\method{as.data.frame}{wiki}(x, ...)

get_wiki_(
  x,
  messages = TRUE,
  wiki_site = "species",
  wiki = "en",
  limit = 100,
  rows = NA,
  ...
)
}
\arguments{
\item{sci_com}{(character) A vector of common or scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{wiki_site}{(character) Wiki site. One of species (default), pedia,
commons}

\item{wiki}{(character) language. Default: en}

\item{ask}{logical; should get_wiki be run in interactive mode?
If \code{TRUE} and more than one wiki is found for the species, the user is
asked for input. If \code{FALSE} NA is returned for multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{limit}{(integer) number of records to return}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a wiki
class object with one to many identifiers. See \code{\link[=get_wiki_]{get_wiki_()}} to get back
all, or a subset, of the raw data that you are presented during the ask
process.}

\item{x}{For \code{get_wiki()}: deprecated, see \code{sci_com}. For \code{as.wiki}, various,
see examples}

\item{...}{Ignored}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.wiki]{as.wiki()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get the page name for a Wiki taxon
}
\details{
For \code{wiki_site = "pedia" }, we use the english language site by
default. Set the \code{wiki} parameter for a different language site.
}
\examples{
\dontrun{
get_wiki(sci_com = "Quercus douglasii")
get_wiki(sci_com = "Quercu")
get_wiki(sci_com = "Quercu", "pedia")
get_wiki(sci_com = "Quercu", "commons")

# diff. wikis with wikipedia
get_wiki("Malus domestica", "pedia")
get_wiki("Malus domestica", "pedia", "fr")

# as coercion
as.wiki("Malus_domestica")
as.wiki("Malus_domestica", wiki_site = "commons")
as.wiki("Malus_domestica", wiki_site = "pedia")
as.wiki("Malus_domestica", wiki_site = "pedia", wiki = "fr")
as.wiki("Malus_domestica", wiki_site = "pedia", wiki = "da")
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_classification.R
\name{tp_classification}
\alias{tp_classification}
\title{Return all synonyms for a taxon name with a given id.}
\usage{
tp_classification(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_getrecord.R
\name{itis_getrecord}
\alias{itis_getrecord}
\title{Get full ITIS record for one or more ITIS TSN's or lsid's.}
\usage{
itis_getrecord(values, by = "tsn", ...)
}
\arguments{
\item{values}{(character) One or more TSN's (taxonomic serial number) or lsid's for a
taxonomic group}

\item{by}{(character) By "tsn" (default) or "lsid"}

\item{...}{Further arguments passed on to \link[ritis:full_record]{ritis::full_record}}
}
\description{
Get full ITIS record for one or more ITIS TSN's or lsid's.
}
\details{
You can only enter values in tsn parameter or lsid, not both.
}
\examples{
\dontrun{
# by TSN
itis_getrecord(202385)
itis_getrecord(c(202385,70340))

# by lsid
itis_getrecord("urn:lsid:itis.gov:itis_tsn:202385", "lsid")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gbif_parse.R
\name{gbif_parse}
\alias{gbif_parse}
\title{Parse taxon names using the GBIF name parser.}
\usage{
gbif_parse(scientificname, ...)
}
\arguments{
\item{scientificname}{(character) scientific names}

\item{...}{Further args passed on to \link[crul:verb-POST]{crul::verb-POST}}
}
\value{
A \code{data.frame} containing fields extracted from parsed
taxon names. Fields returned are the union of fields extracted from
all species names in \code{scientificname}.
}
\description{
Parse taxon names using the GBIF name parser.
}
\examples{
\dontrun{
gbif_parse(scientificname='x Agropogon littoralis')
gbif_parse(c('Arrhenatherum elatius var. elatius',
             'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',
             'Vanessa atalanta (Linnaeus, 1758)'))
}
}
\references{
https://www.gbif.org/tools/name-parser/about
}
\seealso{
\code{\link[=gni_parse]{gni_parse()}}, \code{\link[=gn_parse]{gn_parse()}}
}
\author{
John Baumgartner \email{johnbb@student.unimelb.edu.au}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/id2name.R
\name{id2name}
\alias{id2name}
\alias{id2name.default}
\alias{id2name.tolid}
\alias{id2name.tsn}
\alias{id2name.uid}
\alias{id2name.wormsid}
\alias{id2name.gbifid}
\alias{id2name.boldid}
\title{Taxonomic IDs to taxonomic names}
\usage{
id2name(id, db = NULL, x = NULL, ...)

\method{id2name}{default}(id, db = NULL, x = NULL, ...)

\method{id2name}{tolid}(id, ...)

\method{id2name}{tsn}(id, ...)

\method{id2name}{uid}(id, ...)

\method{id2name}{wormsid}(id, ...)

\method{id2name}{gbifid}(id, ...)

\method{id2name}{boldid}(id, ...)
}
\arguments{
\item{id}{vector of taxonomic IDs (character or numeric)}

\item{db}{(character) database to query. One or more of \code{tol}, \code{itis},
\code{ncbi}, \code{worms}, \code{gbif}, or \code{bold}. Note that each
taxonomic data source has their own  identifiers, so that if you provide
the wrong \code{db} value for the identifier you could get a result,
but it will likely be wrong (not what you were expecting). If using ncbi
we recommend getting API keys; see \link{taxize-authentication}}

\item{x}{Deprecated, see \code{id}}

\item{...}{Further args passed on to \code{tol_id2name} or
\link{itis_getrecord}, or other internal functions.
See those functions for what parameters can be passed on.}
}
\value{
A named list of data.frames, named by the input taxonomic ids
}
\description{
Taxonomic IDs to taxonomic names
}
\section{HTTP version for NCBI requests}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\examples{
\dontrun{
# ITIS
id2name(19322, db = "itis")

# TOL
id2name(515698, db = "tol")
# get NCBI ID and pass to classification()
x <- id2name(515698, db = "tol")
classification(as.uid(x[[1]]$tax_sources_ncbi))

# NCBI
id2name(315567, db = "ncbi")
id2name(3339, db = "ncbi")
id2name(9696, db = "ncbi")
id2name(c(9695, 9696), db = "ncbi")

# WORMS
id2name(105706, db = "worms")

# GBIF
id2name(2441176, db = "gbif")

# BOLD
id2name(88899, db = "bold")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gn_parse.R
\name{gn_parse}
\alias{gn_parse}
\title{Parse scientific names using Global Names Parser}
\usage{
gn_parse(names, ...)
}
\arguments{
\item{names}{A vector of length 1 or more taxonomic names}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame with results, the submitted names, and the
parsed names with additional information.
}
\description{
Parse scientific names using Global Names Parser
}
\examples{
\dontrun{
gn_parse("Cyanistes caeruleus")
gn_parse("Plantago minor")
gn_parse("Plantago minor minor")
gn_parse(c("Plantago minor minor","Helianthus annuus texanus"))

# if > 20 names, uses an HTTP POST request
x <- names_list("species", size = 30)
gn_parse(x)

# pass on curl options
gn_parse("Cyanistes caeruleus", verbose = TRUE)
}
}
\references{
http://gni.globalnames.org/
}
\seealso{
\code{\link[=gbif_parse]{gbif_parse()}}, \code{\link[=gni_parse]{gni_parse()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iplant_resolve.R
\name{iplant_resolve}
\alias{iplant_resolve}
\title{iPlant name resolution}
\usage{
iplant_resolve(sci, retrieve = "all", query = NULL, ...)
}
\arguments{
\item{sci}{Vector of one or more taxonomic names (no common names)}

\item{retrieve}{Specifies whether to retrieve all matches for the
names submitted. One of 'best' (retrieves only the single best match
for each name submitted) or 'all' (retrieves all matches)}

\item{query}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame
}
\description{
iPlant name resolution
}
\examples{
\dontrun{
iplant_resolve(sci=c("Helianthus annuus", "Homo sapiens"))
iplant_resolve("Helianthusss")
iplant_resolve("Pooa")
iplant_resolve("Helianthusss", verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fungorum.R
\name{fungorum}
\alias{fungorum}
\alias{fg_name_search}
\alias{fg_author_search}
\alias{fg_epithet_search}
\alias{fg_name_by_key}
\alias{fg_name_full_by_lsid}
\alias{fg_all_updated_names}
\alias{fg_deprecated_names}
\title{Index Fungorum}
\usage{
fg_name_search(q, anywhere = TRUE, limit = 10, ...)

fg_author_search(q, anywhere = TRUE, limit = 10, ...)

fg_epithet_search(q, anywhere = TRUE, limit = 10, ...)

fg_name_by_key(key, ...)

fg_name_full_by_lsid(lsid, ...)

fg_all_updated_names(date, ...)

fg_deprecated_names(date, ...)
}
\arguments{
\item{q}{(character) Query term}

\item{anywhere}{(logical) Default: \code{TRUE}}

\item{limit}{(integer) Number of results to return. max limit
value appears to be 6000, not positive about that though}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}

\item{key}{(character) A IndexFungorum taxon key}

\item{lsid}{(character) an LSID, e.,g. "urn:lsid:indexfungorum.org:names:81085"}

\item{date}{(character) Date, of the form YYYMMDD}
}
\value{
A \code{data.frame}, or \code{NULL} if no results
}
\description{
Search for taxonomic names in Index Fungorum
}
\examples{
\dontrun{
# NameSearch
fg_name_search(q = "Gymnopus", limit = 2, verbose = TRUE)
fg_name_search(q = "Gymnopus")

# EpithetSearch
fg_epithet_search(q = "phalloides")

# NameByKey
fg_name_by_key(17703)

# NameFullByKey
fg_name_full_by_lsid("urn:lsid:indexfungorum.org:names:81085")

# AllUpdatedNames
fg_all_updated_names(date = gsub("-", "", Sys.Date() - 2))

# DeprecatedNames
fg_deprecated_names(date=20151001)

# AuthorSearch
fg_author_search(q = "Fayod", limit = 2)
}
}
\references{
http://www.indexfungorum.org/, API docs:
http://www.indexfungorum.org/ixfwebservice/fungus.asmx
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_getbyid.R
\name{ncbi_getbyid}
\alias{ncbi_getbyid}
\title{Retrieve gene sequences from NCBI by accession number.}
\usage{
ncbi_getbyid(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\author{
Scott Chamberlain
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apg.R
\name{apg}
\alias{apg}
\alias{apgOrders}
\alias{apgFamilies}
\title{Get APG names}
\usage{
apgOrders(...)

apgFamilies(...)
}
\arguments{
\item{...}{Curl args passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\description{
Generic names and their replacements from the Angiosperm Phylogeny
Group III system of flowering plant classification.
}
\examples{
\dontrun{
head(apgOrders())
head(apgFamilies())
}
}
\references{
http://www.mobot.org/MOBOT/research/APweb/
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{package}
\name{taxize-package}
\alias{taxize-package}
\alias{taxize}
\title{Taxonomic Information from Around the Web}
\description{
This package interacts with a suite of web 'APIs'
for taxonomic tasks, such as verifying species names, getting
taxonomic hierarchies, and verifying name spelling.
}
\section{About}{

Allows users to search over many websites for species names (scientific and
common) and download up- and downstream taxonomic hierarchical information -
and many other things.

The functions in the package that hit a specific API have a prefix and suffix
separated by an underscore. They follow the format of \code{service_whatitdoes}.
For example, \code{gnr_resolve} uses the Global Names Resolver API to resolve
species names.

General functions in the package that don't hit a specific API don't have
two words separated by an underscore, e.g., \code{classification}

You need API keys for some data sources. See \link{taxize-authentication}
for more information.
}

\section{Currently supported APIs}{


\tabular{llc}{
API \tab prefix \tab SOAP? \cr
Encyclopedia of Life (EOL)  \tab eol \tab FALSE \cr
Integrated Taxonomic Information Service (ITIS)  \tab itis \tab FALSE \cr
Global Names Resolver (from EOL/GBIF) \tab gnr \tab FALSE \cr
Global Names Index (from EOL/GBIF) \tab gni \tab FALSE \cr
IUCN Red List \tab iucn \tab FALSE \cr
Tropicos (from Missouri Botanical Garden) \tab tp \tab FALSE \cr
Theplantlist.org \tab tpl \tab FALSE \cr
National Center for Biotechnology Information \tab ncbi \tab FALSE \cr
CANADENSYS Vascan name search API \tab vascan \tab FALSE \cr
International Plant Names Index (IPNI) \tab ipni \tab FALSE \cr
World Register of Marine Species (WoRMS) \tab worms \tab TRUE \cr
Barcode of Life Data Systems (BOLD) \tab bold \tab FALSE \cr
Pan-European Species directories Infrastructure (PESI) \tab pesi \tab TRUE \cr
Mycobank \tab myco \tab TRUE \cr
National Biodiversity Network (UK)	\tab nbn \tab FALSE \cr
Index Fungorum \tab fg \tab FALSE \cr
EU BON \tab eubon \tab FALSE \cr
Index of Names (ION) \tab ion \tab FALSE \cr
Open Tree of Life (TOL) \tab tol \tab FALSE \cr
World Register of Marine Species (WoRMS) \tab worms \tab FALSE \cr
NatureServe \tab natserv \tab FALSE \cr
}

If the source above has a \code{TRUE} in the \verb{SOAP?} column, it is not available
in this package. They are available from a different package called \strong{taxizesoap}.
See the GitHub repo for how to install https://github.com/ropensci/taxizesoap
}

\section{Catalogue of Life (COL)}{

COL introduced rate limiting recently in 2019 - which has made the API
essentially unusable - CoL+ is coming soon and we'll incorporate it here
when it's stable. See https://github.com/ropensci/colpluz for the
R implementation for CoL+
}

\author{
Scott Chamberlain

Eduard Szoecs \email{eduardszoecs@gmail.com}

Zachary Foster \email{zacharyfoster1989@gmail.com}

Carl Boettiger \email{cboettig@gmail.com}

Karthik Ram \email{karthik@ropensci.org}

Ignasi Bartomeus \email{nacho.bartomeus@gmail.com}

John Baumgartner \email{johnbb@student.unimelb.edu.au}

James O'Donnell \email{jodonnellbio@gmail.com}
}
\keyword{package}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gbif_name_usage.R
\name{gbif_name_usage}
\alias{gbif_name_usage}
\title{Lookup details for specific names in all taxonomies in GBIF.}
\usage{
gbif_name_usage(
  key = NULL,
  name = NULL,
  data = "all",
  language = NULL,
  datasetKey = NULL,
  uuid = NULL,
  sourceId = NULL,
  rank = NULL,
  shortname = NULL,
  start = NULL,
  limit = 20,
  ...
)
}
\arguments{
\item{key}{(numeric) A GBIF key for a taxon}

\item{name}{(character) Filters by a case insensitive, canonical namestring,
e.g. 'Puma concolor'}

\item{data}{(character) Specify an option to select what data is returned. See Description
below.}

\item{language}{(character) Language, default is english}

\item{datasetKey}{(character) Filters by the dataset's key (a uuid)}

\item{uuid}{(character) A uuid for a dataset. Should give exact same results as datasetKey.}

\item{sourceId}{(numeric) Filters by the source identifier. Not used right now.}

\item{rank}{(character) Taxonomic rank. Filters by taxonomic rank as one of:
CLASS, CULTIVAR, CULTIVAR_GROUP, DOMAIN, FAMILY, FORM, GENUS, INFORMAL,
INFRAGENERIC_NAME, INFRAORDER, INFRASPECIFIC_NAME, INFRASUBSPECIFIC_NAME,
KINGDOM, ORDER, PHYLUM, SECTION, SERIES, SPECIES, STRAIN, SUBCLASS, SUBFAMILY,
SUBFORM, SUBGENUS, SUBKINGDOM, SUBORDER, SUBPHYLUM, SUBSECTION, SUBSERIES,
SUBSPECIES, SUBTRIBE, SUBVARIETY, SUPERCLASS, SUPERFAMILY, SUPERORDER,
SUPERPHYLUM, SUPRAGENERIC_NAME, TRIBE, UNRANKED, VARIETY}

\item{shortname}{(character) A short name..need more info on this?}

\item{start}{Record number to start at}

\item{limit}{Number of records to return}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
A list of length two. The first element is metadata. The second is
either a data.frame (verbose=FALSE, default) or a list (verbose=TRUE)
}
\description{
This is a taxize version of the same function in the \code{rgbif} package so as to not have to
import rgbif and thus require GDAL binary installation.
}
\references{
https://www.gbif.org/developer/summary
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/names_list.r
\name{names_list}
\alias{names_list}
\title{Get a random vector of species names.}
\usage{
names_list(rank = "genus", size = 10)
}
\arguments{
\item{rank}{(character) Taxonomic rank, one of species, genus (default),
family, order}

\item{size}{(integer/numeric) Number of names to get. Maximum depends on
the rank}
}
\value{
character vector of taxonomic names
}
\description{
Family and order names come from the APG plant names list. Genus and
species names come from Theplantlist.org.
}
\examples{
names_list()
names_list('species')
names_list('genus')
names_list('family')
names_list('order')
names_list('order', 2)
names_list('order', 15)

# You can get a lot of genus or species names if you want
nrow(theplantlist)
names_list('genus', 500)
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_wormsid.R
\name{get_wormsid}
\alias{get_wormsid}
\alias{as.wormsid}
\alias{as.wormsid.wormsid}
\alias{as.wormsid.character}
\alias{as.wormsid.list}
\alias{as.wormsid.numeric}
\alias{as.wormsid.data.frame}
\alias{as.data.frame.wormsid}
\alias{get_wormsid_}
\title{Get Worms ID for a taxon name}
\usage{
get_wormsid(
  sci_com,
  searchtype = "scientific",
  marine_only = TRUE,
  fuzzy = NULL,
  accepted = FALSE,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  query = NULL,
  ...
)

as.wormsid(x, check = TRUE)

\method{as.wormsid}{wormsid}(x, check = TRUE)

\method{as.wormsid}{character}(x, check = TRUE)

\method{as.wormsid}{list}(x, check = TRUE)

\method{as.wormsid}{numeric}(x, check = TRUE)

\method{as.wormsid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{wormsid}(x, ...)

get_wormsid_(
  sci_com,
  messages = TRUE,
  searchtype = "scientific",
  marine_only = TRUE,
  fuzzy = NULL,
  accepted = TRUE,
  rows = NA,
  query = NULL,
  ...
)
}
\arguments{
\item{sci_com}{character; A vector of common or scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{searchtype}{character; One of 'scientific' or 'common', or any unique
abbreviation}

\item{marine_only}{logical; marine only? default: \code{TRUE} (only used
when \code{searchtype="scientific"}); passed on to \code{\link[worrms:wm_records_name]{worrms::wm_records_name()}}}

\item{fuzzy}{logical; fuzzy search. default: \code{NULL} (\code{TRUE} for
\code{searchtype="scientific"} and \code{FALSE} for \code{searchtype="common"} to match
the default values for those parameters in \pkg{worrms} package); passed on
to \code{\link[worrms:wm_records_name]{worrms::wm_records_name()}} or \code{\link[worrms:wm_records_common]{worrms::wm_records_common()}}}

\item{accepted}{logical; If TRUE, removes names that are not accepted valid
names by WORMS. Set to \code{FALSE} (default) to give back both accepted
and unaccepted names.}

\item{ask}{logical; should get_wormsid be run in interactive mode?
If \code{TRUE} and more than one wormsid is found for the species, the
user is asked for input. If \code{FALSE} NA is returned for
multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{rows}{numeric; Any number from 1 to infinity. If the default NaN, all
rows are considered. Note that this function still only gives back a wormsid
class object with one to many identifiers. See \code{\link[=get_wormsid_]{get_wormsid_()}} to get back
all, or a subset, of the raw data that you are presented during the ask
process.}

\item{query}{Deprecated, see \code{sci_com}}

\item{...}{Ignored}

\item{x}{Input to \code{as.wormsid}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.wormsid]{as.wormsid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Retrieve Worms ID of a taxon from World Register of Marine
Species (WORMS).
}
\examples{
\dontrun{
(x <- get_wormsid('Gadus morhua'))
attributes(x)
attr(x, "match")
attr(x, "multiple_matches")
attr(x, "pattern_match")
attr(x, "uri")

get_wormsid('Pomatomus saltatrix')
get_wormsid(c("Gadus morhua", "Lichenopora neapolitana"))

# marine_only
get_wormsid("Apedinella", marine_only=TRUE)
get_wormsid("Apedinella", marine_only=FALSE)

# fuzzy
## searchtype="scientific": fuzzy is TRUE by default
get_wormsid("Platypro", searchtype="scientific", fuzzy=TRUE)
get_wormsid("Platypro", searchtype="scientific", fuzzy=FALSE)
## searchtype="common": fuzzy is FALSE by default
get_wormsid("clam", searchtype="common", fuzzy=FALSE)
get_wormsid("clam", searchtype="common", fuzzy=TRUE)

# by common name
get_wormsid("dolphin", 'common')
get_wormsid("clam", 'common')

# specify rows to limit choices available
get_wormsid('Plat')
get_wormsid('Plat', rows=1)
get_wormsid('Plat', rows=1:2)

# When not found
get_wormsid("howdy")
get_wormsid(c('Gadus morhua', "howdy"))

# Convert a wormsid without class information to a wormsid class
# already a wormsid, returns the same
as.wormsid(get_wormsid('Gadus morhua'))
# same
as.wormsid(get_wormsid(c('Gadus morhua', 'Pomatomus saltatrix')))
# numeric
as.wormsid(126436)
# numeric vector, length > 1
as.wormsid(c(126436,151482))
# character
as.wormsid("126436")
# character vector, length > 1
as.wormsid(c("126436","151482"))
# list, either numeric or character
as.wormsid(list("126436","151482"))
## dont check, much faster
as.wormsid("126436", check=FALSE)
as.wormsid(126436, check=FALSE)
as.wormsid(c("126436","151482"), check=FALSE)
as.wormsid(list("126436","151482"), check=FALSE)

(out <- as.wormsid(c(126436,151482)))
data.frame(out)
as.wormsid( data.frame(out) )

# Get all data back
get_wormsid_("Plat")
get_wormsid_("Plat", rows=1)
get_wormsid_("Plat", rows=1:2)
get_wormsid_("Plat", rows=1:75)
# get_wormsid_(c("asdfadfasd","Plat"), rows=1:5)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iucn_summary.R
\name{iucn_status}
\alias{iucn_status}
\title{Extractor functions for \code{iucn}-class.}
\usage{
iucn_status(x, ...)
}
\arguments{
\item{x}{an \code{iucn}-object as returned b\code{iucn_summary}ry}

\item{...}{Currently not used}
}
\value{
A character vector with the status.
}
\description{
Extractor functions for \code{iucn}-class.
}
\examples{
\dontrun{
ia <- iucn_summary(c("Panthera uncia", "Lynx lynx"))
iucn_status(ia)}
}
\seealso{
\code{\link[=iucn_summary]{iucn_summary()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_ubioid.R
\name{get_ubioid}
\alias{get_ubioid}
\alias{as.ubioid}
\alias{get_ubioid_}
\title{Get the uBio id for a search term}
\usage{
get_ubioid(...)

as.ubioid(...)

get_ubioid_(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_iucn.R
\name{get_iucn}
\alias{get_iucn}
\alias{as.iucn}
\alias{as.iucn.iucn}
\alias{as.iucn.character}
\alias{as.iucn.list}
\alias{as.iucn.numeric}
\alias{as.iucn.data.frame}
\alias{as.data.frame.iucn}
\title{Get a IUCN Redlist taxon}
\usage{
get_iucn(sci, messages = TRUE, key = NULL, x = NULL, ...)

as.iucn(x, check = TRUE, key = NULL)

\method{as.iucn}{iucn}(x, check = TRUE, key = NULL)

\method{as.iucn}{character}(x, check = TRUE, key = NULL)

\method{as.iucn}{list}(x, check = TRUE, key = NULL)

\method{as.iucn}{numeric}(x, check = TRUE, key = NULL)

\method{as.iucn}{data.frame}(x, check = TRUE, key = NULL)

\method{as.data.frame}{iucn}(x, ...)
}
\arguments{
\item{sci}{(character) A vector of scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{messages}{logical; should progress be printed?}

\item{key}{(character) required. you IUCN Redlist API key. See
\link[rredlist:rredlist-package]{rredlist::rredlist-package} for help on authenticating with
IUCN Redlist}

\item{x}{For \code{get_iucn()}: Deprecated, see \code{sci}. For \code{as.iucn()}, various,
see examples}

\item{...}{Ignored}

\item{check}{(logical) Check if ID matches any existing on the DB, only
used in \code{\link[=as.iucn]{as.iucn()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.

Comes with the following attributes:
\itemize{
\item \emph{match} (character) - the reason for NA, either 'not found',
'found' or if \code{ask = FALSE} then 'NA due to ask=FALSE')
\item \emph{name} (character) - the taxonomic name, which is needed in
\code{\link[=synonyms]{synonyms()}} and \code{\link[=sci2comm]{sci2comm()}} methods since they
internally use \pkg{rredlist} functions which require the taxonomic name,
and not the taxonomic identifier
\item \emph{ri} (character) - The URI where more information can be
read on the taxon - includes the taxonomic identifier in the URL somewhere
}

\emph{multiple_matches} and \emph{pattern_match} do not apply here as in other \verb{get_*}
methods since there is no IUCN Redlist search, so you either get a match or
you do not get a match.
}
\description{
Get a IUCN Redlist taxon
}
\details{
There is no underscore method, because there's no real
search for IUCN, that is, where you search for a string, and get back
a bunch of results due to fuzzy matching. If that exists in the future
we'll add an underscore method here.

IUCN ids only work with \code{\link[=synonyms]{synonyms()}} and \code{\link[=sci2comm]{sci2comm()}}
methods.
}
\examples{
\dontrun{
get_iucn("Branta canadensis")
get_iucn("Branta bernicla")
get_iucn("Panthera uncia")

# as coercion
as.iucn(22732)
as.iucn("22732")
(res <- as.iucn(c(22679946, 22732, 22679935)))
data.frame(res)
as.iucn(data.frame(res))
}
}
\seealso{
Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_boldid.R
\name{get_boldid}
\alias{get_boldid}
\alias{as.boldid}
\alias{as.boldid.boldid}
\alias{as.boldid.character}
\alias{as.boldid.list}
\alias{as.boldid.numeric}
\alias{as.boldid.data.frame}
\alias{as.data.frame.boldid}
\alias{get_boldid_}
\title{Get the BOLD (Barcode of Life) code for a search term.}
\usage{
get_boldid(
  sci,
  fuzzy = FALSE,
  dataTypes = "basic",
  includeTree = FALSE,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  rank = NULL,
  division = NULL,
  parent = NULL,
  searchterm = NULL,
  ...
)

as.boldid(x, check = TRUE)

\method{as.boldid}{boldid}(x, check = TRUE)

\method{as.boldid}{character}(x, check = TRUE)

\method{as.boldid}{list}(x, check = TRUE)

\method{as.boldid}{numeric}(x, check = TRUE)

\method{as.boldid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{boldid}(x, ...)

get_boldid_(
  sci,
  messages = TRUE,
  fuzzy = FALSE,
  dataTypes = "basic",
  includeTree = FALSE,
  rows = NA,
  searchterm = NULL,
  ...
)
}
\arguments{
\item{sci}{character; A vector of scientific names. Or,
a \code{taxon_state} object (see \link{taxon-state})}

\item{fuzzy}{(logical) Whether to use fuzzy search or not (default: FALSE).}

\item{dataTypes}{(character) Specifies the datatypes that will be returned.
See \code{\link[=bold_search]{bold_search()}} for options.}

\item{includeTree}{(logical) If TRUE (default: FALSE), returns a list
containing information for parent taxa as well as the specified taxon.}

\item{ask}{logical; should get_tsn be run in interactive mode?
If TRUE and more than one TSN is found for teh species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all rows are
considered. Note that this function still only gives back a boldid class object with one
to many identifiers. See \code{\link[=get_boldid_]{get_boldid_()}} to get back all, or a subset,
of the raw data that you are presented during the ask process.}

\item{rank}{(character) A taxonomic rank name. See \link{rank_ref} for possible
options. Though note that some data sources use atypical ranks, so inspect the
data itself for options. Optional. See \code{Filtering} below.}

\item{division}{(character) A division (aka phylum) name. Optional. See \code{Filtering}
below.}

\item{parent}{(character) A parent name (i.e., the parent of the target search
taxon). Optional. See \code{Filtering} below.}

\item{searchterm}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \code{\link[crul:verb-GET]{crul::verb-GET}}}

\item{x}{Input to \code{\link[=as.boldid]{as.boldid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only used in
\code{\link[=as.boldid]{as.boldid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get the BOLD (Barcode of Life) code for a search term.
}
\section{Filtering}{

The parameters \code{division}, \code{parent}, and \code{rank} are not used in the search to
the data provider, but are used in filtering the data down to a subset that
is closer to the target you want.  For all these parameters, you can use
regex strings since we use \code{\link[=grep]{grep()}} internally to match. Filtering narrows
down to the set that matches your query, and removes the rest.
}

\examples{
\dontrun{
get_boldid(sci = "Agapostemon")
get_boldid(sci = "Chironomus riparius")
get_boldid(c("Chironomus riparius","Quercus douglasii"))
splist <- names_list('species')
get_boldid(splist, messages=FALSE)

# Fuzzy searching
get_boldid(sci="Osmi", fuzzy=TRUE)

# Get back a subset
get_boldid(sci="Osmi", fuzzy=TRUE, rows = 1)
get_boldid(sci="Osmi", fuzzy=TRUE, rows = 1:10)
get_boldid(sci=c("Osmi","Aga"), fuzzy=TRUE, rows = 1)
get_boldid(sci=c("Osmi","Aga"), fuzzy=TRUE, rows = 1:3)

# found
get_boldid('Epicordulia princeps')
get_boldid('Arigomphus furcifer')

# When not found
get_boldid("howdy")
get_boldid(c("Chironomus riparius", "howdy"))
get_boldid("Cordulegaster erronea")
get_boldid("Nasiaeshna pentacantha")

# Narrow down results to a division or rank, or both
## Satyrium example
### Results w/o narrowing
get_boldid("Satyrium")
### w/ phylum
get_boldid("Satyrium", division = "Plantae")
get_boldid("Satyrium", division = "Animalia")

## Rank example
get_boldid("Osmia", fuzzy = TRUE)
get_boldid("Osmia", fuzzy = TRUE, rank = "genus")

# Fuzzy filter on any filtering fields
## uses grep on the inside
get_boldid("Satyrium", division = "anim")
get_boldid("Aga", fuzzy = TRUE, parent = "*idae")

# Convert a boldid without class information to a boldid class
as.boldid(get_boldid("Agapostemon")) # already a boldid, returns the same
as.boldid(get_boldid(c("Agapostemon","Quercus douglasii"))) # same
as.boldid(1973) # numeric
as.boldid(c(1973,101009,98597)) # numeric vector, length > 1
as.boldid("1973") # character
as.boldid(c("1973","101009","98597")) # character vector, length > 1
as.boldid(list("1973","101009","98597")) # list, either numeric or character
## dont check, much faster
as.boldid("1973", check=FALSE)
as.boldid(1973, check=FALSE)
as.boldid(c("1973","101009","98597"), check=FALSE)
as.boldid(list("1973","101009","98597"), check=FALSE)

(out <- as.boldid(c(1973,101009,98597)))
data.frame(out)
as.boldid( data.frame(out) )

# Get all data back
get_boldid_("Osmia", fuzzy=TRUE, rows=1:5)
get_boldid_("Osmia", fuzzy=TRUE, rows=1)
get_boldid_(c("Osmi","Aga"), fuzzy=TRUE, rows = 1:3)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gbif_downstream.R
\name{gbif_downstream}
\alias{gbif_downstream}
\title{Retrieve all taxonomic names downstream in hierarchy for GBIF}
\usage{
gbif_downstream(
  id,
  downto,
  intermediate = FALSE,
  limit = 100,
  start = NULL,
  key = NULL,
  ...
)
}
\arguments{
\item{id}{A taxonomic serial number.}

\item{downto}{The taxonomic level you want to go down to. See examples below.
The taxonomic level IS case sensitive, and you do have to spell it
correctly. See \code{data(rank_ref)} for spelling.}

\item{intermediate}{(logical) If TRUE, return a list of length two with
target taxon rank names, with additional list of data.frame's of
intermediate taxonomic groups. Default: FALSE}

\item{limit}{Number of records to return. default: 100. max: 1000. use in
combination with the \code{start} parameter}

\item{start}{Record number to start at. default: 0. use in combination
with the \code{limit} parameter}

\item{key}{Deprecated, see \code{id}}

\item{...}{Further args passed on to \code{\link[=gbif_name_usage]{gbif_name_usage()}}}
}
\value{
data.frame of taxonomic information downstream to family from e.g.,
Order, Class, etc., or if \code{intermediated=TRUE}, list of length two,
with target taxon rank names, and intermediate names.
}
\description{
Retrieve all taxonomic names downstream in hierarchy for GBIF
}
\details{
Sometimes records don't have a \code{canonicalName} entry which is
what we look for. In that case we grab the \code{scientificName} entry.
You can see the type of name colleceted in the column \code{name_type}
}
\examples{
\dontrun{
## the plant class Bangiophyceae
gbif_downstream(id = 198, downto="genus")
gbif_downstream(id = 198, downto="genus", intermediate=TRUE)

# families downstream from the family Strepsiptera (twisted wing parasites)
gbif_downstream(id = 1227, "family")
## here, intermediate leads to the same result as the target
gbif_downstream(id = 1227, "family", intermediate=TRUE)

if (interactive()) {
# Lepidoptera
gbif_downstream(id = 797, "family")

# get species downstream from the genus Ursus
gbif_downstream(id = 2433406, "species")

# get tribes down from the family Apidae
gbif_downstream(id = 7799978, downto="species")
gbif_downstream(id = 7799978, downto="species", intermediate=TRUE)

# names that don't have canonicalname entries for some results
# Myosotis: key 2925668
key <- 2925668
res <- gbif_downstream(key, downto = "species")
res2 <- downstream(key, db = "gbif", downto = "species")

# Pagination
# GBIF limits queries to a maximum of 1000 records per request, so if
# there's more than 1000, use the start parameter
# Piper, taxonKey = 3075433
x1 <- gbif_downstream(id = 3075433, downto = "species", limit=1000)
x2 <- gbif_downstream(id = 3075433, downto = "species", limit=1000,
  start=1000)
x3 <- gbif_downstream(id = 3075433, downto = "species", limit=1000,
  start=2000)
x4 <- gbif_downstream(id = 3075433, downto = "species", limit=1000,
  start=3000)
rbind(x1, x2, x3, x4)
}
}
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ubio_classification.R
\name{ubio_classification}
\alias{ubio_classification}
\title{uBio classification}
\usage{
ubio_classification(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bold_search.R
\name{bold_children}
\alias{bold_children}
\title{Barcode of Life taxonomic children}
\usage{
bold_children(id, ...)
}
\arguments{
\item{id}{(integer) A BOLD taxonomic identifier. length=1. required}

\item{...}{named curl options passed on to \link[crul:verb-GET]{crul::verb-GET}
debugging}
}
\value{
list of data.frame's
}
\description{
BEWARE: this function scrapes data from the BOLD website, so may
be unstable. That is, one day it may work, and the next it may fail.
Open an issue if you encounter an error:
https://github.com/ropensci/taxize/issues
}
\examples{
\dontrun{
# Osmia (genus): 253 children
bold_children(id = 4940)
# Momotus (genus): 3 children
bold_children(id = 88899)
# Momotus aequatorialis (species): no children
bold_children(id = 115130)
# Osmia sp1 (species): no children
bold_children(id = 293378)
# Arthropoda (phylum): 27 children
bold_children(id = 82)
# Psocodea (order): 51 children
bold_children(id = 737139)
# Megachilinae (subfamily): 2 groups (tribes: 3, genera: 60)
bold_children(id = 4962)
# Stelis (species): 78 taxa
bold_children(id = 4952)
}
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/key_helpers.R
\name{key_helpers}
\alias{key_helpers}
\alias{use_tropicos}
\alias{use_entrez}
\alias{use_iucn}
\title{Helpers to set up authentication for the different providers.}
\usage{
use_tropicos()

use_entrez()

use_iucn()
}
\description{
Sets up authentication to diverse providers by providing
the user a detailed prompt.
}
\details{
Key helpers
}
\section{\code{use_tropicos()}}{

Browses to Tropicos API key request URL and provides instruction on how to
store the key. After filling the form you will get the key soon, but
not immediately.
}

\section{\code{use_entrez()}}{

Browse NCBI Entrez to help make an API key request and provides instruction
on how to store the key. There's no direct URL to request a key, one first
needs to log in or register and then to generate a key from one's account.

Note that NCBI Entrez doesn't require that you use an API key,
but you should get higher rate limit with a key, so do get one.
}

\section{\code{use_iucn()}}{

Browse IUCN Red List API key request URL and provides instruction on how
to store the key. This function wraps \code{\link[rredlist:rl_use_iucn]{rredlist::rl_use_iucn()}}
from the \code{rredlist} package. After filling the form you will get
the key soon, but not immediately.
}

\seealso{
\link{taxize-authentication}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_uid.R
\name{get_uid}
\alias{get_uid}
\alias{as.uid}
\alias{as.uid.uid}
\alias{as.uid.character}
\alias{as.uid.list}
\alias{as.uid.numeric}
\alias{as.uid.data.frame}
\alias{as.data.frame.uid}
\alias{get_uid_}
\title{Get the UID codes from NCBI for taxonomic names.}
\usage{
get_uid(
  sci_com,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  modifier = NULL,
  rank_query = NULL,
  division_filter = NULL,
  rank_filter = NULL,
  key = NULL,
  sciname = NULL,
  ...
)

as.uid(x, check = TRUE)

\method{as.uid}{uid}(x, check = TRUE)

\method{as.uid}{character}(x, check = TRUE)

\method{as.uid}{list}(x, check = TRUE)

\method{as.uid}{numeric}(x, check = TRUE)

\method{as.uid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{uid}(x, ...)

get_uid_(sci_com, messages = TRUE, rows = NA, key = NULL, sciname = NULL, ...)
}
\arguments{
\item{sci_com}{character; scientific or common name. Or, a \code{taxon_state}
object (see \link{taxon-state})}

\item{ask}{logical; should get_uid be run in interactive mode? If TRUE and
more than one TSN is found for the species, the user is asked for input. If
FALSE NA is returned for multiple matches.}

\item{messages}{logical; If \code{TRUE} (default) the actual taxon queried is
printed on the console.}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a uid
class object with one to many identifiers. See \code{\link[=get_uid_]{get_uid_()}} to get back
all, or a subset, of the raw data that you are presented during the ask
process.}

\item{modifier}{(character) A modifier to the \code{sci_com} given. Options
include: Organism, Scientific Name, Common Name, All Names, Division,
Filter, Lineage, GC, MGC, Name Tokens, Next Level, PGC, Properties, Rank,
Subtree, Synonym, Text Word. These are not checked, so make sure they are
entered correctly, as is.}

\item{rank_query}{(character) A taxonomic rank name to modify the query sent
to NCBI. See \link{rank_ref} for possible options. Though note that
some data sources use atypical ranks, so inspect the data itself for
options. Optional. See \code{Querying} below.}

\item{division_filter}{(character) A division (aka phylum) name to filter
data after retrieved from NCBI. Optional. See \code{Filtering} below.}

\item{rank_filter}{(character) A taxonomic rank name to filter data after
retrieved from NCBI. See \link{rank_ref} for possible options.
Though note that some data sources use atypical ranks, so inspect the data
itself for options. Optional. See \code{Filtering} below.}

\item{key}{(character) NCBI Entrez API key. optional. See Details.}

\item{sciname}{Deprecated, see \code{sci_com}}

\item{...}{Ignored}

\item{x}{Input to \code{\link[=as.uid]{as.uid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only used
in \code{\link[=as.uid]{as.uid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Retrieve the Unique Identifier (UID) of a taxon from NCBI taxonomy browser.
}
\section{Rate limits}{

In case you run into errors due to your rate limit being exceeded, see
\code{\link[=taxize_options]{taxize_options()}}, where you can set \code{ncbi_sleep}.
}

\section{Querying}{
 The parameter \code{rank_query} is used in the search sent
to NCBI, whereas \code{rank_filter} filters data after it comes back. The
parameter \code{modifier} adds modifiers to the name. For example,
\code{modifier="Organism"} adds that to the name, giving e.g.,
\code{Helianthus[Organism]}.
}

\section{Filtering}{
 The parameters \code{division_filter} and
\code{rank_filter} are not used in the search to the data provider, but are
used in filtering the data down to a subset that is closer to the target
you want. For all these parameters, you can use regex strings since we use
\code{\link[=grep]{grep()}} internally to match. Filtering narrows down to the set
that matches your query, and removes the rest.
}

\section{Beware}{
 NCBI does funny things sometimes. E.g., if you search on
Fringella morel, a slight misspelling of the genus name, and a non-existent
epithet, NCBI gives back a morel fungal species. In addition, NCBI doesn't
really do fuzzy searching very well, so if there is a slight mis-spelling
in your names, you likely won't get what you are expecting. The lesson:
clean your names before using this function. Other data sources are better
about fuzzy matching.
}

\section{Authentication}{

See \link{taxize-authentication} for help on authentication

Note that even though you can't pass in your key to \code{as.uid} functions,
we still use your Entrez API key if you have it saved as an R option
or environment variable.
}

\section{HTTP version}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\examples{
\dontrun{
get_uid(c("Chironomus riparius", "Chaetopteryx"))
get_uid(c("Chironomus riparius", "aaa vva"))

# When not found
get_uid("howdy")
get_uid(c("Chironomus riparius", "howdy"))

# Narrow down results to a division or rank, or both
## By modifying the query
### w/ modifiers to the name
get_uid(sci_com = "Aratinga acuticauda", modifier = "Organism")
get_uid(sci_com = "bear", modifier = "Common Name")

### w/ rank query
get_uid(sci_com = "Pinus", rank_query = "genus")
get_uid(sci_com = "Pinus", rank_query = "subgenus")
### division query doesn't really work, for unknown reasons, so not available

## By filtering the result
## Echinacea example
### Results w/o narrowing
get_uid("Echinacea")
### w/ division
get_uid(sci_com = "Echinacea", division_filter = "eudicots")
get_uid(sci_com = "Echinacea", division_filter = "sea urchins")

## Satyrium example
### Results w/o narrowing
get_uid(sci_com = "Satyrium")
### w/ division
get_uid(sci_com = "Satyrium", division_filter = "monocots")
get_uid(sci_com = "Satyrium", division_filter = "butterflies")

## Rank example
get_uid(sci_com = "Pinus")
get_uid(sci_com = "Pinus", rank_filter = "genus")
get_uid(sci_com = "Pinus", rank_filter = "subgenus")

# Fuzzy filter on any filtering fields
## uses grep on the inside
get_uid("Satyrium", division_filter = "m")

# specify rows to limit choices available
get_uid('Dugesia') # user prompt needed
get_uid('Dugesia', rows=1) # 2 choices, so returns only 1 row, so no choices
get_uid('Dugesia', ask = FALSE) # returns NA for multiple matches

# Go to a website with more info on the taxon
res <- get_uid("Chironomus riparius")
browseURL(attr(res, "uri"))

# Convert a uid without class information to a uid class
as.uid(get_uid("Chironomus riparius")) # already a uid, returns the same
as.uid(get_uid(c("Chironomus riparius","Pinus contorta"))) # same
as.uid(315567) # numeric
as.uid(c(315567,3339,9696)) # numeric vector, length > 1
as.uid("315567") # character
as.uid(c("315567","3339","9696")) # character vector, length > 1
as.uid(list("315567","3339","9696")) # list, either numeric or character
## dont check, much faster
as.uid("315567", check=FALSE)
as.uid(315567, check=FALSE)
as.uid(c("315567","3339","9696"), check=FALSE)
as.uid(list("315567","3339","9696"), check=FALSE)

(out <- as.uid(c(315567,3339,9696)))
data.frame(out)
as.uid( data.frame(out) )

# Get all data back
get_uid_("Puma concolor")
get_uid_("Dugesia")
get_uid_("Dugesia", rows=2)
get_uid_("Dugesia", rows=1:2)
get_uid_(c("asdfadfasd","Pinus contorta"))

# use curl options
get_uid("Quercus douglasii", verbose = TRUE)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\author{
Eduard Szoecs, \email{eduardszoecs@gmail.com}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-authentication.R
\name{taxize-authentication}
\alias{taxize-authentication}
\alias{authentication}
\title{taxize authentication}
\description{
Help on authentication
}
\section{What is an API?}{

An API is an Application Programming Interface. The term "API" can be used
for lots of scenarios, but in this case we're talking about web APIs,
or APIs (interfaces) to web resources. \pkg{taxize} interacts with
remote databases on the web via their APIs. You don't need to worry
about the details of how that all works; just know that some of them
require authentication and some do not.
}

\section{What are API keys?}{

For those APIs that require authentication, the way that's typically done
is through API keys: alphanumeric strings of variable lengths that are
supplied with a request to an API.

\pkg{taxize} won't get these keys for you; rather, you have to
go get a key for each service, but we do provide information on how
to get those keys. See \code{\link[=key_helpers]{key_helpers()}} for help on how to
obtain keys for this package.
}

\section{Using API keys}{

You can store API keys as R options in your \code{.Rprofile} file, or
as environment variables in either your \code{.Renviron} file or
\code{.bash_profile} file, o\code{.zshrc} file (if you use oh-my-zsh) or
similar. See \link{Startup} for help on R options and environment
variables.

Save your API keys with the following names:
\itemize{
\item Tropicos: R option or env var as 'TROPICOS_KEY'
\item IUCN: R option or env var as 'IUCN_REDLIST_KEY'
\item ENTREZ: R option or env var as 'ENTREZ_KEY'
}

If you save in .Renviron it looks like: \code{ENTREZ_KEY=somekey}

If you save in a .bash_profile, .zshrc, or similar file it looks like:
\verb{export ENTREZ_KEY=somekey}

If you save in a .Rprofile it looks like: \code{options(ENTREZ_KEY = "somekey")}

Remember to restart your R session (and to start a new shell window/tab
if you're using the shell) to take advantage of the new R options
or environment variables.

We strongly recommend using environment variables
(https://en.wikipedia.org/wiki/Environment_variable) over R options
because environment variables are widely used across programming
languages, operating systems, and computing environments; whereas
R options are specific to R.

Note that NCBI Entrez doesn't require that you use an API key,
but you do get a higher rate limit with a key (more requests per
time period), from 3 to 10 requests per second, so do get one.
}

\seealso{
\code{\link[=key_helpers]{key_helpers()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pow_search.R
\name{pow_synonyms}
\alias{pow_synonyms}
\title{Lookup synonyms in Kew's Plants of the World}
\usage{
pow_synonyms(id, ...)
}
\arguments{
\item{id}{(character) taxon id. required}

\item{...}{Further args passed on to \code{\link[=pow_lookup]{pow_lookup()}}}
}
\description{
Lookup synonyms in Kew's Plants of the World
}
\examples{
\dontrun{
pow_synonyms(id = 'urn:lsid:ipni.org:names:320035-2')
pow_synonyms(id = 'urn:lsid:ipni.org:names:358881-1')
pow_synonyms(id = 'urn:lsid:ipni.org:names:359855-1')
}
}
\seealso{
Other pow: 
\code{\link{get_pow}()},
\code{\link{pow_lookup}()},
\code{\link{pow_search}()}
}
\concept{pow}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-params.R
\name{taxize-params}
\alias{taxize-params}
\title{taxize parameters}
\description{
Information on standardized parameters across the package
}
\section{Standardized parameters}{

\itemize{
\item \code{sci}: scientific name
\item \code{com}: common name
\item \code{id}: name identifier
\item \code{sci_com}: scientific name or common name
\item \code{sci_id}: scientific name or name identifier
}

We were going to standardize parameter names for cases in which
a parameter accepts either of three options: scientific name,
common name, or name identifier. However, there was no clear
parameter name we could use for this case, so we've left
parameter names as they are for the two cases (\code{\link[=get_ids]{get_ids()}} and
\code{\link[=vascan_search]{vascan_search()}})
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_synonyms.R
\name{tp_synonyms}
\alias{tp_synonyms}
\title{Return all synonyms for a taxon name with a given id.}
\usage{
tp_synonyms(id, key = NULL, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
List or dataframe.
}
\description{
Return all synonyms for a taxon name with a given id.
}
\examples{
\dontrun{
tp_synonyms(id = 25509881)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_refs.R
\name{tp_namereferences}
\alias{tp_namereferences}
\title{Return all reference records for for a taxon name with a given id.}
\usage{
tp_namereferences(...)
}
\arguments{
\item{...}{ignored}
}
\description{
Function name changed to tp_refs.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ping.R
\name{ping}
\alias{ping}
\alias{col_ping}
\alias{eol_ping}
\alias{itis_ping}
\alias{ncbi_ping}
\alias{tropicos_ping}
\alias{nbn_ping}
\alias{gbif_ping}
\alias{bold_ping}
\alias{ipni_ping}
\alias{vascan_ping}
\alias{fg_ping}
\title{Ping an API used in taxize to see if it's working.}
\usage{
col_ping(what = "status", ...)

eol_ping(what = "status", ...)

itis_ping(what = "status", ...)

ncbi_ping(what = "status", key = NULL, ...)

tropicos_ping(what = "status", ...)

nbn_ping(what = "status", ...)

gbif_ping(what = "status", ...)

bold_ping(what = "status", ...)

ipni_ping(what = "status", ...)

vascan_ping(what = "status", ...)

fg_ping(what = "status", ...)
}
\arguments{
\item{what}{(character) One of status (default), content, or an HTTP status
code. If status, we just check that the HTTP status code is 200, or similar
signifying the service is up. If content, we do a simple, quick check to
determine if returned content matches what's expected. If an HTTP status
code, it must match an appropriate code. See \code{\link[=status_codes]{status_codes()}}.}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}

\item{key}{(character) NCBI Entrez API key. optional. See \code{\link[=get_uid]{get_uid()}}}
}
\value{
A logical, TRUE or FALSE
}
\description{
Ping an API used in taxize to see if it's working.
}
\details{
For ITIS, see \link[ritis:description]{ritis::description}, which provides number of
scientific and common names in a character string.
}
\section{HTTP version for NCBI requests}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\examples{
\dontrun{
col_ping()
col_ping("content")
col_ping(200)
col_ping("200")
col_ping(204)

itis_ping()
eol_ping()
ncbi_ping()
tropicos_ping()
nbn_ping()

gbif_ping()
gbif_ping(200)

bold_ping()
bold_ping(200)
bold_ping("content")

ipni_ping()
ipni_ping(200)
ipni_ping("content")

vascan_ping()
vascan_ping(200)
vascan_ping("content")

# curl options
vascan_ping(verbose = TRUE)
eol_ping(500, verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{rank_ref_zoo}
\alias{rank_ref_zoo}
\title{Lookup-table for IDs of taxonomic ranks (WoRMS)}
\description{
Same as \code{rank_ref} but specifically for WoRMS, where section/subsection
ranks are put between family/order rather than between species/genus.
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eol_dataobjects.R
\name{eol_dataobjects}
\alias{eol_dataobjects}
\title{Given the identifier for a data object, return all metadata about the object}
\usage{
eol_dataobjects(id, taxonomy = TRUE, language = NULL, ...)
}
\arguments{
\item{id}{(character) The EOL data object identifier}

\item{taxonomy}{(logical) Whether to return any taxonomy details from
different taxon hierarchy providers, in an array named \code{taxonconcepts}}

\item{language}{(character) provides the results in the specified language.
one of ms, de, en, es, fr, gl, it, nl, nb, oc, pt-BR, sv, tl, mk, sr, uk,
ar, zh-Hans, zh-Hant, ko}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
A list, optionally with a data.frame if \code{taxonomy=TRUE}
}
\description{
Given the identifier for a data object, return all metadata about the object
}
\details{
It's possible to return JSON or XML with the EOL API. However,
this function only returns JSON for now.
}
\examples{
\dontrun{
eol_dataobjects(id = 7561533)

# curl options
eol_dataobjects(id = 7561533, verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_accnames.R
\name{tp_acceptednames}
\alias{tp_acceptednames}
\title{Return all accepted names for a taxon name with a given id.}
\usage{
tp_acceptednames(...)
}
\arguments{
\item{...}{ignored}
}
\description{
Function name changed to tp_accnames.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/phylomatic_tree.R
\name{phylomatic_tree}
\alias{phylomatic_tree}
\title{Query Phylomatic for a phylogenetic tree.}
\usage{
phylomatic_tree(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eol_search.R
\name{eol_search}
\alias{eol_search}
\title{Search for terms in EOL database.}
\usage{
eol_search(
  sci,
  page = 1,
  exact = NULL,
  filter_tid = NULL,
  filter_heid = NULL,
  filter_by_string = NULL,
  cache_ttl = NULL,
  terms = NULL,
  ...
)
}
\arguments{
\item{sci}{(character) scientific name}

\item{page}{A maximum of 30 results are returned per page. This parameter
allows you to fetch more pages of results if there are more than
30 matches (Default 1)}

\item{exact}{Will find taxon pages if the preferred name or any synonym
or common name exactly matches the search term.}

\item{filter_tid}{Given an EOL page ID, search results will be limited
to members of that taxonomic group}

\item{filter_heid}{Given a Hierarchy Entry ID, search results will be
limited to members of that taxonomic group}

\item{filter_by_string}{Given a search term, an exact search will be made
and that matching page will be used as the taxonomic group against which
to filter search results}

\item{cache_ttl}{The number of seconds you wish to have the response cached.}

\item{terms}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
A data frame with four columns:
\itemize{
\item pageid: pageid, this is the same as the eolid you can get from
\code{\link[=get_eolid]{get_eolid()}}
\item name: taxonomic name, may or may not contain the taxonomic authority
\item link: URL for the taxon in question
\item content: a string of semi-colon separated names. it's not clear
to us what these represent exactly, but figured why not give it to users
in case some may find it useful
}
}
\description{
Search for terms in EOL database.
}
\details{
It's possible to return JSON or XML with the EOL API. However,
this function only returns JSON for now.
}
\examples{
\dontrun{
eol_search(sci='Homo')
eol_search(sci='Salix', verbose = TRUE)
eol_search(sci='Ursus americanus')
eol_search('Pinus contorta')
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{worrms_ranks}
\alias{worrms_ranks}
\title{WORMS ranks}
\format{
A data frame with 216 rows and 2 variables:
\itemize{
\item \code{id}: rank id
\item \code{rank}: rank name
}
}
\description{
Created using \code{worrms::wm_ranks_id(-1)} on 2020-02-11.
}
\details{
Present in taxize in the case where WORMS does not
return rank names - with this dataset we can fill
in rank information as long as rank ids are returned
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scrapenames.r
\name{scrapenames}
\alias{scrapenames}
\title{Resolve names using Global Names Recognition and Discovery.}
\usage{
scrapenames(
  url = NULL,
  file = NULL,
  text = NULL,
  engine = NULL,
  unique = NULL,
  verbatim = NULL,
  detect_language = NULL,
  all_data_sources = NULL,
  data_source_ids = NULL,
  return_content = FALSE,
  ...
)
}
\arguments{
\item{url}{An encoded URL for a web page, PDF, Microsoft Office document, or
image file, see examples}

\item{file}{When using multipart/form-data as the content-type, a file may
be sent. This should be a path to your file on your machine.}

\item{text}{Type: string. Text content; best used with a POST request, see
examples}

\item{engine}{(optional) (integer) Default: 0. Either 1 for TaxonFinder,
2 for NetiNeti, or 0 for both. If absent, both engines are used.}

\item{unique}{(optional) (logical) If \code{TRUE} (default), response has
unique names without offsets.}

\item{verbatim}{(optional) Type: boolean, If \code{TRUE} (default to
\code{FALSE}), response excludes verbatim strings.}

\item{detect_language}{(optional) Type: boolean, When \code{TRUE} (default),
NetiNeti is not used if the language of incoming text is determined not to
be English. When \code{FALSE}, NetiNeti will be used if requested.}

\item{all_data_sources}{(optional) Type: boolean. Resolve found names
against all available Data Sources.}

\item{data_source_ids}{(optional) Type: string. Pipe separated list of
data source ids to resolve found names against. See list of Data Sources
http://resolver.globalnames.org/data_sources}

\item{return_content}{(logical) return OCR'ed text. returns text
string in \code{x$meta$content} slot. Default: \code{FALSE}}

\item{...}{Further args passed to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A list of length two, first is metadata, second is the data as a
data.frame.
}
\description{
Uses the Global Names Recognition and Discovery service, see
http://gnrd.globalnames.org/

Note: this function sometimes gives data back and sometimes not. The API
that this function is extremely buggy.
}
\details{
One of url, file, or text must be specified - and only one of them.
}
\examples{
\dontrun{
# Get data from a website using its URL
scrapenames('https://en.wikipedia.org/wiki/Spider')
scrapenames('https://en.wikipedia.org/wiki/Animal')
scrapenames('https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0095068')
scrapenames('https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0080498')
scrapenames('http://ucjeps.berkeley.edu/cgi-bin/get_JM_treatment.pl?CARYOPHYLLACEAE')

# Scrape names from a pdf at a URL
url <- 'https://journals.plos.org/plosone/article/file?id=
10.1371/journal.pone.0058268&type=printable'
scrapenames(url = sub('\n', '', url))

# With arguments
scrapenames(url = 'https://www.mapress.com/zootaxa/2012/f/z03372p265f.pdf',
  unique=TRUE)
scrapenames(url = 'https://en.wikipedia.org/wiki/Spider',
  data_source_ids=c(1, 169))

# Get data from a file
speciesfile <- system.file("examples", "species.txt", package = "taxize")
scrapenames(file = speciesfile)

nms <- paste0(names_list("species"), collapse="\n")
file <- tempfile(fileext = ".txt")
writeLines(nms, file)
scrapenames(file = file)

# Get data from text string
scrapenames(text='A spider named Pardosa moesta Banks, 1892')

# return OCR content
scrapenames(url='https://www.mapress.com/zootaxa/2012/f/z03372p265f.pdf',
  return_content = TRUE)
}
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gisd_isinvasive.R
\name{gisd_isinvasive}
\alias{gisd_isinvasive}
\title{Check invasive species status for a set of species from GISD database}
\usage{
gisd_isinvasive(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ping.R
\name{ubio_ping}
\alias{ubio_ping}
\title{uBio ping}
\usage{
ubio_ping()
}
\description{
uBio ping
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_eolid.R
\name{get_eolid}
\alias{get_eolid}
\alias{as.eolid}
\alias{as.eolid.eolid}
\alias{as.eolid.character}
\alias{as.eolid.list}
\alias{as.eolid.numeric}
\alias{as.eolid.data.frame}
\alias{as.data.frame.eolid}
\alias{get_eolid_}
\title{Get the EOL ID from Encyclopedia of Life from taxonomic names.}
\usage{
get_eolid(
  sci_com,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  rank = NULL,
  data_source = NULL,
  sciname = NULL,
  ...
)

as.eolid(x, check = TRUE)

\method{as.eolid}{eolid}(x, check = TRUE)

\method{as.eolid}{character}(x, check = TRUE)

\method{as.eolid}{list}(x, check = TRUE)

\method{as.eolid}{numeric}(x, check = TRUE)

\method{as.eolid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{eolid}(x, ...)

get_eolid_(sci_com, messages = TRUE, rows = NA, sciname = NULL, ...)
}
\arguments{
\item{sci_com}{character; one or more scientific or common names. Or,
a \code{taxon_state} object (see \link{taxon-state})}

\item{ask}{logical; should get_eolid be run in interactive mode?
If TRUE and more than one ID is found for the species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; If \code{TRUE} the actual taxon queried is printed
on the console.}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a eolid
class object with one to many identifiers. See
\code{\link[=get_eolid_]{get_eolid_()}} to get back all, or a subset, of the raw
data that you are presented during the ask process.}

\item{rank}{(character) A taxonomic rank name. See \link{rank_ref}
for possible options. Though note that some data sources use atypical ranks,
so inspect the data itself for options. Optional. See \code{Filtering} below.}

\item{data_source}{(character) A data source inside of EOL. These are
longish names like e.g., "Barcode of Life Data Systems" or
"USDA PLANTS images". Optional. See \code{Filtering} below.}

\item{sciname}{Deprecated, see \code{sci_com}}

\item{...}{Further args passed on to \code{\link[=eol_search]{eol_search()}}}

\item{x}{Input to \code{\link[=as.eolid]{as.eolid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.eolid]{as.eolid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Note that EOL doesn't expose an API endpoint for directly querying for EOL
taxon ID's, so we first use the function \code{\link[=eol_search]{eol_search()}}
to find pages that deal with the species of interest, then use
\code{\link[=eol_pages]{eol_pages()}} to find the actual taxon IDs.
}
\details{
EOL is a bit odd in that they have page IDs for each taxon, but
then within that, they have taxon ids for various taxa within that page
(e.g., GBIF and NCBI each have a taxon they refer to within the
page [i.e., taxon]). And we need the taxon ids from a particular data
provider (e.g, NCBI) to do other things, like get a higher classification
tree. However, humans want the page id, not the taxon id. So, the
id returned from this function is the taxon id, not the page id. You can
get the page id for a taxon by using \code{\link[=eol_search]{eol_search()}} and
`\code{\link[=eol_pages]{eol_pages()}}, and the URI returned in the attributes for a
taxon will lead you to the taxon page, and the ID in the URL is the
page id.
}
\section{Filtering}{

The parameters \code{rank} and \code{data_source} are not used in the
search to the data provider, but are used in filtering the data down to a
subset that is closer to the target you want.  For all these parameters,
you can use regex strings since we use \code{\link[=grep]{grep()}} internally to
match. Filtering narrows down to the set that matches your query, and
removes the rest.
}

\examples{
\dontrun{
get_eolid(sci_com='Pinus contorta')
get_eolid(sci_com='Puma concolor')

get_eolid(c("Puma concolor", "Pinus contorta"))

# specify rows to limit choices available
get_eolid('Poa annua')
get_eolid('Poa annua', rows=1)
get_eolid('Poa annua', rows=2)
get_eolid('Poa annua', rows=1:2)

# When not found
get_eolid(sci_com="uaudnadndj")
get_eolid(c("Chironomus riparius", "uaudnadndj"))

# filter results to a rank or data source, or both
get_eolid("Satyrium")
get_eolid("Satyrium", rank = "genus")
get_eolid("Satyrium", data_source = "INAT")
get_eolid("Satyrium", rank = "genus",
  data_source = "North Pacific Species List")

# Convert a eolid without class information to a eolid class
# already a eolid, returns the same
as.eolid(get_eolid("Chironomus riparius"))
# same
as.eolid(get_eolid(c("Chironomus riparius","Pinus contorta")))
# numeric
as.eolid(10247706)
# numeric vector, length > 1
as.eolid(c(6985636,12188704,10247706))
# character
as.eolid("6985636")
# character vector, length > 1
as.eolid(c("6985636","12188704","10247706"))
# list, either numeric or character
as.eolid(list("6985636","12188704","10247706"))
## dont check, much faster
as.eolid("6985636", check=FALSE)
as.eolid(6985636, check=FALSE)
as.eolid(c("6985636","12188704","10247706"), check=FALSE)
as.eolid(list("6985636","12188704","10247706"), check=FALSE)

(out <- as.eolid(c(6985636,12188704,10247706)))
data.frame(out)
as.eolid( data.frame(out) )

# Get all data back
get_eolid_("Poa annua")
get_eolid_("Poa annua", rows=2)
get_eolid_("Poa annua", rows=1:2)
get_eolid_(c("asdfadfasd", "Pinus contorta"))
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\author{
Scott Chamberlain
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eubon_capabilities.R
\name{eubon_capabilities}
\alias{eubon_capabilities}
\title{EUBON capabilities}
\usage{
eubon_capabilities(...)
}
\arguments{
\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\description{
EUBON capabilities
}
\examples{
\dontrun{
eubon_capabilities()
}
}
\references{
https://cybertaxonomy.eu/eu-bon/utis/1.3/doc.html
}
\seealso{
Other eubon-methods: 
\code{\link{eubon_children}()},
\code{\link{eubon_hierarchy}()},
\code{\link{eubon_search}()}
}
\concept{eubon-methods}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ubio_id.R
\name{ubio_id}
\alias{ubio_id}
\title{Search uBio by namebank ID.}
\usage{
ubio_id(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_tpsid.R
\name{get_tpsid}
\alias{get_tpsid}
\alias{as.tpsid}
\alias{as.tpsid.tpsid}
\alias{as.tpsid.character}
\alias{as.tpsid.list}
\alias{as.tpsid.numeric}
\alias{as.tpsid.data.frame}
\alias{as.data.frame.tpsid}
\alias{get_tpsid_}
\title{Get the NameID codes from Tropicos for taxonomic names.}
\usage{
get_tpsid(
  sci,
  ask = TRUE,
  messages = TRUE,
  key = NULL,
  rows = NA,
  family = NULL,
  rank = NULL,
  sciname = NULL,
  ...
)

as.tpsid(x, check = TRUE)

\method{as.tpsid}{tpsid}(x, check = TRUE)

\method{as.tpsid}{character}(x, check = TRUE)

\method{as.tpsid}{list}(x, check = TRUE)

\method{as.tpsid}{numeric}(x, check = TRUE)

\method{as.tpsid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{tpsid}(x, ...)

get_tpsid_(sci, messages = TRUE, key = NULL, rows = NA, sciname = NULL, ...)
}
\arguments{
\item{sci}{(character) One or more scientific name's as a vector or list. Or,
a \code{taxon_state} object (see \link{taxon-state})}

\item{ask}{logical; should get_tpsid be run in interactive mode?
If TRUE and more than one ID is found for the species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; If TRUE the actual taxon queried is printed on the console.}

\item{key}{Your API key; see \link{taxize-authentication}}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all rows are considered.
Note that this function still only gives back a tpsid class object with one to many identifiers.
See \code{\link[=get_tpsid_]{get_tpsid_()}} to get back all, or a subset, of the raw data that you are
presented during the ask process.}

\item{family}{(character) A family name. Optional. See \code{Filtering} below.}

\item{rank}{(character) A taxonomic rank name. See \link{rank_ref} for possible
options. Though note that some data sources use atypical ranks, so inspect the
data itself for options. Optional. See \code{Filtering} below.}

\item{sciname}{Deprecated, see \code{sci}}

\item{...}{Other arguments passed to \code{\link[=tp_search]{tp_search()}}.}

\item{x}{Input to \code{\link[=as.tpsid]{as.tpsid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only used in
\code{\link[=as.tpsid]{as.tpsid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get the NameID codes from Tropicos for taxonomic names.
}
\section{Filtering}{

The parameters \code{family} an\code{rank}nk are not used in the search to the data
provider, but are used in filtering the data down to a subset that is closer to the
target you want.  For all these parameters,
you can use regex strings since we use \code{\link[=grep]{grep()}} internally to match.
Filtering narrows down to the set that matches your query, and removes the rest.
}

\examples{
\dontrun{
get_tpsid(sci='Poa annua')
get_tpsid(sci='Pinus contorta')

get_tpsid(c("Poa annua", "Pinus contorta"))

# specify rows to limit choices available
get_tpsid('Poa ann')
get_tpsid('Poa ann', rows=1)
get_tpsid('Poa ann', rows=25)
get_tpsid('Poa ann', rows=1:2)

# When not found, NA given (howdy is not a species name, and Chrinomus is a fly)
get_tpsid("howdy")
get_tpsid(c("Chironomus riparius", "howdy"))

# Narrow down results to a division or rank, or both
## Satyrium example
### Results w/o narrowing
get_tpsid("Satyrium")
### w/ rank
get_tpsid("Satyrium", rank = "var.")
get_tpsid("Satyrium", rank = "sp.")

## w/ family
get_tpsid("Poa")
get_tpsid("Poa", family = "Iridaceae")
get_tpsid("Poa", family = "Orchidaceae")
get_tpsid("Poa", family = "Orchidaceae", rank = "gen.")

# Fuzzy filter on any filtering fields
## uses grep on the inside
get_tpsid("Poa", family = "orchidaceae")
get_tpsid("Aga", fuzzy = TRUE, parent = "*idae")

# pass to classification function to get a taxonomic hierarchy
classification(get_tpsid(sci='Poa annua'))

# Convert a tpsid without class information to a tpsid class
as.tpsid(get_tpsid("Pinus contorta")) # already a tpsid, returns the same
as.tpsid(get_tpsid(c("Chironomus riparius","Pinus contorta"))) # same
as.tpsid(24900183) # numeric
as.tpsid(c(24900183,50150089,50079838)) # numeric vector, length > 1
as.tpsid("24900183") # character
as.tpsid(c("24900183","50150089","50079838")) # character vector, length > 1
as.tpsid(list("24900183","50150089","50079838")) # list, either numeric or character
## dont check, much faster
as.tpsid("24900183", check=FALSE)
as.tpsid(24900183, check=FALSE)
as.tpsid(c("24900183","50150089","50079838"), check=FALSE)
as.tpsid(list("24900183","50150089","50079838"), check=FALSE)

(out <- as.tpsid(c(24900183,50150089,50079838)))
data.frame(out)
as.tpsid( data.frame(out) )

# Get all data back
get_tpsid_("Poa annua")
get_tpsid_("Poa annua", rows=2)
get_tpsid_("Poa annua", rows=1:2)
get_tpsid_(c("asdfadfasd","Pinus contorta"), rows=1:5)

# use curl options
invisible(get_tpsid("Quercus douglasii", messages = TRUE))
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\author{
Scott Chamberlain,
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_summary.R
\name{tp_summary}
\alias{tp_summary}
\title{Return summary data a taxon name with a given id.}
\usage{
tp_summary(id, key = NULL, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame.
}
\description{
Return summary data a taxon name with a given id.
}
\examples{
\dontrun{
tp_summary(id = 25509881)
tp_summary(id = 2700851)
tp_summary(id = 24900183)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_search.R
\name{get_genes_avail}
\alias{get_genes_avail}
\title{Retrieve gene sequences from NCBI by accession number.}
\usage{
get_genes_avail(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_children.R
\name{ncbi_children}
\alias{ncbi_children}
\title{Search NCBI for children of a taxon}
\usage{
ncbi_children(
  name = NULL,
  id = NULL,
  start = 0,
  max_return = 1000,
  ancestor = NULL,
  out_type = c("summary", "uid"),
  ambiguous = FALSE,
  key = NULL,
  ...
)
}
\arguments{
\item{name}{(\code{character}) The string to search for. Only exact matches
found the name given will be returned. Not compatible with \code{id}.}

\item{id}{(\code{character}/\code{numeric}) The uid to search for. Not compatible with
\code{name}.}

\item{start}{The first record to return. If omitted, the results are
returned from the first record (start=0).}

\item{max_return}{(\verb{numeric; length=1}) The maximum number of children
to return.}

\item{ancestor}{(\code{character}) The ancestor of the taxon being searched
for. This is useful if there could be more than one taxon with the same
name. Has no effect if \code{id} is used.}

\item{out_type}{(character) Currently either \code{"summary"} or \code{"uid"}:
\itemize{
\item \code{summary} The output is a list of \code{data.frame} with children uid, name,
and rank.
\item \code{uid} A list of character vectors of children uids
}}

\item{ambiguous}{\verb{logical; length 1} If \code{FALSE}, children taxa
with words like "unclassified", "unknown", "uncultured", or "sp." are
removed from the output. NOTE: This option only applies when
\code{out_type= "summary"}.}

\item{key}{(character) NCBI Entrez API key. optional. See Details.}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
The output type depends on the value of the \code{out_type}
parameter. Taxa that cannot be found will result in \code{NA}s and a lack
of children results in an empty data structure.
}
\description{
Search the NCBI Taxonomy database for uids of children of taxa.
Taxa can be referenced by name or uid. Referencing by name is faster

In a few cases, different taxa have the same name (e.g. Satyrium; see
examples). If one of these are searched for then the children of both taxa
will be returned. This can be avoided by using a uid instead of the name or
specifying an ancestor. If an ancestor is provided, only children of both
the taxon and its ancestor are returned. This will only fail if there are
two taxa with the same name and the same specified ancestor.
}
\section{Authentication}{

See \code{\link[=taxize-authentication]{taxize-authentication()}} for help on authentication.
We strongly recommend getting an API key
}

\section{HTTP version}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\section{Rate limits}{

In case you run into errors due to your rate limit being exceeded, see
\code{\link[=taxize_options]{taxize_options()}}, where you can set \code{ncbi_sleep}.
}

\examples{
\dontrun{
ncbi_children(name="Satyrium") #Satyrium is the name of two different genera
ncbi_children(name="Satyrium", ancestor="Eumaeini") # A genus of butterflies
ncbi_children(name="Satyrium", ancestor="Orchidaceae") # A genus of orchids
ncbi_children(id="266948") #"266948" is the uid for the butterfly genus
ncbi_children(id="62858") #"62858" is the uid for the orchid genus

# use curl options
ncbi_children(name="Satyrium", ancestor="Eumaeini", verbose = TRUE)
}
}
\seealso{
\code{\link[=ncbi_get_taxon_summary]{ncbi_get_taxon_summary()}}, \code{\link[=children]{children()}}
}
\author{
Zachary Foster \email{zacharyfoster1989@gmail.com}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{apg_orders}
\alias{apg_orders}
\title{MOBOT order names}
\format{
A data frame with 576 rows and 5 variables:
\itemize{
\item \code{order}: order name
\item \code{synonym}: if \code{accepted=FALSE}, this is the accepted name;
if \code{accepted=TRUE}, this is \code{NA}, and the name in \code{order} is accepted
\item \code{accepted}: logical, if name in \code{order} column is accepted or not
\item \code{original}: original data record from APG website, mapping
name in \code{order} column to a new name, if there is one
\item \code{accepted_name}: accepted name. accepted names, combining those that
are accepted from \code{order} column, with the new name from \code{synonym}
if applicable
}
}
\source{
http://www.mobot.org/MOBOT/research/APweb/
}
\description{
Order names and their replacements from the Angiosperm Phylogeny
Website system of flowering plant classification.
}
\details{
This dataset is from Version 14, incorporated on 2020-06-03,
generated using \code{\link[=apgOrders]{apgOrders()}}

(update script in inst/ignore/apg_script.R)
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tnrs.R
\name{tnrs}
\alias{tnrs}
\title{Phylotastic Taxonomic Name Resolution Service.}
\usage{
tnrs(...)
}
\arguments{
\item{...}{ignored}
}
\description{
Defunct - service was down far too much to be reliable
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eol_invasive.R
\name{eol_invasive}
\alias{eol_invasive}
\title{Search for presence of taxonomic names in EOL invasive species databases.}
\usage{
eol_invasive(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sci2comm.R
\name{sci2comm}
\alias{sci2comm}
\alias{sci2comm.default}
\alias{sci2comm.uid}
\alias{sci2comm.tsn}
\alias{sci2comm.wormsid}
\alias{sci2comm.iucn}
\title{Get common names from scientific names.}
\usage{
sci2comm(...)

\method{sci2comm}{default}(sci, db = "ncbi", simplify = TRUE, scinames = NULL, ...)

\method{sci2comm}{uid}(id, ...)

\method{sci2comm}{tsn}(id, simplify = TRUE, ...)

\method{sci2comm}{wormsid}(id, simplify = TRUE, ...)

\method{sci2comm}{iucn}(id, simplify = TRUE, ...)
}
\arguments{
\item{...}{Further arguments passed on to functions \code{\link[=get_uid]{get_uid()}},
\code{\link[=get_tsn]{get_tsn()}}.}

\item{sci}{character; One or more scientific names or partial names.}

\item{db}{character; Data source, one of \code{"ncbi"} (default),
\code{"itis"} \code{"eol"}, \code{"worms"}, or \code{"iucn"}. Note that
each taxonomic data source has their own identifiers,  so that if you
provide the wrong \code{db} value for the identifier you could get a
result, but it will likely be wrong (not what you were expecting).
If using ncbi or iucn we recommend getting an API key;
see \link{taxize-authentication}}

\item{simplify}{(logical) If TRUE, simplify output to a vector of names.
If FALSE, return variable formats from different sources, usually a
data.frame. Only applies to eol and itis. Specify \code{FALSE} to obtain
the language of each vernacular in the output for eol and itis.}

\item{scinames}{Deprecated, see \code{sci}}

\item{id}{character; identifiers, as returned by \code{\link[=get_tsn]{get_tsn()}},
\code{\link[=get_uid]{get_uid()}}.}
}
\value{
List of character vectors, named by input taxon name,
or taxon ID. \code{character(0)} on no match
}
\description{
Get common names from scientific names.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\section{HTTP version for NCBI requests}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\examples{
\dontrun{
sci2comm(sci='Helianthus annuus')
sci2comm(sci='Helianthus annuus', db='eol')
sci2comm(sci=c('Helianthus annuus', 'Poa annua'))
sci2comm(sci='Puma concolor', db='ncbi')
sci2comm('Gadus morhua', db='worms')
sci2comm('Pomatomus saltatrix', db='worms')
sci2comm('Loxodonta africana', db='iucn')

# Passing id in, works for sources: itis and ncbi, not eol
sci2comm(get_uid('Helianthus annuus'))
sci2comm(get_wormsid('Gadus morhua'))
sci2comm(get_iucn('Loxodonta africana'))

# Don't simplify returned
sci2comm(get_iucn('Loxodonta africana'), simplify=FALSE)

# Use curl options
sci2comm('Helianthus annuus', db="ncbi", verbose = TRUE)
}
}
\seealso{
\code{\link[=comm2sci]{comm2sci()}}
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iucn_summary.R
\name{iucn_summary}
\alias{iucn_summary}
\title{Get a summary from the IUCN Red List}
\usage{
iucn_summary(x, distr_detail = FALSE, key = NULL, ...)
}
\arguments{
\item{x}{character; Scientific name. Should be cleaned and in the
format \verb{*<Genus> <Species>*}.}

\item{distr_detail}{logical; If \code{TRUE}, the geographic distribution is
returned as a list of vectors corresponding to the different range types:
native, introduced, etc.}

\item{key}{a Redlist API key, get one from
https://apiv3.iucnredlist.org/api/v3/token Required for
\code{iucn_summary}. Defaults to \code{NULL} in case you have your key
stored (see \verb{Redlist Authentication} below).}

\item{...}{curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A list (for every species one entry) of lists with the following
items:
\itemize{
\item \code{status} Red List Category.
\item \code{history} History of status, if available.
\item \code{distr} Geographic distribution, if available.
\item \code{trend} Trend of population size, if available.
}
}
\description{
Get a summary from the IUCN Red List (https://www.iucnredlist.org/).
}
\details{
Beware: IUCN functions can give back incorrect data. This isn't our fault.
We do our best to get you the correct data quickly, but sometimes IUCN gives
back the wrong data, and sometimes Global Names gives back the wrong data.
We will fix these as soon as possible. In the meantime, just make sure that
the data you get back is correct.

\code{iucn_summary} has a default method that errors when anything's
passed in that's not \code{character} or \code{iucn} class - a
\code{iucn_summary.character} method for when you pass in taxon names -
and a \code{iucn_summary.iucn} method so you can pass in iucn class objects
as output from \code{\link[=get_iucn]{get_iucn()}} or \code{\link[=as.iucn]{as.iucn()}}. If you
already have IUCN IDs, coerce them to \code{iucn} class via
\code{as.iucn(..., check = FALSE)}
}
\note{
Not all entries (history, distr, trend) are available for every species
and NA is returned.
\code{\link[=iucn_status]{iucn_status()}} is an extractor function to easily extract
status into a vector.
}
\section{Redlist Authentication}{

\code{iucn_summary} uses the new Redlist API for searching for a IUCN ID, so we
use the \code{\link[=rl_search]{rl_search()}} function internally. This function
requires an API key. Get the key at https://apiv3.iucnredlist.org/api/v3/token,
and pass it to the \code{key} parameter, or store in your \code{.Renviron} file like
\code{IUCN_REDLIST_KEY=yourkey} or in your \code{.Rprofile} file like
\code{options(iucn_redlist_key="yourkey")}. We strongly encourage you to not pass
the key in the function call but rather store it in one of those two files.
This key will also set you up to use the \pkg{rredlist} package.
}

\examples{
\dontrun{
# if you send a taxon name, an IUCN API key is required
## here, the key is being detected from a .Rprofile file
## or .Renviron file, See "Redlist Authentication" above
iucn_summary("Lutra lutra")

ia <- iucn_summary(c("Panthera uncia", "Lynx lynx"))
ia <- iucn_summary(c("Panthera uncia", "Lynx lynx", "aaa"))
iucn_summary("Muntiacus rooseveltorum/truongsonensis")
iucn_summary(c("Muntiacus rooseveltorum/truongsonensis", "Lynx lynx"))

## get detailed distribution
iac <- iucn_summary(x="Ara chloropterus", distr_detail = TRUE)
iac[[1]]$distr


# If you pass in an IUCN ID, you don't need to pass in a Redlist API Key
# extract status
iucn_status(iac)
}
}
\seealso{
\code{\link[=iucn_status]{iucn_status()}}
}
\author{
Eduard Szoecs, \email{eduardszoecs@gmail.com}

Philippe Marchand, \email{marchand.philippe@gmail.com}

Scott Chamberlain,
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_name.R
\name{itis_name}
\alias{itis_name}
\title{Get taxonomic names for a given taxonomic name query.}
\usage{
itis_name(query = NULL, get = NULL)
}
\arguments{
\item{query}{TSN number (taxonomic serial number).}

\item{get}{The rank of the taxonomic name to get.}
}
\value{
Taxonomic name for the searched taxon.
}
\description{
Get taxonomic names for a given taxonomic name query.
}
\examples{
\dontrun{
itis_name(query="Helianthus annuus", get="family")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_tolid.R
\name{get_tolid}
\alias{get_tolid}
\alias{as.tolid}
\alias{as.tolid.tolid}
\alias{as.tolid.character}
\alias{as.tolid.list}
\alias{as.tolid.numeric}
\alias{as.tolid.data.frame}
\alias{as.data.frame.tolid}
\alias{get_tolid_}
\title{Get the OTT id for a search term}
\usage{
get_tolid(sci, ask = TRUE, messages = TRUE, rows = NA, sciname = NULL, ...)

as.tolid(x, check = TRUE)

\method{as.tolid}{tolid}(x, check = TRUE)

\method{as.tolid}{character}(x, check = TRUE)

\method{as.tolid}{list}(x, check = TRUE)

\method{as.tolid}{numeric}(x, check = TRUE)

\method{as.tolid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{tolid}(x, ...)

get_tolid_(sci, messages = TRUE, rows = NA, sciname = NULL)
}
\arguments{
\item{sci}{character; one or more scientific names. Or, a \code{taxon_state}
object (see \link{taxon-state})}

\item{ask}{logical; should \code{get_tolid} be run in interactive mode?
If \code{TRUE} and more than one TOL is found for the species, the user is
asked for input. If \code{FALSE} NA is returned for multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a tol
class object with one to many identifiers. See \code{\link[=get_tolid_]{get_tolid_()}}
to get back all, or a subset, of the raw data that you are presented during
the ask process.}

\item{sciname}{Deprecated, see \code{sci}}

\item{...}{Ignored}

\item{x}{Input to \code{as.tolid}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.tolid]{as.tolid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Retrieve the Open Tree of Life Taxonomy (OTT) id of a taxon from
OpenTreeOfLife
}
\examples{
\dontrun{
get_tolid(sci = "Quercus douglasii")
get_tolid(sci = "Chironomus riparius")
get_tolid(c("Chironomus riparius","Quercus douglasii"))
splist <- c("annona cherimola", 'annona muricata', "quercus robur",
		"shorea robusta", "pandanus patina", "oryza sativa", "durio zibethinus")
get_tolid(splist, messages=FALSE)

# specify rows to limit choices available
get_tolid('Arni')
get_tolid('Arni', rows=1)
get_tolid('Arni', rows=1:2)

# When not found
get_tolid("howdy")
get_tolid(c("Chironomus riparius", "howdy"))

# Convert a tol without class information to a tol class
as.tolid(get_tolid("Quercus douglasii")) # already a tol, returns the same
as.tolid(get_tolid(c("Chironomus riparius","Pinus contorta"))) # same
as.tolid(5907893) # numeric
as.tolid(c(3930798,515712,872577)) # numeric vector, length > 1
as.tolid("3930798") # character
as.tolid(c("3930798","515712","872577")) # character vector, length > 1
as.tolid(list("3930798","515712","872577")) # list, either numeric or character
## dont check, much faster
as.tolid("3930798", check=FALSE)
as.tolid(3930798, check=FALSE)
as.tolid(c("3930798","515712","872577"), check=FALSE)
as.tolid(list("3930798","515712","872577"), check=FALSE)

(out <- as.tolid(c(3930798,515712,872577)))
data.frame(out)
as.tolid( data.frame(out) )

# Get all data back
get_tolid_("Arni")
get_tolid_("Arni", rows=1)
get_tolid_("Arni", rows=1:2)
get_tolid_(c("asdfadfasd","Pinus contorta"))
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_search.R
\name{ncbi_search}
\alias{ncbi_search}
\title{Search for gene sequences available for taxa from NCBI.}
\usage{
ncbi_search(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/children.R
\name{children}
\alias{children}
\alias{children.default}
\alias{children.tsn}
\alias{children.wormsid}
\alias{children.ids}
\alias{children.uid}
\alias{children.boldid}
\title{Retrieve immediate children taxa for a given taxon name or ID.}
\usage{
children(...)

\method{children}{default}(sci_id, db = NULL, rows = NA, x = NULL, ...)

\method{children}{tsn}(sci_id, db = NULL, ...)

\method{children}{wormsid}(sci_id, db = NULL, ...)

\method{children}{ids}(sci_id, db = NULL, ...)

\method{children}{uid}(sci_id, db = NULL, ...)

\method{children}{boldid}(sci_id, db = NULL, ...)
}
\arguments{
\item{...}{Further args passed on to \code{\link[ritis:hierarchy]{ritis::hierarchy_down()}},
\code{\link[=ncbi_children]{ncbi_children()}}, \code{\link[worrms:wm_children]{worrms::wm_children()}}, \code{\link[=bold_children]{bold_children()}}
See those functions for what parameters can be passed on.}

\item{sci_id}{Vector of taxa names (character) or IDs (character or numeric)
to query.}

\item{db}{character; database to query. One or more of \code{itis},
\code{ncbi}, \code{worms}, or \code{bold}. Note that each taxonomic data
source has their own identifiers, so that if you provide the wrong
\code{db} value for the identifier you could get a result, but it will
likely be wrong (not what you were expecting). If using ncbi, we recommend
getting an API key; see \link{taxize-authentication}}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this parameter is ignored if you pass in a
taxonomic id of any of the acceptable classes: tsn. NCBI has a
method for this function but rows doesn't work.}

\item{x}{Deprecated, see \code{sci_id}}
}
\value{
A named list of data.frames with the children names of every
supplied taxa. You get an NA if there was no match in the database.
}
\description{
This function is different from \code{\link[=downstream]{downstream()}} in that it only
collects immediate taxonomic children, while \code{\link[=downstream]{downstream()}}
collects taxonomic names down to a specified taxonomic rank, e.g.,
getting all species in a family.
}
\section{ncbi}{

note that with \code{db = "ncbi"}, we set \code{ambiguous = TRUE}; that is, children
taxa with words like "unclassified", "unknown", "uncultured", "sp." are
NOT removed
}

\section{bold}{

BEWARE: \code{db="bold"} scrapes the BOLD website, so may be unstable. That is,
one day it may work, and the next it may fail. Open an issue if you
encounter an error: https://github.com/ropensci/taxize/issues
}

\examples{
\dontrun{
# Plug in taxonomic IDs
children(161994, db = "itis")
children(8028, db = "ncbi")
## works with numeric if as character as well
children(161994, db = "itis")
children(88899, db = "bold")
children(as.boldid(88899))

# Plug in taxon names
children("Salmo", db = 'itis')
children("Salmo", db = 'ncbi')
children("Salmo", db = 'worms')
children("Salmo", db = 'bold')

# Plug in IDs
(id <- get_wormsid("Gadus"))
children(id)

# Many taxa
sp <- c("Tragia", "Schistocarpha", "Encalypta")
children(sp, db = 'itis')

# Two data sources
(ids <- get_ids("Apis", db = c('ncbi','itis')))
children(ids)
## same result
children(get_ids("Apis", db = c('ncbi','itis')))

# Use the rows parameter
children("Poa", db = 'itis')
children("Poa", db = 'itis', rows=1)

# use curl options
res <- children("Poa", db = 'itis', rows=1, verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tol_resolve.R
\name{tol_resolve}
\alias{tol_resolve}
\title{Resolve names using Open Tree of Life (OTL) resolver}
\usage{
tol_resolve(
  names = NULL,
  context_name = NULL,
  do_approximate_matching = TRUE,
  ids = NULL,
  include_suppressed = FALSE,
  ...
)
}
\arguments{
\item{names}{(character) taxon names to be queried}

\item{context_name}{name of the taxonomic context to be searched
(length-one character vector). Must match (case sensitive) one
of the values returned by \code{\link[rotl:tnrs_contexts]{rotl::tnrs_contexts()}}.}

\item{do_approximate_matching}{(logical) A logical indicating whether or not
to perform approximate string (a.k.a. \dQuote{fuzzy}) matching. Using \code{FALSE}
will greatly improve speed. Default: \code{TRUE}}

\item{ids}{An array of OTL ids to use for identifying names. These
will be assigned to each name in the names array. If ids is
provided, then ids and names must be identical in length.}

\item{include_suppressed}{(logical) Ordinarily, some quasi-taxa, such as
incertae sedis buckets and other non-OTUs, are suppressed from TNRS
results. If this parameter is true, these quasi-taxa are allowed as
possible TNRS results. Default: \code{FALSE}}

\item{...}{Curl options passed on to \code{httr::POST} within
\code{\link[rotl:tnrs_match_names]{rotl::tnrs_match_names()}}}
}
\value{
A data frame summarizing the results of the query. The
original query output is appended as an attribute to the
returned object (and can be obtained using
\code{attr(object, "original_response")}).
}
\description{
Resolve names using Open Tree of Life (OTL) resolver
}
\examples{
\dontrun{
tol_resolve(names=c("echinodermata", "xenacoelomorpha",
  "chordata", "hemichordata"))
tol_resolve(c("Hyla", "Salmo", "Diadema", "Nautilus"))
tol_resolve(c("Hyla", "Salmo", "Diadema", "Nautilus"),
  context_name = "Animals")

turducken_spp <- c("Meleagris gallopavo", "Anas platyrhynchos",
  "Gallus gallus")
tol_resolve(turducken_spp, context_name="Animals")
}
}
\references{
https://github.com/OpenTreeOfLife/germinator/wiki/TNRS-API-v3#match_names
}
\seealso{
\code{\link[=gnr_resolve]{gnr_resolve()}}, \code{\link[=tnrs]{tnrs()}}
}
\author{
Francois Michonneau \email{francois.michonneau@gmail.com}
Scott Chamberlain
}
\keyword{names}
\keyword{resolve}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_kingdomnames.R
\name{itis_kingdomnames}
\alias{itis_kingdomnames}
\title{Get kingdom names}
\usage{
itis_kingdomnames(tsn = NULL, ...)
}
\arguments{
\item{tsn}{One or more TSN's (taxonomic serial number)}

\item{...}{Further arguments passed on to getkingdomnamefromtsn}
}
\description{
Get kingdom names
}
\examples{
\dontrun{
itis_kingdomnames(202385)
itis_kingdomnames(tsn=c(202385,183833,180543))
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eubon_hierarchy.R
\name{eubon_hierarchy}
\alias{eubon_hierarchy}
\title{EUBON hierarchy}
\usage{
eubon_hierarchy(id, providers = "pesi", timeout = 0, ...)
}
\arguments{
\item{id}{(character) identifier for the taxon. (LSID, DOI, URI, or any
other identifier used by the checklist provider)}

\item{providers}{(character) A list of provider id strings concatenated by
comma characters. The default : "pesi,bgbm-cdm-server[col]" will be
used if this parameter is not set. A list of all available provider ids
can be obtained from the '/capabilities' service end point. Providers can be
nested, that is a parent provider can have sub providers. If the id of the
parent provider is supplied all subproviders will be queried. The query
can also be restricted to one or more subproviders by using the following
syntax: parent-id[sub-id-1,sub-id2,...]}

\item{timeout}{(numeric) The maximum of milliseconds to wait for responses
from any of the providers. If the timeout is exceeded the service will just
return the responses that have been received so far. The default timeout is
0 ms (wait for ever)}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\description{
EUBON hierarchy
}
\note{
There is no pagination in this method, so you may or may not be
getting all the results for a search. Sorry, out of our control
}
\examples{
\dontrun{
eubon_hierarchy(id = "urn:lsid:marinespecies.org:taxname:126141", 'worms')
eubon_hierarchy(id = "urn:lsid:marinespecies.org:taxname:274350", 'worms')
}
}
\references{
https://cybertaxonomy.eu/eu-bon/utis/1.3/doc.html
}
\seealso{
Other eubon-methods: 
\code{\link{eubon_capabilities}()},
\code{\link{eubon_children}()},
\code{\link{eubon_search}()}
}
\concept{eubon-methods}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ion.R
\name{ion}
\alias{ion}
\title{ION - Index to Organism Names}
\usage{
ion(x, ...)
}
\arguments{
\item{x}{An LSID number. Required.}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame
}
\description{
ION - Index to Organism Names
}
\examples{
\dontrun{
ion(155166)
ion(298678)
ion(4796748) # ursus americanus
ion(1280626) # puma concolor
}
}
\references{
http://www.organismnames.com
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_refs.R
\name{tp_refs}
\alias{tp_refs}
\title{Return all reference records for for a taxon name with a given id.}
\usage{
tp_refs(id, key = NULL, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
List or dataframe.
}
\description{
Return all reference records for for a taxon name with a given id.
}
\examples{
\dontrun{
tp_refs(id = 25509881)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/limited_print.R
\name{limited_print}
\alias{limited_print}
\title{Print a subset of a character vector}
\usage{
limited_print(
  chars,
  prefix = "",
  max_chars = getOption("width") - nchar(prefix) - 5,
  type = "message"
)
}
\arguments{
\item{chars}{(\code{character}) What to print.}

\item{prefix}{(\code{character} of length 1) What to print before
\code{chars}, on the same line.}

\item{max_chars}{(\code{numeric} of length 1) The maximum number of
characters to print.}

\item{type}{(\code{"error"}, \code{"warning"}, \code{"message"}, \code{"cat"}, \code{"print"}, \code{"silent"})}
}
\value{
\code{NULL}
}
\description{
Prints the start and end values for a character vector. The number of values
printed depend on the width of the screen by default.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_lsid.R
\name{itis_lsid}
\alias{itis_lsid}
\title{Get TSN from LSID}
\usage{
itis_lsid(lsid = NULL, what = "tsn", ...)
}
\arguments{
\item{lsid}{One or more lsid's}

\item{what}{What to retrieve. One of tsn, record, or fullrecord}

\item{...}{Further arguments passed on to \code{\link[ritis:lsid2tsn]{ritis::lsid2tsn()}},
\code{\link[ritis:record]{ritis::record()}}, or \code{\link[ritis:full_record]{ritis::full_record()}}}
}
\description{
Get TSN from LSID
}
\examples{
\dontrun{
# Get TSN
itis_lsid("urn:lsid:itis.gov:itis_tsn:180543")
itis_lsid(lsid=c("urn:lsid:itis.gov:itis_tsn:180543","urn:lsid:itis.gov:itis_tsn:28726"))

# Get partial record
itis_lsid("urn:lsid:itis.gov:itis_tsn:180543", "record")

# Get full record
itis_lsid("urn:lsid:itis.gov:itis_tsn:180543", "fullrecord")

# An invalid lsid (a tsn actually)
itis_lsid(202385)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vascan_search.r
\name{vascan_search}
\alias{vascan_search}
\title{Search the CANADENSYS Vascan API.}
\usage{
vascan_search(q, format = "json", raw = FALSE, ...)
}
\arguments{
\item{q}{(character) Can be a scientific name, a vernacular name or a VASCAN
taxon identifier (e.g. 861)}

\item{format}{(character) One of json (default) or xml.}

\item{raw}{(logical) If TRUE, raw json or xml returned, if FALSE, parsed
data returned.}

\item{...}{(list) Further args passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
json, xml or a list.
}
\description{
Search the CANADENSYS Vascan API.
}
\details{
Note that we lowercase all outputs in data.frame's, but when a
list is given back, we don't touch the list names.
}
\examples{
\dontrun{
vascan_search(q = "Helianthus annuus")
vascan_search(q = "Helianthus annuus", raw=TRUE)
vascan_search(q = c("Helianthus annuus", "Crataegus dodgei"), raw=TRUE)

# format type
## json
c <- vascan_search(q = "Helianthus annuus", format="json", raw=TRUE)
library("jsonlite")
fromJSON(c, FALSE)

## xml
d <- vascan_search(q = "Helianthus annuus", format="xml", raw=TRUE)
library("xml2")
xml2::read_xml(d)

# lots of names, in this case 50
splist <- names_list(rank='species', size=50)
vascan_search(q = splist)

# Curl options
invisible(vascan_search(q = "Helianthus annuus", verbose = TRUE))
}
}
\references{
API docs https://data.canadensys.net/vascan/api
}
\author{
Scott Chamberlain
}
\keyword{names}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pow_search.R
\name{pow_search}
\alias{pow_search}
\title{Search Kew's Plants of the World}
\usage{
pow_search(sci_com, limit = 100, cursor = "*", sort = NULL, q = NULL, ...)
}
\arguments{
\item{sci_com}{(character) query terms, scientific or common name}

\item{limit}{(integer) Number of records to return. default: 100}

\item{cursor}{(character) cursor string}

\item{sort}{(character) The field to sort by and sort order separted with
underscore, e.g., \code{sort="name_desc"}}

\item{q}{Deprecated, see \code{sci_com}}

\item{...}{Further args passed on to \link[crul:HttpClient]{crul::HttpClient}.}
}
\value{
a list with slots for metadata (\code{meta}) with list of response
attributes, and data (\code{data}) with a data.frame of results
}
\description{
Search Kew's Plants of the World
}
\examples{
\dontrun{
x <- pow_search(sci_com = "Quercus")
x$meta
x$meta$totalResults
x$meta$perPage
x$meta$totalPages
x$meta$page
x$meta$cursor
head(x$data)

# pagination
pow_search(sci_com = "sunflower", limit = 2)

# debug curl stuff
invisible(pow_search(sci_com = "Helianthus annuus", verbose = TRUE))

# sort
desc <- pow_search(sci_com = "Helianthus", sort = "name_desc")
desc$data$name
asc <- pow_search(sci_com = "Helianthus", sort = "name_asc")
asc$data$name
}
}
\references{
http://powo.science.kew.org/
}
\seealso{
Other pow: 
\code{\link{get_pow}()},
\code{\link{pow_lookup}()},
\code{\link{pow_synonyms}()}
}
\author{
Scott Chamberlain,
}
\concept{pow}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eubon.R
\name{eubon_search}
\alias{eubon_search}
\title{EUBON taxonomy search}
\usage{
eubon_search(
  query,
  providers = "pesi",
  searchMode = "scientificNameExact",
  addSynonymy = FALSE,
  addParentTaxon = FALSE,
  timeout = 0,
  dedup = NULL,
  limit = 20,
  page = 1,
  ...
)
}
\arguments{
\item{query}{(character) The scientific name to search for. For example:
"Bellis perennis", "Prionus" or "Bolinus brandaris". This is an exact search
so wildcard characters are not supported}

\item{providers}{(character) A list of provider id strings concatenated by
comma characters. The default : "pesi,bgbm-cdm-server[col]" will be
used if this parameter is not set. A list of all available provider ids
can be obtained from the '/capabilities' service end point. Providers can be
nested, that is a parent provider can have sub providers. If the id of the
parent provider is supplied all subproviders will be queried. The query
can also be restricted to one or more subproviders by using the following
syntax: parent-id[sub-id-1,sub-id2,...]}

\item{searchMode}{(character) Specifies the searchMode. Possible search
modes are: \code{scientificNameExact}, \code{scientificNameLike} (begins with),
\code{vernacularNameExact}, \code{vernacularNameLike}
(contains), \code{findByIdentifier}. If the a provider does not support the
chosen searchMode it will be skipped and the status message in the
tnrClientStatus will be set to 'unsupported search mode' in this case.}

\item{addSynonymy}{(logical) Indicates whether the synonymy of the accepted
taxon should be included into the response. Turning this option on may
cause an increased response time. Default: \code{FALSE}}

\item{addParentTaxon}{(logical) Indicates whether the the parent taxon of
the accepted taxon should be included into the response. Turning this option
on may cause a slightly increased response time. Default: \code{FALSE}}

\item{timeout}{(numeric) The maximum of milliseconds to wait for responses
from any of the providers. If the timeout is exceeded the service will just
return the responses that have been received so far. The default timeout is
0 ms (wait for ever)}

\item{dedup}{(character) Allows to deduplicate the results by making use of
a deduplication strategy. The deduplication is done by comparing
specific properties of the taxon:
\itemize{
\item id: compares 'taxon.identifier'
\item id_name: compares 'taxon.identifier' AND
'taxon.taxonName.scientificName'
\item name: compares 'taxon.taxonName.scientificName' Using the pure
'name' strategy is not recommended.
}}

\item{limit}{(numeric/integer) number of records to retrieve. default: 20.
This only affects the search mode \code{scientificNameLike} and
\code{vernacularNameLike}; other search modes are expected to return only one
record per check list}

\item{page}{(numeric/integer) page to retrieve. default: 1. This only
affects the search mode \code{scientificNameLike} and \code{vernacularNameLike}; other
search modes are expected to return only one record per check list}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\description{
EUBON taxonomy search
}
\examples{
\dontrun{
eubon_search("Prionus")
eubon_search("Salmo", "pesi")
eubon_search("Salmo", c("pesi", "worms"))
eubon_search("Salmo", "worms", "scientificNameLike")
eubon_search("Salmo", "worms", "scientificNameLike", limit = 3)
eubon_search("Salmo", "worms", "scientificNameLike", limit = 20, page = 2)
eubon_search("Salmo", "worms", addSynonymy = TRUE)
eubon_search("Salmo", "worms", addParentTaxon = TRUE)
}
}
\references{
https://cybertaxonomy.eu/eu-bon/utis/1.3/doc.html
}
\seealso{
Other eubon-methods: 
\code{\link{eubon_capabilities}()},
\code{\link{eubon_children}()},
\code{\link{eubon_hierarchy}()}
}
\concept{eubon-methods}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_hierarchy.R
\name{itis_hierarchy}
\alias{itis_hierarchy}
\title{ITIS hierarchy}
\usage{
itis_hierarchy(tsn, what = "full", ...)
}
\arguments{
\item{tsn}{One or more TSN's (taxonomic serial number). Required.}

\item{what}{One of full (full hierarchy), up (immediate upstream), or down
(immediate downstream)}

\item{...}{Further arguments passed on to \code{\link[ritis:hierarchy]{ritis::hierarchy_full()}}
\code{\link[ritis:hierarchy]{ritis::hierarchy_up()}} or \code{\link[ritis:hierarchy]{ritis::hierarchy_down()}}}
}
\description{
Get hierarchies from TSN values, full, upstream only, or
immediate downstream only
}
\details{
Note that \code{\link[=itis_downstream]{itis_downstream()}} gets taxa downstream to a
particular rank, while this function only gets immediate names downstream.
}
\examples{
\dontrun{
# Get full hierarchy
itis_hierarchy(tsn=180543)

# Get hierarchy upstream
itis_hierarchy(tsn=180543, "up")

# Get hierarchy downstream
itis_hierarchy(tsn=180543, "down")

# Many tsn's
itis_hierarchy(tsn=c(180543,41074,36616))
}
}
\seealso{
\code{\link[=itis_downstream]{itis_downstream()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_pow.R
\name{get_pow}
\alias{get_pow}
\alias{as.pow}
\alias{as.pow.pow}
\alias{as.pow.character}
\alias{as.pow.list}
\alias{as.pow.data.frame}
\alias{as.data.frame.pow}
\alias{get_pow_}
\title{Get Kew's Plants of the World code for a taxon}
\usage{
get_pow(
  sci_com,
  accepted = FALSE,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  family_filter = NULL,
  rank_filter = NULL,
  x = NULL,
  ...
)

as.pow(x, check = TRUE)

\method{as.pow}{pow}(x, check = TRUE)

\method{as.pow}{character}(x, check = TRUE)

\method{as.pow}{list}(x, check = TRUE)

\method{as.pow}{data.frame}(x, check = TRUE)

\method{as.data.frame}{pow}(x, ...)

get_pow_(sci_com, messages = TRUE, rows = NA, x = NULL, ...)
}
\arguments{
\item{sci_com}{character; A vector of common or scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{accepted}{logical; If TRUE, removes names that are not accepted
valid names by ITIS. Set to \code{FALSE} (default) to give back both
accepted and unaccepted names.}

\item{ask}{logical; should \code{get_pow} be run in interactive mode?
If TRUE and more than one pow is found for teh species, the user is
asked for input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; should progress be printed?}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA,
all rows are considered. Note that this function still only gives back
a pow class object with one to many identifiers. See
\code{\link[=get_pow_]{get_pow_()}} to get back all, or a subset,
of the raw data that you are presented during the ask process.}

\item{family_filter}{(character) A division (aka phylum) name to filter
data after retrieved from NCBI. Optional. See \code{Filtering} below.}

\item{rank_filter}{(character) A taxonomic rank name to filter data after
retrieved from NCBI. See \link{rank_ref} for possible options.
Though note that some data sources use atypical ranks, so inspect the data
itself for options. Optional. See \code{Filtering} below.}

\item{x}{For \code{get_pow()}: deprecated, see \code{sci_com}. For \code{as.pow}, various,
see examples}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.pow]{as.pow()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get Kew's Plants of the World code for a taxon
}
\section{Filtering}{

The parameters \code{family_filter} an\code{rank_filter}er are not
used in the search to the data provider, but are used in filtering the data down to a
subset that is closer to the target you want.  For these two parameters,
you can use regex strings since we use \code{\link[=grep]{grep()}} internally to match.
Filtering narrows down to the set that matches your query, and removes the rest.
}

\section{Rate-limits}{

As of February 2019, KEW was limiting to 5 requests per second. Note that
they may change that number in the future.

If you get errors that contain \code{429} you are hitting the rate limit, and you
can get around it by doing requests with \code{Sys.sleep} in between requests.
}

\examples{
\dontrun{
get_pow(sci_com="Helianthus")
get_pow(c("Helianthus","Quercus douglasii"))

# Get back a subset
get_pow(sci_com="Helianthus", rows = 1)
get_pow(sci_com="Helianthus", rows = 1:10)

# When not found
get_pow("howdy")
get_pow(c("Helianthus annuus", "howdy"))

# Narrow down results 
# to accepted names
get_pow("Helianthus", accepted = TRUE)
# to a kingom 
get_pow("Helianthus", rank_filter = "genus")
# to accepted names and rank
get_pow("Helianthus annuus", accepted = TRUE, rank_filter = "species")
# to a family
get_pow("flower", family_filter = "Acanthaceae")

# Convert a pow without class information to a pow class
z <- get_pow("Helianthus annuus", accepted = TRUE, rank_filter = "species")
# already a pow, returns the same
as.pow(z)
as.pow("urn:lsid:ipni.org:names:119003-2")
# character vector, length > 1
ids <- c("urn:lsid:ipni.org:names:119003-2","urn:lsid:ipni.org:names:328247-2")
as.pow(ids)
# list, with character strings
as.pow(as.list(ids)) 
## dont check, much faster
as.pow("urn:lsid:ipni.org:names:119003-2", check=FALSE)
as.pow(ids, check=FALSE)
as.pow(as.list(ids), check=FALSE)

(out <- as.pow(ids))
data.frame(out)
as.pow( data.frame(out) )

# Get all data back
get_pow_("Quercus", rows=1:5)
get_pow_("Quercus", rows=1)
get_pow_(c("Pinus", "Abies"), rows = 1:3)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other pow: 
\code{\link{pow_lookup}()},
\code{\link{pow_search}()},
\code{\link{pow_synonyms}()}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{pow}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downstream.R
\name{downstream}
\alias{downstream}
\alias{downstream.default}
\alias{downstream.tsn}
\alias{downstream.gbifid}
\alias{downstream.uid}
\alias{downstream.wormsid}
\alias{downstream.boldid}
\alias{downstream.ids}
\title{Retrieve the downstream taxa for a given taxon name or ID.}
\usage{
downstream(...)

\method{downstream}{default}(
  sci_id,
  db = NULL,
  downto = NULL,
  intermediate = FALSE,
  rows = NA,
  x = NULL,
  ...
)

\method{downstream}{tsn}(sci_id, db = NULL, downto = NULL, intermediate = FALSE, ...)

\method{downstream}{gbifid}(
  sci_id,
  db = NULL,
  downto = NULL,
  intermediate = FALSE,
  limit = 100,
  start = NULL,
  ...
)

\method{downstream}{uid}(sci_id, db = NULL, downto = NULL, intermediate = FALSE, ...)

\method{downstream}{wormsid}(sci_id, db = NULL, downto = NULL, intermediate = FALSE, ...)

\method{downstream}{boldid}(sci_id, db = NULL, downto = NULL, intermediate = FALSE, ...)

\method{downstream}{ids}(sci_id, db = NULL, downto = NULL, intermediate = FALSE, ...)
}
\arguments{
\item{...}{Further args passed on to \code{\link[=itis_downstream]{itis_downstream()}},
\code{\link[=gbif_downstream]{gbif_downstream()}}, \code{\link[=ncbi_downstream]{ncbi_downstream()}},
\code{\link[=worms_downstream]{worms_downstream()}}, or \code{\link[=bold_downstream]{bold_downstream()}}}

\item{sci_id}{Vector of taxa names (character) or IDs (character or numeric)
to query.}

\item{db}{character; database to query. One or more of \code{itis}, \code{gbif},
\code{ncbi}, \code{worms}, or \code{bold}. Note that each taxonomic  data source has
their own identifiers, so that if you provide the wrong \code{db} value for
the identifier
you could get a result, but it will likely be wrong (not what you were
expecting). If using ncbi, we recommend getting an API key; see
\link{taxize-authentication}}

\item{downto}{What taxonomic rank to go down to. One of: 'superkingdom',
'kingdom', 'subkingdom','infrakingdom','phylum','division','subphylum',
'subdivision','infradivision', 'superclass','class','subclass','infraclass',
'superorder','order','suborder','infraorder','superfamily','family',
'subfamily','tribe','subtribe','genus','subgenus','section','subsection',
'species group','species','subspecies','variety','form','subvariety','race',
'stirp', 'morph','aberration','subform', 'unspecified', 'no rank'}

\item{intermediate}{(logical) If \code{TRUE}, return a list of length two
with target taxon rank names, with additional list of data.frame's of
intermediate taxonomic groups. Default: \code{FALSE}}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this parameter is ignored if you pass in a
taxonomic id of any of the acceptable classes: tsn.}

\item{x}{Deprecated, see \code{sci_id}}

\item{limit}{Number of records to return. Applies to gbif only.
default: 100. max: 1000. use in combination with the \code{start} parameter}

\item{start}{Record number to start at. Applies to gbif only. default: 0.
use in combination with the \code{limit} parameter}
}
\value{
A named list of data.frames with the downstream names of every
supplied taxa. You get an NA if there was no match in the database.
}
\description{
This function uses a while loop to continually collect children taxa down
to the taxonomic rank that you specify in the \code{downto} parameter. You
can get data from ITIS (itis), GBIF (gbif), NCBI (ncbi), WORMS (worms),
or BOLD (bold). There is no method exposed by these four
services for getting taxa at a specific taxonomic rank, so we do it
ourselves here.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\section{bold}{

BEWARE: \code{db="bold"} scrapes the BOLD website, so may be unstable. That is,
one day it may work, and the next it may fail. Open an issue if you
encounter an error: https://github.com/ropensci/taxize/issues
}

\examples{
\dontrun{
# Plug in taxon IDs
downstream(125732, db = 'worms', downto = 'species')
downstream(3451, db = 'bold', downto = 'species')

if (interactive()) {

# Plug in taxon names
downstream("Apis", db = 'ncbi', downto = 'species')
downstream("Apis", db = 'itis', downto = 'species')
downstream("Apis", db = 'bold', downto = 'species')
downstream("Gadus", db = 'worms', downto = 'species')
downstream(c("Apis","Epeoloides"), db = 'itis', downto = 'species')
downstream("Ursus", db = 'gbif', downto = 'species')
downstream(get_gbifid("Ursus"), db = 'gbif', downto = 'species')

# Many taxa
sp <- names_list("genus", 3)
downstream(sp, db = 'itis', downto = 'species')
downstream(sp, db = 'gbif', downto = 'species')

# Both data sources
ids <- get_ids("Apis", db = c('gbif','itis'))
downstream(ids, downto = 'species')
## same result
downstream(get_ids("Apis", db = c('gbif','itis')), downto = 'species')

# Collect intermediate names
## itis
downstream('Bangiophyceae', db="itis", downto="genus")
downstream('Bangiophyceae', db="itis", downto="genus", intermediate=TRUE)
downstream(get_tsn('Bangiophyceae'), downto="genus")
downstream(get_tsn('Bangiophyceae'), downto="genus", intermediate=TRUE)

# Use the rows parameter
## note how in the second function call you don't get the prompt
downstream("Poa", db = 'gbif', downto="species")
downstream("Poa", db = 'gbif', downto="species", rows=1)

# use curl options
res <- downstream("Apis", db = 'gbif', downto = 'species', verbose = TRUE)

# Pagination
# GBIF limits queries to a maximum of 1000 records per request, so if
# there's more than 1000, use the start parameter
# Piper, taxonKey = 3075433
z1 <- downstream(3075433, db = 'gbif', downto = "species", limit=1000)
z2 <- downstream(3075433, db = 'gbif', downto = "species", limit=1000,
  start=1000)
z3 <- downstream(3075433, db = 'gbif', downto = "species", limit=1000,
  start=2000)
z4 <- downstream(3075433, db = 'gbif', downto = "species", limit=1000,
  start=3000)
NROW(rbind(z1[[1]], z2[[1]], z3[[1]], z4[[1]]))
}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eubon.R
\name{eubon}
\alias{eubon}
\title{DEFUNCT}
\usage{
eubon(...)
}
\description{
DEFUNCT
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resolve.R
\name{resolve}
\alias{resolve}
\title{Resolve names from different data sources}
\usage{
resolve(sci, db = "gnr", query = NULL, ...)
}
\arguments{
\item{sci}{Vector of one or more taxonomic names (common names not
supported)}

\item{db}{Source to check names against. One of iplant or gnr.
Default: gnr. Note that each taxonomic data source has their own
identifiers, so that if you provide the wrong \code{db} value for the
identifier you could get a result, but it will likely be wrong (not
what you were expecting).}

\item{query}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET} or
\link[crul:verb-POST]{crul::verb-POST}. In addition, further named args passed
on to  each respective function. See examples}
}
\value{
A list with length equal to length of the db parameter (number
of sources requested), with each element being a data.frame or list
with results from that source.
}
\description{
Resolve names from iPlant's name resolver, and
the Global Names Resolver (GNR)
}
\examples{
\dontrun{
resolve(sci=c("Helianthus annuus", "Homo sapiens"))
resolve(sci="Quercus keloggii", db='gnr')
resolve(sci=c("Helianthus annuus", "Homo sapiens"), db=c('iplant', 'gnr'))
resolve(sci="Quercus keloggii", db=c('iplant', 'gnr'))

# pass in options specific to each source
resolve("Helianthus annuus", db = 'gnr', preferred_data_sources = c(3, 4))
resolve("Helianthus annuus", db = 'iplant', retrieve = 'best')
identical(
 resolve("Helianthus annuus", db = 'iplant', retrieve = 'best')$iplant,
 iplant_resolve("Helianthus annuus", retrieve = 'best')
)

# pass in curl options
resolve(sci="Qercuss", db = "iplant", verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lowest_common.R
\name{lowest_common}
\alias{lowest_common}
\alias{lowest_common.default}
\alias{lowest_common.uid}
\alias{lowest_common.tsn}
\alias{lowest_common.gbifid}
\alias{lowest_common.tolid}
\title{Retrieve the lowest common taxon and rank for a given taxon name or ID}
\usage{
lowest_common(...)

\method{lowest_common}{default}(
  sci_id,
  db = NULL,
  rows = NA,
  class_list = NULL,
  low_rank = NULL,
  x = NULL,
  ...
)

\method{lowest_common}{uid}(sci_id, class_list = NULL, low_rank = NULL, ...)

\method{lowest_common}{tsn}(sci_id, class_list = NULL, low_rank = NULL, ...)

\method{lowest_common}{gbifid}(sci_id, class_list = NULL, low_rank = NULL, ...)

\method{lowest_common}{tolid}(sci_id, class_list = NULL, low_rank = NULL, ...)
}
\arguments{
\item{...}{Other arguments passed to \code{\link[=get_tsn]{get_tsn()}}, \code{\link[=get_uid]{get_uid()}},
\code{\link[=get_gbifid]{get_gbifid()}}, \code{\link[=get_tolid]{get_tolid()}}}

\item{sci_id}{Vector of taxa names (character) or id (character or numeric) to
query.}

\item{db}{character; database to query. either \code{ncbi}, \code{itis}, \code{gbif},
\code{tol}. If using ncbi, we recommend getting an API key;
see \link{taxize-authentication}}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA,
all rows are considered. Note that this parameter is ignored if you pass in
a taxonomic id of any of the acceptable classes: tsn, gbifid, tolid.
NCBI has a method for this function but rows doesn't work.}

\item{class_list}{(list) A list of classifications, as returned from
\code{\link[=classification]{classification()}}}

\item{low_rank}{(character) taxonomic rank to return, of length 1}

\item{x}{Deprecated, see \code{sci_id}}
}
\value{
NA when no match, or a data.frame with columns
\itemize{
\item name
\item rank
\item id
}
}
\description{
Retrieve the lowest common taxon and rank for a given taxon name or ID
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\examples{
\dontrun{
id <- c("9031", "9823", "9606", "9470")
id_class <- classification(id, db = 'ncbi')
lowest_common(id[2:4], db = "ncbi")
lowest_common(id[2:4], db = "ncbi", low_rank = 'class')
lowest_common(id[2:4], db = "ncbi", low_rank = 'family')
lowest_common(id[2:4], class_list = id_class)
lowest_common(id[2:4], class_list = id_class, low_rank = 'class')
lowest_common(id[2:4], class_list = id_class, low_rank = 'family')

# TOL
taxa <- c("Angraecum sesquipedale", "Dracula vampira",
  "Masdevallia coccinea")
(cls <- classification(taxa, db = "tol"))
lowest_common(taxa, db = "tol", class_list = cls)
lowest_common(get_tolid(taxa), class_list = cls)
xx <- get_tolid(taxa)
lowest_common(xx, class_list = cls)

spp <- c("Sus scrofa", "Homo sapiens", "Nycticebus coucang")
lowest_common(spp, db = "ncbi")
lowest_common(get_uid(spp))

lowest_common(spp, db = "itis")
lowest_common(get_tsn(spp))

gbifid <- c("2704179", "3119195")
lowest_common(gbifid, db = "gbif")

spp <- c("Poa annua", "Helianthus annuus")
lowest_common(spp, db = "gbif")
lowest_common(get_gbifid(spp))

cool_orchid <- c("Angraecum sesquipedale", "Dracula vampira",
  "Masdevallia coccinea")
orchid_ncbi <- get_uid(cool_orchid)
orchid_gbif <- get_gbifid(cool_orchid)

cool_orchids2 <- c("Domingoa haematochila", "Gymnadenia conopsea",
  "Masdevallia coccinea")
orchid_itis <- get_tsn(cool_orchids2)

orchid_hier_ncbi <- classification(orchid_ncbi, db = 'ncbi')
orchid_hier_gbif <- classification(orchid_gbif, db = 'gbif')
orchid_hier_itis <- classification(orchid_itis, db = 'itis')

lowest_common(orchid_ncbi, low_rank = 'class')
lowest_common(orchid_ncbi, class_list = orchid_hier_ncbi,
  low_rank = 'class')
lowest_common(orchid_gbif, low_rank = 'class')
lowest_common(orchid_gbif, orchid_hier_gbif, low_rank = 'class')
lowest_common(get_uid(cool_orchid), low_rank = 'class')
lowest_common(get_uid(cool_orchid), low_rank = 'family')

lowest_common(orchid_ncbi, class_list = orchid_hier_ncbi,
  low_rank = 'subfamily')
lowest_common(orchid_gbif, class_list = orchid_hier_gbif,
  low_rank = 'subfamily')

lowest_common(orchid_itis, class_list = orchid_hier_itis,
  low_rank = 'class')

## Pass in sci. names
nms <- c("Angraecum sesquipedale", "Dracula vampira", "Masdevallia coccinea")
lowest_common(x = nms, db = "ncbi")
lowest_common(x = nms, db = "gbif")
# lowest_common(x = nms, db = "itis")

## NAs due to taxon not found, stops with error message
# lowest_common(orchid_itis, db = "itis")
# lowest_common(get_tsn(cool_orchid))
}
}
\author{
Jimmy O'Donnell \email{jodonnellbio@gmail.com}
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxon_state.R
\name{taxon_state}
\alias{taxon_state}
\title{Keep track of queries in \verb{get_*} functions}
\description{
Keep track of queries in \verb{get_*} functions

Keep track of queries in \verb{get_*} functions
}
\details{
This object lives inside each \verb{get_*} function call, maintaining
results as they are accumulated.
}
\examples{
\dontrun{
if (interactive()) {
ts <- taxon_state$new()
taxon_last()
ts
res <- list(
  id = 123456,
  att = "found",
  multiple = FALSE,
  direct = FALSE,
  class = "tsn"
)
ts$add(query = "Quercus robur", result = res)
ts
ts$get(query = "Quercus robur")
ts$count
ts$remove(query = "Quercus robur")
ts
ts$count

res2 <- list(
  id = 3430834535,
  att = "found",
  multiple = FALSE,
  direct = FALSE,
  class = "gbifid"
)
ts$add(query = "Poa annua", result = res2)
res3 <- list(
  id = 1223424,
  att = "found",
  multiple = FALSE,
  direct = FALSE,
  class = "uid"
)
ts$add(query = "Puma concolor", result = res3)
ts
ts$count
ts$get("Puma concolor")
ts$get()

# cleanup
ts$purge()
ts$count
}
}
}
\keyword{internal}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{initialized}}{(time) time job started}

\item{\code{finalized}}{(time) time job finished}

\item{\code{class}}{(character) a class name (e.g., "gbif")}

\item{\code{names}}{(character) one or more taxon names}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{count}}{(integer) count number of records}

\item{\code{exit}}{record date/time function exited}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{taxon_state$new()}}
\item \href{#method-print}{\code{taxon_state$print()}}
\item \href{#method-add}{\code{taxon_state$add()}}
\item \href{#method-get}{\code{taxon_state$get()}}
\item \href{#method-remove}{\code{taxon_state$remove()}}
\item \href{#method-purge}{\code{taxon_state$purge()}}
\item \href{#method-taxa_remaining}{\code{taxon_state$taxa_remaining()}}
\item \href{#method-taxa_completed}{\code{taxon_state$taxa_completed()}}
\item \href{#method-clone}{\code{taxon_state$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{taxon_state} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$new(class, names)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{class}}{(character) a class name (e.g., "gbif")}

\item{\code{names}}{(character) one or more taxon names}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{taxon_state} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
print method for the \code{taxon_state} class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$print(x, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{self}

\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add"></a>}}
\if{latex}{\out{\hypertarget{method-add}{}}}
\subsection{Method \code{add()}}{
add a record with it's result; duplicates allowed
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$add(query, result)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{(character), a taxon name}

\item{\code{result}}{(list) a named list}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing returned; sets only
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get"></a>}}
\if{latex}{\out{\hypertarget{method-get}{}}}
\subsection{Method \code{get()}}{
get all records matching 'query'
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$get(query = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{(character), a taxon name}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list, with slots for the taxon id, and other attributes,
named by the taxon name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove"></a>}}
\if{latex}{\out{\hypertarget{method-remove}{}}}
\subsection{Method \code{remove()}}{
remove's all records matching 'query'
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$remove(query)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{(character), a taxon name}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing, removes records matching query
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-purge"></a>}}
\if{latex}{\out{\hypertarget{method-purge}{}}}
\subsection{Method \code{purge()}}{
removes all records
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$purge()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing returned; sets only
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-taxa_remaining"></a>}}
\if{latex}{\out{\hypertarget{method-taxa_remaining}{}}}
\subsection{Method \code{taxa_remaining()}}{
get remaining taxa
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$taxa_remaining()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
sorted taxon names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-taxa_completed"></a>}}
\if{latex}{\out{\hypertarget{method-taxa_completed}{}}}
\subsection{Method \code{taxa_completed()}}{
get completed taxa
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$taxa_completed()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
sorted taxon names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{taxon_state$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genbank2uid.R
\name{genbank2uid}
\alias{genbank2uid}
\title{Get NCBI taxonomy UID from GenBankID}
\usage{
genbank2uid(id, batch_size = 100, key = NULL, ...)
}
\arguments{
\item{id}{A GenBank accession alphanumeric string, or a gi numeric string.}

\item{batch_size}{The number of queries to submit at a time.}

\item{key}{(character) NCBI Entrez API key. optional. See Details.}

\item{...}{Curl args passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
one or more NCBI taxonomic IDs
}
\description{
Get NCBI taxonomy UID from GenBankID
}
\details{
See https://www.ncbi.nlm.nih.gov/Sitemap/sequenceIDs.html for
help on why there are two identifiers, and the difference between them.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication. We
recommend getting an API key.
}

\section{HTTP version}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\section{Rate limits}{

In case you run into errors due to your rate limit being exceeded, see
\code{\link[=taxize_options]{taxize_options()}}, where you can set \code{ncbi_sleep}.
}

\examples{
\dontrun{
# with accession numbers
genbank2uid(id = 'AJ748748')
genbank2uid(id = 'Y13155')
genbank2uid(id = 'X78312')
genbank2uid(id = 'KM495596')

# with gi numbers
genbank2uid(id = 62689767)
genbank2uid(id = 22775511)
genbank2uid(id = 156446673)

# pass in many accession or gi numbers
genbank2uid(c(62689767,156446673))
genbank2uid(c('X78312','KM495596'))
genbank2uid(list('X78312',156446673))

# curl options
res <- genbank2uid(id = 156446673, verbose = TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ubio_classification_search.R
\name{ubio_classification_search}
\alias{ubio_classification_search}
\title{This function will return ClassificationBankIDs (hierarchiesIDs) that refer to the
given NamebankID}
\usage{
ubio_classification_search(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize_options.R
\name{taxize_options}
\alias{taxize_options}
\title{taxize options}
\usage{
taxize_options(taxon_state_messages = NULL, ncbi_sleep = NULL, quiet = FALSE)
}
\arguments{
\item{taxon_state_messages}{(logical) suppress messages? default: \code{NULL}
(same as setting \code{FALSE}). Set to \code{TRUE} to suppress messages, and \code{FALSE}
to not suppress messages}

\item{ncbi_sleep}{(numeric/integer) number of seconds to sleep between
NCBI ENTREZ http requests. applies to the functions: \code{\link[=classification]{classification()}},
\code{\link[=comm2sci]{comm2sci()}}, \code{\link[=genbank2uid]{genbank2uid()}}, \code{\link[=get_uid]{get_uid()}} and \code{\link[=ncbi_children]{ncbi_children()}}.
defaults: 0.334 (without API key) or 0.101 (with API key). minimum value
can not be less than 0.101}

\item{quiet}{(logical) quiet informational output from this function.
default: \code{TRUE}}
}
\description{
taxize options
}
\examples{
\dontrun{
taxize_options()
taxize_options(FALSE)
taxize_options(TRUE)
taxize_options(ncbi_sleep = 0.4)
taxize_options(taxon_state_messages = TRUE, ncbi_sleep = 0.4)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/progressor.R
\name{progressor}
\alias{progressor}
\title{methods for preparing/printing info for prompts for \verb{get_*} functions}
\description{
methods for preparing/printing info for prompts for \verb{get_*} functions

methods for preparing/printing info for prompts for \verb{get_*} functions
}
\examples{
\dontrun{
# nms <- c("Quercus", "Sasdsfasdf")
# x <- progressor$new(items = nms)
# x
# x$prog_start()

# x$completed(nms[1], "found")
# x$prog_found()

# x$completed(nms[2], "not found")
# x$prog_not_found()

# x$prog_summary()

# suppress cli::cat_line
# x <- progressor$new(items = nms, suppress = TRUE)
# x$prog_summary()
}
}
\keyword{internal}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{total}}{(integer) x}

\item{\code{found}}{(integer) list of results when name found}

\item{\code{not_found}}{(integer) list of results when name not found}

\item{\code{done}}{(integer) x}

\item{\code{suppress}}{(integer) x}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{p}}{(integer) percent done}

\item{\code{d}}{(integer) number done}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{progressor$new()}}
\item \href{#method-completed}{\code{progressor$completed()}}
\item \href{#method-completed_found}{\code{progressor$completed_found()}}
\item \href{#method-completed_not_found}{\code{progressor$completed_not_found()}}
\item \href{#method-prog_start}{\code{progressor$prog_start()}}
\item \href{#method-prog}{\code{progressor$prog()}}
\item \href{#method-prog_found}{\code{progressor$prog_found()}}
\item \href{#method-prog_not_found}{\code{progressor$prog_not_found()}}
\item \href{#method-prog_summary}{\code{progressor$prog_summary()}}
\item \href{#method-clone}{\code{progressor$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{progressor} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$new(items, suppress = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{items}}{(character) xxx}

\item{\code{suppress}}{(logical) suppress messages. default: \code{FALSE}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{progressor} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-completed"></a>}}
\if{latex}{\out{\hypertarget{method-completed}{}}}
\subsection{Method \code{completed()}}{
add results to found or not found
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$completed(name, att)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{(character) vector of names}

\item{\code{att}}{(character) one of "found" or "not found"}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing returned; adds to \verb{$found} or \verb{$not_found}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-completed_found"></a>}}
\if{latex}{\out{\hypertarget{method-completed_found}{}}}
\subsection{Method \code{completed_found()}}{
add to found results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$completed_found(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{(character) vector of taxon names}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing returned; adds to \verb{$found}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-completed_not_found"></a>}}
\if{latex}{\out{\hypertarget{method-completed_not_found}{}}}
\subsection{Method \code{completed_not_found()}}{
add to not found results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$completed_not_found(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{(character) vector of taxon names}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing returned; adds to \verb{$not_found}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-prog_start"></a>}}
\if{latex}{\out{\hypertarget{method-prog_start}{}}}
\subsection{Method \code{prog_start()}}{
print messages of total queries to do, and
percent completed
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$prog_start()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-prog"></a>}}
\if{latex}{\out{\hypertarget{method-prog}{}}}
\subsection{Method \code{prog()}}{
prints message of found or not found using packages
cli and crayon
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$prog(att)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{att}}{(character) one of "found" or "not found"}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
messages
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-prog_found"></a>}}
\if{latex}{\out{\hypertarget{method-prog_found}{}}}
\subsection{Method \code{prog_found()}}{
prints found message using packages cli and crayon
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$prog_found()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
messages
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-prog_not_found"></a>}}
\if{latex}{\out{\hypertarget{method-prog_not_found}{}}}
\subsection{Method \code{prog_not_found()}}{
prints not found message using packages cli and crayon
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$prog_not_found()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
messages
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-prog_summary"></a>}}
\if{latex}{\out{\hypertarget{method-prog_summary}{}}}
\subsection{Method \code{prog_summary()}}{
prints summary at end of result with total found and
not found
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$prog_summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
messages
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{progressor$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tax_name.R
\name{tax_name}
\alias{tax_name}
\title{Get taxonomic names for a given rank}
\usage{
tax_name(
  sci,
  get,
  db = "itis",
  pref = "ncbi",
  messages = TRUE,
  query = NULL,
  ...
)
}
\arguments{
\item{sci}{(character) Vector of taxonomic names to query. required.}

\item{get}{(character) The ranks of the taxonomic name to get, see
\link{rank_ref}. required.}

\item{db}{(character) The database to search from: 'itis', 'ncbi' or 'both'.
If 'both' both NCBI and ITIS will be queried. Result will be the union of
both. If using ncbi, we recommend getting an API key; see
\link{taxize-authentication}}

\item{pref}{(character) If db = 'both', sets the preference for the union.
Either 'ncbi' (default) or 'itis'. Currently not implemented.}

\item{messages}{(logical) If \code{TRUE} the actual taxon queried is printed
on the console.}

\item{query}{Deprecated, see \code{sci}}

\item{...}{Other arguments passed to \code{\link[=get_tsn]{get_tsn()}} or
\code{\link[=get_uid]{get_uid()}}.}
}
\value{
A data.frame with one column for every queried rank, in addition to
a column for db and queried term.
}
\description{
Get taxonomic names for a given rank
}
\note{
While \code{\link[=tax_rank]{tax_rank()}} returns the actual rank of a
taxon, \code{\link[=tax_name]{tax_name()}} searches and returns any specified rank
higher in taxonomy.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\examples{
\dontrun{
# A case where itis and ncbi use the same names
tax_name(sci = "Helianthus annuus", get = "family", db = "itis")
tax_name(sci = "Helianthus annuus", get = "family", db = "ncbi")
tax_name(sci = "Helianthus annuus", get = c("genus","family","order"),
  db = "ncbi")

# Case where itis and ncbi use different names
tax_name(sci = "Helianthus annuus", get = "kingdom", db = "itis")
tax_name(sci = "Helianthus annuus", get = "kingdom", db = "ncbi")

# multiple rank arguments
tax_name(sci = c("Helianthus annuus","Baetis rhodani"), get = c("genus",
"kingdom"), db = "ncbi")
tax_name(sci = c("Helianthus annuus","Baetis rhodani"), get = c("genus",
"kingdom"), db = "itis")

# query both sources
tax_name(sci=c("Helianthus annuus", 'Baetis rhodani'), get=c("genus",
"kingdom"), db="both")
}
}
\seealso{
\code{\link[=classification]{classification()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ubio_search.R
\name{ubio_search}
\alias{ubio_search}
\title{This function will return NameBankIDs that match given search terms}
\usage{
ubio_search(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/status_codes.R
\name{status_codes}
\alias{status_codes}
\title{Get HTTP status codes}
\usage{
status_codes()
}
\description{
Get HTTP status codes
}
\examples{
status_codes()
}
\seealso{
\code{\link[=ping]{ping()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plantminer.R
\name{plantminer}
\alias{plantminer}
\title{Search for taxonomy data from Plantminer.com}
\usage{
plantminer(plants, from = "tpl", messages = TRUE, ...)
}
\arguments{
\item{plants}{(character) Vector of plant species names. Required.}

\item{from}{(character) One of tpl (for theplantlist.com data), or
flora (for Brazilian Flora Checklist). Required. Default: \code{tpl}}

\item{messages}{(logical) informative messages or not. Default: \code{TRUE}}

\item{...}{curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
data.frame of results.
}
\description{
Search for taxonomy data from Plantminer.com
}
\note{
you used to need an API key for Plantminer; it's no longer needed
}
\examples{
\dontrun{
# A single taxon
plantminer("Ocotea pulchella")

# Many taxa
plants <- c("Myrcia lingua", "Myrcia bella", "Ocotea pulchella",
		"Miconia", "Coffea arabica var. amarella", "Bleh")
plantminer(plants)

# By deafult, tpl is used, for Theplantlist data,
# toggle the from parameter here
plantminer("Ocotea pulchella", from = "flora")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_acceptname.R
\name{itis_acceptname}
\alias{itis_acceptname}
\title{Retrieve accepted TSN and name}
\usage{
itis_acceptname(searchtsn, ...)
}
\arguments{
\item{searchtsn}{One or more TSN for a taxon (numeric/integer)}

\item{...}{Curl options passed on to\link[crul:verb-GET]{crul::verb-GET}}
}
\value{
data.frame with with row number equal to input vector length, and
with three columns:
\itemize{
\item submittedtsn (numeric) - The submitted TSN
\item acceptedname (character) - The accepted name - if the submitted TSN
is the accepted TSN, then this is \code{NA_character_} because ITIS does
not return a name along with the TSN if it's an accepted name. We could
make an extra HTTP request to ITIS, but that means additional time.
\item acceptedtsn (numeric) - The accepted TSN
\item author (character) - taxonomic authority
}
}
\description{
Retrieve accepted TSN and name
}
\examples{
\dontrun{
# TSN accepted - good name
itis_acceptname(searchtsn = 208527)

# TSN not accepted - input TSN is old
itis_acceptname(searchtsn = 504239)

# many accepted names
ids <- c(18161, 18162, 18163, 18164, 18165, 18166, 46173, 46174,
46178, 46181, 46186, 46193, 46196, 46197, 46200, 46201, 46204,
46207, 46867, 46868)
itis_acceptname(searchtsn = ids)

# many unaccepted names
ids <- c(39087, 46208, 46973, 46976, 46978, 46980, 47295, 47445,
47448, 47512, 47515, 47527, 47546, 47622, 47783, 47786, 47787,
47788, 47835, 47839)
itis_acceptname(searchtsn = ids)

# many: mix of accepted and unaccepted names
ids <- c(18161, 18162, 47527, 47546, 47622, 46200)
itis_acceptname(searchtsn = ids)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getkey.R
\name{getkey}
\alias{getkey}
\title{Function to get API key.}
\usage{
getkey(x = NULL, service)
}
\arguments{
\item{x}{(character) An API key, defaults to \code{NULL}}

\item{service}{(character) The API data provider, used to match to
default guest key (for Tropicos; there's no guest
key for NCBI or IUCN, for which you have to get your own)}
}
\description{
Checks first to get key from your .Rprofile or .Renviron (or similar) file
}
\examples{
\dontrun{
getkey(service="tropicos")
getkey(service="iucn")
getkey(service="entrez")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/comm2sci.R
\name{comm2sci}
\alias{comm2sci}
\alias{comm2sci.default}
\alias{comm2sci.tsn}
\alias{comm2sci.uid}
\title{Get scientific names from common names.}
\usage{
comm2sci(...)

\method{comm2sci}{default}(
  com,
  db = "ncbi",
  itisby = "search",
  simplify = TRUE,
  commnames = NULL,
  ...
)

\method{comm2sci}{tsn}(id, db = "ncbi", itisby = "search", simplify = TRUE, ...)

\method{comm2sci}{uid}(id, db = "ncbi", itisby = "search", simplify = TRUE, ...)
}
\arguments{
\item{...}{Further arguments passed on to internal methods.}

\item{com}{One or more common names or partial names.}

\item{db}{Data source, one of \emph{"ncbi"} (default), \emph{"itis"},
\emph{"tropicos"}, \emph{"eol"}, or \emph{"worms"}. If using ncbi, we
recommend getting an API key; see \link{taxize-authentication}}

\item{itisby}{Search for common names across entire names (search, default),
at beginning of names (begin), or at end of names (end).}

\item{simplify}{(logical) If \code{TRUE}, simplify output to a vector of names.
If \code{FALSE}, return variable formats from different sources, usually a
data.frame.}

\item{commnames}{Deprecated, see \code{com}}

\item{id}{taxon identifiers, as returned by \code{\link[=get_tsn]{get_tsn()}} or \code{\link[=get_uid]{get_uid()}}}
}
\value{
If \code{simplify=TRUE}, a list of scientific names, with list
labeled by your input names. If \code{simplify=FALSE}, a data.frame with
columns that vary by data source. \code{character(0)} on no match
}
\description{
Get scientific names from common names.
}
\details{
For data sources ITIS and NCBI you can pass in common names
directly, and use \code{\link[=get_uid]{get_uid()}} or \code{\link[=get_tsn]{get_tsn()}} to get ids first, then pass in
to this fxn.

For the other data sources, you can only pass in common names directly.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\section{HTTP version for NCBI requests}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\section{Rate limits}{

In case you run into errors due to your rate limit being exceeded, see
\code{\link[=taxize_options]{taxize_options()}}, where you can set \code{ncbi_sleep}.
}

\examples{
\dontrun{
comm2sci(com='american black bear')
comm2sci(com='american black bear', simplify = FALSE)
comm2sci(com='black bear', db='itis')
comm2sci(com='american black bear', db='itis')
comm2sci(com='annual blue grass', db='tropicos')
comm2sci(com=c('annual blue grass','tree of heaven'), db='tropicos')
comm2sci('blue whale', db = "worms")
comm2sci(c('blue whale', 'dwarf surfclam'), db = "worms")

# ncbi: pass in uid's from get_uid() directly
x <- get_uid("western capercaillie", modifier = "Common Name")
comm2sci(x)
# itis: pass in tsn's from get_tsn() directly
x <- get_tsn(c("Louisiana black bear", "american crow"),
  searchtype = "common")
comm2sci(x)
}
}
\seealso{
\code{\link[=sci2comm]{sci2comm()}}
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iucn_id.R
\name{iucn_id}
\alias{iucn_id}
\title{Get an ID for a IUCN listed taxon}
\usage{
iucn_id(sciname, key = NULL, ...)
}
\arguments{
\item{sciname}{character; Scientific name. Should be cleand and in the
format \verb{*<Genus> <Species>*}. One or more.}

\item{key}{(character) required. you IUCN Redlist API key. See
\link[rredlist:rredlist-package]{rredlist::rredlist-package} for help on authenticating with
IUCN Redlist}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
A named list (names are input taxa names) of one or more IUCN IDs.
Taxa that aren't found are silently dropped.
}
\description{
Get an ID for a IUCN listed taxon
}
\examples{
\dontrun{
iucn_id("Branta canadensis")
iucn_id("Branta bernicla")
iucn_id("Panthera uncia")
iucn_id("Lynx lynx")

# many names
iucn_id(c("Panthera uncia", "Lynx lynx"))

# many names, some not found
iucn_id(c("Panthera uncia", "Lynx lynx", "foo bar", "hello world"))

# a name not found
iucn_id("Foo bar")
}
}
\author{
Scott Chamberlain,
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_getbyid.R
\name{get_genes}
\alias{get_genes}
\title{Retrieve gene sequences from NCBI by accession number.}
\usage{
get_genes(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{species_plantarum_binomials}
\alias{species_plantarum_binomials}
\title{Species names from Species Plantarum}
\format{
A data frame with 5940 rows and 3 variables:
\itemize{
\item genus First part of the binomial species name for each species
within the \href{https://en.wikipedia.org/wiki/Genus}{genus}
\item epithet specific epithet or second part of the binomial species name
for each \href{https://en.wikipedia.org/wiki/Species}{species}
\item page_number The following abbreviations sometimes are used in the
page_number field.
\itemize{
\item "add." refers to addenda that appear on the unnumbered last page of
the index in volume two.
\item "err." refers to the unnumbered page of errata that appears following
the index in volume two.
\item "canc." following a page number indicates that the binomial appeared
on the cancelled version of that page and does not appear on its
replacement (as in the 1957-1959 facsimile edition.
}
}
}
\source{
\href{http://fmhibd.library.cmu.edu/HIBD-DB/Species/home.php}{Hunt Institute for Botanical Documentation}
}
\description{
These names have been compiled from
\href{https://en.wikipedia.org/wiki/Species_Plantarum}{\emph{Species Plantarum}} by
\href{https://en.wikipedia.org/wiki/Carl_Linnaeus}{Carl Linnaeus} originally
published in 1753. It is the first work to consistently apply
\href{https://en.wikipedia.org/wiki/Binomial_nomenclature}{binomial names}
and was the starting point for the naming of plants. The book lists every
species of plant known at the time, classified into
\href{https://en.wikipedia.org/wiki/Genus}{genera}. The dataset provides a
useful reference point to see how taxonomic names have changed since their
inception. The names were transcribed by Robert W. Kiger.
}
\references{
Linnaeus, C. 1753. Species Plantarum. 2 vols. Salvius, Stockholm.
[Facsimile edition, 1957-1959, Ray Society, London.]
}
\author{
Carl Linnaeus
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_getbyname.R
\name{ncbi_getbyname}
\alias{ncbi_getbyname}
\title{Retrieve gene sequences from NCBI by taxon name and gene names.}
\usage{
ncbi_getbyname(...)
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\author{
Scott Chamberlain
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize_cite.R
\name{taxize_cite}
\alias{taxize_cite}
\title{Get citations and licenses for data sources used in taxize}
\usage{
taxize_cite(fxn = "itis", what = "citation")
}
\arguments{
\item{fxn}{Function to search on. A special case is the package name
'taxize' that will give the citations for the package.}

\item{what}{One of citation (default), license, or both.}
}
\description{
Get citations and licenses for data sources used in taxize
}
\examples{
taxize_cite(fxn='eol_search')
taxize_cite(fxn='itis_hierarchy')
taxize_cite(fxn='tp_classification')
taxize_cite(fxn='gbif_ping')
taxize_cite(fxn='plantminer')
taxize_cite(fxn='get_natservid_')
taxize_cite(fxn='as.natservid')
taxize_cite(fxn='get_wormsid')
taxize_cite(fxn='as.wormsid')

# Functions that use many data sources
taxize_cite(fxn='synonyms')
taxize_cite(fxn='classification')

# Get the taxize citation
taxize_cite(fxn='taxize')

# Get license information
taxize_cite(fxn='taxize', "license")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize_ldfast.R
\name{taxize_ldfast}
\alias{taxize_ldfast}
\title{Replacement function for ldply that should be faster in all cases.}
\usage{
taxize_ldfast(x, convertvec = FALSE)
}
\arguments{
\item{x}{A list.}

\item{convertvec}{Convert a vector to a data.frame before rbind is called.}
}
\description{
Replacement function for ldply that should be faster in all cases.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gni_search.R
\name{gni_search}
\alias{gni_search}
\title{Search for taxonomic names using the Global Names Index}
\usage{
gni_search(
  sci,
  per_page = NULL,
  page = NULL,
  justtotal = FALSE,
  parse_names = FALSE,
  search_term = NULL,
  ...
)
}
\arguments{
\item{sci}{(character) required. Name pattern you want to search
for. WARNING: Does not work for common names. Search term may include
following options (Note: can, uni, gen, sp, ssp, au, yr work only for
parsed names)
\itemize{
\item \code{*}    wild card - Search by part of a word (E.g.: planta*)
\item \code{exact} exact match    - Search for exact match of a literal string
(E.g.: exact:Parus major)
\item \code{ns} name string- Search for literal string from its beginning (other
modifiers will be ignored) (E.g.: ns:parus maj*)
\item \code{can} canonical form- Search name without authors (other modifiers will
be ignored)    (E.g.: can:parus major)
\item \code{uni} uninomial- Search for higher taxa    (E.g.: uni:parus)
\item \code{gen} genus - Search by genus epithet of species name (E.g.: gen:parus)
\item \code{sp} species - Search by species epithet (E.g.: sp:major)
\item \code{ssp} subspecies - Search by infraspecies epithet (E.g.: ssp:major)
\item \code{au} author - Search by author word    (E.g.: au:Shipunov)
\item \code{yr} year - Search by year (E.g.: yr:2005)
}}

\item{per_page}{Number of items per one page (numbers larger
than 1000 will be decreased to 1000) (default is 30).}

\item{page}{Page number you want to see (default is 1).}

\item{justtotal}{Return only the total results found.}

\item{parse_names}{If \code{TRUE}, use \code{\link[=gni_parse]{gni_parse()}} to parse
names. Default: \code{FALSE}}

\item{search_term}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
data.frame of results.
}
\description{
Uses the Global Names Index, see http://gni.globalnames.org
}
\details{
Note that you can use fuzzy searching, e.g., by attaching an
asterisk to the end of a search term. See the first two examples below
}
\examples{
\dontrun{
gni_search(sci = "ani*")
gni_search(sci = "ama*", per_page = 3, page = 21)
gni_search(sci = "animalia", per_page = 8, page = 1)
gni_search(sci = "animalia", per_page = 8, page = 1, justtotal=TRUE)

gni_search(sci = "Cyanistes caeruleus", parse_names=TRUE)

# pass on curl options
gni_search(sci = "ani*", verbose = TRUE)
}
}
\references{
http://gni.globalnames.org/
https://github.com/dimus/gni/wiki/api
}
\seealso{
\code{\link[=gnr_datasources]{gnr_datasources()}}, \code{\link[=gni_search]{gni_search()}}
}
\author{
Scott Chamberlain
}
\keyword{globalnamesindex}
\keyword{names}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pow_search.R
\name{pow_lookup}
\alias{pow_lookup}
\title{Lookup taxa in Kew's Plants of the World}
\usage{
pow_lookup(id, include = NULL, ...)
}
\arguments{
\item{id}{(character) taxon id. required}

\item{include}{(character) vector of additional fields to include in
results. options include 'distribution' and 'descriptions'. optional}

\item{...}{Further args passed on to \link[crul:HttpClient]{crul::HttpClient}.}
}
\description{
Lookup taxa in Kew's Plants of the World
}
\examples{
\dontrun{
pow_lookup(id = 'urn:lsid:ipni.org:names:320035-2')
pow_lookup(id = 'urn:lsid:ipni.org:names:320035-2',
  include = "distribution")
pow_lookup(id = 'urn:lsid:ipni.org:names:320035-2',
  include = c("distribution", "descriptions"))
}
}
\seealso{
Other pow: 
\code{\link{get_pow}()},
\code{\link{pow_search}()},
\code{\link{pow_synonyms}()}
}
\concept{pow}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/phylomatic_format.R
\name{phylomatic_format}
\alias{phylomatic_format}
\title{Get family names to make Phylomatic input object, and output input string
to Phylomatic for use in the function phylomatic_tree.}
\usage{
phylomatic_format(...)
}
\arguments{
\item{...}{Parameters, ignored}
}
\description{
THIS FUNCTION IS DEFUNCT.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classification.R
\name{classification}
\alias{classification}
\alias{classification.default}
\alias{classification.tsn}
\alias{classification.uid}
\alias{classification.eolid}
\alias{classification.tpsid}
\alias{classification.gbifid}
\alias{classification.nbnid}
\alias{classification.tolid}
\alias{classification.wormsid}
\alias{classification.natservid}
\alias{classification.boldid}
\alias{classification.wiki}
\alias{classification.pow}
\alias{classification.ids}
\alias{cbind.classification}
\alias{rbind.classification}
\alias{cbind.classification_ids}
\alias{rbind.classification_ids}
\title{Retrieve the taxonomic hierarchy for a given taxon ID.}
\usage{
classification(...)

\method{classification}{default}(
  sci_id,
  db = NULL,
  callopts = list(),
  return_id = TRUE,
  rows = NA,
  x = NULL,
  ...
)

\method{classification}{tsn}(id, return_id = TRUE, ...)

\method{classification}{uid}(
  id,
  callopts = list(),
  return_id = TRUE,
  batch_size = 50,
  max_tries = 3,
  ...
)

\method{classification}{eolid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{tpsid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{gbifid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{nbnid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{tolid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{wormsid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{natservid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{boldid}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{wiki}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{pow}(id, callopts = list(), return_id = TRUE, ...)

\method{classification}{ids}(id, ...)

\method{cbind}{classification}(...)

\method{rbind}{classification}(...)

\method{cbind}{classification_ids}(...)

\method{rbind}{classification_ids}(...)
}
\arguments{
\item{...}{For \code{classification}: other arguments passed to \code{\link[=get_tsn]{get_tsn()}},
\code{\link[=get_uid]{get_uid()}}, \code{\link[=get_eolid]{get_eolid()}}, \code{\link[=get_tpsid]{get_tpsid()}}, \code{\link[=get_gbifid]{get_gbifid()}},
\code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_natservid]{get_natservid()}}, \code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_wiki]{get_wiki()}},
\code{\link[=get_pow]{get_pow()}}. For \code{rbind.classification} and \code{cbind.classification}: one or
more objects of class \code{classification}}

\item{sci_id}{Vector of taxa names (character) or IDs (character or numeric)
to query. For \code{db = "eol"}, EOL expects you to pass it a taxon id, called
\code{eolid} in the output of \code{\link[=get_eolid]{get_eolid()}}.}

\item{db}{character; database to query. either \code{ncbi}, \code{itis}, \code{eol},
\code{tropicos}, \code{gbif}, \code{nbn}, \code{worms}, \code{natserv}, \code{bold}, \code{wiki}, or \code{pow}.
Note that each taxonomic data source has, their own identifiers, so that
if you provide the wrong \code{db} value for the identifier you could get a
result, but it will likely be wrong (not what you were expecting). If using
ncbi, and/or tropicos, we recommend getting an API key; see
\link{taxize-authentication}}

\item{callopts}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}

\item{return_id}{(logical) If \code{TRUE} (default), return the taxon id
as well as the name and rank of taxa in the lineage returned.
Ignored for natserv as they don't return IDs in their taxonomic
classification data.}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA,
all rows are considered. Note that this parameter is ignored if you pass
in a taxonomic id instead of a name of class character.}

\item{x}{Deprecated, see \code{sci_id}}

\item{id}{character; identifiers, returned by \code{\link[=get_tsn]{get_tsn()}}, \code{\link[=get_uid]{get_uid()}},
\code{\link[=get_eolid]{get_eolid()}}, \code{\link[=get_tpsid]{get_tpsid()}}, \code{\link[=get_gbifid]{get_gbifid()}}, \code{\link[=get_tolid]{get_tolid()}},
\code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_natservid]{get_natservid()}}, \code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_wiki]{get_wiki()}},
\code{\link[=get_pow]{get_pow()}}}

\item{batch_size}{(numeric) For NCBI queries, specify the number of IDs to
lookup for each query.}

\item{max_tries}{(numeric) For NCBI queries, the number of times a particular
query will be attempted, assuming the first does not work.}
}
\value{
A named list of data.frames with the taxonomic classification of
every supplied taxa.
}
\description{
Retrieve the taxonomic hierarchy for a given taxon ID.
}
\details{
If IDs are supplied directly (not from the \verb{get_*} functions)
you must specify the type of ID. There is a timeout of 1/3 seconds between
queries to NCBI.

BEWARE: Right now, NBN doesn't return the queried taxon in the
classification. But you can attach it yourself quite easily of course.
This behavior is different from the other data sources.
}
\section{Lots of results}{

It may happen sometimes that you get more results back from your query
than will show in the data.frame on screen. Our advice is to refine your
query in those cases. On a data source basis we can attempt to help
make it easier to refine queries, whether it be with the data provider
(unlikely to happen), or in the code in this package (more likely) -
let us know if you run into too many results problem and we'll see what
we can do.
}

\section{Authentication}{

See \link{taxize-authentication}
}

\section{EOL}{

EOL does not have very good failure behavior. For example, if you submit
an ID that does not exist they'll return a 500 HTTP error, which is
not an appropriate error; it's probably that that ID does not exist
in their database, but we can't know for sure. Isn't that fun?
}

\section{NCBI Rate limits}{

In case you run into NCBI errors due to your rate limit being exceeded, see
\code{\link[=taxize_options]{taxize_options()}}, where you can set \code{ncbi_sleep}.
}

\section{HTTP version for NCBI requests}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\examples{
\dontrun{
# Plug in taxon IDs
classification(9606, db = 'ncbi')
classification(c(9606, 55062), db = 'ncbi')
classification(129313, db = 'itis')
classification(6985636, db = 'eol')
classification(126436, db = 'worms')
classification('Helianthus annuus', db = 'pow')
classification('Helianthus', db = 'pow')
classification('Asteraceae', db = 'pow')
classification("134717", db = 'natserv')
classification(c(2704179, 6162875, 8286319, 2441175, 731), db = 'gbif')
classification(25509881, db = 'tropicos')
classification("NBNSYS0000004786", db = 'nbn')
classification(as.nbnid("NBNSYS0000004786"), db = 'nbn')
classification(3930798, db = 'tol')

## works the same if IDs are in class character
classification(c("2704179", "2441176"), db = 'gbif')
classification("Agapostemon", db = "bold")

# wikispecies
classification("Malus domestica", db = "wiki")
classification("Pinus contorta", db = "wiki")
classification("Pinus contorta", db = "wiki", wiki_site = "commons")
classification("Pinus contorta", db = "wiki", wiki_site = "pedia")
classification("Pinus contorta", db = "wiki", wiki_site = "pedia",
  wiki = "fr")

classification(get_wiki("Malus domestica", "commons"))
classification(get_wiki("Malus domestica", "species"))
classification(c("Pinus contorta", "Malus domestica"), db = "wiki")

# Plug in taxon names
## in this case, we use get_*() fxns internally to first get taxon IDs
classification("Oncorhynchus mykiss", db = "eol")
classification(c("Chironomus riparius", "aaa vva"), db = 'ncbi')
classification(c("Chironomus riparius", "aaa vva"), db = 'ncbi',
  messages=FALSE)
classification(c("Chironomus riparius", "aaa vva"), db = 'itis')
classification(c("Chironomus riparius", "aaa vva"), db = 'itis',
  messages=FALSE)
classification(c("Chironomus riparius", "aaa vva"), db = 'eol')
classification("Alopias vulpinus", db = 'nbn')
classification('Gadus morhua', db = 'worms')
classification('Aquila chrysaetos', db = 'natserv')
classification('Gadus morhua', db = 'natserv')
classification('Pomatomus saltatrix', db = 'natserv')
classification('Aquila chrysaetos', db = 'natserv')
classification(c("Chironomus riparius", "asdfasdfsfdfsd"), db = 'gbif')
classification("Chironomus", db = 'tol')
classification("Poa annua", db = 'tropicos')

# Use methods for get_uid, get_tsn, get_eolid, get_tpsid
classification(get_uid(c("Chironomus riparius", "Puma concolor")))

classification(get_uid(c("Chironomus riparius", "aaa vva")))
classification(get_tsn(c("Chironomus riparius", "aaa vva")))
classification(get_tsn(c("Chironomus riparius", "aaa vva"),
  messages = FALSE))
classification(get_eolid(c("Chironomus riparius", "aaa vva")))
classification(get_tpsid(c("Poa annua", "aaa vva")))
classification(get_gbifid(c("Poa annua", "Bison bison")))

# Pass many ids from class "ids"
(out <- get_ids("Puma concolor", db = c('ncbi','gbif')))
(cl <- classification(out))

# Bind width-wise from class classification_ids
cbind(cl)

# Bind length-wise
rbind(cl)

# Many names to get_ids
(out <- get_ids(c("Puma concolor","Accipiter striatus"),
  db = c('ncbi','itis')))
(cl <- classification(out))
rbind(cl)
## cbind with so many names results in some messy data
cbind(cl)
## so you can turn off return_id
cbind( classification(out, return_id=FALSE) )

(cl_uid <- classification(get_uid(c("Puma concolor",
  "Accipiter striatus")), return_id=FALSE))
rbind(cl_uid)
cbind(cl_uid)
## cbind works a bit odd when there are lots of ranks without names
(cl_uid <- classification(get_uid(c("Puma concolor","Accipiter striatus")),
  return_id=TRUE))
cbind(cl_uid)

(cl_tsn <- classification(get_tsn(c("Puma concolor","Accipiter striatus"))))
rbind(cl_tsn)
cbind(cl_tsn)

(tsns <- get_tsn(c("Puma concolor","Accipiter striatus")))
(cl_tsns <- classification(tsns))
cbind(cl_tsns)

# NBN data
(res <- classification(c("Alopias vulpinus","Pinus sylvestris"),
  db = 'nbn'))
rbind(res)
cbind(res)

# Return taxonomic IDs
## the return_id parameter is logical, and you can turn it on or off.
## It's TRUE by default
classification(c("Alopias vulpinus","Pinus sylvestris"), db = 'ncbi',
  return_id = TRUE)
classification(c("Alopias vulpinus","Pinus sylvestris"), db = 'ncbi',
  return_id = FALSE)

# Use rows parameter to select certain
classification('Poa annua', db = 'tropicos')
classification('Poa annua', db = 'tropicos', rows=1:4)
classification('Poa annua', db = 'tropicos', rows=1)
classification('Poa annua', db = 'tropicos', rows=6)

# Queries of many IDs are processed in batches for NCBI
ids <- c("13083", "2650392", "1547764", "230054", "353934", "656984", 
"271789", "126272", "184644", "73213", "662816", "1161803", "1239353", 
"59420", "665675", "866969", "1091219", "1431218", "1471898", 
"864321", "251768", "2486276", "2068772", "1825808", "2006532", 
"128287", "1195738", "1084683", "1886461", "508296", "377247", 
"1489665", "329325", "219243", "1176946", "339893", "197933", 
"174510", "1704048", "212897", "154842", "1239280", "260135", 
"405735", "1566412", "2083462", "651348", "983204", "165380", 
"2338856", "2068760", "167262", "34229", "1213340", "478939", 
"1933585", "49951", "1277794", "1671089", "1502538", "362355", 
"746473", "242879", "158219", "313664", "2093188", "1541232", 
"584742", "1331091", "147639", "284492", "75642", "1412882", 
"391782", "1406855", "434506", "2053357", "217315", "1444328", 
"329249", "2294004", "84942", "324458", "538247", "69452", "49170", 
"1993845", "261646", "127633", "228146", "1420004", "1629772", 
"577055", "697062", "231660", "648380", "554953", "746496", "2602969")
result <- classification(ids, db = 'ncbi')
}

\dontrun{
# Fails without db param set
# classification(315576)
}
}
\seealso{
\code{\link[=get_tsn]{get_tsn()}}, \code{\link[=get_uid]{get_uid()}}, \code{\link[=get_eolid]{get_eolid()}},
\code{\link[=get_tpsid]{get_tpsid()}}, \code{\link[=get_gbifid]{get_gbifid()}}, \code{\link[=get_wormsid]{get_wormsid()}}, \code{\link[=get_natservid]{get_natservid()}},
\code{\link[=get_boldid]{get_boldid()}}, \code{\link[=get_wiki]{get_wiki()}}, \code{\link[=get_pow]{get_pow()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_nbnid.R
\name{get_nbnid}
\alias{get_nbnid}
\alias{as.nbnid}
\alias{as.nbnid.nbnid}
\alias{as.nbnid.character}
\alias{as.nbnid.list}
\alias{as.nbnid.data.frame}
\alias{as.data.frame.nbnid}
\alias{get_nbnid_}
\title{Get the UK National Biodiversity Network ID from taxonomic names.}
\usage{
get_nbnid(
  sci_com,
  ask = TRUE,
  messages = TRUE,
  rec_only = FALSE,
  rank = NULL,
  rows = NA,
  name = NULL,
  ...
)

as.nbnid(x, check = TRUE)

\method{as.nbnid}{nbnid}(x, check = TRUE)

\method{as.nbnid}{character}(x, check = TRUE)

\method{as.nbnid}{list}(x, check = TRUE)

\method{as.nbnid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{nbnid}(x, ...)

get_nbnid_(
  sci_com,
  messages = TRUE,
  rec_only = FALSE,
  rank = NULL,
  rows = NA,
  name = NULL,
  ...
)
}
\arguments{
\item{sci_com}{character; a vector of common or scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{ask}{logical; should get_nbnid be run in interactive mode?
If TRUE and more than one ID is found for the species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; If TRUE the actual taxon queried is printed on the
console.}

\item{rec_only}{(logical) If \code{TRUE} ids of recommended names are
returned (i.e. synonyms are removed). Defaults to \code{FALSE}. Remember,
the id of a synonym is a taxa with 'recommended' name status.}

\item{rank}{(character) If given, we attempt to limit the results to those
taxa with the matching rank.}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all
rows are considered. Note that this function still only gives back a nbnid
class object with one to many identifiers. See
\code{\link[=get_nbnid_]{get_nbnid_()}} to get back all, or a subset, of the raw
data that you are presented during the ask process.}

\item{name}{Deprecated, see \code{sci_com}}

\item{...}{Further args passed on to \code{nbn_search}}

\item{x}{Input to \code{\link[=as.nbnid]{as.nbnid()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.nbnid]{as.nbnid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions

an object of class nbnid, a light wrapper around a character
string that is the taxonomic ID - includes attributes with relavant
metadata
}
\description{
Get the UK National Biodiversity Network ID from taxonomic names.
}
\examples{
\dontrun{
get_nbnid(sci_com='Poa annua')
get_nbnid(sci_com='Poa annua', rec_only=TRUE)
get_nbnid(sci_com='Poa annua', rank='Species')
get_nbnid(sci_com='Poa annua', rec_only=TRUE, rank='Species')
get_nbnid(sci_com='Pinus contorta')

# The NBN service handles common names too
get_nbnid(sci_com='red-winged blackbird')

# specify rows to limit choices available
get_nbnid('Poa ann')
get_nbnid('Poa ann', rows=1)
get_nbnid('Poa ann', rows=25)
get_nbnid('Poa ann', rows=1:2)

# When not found
get_nbnid(sci_com="uaudnadndj")
get_nbnid(c("Zootoca vivipara", "uaudnadndj"))
get_nbnid(c("Zootoca vivipara","Chironomus riparius", "uaudnadndj"))

# Convert an nbnid without class information to a nbnid class
as.nbnid(get_nbnid("Zootoca vivipara")) # already a nbnid, returns the same
as.nbnid(get_nbnid(c("Zootoca vivipara","Pinus contorta"))) # same
as.nbnid('NHMSYS0001706186') # character
# character vector, length > 1
as.nbnid(c("NHMSYS0001706186","NHMSYS0000494848","NBNSYS0000010867"))
# list
as.nbnid(list("NHMSYS0001706186","NHMSYS0000494848","NBNSYS0000010867"))
## dont check, much faster
as.nbnid('NHMSYS0001706186', check=FALSE)
as.nbnid(list("NHMSYS0001706186","NHMSYS0000494848","NBNSYS0000010867"),
  check=FALSE)

(out <- as.nbnid(c("NHMSYS0001706186","NHMSYS0000494848",
  "NBNSYS0000010867")))
data.frame(out)
as.nbnid( data.frame(out) )

# Get all data back
get_nbnid_("Zootoca vivipara")
get_nbnid_("Poa annua", rows=2)
get_nbnid_("Poa annua", rows=1:2)
get_nbnid_(c("asdfadfasd","Pinus contorta"), rows=1:5)

# use curl options
invisible(get_nbnid("Quercus douglasii", verbose = TRUE))
}
}
\references{
https://api.nbnatlas.org/
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}

Other nbn: 
\code{\link{nbn_classification}()},
\code{\link{nbn_search}()},
\code{\link{nbn_synonyms}()}
}
\author{
Scott Chamberlain,
}
\concept{nbn}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{rank_ref}
\alias{rank_ref}
\title{Lookup-table for IDs of taxonomic ranks}
\description{
data.frame of 46 rows, with 2 columns:
\itemize{
\item rankid - a numeric rank id, consecutive
\item ranks - a comma separated vector of names that are considered
equal to one another within the row
}
}
\details{
We use this data.frame to do data sorting/filtering based on the ordering
of ranks.

Please let us know if there is a rank that occurs from one of the data
sources \pkg{taxize} that we don't have in \code{rank_ref} dataset.

Let us know if you disagree with the ordering of ranks.

Note that \code{rankid} 280 are essentially "genetic variants"; placed just above
'unspecified' to denote they're not without rank, but they're not
really taxonomic ranks either. As far as I know there's no way
to delineate among these "genetic variant" types.
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_native.R
\name{itis_native}
\alias{itis_native}
\title{Get jurisdiction data, i.e., native or not native in a region.}
\usage{
itis_native(tsn = NULL, what = "bytsn", ...)
}
\arguments{
\item{tsn}{One or more TSN's (taxonomic serial number)}

\item{what}{One of bytsn, values, or originvalues}

\item{...}{Further arguments passed on to
\code{\link[ritis:jurisdiction]{ritis::jurisdictional_origin()}},
\code{\link[ritis:jurisdiction]{ritis::jurisdiction_values()}}, or
\code{\link[ritis:jurisdiction]{ritis::jurisdiction_origin_values()}}}
}
\description{
Get jurisdiction data, i.e., native or not native in a region.
}
\examples{
\dontrun{
# Get values
itis_native(what="values")

# Get origin values
itis_native(what="originvalues")

# Get values by tsn
itis_native(tsn=180543)
itis_native(tsn=c(180543,41074,36616))
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_get_taxon_summary.R
\name{ncbi_get_taxon_summary}
\alias{ncbi_get_taxon_summary}
\title{NCBI taxon information from uids}
\usage{
ncbi_get_taxon_summary(id, key = NULL, ...)
}
\arguments{
\item{id}{(character) NCBI taxonomy uids to retrieve information for.
See Details.}

\item{key}{(character) NCBI Entrez API key. optional. See Details.}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A \code{data.frame} with the following columns:
\itemize{
\item \code{uid} The uid queried for
\item \code{name} The name of the taxon; a binomial name if the taxon is of rank species
\item \code{rank} The taxonomic rank (e.g. 'Genus')
}
}
\description{
Downloads summary taxon information from the NCBI taxonomy
databases for a set of taxonomy UIDs using eutils esummary.
}
\details{
If your input vector or list of NCBI IDs is longer than about
2500 characters (use \code{nchar(paste(ids, collapse = "+"))}), split
the list up into chunks since at about that number of characters you
will run into the HTTP 414 error "Request-URI Too Long".
}
\section{HTTP version}{

We hard code \code{http_version = 2L} to use HTTP/1.1 in HTTP requests to
the Entrez API. See \code{curl::curl_symbols('CURL_HTTP_VERSION')}
}

\section{Authentication}{

See \link{taxize-authentication} for help on authentication.
We strongly recommend getting an API key
}

\examples{
\dontrun{
ncbi_get_taxon_summary(c(1430660, 4751))

# use curl options
ncbi_get_taxon_summary(c(1430660, 4751), verbose = TRUE)
}
}
\author{
Zachary Foster \email{zacharyfoster1989@Sgmail.com}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nbn_synonyms.R
\name{nbn_synonyms}
\alias{nbn_synonyms}
\title{Return all synonyms for a taxon name with a given id from NBN}
\usage{
nbn_synonyms(id, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{...}{Further args passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame
}
\description{
Return all synonyms for a taxon name with a given id from NBN
}
\examples{
\dontrun{
nbn_synonyms(id = 'NHMSYS0001501147')
nbn_synonyms(id = 'NHMSYS0000456036')

# none
nbn_synonyms(id = 'NHMSYS0000502940')
}
}
\references{
https://api.nbnatlas.org/
}
\seealso{
Other nbn: 
\code{\link{get_nbnid}()},
\code{\link{nbn_classification}()},
\code{\link{nbn_search}()}
}
\concept{nbn}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eol_pages.R
\name{eol_pages}
\alias{eol_pages}
\title{Search for pages in EOL database using a taxonconceptID.}
\usage{
eol_pages(
  taxonconceptID,
  images_per_page = NULL,
  images_page = NULL,
  videos_per_page = NULL,
  videos_page = NULL,
  sounds_per_page = NULL,
  sounds_page = NULL,
  maps_per_page = NULL,
  maps_page = NULL,
  texts_per_page = NULL,
  texts_page = NULL,
  subjects = "overview",
  licenses = "all",
  details = FALSE,
  common_names = FALSE,
  synonyms = FALSE,
  references = FALSE,
  taxonomy = TRUE,
  vetted = 0,
  cache_ttl = NULL,
  ...
)
}
\arguments{
\item{taxonconceptID}{(numeric) a taxonconceptID, which is also the page
number}

\item{images_per_page}{(integer) number of returned image objects (0-75)}

\item{images_page}{(integer) images page}

\item{videos_per_page}{(integer) number of returned video objects (0-75)}

\item{videos_page}{(integer) videos page}

\item{sounds_per_page}{(integer) number of returned sound objects (0-75)}

\item{sounds_page}{(integer) sounds page}

\item{maps_per_page}{(integer) number of returned map objects (0-75)}

\item{maps_page}{(integer) maps page}

\item{texts_per_page}{(integer) number of returned text objects (0-75)}

\item{texts_page}{(integer) texts page}

\item{subjects}{'overview' (default) to return the overview text
(if exists), a pipe | delimited list of subject names from the list of EOL
accepted subjects (e.g. TaxonBiology, FossilHistory), or 'all' to get text
in any subject. Always returns an overview text as a first result (if one
exists in the given context).}

\item{licenses}{A pipe | delimited list of licenses or 'all' (default) to
get objects under any license. Licenses abbreviated cc- are all Creative
Commons licenses. Visit their site for more information on the various
licenses they offer.}

\item{details}{Include all metadata for data objects. (Default: \code{FALSE})}

\item{common_names}{Return all common names for the page's taxon
(Default: \code{FALSE})}

\item{synonyms}{Return all synonyms for the page's taxon
(Default: \code{FALSE})}

\item{references}{Return all references for the page's taxon
(Default: \code{FALSE})}

\item{taxonomy}{(logical) Whether to return any taxonomy details from
different taxon hierarchy providers, in an array named \code{taxonconcepts}
(Default: \code{TRUE})}

\item{vetted}{If 'vetted' is given a value of '1', then only trusted
content will be returned. If 'vetted' is '2', then only trusted and
unreviewed content will be returned (untrusted content will not be returned).
The default is to return all content. (Default: \code{FALSE})}

\item{cache_ttl}{The number of seconds you wish to have the response cached.}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
JSON list object, or data.frame.
}
\description{
Search for pages in EOL database using a taxonconceptID.
}
\details{
It's possible to return JSON or XML with the EOL API. However,
this function only returns JSON for now.
}
\examples{
\dontrun{
(pageid <- eol_search('Pomatomus')$pageid[1])
x <- eol_pages(taxonconceptID = pageid)
x
x$scinames

z <- eol_pages(taxonconceptID = pageid, synonyms = TRUE)
z$synonyms

z <- eol_pages(taxonconceptID = pageid, common_names = TRUE)
z$vernacular
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tpl_search.r
\name{tpl_search}
\alias{tpl_search}
\title{A light wrapper around the taxonstand fxn to call Theplantlist.org database.}
\usage{
tpl_search()
}
\description{
THIS FUNCTION IS DEFUNCT.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apg_lookup.R
\name{apg_lookup}
\alias{apg_lookup}
\title{Lookup in the APGIII taxonomy and replace family names}
\usage{
apg_lookup(taxa, rank = "family")
}
\arguments{
\item{taxa}{(character) Taxonomic name to lookup a synonym for
in APGIII taxonomy.}

\item{rank}{(character) Taxonomic rank to lookup a synonym for. One of
family or order.}
}
\value{
A APGIII family or order name, the original name if the name
is the same as APG has, or NA if no match found
}
\description{
Lookup in the APGIII taxonomy and replace family names
}
\details{
Internally in this function, we use the datasets \link{apg_families}
and \link{apg_orders} - see their descriptions for the data in them.
The functions \code{\link[=apgOrders]{apgOrders()}} \code{\link[=apgFamilies]{apgFamilies()}} are for scraping
current content from the http://www.mobot.org/MOBOT/research/APweb/
website

The datasets used in this function are from the most recent version of
APGIII, Version 14 (http://www.mobot.org/MOBOT/research/APweb/)
}
\examples{
# New name found
apg_lookup(taxa = "Hyacinthaceae", rank = "family")
# Name is the same
apg_lookup(taxa = "Poaceae", rank = "family")
apg_lookup(taxa = "Asteraceae", rank = "family")
# Name not found
apg_lookup(taxa = "Foobar", rank = "family")

# New name found
apg_lookup(taxa = "Acerales", rank = "order")
# Name is the same
apg_lookup(taxa = "Acorales", rank = "order")
# Name not found
apg_lookup(taxa = "Foobar", rank = "order")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{apg_families}
\alias{apg_families}
\title{MOBOT family names}
\format{
A data frame with 1705 rows and 6 variables:
\itemize{
\item \code{family}: family name
\item \code{synonym}: if \code{accepted=FALSE}, this is the accepted name;
if \code{accepted=TRUE}, this is \code{NA}, and the name in \code{family} is accepted
\item \code{order}: order name for the family
\item \code{accepted}: logical, if name in \code{family} column is accepted or not
\item \code{original}: original data record from APG website, mapping
name in \code{family} column to a new name, if there is one
\item \code{accepted_name}: accepted name. accepted names, combining those that
are accepted from \code{family} column, with the new name from \code{synonym}
if applicable
}
}
\source{
http://www.mobot.org/MOBOT/research/APweb/
}
\description{
Family names and their replacements from the Angiosperm Phylogeny
Website system of flowering plant classification.
}
\details{
This dataset is from Version 14, incorporated on 2020-06-03,
generated using \code{\link[=apgFamilies]{apgFamilies()}}

(update script in inst/ignore/apg_script.R)
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rankagg.R
\name{rankagg}
\alias{rankagg}
\title{Aggregate data by given taxonomic rank}
\usage{
rankagg(data = NULL, datacol = NULL, rank = NULL, fxn = "sum")
}
\arguments{
\item{data}{A data.frame. Column headers must have capitalized ranks (e.g.,
Genus, Tribe, etc.) (data.frame)}

\item{datacol}{The data column (character)}

\item{rank}{Taxonomic rank to aggregate by (character)}

\item{fxn}{Arithmetic function or vector or functions (character)}
}
\description{
Aggregate data by given taxonomic rank
}
\examples{
if (require(vegan)) {
data(dune.taxon, dune, package='vegan')
dat <- dune.taxon
dat$abundance <- colSums(dune)
rankagg(data=dat, datacol="abundance", rank="Genus")
rankagg(data=dat, "abundance", rank="Family")
rankagg(data=dat, "abundance", rank="Genus", fxn="mean")
rankagg(data=dat, "abundance", rank="Subclass")
rankagg(data=dat, "abundance", rank="Subclass", fxn="sd")
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/worms_downstream.R
\name{worms_downstream}
\alias{worms_downstream}
\title{Retrieve all taxa names downstream in hierarchy for WORMS}
\usage{
worms_downstream(id, downto, intermediate = FALSE, start = 1, ...)
}
\arguments{
\item{id}{(integer) One or more AphiaID's}

\item{downto}{(character) The taxonomic level you want to go down to.
See examples below. The taxonomic level IS case sensitive, and you do have
to spell it correctly. See \link{rank_ref_zoo} for spelling.}

\item{intermediate}{(logical) If \code{TRUE}, return a list of length two
with target taxon rank names, with additional list of data.frame's of
intermediate taxonomic groups. Default: \code{FALSE}}

\item{start}{(integer) Record number to start at}

\item{...}{crul options passed on to \code{\link[worrms:wm_children]{worrms::wm_children()}}, including the
parameters \code{marine_only} and \code{offset}, see \code{?worrms::wm_children} for
details}
}
\value{
data.frame of taxonomic information downstream to family from e.g.,
Order, Class, etc., or if \code{intermediated=TRUE}, list of length two,
with target taxon rank names, and intermediate names.
}
\description{
Retrieve all taxa names downstream in hierarchy for WORMS
}
\examples{
\dontrun{
## the genus Gadus
worms_downstream(id = 125732, downto="species")
worms_downstream(id = 125732, downto="species", intermediate=TRUE)

worms_downstream(id = 51, downto="class")
worms_downstream(id = 51, downto="subclass", intermediate=TRUE)

worms_downstream(id = 105, downto="subclass")

# marine_only parameter
worms_downstream(545470, downto = "species")
worms_downstream(545470, downto = "species", marine_only = FALSE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/col.R
\name{col-defunct}
\alias{col-defunct}
\alias{as.colid}
\alias{col_children}
\alias{col_classification}
\alias{col_downstream}
\alias{col_search}
\alias{get_colid}
\alias{get_colid_}
\title{COL defunct functions}
\usage{
as.colid(...)

col_children(...)

col_classification(...)

col_downstream(...)

col_search(...)

get_colid(...)

get_colid_(...)
}
\arguments{
\item{...}{ignored}
}
\description{
COL introduced rate limiting recently in 2019 - which has made the API
essentially unusable - COL+ is coming soon and we'll incorporate it here
when it's stable
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_dist.R
\name{tp_namedistributions}
\alias{tp_namedistributions}
\title{Return all distribution records for for a taxon name with a given id.}
\usage{
tp_namedistributions(...)
}
\arguments{
\item{...}{ignored}
}
\description{
Function name changed to tp_dist.
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eubon_children.R
\name{eubon_children}
\alias{eubon_children}
\title{EUBON children}
\usage{
eubon_children(id, providers = NULL, timeout = 0, ...)
}
\arguments{
\item{id}{(character) identifier for the taxon. (LSID, DOI, URI, or any
other identifier used by the checklist provider)}

\item{providers}{(character) A list of provider id strings concatenated by
comma characters. The default : "pesi,bgbm-cdm-server[col] will
be used if this parameter is not set. A list of all available provider ids
can be obtained from the '/capabilities' service end point. Providers can be
nested, that is a parent provider can have sub providers. If the id of the
parent provider is supplied all subproviders will be queried. The query
can also be restricted to one or more subproviders by using the following
syntax: parent-id[sub-id-1,sub-id2,...]}

\item{timeout}{(numeric) The maximum of milliseconds to wait for responses
from any of the providers. If the timeout is exceeded the service will just
return the responses that have been received so far. The default timeout is
0 ms (wait for ever)}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
a data.frame or an empty list if no results found
}
\description{
EUBON children
}
\note{
There is no pagination in this method, so you may or may not be
getting all the results for a search. Sorry, out of our control
}
\examples{
\dontrun{
x <- eubon_children(id = "urn:lsid:marinespecies.org:taxname:126141",
  providers = 'worms')
head(x)
}
}
\references{
https://cybertaxonomy.eu/eu-bon/utis/1.3/doc.html
}
\seealso{
Other eubon-methods: 
\code{\link{eubon_capabilities}()},
\code{\link{eubon_hierarchy}()},
\code{\link{eubon_search}()}
}
\concept{eubon-methods}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncbi_downstream.R
\name{ncbi_downstream}
\alias{ncbi_downstream}
\title{Retrieve all taxa names downstream in hierarchy for NCBI}
\usage{
ncbi_downstream(id, downto, intermediate = FALSE, ...)
}
\arguments{
\item{id}{(numeric/integer) An NCBI taxonomic identifier}

\item{downto}{The taxonomic level you want to go down to. See examples below.
The taxonomic level IS case sensitive, and you do have to spell it
correctly. See \code{data(rank_ref)} for spelling.}

\item{intermediate}{(logical) If \code{TRUE}, return a list of length two
with target taxon rank names, with additional list of data.frame's of
intermediate taxonomic groups. Default: \code{FALSE}}

\item{...}{Further args passed on to \code{\link[=ncbi_children]{ncbi_children()}}}
}
\value{
Data.frame of taxonomic information downstream to family from e.g.,
Order, Class, etc., or if \code{intermediate=TRUE}, list of length two,
with target taxon rank names, and intermediate names.
}
\description{
Retrieve all taxa names downstream in hierarchy for NCBI
}
\section{No Rank}{

A sticky point with NCBI is that they can have designation for taxonomic
rank of "No Rank". So we have no way of programatically knowing what to
do with that taxon. Of course one can manually look at a name and perhaps
know what it is, or look it up on the web - but we can't do anything
programatically. So, no rank things will sometimes be missing.
}

\section{Authentication}{

See \code{\link[=taxize-authentication]{taxize-authentication()}} for help on authentication.
We strongly recommend getting an API key
}

\examples{
\dontrun{
## genus Apis
ncbi_downstream(id = 7459, downto="species")

## get intermediate taxa as a separate object
ncbi_downstream(id = 7459, downto="species", intermediate = TRUE)

## Lepidoptera
ncbi_downstream(id = 7088, downto="superfamily")

## families in the ferns (Moniliformopses)
(id <- get_uid("Moniliformopses"))
ncbi_downstream(id = id, downto = "order")
}
}
\author{
Scott Chamberlain
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bold_downstream.R
\name{bold_downstream}
\alias{bold_downstream}
\title{Retrieve all taxa names downstream in hierarchy for BOLD}
\usage{
bold_downstream(id, downto, intermediate = FALSE, ...)
}
\arguments{
\item{id}{(integer) One or more BOLD taxonomic identifiers}

\item{downto}{(character) The taxonomic level you want to go down to.
See examples below. The taxonomic level IS case sensitive, and you do have
to spell it correctly. See \code{data(rank_ref)} for spelling.}

\item{intermediate}{(logical) If \code{TRUE}, return a list of length two
with target taxon rank names, with additional list of data.frame's of
intermediate taxonomic groups. Default: \code{FALSE}}

\item{...}{crul options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
data.frame of taxonomic information downstream to family from e.g.,
Order, Class, etc., or if \code{intermediated=TRUE}, list of length two,
with target taxon rank names, and intermediate names.
}
\description{
Retrieve all taxa names downstream in hierarchy for BOLD
}
\details{
BEWARE: This function scrapes the BOLD website, so may be unstable. That is,
one day it may work, and the next it may fail. Open an issue if you
encounter an error: https://github.com/ropensci/taxize/issues
}
\examples{
\dontrun{
## the genus Gadus
bold_downstream(id = 3451, downto="species")

bold_downstream(id = 443, downto="genus")
bold_downstream(id = 443, downto="genus", intermediate=TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_ids.R
\name{get_ids}
\alias{get_ids}
\alias{get_ids_}
\title{Retrieve taxonomic identifiers for a given taxon name.}
\usage{
get_ids(
  sci_com,
  db = c("itis", "ncbi", "eol", "tropicos", "gbif", "nbn", "pow"),
  suppress = FALSE,
  names = NULL,
  ...
)

get_ids_(
  sci_com,
  db = get_ids_dbs,
  rows = NA,
  suppress = FALSE,
  names = NULL,
  ...
)
}
\arguments{
\item{sci_com}{(character) Taxonomic name to query.}

\item{db}{(character) database to query. One or more of \code{ncbi}, \code{itis}, \code{eol},
\code{tropicos}, \code{gbif}, \code{nbn}, or \code{pow}. By default db is set to search
all data sources. Note that each taxonomic data source has their own
identifiers, so that if you give the wrong \code{db} value for the identifier you
could get a result, it will likely be wrong (not what you were expecting).
If using ncbi and/or tropicos we recommend getting API keys;
see \link{taxize-authentication}}

\item{suppress}{(logical) suppress \pkg{cli} separators with the database
name being queried. default: \code{FALSE}}

\item{names}{Deprecated, see \code{sci_com}}

\item{...}{Other arguments passed to \code{\link[=get_tsn]{get_tsn()}}, \code{\link[=get_uid]{get_uid()}},
\code{\link[=get_eolid]{get_eolid()}}, \code{\link[=get_tpsid]{get_tpsid()}}, \code{\link[=get_gbifid]{get_gbifid()}},
\code{\link[=get_nbnid]{get_nbnid()}}.}

\item{rows}{(numeric) Any number from 1 to infinity. If the default NA, all
rows are returned. When used in \code{get_ids} this function still only
gives back a ids class object with one to many identifiers. See
\code{get_ids_} to get back all, or a subset, of the raw data that you
are presented during the ask process.}
}
\value{
A vector of taxonomic identifiers, each retaining their respective
S3 classes so that each element can be passed on to another function
(see e.g.'s).
}
\description{
This is a convenience function to get identifiers across all data sources.
You can use other \verb{get_*} functions to get identifiers from specific
sources if you like.
}
\note{
There is a timeout of 1/3 seconds between queries to NCBI.
}
\section{Authentication}{

See \link{taxize-authentication} for help on authentication
}

\examples{
\dontrun{
# Plug in taxon names directly
# specify rows to limit choices available
get_ids("Poa annua", db="eol", rows=1)
get_ids("Poa annua", db="eol", rows=1:2)

## Or you can specify which source you want via the db parameter
get_ids("Chironomus riparius", db = 'ncbi')
get_ids("Salvelinus fontinalis", db = 'nbn')

get_ids(c("Chironomus riparius", "Pinus contorta"), db = 'ncbi')
get_ids("Pinus contorta", db = c('ncbi','eol','tropicos'))
get_ids("ava avvva", db = c('ncbi','eol','tropicos'))

# Pass on to other functions
out <- get_ids("Pinus contorta", db = c('ncbi','eol','tropicos'))
classification(out$ncbi)

# Get all data back
get_ids_(c("Chironomus riparius", "Pinus contorta"), db = 'nbn',
  rows=1:10)
get_ids_(c("Chironomus riparius", "Pinus contorta"), db = c('nbn','gbif'),
  rows=1:10)

# use curl options
get_ids("Agapostemon", db = "ncbi", verbose = TRUE)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_iucn}()},
\code{\link{get_natservid}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_refs.R
\name{itis_refs}
\alias{itis_refs}
\title{Get references related to a ITIS TSN.}
\usage{
itis_refs(tsn, ...)
}
\arguments{
\item{tsn}{One or more TSN's (taxonomic serial number) for a
taxonomic group (numeric)}

\item{...}{Further arguments passed on to getpublicationsfromtsn}
}
\description{
Get references related to a ITIS TSN.
}
\examples{
\dontrun{
itis_refs(202385)
itis_refs(c(202385, 70340))
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_natservid.R
\name{get_natservid}
\alias{get_natservid}
\alias{as.natservid}
\alias{as.natservid.natservid}
\alias{as.natservid.character}
\alias{as.natservid.list}
\alias{as.natservid.numeric}
\alias{as.natservid.data.frame}
\alias{as.data.frame.natservid}
\alias{get_natservid_}
\title{Get NatureServe taxonomic ID for a taxon name}
\usage{
get_natservid(
  sci_com,
  searchtype = "scientific",
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  query = NULL,
  ...
)

as.natservid(x, check = TRUE)

\method{as.natservid}{natservid}(x, check = TRUE)

\method{as.natservid}{character}(x, check = TRUE)

\method{as.natservid}{list}(x, check = TRUE)

\method{as.natservid}{numeric}(x, check = TRUE)

\method{as.natservid}{data.frame}(x, check = TRUE)

\method{as.data.frame}{natservid}(x, ...)

get_natservid_(
  sci_com,
  searchtype = "scientific",
  messages = TRUE,
  rows = NA,
  query = NULL,
  ...
)
}
\arguments{
\item{sci_com}{character; A vector of common or scientific names. Or, a
\code{taxon_state} object (see \link{taxon-state})}

\item{searchtype}{character; One of 'scientific' (default) or 'common'.
This doesn't affect the query to NatureServe - but rather affects what
column of data is targeted in name filtering post data request.}

\item{ask}{logical; should get_natservid be run in interactive mode?
If \code{TRUE} and more than one wormsid is found for the species, the
user is asked for input. If \code{FALSE} NA is returned for
multiple matches. default: \code{TRUE}}

\item{messages}{logical; should progress be printed? default: \code{TRUE}}

\item{rows}{numeric; Any number from 1 to infinity. If the default NaN, all
rows are considered. Note that this function still only gives back a
natservid class object with one to many identifiers. See
\code{get_natservid_()} to get back all, or a subset, of the raw
data that you are presented during the ask process.}

\item{query}{Deprecated, see \code{sci_com}}

\item{...}{curl options passed on to \link[crul:verb-POST]{crul::verb-POST}}

\item{x}{Input to \code{as.natservid}}

\item{check}{logical; Check if ID matches any existing on the DB, only
used in \code{\link[=as.natservid]{as.natservid()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get NatureServe taxonomic ID for a taxon name
}
\note{
Authentication no longer required
}
\examples{
\dontrun{
(x <- get_natservid("Helianthus annuus", verbose = TRUE))
attributes(x)
attr(x, "match")
attr(x, "multiple_matches")
attr(x, "pattern_match")
attr(x, "uri")

get_natservid('Gadus morhua')
get_natservid(c("Helianthus annuus", 'Gadus morhua'))

# specify rows to limit choices available
get_natservid('Ruby Quaker Moth', 'common')
get_natservid('Ruby*', 'common')
get_natservid('Ruby*', 'common', rows=1)
get_natservid('Ruby*', 'common', rows=1:2)

# When not found
get_natservid("howdy")
get_natservid(c('Gadus morhua', "howdy"))

# Convert a natservid without class information to a natservid class
# already a natservid, returns the same
as.natservid(get_natservid('Pomatomus saltatrix'))
# same
as.natservid(get_natservid(c('Gadus morhua', 'Pomatomus saltatrix')))
# character
as.natservid(101905)
# character vector, length > 1
as.natservid(c(101905, 101998))
# list, either numeric or character
as.natservid(list(101905, 101998))
## dont check, much faster
as.natservid(101905, check = FALSE)
as.natservid(c(101905, 101998), check = FALSE)
as.natservid(list(101905, 101998), check = FALSE)

(out <- as.natservid(c(101905, 101998), check = FALSE))
data.frame(out)
as.natservid( data.frame(out) )

# Get all data back
get_natservid_("Helianthus")
get_natservid_("Ruby*", searchtype = "common")
get_natservid_("Ruby*", searchtype = "common", rows=1:3)
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_boldid}()},
\code{\link{get_eolid}()},
\code{\link{get_gbifid}()},
\code{\link{get_ids}()},
\code{\link{get_iucn}()},
\code{\link{get_nbnid}()},
\code{\link{get_pow}()},
\code{\link{get_tolid}()},
\code{\link{get_tpsid}()},
\code{\link{get_tsn}()},
\code{\link{get_uid}()},
\code{\link{get_wiki}()},
\code{\link{get_wormsid}()}
}
\concept{taxonomic-ids}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class2tree.R
\name{class2tree}
\alias{class2tree}
\alias{plot.classtree}
\alias{print.classtree}
\title{Convert a list of classifications to a tree.}
\usage{
class2tree(input, varstep = TRUE, check = TRUE, ...)

\method{plot}{classtree}(x, ...)

\method{print}{classtree}(x, ...)
}
\arguments{
\item{input}{List of classification data.frame's from the function
\code{\link[=classification]{classification()}}}

\item{varstep}{Vary step lengths between successive levels relative to
proportional loss of the number of distinct classes.}

\item{check}{If TRUE, remove all redundant levels which are different for
all rows or constant for all rows and regard each row as a different basal
taxon (species). If FALSE all levels are retained and basal taxa (species)
also must be coded as variables (columns). You will get a warning if
species are not coded, but you can ignore this if that was your intention.}

\item{...}{Further arguments passed on to hclust.}

\item{x}{Input object to print or plot - output from class2tree function.}
}
\value{
An object of class "classtree" with slots:
\itemize{
\item phylo - The resulting object, a phylo object
\item classification - The classification data.frame, with taxa as rows,
and different classification levels as columns
\item distmat - Distance matrix
\item names - The names of the tips of the phylogeny
}

Note that when you execute the resulting object, you only get the phylo
object. You can get to the other 3 slots by calling them directly, like
output$names, etc.
}
\description{
This function converts a list of hierarchies for individual species into
a single species by taxonomic level matrix, then calculates a distance
matrix based on taxonomy alone, and outputs either a phylo or dist object.
See details for more information.
}
\details{
See \code{\link[vegan:taxondive]{vegan::taxa2dist()}}. Thanks to Jari Oksanen for
making the taxa2dist function and pointing it out, and Clarke & Warwick
(1998, 2001), which taxa2dist was based on.
The taxonomy tree created is not only based on the clustering of the
taxonomy ranks (e.g. strain, species, genus, ...), but it also utilizes the
actual taxon clades (e.g. mammals, plants or reptiles, etc.). The process of
this function is as following: First, all possible taxonomy ranks and their
corresponding IDs for each given taxon will be collected from the input.
Then, the rank vectors of all taxa will be aligned, so that they together
will become a matrix where columns are ordered taxonomy ranks of all taxa and
rows are the rank vectors of those taxa. After that, the rank matrix will be
converted into taxonomy ID matrix, any missing rank will have a pseudo
ID from the previous rank. Finally, this taxonomy ID matrix will be used to
cluster taxa that have similar taxonomy hierarchy together.
}
\examples{
\dontrun{
spnames <- c('Quercus robur', 'Iris oratoria', 'Arachis paraguariensis',
 'Helianthus annuus','Madia elegans','Lupinus albicaulis',
 'Pinus lambertiana')
out <- classification(spnames, db='itis')
tr <- class2tree(out)
plot(tr)

spnames <- c('Klattia flava', 'Trollius sibiricus',
 'Arachis paraguariensis',
 'Tanacetum boreale', 'Gentiana yakushimensis','Sesamum schinzianum',
 'Pilea verrucosa','Tibouchina striphnocalyx','Lycium dasystemum',
 'Berkheya echinacea','Androcymbium villosum',
 'Helianthus annuus','Madia elegans','Lupinus albicaulis',
 'Pinus lambertiana')
out <- classification(spnames, db='ncbi')
tr <- class2tree(out)
plot(tr)
}

}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gni_details.R
\name{gni_details}
\alias{gni_details}
\title{Search for taxonomic name details using the Global Names Index}
\usage{
gni_details(id, all_records = 1, ...)
}
\arguments{
\item{id}{Name id. Required.}

\item{all_records}{If all_records is 1, GNI returns all records from all
repositories for the name string (takes 0, or 1 [default]).}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
Data.frame of results.
}
\description{
Uses the Global Names Index, see http://gni.globalnames.org/
}
\examples{
\dontrun{
gni_details(id = 17802847)

# pass on curl options
gni_details(id = 17802847, verbose = TRUE)
}
}
\seealso{
\code{\link[=gnr_datasources]{gnr_datasources()}}, \code{\link[=gni_search]{gni_search()}}.
}
\author{
Scott Chamberlain
}
\keyword{globalnamesindex}
\keyword{names}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iucn_summary.R
\name{iucn_summary_id}
\alias{iucn_summary_id}
\title{DEFUNCT}
\usage{
iucn_summary_id(...)
}
\description{
DEFUNCT
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{theplantlist}
\alias{theplantlist}
\title{Lookup-table for family, genus, and species names for ThePlantList}
\format{
A data frame with 10,000 rows and 3 variables:
\itemize{
\item \code{family} family name
\item \code{genus} genus name
\item \code{species} specific epithet name
}
}
\source{
http://www.theplantlist.org
}
\description{
These names are from http://www.theplantlist.org, and are from
version 1.1 of their data. This data is used in the function
\code{\link[=names_list]{names_list()}}. This is a randomly selected subset of the ~350K
accepted species names in Theplantlist.
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gnr_resolve.R
\name{gnr_resolve}
\alias{gnr_resolve}
\title{Resolve names using Global Names Resolver}
\usage{
gnr_resolve(
  sci,
  data_source_ids = NULL,
  resolve_once = FALSE,
  with_context = FALSE,
  canonical = FALSE,
  highestscore = TRUE,
  best_match_only = FALSE,
  preferred_data_sources = NULL,
  with_canonical_ranks = FALSE,
  http = "get",
  cap_first = TRUE,
  fields = "minimal",
  names = NULL,
  ...
)
}
\arguments{
\item{sci}{character; taxonomic names to be resolved. Doesn't work for
vernacular/common names.}

\item{data_source_ids}{character; IDs to specify what data source
is searched. See \code{\link[=gnr_datasources]{gnr_datasources()}}.}

\item{resolve_once}{logical; Find the first available match instead of
matches across all data sources with all possible renderings of a name.
When \code{TRUE}, response is rapid but incomplete.}

\item{with_context}{logical; Reduce the likelihood of matches to taxonomic
homonyms. When \code{TRUE} a common taxonomic context is calculated for
all supplied names from matches in data sources that have classification
tree paths. Names out of determined context are penalized during score
calculation.}

\item{canonical}{logical; If \code{FALSE} (default), gives back names with
taxonomic authorities. If \code{TRUE}, returns canocial names
(without tax. authorities and abbreviations).}

\item{highestscore}{logical; Return those names with the highest score for
each searched name? Defunct}

\item{best_match_only}{(logical) If \code{TRUE}, best match only returned.
Default: \code{FALSE}}

\item{preferred_data_sources}{(character) A vector of one or more data
source IDs.}

\item{with_canonical_ranks}{(logical) Returns names with infraspecific
ranks, if present. If \code{TRUE}, we force \code{canonical=TRUE}, otherwise
this parameter would have no effect. Default: \code{FALSE}}

\item{http}{The HTTP method to use, one of "get" or "post". Default: "get".
Use \code{http="post"} with large queries. Queries with > 300 records
use "post" automatically because "get" would fail}

\item{cap_first}{(logical) For each name, fix so that the first name part is
capitalized, while others are not. This web service is sensitive to
capitalization, so you'll get different results depending on capitalization.
First name capitalized is likely what you'll want and is the default.
If \code{FALSE}, names are not modified. Default: \code{TRUE}}

\item{fields}{(character) One of minimal (default) or all. Minimal gives
back just four fields, whereas all gives all fields back.}

\item{names}{Deprecated, see \code{sci}}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
A data.frame with one attribute \code{not_known}: a character
vector of taxa unknown to the Global Names Index. Access like
\code{attr(output, "not_known")}, or \code{attributes(output)$not_known}.

Columns of the output data.frame:
\itemize{
\item user_supplied_name (character) - the name you passed in to the
\code{names} parameter, unchanged.
\item submitted_name (character) - the actual name submitted to the GNR
service
\item data_source_id (integer/numeric) - data source ID
\item data_source_title (character) - data source name
\item gni_uuid (character) - Global Names Index UUID (aka identifier)
\item matched_name (character) - the matched name in the GNR service
\item matched_name2 (character) - returned if \code{canonical=TRUE}, in
which case \strong{matched_name} is not returned
\item classification_path (character) - names of the taxonomic
classification tree, with names separated by pipes (\code{|})
\item classification_path_ranks (character) - ranks of the taxonomic
classification tree, with names separated by pipes (\code{|})
\item classification_path_ids (character) - identifiers of the taxonomic
classification tree, with names separated by pipes (\code{|})
\item taxon_id (character) - taxon identifier
\item edit_distance (integer/numeric) - edit distance
\item imported_at (character) - date imported
\item match_type (integer/numeric) - match type
\item match_value (character) - description of match type
\item prescore (character) - pre score
\item score (numeric) - score
\item local_id (character) - local identifier
\item url (character) - URL for taxon
\item global_id (character) - global identifier
\item current_taxon_id (character) - current taxon id
\item current_name_string (character) - current name string
}

Note that names (i.e. rows) are dropped that are NA, are zero length
strings, are not character vectors, or are not found by the API.
}
\description{
See section \strong{Age of datasets in the Global Names Resolver}
}
\section{Age of datasets in the Global Names Resolver}{

IMPORTANT: Datasets used in the Global Names Resolver vary in how recently
they've been updated. See the \code{updated_at} field in the
output of \code{\link[=gnr_datasources]{gnr_datasources()}} for dates when each dataset
was last updated.
}

\section{preferred_data_sources}{

If \code{preferred_data_sources} is used, only the preferred data
is returned - if it has any results.
}

\examples{
\dontrun{
gnr_resolve(sci = c("Helianthus annuus", "Homo sapiens"))
gnr_resolve(sci = c("Asteraceae", "Plantae"))

# Using data source 12 (Encyclopedia of Life)
sources <- gnr_datasources()
sources
eol <- sources$id[sources$title == 'EOL']
gnr_resolve(names=c("Helianthos annuus","Homo sapians"), data_source_ids=eol)

# Two species in the NE Brazil catalogue
sps <- c('Justicia brasiliana','Schinopsis brasiliensis')
gnr_resolve(sci = sps, data_source_ids = 145)

# Best match only, compare the two
gnr_resolve(sci = "Helianthus annuus", best_match_only = FALSE)
gnr_resolve(sci = "Helianthus annuus", best_match_only = TRUE)

# Preferred data source
gnr_resolve(sci = "Helianthus annuus", preferred_data_sources = c(3,4))

# Return canonical names - default is canonical=FALSE
head(gnr_resolve(sci = "Helianthus annuus"))
head(gnr_resolve(sci = "Helianthus annuus", canonical=TRUE))

# Return canonical names with authority stripped but
# ranks still present
gnr_resolve("Scorzonera hispanica L. subsp. asphodeloides Wallr.")
## vs.
gnr_resolve("Scorzonera hispanica L. subsp. asphodeloides Wallr.",
   with_canonical_ranks = TRUE)
}
}
\references{
http://gnrd.globalnames.org/api
http://gnrd.globalnames.org/
}
\seealso{
\code{\link[=gnr_datasources]{gnr_datasources()}}
}
\author{
Scott Chamberlain
}
\keyword{names}
\keyword{resolve}
\keyword{taxonomy}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{plantNames}
\alias{plantNames}
\title{Vector of plant species (genus - specific epithet) names from ThePlantList}
\format{
A vector of length 1182
}
\source{
http://www.theplantlist.org
}
\description{
These names are from http://www.theplantlist.org, and are a
randomly chosen subset of names of the form genus/specific epithet
for the purpose of having some names to play with for examples in
this package.
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tpl_families.r
\name{tpl_families}
\alias{tpl_families}
\title{Get The Plant List families.}
\usage{
tpl_families(...)
}
\arguments{
\item{...}{(list) Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
Returns a \code{data.frame} including the names of all families
indexed by The Plant List, and the major groups into which they fall
(i.e. Angiosperms, Gymnosperms, Bryophytes and Pteridophytes).
}
\description{
Get The Plant List families.
}
\details{
Requires an internet connection in order to connect to
<www.theplantlist.org>.
}
\examples{
\dontrun{
# Get a data.frame of plant families, with the group name 
# (Angiosperms, etc.)
head(tpl_families())
}
}
\seealso{
\code{\link[=tpl_get]{tpl_get()}}
}
\author{
John Baumgartner (johnbb@student.unimelb.edu.au)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_taxrank.R
\name{itis_taxrank}
\alias{itis_taxrank}
\title{Retrieve taxonomic rank name from given TSN.}
\usage{
itis_taxrank(query = NULL, ...)
}
\arguments{
\item{query}{TSN for a taxonomic group (numeric). If query is left as default
(NULL), you get all possible rank names, and their TSN's (using function
\code{\link[ritis:rank_names]{ritis::rank_names()}}. There is slightly different terminology for
Monera vs. Plantae vs. Fungi vs. Animalia vs. Chromista, so there are
separate terminologies for each group.}

\item{...}{Further arguments passed on to \code{\link[ritis:rank_name]{ritis::rank_name()}}}
}
\value{
Taxonomic rank names or data.frame of all ranks.
}
\description{
Retrieve taxonomic rank name from given TSN.
}
\details{
You can print messages by setting \code{verbose=FALSE}.
}
\examples{
\dontrun{
# All ranks
itis_taxrank()

# A single TSN
itis_taxrank(query=202385)

# Many TSN's
itis_taxrank(query=c(202385,183833,180543))
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp_dist.R
\name{tp_dist}
\alias{tp_dist}
\title{Return all distribution records for for a taxon name with a given id.}
\usage{
tp_dist(id, key = NULL, ...)
}
\arguments{
\item{id}{the taxon identifier code}

\item{key}{Your Tropicos API key; See \link{taxize-authentication}
for help on authentication}

\item{...}{Curl options passed on to \link[crul:HttpClient]{crul::HttpClient}}
}
\value{
List of two data.frame's, one named "location", and one "reference".
}
\description{
Return all distribution records for for a taxon name with a given id.
}
\examples{
\dontrun{
# Query using a taxon name Id
out <- tp_dist(id = 25509881)
## just location data
head(out[['location']])
## just reference data
head(out[['reference']])
}
}
\references{
http://services.tropicos.org/help?method=GetNameDistributionsXml
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tax_rank.R
\name{tax_rank}
\alias{tax_rank}
\title{Get rank for a given taxonomic name.}
\usage{
tax_rank(sci_id, db = NULL, rows = NA, x = NULL, ...)
}
\arguments{
\item{sci_id}{(character) Vector of one or more taxon names (character) or
IDs (character or numeric) to query. Or objects returned from \verb{get_*()}
functions like \code{\link[=get_tsn]{get_tsn()}}}

\item{db}{(character) database to query. either \code{ncbi}, \code{itis}, \code{eol},
\code{tropicos}, \code{gbif},\code{nbn}, \code{worms}, \code{natserv}, \code{bold}. Note that each
taxonomic data source has their own identifiers, so that if you provide the
wrong \code{db} value for the identifier you may get a result, but it will
likely be wrong (not what you were expecting). If using ncbi we
recommend getting an API key; see \link{taxize-authentication}}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA,
all rows are considered. passed down to \verb{get_*()} functions.}

\item{x}{Deprecated, see \code{sci_id}}

\item{...}{Additional arguments to \code{\link[=classification]{classification()}}}
}
\value{
A named list of character vectors with ranks (all lower-cased)
}
\description{
Get rank for a given taxonomic name.
}
\note{
While \code{\link[=tax_name]{tax_name()}} returns the name of a specified
rank, \code{\link[=tax_rank]{tax_rank()}} returns the actual rank of the taxon.
}
\examples{
\dontrun{
tax_rank("Helianthus annuus", db = "itis")
tax_rank("Helianthus annuus", db = "natserv")
tax_rank(get_tsn("Helianthus annuus"))
tax_rank(c("Helianthus", "Pinus", "Poa"), db = "itis")

tax_rank(get_boldid("Helianthus annuus"))
tax_rank("421377", db = "bold")
tax_rank(421377, db = "bold")

tax_rank(c("Plantae", "Helianthus annuus",
  "Puma", "Homo sapiens"), db = 'itis')
tax_rank(c("Helianthus annuus", "Quercus", "Fabaceae"), db = 'tropicos')

tax_rank(names_list("species"), db = 'gbif')
tax_rank(names_list("family"), db = 'gbif')

tax_rank(c("Gadus morhua", "Lichenopora neapolitana"),
  db = "worms")
}
}
\seealso{
\code{\link[=classification]{classification()}},\code{\link[=tax_name]{tax_name()}}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipni_search.R
\name{ipni_search}
\alias{ipni_search}
\title{Search for names in the International Plant Names Index (IPNI).}
\usage{
ipni_search(
  family = NULL,
  infrafamily = NULL,
  genus = NULL,
  infragenus = NULL,
  species = NULL,
  infraspecies = NULL,
  publicationtitle = NULL,
  authorabbrev = NULL,
  includepublicationauthors = NULL,
  includebasionymauthors = NULL,
  geounit = NULL,
  addedsince = NULL,
  modifiedsince = NULL,
  isapnirecord = NULL,
  isgcirecord = NULL,
  isikrecord = NULL,
  ranktoreturn = NULL,
  output = "minimal",
  ...
)
}
\arguments{
\item{family}{Family name to search on (Optional)}

\item{infrafamily}{Infrafamilial name to search on (Optional)}

\item{genus}{Genus name to search on (Optional)}

\item{infragenus}{Infrageneric name to search on (Optional)}

\item{species}{Species name to search on (Optional) - Note, this is the
epithet, not the full genus - epithet name combination.}

\item{infraspecies}{Infraspecies name to search on (Optional)}

\item{publicationtitle}{Publication name or abbreviation to search on.
Again, replace any spaces with a '+' (e.g. 'J.+Bot.') (Optional)}

\item{authorabbrev}{Author standard form to search on (publishing author,
basionym author or both - see below) (Optional)}

\item{includepublicationauthors}{TRUE (default) to include the taxon author
in the search or FALSE to exclude it}

\item{includebasionymauthors}{TRUE (default) to include the basionum author
in the search or FALSE to exclude it}

\item{geounit}{Country name or other geographical unit to search on (see
the help pages for more information and warnings about the use of this
option) (Optional)}

\item{addedsince}{Date to search on in the format 'yyyy-mm-dd', e.g.
2005-08-01 for all records added since the first of August, 2005. (see the
help pages for more information and warnings about the use of this option)
(Optional. If supplied must be in format YYYY-MM-DD and must be greater
than or equal to 1984-01-01.)}

\item{modifiedsince}{Date to search on in the format 'yyyy-mm-dd', e.g.
2005-08-01 for all records edited since the first of August, 2005. (See
the help pages for more information about the use of this option)
(Optional. If supplied must be in format YYYY-MM-DD and must be greater
than or equal to 1993-01-01.)}

\item{isapnirecord}{FALSE (default) to exclude records from the Australian
Plant Name Index}

\item{isgcirecord}{FALSE (default) to exclude records from the Gray Cards
Index}

\item{isikrecord}{FALSE (default) to exclude records from the Index Kewensis}

\item{ranktoreturn}{One of a few options to choose the ranks returned. See
details.}

\item{output}{One of minimal (default), classic, short, or extended}

\item{...}{Curl options passed on to \link[crul:verb-GET]{crul::verb-GET}
(Optional). Default: returns all ranks.}
}
\value{
a tibble (data.frame)
}
\description{
Note: This data source is also provided in the Global Names Index (GNI)
(http://gni.globalnames.org/data_sources). The interface to the data is
different among the two services though.
}
\details{
\code{ranktoreturn} options:
\itemize{
\item "all" - all records
\item "fam" - family records
\item "infrafam" - infrafamilial records
\item "gen" - generic records
\item "infragen" - infrageneric records
\item "spec" - species records
\item "infraspec" - infraspecific records
}
}
\examples{
\dontrun{
ipni_search(genus='Brintonia', isapnirecord=TRUE, isgcirecord=TRUE,
  isikrecord=TRUE)
ipni_search(genus='Ceanothus')
ipni_search(genus='Pinus', species='contorta')

# Different output formats
ipni_search(genus='Ceanothus')
ipni_search(genus='Ceanothus', output='short')
ipni_search(genus='Ceanothus', output='extended')
}
}
\references{
https://web.archive.org/web/20190501132148/http://www.ipni.org/link_to_ipni.html
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/key_helpers.R
\name{use_eol-defunct}
\alias{use_eol-defunct}
\alias{use_eol}
\title{use eol}
\usage{
use_eol()
}
\description{
use eol
}
\keyword{internal}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bold_search.R
\name{bold_search}
\alias{bold_search}
\title{Search Barcode of Life for taxonomic IDs}
\usage{
bold_search(
  sci = NULL,
  id = NULL,
  fuzzy = FALSE,
  dataTypes = "basic",
  includeTree = FALSE,
  response = FALSE,
  name = NULL,
  ...
)
}
\arguments{
\item{sci}{(character) One or more scientific names.}

\item{id}{(integer) One or more BOLD taxonomic identifiers.}

\item{fuzzy}{(logical) Whether to use fuzzy search or not (default: \code{FALSE}).
Only used if \code{name} passed.}

\item{dataTypes}{(character) Specifies the datatypes that will be returned.
See Details for options. This variable is ignored if \code{name} parameter is passed,
but is used if the \code{id} parameter is passed.}

\item{includeTree}{(logical) If TRUE (default: FALSE), returns a list containing
information for parent taxa as well as the specified taxon. Only used if \code{id}
passed.}

\item{response}{(logical) Note that response is the object that returns from the
curl call, useful for debugging, and getting detailed info on the API call.}

\item{name}{Deprecated, see \code{sci}}

\item{...}{named curl options passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A list of data.frame's.
}
\description{
Search Barcode of Life for taxonomic IDs
}
\details{
You must provide one of \code{sci} or \code{id} to this function. The other
parameters are optional. Note that when passing in \code{sci}, \code{fuzzy} can be used
as well, while if \code{id} is passed, then \code{fuzzy} is ignored, and \code{dataTypes}
\code{includeTree} can be used.

Options for \code{dataTypes} parameter:
\itemize{
\item all returns all data
\item basic returns basic taxon information
\item images returns specimen image. Includes copyright information, image URL,
image metadata.
\item stats Returns specimen and sequence statistics. Includes public species
count, public BIN count, public marker counts, public record count,
specimen count, sequenced specimen count, barcode specimen count, species
count, barcode species count.
\item geo Returns collection site information. Includes country, collection
site map.
\item sequencinglabs Returns sequencing labs. Includes lab name, record count.
\item depository Returns specimen depositories. Includes depository name,
record count.
\item thirdparty Returns information from third parties. Includes wikipedia
summary, wikipedia URL, GBIF map.
}
}
\examples{
\dontrun{
# A basic example
bold_search(sci="Apis")
bold_search(sci="Agapostemon")
bold_search(sci="Poa")

# Fuzzy search
head(bold_search(sci="Po", fuzzy=TRUE))
head(bold_search(sci="Aga", fuzzy=TRUE))

# Many names
bold_search(sci=c("Apis","Puma concolor"))
nms <- names_list('species')
bold_search(sci=nms)

# Searching by ID - dataTypes can be used, and includeTree can be used
bold_search(id=88899)
bold_search(id=88899, dataTypes="stats")
bold_search(id=88899, dataTypes="geo")
bold_search(id=88899, dataTypes="basic")
bold_search(id=88899, includeTree=TRUE)
}
}
\references{
http://www.boldsystems.org/index.php/resources/api
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxon_state.R
\name{taxon-state}
\alias{taxon-state}
\alias{taxon_last}
\alias{taxon_clear}
\title{Last taxon state object from a \verb{get_*} function call}
\usage{
taxon_last()

taxon_clear()
}
\value{
\code{taxon_last()} returns an object of class \code{taxon_state}, the last
one used, else \code{NULL} if none found. \code{taxon_clear()} clears the saved state
}
\description{
Last taxon state object from a \verb{get_*} function call
}
\details{
\itemize{
\item \code{taxon_last()}: get the last \code{taxon_state} object in use
\item \code{taxon_clear()}: clear any data from last \code{taxon_state} object
}

The \code{taxon_state} object is an R6 object that holds data and methods
used for keeping track of results gathered within a \verb{get_*} function.
You shouldn't create \code{taxon_state} R6 objects yourself.

Behaviors to be aware of:
\itemize{
\item If a \code{taxon_state} object is not passed you don't need to worry about
a previously run \verb{get_*} function interfering with another \verb{get_*}
function call - you have to explicitly pass a \code{taxon_state} object
to use \code{taxon_state}
\item The passed in \code{taxon_state} object must have a \verb{$class} matching that of
the \verb{get_*} function being called. For example, you can only pass a
\code{taxon_state} with \verb{$class} of \code{gbifid} to \code{get_gbifid()}, and so on.
\item If you run \code{taxon_clear()} while a \verb{get*} function is running, you may
lose track of any state known to this package before it was cleared
}

See the internal method \link{progressor} for information on how we control messages
in \verb{get*} functions
}
\examples{
\dontrun{
spp <- names_list("species", 3)
res <- get_gbifid(spp)
z <- taxon_last()
z
z$taxa_remaining()
z$taxa_completed()
z$count # active binding; no parens needed

# cleanup
taxon_clear()
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize_capwords.r
\name{taxize_capwords}
\alias{taxize_capwords}
\title{Capitalize the first letter of a character string.}
\usage{
taxize_capwords(s, strict = FALSE, onlyfirst = FALSE)
}
\arguments{
\item{s}{A character string}

\item{strict}{Should the algorithm be strict about capitalizing.
Defaults to FALSE.}

\item{onlyfirst}{Capitalize only first word, lowercase all others. Useful
for taxonomic names.}
}
\description{
Capitalize the first letter of a character string.
}
\examples{
taxize_capwords(c("using AIC for model selection"))
taxize_capwords(c("using AIC for model selection"), strict=TRUE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxize-package.R
\docType{data}
\name{plantGenusNames}
\alias{plantGenusNames}
\title{Vector of plant genus names from ThePlantList}
\format{
A vector of length 793
}
\source{
http://www.theplantlist.org
}
\description{
These names are from http://www.theplantlist.org, and are a
randomly chosen subset of genera names for the purpose of having some
names to play with for examples in this package.
}
\keyword{data}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itis_downstream.R
\name{itis_downstream}
\alias{itis_downstream}
\title{Retrieve all taxa names or TSNs downstream in hierarchy from given TSN.}
\usage{
itis_downstream(id, downto, intermediate = FALSE, tsns = NULL, ...)
}
\arguments{
\item{id}{A taxonomic serial number.}

\item{downto}{The taxonomic level you want to go down to. See examples below.
The taxonomic level IS case sensitive, and you do have to spell it
correctly. See \code{data(rank_ref)} for spelling.}

\item{intermediate}{(logical) If TRUE, return a list of length two with target
taxon rank names, with additional list of data.frame's of intermediate
taxonomic groups. Default: FALSE}

\item{tsns}{Deprecated, see \code{id}}

\item{...}{Further args passed on to \code{\link[ritis:rank_name]{ritis::rank_name()}} and
\code{\link[ritis:hierarchy]{ritis::hierarchy_down()}}}
}
\value{
Data.frame of taxonomic information downstream to family from e.g.,
Order, Class, etc., or if \code{intermediated=TRUE}, list of length two,
with target taxon rank names, and intermediate names.
}
\description{
Retrieve all taxa names or TSNs downstream in hierarchy from given TSN.
}
\examples{
\dontrun{
## the plant class Bangiophyceae, tsn 846509
itis_downstream(id = 846509, downto="genus")
itis_downstream(id = 846509, downto="genus", intermediate=TRUE)

# get families downstream from Acridoidea
itis_downstream(id = 650497, "family")
## here, intermediate leads to the same result as the target
itis_downstream(id = 650497, "family", intermediate=TRUE)

# get species downstream from Ursus
itis_downstream(id = 180541, "species")

# get orders down from the Division Rhodophyta (red algae)
itis_downstream(id = 660046, "order")
itis_downstream(id = 660046, "order", intermediate=TRUE)

# get tribes down from the family Apidae
itis_downstream(id = 154394, downto="tribe")
itis_downstream(id = 154394, downto="tribe", intermediate=TRUE)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nbn_classification.R
\name{nbn_classification}
\alias{nbn_classification}
\title{Search UK National Biodiversity Network database for
taxonomic classification}
\usage{
nbn_classification(id, ...)
}
\arguments{
\item{id}{(character) An NBN identifier.}

\item{...}{Further args passed on to \link[crul:verb-GET]{crul::verb-GET}}
}
\value{
A data.frame
}
\description{
Search UK National Biodiversity Network database for
taxonomic classification
}
\examples{
\dontrun{
nbn_classification(id="NHMSYS0000376773")

# get id first, then pass to this fxn
id <- get_nbnid("Zootoca vivipara", rec_only = TRUE, rank = "Species")
nbn_classification(id)

nbn_classification(id="NHMSYS0000502940", verbose = TRUE)
}
}
\references{
https://api.nbnatlas.org/
}
\seealso{
Other nbn: 
\code{\link{get_nbnid}()},
\code{\link{nbn_search}()},
\code{\link{nbn_synonyms}()}
}
\author{
Scott Chamberlain,
}
\concept{nbn}
