# Bindings to 'OpenCV' Computer Vision Library

> Experimenting with computer vision and machine learning in R. This 
  package exposes some of the available 'OpenCV' <https://opencv.org/> algorithms,
  such as edge, body or face detection. These can either be applied to analyze 
  static images, or to filter live video footage from a camera device.

[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/ropensci/opencv?branch=master&svg=true)](https://ci.appveyor.com/project/jeroen/opencv)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/opencv)](http://cran.r-project.org/package=opencv)
[![CRAN RStudio mirror downloads](http://cranlogs.r-pkg.org/badges/opencv)](http://cran.r-project.org/web/packages/opencv/index.html)


## Installation

On Windows and MacOS, the package can be installed directoy from CRAN:

```r
install.packages("opencv")
```

### Install from source

To install from source on MacOS, you need to install the opencv library from homebrew:

```sh
brew install opencv
```

On Ubuntu or Fedora you need [`libopencv-dev`](https://packages.debian.org/testing/libopencv-dev) or [`opencv-devel`](https://apps.fedoraproject.org/packages/opencv-devel/):

```sh
sudo apt-get install libopencv-dev
```

For Ubuntu 16.04 (Xenial) and Ubuntu 18.04 (Bionic) we provide [a PPA](https://launchpad.net/~cran/+archive/ubuntu/opencv) with more recent versions of OpenCV:

```sh
sudo add-apt-repository ppa:cran/opencv
sudo apt-get install libopencv-dev
```

And then install the R bindings:

```r
install.packages("opencv", type = "source")
```

## Basic stuff:

Face recognition:

```r
unconf <- ocv_read('https://jeroen.github.io/images/unconf18.jpg')
faces <- ocv_face(unconf)
ocv_write(faces, 'faces.jpg')
```

Or get the face location data:

```r
facemask <- ocv_facemask(unconf)
attr(facemask, 'faces')
```

## Live Webcam Examples

Live face detection:

```r
library(opencv)
ocv_video(ocv_face)
```

Edge detection:

```r
library(opencv)
ocv_video(ocv_edges)
```

## Combine with Graphics

Replaces the background with a plot:

```r
library(opencv)
library(ggplot2)

# get webcam size
test <- ocv_picture()
bitmap <- ocv_bitmap(test)
width <- dim(bitmap)[2]
height <- dim(bitmap)[3]

png('bg.png', width = width, height = height)
par(ask=FALSE)
print(ggplot2::qplot(speed, dist, data = cars, geom = c("smooth", "point")))
dev.off()
bg <- ocv_read('bg.png')
unlink('pg.png')
ocv_video(function(input){
  mask <- ocv_mog2(input)
  return(ocv_copyto(input, bg, mask))
})
```

Put your face in the plot:

```r
# Overlay face filter
ocv_video(function(input){
  mask <- ocv_facemask(input)
  ocv_copyto(input, bg, mask)
})
```

## Live Face Survey

Go stand on the left if you're a tidier

```r
library(opencv)

# get webcam size
test <- ocv_picture()
bitmap <- ocv_bitmap(test)
width <- dim(bitmap)[2]
height <- dim(bitmap)[3]

# generates the plot
makeplot <- function(x){
  png('bg.png', width = width, height = height, res = 96)
  on.exit(unlink('bg.png'))
  groups <- seq(0, width, length.out = 4)
  left <- rep("left", sum(x < groups[2]))
  middle <- rep("middle", sum(x >= groups[2] & x < groups[3]))
  right <- rep("right", sum(x >= groups[3]))
  f <- factor(c(left, middle, right), levels = c('left', 'middle', 'right'),
              labels = c("Tidy!", "Whatever Works", "Base!"))
  color = I(c("#F1BB7B", "#FD6467", "#5B1A18"))
  plot(f, ylim = c(0, 5),
       main = "Are you a tidyer or baser?", col = color)
  dev.off()
  ocv_read('bg.png')
}

# overlays faces on the plot
ocv_video(function(input){
  mask <- ocv_facemask(input)
  faces <- attr(mask, 'faces')
  bg <- makeplot(faces$x)
  return(ocv_copyto(input, bg, mask))
})
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/keypoints.R
\name{ocv_keypoints}
\alias{ocv_keypoints}
\title{OpenCV keypoints}
\usage{
ocv_keypoints(
  image,
  method = c("FAST", "Harris"),
  control = ocv_keypoints_options(method, ...),
  ...
)
}
\arguments{
\item{image}{an ocv grayscale image object}

\item{method}{the type of keypoint detection algorithm}

\item{control}{a list of arguments passed on to the algorithm}

\item{...}{further arguments passed on to ocv_keypoints_options}
}
\description{
Find key points in images
}
\section{FAST algorithm arguments}{

\itemize{
\item threshold threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.
\item nonmaxSuppression if true, non-maximum suppression is applied to detected corners (keypoints).
\item type one of the three neighborhoods as defined in the paper: TYPE_9_16, TYPE_7_12, TYPE_5_8
}
}

\section{Harris algorithm arguments}{

\itemize{
\item numOctaves the number of octaves in the scale-space pyramid
\item corn_thresh the threshold for the Harris cornerness measure
\item DOG_thresh the threshold for the Difference-of-Gaussians scale selection
\item maxCorners the maximum number of corners to consider
\item num_layers the number of intermediate scales per octave
}
}

\examples{
mona <- ocv_read('https://jeroen.github.io/images/monalisa.jpg')
mona <- ocv_resize(mona, width = 320, height = 477)

# FAST-9
pts <- ocv_keypoints(mona, method = "FAST", type = "TYPE_9_16", threshold = 40)
# Harris
pts <- ocv_keypoints(mona, method = "Harris", maxCorners = 50)

# Convex Hull of points
pts <- ocv_chull(pts)

\dontshow{
ocv_destroy(mona)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/areas.R
\name{opencv-area}
\alias{opencv-area}
\alias{ocv_rectangle}
\alias{ocv_polygon}
\alias{ocv_bbox}
\alias{ocv_chull}
\title{OpenCV area manipulation}
\usage{
ocv_rectangle(image, x = 0L, y = 0L, width, height)

ocv_polygon(image, pts, convex = FALSE, crop = FALSE, color = 255)

ocv_bbox(image, pts)

ocv_chull(pts)
}
\arguments{
\item{image}{an ocv image object}

\item{x}{horizontal location}

\item{y}{vertical location}

\item{width}{width of the area}

\item{height}{height of the area}

\item{pts}{a list of points with elements x and y}

\item{convex}{are the points convex}

\item{crop}{crop the resulting area to its bounding box}

\item{color}{color for the non-polygon area}
}
\description{
Manipulate image regions
}
\examples{
mona <- ocv_read('https://jeroen.github.io/images/monalisa.jpg')

# Rectangular area
ocv_rectangle(mona, x = 400, y = 300, height = 300, width = 350)
ocv_rectangle(mona, x = 0, y = 100, height = 200)
ocv_rectangle(mona, x = 500, y = 0, width = 75)

# Polygon area
img <- ocv_resize(mona, width = 320, height = 477)
pts <- list(x = c(184, 172, 146, 114,  90,  76,  92, 163, 258),
            y = c(72,   68,  70,  90, 110, 398, 412, 385, 210))
ocv_polygon(img, pts)
ocv_polygon(img, pts, crop = TRUE)
ocv_polygon(img, pts, convex = TRUE, crop = TRUE)

# Bounding box based on points
ocv_bbox(img, pts)

# Bounding box of non-zero pixel area
area <- ocv_polygon(img, pts, color = 0, crop = FALSE)
area
area <- ocv_bbox(area)
area

\dontshow{
ocv_destroy(mona)
ocv_destroy(img)
ocv_destroy(area)
}
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/opencv.R
\docType{import}
\name{reexports}
\alias{reexports}
\alias{\%>\%}
\title{Objects exported from other packages}
\keyword{internal}
\description{
These objects are imported from other packages. Follow the links
below to see their documentation.

\describe{
  \item{magrittr}{\code{\link[magrittr:pipe]{\%>\%}}}
}}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/face.R, R/opencv.R
\name{ocv_face}
\alias{ocv_face}
\alias{ocv_facemask}
\alias{ocv_read}
\alias{ocv_write}
\alias{ocv_destroy}
\alias{ocv_bitmap}
\alias{ocv_edges}
\alias{ocv_picture}
\alias{ocv_resize}
\alias{ocv_mog2}
\alias{ocv_knn}
\alias{ocv_hog}
\alias{ocv_blur}
\alias{ocv_sketch}
\alias{ocv_stylize}
\alias{ocv_markers}
\alias{ocv_info}
\alias{ocv_copyto}
\alias{ocv_display}
\alias{ocv_video}
\alias{ocv_grayscale}
\alias{ocv_version}
\title{OpenCV Computer Vision}
\usage{
ocv_face(image)

ocv_facemask(image)

ocv_read(path)

ocv_write(image, path)

ocv_destroy(image)

ocv_bitmap(image)

ocv_edges(image)

ocv_picture()

ocv_resize(image, width = 0, height = 0)

ocv_mog2(image)

ocv_knn(image)

ocv_hog(image)

ocv_blur(image, ksize = 5)

ocv_sketch(image, color = TRUE)

ocv_stylize(image)

ocv_markers(image)

ocv_info(image)

ocv_copyto(image, target, mask)

ocv_display(image)

ocv_video(filter)

ocv_grayscale(image)

ocv_version()
}
\arguments{
\item{image}{an ocv image object}

\item{path}{image file such as png or jpeg}

\item{width}{output width in pixels}

\item{height}{output height in pixels}

\item{ksize}{size of blurring matrix}

\item{color}{true or false}

\item{target}{the output image}

\item{mask}{only copy pixels from the mask}

\item{filter}{an R function that takes and returns an opecv image}
}
\description{
Tools to experiment with computer vision algorithms. Use \link{ocv_read} and
\link{ocv_write} to load/save images on disk, or use \link{ocv_picture} / \link{ocv_video}
to use your webcam. In RSudio IDE the image objects will automatically be
displayed in the viewer pane.
}
\examples{
# Silly example
mona <- ocv_read('https://jeroen.github.io/images/monalisa.jpg')

# Edge detection
ocv_edges(mona)
ocv_markers(mona)

# Find face
faces <- ocv_face(mona)

# To show locations of faces
facemask <- ocv_facemask(mona)
attr(facemask, 'faces')

# This is not strictly needed
ocv_destroy(mona)
}
