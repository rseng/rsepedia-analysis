
Table of Contents
=================

   * [Introduction](#introduction)
   * [Citation](#citation)
   * [How to install SAIGE and SAIGE-GENE](#how-to-install-and-run-saige-and-saige-gene)
   * [Notes for users before running jobs](#notes-for-users-before-running-jobs)
   * [UK Biobank GWAS Results](#uk-biobank-gwas-results)
   * [Log for fixing bugs](#log-for-fixing-bugs)
   

# Introduction
## Manuscript for SAIGE-GENE+: https://www.medrxiv.org/content/10.1101/2021.07.12.21260400v1

## Current version is 0.45 (Updated on January 24, 2022) - comment out the part to estimate the effective sample sizes, which may not convert and take very long; put <= instead of < for maxMAF in the gene-based tests

## Current version is 0.44.6.5 (Updated on August 18, 2021) - 0.44.6.2 add extdata/extractNglmm.R to extract the effective sample size without running Step 1. extdata/cmd_extractNeff.sh has the pipeline. The effective sample size (Nglmm) is differently calculated than the previous versions.

## Previous version is 0.44.6.1 (Updated on July 16, 2021) - SAIGE-GENE+: for group tests, collpasing ultra-rare variants with MAC <= 10. Set --method_to_CollapseUltraRare="absence_or_presence" as default to collpase ultra-rare varaints with MAC <= 10. SAIGE-GENE+ has well controlled type I error rates when the maximum MAF cutoff (maxMAFforGroupTest) is lower than 1%, e.g. 0.01% or 0.1%. Tests with multiple MAF cutoffs and variant annotations can be combined using the Cauchy combination (function CCT)

##Please re-install 0.44.2 if you installed this verion on March 31. 

##For BGEN input, 8 bits are required. 

##For BGEN input in step 2 with missing dosages, Please use version 0.38 or later.


SAIGE is an R package with Scalable and Accurate Implementation of Generalized mixed model (Chen, H. et al. 2016). It accounts for sample relatedness and is feasible for genetic association tests in large cohorts and biobanks (N > 400,000).

SAIGE performs single-variant association tests for binary traits and quantitative taits. For binary traits, SAIGE uses the saddlepoint approximation (SPA)(mhof, J. P. , 1961; Kuonen, D. 1999; Dey, R. et.al 2017) to account for case-control imbalance.

SAIGE-GENE (implemented in the SAIGE R package) performs gene- or region-based association tests (Burde, SKAT, SKAT-O) for binary traits and quantitative traits. Note: SAIGE-GENE accounts for case-control imbalance in gene-based tests (>= 0.35.8.5)


# Citation
The SAIGE manuscript:
Wei Zhou, Jonas B. Nielsen, Lars G. Fritsche, Maiken B. Elvestad, Brooke Wolford, Maoxuan Lin, Kristian Hveem, Hyun Min Kang, Goncalo R. Abecasis, Cristen J. Willer*, Seunggeun Lee* “Efficiently controlling for case-control imbalance and sample relatedness in large-scale genetic association studies.” Nature Genetics 50, 1335–1341 (2018)

The SAIGE-GENE pre-print:
https://www.biorxiv.org/content/10.1101/583278v2


# How to install and run SAIGE and SAIGE-GENE


## Install SAIGE/SAIGE-GENE

### List of dependencies: 

* R-3.6.1, gcc >= 5.4.0, cmake 3.14.1, [cget](https://cget.readthedocs.io/en/latest/src/intro.html#installing-cget)
* R packages: "R.utils", "Rcpp", "RcppParallel", "RcppArmadillo", "data.table", "RcppEigen", "Matrix", "methods", "BH", "optparse", "SPAtest", "SKAT","MetaSKAT"
* /extdata/install_packages.R can be used to install the R packages
* SAIGE v0.39.2 depends on the SPAtest v3.1.2
* MetaSKAT is currently not available on CRAN. Please install it from github using R
  ``` 
   devtools::install_github("leeshawn/MetaSKAT") 
  ```

###  Install SAIGE from conda

#### Warning: please do not use this bioconda version for bgen input. We are working on the issue. 

![r-saige](https://anaconda.org/bioconda/r-saige/badges/version.svg)
![latest_update](https://anaconda.org/bioconda/r-saige/badges/latest_release_date.svg)

To install saige from conda simply create environment with latest version of R and saige:
```
conda create -n saige -c conda-forge -c bioconda "r-base>=4.0" r-saige
conda activate saige
```

More info on [r-saige conda package](https://anaconda.org/bioconda/r-saige) and available versions can be found in the [issue #272](https://github.com/weizhouUMICH/SAIGE/issues/272).

###  Install SAIGE using the conda environment

1. Create a conda environment using 
     ([conda environment file](https://github.com/weizhouUMICH/SAIGE/blob/master/conda_env/environment-RSAIGE.yml)) 
     Here is a link to download the [conda environment file](https://raw.githubusercontent.com/weizhouUMICH/SAIGE/master/conda_env/environment-RSAIGE.yml)

     After downloading environment-RSAIGE.yml, run following command
     ```
       conda env create -f environment-RSAIGE.yml
   ```

2. Activate the conda environment RSAIGE

     ```
       conda activate RSAIGE
       FLAGPATH=`which python | sed 's|/bin/python$||'`
       export LDFLAGS="-L${FLAGPATH}/lib"
       export CPPFLAGS="-I${FLAGPATH}/include"
     ```
Please make sure to set up the LDFLAGS and CPPFLAGS using export (the last two command lines), so libraries can be linked correctly when the SAIGE source code is compiled. Note: [Here](https://github.com/weizhouUMICH/SAIGE/blob/master/conda_env/createCondaEnvSAIGE_steps.txt) are the steps to create the conda environment file 

3. Open R, run following script to install the MetaSKAT R library.
   
     ```
       devtools::install_github("leeshawn/MetaSKAT") 
     ```

4. Install SAIGE from the source code. 

     Method 1: 

     ```
       src_branch=master
       repo_src_url=https://github.com/weizhouUMICH/SAIGE
       git clone --depth 1 -b $src_branch $repo_src_url

       R CMD INSTALL --library=path_to_final_SAIGE_library SAIGE
     ```
     
     When call SAIGE in R, set lib.loc=path_to_final_SAIGE_library   

     ```
       library(SAIGE, lib.loc=path_to_final_SAIGE_library)
     ```

    Method 2: 

    Open R. Run

    ```
      devtools::install_github("weizhouUMICH/SAIGE")
    ```

### Run SAIGE using a docker image 

Thanks to Juha Karjalainen for sharing the Dockerfile. 
The docker image can be pulled

```
docker pull wzhou88/saige:0.45
```

Functions can be called
```
step1_fitNULLGLMM.R --help
step2_SPAtests.R --help
createSparseGRM.R --help
```


## Run SAIGE for single-variant association tests and SAIGE-GENE for gene- or region-based tests

Here is a wiki page containg tutorial to run SAIGE and SAIGE-GENE
  https://github.com/weizhouUMICH/SAIGE/wiki/Genetic-association-tests-using-SAIGE
  
### Examples

Example data and script can be found in ./extdata. Run

    bash cmd.sh

to run single-variant and gene-based association tests


## extract effectize sample size v0.44.6.2)
```
  SAIGE_extractNeff.R --help
  bash cmd_extractNeff.sh
```    


# Notes before running jobs

### FAQ can be found  [here](https://github.com/weizhouUMICH/SAIGE/wiki/Genetic-association-tests-using-SAIGE#Frequently-asked-questions)

### More notes
1. Since the SPA test always provides close to 0 p-values for variants with MAC < 3, please use at least minMAC = 3 to filter out the results
2. When query is used for bgen files, please make sure there are no duplicate SNP ids in the list
3. If the error message "Error in setgeno(genofile, subSampleInGeno, memoryChunk) :
  vector::_M_range_check", try use a smaller memeoryChunk, such as 2
4. IMPORTANT:In version <= 0.26, for binary traits, BETA is for alt allele and for quantitative traits, BETA is for minor allele 
5. Please note that LOCO only works for autosomal genetic variants. For non-autosomal genetic variants, please leave LOCO=FALSE in step 2.
6. SAIGE-GENE 0.36.3 and 0.36.3.1 now output an effect size for burden tests with the option IsOutputBETASEinBurdenTest in step2. Please note that the magnitude of the effect size is difficult to interpret. 
7. We haven't throughly tested the program on a small sample size. All simulation studies were done using 10,000 samples. Similar to BOLT-LMM, SAIGE uses asymptotic approaches to for feasibility on large samples. Based on our previous real-data analysis, we saw the performance on 3,000 samples were fine. 

# UK Biobank GWAS Results
1. The GWAS results for binary phenotypes in UK Biobank (1,283 phenotypes) using SAIGE are currently available for public download at

https://www.leelabsg.org/resources

Pheweb browser for the UK Biobank results

http://pheweb.sph.umich.edu/SAIGE-UKB/


*This research has been conducted using the UK Biobank Resource under application number 24460.

2. The exome-wide gene-based association results for quantitative traits in UK Biobank (53 traits) using SAIGE-GENE are currently available for public download at

https://www.leelabsg.org/resources

*This research has been conducted using the UK Biobank Resource under application number 45227.


# Log for fixing bugs

* 0.45 (January-24-2022). comment out the part to estimate the effective sample sizes, which may not convert and take very long; put <= instead of < for maxMAF in the gene-based tests

* 0.44.6.5 (August-19-2021). fix the SE=0 issue when IsOutputlogPforSingle=TRUE

* 0.44.6.4 (August-16-2021). make IsOutputlogPforSingle work for quantitative traits. remove the rsid in the output when the input is bgen

* 0.44.6.2 (August-2-2021). add extdata/extractNglmm.R to extract the effective sample size without running Step 1. extdata/cmd_extractNeff.sh has the pipeline. The effective sample size (Nglmm) is differently calculated than the previous versions. 

* 0.44.6.1 (July-16-2021). add the function CCT to perform Cauchy combination to combine multipel tests

* 0.44.6 (July-13-2021). Set --method_to_CollapseUltraRare="absence_or_presence" as default to collpase ultra-rare varaints with MAC <= 10. We call this version SAIGE-GENE+. SAIGE-GENE+ has well controlled type I error rates when the maximum MAF cutoff (maxMAFforGroupTest) is lower than 1%, e.g. 0.01% or 0.1%.  

* 0.44.5 (April-21-2021). 1. re-write code for leave-one-chromosome-out in Step 1 to have more efficient parallel computation in Step 1. 2. Speed up the single-variant association tests when running gene-based tests

* 0.44.2 (March-31-2021) 1.add an option useSparseGRMtoFitNULL to allow for fitting the null model using the sparse GRM and 2. add options to collapse the ultra-rare variants in the set-based tests. --method_to_CollapseUltraRare, --MACCutoff_to_CollapseUltraRare, --DosageCutoff_for_UltraRarePresence

* 0.44.1 (Feb-16-2021) 1. Fixed the error " X %*% Z : non-conformable arguments" for monomorphic variants. 2. merged Jonathon's codes to update savvy to savvy 2.0. For markers in VCF or SAV files without imputation info R2 values, the imputationInfo column will be 1 in the output file, so the markers will not but removed by minInfo 

* 0.44 (January-11-2021) 1. Fixed the error "Phi_ccadj[-indexNeg, -indexNeg]"; 2.  inverse normalization is only performed for quantitative traits; 3. For step 2, bgen input requires the sample file. vcf input does not require a seperate sample file. If sample file is not provided, sample ids will be read from vcf file

* 0.43.3 (January-05-2021)  error "FALis_rewrite_XnonPAR_forMalesSE not found" has been fixed

* 0.43.2 (December-13-2020)  add scripts to calcuate the effectize sample size in Step 1 for binary traits

* 0.43.1. with LOCO=TRUE, remove model results for other chromosomes to save memory usage for Step 2. 

* 0.43 (November-21-2020) Further modify the sparse version of the score test for quantitative traits. This causes slight different assoc tests for variants with MAF < 0.05 for quantitative traits. Set LOCO = TRUE to the default values for step 1 and step 2. In step 2, --chrom needs to be specified for LOCO=TRUE.

* 0.42.1 (September-21-2020) uncomment isSparse=FALSE for quantitative traits. This was commented out for testing in 0.42

* 0.42 (September-16-2020) fix a bug for variance ratio adjustion when account for case-control imbalance for gene-based tests. minMAC is set to 1/(2*N) instead of 0 if is_rewrite_XnonPAR_forMales=TRUE

* 0.41 (August-30-2020) improve the LOCO feature, implement LOCO for gene- and region- based tests (require --chrom to be specified), and with minInfo cutoff, if the input VCF files do not contain info scores, info will be output as NA and markers won't be filtered out. fixed an issue when subsetting pre-calcuated terms (regress X out of G) to drop missing dosages. Use sparse matrices for genotypes/dosages in gene- and region- based tests, so memory usage is dramatically decreased

* 0.39.4 (August-11-2020) use sparse matrix to represent genotype matrix for gene-based tests to save memory

* 0.39.3 (August-6-2020)  add five options --sexCol, --FemaleCode, --FemaleOnly, --MaleCode, --MaleOnly to perform sex-specific Step 1.

* 0.39.2 (July-27-2020)
** add three options --sampleFile_male, --X_PARregion, --is_rewrite_XnonPAR_forMales for chromosome X association tests, in which genotypes/dosages of non-PAR region of males will be multiplied by 2 

* 0.39.1 (July-27-2020)
** add an option --IsOutputlogPforSingle to output log(P) for single-variant assoc tests. v0.39.1 requires SPAtest 3.1.2.  

* 0.39 (May-27-2020)
** fixed an error when conditional analysis is conducted based on vcf input (introduced in 0.38)

* 0.38 (May-4-2020)
** further fixed the bug for output the allele 2 when bgen input with missing dosages was used and missing dosages were dropped. 
** sampleFile is no longer needed if VCF file is used in Step 2
** add --IsOverwriteVarianceRatioFile in step 1 to overwrite the variance ratio file

* 0.37 (May-1-2020)
** fixed an issue with AC values when bgen input is used with missing dosages to be mean imputed (default setting).
 
* 0.36.6 (April-15-2020)
** add an option IsOutputHetHomCountsinCaseCtrl to output the heterozygous and homozygous counts in cases and controls

* 0.36.5.1 (March-29-2020)
** add the option SPAcutoff, If the test statistic lies within the standard deviation cutoff of the mean, p-value based on traditional score test is returned. Otherwise, SPA will be applied. Default value of SPAcutoff is 2 (corresponding p.value.NA 0.05

* 0.36.5 (March-29-2020)
** Fix a typo to extract p.value. 0.36.5: fix an issue for LOCO=TRUE. This issue was introduced when the option minMAFforGRM was introduced.

* 0.36.4.2 (March-20-2020)
** Fix a bug by unlist(p.value), which was introduced in 0.36.4

* 0.36.4.1 (March-18-2020)
** Trying to fix a bug when minMAFforGRM is set and LOCO=TRUE


* 0.36.4 (March-18-2020)
** add an option includeNonautoMarkersforVarRatio in step 1. If TRUE, non-autosomal markers are also used for variance ratio estimation, which will make the algorithm more appropriate for assoc tests for non-autosomal markers; use the new function with sparse sigma for p-values for single variants in gene-based tests; assign AF to be 0 if all samples have missing genotypes or dosages


* 0.36.3.2 (February-25-2020)
** Bug fixed: 1. fixed a bug for gene-based conditioning tests with multiple conditioning markers 2. add codes to re-check markers after dropping samples with missing dosages/genotypes in gene-based tests

* 0.36.3.1 (February-04-2020):
** Note: in v0.36.3.1, uses SPAtest 3.0.2

* 0.36.3 (January-05-2020):
** Note: in v0.36.3, an option IsOutputBETASEinBurdenTest in step 2 is added to output effect sizes for burden tests
Bugs fixed: the header in output files from conditional analysis in gene or reigon-based tests is corrected.  

* 0.36.2 (November-23-2019):
** Note: in v0.36.2, users can specify customized weights for markers in gene- or region-based tests by adding a weight for each marker in the group file

Bugs fixed: 1. The option weights.beta.common is not fully correctly developed, so we make weights.beta.common equal to weights.beta.rare for now. 2. Instead of output NA for SKAT-O p values when the function SKAT:::Met_SKAT_Get_Pvalue failed, output 2*min(SKAT p, Burden p, 0.5).


* 0.36.1 (November-12-2019): 

** Note: in v0.36.1, plain text dosage files are no longer allowed as input in step 2 to get rid of the dependence of the boost_iostream library

Bugs fixed: 1. fixed the freq calculation for mean impute for missing genotypes in  plinkFile 2. Diagonal elements of GRM are now estimated using markers in plinkFile with MAF >= minMAFforGRM 3. Conditional analysis for gene- or region-based test for binary traits is now accounting for case-control imbalance 4. plain dosage files are no longer supported for step 2 so no external boost_iostream library is needed

** minMAFforGRM is added as a parameter in step 0 and 1, so only markers in the plinkFile with MAF >= minMAFforGRM will be used for GRM
** weights.beta.rare, weights.beta.common, weightMAFcutoff, dosageZerodCutoff, IsOutputPvalueNAinGroupTestforBinary, IsAccountforCasecontrolImbalanceinGroupTest are added as new parameters in step 2

* 0.35.8.8: Fixes a matrix inversion issue in the null model and adds an optional argument for the null computation to remove binary covariates with low counts by juhis

* 0.35.8.8 (August-27-2019): Fixes a matrix inversion issue in the null model and adds an optional argument for the null computation to remove binary covariates with low counts by juhis

* 0.35.8.7 (August-15-2019): fixed the bug when there is no covariate specified, added an argument IsOutputNinCaseCtrl for step 2 to allow for output sample sizes in cases and controls for binary traits in the output file, fixed the out of boundary bug for LOCO

* 0.35.8.6 (August-13-2019): fixed the output bug when the genotype matrix has rank 1 for binary phenotypes and add an argument minMAFtoConstructGRM for step 0 and step 1 to allow users to specify the minumum MAF of markers used to construct GRM (default: 1%)

* 0.35.8.5 (June-29-2019): account for case control imbalance for binary traits in gene-based tests

* 0.35.8.3 (May-14-2019): fix a bug in the function getCovM_nopcg, which affected the conditional analysis for binary traits. Merge hyacz/master to use cget to manage superlu 

* 0.35.8.2 (April-16-2019): minor changes include fix error message, change MAC to MAF, add a line to check if the chomosome in plink file is numeric or not, add rsid to the header when input file is bgen

* 0.35.8.1: fix some errors in documentation and the warning message for case-control imbalance of binary traits when running SAIGE-GENE

* 0.35.8 merge changes in the master-gene branch to master

* 0.35.7 merge changes in 0.29.6 and 0.29.7 from master

* 0.35.6 merge in 0.29.5 from master

* 0.35.5 (fix a bug for updating predicted values in the model fit for binary traits. Added a function to create a sparse GRM only for a data set)

* 0.35.3 (this is a clean version for single-variance assoc tests, gene-based tests, and conditional analysis)

* 0.35.2.3 (this version works with the conditonal analysis and gene-based tests)

* 0.29.4.2 (this version works with R-3.5.1)

* 0.29.4 (this version works with R-3.4.4) update SAIGE as a bug for reading vcf and sav files was fixed in the savvy library

* 0.29.3.2 this version works with R-3.5.1

* 0.29.3: update SAIGE step 1 to use the updated R libary SPAtest 3.0.0

* 0.29.2: update SAIGE to use the updated R library SPAtest 3.0.0

* 0.29:
```
1. The colSums() error when there is no covariate has been fixed. 
2. BETA and Tstat are now for the alt allele for both quantitative and binary traits. Note that in version <= 0.26, for binary traits, BETA is for alt allele and for quantitative traits, BETA is for minor allele
3. Options for leave-one-chromosome-out (LOCO), cutoffs for the coefficient of variation (CV) for trace estimates and variance ratio estimates have been added, but these three options have not been extensively tested. CV is mainly for automatically determining whether the number of random markers selected is sufficient or not. If not, the number will be increased until the CV is lower than the specified cutoff.  
```
* 0.26: fixed a bug for the Tstat in the output
* 0.25: allow models with no covariates and GRM contruction using a large number of genetic markers (> 600,000)
* 0.24: centerVariable is no longer needed. QR transformation of the covariate matrix is automatically performed. Supports the dosage files in the VCF,BCF and SAV formats using the SAVVY library 
History
====

7 July 2016
----

* Updates to bgenix to handle UK biobank interim files and to avoid extra index tables in the index file.

21 March 2016
----

* BGEN spec and implementation updated to alter probability order for unphased data when the number of alleles (K) or the ploidy is greater than two.
This order now better matches the order of VCF GP fields and as a simple enumeration scheme.

10 Nov 2015
----

Major changes in revision ff11254f9505:

1. I've implemented two new tools
    - cat-bgen, which can be used to concatenate BGEN files.
    - bgenix, which can be used to index BGEN files and efficiently retrieve specified data.

2. For this purpose I've imported several extra pieces of code
    - appcontext/ and db/ sublibs from qctool
    - sqlite3 3.9.2
    - boost 1.55.0

Note: these changes were erroneously applied first to the master branch (they were intended for default first).

6 Nov 2015
----
Major changes in revision 392429affc42:

1. I’ve changed the behaviour of BGEN v1.2 with respect to samples with missing data: they are now stored with dummy zero probabilities.  The spec is now in 'beta' which means I don’t have any other planned changes to make; unless major issues are uncovered this will be the final version of the format.

2. I’ve revamped the setter api of parse_probability_data somewhat.  It is documented in the code and here [on the wiki](https://bitbucket.org/gavinband/bgen/wiki/The_Setter_API).  The main breaking changes are:
- Renamed operator() to set_value(), and given it an index argument; I think these make the API more consistent.
- Added an initial ploidy argument to set_number_of_entries() as requested.  (The type of data - phased or unphased - is already reported in the order_type argument so I don’t think another argument is needed).
- Added two new method calls, which are optional: set_min_max_ploidy() (useful for setting storage) and finalise().  See the docs for info.

3. I’ve also got rid of the max_id_size option to write_snp_identifying_data().  (This is now not needed because writing BGEN v1.0 files is no longer supported.)

4. I’ve also added some test code (using the [catch framework](https://github.com/philsquared/catch), which seems pretty good).  Tests are not exhaustive but hopefully a start.
:q
5. I've removed some code warnings - thanks to Robert V. Baron of [Mega2](https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html) for testing this code.

23 Sep 2015
----
First version, based on qctool implementation.
# BGEN reference implementation

This repository contains a reference implementation of
the [BGEN format](http://www.well.ox.ac.uk/~gav/bgen_format/bgen_format_v1.2.html), written in C++.
The library can be used as the basis for BGEN support in other software, or as a reference for developers writing 
their own implementations of the BGEN format.

### What's included?
This repository contains the library itself, a set of [example data files](example/),
and a number of example programs (e.g. [bgen_to_vcf](example/bgen_to_vcf.cpp)) that demonstrate the use of the library API.

In addition, a number of utilities built using the library are also included in this repository:

* [bgenix](https://bitbucket.org/gavinband/bgen/wiki/bgenix) - a tool to index and efficiently retrieve subsets of a BGEN file. 
* [cat-bgen](https://bitbucket.org/gavinband/bgen/wiki/cat-bgen) - a tool to efficiently concatenate BGEN files.
* [edit-bgen](https://bitbucket.org/gavinband/bgen/wiki/edit-bgen) - a tool to edit BGEN file metadata.
* An R package called [rbgen](https://bitbucket.org/gavinband/bgen/wiki/rbgen) is also constructed in the build directory.  See the [rbgen wiki page](https://bitbucket.org/gavinband/bgen/wiki/rbgen) for more information on using this package.

### Citing BGEN

If you make use of the BGEN library, its tools or example programs, please cite:

Band, G. and Marchini, J., "*BGEN: a binary file format for imputed genotype and haplotype data*", bioArxiv bioRxiv 308296; doi: https://doi.org/10.1101/308296

Thanks!

### License
This BGEN implementation is released under the Boost Software License v1.0.  This is a relatively permissive open-source license that is compatible with many other open-source licenses.  See [this page](http://www.boost.org/users/license.html) and the file [LICENSE_1_0.txt](https://bitbucket.org/gavinband/bgen/src/tip/LICENSE_1_0.txt) for full details.

This repository also contains code from  the [sqlite](www.sqlite.org), [boost](www.boost.org), and [zstandard](http://www.zstd.net) libraries, which comes with their own respective licenses. (respectively, [public domain](http://www.sqlite.org/copyright.html), the boost software license, and the [BSD license](https://github.com/facebook/zstd/blob/dev/LICENSE)).  These libraries are not used in the core BGEN implementation, but may be used in the example programs provided.

---

### **!! Important note on the UK Biobank data**

The UK Biobank has released [imputed genotype data](http://www.ukbiobank.ac.uk/scientists-3/genetic-data/) for almost half a million individuals
in BGEN format, with accompanying bgenix index files.  The original release of this data (version 2) had an issue with
naming of the index files.  Please see [here](https://bitbucket.org/gavinband/bgen/wiki/Using the UK Biobank full release index files) for information on working around this.  The more recent version of this data (version 3) does not have this issue.

---

# Obtaining and installing BGEN

### In brief

The following commands (typed into a UNIX shell - the dollar symbol indicates the prompt, and shouldn't be typed in)
should perform a basic download and install of the BGEN library, example data and tools:

```bash
$ # get it
$ wget http://bitbucket.org/gavinband/bgen/get/master.tar.gz
$ cd bgen
$ # compile it
$ ./waf configure
$ ./waf
$ # test it
$ ./build/test/unit/test_bgen
$ ./build/apps/bgenix -g example/example.16bits.bgen -list
```

The following sections contains more information on this process.

### Download

A tarball of the latest master branch is available here: http://bitbucket.org/gavinband/bgen/get/master.tar.gz.

Alternatively, use mercurial to download the master branch as follows:
```sh
hg clone https://gavinband@bitbucket.org/gavinband/bgen -u master
```
(This command can take a while.)

Additionally, pre-built version of the bgen utilities may be available from [this page](http://www.well.ox.ac.uk/~gav/resources/).  **Note**: the recommended use is to download and compile bgenix for your platform; these binaries are provided for convenience in getting started quickly.

### Compilation

To compile the code, use the supplied waf build tool:
```sh
./waf configure
./waf
```
Results will appear under the `build/` directory.  

Note: a full build requires a compiler that supports C++11, e.g. gcc v4.7 or above.  To specify the compiler used, set the `CXX` environment variable during the configure step.  For example (if your shell is `bash`):
```
CXX=/path/to/g++ ./waf configure
./waf
```

The sqlite and zstd libraries are written in C; to specify the C compiler you can additionally add `CC=/path/to/gcc`.  We have tested compilation on gcc 4.9.3 and 5.4.0, and using clang, among others.

If you don't have access to a compiler with C++11 support, you can still build the core bgen implementation, but won't be able to build the applications or example programs.
See [the wiki](https://bitbucket.org/gavinband/bgen/wiki/Troubleshooting_compilation) for more information.

### Testing

BGEN's tests can be run by typing 
```sh
./build/test/test_bgen
```
or, for more recent versions:
```sh
./build/test/unit/test_bgen
```

If all goes well a message like `All tests passed` should be printed.

If you have [Robot Test Framework](http://robotframework.org/) installed, you can instead run the full suite of unit and functional tests like so:
```sh
./test/functional/run_tests.sh
```
Test results will be placed in the directory `build/test/functional/test-reports`.


### Trying an example

The example program `bgen_to_vcf` reads a bgen file (v1.1 or v1.2) and outputs it as a VCF file to stdout.  You can try running it
by typing
```sh
./build/example/bgen_to_vcf example/example.8bits.bgen
```
which should output vcf-formatted data to stdout.  We've provided further example bgen files in the `example/` subdirectory.

### Installation

The command
```sh
./waf install
```
will install the applications listed above into a specified system or user directory.  By default this is `/usr/local`.  To change it, specify the prefix at the configure step:
```sh
./waf configure --prefix=/path/to/installation/directory
./waf install
```
The programs listed above will be installed into a folder called `bin/` under the prefix dir, e.g. `bgenix` will be installed as `/path/to/installation/directory/bin/bgenix` etc.

Note that in many cases there's no need for installation; the executables are self-contained.  The install step simply copies them into the destination directory.

(The installation prefix need not be a system-wide directory.  For example, I typically specify an installation directory within my home dir, e.g. `~gav/projects/software/`.

### Branches

This repo follows the branch naming practice in which `master` represents the most up-to-date code considered in a 'releasable' state.  If you are interested in using bgen code in your own project, we therefore recommend cloning the `master` branch.  Code development takes place in the `default` branch and/or in feature branches branched from the `default` branch.  The command given above downloads the master branch, which is what most people will want.

### More information

See the [source code](https://bitbucket.org/gavinband/bgen/src), 
BGEN [releases](https://bitbucket.org/gavinband/bgen/wiki/Releases),
or the [Wiki](https://bitbucket.org/gavinband/bgen/wiki/Home) for more information.<body bgcolor="#ffffff" link="#0000ee" text="#000000" vlink="#551a8b" alink="#ff0000">

![C++ Boost](../../../boost.png)

# `hawick_circuits`

    template <typename Graph, typename Visitor, typename VertexIndexMap>
    void hawick_circuits(Graph const& graph, Visitor visitor, VertexIndexMap const& vim = get(vertex_index, graph));

    template <typename Graph, typename Visitor, typename VertexIndexMap>
    void hawick_unique_circuits(Graph const& graph, Visitor visitor, VertexIndexMap const& vim = get(vertex_index, graph));

Enumerate all the elementary circuits in a directed multigraph. Specifically,
self-loops and redundant circuits caused by parallel edges are enumerated too.
`hawick_unique_circuits` may be used if redundant circuits caused by parallel
edges are not desired.

The algorithm is described in detail in
<http://www.massey.ac.nz/~kahawick/cstn/013/cstn-013.pdf>.


### Where defined

[`#include <boost/graph/hawick_circuits.hpp>`](../../../boost/graph/hawick_circuits.hpp)


### Parameters

__IN:__ `Graph const& graph`

> The graph on which the algorithm is to be performed. It must be a model of
> the `VertexListGraph` and `AdjacencyGraph` concepts.

__IN:__ `Visitor visitor`

> The visitor that will be notified on each circuit found by the algorithm.
> The `visitor.cycle(circuit, graph)` expression must be valid, with `circuit`
> being a `const`-reference to a random access sequence of `vertex_descriptor`s.
>
> For example, if a circuit `u -> v -> w -> u` exists in the graph, the
> visitor will be called with a sequence consisting of `(u, v, w)`.

__IN:__ `VertexIndexMap const& vim = get(vertex_index, graph)`

> A model of the `ReadablePropertyMap` concept mapping each `vertex_descriptor`
> to an integer in the range `[0, num_vertices(graph))`. It defaults to using
> the vertex index map provided by the `graph`.


------------------------------------------------------------------------------
<div class="footer">
    &copy; 2013 Louis Dionne
</div>
 **Zstd**, short for Zstandard, is a fast lossless compression algorithm,
 targeting real-time compression scenarios at zlib-level and better compression ratios.

It is provided as an open-source BSD-licensed **C** library.
For other programming languages,
you can consult a list of known ports on [Zstandard homepage](http://www.zstd.net/#other-languages).

|Branch      |Status   |
|------------|---------|
|master      | [![Build Status](https://travis-ci.org/facebook/zstd.svg?branch=master)](https://travis-ci.org/facebook/zstd) |
|dev         | [![Build Status](https://travis-ci.org/facebook/zstd.svg?branch=dev)](https://travis-ci.org/facebook/zstd) |

As a reference, several fast compression algorithms were tested and compared on a Core i7-3930K CPU @ 4.5GHz, using [lzbench], an open-source in-memory benchmark by @inikep compiled with GCC 5.4.0, with the [Silesia compression corpus].

[lzbench]: https://github.com/inikep/lzbench
[Silesia compression corpus]: http://sun.aei.polsl.pl/~sdeor/index.php?page=silesia


|Name             | Ratio | C.speed | D.speed |
|-----------------|-------|--------:|--------:|
|                 |       |   MB/s  |  MB/s   |
|**zstd 0.8.2 -1**|**2.877**|**330**| **940** |
| [zlib] 1.2.8 -1 | 2.730 |    95   |   360   |
| brotli 0.4 -0   | 2.708 |   320   |   375   |
| QuickLZ 1.5     | 2.237 |   510   |   605   |
| LZO 2.09        | 2.106 |   610   |   870   |
| [LZ4] r131      | 2.101 |   620   |  3100   |
| Snappy 1.1.3    | 2.091 |   480   |  1600   |
| LZF 3.6         | 2.077 |   375   |   790   |

[zlib]:http://www.zlib.net/
[LZ4]: http://www.lz4.org/

Zstd can also offer stronger compression ratios at the cost of compression speed.
Speed vs Compression trade-off is configurable by small increments. Decompression speed is preserved and remains roughly the same at all settings, a property shared by most LZ compression algorithms, such as [zlib] or lzma.

The following tests were run on a Core i7-3930K CPU @ 4.5GHz, using [lzbench], an open-source in-memory benchmark by @inikep compiled with GCC 5.2.1, on the [Silesia compression corpus].

Compression Speed vs Ratio | Decompression Speed
---------------------------|--------------------
![Compression Speed vs Ratio](images/Cspeed4.png "Compression Speed vs Ratio") | ![Decompression Speed](images/Dspeed4.png "Decompression Speed")

Several algorithms can produce higher compression ratios, but at slower speeds, falling outside of the graph.
For a larger picture including very slow modes, [click on this link](images/DCspeed5.png) .


### The case for Small Data compression

Previous charts provide results applicable to typical file and stream scenarios (several MB). Small data comes with different perspectives. The smaller the amount of data to compress, the more difficult it is to achieve any significant compression.

This problem is common to many compression algorithms. The reason is, compression algorithms learn from past data how to compress future data. But at the beginning of a new file, there is no "past" to build upon.

To solve this situation, Zstd offers a __training mode__, which can be used to tune the algorithm for a selected type of data, by providing it with a few samples. The result of the training is stored in a file called "dictionary", which can be loaded before compression and decompression. Using this dictionary, the compression ratio achievable on small data improves dramatically:

![Compressing Small Data](images/smallData.png "Compressing Small Data")

These compression gains are achieved while simultaneously providing faster compression and decompression speeds.

Dictionary works if there is some correlation in a family of small data (there is no _universal dictionary_).
Hence, deploying one dictionary per type of data will provide the greatest benefits. Dictionary gains are mostly effective in the first few KB. Then, the compression algorithm will rely more and more on previously decoded content to compress the rest of the file.

#### Dictionary compression How To :

1) Create the dictionary

`zstd --train FullPathToTrainingSet/* -o dictionaryName`

2) Compress with dictionary

`zstd FILE -D dictionaryName`

3) Decompress with dictionary

`zstd --decompress FILE.zst -D dictionaryName`

### Build

Once you have the repository cloned, there are multiple ways provided to build Zstandard.

#### Makefile

If your system is compatible with a standard `make` (or `gmake`) binary generator,
you can simply run it at the root directory.
It will generate `zstd` within root directory.

Other available options include :
- `make install` : create and install zstd binary, library and man page
- `make test` : create and run `zstd` and test tools on local platform

#### cmake

A `cmake` project generator is provided within `build/cmake`.
It can generate Makefiles or other build scripts
to create `zstd` binary, and `libzstd` dynamic and static libraries.

#### Visual (Windows)

Going into `build` directory, you will find additional possibilities :
- Projects for Visual Studio 2005, 2008 and 2010
  + VS2010 project is compatible with VS2012, VS2013 and VS2015
- Automated build scripts for Visual compiler by @KrzysFR , in `build/VS_scripts`,
  which will build `zstd` cli and `libzstd` library without any need to open Visual Studio solution.


### Status

Zstandard is currently deployed within Facebook. It is used daily to compress and decompress very large amounts of data in multiple formats and use cases.
Zstandard is considered safe for production environments.

### License

Zstandard is [BSD-licensed](LICENSE). We also provide an [additional patent grant](PATENTS).

### Contributing

The "dev" branch is the one where all contributions will be merged before reaching "master".
If you plan to propose a patch, please commit into the "dev" branch or its own feature branch.
Direct commit to "master" are not permitted.
For more information, please read [CONTRIBUTING](CONTRIBUTING.md).

### Miscellaneous

Zstd entropy stage is provided by [Huff0 and FSE, from Finite State Entropy library](https://github.com/Cyan4973/FiniteStateEntropy).
Zstandard Compression Format
============================

### Notices

Copyright (c) 2016 Yann Collet

Permission is granted to copy and distribute this document
for any purpose and without charge,
including translations into other languages
and incorporation into compilations,
provided that the copyright notice and this notice are preserved,
and that any substantive changes or deletions from the original
are clearly marked.
Distribution of this document is unlimited.

### Version

0.2.2 (14/09/16)


Introduction
------------

The purpose of this document is to define a lossless compressed data format,
that is independent of CPU type, operating system,
file system and character set, suitable for
file compression, pipe and streaming compression,
using the [Zstandard algorithm](http://www.zstandard.org).

The data can be produced or consumed,
even for an arbitrarily long sequentially presented input data stream,
using only an a priori bounded amount of intermediate storage,
and hence can be used in data communications.
The format uses the Zstandard compression method,
and optional [xxHash-64 checksum method](http://www.xxhash.org),
for detection of data corruption.

The data format defined by this specification
does not attempt to allow random access to compressed data.

This specification is intended for use by implementers of software
to compress data into Zstandard format and/or decompress data from Zstandard format.
The text of the specification assumes a basic background in programming
at the level of bits and other primitive data representations.

Unless otherwise indicated below,
a compliant compressor must produce data sets
that conform to the specifications presented here.
It doesn’t need to support all options though.

A compliant decompressor must be able to decompress
at least one working set of parameters
that conforms to the specifications presented here.
It may also ignore informative fields, such as checksum.
Whenever it does not support a parameter defined in the compressed stream,
it must produce a non-ambiguous error code and associated error message
explaining which parameter is unsupported.


Overall conventions
-----------
In this document:
- square brackets i.e. `[` and `]` are used to indicate optional fields or parameters.
- a naming convention for identifiers is `Mixed_Case_With_Underscores`

Definitions
-----------
A content compressed by Zstandard is transformed into a Zstandard __frame__.
Multiple frames can be appended into a single file or stream.
A frame is totally independent, has a defined beginning and end,
and a set of parameters which tells the decoder how to decompress it.

A frame encapsulates one or multiple __blocks__.
Each block can be compressed or not,
and has a guaranteed maximum content size, which depends on frame parameters.
Unlike frames, each block depends on previous blocks for proper decoding.
However, each block can be decompressed without waiting for its successor,
allowing streaming operations.


Frame Concatenation
-------------------

In some circumstances, it may be required to append multiple frames,
for example in order to add new data to an existing compressed file
without re-framing it.

In such case, each frame brings its own set of descriptor flags.
Each frame is considered independent.
The only relation between frames is their sequential order.

The ability to decode multiple concatenated frames
within a single stream or file is left outside of this specification.
As an example, the reference `zstd` command line utility is able
to decode all concatenated frames in their sequential order,
delivering the final decompressed result as if it was a single content.


Skippable Frames
----------------

| `Magic_Number` | `Frame_Size` | `User_Data` |
|:--------------:|:------------:|:-----------:|
|   4 bytes      |  4 bytes     |   n bytes   |

Skippable frames allow the insertion of user-defined data
into a flow of concatenated frames.
Its design is pretty straightforward,
with the sole objective to allow the decoder to quickly skip
over user-defined data and continue decoding.

Skippable frames defined in this specification are compatible with [LZ4] ones.

[LZ4]:http://www.lz4.org

__`Magic_Number`__

4 Bytes, little-endian format.
Value : 0x184D2A5X, which means any value from 0x184D2A50 to 0x184D2A5F.
All 16 values are valid to identify a skippable frame.

__`Frame_Size`__

This is the size, in bytes, of the following `User_Data`
(without including the magic number nor the size field itself).
This field is represented using 4 Bytes, little-endian format, unsigned 32-bits.
This means `User_Data` can’t be bigger than (2^32-1) bytes.

__`User_Data`__

The `User_Data` can be anything. Data will just be skipped by the decoder.



General Structure of Zstandard Frame format
-------------------------------------------
The structure of a single Zstandard frame is following:

| `Magic_Number` | `Frame_Header` |`Data_Block`| [More data blocks] | [`Content_Checksum`] |
|:--------------:|:--------------:|:----------:| ------------------ |:--------------------:|
| 4 bytes        |  2-14 bytes    | n bytes    |                    |   0-4 bytes          |

__`Magic_Number`__

4 Bytes, little-endian format.
Value : 0xFD2FB528

__`Frame_Header`__

2 to 14 Bytes, detailed in [next part](#the-structure-of-frame_header).

__`Data_Block`__

Detailed in [next chapter](#the-structure-of-data_block).
That’s where compressed data is stored.

__`Content_Checksum`__

An optional 32-bit checksum, only present if `Content_Checksum_flag` is set.
The content checksum is the result
of [xxh64() hash function](http://www.xxhash.org)
digesting the original (decoded) data as input, and a seed of zero.
The low 4 bytes of the checksum are stored in little endian format.


The structure of `Frame_Header`
-------------------------------
The `Frame_Header` has a variable size, which uses a minimum of 2 bytes,
and up to 14 bytes depending on optional parameters.
The structure of `Frame_Header` is following:

| `Frame_Header_Descriptor` | [`Window_Descriptor`] | [`Dictionary_ID`] | [`Frame_Content_Size`] |
| ------------------------- | --------------------- | ----------------- | ---------------------- |
| 1 byte                    | 0-1 byte              | 0-4 bytes         | 0-8 bytes              |

### `Frame_Header_Descriptor`

The first header's byte is called the `Frame_Header_Descriptor`.
It tells which other fields are present.
Decoding this byte is enough to tell the size of `Frame_Header`.

| Bit number | Field name                |
| ---------- | ----------                |
| 7-6        | `Frame_Content_Size_flag` |
| 5          | `Single_Segment_flag`     |
| 4          | `Unused_bit`              |
| 3          | `Reserved_bit`            |
| 2          | `Content_Checksum_flag`   |
| 1-0        | `Dictionary_ID_flag`      |

In this table, bit 7 is highest bit, while bit 0 is lowest.

__`Frame_Content_Size_flag`__

This is a 2-bits flag (`= Frame_Header_Descriptor >> 6`),
specifying if decompressed data size is provided within the header.
The `Flag_Value` can be converted into `Field_Size`,
which is the number of bytes used by `Frame_Content_Size`
according to the following table:

|`Flag_Value`|    0   |  1  |  2  |  3  |
| ---------- | ------ | --- | --- | --- |
|`Field_Size`| 0 or 1 |  2  |  4  |  8  |

When `Flag_Value` is `0`, `Field_Size` depends on `Single_Segment_flag` :
if `Single_Segment_flag` is set, `Field_Size` is 1.
Otherwise, `Field_Size` is 0 (content size not provided).

__`Single_Segment_flag`__

If this flag is set,
data must be regenerated within a single continuous memory segment.

In this case, `Frame_Content_Size` is necessarily present,
but `Window_Descriptor` byte is skipped.
As a consequence, the decoder must allocate a memory segment
of size equal or bigger than `Frame_Content_Size`.

In order to preserve the decoder from unreasonable memory requirement,
a decoder can reject a compressed frame
which requests a memory size beyond decoder's authorized range.

For broader compatibility, decoders are recommended to support
memory sizes of at least 8 MB.
This is just a recommendation,
each decoder is free to support higher or lower limits,
depending on local limitations.

__`Unused_bit`__

The value of this bit should be set to zero.
A decoder compliant with this specification version shall not interpret it.
It might be used in a future version,
to signal a property which is not mandatory to properly decode the frame.

__`Reserved_bit`__

This bit is reserved for some future feature.
Its value _must be zero_.
A decoder compliant with this specification version must ensure it is not set.
This bit may be used in a future revision,
to signal a feature that must be interpreted to decode the frame correctly.

__`Content_Checksum_flag`__

If this flag is set, a 32-bits `Content_Checksum` will be present at frame's end.
See `Content_Checksum` paragraph.

__`Dictionary_ID_flag`__

This is a 2-bits flag (`= FHD & 3`),
telling if a dictionary ID is provided within the header.
It also specifies the size of this field as `Field_Size`.

|`Flag_Value`|  0  |  1  |  2  |  3  |
| ---------- | --- | --- | --- | --- |
|`Field_Size`|  0  |  1  |  2  |  4  |

### `Window_Descriptor`

Provides guarantees on maximum back-reference distance
that will be used within compressed data.
This information is important for decoders to allocate enough memory.

The `Window_Descriptor` byte is optional. It is absent when `Single_Segment_flag` is set.
In this case, the maximum back-reference distance is the content size itself,
which can be any value from 1 to 2^64-1 bytes (16 EB).

| Bit numbers |     7-3    |     0-2    |
| ----------- | ---------- | ---------- |
| Field name  | `Exponent` | `Mantissa` |

Maximum distance is given by the following formulas :
```
windowLog = 10 + Exponent;
windowBase = 1 << windowLog;
windowAdd = (windowBase / 8) * Mantissa;
Window_Size = windowBase + windowAdd;
```
The minimum window size is 1 KB.
The maximum size is `15*(1<<38)` bytes, which is 1.875 TB.

To properly decode compressed data,
a decoder will need to allocate a buffer of at least `Window_Size` bytes.

In order to preserve decoder from unreasonable memory requirements,
a decoder can refuse a compressed frame
which requests a memory size beyond decoder's authorized range.

For improved interoperability,
decoders are recommended to be compatible with window sizes of 8 MB,
and encoders are recommended to not request more than 8 MB.
It's merely a recommendation though,
decoders are free to support larger or lower limits,
depending on local limitations.

### `Dictionary_ID`

This is a variable size field, which contains
the ID of the dictionary required to properly decode the frame.
Note that this field is optional. When it's not present,
it's up to the caller to make sure it uses the correct dictionary.
Format is little-endian.

Field size depends on `Dictionary_ID_flag`.
1 byte can represent an ID 0-255.
2 bytes can represent an ID 0-65535.
4 bytes can represent an ID 0-4294967295.

It's allowed to represent a small ID (for example `13`)
with a large 4-bytes dictionary ID, losing some compacity in the process.

_Reserved ranges :_
If the frame is going to be distributed in a private environment,
any dictionary ID can be used.
However, for public distribution of compressed frames using a dictionary,
the following ranges are reserved for future use and should not be used :
- low range : 1 - 32767
- high range : >= (2^31)


### `Frame_Content_Size`

This is the original (uncompressed) size. This information is optional.
The `Field_Size` is provided according to value of `Frame_Content_Size_flag`.
The `Field_Size` can be equal to 0 (not present), 1, 2, 4 or 8 bytes.
Format is little-endian.

| `Field_Size` |    Range   |
| ------------ | ---------- |
|      1       |   0 - 255  |
|      2       | 256 - 65791|
|      4       | 0 - 2^32-1 |
|      8       | 0 - 2^64-1 |

When `Field_Size` is 1, 4 or 8 bytes, the value is read directly.
When `Field_Size` is 2, _the offset of 256 is added_.
It's allowed to represent a small size (for example `18`) using any compatible variant.


The structure of `Data_Block`
-----------------------------
The structure of `Data_Block` is following:

| `Last_Block` | `Block_Type` | `Block_Size` | `Block_Content` |
|:------------:|:------------:|:------------:|:---------------:|
|   1 bit      |  2 bits      |  21 bits     |  n bytes        |

The block header (`Last_Block`, `Block_Type`, and `Block_Size`) uses 3-bytes.

__`Last_Block`__

The lowest bit signals if this block is the last one.
Frame ends right after this block.
It may be followed by an optional `Content_Checksum` .

__`Block_Type` and `Block_Size`__

The next 2 bits represent the `Block_Type`,
while the remaining 21 bits represent the `Block_Size`.
Format is __little-endian__.

There are 4 block types :

|    Value     |      0      |     1       |  2                 |    3      |
| ------------ | ----------- | ----------- | ------------------ | --------- |
| `Block_Type` | `Raw_Block` | `RLE_Block` | `Compressed_Block` | `Reserved`|

- `Raw_Block` - this is an uncompressed block.
  `Block_Size` is the number of bytes to read and copy.
- `RLE_Block` - this is a single byte, repeated N times.
  In which case, `Block_Size` is the size to regenerate,
  while the "compressed" block is just 1 byte (the byte to repeat).
- `Compressed_Block` - this is a [Zstandard compressed block](#the-format-of-compressed_block),
  detailed in another section of this specification.
  `Block_Size` is the compressed size.
  Decompressed size is unknown,
  but its maximum possible value is guaranteed (see below)
- `Reserved` - this is not a block.
  This value cannot be used with current version of this specification.

Block sizes must respect a few rules :
- In compressed mode, compressed size if always strictly `< decompressed size`.
- Block decompressed size is always <= maximum back-reference distance .
- Block decompressed size is always <= 128 KB


__`Block_Content`__

The `Block_Content` is where the actual data to decode stands.
It might be compressed or not, depending on previous field indications.
A data block is not necessarily "full" :
since an arbitrary “flush” may happen anytime,
block decompressed content can be any size,
up to `Block_Maximum_Decompressed_Size`, which is the smallest of :
- Maximum back-reference distance
- 128 KB



The format of `Compressed_Block`
--------------------------------
The size of `Compressed_Block` must be provided using `Block_Size` field from `Data_Block`.
The `Compressed_Block` has a guaranteed maximum regenerated size,
in order to properly allocate destination buffer.
See [`Data_Block`](#the-structure-of-data_block) for more details.

A compressed block consists of 2 sections :
- [`Literals_Section`](#literals_section)
- [`Sequences_Section`](#sequences_section)

### Prerequisites
To decode a compressed block, the following elements are necessary :
- Previous decoded blocks, up to a distance of `Window_Size`,
  or all previous blocks when `Single_Segment_flag` is set.
- List of "recent offsets" from previous compressed block.
- Decoding tables of previous compressed block for each symbol type
  (literals, literals lengths, match lengths, offsets).


### `Literals_Section`

During sequence phase, literals will be entangled with match copy operations.
All literals are regrouped in the first part of the block.
They can be decoded first, and then copied during sequence operations,
or they can be decoded on the flow, as needed by sequence commands.

| `Literals_Section_Header` | [`Huffman_Tree_Description`] | Stream1 | [Stream2] | [Stream3] | [Stream4] |
| ------------------------- | ---------------------------- | ------- | --------- | --------- | --------- |

Literals can be stored uncompressed or compressed using Huffman prefix codes.
When compressed, an optional tree description can be present,
followed by 1 or 4 streams.


#### `Literals_Section_Header`

Header is in charge of describing how literals are packed.
It's a byte-aligned variable-size bitfield, ranging from 1 to 5 bytes,
using little-endian convention.

| `Literals_Block_Type` | `Size_Format` | `Regenerated_Size` | [`Compressed_Size`] |
| --------------------- | ------------- | ------------------ | ----------------- |
|   2 bits              |  1 - 2 bits   |    5 - 20 bits     |    0 - 18 bits    |

In this representation, bits on the left are smallest bits.

__`Literals_Block_Type`__

This field uses 2 lowest bits of first byte, describing 4 different block types :

| `Literals_Block_Type`         | Value |
| ----------------------------- | ----- |
| `Raw_Literals_Block`          |   0   |
| `RLE_Literals_Block`          |   1   |
| `Compressed_Literals_Block`   |   2   |
| `Repeat_Stats_Literals_Block` |   3   |

- `Raw_Literals_Block` - Literals are stored uncompressed.
- `RLE_Literals_Block` - Literals consist of a single byte value repeated N times.
- `Compressed_Literals_Block` - This is a standard Huffman-compressed block,
        starting with a Huffman tree description.
        See details below.
- `Repeat_Stats_Literals_Block` - This is a Huffman-compressed block,
        using Huffman tree _from previous Huffman-compressed literals block_.
        Huffman tree description will be skipped.

__`Size_Format`__

`Size_Format` is divided into 2 families :

- For `Compressed_Block`, it requires to decode both `Compressed_Size`
  and `Regenerated_Size` (the decompressed size). It will also decode the number of streams.
- For `Raw_Literals_Block` and `RLE_Literals_Block` it's enough to decode `Regenerated_Size`.

For values spanning several bytes, convention is little-endian.

__`Size_Format` for `Raw_Literals_Block` and `RLE_Literals_Block`__ :

- Value x0 : `Regenerated_Size` uses 5 bits (0-31).
               `Literals_Section_Header` has 1 byte.
               `Regenerated_Size = Header[0]>>3`
- Value 01 : `Regenerated_Size` uses 12 bits (0-4095).
               `Literals_Section_Header` has 2 bytes.
               `Regenerated_Size = (Header[0]>>4) + (Header[1]<<4)`
- Value 11 : `Regenerated_Size` uses 20 bits (0-1048575).
               `Literals_Section_Header` has 3 bytes.
               `Regenerated_Size = (Header[0]>>4) + (Header[1]<<4) + (Header[2]<<12)`

Note : it's allowed to represent a short value (for example `13`)
using a long format, accepting the increased compressed data size.

__`Size_Format` for `Compressed_Literals_Block` and `Repeat_Stats_Literals_Block`__ :

- Value 00 : _A single stream_.
               Both `Compressed_Size` and `Regenerated_Size` use 10 bits (0-1023).
               `Literals_Section_Header` has 3 bytes.
- Value 01 : 4 streams.
               Both `Compressed_Size` and `Regenerated_Size` use 10 bits (0-1023).
               `Literals_Section_Header` has 3 bytes.
- Value 10 : 4 streams.
               Both `Compressed_Size` and `Regenerated_Size` use 14 bits (0-16383).
               `Literals_Section_Header` has 4 bytes.
- Value 11 : 4 streams.
               Both `Compressed_Size` and `Regenerated_Size` use 18 bits (0-262143).
               `Literals_Section_Header` has 5 bytes.

Both `Compressed_Size` and `Regenerated_Size` fields follow little-endian convention.


#### `Huffman_Tree_Description`

This section is only present when `Literals_Block_Type` type is `Compressed_Literals_Block` (`2`).

Prefix coding represents symbols from an a priori known alphabet
by bit sequences (codewords), one codeword for each symbol,
in a manner such that different symbols may be represented
by bit sequences of different lengths,
but a parser can always parse an encoded string
unambiguously symbol-by-symbol.

Given an alphabet with known symbol frequencies,
the Huffman algorithm allows the construction of an optimal prefix code
using the fewest bits of any possible prefix codes for that alphabet.

Prefix code must not exceed a maximum code length.
More bits improve accuracy but cost more header size,
and require more memory or more complex decoding operations.
This specification limits maximum code length to 11 bits.


##### Representation

All literal values from zero (included) to last present one (excluded)
are represented by `Weight` with values from `0` to `Max_Number_of_Bits`.
Transformation from `Weight` to `Number_of_Bits` follows this formula :
```
Number_of_Bits = Weight ? (Max_Number_of_Bits + 1 - Weight) : 0
```
The last symbol's `Weight` is deduced from previously decoded ones,
by completing to the nearest power of 2.
This power of 2 gives `Max_Number_of_Bits`, the depth of the current tree.

__Example__ :
Let's presume the following Huffman tree must be described :

|     literal      |  0  |  1  |  2  |  3  |  4  |  5  |
| ---------------- | --- | --- | --- | --- | --- | --- |
| `Number_of_Bits` |  1  |  2  |  3  |  0  |  4  |  4  |

The tree depth is 4, since its smallest element uses 4 bits.
Value `5` will not be listed, nor will values above `5`.
Values from `0` to `4` will be listed using `Weight` instead of `Number_of_Bits`.
Weight formula is :
```
Weight = Number_of_Bits ? (Max_Number_of_Bits + 1 - Number_of_Bits) : 0
```
It gives the following serie of weights :

| `Weight` |  4  |  3  |  2  |  0  |  1  |
| -------- | --- | --- | --- | --- | --- |
| literal  |  0  |  1  |  2  |  3  |  4  |

The decoder will do the inverse operation :
having collected weights of literals from `0` to `4`,
it knows the last literal, `5`, is present with a non-zero weight.
The weight of `5` can be deducted by joining to the nearest power of 2.
Sum of `2^(Weight-1)` (excluding 0) is :
`8 + 4 + 2 + 0 + 1 = 15`.
Nearest power of 2 is 16.
Therefore, `Max_Number_of_Bits = 4` and `Weight[5] = 1`.

##### Huffman Tree header

This is a single byte value (0-255),
which tells how to decode the list of weights.

- if `headerByte` >= 128 : this is a direct representation,
  where each `Weight` is written directly as a 4 bits field (0-15).
  The full representation occupies `((Number_of_Symbols+1)/2)` bytes,
  meaning it uses a last full byte even if `Number_of_Symbols` is odd.
  `Number_of_Symbols = headerByte - 127`.
  Note that maximum `Number_of_Symbols` is 255-127 = 128.
  A larger serie must necessarily use FSE compression.

- if `headerByte` < 128 :
  the serie of weights is compressed by FSE.
  The length of the FSE-compressed serie is equal to `headerByte` (0-127).

##### Finite State Entropy (FSE) compression of Huffman weights

The serie of weights is compressed using FSE compression.
It's a single bitstream with 2 interleaved states,
sharing a single distribution table.

To decode an FSE bitstream, it is necessary to know its compressed size.
Compressed size is provided by `headerByte`.
It's also necessary to know its _maximum possible_ decompressed size,
which is `255`, since literal values span from `0` to `255`,
and last symbol value is not represented.

An FSE bitstream starts by a header, describing probabilities distribution.
It will create a Decoding Table.
Table must be pre-allocated, which requires to support a maximum accuracy.
For a list of Huffman weights, maximum accuracy is 7 bits.

FSE header is [described in relevant chapter](#fse-distribution-table--condensed-format),
and so is [FSE bitstream](#bitstream).
The main difference is that Huffman header compression uses 2 states,
which share the same FSE distribution table.
Bitstream contains only FSE symbols (no interleaved "raw bitfields").
The number of symbols to decode is discovered
by tracking bitStream overflow condition.
When both states have overflowed the bitstream, end is reached.


##### Conversion from weights to Huffman prefix codes

All present symbols shall now have a `Weight` value.
It is possible to transform weights into Number_of_Bits, using this formula:
```
Number_of_Bits = Number_of_Bits ? Max_Number_of_Bits + 1 - Weight : 0
```
Symbols are sorted by `Weight`. Within same `Weight`, symbols keep natural order.
Symbols with a `Weight` of zero are removed.
Then, starting from lowest weight, prefix codes are distributed in order.

__Example__ :
Let's presume the following list of weights has been decoded :

| Literal  |  0  |  1  |  2  |  3  |  4  |  5  |
| -------- | --- | --- | --- | --- | --- | --- |
| `Weight` |  4  |  3  |  2  |  0  |  1  |  1  |

Sorted by weight and then natural order,
it gives the following distribution :

| Literal          |  3  |  4  |  5  |  2  |  1  |   0  |
| ---------------- | --- | --- | --- | --- | --- | ---- |
| `Weight`         |  0  |  1  |  1  |  2  |  3  |   4  |
| `Number_of_Bits` |  0  |  4  |  4  |  3  |  2  |   1  |
| prefix codes     | N/A | 0000| 0001| 001 | 01  |   1  |


#### The content of Huffman-compressed literal stream

##### Bitstreams sizes

As seen in a previous paragraph,
there are 2 types of Huffman-compressed literals :
a single stream and 4 streams.

Encoding using 4 streams is useful for CPU with multiple execution units and out-of-order operations.
Since each stream can be decoded independently,
it's possible to decode them up to 4x faster than a single stream,
presuming the CPU has enough parallelism available.

For single stream, header provides both the compressed and regenerated size.
For 4 streams though,
header only provides compressed and regenerated size of all 4 streams combined.
In order to properly decode the 4 streams,
it's necessary to know the compressed and regenerated size of each stream.

Regenerated size of each stream can be calculated by `(totalSize+3)/4`,
except for last one, which can be up to 3 bytes smaller, to reach `totalSize`.

Compressed size is provided explicitly : in the 4-streams variant,
bitstreams are preceded by 3 unsigned little-endian 16-bits values.
Each value represents the compressed size of one stream, in order.
The last stream size is deducted from total compressed size
and from previously decoded stream sizes :

`stream4CSize = totalCSize - 6 - stream1CSize - stream2CSize - stream3CSize`.


##### Bitstreams read and decode

Each bitstream must be read _backward_,
that is starting from the end down to the beginning.
Therefore it's necessary to know the size of each bitstream.

It's also necessary to know exactly which _bit_ is the latest.
This is detected by a final bit flag :
the highest bit of latest byte is a final-bit-flag.
Consequently, a last byte of `0` is not possible.
And the final-bit-flag itself is not part of the useful bitstream.
Hence, the last byte contains between 0 and 7 useful bits.

Starting from the end,
it's possible to read the bitstream in a little-endian fashion,
keeping track of already used bits.

Reading the last `Max_Number_of_Bits` bits,
it's then possible to compare extracted value to decoding table,
determining the symbol to decode and number of bits to discard.

The process continues up to reading the required number of symbols per stream.
If a bitstream is not entirely and exactly consumed,
hence reaching exactly its beginning position with _all_ bits consumed,
the decoding process is considered faulty.


### `Sequences_Section`

A compressed block is a succession of _sequences_ .
A sequence is a literal copy command, followed by a match copy command.
A literal copy command specifies a length.
It is the number of bytes to be copied (or extracted) from the literal section.
A match copy command specifies an offset and a length.
The offset gives the position to copy from,
which can be within a previous block.

When all _sequences_ are decoded,
if there is any literal left in the _literal section_,
these bytes are added at the end of the block.

The `Sequences_Section` regroup all symbols required to decode commands.
There are 3 symbol types : literals lengths, offsets and match lengths.
They are encoded together, interleaved, in a single _bitstream_.

The `Sequences_Section` starts by a header,
followed by optional probability tables for each symbol type,
followed by the bitstream.

| `Sequences_Section_Header` | [`Literals_Length_Table`] | [`Offset_Table`] | [`Match_Length_Table`] | bitStream |
| -------------------------- | ------------------------- | ---------------- | ---------------------- | --------- |

To decode the `Sequences_Section`, it's required to know its size.
This size is deducted from `blockSize - literalSectionSize`.


#### `Sequences_Section_Header`

Consists of 2 items:
- `Number_of_Sequences`
- Symbol compression modes

__`Number_of_Sequences`__

This is a variable size field using between 1 and 3 bytes.
Let's call its first byte `byte0`.
- `if (byte0 == 0)` : there are no sequences.
            The sequence section stops there.
            Regenerated content is defined entirely by literals section.
- `if (byte0 < 128)` : `Number_of_Sequences = byte0` . Uses 1 byte.
- `if (byte0 < 255)` : `Number_of_Sequences = ((byte0-128) << 8) + byte1` . Uses 2 bytes.
- `if (byte0 == 255)`: `Number_of_Sequences = byte1 + (byte2<<8) + 0x7F00` . Uses 3 bytes.

__Symbol compression modes__

This is a single byte, defining the compression mode of each symbol type.

|Bit number|   7-6                   |   5-4          |   3-2                |     1-0    |
| -------- | ----------------------- | -------------- | -------------------- | ---------- |
|Field name| `Literals_Lengths_Mode` | `Offsets_Mode` | `Match_Lengths_Mode` | `Reserved` |

The last field, `Reserved`, must be all-zeroes.

`Literals_Lengths_Mode`, `Offsets_Mode` and `Match_Lengths_Mode` define the `Compression_Mode` of
literals lengths, offsets, and match lengths respectively.

They follow the same enumeration :

|        Value       |         0         |      1     |           2           |       3       |
| ------------------ | ----------------- | ---------- | --------------------- | ------------- |
| `Compression_Mode` | `Predefined_Mode` | `RLE_Mode` | `FSE_Compressed_Mode` | `Repeat_Mode` |

- `Predefined_Mode` : uses a predefined distribution table.
- `RLE_Mode` : it's a single code, repeated `Number_of_Sequences` times.
- `Repeat_Mode` : re-use distribution table from previous compressed block.
- `FSE_Compressed_Mode` : standard FSE compression.
          A distribution table will be present.
          It will be described in [next part](#distribution-tables).

#### The codes for literals lengths, match lengths, and offsets.

Each symbol is a _code_ in its own context,
which specifies `Baseline` and `Number_of_Bits` to add.
_Codes_ are FSE compressed,
and interleaved with raw additional bits in the same bitstream.

##### Literals length codes

Literals length codes are values ranging from `0` to `35` included.
They define lengths from 0 to 131071 bytes.

| `Literals_Length_Code` |         0-15           |
| ---------------------- | ---------------------- |
| length                 | `Literals_Length_Code` |
| `Number_of_Bits`       |          0             |

| `Literals_Length_Code` |  16  |  17  |  18  |  19  |  20  |  21  |  22  |  23  |
| ---------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `Baseline`             |  16  |  18  |  20  |  22  |  24  |  28  |  32  |  40  |
| `Number_of_Bits`       |   1  |   1  |   1  |   1  |   2  |   2  |   3  |   3  |

| `Literals_Length_Code` |  24  |  25  |  26  |  27  |  28  |  29  |  30  |  31  |
| ---------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `Baseline`             |  48  |  64  |  128 |  256 |  512 | 1024 | 2048 | 4096 |
| `Number_of_Bits`       |   4  |   6  |   7  |   8  |   9  |  10  |  11  |  12  |

| `Literals_Length_Code` |  32  |  33  |  34  |  35  |
| ---------------------- | ---- | ---- | ---- | ---- |
| `Baseline`             | 8192 |16384 |32768 |65536 |
| `Number_of_Bits`       |  13  |  14  |  15  |  16  |

##### Default distribution for literals length codes

When `Compression_Mode` is `Predefined_Mode`,
a predefined distribution is used for FSE compression.

Below is its definition. It uses an accuracy of 6 bits (64 states).
```
short literalsLength_defaultDistribution[36] =
        { 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1,
         -1,-1,-1,-1 };
```

##### Match length codes

Match length codes are values ranging from `0` to `52` included.
They define lengths from 3 to 131074 bytes.

| `Match_Length_Code` |         0-31            |
| ------------------- | ----------------------- |
| value               | `Match_Length_Code` + 3 |
| `Number_of_Bits`    |          0              |

| `Match_Length_Code` |  32  |  33  |  34  |  35  |  36  |  37  |  38  |  39  |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `Baseline`          |  35  |  37  |  39  |  41  |  43  |  47  |  51  |  59  |
| `Number_of_Bits`    |   1  |   1  |   1  |   1  |   2  |   2  |   3  |   3  |

| `Match_Length_Code` |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `Baseline`          |  67  |  83  |  99  |  131 |  258 |  514 | 1026 | 2050 |
| `Number_of_Bits`    |   4  |   4  |   5  |   7  |   8  |   9  |  10  |  11  |

| `Match_Length_Code` |  48  |  49  |  50  |  51  |  52  |
| ------------------- | ---- | ---- | ---- | ---- | ---- |
| `Baseline`          | 4098 | 8194 |16486 |32770 |65538 |
| `Number_of_Bits`    |  12  |  13  |  14  |  15  |  16  |

##### Default distribution for match length codes

When `Compression_Mode` is defined as `Predefined_Mode`,
a predefined distribution is used for FSE compression.

Below is its definition. It uses an accuracy of 6 bits (64 states).
```
short matchLengths_defaultDistribution[53] =
        { 1, 4, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,
         -1,-1,-1,-1,-1 };
```

##### Offset codes

Offset codes are values ranging from `0` to `N`.

A decoder is free to limit its maximum `N` supported.
Recommendation is to support at least up to `22`.
For information, at the time of this writing.
the reference decoder supports a maximum `N` value of `28` in 64-bits mode.

An offset code is also the number of additional bits to read,
and can be translated into an `Offset_Value` using the following formulas :

```
Offset_Value = (1 << offsetCode) + readNBits(offsetCode);
if (Offset_Value > 3) offset = Offset_Value - 3;
```
It means that maximum `Offset_Value` is `(2^(N+1))-1` and it supports back-reference distance up to `(2^(N+1))-4`
but is limited by [maximum back-reference distance](#window_descriptor).

`Offset_Value` from 1 to 3 are special : they define "repeat codes",
which means one of the previous offsets will be repeated.
They are sorted in recency order, with 1 meaning the most recent one.
See [Repeat offsets](#repeat-offsets) paragraph.


##### Default distribution for offset codes

When `Compression_Mode` is defined as `Predefined_Mode`,
a predefined distribution is used for FSE compression.

Below is its definition. It uses an accuracy of 5 bits (32 states),
and supports a maximum `N` of 28, allowing offset values up to 536,870,908 .

If any sequence in the compressed block requires an offset larger than this,
it's not possible to use the default distribution to represent it.

```
short offsetCodes_defaultDistribution[29] =
        { 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1 };
```

#### Distribution tables

Following the header, up to 3 distribution tables can be described.
When present, they are in this order :
- Literals lengths
- Offsets
- Match Lengths

The content to decode depends on their respective encoding mode :
- `Predefined_Mode` : no content. Use predefined distribution table.
- `RLE_Mode` : 1 byte. This is the only code to use across the whole compressed block.
- `FSE_Compressed_Mode` : A distribution table is present.
- `Repeat_Mode` : no content. Re-use distribution from previous compressed block.

##### FSE distribution table : condensed format

An FSE distribution table describes the probabilities of all symbols
from `0` to the last present one (included)
on a normalized scale of `1 << Accuracy_Log` .

It's a bitstream which is read forward, in little-endian fashion.
It's not necessary to know its exact size,
since it will be discovered and reported by the decoding process.

The bitstream starts by reporting on which scale it operates.
`Accuracy_Log = low4bits + 5`.
Note that maximum `Accuracy_Log` for literal and match lengths is `9`,
and for offsets is `8`. Higher values are considered errors.

Then follows each symbol value, from `0` to last present one.
The number of bits used by each field is variable.
It depends on :

- Remaining probabilities + 1 :
  __example__ :
  Presuming an `Accuracy_Log` of 8,
  and presuming 100 probabilities points have already been distributed,
  the decoder may read any value from `0` to `255 - 100 + 1 == 156` (included).
  Therefore, it must read `log2sup(156) == 8` bits.

- Value decoded : small values use 1 less bit :
  __example__ :
  Presuming values from 0 to 156 (included) are possible,
  255-156 = 99 values are remaining in an 8-bits field.
  They are used this way :
  first 99 values (hence from 0 to 98) use only 7 bits,
  values from 99 to 156 use 8 bits.
  This is achieved through this scheme :

  | Value read | Value decoded | Number of bits used |
  | ---------- | ------------- | ------------------- |
  |   0 -  98  |   0 -  98     |  7                  |
  |  99 - 127  |  99 - 127     |  8                  |
  | 128 - 226  |   0 -  98     |  7                  |
  | 227 - 255  | 128 - 156     |  8                  |

Symbols probabilities are read one by one, in order.

Probability is obtained from Value decoded by following formula :
`Proba = value - 1`

It means value `0` becomes negative probability `-1`.
`-1` is a special probability, which means "less than 1".
Its effect on distribution table is described in [next paragraph].
For the purpose of calculating cumulated distribution, it counts as one.

[next paragraph]:#fse-decoding--from-normalized-distribution-to-decoding-tables

When a symbol has a probability of `zero`,
it is followed by a 2-bits repeat flag.
This repeat flag tells how many probabilities of zeroes follow the current one.
It provides a number ranging from 0 to 3.
If it is a 3, another 2-bits repeat flag follows, and so on.

When last symbol reaches cumulated total of `1 << Accuracy_Log`,
decoding is complete.
If the last symbol makes cumulated total go above `1 << Accuracy_Log`,
distribution is considered corrupted.

Then the decoder can tell how many bytes were used in this process,
and how many symbols are present.
The bitstream consumes a round number of bytes.
Any remaining bit within the last byte is just unused.

##### FSE decoding : from normalized distribution to decoding tables

The distribution of normalized probabilities is enough
to create a unique decoding table.

It follows the following build rule :

The table has a size of `tableSize = 1 << Accuracy_Log`.
Each cell describes the symbol decoded,
and instructions to get the next state.

Symbols are scanned in their natural order for "less than 1" probabilities.
Symbols with this probability are being attributed a single cell,
starting from the end of the table.
These symbols define a full state reset, reading `Accuracy_Log` bits.

All remaining symbols are sorted in their natural order.
Starting from symbol `0` and table position `0`,
each symbol gets attributed as many cells as its probability.
Cell allocation is spreaded, not linear :
each successor position follow this rule :

```
position += (tableSize>>1) + (tableSize>>3) + 3;
position &= tableSize-1;
```

A position is skipped if already occupied,
typically by a "less than 1" probability symbol.

The result is a list of state values.
Each state will decode the current symbol.

To get the `Number_of_Bits` and `Baseline` required for next state,
it's first necessary to sort all states in their natural order.
The lower states will need 1 more bit than higher ones.

__Example__ :
Presuming a symbol has a probability of 5.
It receives 5 state values. States are sorted in natural order.

Next power of 2 is 8.
Space of probabilities is divided into 8 equal parts.
Presuming the `Accuracy_Log` is 7, it defines 128 states.
Divided by 8, each share is 16 large.

In order to reach 8, 8-5=3 lowest states will count "double",
taking shares twice larger,
requiring one more bit in the process.

Numbering starts from higher states using less bits.

| state order      |   0   |   1   |    2   |   3  |   4   |
| ---------------- | ----- | ----- | ------ | ---- | ----- |
| width            |  32   |  32   |   32   |  16  |  16   |
| `Number_of_Bits` |   5   |   5   |    5   |   4  |   4   |
| range number     |   2   |   4   |    6   |   0  |   1   |
| `Baseline`       |  32   |  64   |   96   |   0  |  16   |
| range            | 32-63 | 64-95 | 96-127 | 0-15 | 16-31 |

Next state is determined from current state
by reading the required `Number_of_Bits`, and adding the specified `Baseline`.


#### Bitstream

FSE bitstreams are read in reverse direction than written. In zstd,
the compressor writes bits forward into a block and the decompressor
must read the bitstream _backwards_.

To find the start of the bitstream it is therefore necessary to
know the offset of the last byte of the block which can be found
by counting `Block_Size` bytes after the block header.

After writing the last bit containing information, the compressor
writes a single `1`-bit and then fills the byte with 0-7 `0` bits of
padding. The last byte of the compressed bitstream cannot be `0` for
that reason.

When decompressing, the last byte containing the padding is the first
byte to read. The decompressor needs to skip 0-7 initial `0`-bits and
the first `1`-bit it occurs. Afterwards, the useful part of the bitstream
begins.

##### Starting states

The bitstream starts with initial state values,
each using the required number of bits in their respective _accuracy_,
decoded previously from their normalized distribution.

It starts by `Literals_Length_State`,
followed by `Offset_State`,
and finally `Match_Length_State`.

Reminder : always keep in mind that all values are read _backward_.

##### Decoding a sequence

A state gives a code.
A code provides `Baseline` and `Number_of_Bits` to add.
See [Symbol Decoding] section for details on each symbol.

Decoding starts by reading the `Number_of_Bits` required to decode `Offset`.
It then does the same for `Match_Length`,
and then for `Literals_Length`.

`Offset`, `Match_Length`, and `Literals_Length` define a sequence.
It starts by inserting the number of literals defined by `Literals_Length`,
then continue by copying `Match_Length` bytes from `currentPos - Offset`.

The next operation is to update states.
Using rules pre-calculated in the decoding tables,
`Literals_Length_State` is updated,
followed by `Match_Length_State`,
and then `Offset_State`.

This operation will be repeated `Number_of_Sequences` times.
At the end, the bitstream shall be entirely consumed,
otherwise bitstream is considered corrupted.

[Symbol Decoding]:#the-codes-for-literals-lengths-match-lengths-and-offsets

##### Repeat offsets

As seen in [Offset Codes], the first 3 values define a repeated offset and we will call them `Repeated_Offset1`, `Repeated_Offset2`, and `Repeated_Offset3`.
They are sorted in recency order, with `Repeated_Offset1` meaning "most recent one".

There is an exception though, when current sequence's literals length is `0`.
In which case, repeated offsets are "pushed by one",
so `Repeated_Offset1` becomes `Repeated_Offset2`, `Repeated_Offset2` becomes `Repeated_Offset3`,
and `Repeated_Offset3` becomes `Repeated_Offset1 - 1_byte`.

On first block, offset history is populated by the following values : 1, 4 and 8 (in order).

Then each block receives its start value from previous compressed block.
Note that non-compressed blocks are skipped,
they do not contribute to offset history.

[Offset Codes]: #offset-codes

###### Offset updates rules

New offset take the lead in offset history,
up to its previous place if it was already present.

It means that when `Repeated_Offset1` (most recent) is used, history is unmodified.
When `Repeated_Offset2` is used, it's swapped with `Repeated_Offset1`.


Dictionary format
-----------------

`zstd` is compatible with "raw content" dictionaries, free of any format restriction.
But dictionaries created by `zstd --train` follow a format, described here.

__Pre-requisites__ : a dictionary has a size,
                     defined either by a buffer limit, or a file size.

| `Magic_Number` | `Dictionary_ID` | `Entropy_Tables` | `Content` |
| -------------- | --------------- | ---------------- | --------- |

__`Magic_Number`__ : 4 bytes ID, value 0xEC30A437, little-endian format

__`Dictionary_ID`__ : 4 bytes, stored in little-endian format.
              `Dictionary_ID` can be any value, except 0 (which means no `Dictionary_ID`).
              It's used by decoders to check if they use the correct dictionary.

_Reserved ranges :_
              If the frame is going to be distributed in a private environment,
              any `Dictionary_ID` can be used.
              However, for public distribution of compressed frames,
              the following ranges are reserved for future use and should not be used :

              - low range : 1 - 32767
              - high range : >= (2^31)

__`Entropy_Tables`__ : following the same format as a [compressed blocks].
              They are stored in following order :
              Huffman tables for literals, FSE table for offsets,
              FSE table for match lengths, and FSE table for literals lengths.
              It's finally followed by 3 offset values, populating recent offsets,
              stored in order, 4-bytes little-endian each, for a total of 12 bytes.
              Each recent offset must have a value < dictionary size.

__`Content`__ : The rest of the dictionary is its content.
              The content act as a "past" in front of data to compress or decompress.

[compressed blocks]: #the-format-of-compressed_block

Appendix A - Decoding tables for predefined codes
-------------------------------------------------

This appendix contains FSE decoding tables for the predefined literal length, match length, and offset
codes. The tables have been constructed using the algorithm as given above in the
"from normalized distribution to decoding tables" chapter. The tables here can be used as examples
to crosscheck that an implementation implements the decoding table generation algorithm correctly.

#### Literal Length Code:

| State | Symbol | Number_Of_Bits | Base |
| ----- | ------ | -------------- | ---- |
|     0 |      0 |              4 |    0 |
|     1 |      0 |              4 |   16 |
|     2 |      1 |              5 |   32 |
|     3 |      3 |              5 |    0 |
|     4 |      4 |              5 |    0 |
|     5 |      6 |              5 |    0 |
|     6 |      7 |              5 |    0 |
|     7 |      9 |              5 |    0 |
|     8 |     10 |              5 |    0 |
|     9 |     12 |              5 |    0 |
|    10 |     14 |              6 |    0 |
|    11 |     16 |              5 |    0 |
|    12 |     18 |              5 |    0 |
|    13 |     19 |              5 |    0 |
|    14 |     21 |              5 |    0 |
|    15 |     22 |              5 |    0 |
|    16 |     24 |              5 |    0 |
|    17 |     25 |              5 |   32 |
|    18 |     26 |              5 |    0 |
|    19 |     27 |              6 |    0 |
|    20 |     29 |              6 |    0 |
|    21 |     31 |              6 |    0 |
|    22 |      0 |              4 |   32 |
|    23 |      1 |              4 |    0 |
|    24 |      2 |              5 |    0 |
|    25 |      4 |              5 |   32 |
|    26 |      5 |              5 |    0 |
|    27 |      7 |              5 |   32 |
|    28 |      8 |              5 |    0 |
|    29 |     10 |              5 |   32 |
|    30 |     11 |              5 |    0 |
|    31 |     13 |              6 |    0 |
|    32 |     16 |              5 |   32 |
|    33 |     17 |              5 |    0 |
|    34 |     19 |              5 |   32 |
|    35 |     20 |              5 |    0 |
|    36 |     22 |              5 |   32 |
|    37 |     23 |              5 |    0 |
|    38 |     25 |              4 |    0 |
|    39 |     25 |              4 |   16 |
|    40 |     26 |              5 |   32 |
|    41 |     28 |              6 |    0 |
|    42 |     30 |              6 |    0 |
|    43 |      0 |              4 |   48 |
|    44 |      1 |              4 |   16 |
|    45 |      2 |              5 |   32 |
|    46 |      3 |              5 |   32 |
|    47 |      5 |              5 |   32 |
|    48 |      6 |              5 |   32 |
|    49 |      8 |              5 |   32 |
|    50 |      9 |              5 |   32 |
|    51 |     11 |              5 |   32 |
|    52 |     12 |              5 |   32 |
|    53 |     15 |              6 |    0 |
|    54 |     17 |              5 |   32 |
|    55 |     18 |              5 |   32 |
|    56 |     20 |              5 |   32 |
|    57 |     21 |              5 |   32 |
|    58 |     23 |              5 |   32 |
|    59 |     24 |              5 |   32 |
|    60 |     35 |              6 |    0 |
|    61 |     34 |              6 |    0 |
|    62 |     33 |              6 |    0 |
|    63 |     32 |              6 |    0 |

#### Match Length Code:

| State | Symbol | Number_Of_Bits | Base |
| ----- | ------ | -------------- | ---- |
|     0 |      0 |              6 |    0 |
|     1 |      1 |              4 |    0 |
|     2 |      2 |              5 |   32 |
|     3 |      3 |              5 |    0 |
|     4 |      5 |              5 |    0 |
|     5 |      6 |              5 |    0 |
|     6 |      8 |              5 |    0 |
|     7 |     10 |              6 |    0 |
|     8 |     13 |              6 |    0 |
|     9 |     16 |              6 |    0 |
|    10 |     19 |              6 |    0 |
|    11 |     22 |              6 |    0 |
|    12 |     25 |              6 |    0 |
|    13 |     28 |              6 |    0 |
|    14 |     31 |              6 |    0 |
|    15 |     33 |              6 |    0 |
|    16 |     35 |              6 |    0 |
|    17 |     37 |              6 |    0 |
|    18 |     39 |              6 |    0 |
|    19 |     41 |              6 |    0 |
|    20 |     43 |              6 |    0 |
|    21 |     45 |              6 |    0 |
|    22 |      1 |              4 |   16 |
|    23 |      2 |              4 |    0 |
|    24 |      3 |              5 |   32 |
|    25 |      4 |              5 |    0 |
|    26 |      6 |              5 |   32 |
|    27 |      7 |              5 |    0 |
|    28 |      9 |              6 |    0 |
|    29 |     12 |              6 |    0 |
|    30 |     15 |              6 |    0 |
|    31 |     18 |              6 |    0 |
|    32 |     21 |              6 |    0 |
|    33 |     24 |              6 |    0 |
|    34 |     27 |              6 |    0 |
|    35 |     30 |              6 |    0 |
|    36 |     32 |              6 |    0 |
|    37 |     34 |              6 |    0 |
|    38 |     36 |              6 |    0 |
|    39 |     38 |              6 |    0 |
|    40 |     40 |              6 |    0 |
|    41 |     42 |              6 |    0 |
|    42 |     44 |              6 |    0 |
|    43 |      1 |              4 |   32 |
|    44 |      1 |              4 |   48 |
|    45 |      2 |              4 |   16 |
|    46 |      4 |              5 |   32 |
|    47 |      5 |              5 |   32 |
|    48 |      7 |              5 |   32 |
|    49 |      8 |              5 |   32 |
|    50 |     11 |              6 |    0 |
|    51 |     14 |              6 |    0 |
|    52 |     17 |              6 |    0 |
|    53 |     20 |              6 |    0 |
|    54 |     23 |              6 |    0 |
|    55 |     26 |              6 |    0 |
|    56 |     29 |              6 |    0 |
|    57 |     52 |              6 |    0 |
|    58 |     51 |              6 |    0 |
|    59 |     50 |              6 |    0 |
|    60 |     49 |              6 |    0 |
|    61 |     48 |              6 |    0 |
|    62 |     47 |              6 |    0 |
|    63 |     46 |              6 |    0 |

#### Offset Code:

| State | Symbol | Number_Of_Bits | Base |
| ----- | ------ | -------------- | ---- |
|     0 |      0 |              5 |    0 |
|     1 |      6 |              4 |    0 |
|     2 |      9 |              5 |    0 |
|     3 |     15 |              5 |    0 |
|     4 |     21 |              5 |    0 |
|     5 |      3 |              5 |    0 |
|     6 |      7 |              4 |    0 |
|     7 |     12 |              5 |    0 |
|     8 |     18 |              5 |    0 |
|     9 |     23 |              5 |    0 |
|    10 |      5 |              5 |    0 |
|    11 |      8 |              4 |    0 |
|    12 |     14 |              5 |    0 |
|    13 |     20 |              5 |    0 |
|    14 |      2 |              5 |    0 |
|    15 |      7 |              4 |   16 |
|    16 |     11 |              5 |    0 |
|    17 |     17 |              5 |    0 |
|    18 |     22 |              5 |    0 |
|    19 |      4 |              5 |    0 |
|    20 |      8 |              4 |   16 |
|    21 |     13 |              5 |    0 |
|    22 |     19 |              5 |    0 |
|    23 |      1 |              5 |    0 |
|    24 |      6 |              4 |   16 |
|    25 |     10 |              5 |    0 |
|    26 |     16 |              5 |    0 |
|    27 |     28 |              5 |    0 |
|    28 |     27 |              5 |    0 |
|    29 |     26 |              5 |    0 |
|    30 |     25 |              5 |    0 |
|    31 |     24 |              5 |    0 |

Version changes
---------------
- 0.2.2 : added predefined codes, by Johannes Rudolph
- 0.2.1 : clarify field names, by Przemyslaw Skibinski
- 0.2.0 : numerous format adjustments for zstd v0.8
- 0.1.2 : limit Huffman tree depth to 11 bits
- 0.1.1 : reserved dictID ranges
- 0.1.0 : initial release
# Contributing to Zstandard
We want to make contributing to this project as easy and transparent as
possible.

## Our Development Process
New versions are being developed in the "dev" branch,
or in their own feature branch.
When they are deemed ready for a release, they are merged into "master".

As a consequences, all contributions must stage first through "dev"
or their own feature branch.

## Pull Requests
We actively welcome your pull requests.

1. Fork the repo and create your branch from `dev`.
2. If you've added code that should be tested, add tests.
3. If you've changed APIs, update the documentation.
4. Ensure the test suite passes.
5. Make sure your code lints.
6. If you haven't already, complete the Contributor License Agreement ("CLA").

## Contributor License Agreement ("CLA")
In order to accept your pull request, we need you to submit a CLA. You only need
to do this once to work on any of Facebook's open source projects.

Complete your CLA here: <https://code.facebook.com/cla>

## Issues
We use GitHub issues to track public bugs. Please ensure your description is
clear and has sufficient instructions to be able to reproduce the issue.

Facebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe
disclosure of security bugs. In those cases, please go through the process
outlined on that page and do not file a public issue.

## Coding Style  
* 4 spaces for indentation rather than tabs

## License
By contributing to Zstandard, you agree that your contributions will be licensed
under the [LICENSE](LICENSE) file in the root directory of this source tree.
Zstandard library files
================================

The __lib__ directory contains several directories.
Depending on target use case, it's enough to include only files from relevant directories.


#### API

Zstandard's stable API is exposed within [zstd.h](zstd.h),
at the root of `lib` directory.


#### Advanced API

Some additional API may be useful if you're looking into advanced features :
- common/error_public.h : transforms `size_t` function results into an `enum`,
                          for precise error handling.
- ZSTD_STATIC_LINKING_ONLY : if you define this macro _before_ including `zstd.h`,
                          it will give access to advanced and experimental API.
                          These APIs shall ___never be used with dynamic library___ !
                          They are not "stable", their definition may change in the future.
                          Only static linking is allowed.


#### Modular build

Directory `common/` is required in all circumstances.
You can select to support compression only, by just adding files from the `compress/` directory,
In a similar way, you can build a decompressor-only library with the `decompress/` directory.

Other optional functionalities provided are :

- `dictBuilder/`  : source files to create dictionaries.
                    The API can be consulted in `dictBuilder/zdict.h`.
                    This module also depends on `common/` and `compress/` .

- `legacy/` : source code to decompress previous versions of zstd, starting from `v0.1`.
              This module also depends on `common/` and `decompress/` .
              Library compilation must include directive `ZSTD_LEGACY_SUPPORT = 1` .
              The main API can be consulted in `legacy/zstd_legacy.h`.
              Advanced API from each version can be found in their relevant header file.
              For example, advanced API for version `v0.4` is in `legacy/zstd_v04.h` .


#### Obsolete streaming API

Streaming is now provided within `zstd.h`.
Older streaming API is still provided within `common/zbuff.h`.
It is considered obsolete, and will be removed in a future version.
Consider migrating towards newer streaming API.


#### Miscellaneous

The other files are not source code. There are :

 - LICENSE : contains the BSD license text
 - Makefile : script to compile or install zstd library (static and dynamic)
 - libzstd.pc.in : for pkg-config (`make install`)
 - README.md : this file
Programs and scripts for automated testing of Zstandard
=======================================================

This directory contains the following programs and scripts:
- `datagen` : Synthetic and parametrable data generator, for tests
- `fullbench`  : Precisely measure speed for each zstd inner functions
- `fuzzer`  : Test tool, to check zstd integrity on target platform
- `paramgrill` : parameter tester for zstd
- `test-zstd-speed.py` : script for testing zstd speed difference between commits
- `test-zstd-versions.py` : compatibility test between zstd versions stored on Github (v0.1+)
- `zbufftest`  : Test tool to check ZBUFF (a buffered streaming API) integrity
- `zstreamtest` : Fuzzer test tool for zstd streaming API


#### `test-zstd-versions.py` - script for testing zstd interoperability between versions

This script creates `versionsTest` directory to which zstd repository is cloned.
Then all taged (released) versions of zstd are compiled.
In the following step interoperability between zstd versions is checked.


#### `test-zstd-speed.py` - script for testing zstd speed difference between commits

This script creates `speedTest` directory to which zstd repository is cloned.
Then it compiles all branches of zstd and performs a speed benchmark for a given list of files (the `testFileNames` parameter).
After `sleepTime` (an optional parameter, default 300 seconds) seconds the script checks repository for new commits.
If a new commit is found it is compiled and a speed benchmark for this commit is performed.
The results of the speed benchmark are compared to the previous results.
If compression or decompression speed for one of zstd levels is lower than `lowerLimit` (an optional parameter, default 0.98) the speed benchmark is restarted.
If second results are also lower than `lowerLimit` the warning e-mail is send to recipients from the list (the `emails` parameter).

Additional remarks:
- To be sure that speed results are accurate the script should be run on a "stable" target system with no other jobs running in parallel
- Using the script with virtual machines can lead to large variations of speed results
- The speed benchmark is not performed until computers' load average is lower than `maxLoadAvg` (an optional parameter, default 0.75)
- The script sends e-mails using `mutt`; if `mutt` is not available it sends e-mails without attachments using `mail`; if both are not available it only prints a warning


The example usage with two test files, one e-mail address, and with an additional message:
```
./test-zstd-speed.py "silesia.tar calgary.tar" "email@gmail.com" --message "tested on my laptop" --sleepTime 60
``` 

To run the script in background please use:
```
nohup ./test-zstd-speed.py testFileNames emails &
```

The full list of parameters:
```
positional arguments:
  testFileNames         file names list for speed benchmark
  emails                list of e-mail addresses to send warnings

optional arguments:
  -h, --help            show this help message and exit
  --message MESSAGE     attach an additional message to e-mail
  --lowerLimit LOWERLIMIT
                        send email if speed is lower than given limit
  --maxLoadAvg MAXLOADAVG
                        maximum load average to start testing
  --lastCLevel LASTCLEVEL
                        last compression level for testing
  --sleepTime SLEEPTIME
                        frequency of repository checking in seconds
```
Zstandard wrapper for zlib
================================

The main objective of creating a zstd wrapper for [zlib](http://zlib.net/) is to allow a quick and smooth transition to zstd for projects already using zlib.

#### Required files

To build the zstd wrapper for zlib the following files are required:
- zlib.h
- a static or dynamic zlib library
- zlibWrapper/zstd_zlibwrapper.h
- zlibWrapper/zstd_zlibwrapper.c
- a static or dynamic zstd library

The first two files are required by all projects using zlib and they are not included with the zstd distribution.
The further files are supplied with the zstd distribution.


#### Embedding the zstd wrapper within your project

Let's assume that your project that uses zlib is compiled with:
```gcc project.o -lz```

To compile the zstd wrapper with your project you have to do the following:
- change all references with ```#include "zlib.h"``` to ```#include "zstd_zlibwrapper.h"```
- compile your project with `zstd_zlibwrapper.c` and a static or dynamic zstd library

The linking should be changed to:
```gcc project.o zstd_zlibwrapper.o -lz -lzstd```


#### Enabling zstd compression within your project

After embedding the zstd wrapper within your project the zstd library is turned off by default.
Your project should work as before with zlib. There are two options to enable zstd compression:
- compilation with ```-DZWRAP_USE_ZSTD=1``` (or using ```#define ZWRAP_USE_ZSTD 1``` before ```#include "zstd_zlibwrapper.h"```)
- using the ```void ZWRAP_useZSTDcompression(int turn_on)``` function (declared in ```#include "zstd_zlibwrapper.h"```)

During decompression zlib and zstd streams are automatically detected and decompressed using a proper library.
This behavior can be changed using `ZWRAP_setDecompressionType(ZWRAP_FORCE_ZLIB)` what will make zlib decompression slightly faster.


#### Example
We have take the file ```test/example.c``` from [the zlib library distribution](http://zlib.net/) and copied it to [zlibWrapper/examples/example.c](examples/example.c).
After compilation and execution it shows the following results: 
```
zlib version 1.2.8 = 0x1280, compile flags = 0x65
uncompress(): hello, hello!
gzread(): hello, hello!
gzgets() after gzseek:  hello!
inflate(): hello, hello!
large_inflate(): OK
after inflateSync(): hello, hello!
inflate with dictionary: hello, hello!
```
Then we have changed ```#include "zlib.h"``` to ```#include "zstd_zlibwrapper.h"```, compiled the [example.c](examples/example.c) file
with ```-DZWRAP_USE_ZSTD=1``` and linked with additional ```zstd_zlibwrapper.o -lzstd```.
We were forced to turn off the following functions: ```test_gzio```, ```test_flush```, ```test_sync``` which use currently unsupported features.
After running it shows the following results:
```
zlib version 1.2.8 = 0x1280, compile flags = 0x65
uncompress(): hello, hello!
inflate(): hello, hello!
large_inflate(): OK
inflate with dictionary: hello, hello!
```
The script used for compilation can be found at [zlibWrapper/Makefile](Makefile).


#### The measurement of performace of Zstandard wrapper for zlib

The zstd distribution contains a tool called `zwrapbench` which can measure speed and ratio of zlib, zstd, and the wrapper.
The benchmark is conducted using given filenames or synthetic data if filenames are not provided.
The files are read into memory and joined together. 
It makes benchmark more precise as it eliminates I/O overhead. 
Many filenames can be supplied as multiple parameters, parameters with wildcards or names of directories can be used as parameters with the -r option.
One can select compression levels starting from `-b` and ending with `-e`. The `-i` parameter selects minimal time used for each of tested levels.
With `-B` option bigger files can be divided into smaller, independently compressed blocks. 
The benchmark tool can be compiled with `make zwrapbench` using [zlibWrapper/Makefile](Makefile).


#### Improving speed of streaming compression

During streaming compression the compressor never knows how big is data to compress.
Zstandard compression can be improved by providing size of source data to the compressor. By default streaming compressor assumes that data is bigger than 256 KB but it can hurt compression speed on smaller data. 
The zstd wrapper provides the `ZWRAP_setPledgedSrcSize()` function that allows to change a pledged source size for a given compression stream.
The function will change zstd compression parameters what may improve compression speed and/or ratio.
It should be called just after `deflateInit()`or `deflateReset()` and before `deflate()` or `deflateSetDictionary()`. The function is only helpful when data is compressed in blocks. There will be no change in case of `deflateInit()` or `deflateReset()`  immediately followed by `deflate(strm, Z_FINISH)`
as this case is automatically detected.


#### Reusing contexts

The ordinary zlib compression of two files/streams allocates two contexts:
- for the 1st file calls `deflateInit`, `deflate`, `...`, `deflate`, `defalateEnd`
- for the 2nd file calls `deflateInit`, `deflate`, `...`, `deflate`, `defalateEnd`

The speed of compression can be improved with reusing a single context with following steps:
- initialize the context with `deflateInit`
- for the 1st file call `deflate`, `...`, `deflate`
- for the 2nd file call `deflateReset`, `deflate`, `...`, `deflate`
- free the context with `deflateEnd`

To check the difference we made experiments using `zwrapbench -ri6b6` with zstd and zlib compression (both at level 6).
The input data was decompressed git repository downloaded from https://github.com/git/git/archive/master.zip which contains 2979 files.
The table below shows that reusing contexts has a minor influence on zlib but it gives improvement for zstd.
In our example (the last 2 lines) it gives 4% better compression speed and 5% better decompression speed.

| Compression type                                  | Compression | Decompress.| Compr. size | Ratio |
| ------------------------------------------------- | ------------| -----------| ----------- | ----- |
| zlib 1.2.8                                        |  30.51 MB/s | 219.3 MB/s |     6819783 | 3.459 |
| zlib 1.2.8 not reusing a context                  |  30.22 MB/s | 218.1 MB/s |     6819783 | 3.459 |
| zlib 1.2.8 with zlibWrapper and reusing a context |  30.40 MB/s | 218.9 MB/s |     6819783 | 3.459 |
| zlib 1.2.8 with zlibWrapper not reusing a context |  30.28 MB/s | 218.1 MB/s |     6819783 | 3.459 |
| zstd 1.1.0 using ZSTD_CCtx                        |  68.35 MB/s | 430.9 MB/s |     6868521 | 3.435 |
| zstd 1.1.0 using ZSTD_CStream                     |  66.63 MB/s | 422.3 MB/s |     6868521 | 3.435 |
| zstd 1.1.0 with zlibWrapper and reusing a context |  54.01 MB/s | 403.2 MB/s |     6763482 | 3.488 |
| zstd 1.1.0 with zlibWrapper not reusing a context |  51.59 MB/s | 383.7 MB/s |     6763482 | 3.488 |


#### Compatibility issues
After enabling zstd compression not all native zlib functions are supported. When calling unsupported methods they put error message into strm->msg and return Z_STREAM_ERROR.

Supported methods:
- deflateInit
- deflate (with exception of Z_FULL_FLUSH, Z_BLOCK, and Z_TREES)
- deflateSetDictionary
- deflateEnd
- deflateReset
- deflateBound
- inflateInit
- inflate
- inflateSetDictionary
- inflateReset
- inflateReset2
- compress
- compress2
- compressBound
- uncompress

Ignored methods (they do nothing):
- deflateParams

Unsupported methods:
- gzip file access functions
- deflateCopy
- deflateTune
- deflatePending
- deflatePrime
- deflateSetHeader
- inflateGetDictionary
- inflateCopy
- inflateSync
- inflatePrime
- inflateMark
- inflateGetHeader
- inflateBackInit
- inflateBack
- inflateBackEnd
Zstandard library : usage examples
==================================

- [Simple compression](simple_compression.c) :
  Compress a single file.
  Introduces usage of : `ZSTD_compress()`

- [Simple decompression](simple_decompression.c) :
  Decompress a single file.
  Only compatible with simple compression.
  Result remains in memory.
  Introduces usage of : `ZSTD_decompress()`

- [Streaming compression](streaming_compression.c) :
  Compress a single file.
  Introduces usage of : `ZSTD_compressStream()`

- [Streaming decompression](streaming_decompression.c) :
  Decompress a single file compressed by zstd.
  Compatible with both simple and streaming compression.
  Result is sent to stdout.
  Introduces usage of : `ZSTD_decompressStream()`

- [Dictionary compression](dictionary_compression.c) :
  Compress multiple files using the same dictionary.
  Introduces usage of : `ZSTD_createCDict()` and `ZSTD_compress_usingCDict()`

- [Dictionary decompression](dictionary_decompression.c) :
  Decompress multiple files using the same dictionary.
  Result remains in memory.
  Introduces usage of : `ZSTD_createDDict()` and `ZSTD_decompress_usingDDict()`
Command Line Interface for Zstandard library
============================================

Command Line Interface (CLI) can be created using the `make` command without any additional parameters.
There are however other Makefile targets that create different variations of CLI:
- `zstd` : default CLI supporting gzip-like arguments; includes dictionary builder, benchmark, and support for decompression of legacy zstd versions
- `zstd32` : Same as `zstd`, but forced to compile in 32-bits mode
- `zstd_nolegacy` : Same as `zstd` except of support for decompression of legacy zstd versions
- `zstd-small` : CLI optimized for minimal size; without dictionary builder, benchmark, and support for decompression of legacy zstd versions
- `zstd-compress` : compressor-only version of CLI; without dictionary builder, benchmark, and support for decompression of legacy zstd versions
- `zstd-decompress` : decompressor-only version of CLI; without dictionary builder, benchmark, and support for decompression of legacy zstd versions


#### Aggregation of parameters
CLI supports aggregation of parameters i.e. `-b1`, `-e18`, and `-i1` can be joined into `-b1e18i1`. 


#### Dictionary builder in Command Line Interface
Zstd offers a training mode, which can be used to tune the algorithm for a selected
type of data, by providing it with a few samples. The result of the training is stored
in a file selected with the `-o` option (default name is `dictionary`),
which can be loaded before compression and decompression.

Using a dictionary, the compression ratio achievable on small data improves dramatically.
These compression gains are achieved while simultaneously providing faster compression and decompression speeds.
Dictionary work if there is some correlation in a family of small data (there is no universal dictionary). 
Hence, deploying one dictionary per type of data will provide the greater benefits.
Dictionary gains are mostly effective in the first few KB. Then, the compression algorithm
will rely more and more on previously decoded content to compress the rest of the file.

Usage of the dictionary builder and created dictionaries with CLI:

1. Create the dictionary : `zstd --train FullPathToTrainingSet/* -o dictionaryName`
2. Compress with the dictionary: `zstd FILE -D dictionaryName`
3. Decompress with the dictionary: `zstd --decompress FILE.zst -D dictionaryName`



#### Benchmark in Command Line Interface
CLI includes in-memory compression benchmark module for zstd.
The benchmark is conducted using given filenames. The files are read into memory and joined together.
It makes benchmark more precise as it eliminates I/O overhead.
Many filenames can be supplied as multiple parameters, parameters with wildcards or
names of directories can be used as parameters with the `-r` option.

The benchmark measures ratio, compressed size, compression and decompression speed.
One can select compression levels starting from `-b` and ending with `-e`.
The `-i` parameter selects minimal time used for each of tested levels.



#### Usage of Command Line Interface
The full list of options can be obtained with `-h` or `-H` parameter:
```
Usage :
      zstd [args] [FILE(s)] [-o file]

FILE    : a filename
          with no FILE, or when FILE is - , read standard input
Arguments :
 -#     : # compression level (1-19, default:3)
 -d     : decompression
 -D file: use `file` as Dictionary
 -o file: result stored into `file` (only if 1 input file)
 -f     : overwrite output without prompting
--rm    : remove source file(s) after successful de/compression
 -k     : preserve source file(s) (default)
 -h/-H  : display help/long help and exit

Advanced arguments :
 -V     : display Version number and exit
 -v     : verbose mode; specify multiple times to increase log level (default:2)
 -q     : suppress warnings; specify twice to suppress errors too
 -c     : force write to standard output, even if it is the console
 -r     : operate recursively on directories
--ultra : enable levels beyond 19, up to 22 (requires more memory)
--no-dictID : don't write dictID into header (dictionary compression)
--[no-]check : integrity check (default:enabled)
--test  : test compressed file integrity
--[no-]sparse : sparse mode (default:enabled on file, disabled on stdout)

Dictionary builder :
--train ## : create a dictionary from a training set of files
 -o file : `file` is dictionary name (default: dictionary)
--maxdict ## : limit dictionary to specified size (default : 112640)
 -s#    : dictionary selectivity level (default: 9)
--dictID ## : force dictionary ID to specified value (default: random)

Benchmark arguments :
 -b#    : benchmark file(s), using # compression level (default : 1)
 -e#    : test all compression levels from -bX to # (default: 1)
 -i#    : minimum evaluation time in seconds (default : 3s)
 -B#    : cut file into independent blocks of size # (default: no block)
 ```# Parallel Zstandard (PZstandard)

Parallel Zstandard is a Pigz-like tool for Zstandard.
It provides Zstandard format compatible compression and decompression that is able to utilize multiple cores.
It breaks the input up into equal sized chunks and compresses each chunk independently into a Zstandard frame.
It then concatenates the frames together to produce the final compressed output.
Pzstandard will write a 12 byte header for each frame that is a skippable frame in the Zstandard format, which tells PZstandard the size of the next compressed frame.
PZstandard supports parallel decompression of files compressed with PZstandard.
When decompressing files compressed with Zstandard, PZstandard does IO in one thread, and decompression in another.

## Usage

PZstandard supports the same command line interface as Zstandard, but also provies the `-p` option to specify the number of threads.
Dictionary mode is not currently supported.

Basic usage

    pzstd input-file -o output-file -p num-threads -#          # Compression
    pzstd -d input-file -o output-file -p num-threads          # Decompression

PZstandard also supports piping and fifo pipes

    cat input-file | pzstd -p num-threads -# -c > /dev/null

For more options

    pzstd --help

PZstandard tries to pick a smart default number of threads if not specified (displayed in `pzstd --help`).
If this number is not suitable, during compilation you can define `PZSTD_NUM_THREADS` to the number of threads you prefer.

## Benchmarks

As a reference, PZstandard and Pigz were compared on an Intel Core i7 @ 3.1 GHz, each using 4 threads, with the [Silesia compression corpus](http://sun.aei.polsl.pl/~sdeor/index.php?page=silesia).

Compression Speed vs Ratio with 4 Threads | Decompression Speed with 4 Threads
------------------------------------------|-----------------------------------
![Compression Speed vs Ratio](images/Cspeed.png "Compression Speed vs Ratio") | ![Decompression Speed](images/Dspeed.png "Decompression Speed")

The test procedure was to run each of the following commands 2 times for each compression level, and take the minimum time.

    time pzstd -# -p 4    -c silesia.tar     > silesia.tar.zst
    time pzstd -d -p 4    -c silesia.tar.zst > /dev/null

    time pigz  -# -p 4 -k -c silesia.tar     > silesia.tar.gz
    time pigz  -d -p 4 -k -c silesia.tar.gz  > /dev/null

PZstandard was tested using compression levels 1-19, and Pigz was tested using compression levels 1-9.
Pigz cannot do parallel decompression, it simply does each of reading, decompression, and writing on separate threads.

## Tests

Tests require that you have [gtest](https://github.com/google/googletest) installed.
Modify `GTEST_INC` and `GTEST_LIB` in `test/Makefile` and `utils/test/Makefile` to work for your install of gtest.
Then run `make test` in the `contrib/pzstd` directory.
% File src/library/base/man/load.Rd
\name{bgen.load}
\alias{bgen.load}
\alias{bgen}
\alias{rbgen}
\title{Load genotype data from an indexed BGEN file}
\author{Gavin Band}
\description{
Loads genotypes and associated metadata from specified regions, or specified variants, in a BGEN file.
The BGEN file must have been previously indexed using bgenix.
}
\usage{
bgen.load(
  filename,
  ranges = NULL,
  rsids = NULL,
  max_entries_per_sample = 3,
  samples = NULL,
  index.filename = sprintf( "\%s.bgi", filename )
)
}
\arguments{
  \item{filename}{The name of a BGEN file to load data from.  The corresponding bgenix index file (file.bgi) must also exist.}
  \item{ranges}{A dataframe with 'chromosome', 'start', and 'end' columns, holding genomic regions for which to load data.}
  \item{rsids}{A character vector holding the IDs of variants for which to load data.}
  \item{max_entries_per_sample}{An integer specifying the maximum number of probabilities expected per variant per sample.  This is used to set the third dimension of the data matrix returned.  For biallelic variants and diploid samples, there are three possible genotypes at each variant so the default value will work. For more complex situations you may need to increase this to allocate sufficient space.}
  \item{samples}{A character vector specifying the IDs of samples to load data for.}
  \item{index.filename}{The name of the index file, if different from the default.}
}
\details{
First, the specified BGEN file and its corresponding index file are opened.  Then the index file
is used to locate the data for the specified ranges and rsids.  Then the genotype data is loaded.
}
\value{
A list with several members:
 \item{variants}{a data frame containing the genomic position, IDs, and alleles of loaded variants.  These are ordered as specified by the index, which will usually be order of genomic position.}
 \item{samples}{a vector of identifiers of the samples for which data has been loaded.}
 \item{ploidy}{a matrix of ploidy values, with one row per variant and one column per sample.}
 \item{phased}{a vector of logical values indicating whether data for the variants is phased or not}
 \item{data}{an array of genotype probability values, indexed by variants, samples, and by genotype.}
}
\seealso{
}
\examples{
D = bgen.load( "example/example.16bits.bgen", rsids = c( "RSID_101", "RSID_40" ))
print( D$data[,'sample_001',] )
print( D$data[ 'RSID_40',, ] )
bgen.load( "example/example.16bits.bgen", rsids = c( "RSID_101", "RSID_40" ), samples = c( "sample_001", "sample_101"))
bgen.load( "example/example.16bits.bgen", ranges = data.frame( chromosome = '01', start = 0, end = 5000 ))
D = bgen.load( "example/complex.bgen", ranges = data.frame( chromosome = '01', start = 0, end = 1000 ), max_entries_per_sample = 40 )
D$data[4,,]
}
\keyword{bgen}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAIGE_SKAT_NULL_Model_usingSKATLib_p.R
\name{SKATtest_usingSKATLib}
\alias{SKATtest_usingSKATLib}
\title{Run single variant score tests with SPA based on the logistic mixed model.}
\usage{
SKATtest_usingSKATLib(
  dosageFile = "",
  dosageFileNrowSkip = 0,
  dosageFileNcolSkip = 0,
  dosageFilecolnamesSkip = c("SNPID", "CHR", "POS", "Allele0", "Allele1"),
  dosageFileChrCol = "CHR",
  bgenFile = "",
  bgenFileIndex = "",
  vcfFile = "",
  vcfFileIndex = "",
  vcfField = "DS",
  savFile = "",
  savFileIndex = "",
  sampleFile = "",
  idstoExcludeFile = "",
  idstoIncludeFile = "",
  rangestoExcludeFile = "",
  rangestoIncludeFile = "",
  chrom = "",
  start = 1,
  end = 2.5e+08,
  minMAC = 0.5,
  minMAF = 0,
  maxMAFforGroupTest = 1,
  minInfo = 0,
  SKATmodelFile = "",
  SAIGEOutputFile = "",
  numLinesOutput = 10000,
  IsOutputAFinCaseCtrl = FALSE,
  groupFile = "",
  condition = "",
  kernel = "linear.weighted",
  method = "optimal.adj",
  weights.beta = c(1, 25),
  r.corr = 0
)
}
\arguments{
\item{dosageFile}{character. Path to dosage file. Each line contains dosages for a marker to be tested}

\item{dosageFileNrowSkip}{integer(>=0). Number of lines to be skiped in the dosage file.}

\item{dosageFileNcolSkip}{integer(>=0). Number of columns to be skiped in the dosage file}

\item{dosageFilecolnamesSkip}{vector of characters. The column names of the skipped columns. Default: c("SNPID", "CHR", "POS", "Allele0", "Allele1")}

\item{dosageFileChrCol}{string. The column name for the chromosome column. Must be in the dosageFilecolnamesSkip. Required If LOCO = TRUE and chrom ="".}

\item{bgenFile}{character. Path to bgen file. Currently version 1.2 with 8 bit compression is supported}

\item{bgenFileIndex}{character. Path to the .bgi file (index of the bgen file)}

\item{vcfFile}{character. Path to vcf file}

\item{vcfFileIndex}{character. Path to index for vcf file by tabix, ".tbi" by "tabix -p vcf file.vcf.gz"}

\item{vcfField}{character. genotype field in vcf file to use. "DS" for dosages or "GT" for genotypes. By default, "DS".}

\item{savFile}{character. Path to sav file}

\item{savFileIndex}{character. Path to index for sav file .s1r}

\item{sampleFile}{character. Path to the file that contains one column for IDs of samples in the dosage, vcf, sav, or bgen file with NO header}

\item{idstoExcludeFile}{character. Path to the file containing variant ids to be excluded from the bgen or vcf file}

\item{idstoIncludeFile}{character. Path to the file containing variant ids to be included from the bgen or vcf file}

\item{rangestoExcludeFile}{character. Path to the file containing genome regions to be excluded from the bgen file. The file contains three columns for chromosome, start, and end respectively with no header}

\item{rangestoIncludeFile}{character. Path to the file containing genome regions to be included from the bgen file. The file contains three columns for chromosome, start, and end respectively with no header}

\item{chrom}{character. string for the chromosome to include from vcf file. Required for vcf file. If LOCO is specified, providing chrom will save computation cost}

\item{start}{numeric. start genome position to include from vcf file.}

\item{end}{numeric. end genome position to include from vcf file.}

\item{minMAC}{numeric. Minimum minor allele count of markers to test. By default, 1. The higher threshold between minMAC and minMAF will be used}

\item{minMAF}{numeric. Minimum minor allele frequency of markers to test. By default 0. The higher threshold between minMAC and minMAF will be used}

\item{maxMAFforGroupTest}{numeric. Maximum minor allele frequency of markers to test in group test. By default 1.}

\item{minInfo}{numeric. Minimum imputation info of markers to test (in bgen file)}

\item{SAIGEOutputFile}{character. Path to the output file containing the SPAGMMAT test results}

\item{numLinesOutput}{numeric. Output results for how many marker each time.}

\item{IsOutputAFinCaseCtrl}{logical. Whether to output allele frequency in cases and controls. By default, FALSE}

\item{groupFile}{character. Path to the group file containing one column "GeneID", and one column for ID of the tested genetic markers delimited by comma. This file is space-delimited can only work with the bgen,sav,and vcf format}

\item{GMMATmodelFile}{character. Path to the input file containing the glmm model, which is output from previous step. Will be used by load()}

\item{varianceRatioFile}{character. Path to the input file containing the variance ratio, which is output from the previous step}

\item{Cutoff}{by default = 2 (SPA test would be used when p value < 0.05 under the normal approximation)}

\item{IsSparse}{logical. Whether to exploit the sparsity of the genotype vector for less frequent variants to speed up the SPA tests or not for dichotomous traits. By default, TRUE}

\item{condition.}{For conditional analysis. Genetic marker ids (chr:pos_ref/alt) seperated by comma. e.g.chr3:101651171_C/T,chr3:101651186_G/A. Note that currently conditional analysis is only for vcf/sav input.}
}
\value{
SAIGEOutputFile
}
\description{
Run single variant score tests with SPA based on the logistic mixed model.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CCT_modified.R
\name{CCT}
\alias{CCT}
\title{An analytical p-value combination method using the Cauchy distribution}
\usage{
CCT(pvals, weights = NULL)
}
\arguments{
\item{pvals}{a numeric vector of p-values, where each of the element is
between 0 to 1, to be combined.}

\item{weights}{a numeric vector of non-negative weights. If \code{NULL}, the
equal weights are assumed.}
}
\value{
the aggregated p-value combining p-values from the vector \code{pvals}.
}
\description{
The \code{CCT} function takes in a numeric vector of p-values, a numeric
vector of non-negative weights, and return the aggregated p-value using Cauchy method.
}
\examples{
pvalues <- c(2e-02,4e-04,0.2,0.1,0.8)
CCT(pvals=pvalues)
}
\references{
Liu, Y., & Xie, J. (2020). Cauchy combination test: a powerful test
with analytic p-value calculation under arbitrary dependency structures.
\emph{Journal of the American Statistical Association 115}(529), 393-402.
(\href{https://www.tandfonline.com/doi/full/10.1080/01621459.2018.1554485}{pub})
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAIGE_createSparseGRM.R
\name{createSparseGRM}
\alias{createSparseGRM}
\title{Construct a sparse GRM for a given data set}
\usage{
createSparseGRM(
  plinkFile = "",
  outputPrefix = "",
  numRandomMarkerforSparseKin = 1000,
  relatednessCutoff = 0.125,
  memoryChunk = 2,
  isDiagofKinSetAsOne = FALSE,
  nThreads = 1,
  minMAFforGRM = 0.01,
  isSetGeno = TRUE,
  isWritetoFiles = TRUE
)
}
\arguments{
\item{plinkFile}{character. Path to plink file to be used for calculating the sparse GRM}

\item{outputPrefix}{character. Path to the output files with prefix}

\item{numRandomMarkerforSparseKin}{integer. number of randomly selected markers (MAF >= 0.01) to be used to identify related samples for sparse GRM. By default, 1000}

\item{relatednessCutoff}{float. The threshold to treat two samples as unrelated if IsSparseKin is TRUE. By default, 0.125}

\item{memoryChunk}{integer or float. The size (Gb) for each memory chunk. By default, 2}

\item{isDiagofKinSetAsOne}{logical. Whether to set the diagnal elements in GRM to be 1. By default, FALSE}

\item{nThreads}{integer. Number of threads to be used. By default, 1}

\item{minMAFforGRM}{numeric. Minimum MAF for markers (in the Plink file) used for construcing the sparse GRM. By default, 0.01}
}
\value{
a file ended with sampleIDs.txt that contains sample IDs for the sparse GRM and a file ended with .sparseGRM.mtx that contains the sparse GRM
}
\description{
Construct a sparse GRM for a given data set
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAIGE_SPATest.R
\name{SPAGMMATtest}
\alias{SPAGMMATtest}
\title{Run single variant or gene- or region-based score tests with SPA based on the linear/logistic mixed model.}
\usage{
SPAGMMATtest(
  bgenFile = "",
  bgenFileIndex = "",
  vcfFile = "",
  vcfFileIndex = "",
  vcfField = "DS",
  savFile = "",
  savFileIndex = "",
  sampleFile = "",
  idstoExcludeFile = "",
  idstoIncludeFile = "",
  rangestoExcludeFile = "",
  rangestoIncludeFile = "",
  chrom = "",
  start = 1,
  end = 2.5e+08,
  IsDropMissingDosages = FALSE,
  minMAC = 0.5,
  minMAF = 0,
  maxMAFforGroupTest = 0.5,
  minInfo = 0,
  GMMATmodelFile = "",
  varianceRatioFile = "",
  SPAcutoff = 2,
  SAIGEOutputFile = "",
  numLinesOutput = 10000,
  IsSparse = TRUE,
  IsOutputAFinCaseCtrl = FALSE,
  IsOutputHetHomCountsinCaseCtrl = FALSE,
  IsOutputNinCaseCtrl = FALSE,
  IsOutputlogPforSingle = FALSE,
  LOCO = TRUE,
  condition = "",
  sparseSigmaFile = "",
  groupFile = "",
  kernel = "linear.weighted",
  method = "optimal.adj",
  weights.beta.rare = c(1, 25),
  weights.beta.common = c(1, 25),
  weightMAFcutoff = 0.01,
  weightsIncludeinGroupFile = FALSE,
  weights_for_G2_cond = NULL,
  r.corr = 0,
  IsSingleVarinGroupTest = TRUE,
  cateVarRatioMinMACVecExclude = c(0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 10.5, 20.5),
  cateVarRatioMaxMACVecInclude = c(1.5, 2.5, 3.5, 4.5, 5.5, 10.5, 20.5),
  dosageZerodCutoff = 0.2,
  IsOutputPvalueNAinGroupTestforBinary = FALSE,
  IsAccountforCasecontrolImbalanceinGroupTest = TRUE,
  IsOutputBETASEinBurdenTest = FALSE,
  IsOutputMAFinCaseCtrlinGroupTest = FALSE,
  X_PARregion = "60001-2699520,154931044-155270560",
  is_rewrite_XnonPAR_forMales = FALSE,
  sampleFile_male = "",
  method_to_CollapseUltraRare = "absence_or_presence",
  MACCutoff_to_CollapseUltraRare = 10,
  DosageCutoff_for_UltraRarePresence = 0.5
)
}
\arguments{
\item{bgenFile}{character. Path to bgen file. Currently version 1.2 with 8 bit compression is supported}

\item{bgenFileIndex}{character. Path to the .bgi file (index of the bgen file)}

\item{vcfFile}{character. Path to vcf file}

\item{vcfFileIndex}{character. Path to index for vcf file by tabix, ".tbi" by "tabix -p vcf file.vcf.gz"}

\item{vcfField}{character. genotype field in vcf file to use. "DS" for dosages or "GT" for genotypes. By default, "DS".}

\item{savFile}{character. Path to sav file}

\item{savFileIndex}{character. Path to index for sav file .s1r}

\item{sampleFile}{character. Path to the file that contains one column for IDs of samples in the bgen file with NO header}

\item{idstoExcludeFile}{character. Path to the file containing variant ids to be excluded from the bgen file. The file does not have a header and each line is for a marker ID.}

\item{idstoIncludeFile}{character. Path to the file containing variant ids to be included from the bgen file. The file does not have a header and each line is for a marker ID.}

\item{rangestoExcludeFile}{character. Path to the file containing genome regions to be excluded from the bgen file. The file contains three columns for chromosome, start, and end respectively with no header}

\item{rangestoIncludeFile}{character. Path to the file containing genome regions to be included from the bgen file. The file contains three columns for chromosome, start, and end respectively with no header}

\item{chrom}{character. string for the chromosome to include from vcf file. Required for vcf file. Note: the string needs to exactly match the chromosome string in the vcf/sav file. For example, "1" does not match "chr1". If LOCO is specified, providing chrom will save computation cost}

\item{start}{numeric. start genome position to include from vcf file. By default, 1}

\item{end}{numeric. end genome position to include from vcf file. By default, 250000000}

\item{IsDropMissingDosages}{logical. whether to drop missing dosages (TRUE) or to mean impute missing dosages (FALSE). By default, FALSE. This option only works for bgen, vcf, and sav input.}

\item{minMAC}{numeric. Minimum minor allele count of markers to test. By default, 0.5. The higher threshold between minMAC and minMAF will be used}

\item{minMAF}{numeric. Minimum minor allele frequency of markers to test. By default 0. The higher threshold between minMAC and minMAF will be used}

\item{maxMAFforGroupTest}{numeric. Maximum minor allele frequency of markers to test in group test. By default 0.5.}

\item{minInfo}{numeric. Minimum imputation info of markers to test. By default, 0. This option only works for bgen, vcf, and sav input}

\item{GMMATmodelFile}{character. Path to the input file containing the glmm model, which is output from previous step. Will be used by load()}

\item{varianceRatioFile}{character. Path to the input file containing the variance ratio, which is output from the previous step}

\item{SPAcutoff}{by default = 2 (SPA test would be used when p value < 0.05 under the normal approximation)}

\item{SAIGEOutputFile}{character. Path to the output file containing assoc test results}

\item{numLinesOutput}{numeric. Number of  markers to be output each time. By default, 10000}

\item{IsSparse}{logical. Whether to exploit the sparsity of the genotype vector for less frequent variants to speed up the SPA tests or not for dichotomous traits. By default, TRUE}

\item{IsOutputAFinCaseCtrl}{logical. Whether to output allele frequency in cases and controls. By default, FALSE}

\item{IsOutputHetHomCountsinCaseCtrl}{logical. Whether to output heterozygous and homozygous counts in cases and controls. By default, FALSE. If True, the columns "homN_Allele2_cases", "hetN_Allele2_cases", "homN_Allele2_ctrls", "hetN_Allele2_ctrls" will be output.}

\item{IsOutputNinCaseCtrl}{logical. Whether to output sample sizes in cases and controls. By default, FALSE}

\item{IsOutputlogPforSingle}{logical. Whether to output log(Pvalue) for single-variant assoc tests. By default, FALSE. If TRUE, the log(Pvalue) instead of original P values will be output}

\item{LOCO}{logical. Whether to apply the leave-one-chromosome-out option. By default, TRUE}

\item{condition}{character. For conditional analysis. Genetic marker ids (chr:pos_ref/alt if sav/vcf dosage input , marker id if bgen input) seperated by comma. e.g.chr3:101651171_C/T,chr3:101651186_G/A, Note that currently conditional analysis is only for bgen,vcf,sav input.}

\item{sparseSigmaFile}{character. Path to the file containing the sparseSigma from step 1. The suffix of this file is ".mtx".}

\item{groupFile}{character. Path to the file containing the group information for gene-based tests. Each line is for one gene/set of variants. The first element is for gene/set name. The rest of the line is for variant ids included in this gene/set. For vcf/sav, the genetic marker ids are in the format chr:pos_ref/alt. For bgen, the genetic marker ids should match the ids in the bgen file. Each element in the line is seperated by tab.}

\item{kernel}{character. For gene-based test. By default, "linear.weighted". More options can be seen in the SKAT library}

\item{method}{character. method for gene-based test p-values. By default, "optimal.adj". More options can be seen in the SKAT library}

\item{weights.beta.rare}{vector of numeric. parameters for the beta distribution to weight genetic markers with MAF <= weightMAFcutoff in gene-based tests.By default, "c(1,25)". More options can be seen in the SKAT library}

\item{weights.beta.common}{vector of numeric. parameters for the beta distribution to weight genetic markers with MAF > weightMAFcutoff in gene-based tests.By default, "c(1,25)". More options can be seen in the SKAT library. NOTE: this argument is not fully developed. currently, weights.beta.common is euqal to weights.beta.rare}

\item{weightMAFcutoff}{numeric. Between 0 and 0.5. See document above for weights.beta.rare and weights.beta.common. By default, 0.01}

\item{weightsIncludeinGroupFile}{logical. Whether to specify customized weight for makers in gene- or region-based tests. If TRUE, weights are included in the group file. For vcf/sav, the genetic marker ids and weights are in the format chr:pos_ref/alt;weight. For bgen, the genetic marker ids should match the ids in the bgen filE, e.g. SNPID;weight. Each element in the line is seperated by tab. By default, FALSE}

\item{weights_for_G2_cond}{vector of float. weights for conditioning markers for gene- or region-based tests. The length equals to the number of conditioning markers, delimited by comma. By default, "c(1,2)"}

\item{r.corr}{numeric. bewteen 0 and 1. parameters for gene-based tests.  By default, 0.  More options can be seen in the SKAT library}

\item{IsSingleVarinGroupTest}{logical. Whether to perform single-variant assoc tests for genetic markers included in the gene-based tests. By default, FALSE}

\item{cateVarRatioMinMACVecExclude}{vector of float. Lower bound of MAC for MAC categories. The length equals to the number of MAC categories for variance ratio estimation. By default, c(0.5,1.5,2.5,3.5,4.5,5.5,10.5,20.5). If groupFile="", only one variance ratio corresponding to MAC >= 20 is used}

\item{cateVarRatioMaxMACVecInclude}{vector of float. Higher bound of MAC for MAC categories. The length equals to the number of MAC categories for variance ratio estimation minus 1. By default, c(1.5,2.5,3.5,4.5,5.5,10.5,20.5). If groupFile="", only one variance ratio corresponding to MAC >= 20 is used}

\item{dosageZerodCutoff}{numeric. In gene- or region-based tests, for each variants with MAC <= 10, dosages <= dosageZerodCutoff with be set to 0. By default, 0.2.}

\item{IsOutputPvalueNAinGroupTestforBinary}{logical. In gene- or region-based tests for binary traits. if IsOutputPvalueNAinGroupTestforBinary is TRUE, p-values without accounting for case-control imbalance will be output. By default, FALSE}

\item{IsAccountforCasecontrolImbalanceinGroupTest}{logical. In gene- or region-based tests for binary traits. If IsAccountforCasecontrolImbalanceinGroupTest is TRUE, p-values after accounting for case-control imbalance will be output. By default, TRUE}

\item{IsOutputBETASEinBurdenTest}{logical. Output effect size (BETA and SE) for burden tests. By default, FALSE}

\item{IsOutputMAFinCaseCtrlinGroupTest}{logical. Whether to output minor allele frequency in cases and controls in set-based tests By default, FALSE}

\item{X_PARregion}{character. ranges of (pseudoautosomal) PAR region on chromosome X, which are seperated by comma and in the format start:end. By default: '60001-2699520,154931044-155260560' in the UCSC build hg19. For males, there are two X alleles in the PAR region, so PAR regions are treated the same as autosomes. In the NON-PAR regions (outside the specified PAR regions on chromosome X), for males, there is only one X allele. If is_rewrite_XnonPAR_forMales=TRUE, genotypes/dosages of all variants in the NON-PAR regions on chromosome X will be multiplied by 2.}

\item{is_rewrite_XnonPAR_forMales}{logical. Whether to rewrite gentoypes or dosages of variants in the NON-PAR regions on chromosome X for males (multiply by 2). By default, FALSE. Note, only use is_rewrite_XnonPAR_forMales=TRUE when the specified VCF or Bgen file only has variants on chromosome X. When is_rewrite_XnonPAR_forMales=TRUE, the program does not check the chromosome value by assuming all variants are on chromosome X}

\item{sampleFile_male}{character. Path to the file containing one column for IDs of MALE samples in the bgen or vcf file with NO header. Order does not matter}

\item{method_to_CollapseUltraRare}{character. Method to collpase the ultra rare variants in the set-based association tests. This argument can be 'absence_or_presence', 'sum_geno', or ''. absence_or_presence:  For the resulted collpased marker, any individual having DosageCutoff_for_UltraRarePresence <= dosage < 1+DosageCutoff_for_UltraRarePresence for any ultra rare variant has 1 in the genotype vector, having dosage >= 1+DosageCutoff_for_UltraRarePresence for any ultra rare variant has 2 in the genotype vector, otherwise 0. sum_geno: Ultra rare variants with MAC <=  MACCutoff_to_CollapseUltraRare will be collpased for set-based tests in the 'sum_geno' way and the resulted collpased marker's genotype equals weighted sum of the genotypes of all ultra rare variants. NOTE: this option sum_geno currently is NOT active. By default, "absence_or_presence".}

\item{MACCutoff_to_CollapseUltraRare}{numeric. MAC cutoff to collpase the ultra rare variants (<= MACCutoff_to_CollapseUltraRare) in the set-based association tests. By default, 10.}

\item{DosageCutoff_for_UltraRarePresence}{numeric. Dosage cutoff to determine whether the ultra rare variants are absent or present in the samples. Dosage >= DosageCutoff_for_UltraRarePresence indicates the varaint in present in the sample. 0< DosageCutoff_for_UltraRarePresence <= 2. By default, 0.5.}
}
\value{
SAIGEOutputFile
}
\description{
Run single variant or gene- or region-based score tests with SPA based on the linear/logistic mixed model.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAIGE_fitGLMM_fast.R
\name{fitNULLGLMM}
\alias{fitNULLGLMM}
\title{Fit the null logistic/linear mixed model and estimate the variance ratios by randomly selected variants}
\usage{
fitNULLGLMM(
  plinkFile = "",
  phenoFile = "",
  phenoCol = "",
  traitType = "binary",
  invNormalize = FALSE,
  covarColList = NULL,
  qCovarCol = NULL,
  sampleIDColinphenoFile = "",
  tol = 0.02,
  maxiter = 20,
  tolPCG = 1e-05,
  maxiterPCG = 500,
  nThreads = 1,
  SPAcutoff = 2,
  numMarkers = 30,
  skipModelFitting = FALSE,
  memoryChunk = 2,
  tauInit = c(0, 0),
  LOCO = TRUE,
  traceCVcutoff = 0.0025,
  ratioCVcutoff = 0.001,
  outputPrefix = "",
  outputPrefix_varRatio = NULL,
  IsOverwriteVarianceRatioFile = FALSE,
  IsSparseKin = FALSE,
  sparseGRMFile = NULL,
  sparseGRMSampleIDFile = NULL,
  numRandomMarkerforSparseKin = 1000,
  relatednessCutoff = 0.125,
  isCateVarianceRatio = FALSE,
  cateVarRatioIndexVec = NULL,
  cateVarRatioMinMACVecExclude = c(0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 10.5, 20.5),
  cateVarRatioMaxMACVecInclude = c(1.5, 2.5, 3.5, 4.5, 5.5, 10.5, 20.5),
  isCovariateTransform = TRUE,
  isDiagofKinSetAsOne = FALSE,
  useSparseSigmaConditionerforPCG = FALSE,
  useSparseSigmaforInitTau = FALSE,
  minCovariateCount = -1,
  minMAFforGRM = 0.01,
  useSparseGRMtoFitNULL = FALSE,
  includeNonautoMarkersforVarRatio = FALSE,
  sexCol = "",
  FemaleCode = 1,
  FemaleOnly = FALSE,
  MaleCode = 0,
  MaleOnly = FALSE,
  noEstFixedEff = FALSE,
  skipVarianceRatioEstimation = FALSE
)
}
\arguments{
\item{plinkFile}{character. Path to plink file to be used for calculating elements of the genetic relationship matrix (GRM). minMAFforGRM can be used to specify the minimum MAF of markers in he plink file to be used for constructing GRM. Genetic markers are also randomly selected from the plink file to estimate the variance ratios}

\item{phenoFile}{character. Path to the phenotype file. The phenotype file has a header and contains at least two columns. One column is for phentoype and the other column is for sample IDs. Additional columns can be included in the phenotype file for covariates in the null GLMM. Please note that covariates to be used in the NULL GLMM need to specified using the argument covarColList.}

\item{phenoCol}{character. Column name for the phenotype in phenoFile e.g. "CAD"}

\item{traitType}{character. e.g. "binary" or "quantitative". By default, "binary"}

\item{invNormalize}{logical. Whether to perform the inverse normalization for the phentoype or not. e.g. TRUE or FALSE. By default, FALSE}

\item{covarColList}{vector of characters. Covariates to be used in the null GLM model e.g c("Sex", "Age")}

\item{qCovarCol}{vector of characters. Categorical covariates to be used in the glm model (NOT work yet)}

\item{sampleIDColinphenoFile}{character. Column name for the sample IDs in the phenotype file e.g. "IID".}

\item{tol}{numeric. The tolerance for fitting the null GLMMM to converge. By default, 0.02.}

\item{maxiter}{integer. The maximum number of iterations used to fit the null GLMMM. By default, 20.}

\item{tolPCG}{numeric. The tolerance for PCG to converge. By default, 1e-5.}

\item{maxiterPCG}{integer. The maximum number of iterations for PCG. By default, 500.}

\item{nThreads}{integer. Number of threads to be used. By default, 1}

\item{SPAcutoff}{numeric. The cutoff for the deviation of score test statistics from the mean in the unit of sd to perform SPA. By default, 2.}

\item{numMarkers}{integer (>0). Minimum number of markers to be used for estimating the variance ratio. By default, 30}

\item{skipModelFitting}{logical.  Whether to skip fitting the null model and only calculating the variance ratio, By default, FALSE. If TURE, the model file ".rda" is needed}

\item{memoryChunk}{integer or float. The size (Gb) for each memory chunk. By default, 2}

\item{tauInit}{vector of numbers. e.g. c(1,1), Unitial values for tau. For binary traits, the first element will be always be set to 1. If the tauInit is 0,0, the second element will be 0.5 for binary traits and the initial tau vector for quantitative traits is 1,0}

\item{LOCO}{logical. Whether to apply the leave-one-chromosome-out (LOCO) option. By default, TRUE}

\item{traceCVcutoff}{numeric. The threshold for coefficient of variantion (CV) for the trace estimator to increase nrun. By default, 0.0025}

\item{ratioCVcutoff}{numeric. The threshold for coefficient of variantion (CV) for the variance ratio estimate. If ratioCV > ratioCVcutoff. numMarkers will be increased by 10. By default, 0.001}

\item{outputPrefix}{character. Path to the output files with prefix.}

\item{outputPrefix_varRatio}{character. Path to the output variance ratio file with prefix. variace ratios will be output to outputPrefix_varRatio.varianceRatio.txt. If outputPrefix_varRatio is not specified, outputPrefix_varRatio will be the same as the outputPrefix}

\item{IsOverwriteVarianceRatioFile}{logical. Whether to overwrite the variance ratio file if the file exists. By default, FALSE}

\item{IsSparseKin}{logical. Whether to exploit the sparsity of GRM to estimate the variance ratio. By default, TRUE}

\item{sparseGRMFile}{character. Path to the pre-calculated sparse GRM file. If not specified and IsSparseKin=TRUE, sparse GRM will be computed}

\item{sparseGRMSampleIDFile}{character. Path to the sample ID file for the pre-calculated sparse GRM. No header is included. The order of sample IDs is corresponding to the order of samples in the sparse GRM.}

\item{numRandomMarkerforSparseKin}{integer. number of randomly selected markers (MAF >= 0.01) to be used to identify related samples that are included in the sparse GRM. By default, 2000}

\item{relatednessCutoff}{float. The threshold for coefficient of relatedness to treat two samples as unrelated if IsSparseKin is TRUE. By default, 0.125}

\item{cateVarRatioIndexVec}{vector of integer 0 or 1. The length of cateVarRatioIndexVec is the number of MAC categories for variance ratio estimation. 1 indicates variance ratio in the MAC category is to be estimated, otherwise 0. By default, NULL. If NULL, variance ratios corresponding to all specified MAC categories will be estimated. This argument is only activated when isCateVarianceRatio=TRUE}

\item{cateVarRatioMinMACVecExclude}{vector of float. Lower bound of MAC for MAC categories. The length equals to the number of MAC categories for variance ratio estimation. By default, c(0.5,1.5,2.5,3.5,4.5,5.5,10.5,20.5). This argument is only activated when isCateVarianceRatio=TRUE}

\item{cateVarRatioMaxMACVecInclude}{vector of float. Higher bound of MAC for MAC categories. The length equals to the number of MAC categories for variance ratio estimation minus 1. By default, c(1.5,2.5,3.5,4.5,5.5,10.5,20.5). This argument is only activated when isCateVarianceRatio=TRUE}

\item{isCovariateTransform}{logical. Whether use qr transformation on non-genetic covariates. By default, TRUE}

\item{isDiagofKinSetAsOne}{logical. Whether to set the diagnal elements in GRM to be 1. By default, FALSE}

\item{useSparseSigmaConditionerforPCG}{logical. Whether to use sparse GRM to construct a conditoner for PCG. By default, FALSE. Current this option is deactivated.}

\item{useSparseSigmaforInitTau}{logical. Whether to use sparse GRM to estimate the initial values for fitting the null GLMM. By default, FALSE}

\item{minCovariateCount}{integer. If binary covariates have a count less than this, they will be excluded from the model to avoid convergence issues. By default, -1 (no covariates will be excluded)}

\item{minMAFforGRM}{numeric. Minimum MAF for markers (in the Plink file) used for construcing the sparse GRM. By default, 0.01}

\item{useSparseGRMtoFitNULL}{logical. Whether to use sparse GRM to fit the null GLMM. By default, FALSE}

\item{includeNonautoMarkersforVarRatio}{logical. Whether to allow for non-autosomal markers for variance ratio. By default, FALSE}

\item{sexCol}{character. Coloumn name for sex in the phenotype file, e.g Sex. By default, ''}

\item{FemaleCode}{character. Values in the column for sex (sexCol) in the phenotype file are used for females. By default, '1'}

\item{FemaleOnly}{logical. Whether to run Step 1 for females only. If TRUE, sexCol and FemaleCode need to be specified. By default, FALSE}

\item{MaleCode}{character. Values in the column for sex (sexCol) in the phenotype file are used for males. By default, '0'}

\item{MaleOnly}{logical. Whether to run Step 1 for males only. If TRUE, sexCol and MaleCode need to be specified. By default, FALSE}

\item{noEstFixedEff}{logical. Whether to estimate fixed effect coeffciets. By default, FALSE.}
}
\value{
a file ended with .rda that contains the glmm model information, a file ended with .varianceRatio.txt that contains the variance ratio values, and a file ended with #markers.SPAOut.txt that contains the SPAGMMAT tests results for the markers used for estimating the variance ratio.
}
\description{
Fit the null logistic/linear mixed model and estimate the variance ratios by randomly selected variants
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SAIGE_SKAT_NULL_Model_usingSKATLib.R
\name{fit_SKAT_NULL}
\alias{fit_SKAT_NULL}
\title{Fit the null logistic mixed model and estimate the variance ratio by a set of randomly selected variants}
\usage{
fit_SKAT_NULL(
  kins = NULL,
  phenoFile = "",
  phenoCol = "",
  traitType = "quantitative",
  invNormalize = FALSE,
  covarColList = NULL,
  qCovarCol = NULL,
  sampleIDColinphenoFile = "",
  outputPrefix = "",
  isCovariateTransform = FALSE,
  sampleFileForDosages = "",
  methodforRelatedSample = "EMMAX",
  isDiagofKinSetAsOne = FALSE
)
}
\arguments{
\item{phenoFile}{character. Path to the phenotype file}

\item{phenoCol}{character. Column name for the trait e.g. "CAD"}

\item{traitType}{character. e.g. "binary" or "quantitative". By default, "binary"}

\item{invNormalize}{logical. Whether to perform the inverse normalization of the trait or not. E.g. TRUE or FALSE. By default, FALSE}

\item{covarColList}{vector of characters. Covariates to be used in the glm model e.g c("Sex", "Age")}

\item{qCovarCol}{vector of characters. Categorical covariates to be used in the glm model (NOT work yet)}

\item{sampleIDColinphenoFile}{character.  Column name for the sample IDs in the phenotype file e.g. "IID".}

\item{outputPrefix}{character. Path to the output files with prefix.}

\item{methodforRelatedSample}{character. The method to fit model for related samples. GMMAT or EMMAX}

\item{plinkFile}{character. Path to plink file to be used for calculating elements of the genetic relationship matrix (GRM)}

\item{nThreads}{integer. Number of threads to be used. By default, 1}

\item{numMarkers}{integer (>0). Number of markers to be used for estimating the variance ratio. By default, 30}

\item{skipModelFitting}{logical.  Whether to skip fitting the null model and only calculating the variance ratio, By default, FALSE. If TURE, the model file ".rda" is needed}

\item{tauInit}{vector of numbers. e.g. c(1,1), Unitial values for tau. For binary traits, the first element will be always be set to 1. If the tauInit is not specified, the second element will be 0.5 for binary traits.}

\item{memoryChunk}{integer or float. The size (Gb) for each memory chunk. By default, 4}

\item{LOCO}{logical. Whether to apply the leave-one-chromosome-out (LOCO) option.}

\item{traceCVcutoff}{float. The threshold for coefficient of variantion (CV) for the trace estimator to increase nrun}

\item{isCateVarianceRatio}{logical. Whether to estimate variance ratio based on different MAC categories. If yes, six categories will be used MAC = 1, 2, 3, 4, 5, >5. Currently, if isCateVarianceRatio=TRUE, then LOCO=FALSE}

\item{IsSparseKin}{logical. Whether to exploit the sparsity of GRM to estimate the variance ratio. By default, TRUE}

\item{numRandomMarkerforSparseKin}{integer (>0). Number of markers to be used for first estimating the relatedness between each sample pair  if IsSparseKin is TRUE}

\item{relatednessCutoff}{float. The threshold to treat two samples as unrelated if IsSparseKin is TRUE}
}
\value{
a file ended with .rda that contains the glmm model information, a file ended with .varianceRatio.txt that contains the variance ratio value, and a file ended with #markers.SPAOut.txt that contains the SPAGMMAT tests results for the markers used for estimating the variance ratio.
}
\description{
Fit the null logistic mixed model and estimate the variance ratio by a set of randomly selected variants
}
++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Indirected functions
--------------------

It is quite common that we have two pointers and what to compare the
pointed to objects. Also, we have usually already defined how
to compare the objects. So to avoid some tedious boiler-plate code
this library defines predicates that apply an indirection before comparing.

When the container uses ``void*`` internally, we can use the
class ``void_ptr_indirect_fun``; otherwise we use the class
``indirect_fun``. 

**Example:** ::

    std::string* bar = new std::string("bar");
    std::string* foo = new std::string("foo");
    BOOST_ASSERT( indirect_fun< std::less<std::string> >()( bar, foo ) == true );
    BOOST_ASSERT( make_indirect_fun( std::less<std::string>() )( foo, bar ) == false );   

    void*       vptr1  = ptr1;
    void*       vptr2  = ptr2;
    void_ptr_indirect_fun< std::less<std::string>, std::string> cast_fun;
    BOOST_CHECK( cast_fun( vptr1, vptr2 ) == true );
 
**See also:**

- `result_of <http://www.boost.org/libs/utility/utility.htm#result_of>`_
- `pointee <http://www.boost.org/libs/iterator/doc/pointee.html>`_
- `ptr_set <ptr_set.html>`_
- `ptr_multiset <ptr_multiset.html>`_

**Navigate**

- `home <ptr_container.html>`_
- `reference <reference.html>`_
    
**Remarks:**

The class ``indirect_fun`` will work with smart pointers such as `boost::shared_ptr<T> <http://www.boost.org/libs/smart_ptr/shared_ptr.htm>`_
because of the type traits ``pointee<T>::type`` from the header ``<boost/pointee.hpp>``.
  
**Synopsis:**

Since the definition of the predicates is somewhat trivial, only the
first operation is expanded inline.

::  
           
        namespace boost
        {      

            template< class Fun >
            struct indirect_fun
            {
                indirect_fun() : fun(Fun())
                { }
                
                indirect_fun( Fun f ) : fun(f)
                { }
            
                template< class T >
                typename result_of< Fun( typename pointee<T>::type ) >::type 
                operator()( const T& r ) const
                { 
                    return fun( *r );
                }
            
                template< class T, class U >
                typename result_of< Fun( typename pointee<T>::type, 
                                         typename pointee<U>::type ) >::type 
                operator()( const T& r, const U& r2 ) const
                { 
                    return fun( *r, *r2 );
                }
            
            private:
                Fun fun;
            };
        
            template< class Fun >
            inline indirect_fun<Fun> make_indirect_fun( Fun f )
            {
                return indirect_fun<Fun>( f );
            }        



            template< class Fun, class Arg1, class Arg2 = Arg1 >
            struct void_ptr_indirect_fun
            {
                void_ptr_indirect_fun() : fun(Fun())
                { }
        
                void_ptr_indirect_fun( Fun f ) : fun(f)
                { }
        
                typename result_of< Fun( Arg1 ) >::type 
                operator()( const void* r ) const
                { 
                    return fun( * static_cast<const Arg1*>( r ) );
                }
        
                typename result_of< Fun( Arg1, Arg2 ) >::type 
                operator()( const void* l, const void* r ) const
                { 
                    return fun( * static_cast<const Arg1*>( l ), * static_cast<const Arg2*>( r ) );
                }
                
            private:
                Fun fun;   
            };
        
            template< class Fun, class Arg >
            inline void_ptr_indirect_fun<Fun,Arg> 
            make_void_ptr_indirect_fun( Fun f )
            {
                return void_ptr_indirect_fun<Fun,Arg>( f );
            }
                 
        } // namespace 'boost'  
        
.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_map``
-----------------

A ``ptr_map<Key,T>`` is a pointer container that uses an underlying ``std::map<Key,void*>``
to store the pointers.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - ``ptr_map``
      - `ptr_multimap <ptr_multimap.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {

            template
            < 
                class Key, 
                class T, 
                class Compare        = std::less<Key>, 
                class CloneAllocator = heap_clone_allocator,
                class Allocator      = std::allocator< std::pair<const Key,void*> >
            >
            class ptr_map : public ptr_map_adapter
                                   <
                                       T,
                                       std::map<Key,void*,Compare,Allocator>,
                                       CloneAllocator
                                   >
            {
                // see references
                
            }; //  class 'ptr_map'
        
        } // namespace 'boost'  

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

========
Examples
========

Some examples are given here and in the accompanying test files:

.. contents:: :local: 


.. _`Example 1`:

1. Null pointers cannot be stored in the containers 
+++++++++++++++++++++++++++++++++++++++++++++++++++

::

        my_container.push_back( 0 );            // throws bad_ptr 
        my_container.replace( an_iterator, 0 ); // throws bad_ptr
        my_container.insert( an_iterator, 0 );  // throws bad_ptr       
        std::auto_ptr<T> p( 0 );
        my_container.push_back( p );            // throws bad_ptr                                                          

.. _`Example 2`:

2. Iterators and other operations return indirected values 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

:: 

        ptr_vector<X> pvec; 
        std::vector<X*> vec;
        *vec.begin()  = new X;   // fine, memory leak
        *pvec.begin() = new X;   // compile time error
        ( *vec.begin() )->foo(); // call X::foo(), a bit clumsy
        pvec.begin()->foo();     // no indirection needed
        *vec.front()  = X();     // overwrite first element
        pvec.front()  = X();     // no indirection needed


.. _`Example 3`:

3. Copy-semantics of pointer containers
+++++++++++++++++++++++++++++++++++++++

::

        ptr_vector<T> vec1; 
        ...
        ptr_vector<T> vec2( vec1.clone() ); // deep copy objects of 'vec1' and use them to construct 'vec2', could be very expensive
        vec2 = vec1.release();              // give up ownership of pointers in 'vec1' and pass the ownership to 'vec2', rather cheap
        vec2.release();                     // give up ownership; the objects will be deallocated if not assigned to another container
        vec1 = vec2;                        // deep copy objects of 'vec2' and assign them to 'vec1', could be very expensive 
        ptr_vector<T> vec3( vec1 );         // deep copy objects of 'vec1', could be very expensive


.. _`Example 4`:

4. Making a non-copyable type Cloneable
+++++++++++++++++++++++++++++++++++++++

::
        
         // a class that has no normal copy semantics
        class X : boost::noncopyable { public: X* clone() const; ... };
                                                                           
        // this will be found by the library by argument dependent lookup (ADL)                                                                  
        X* new_clone( const X& x ) 
        { return x.clone(); }
                                                                           
        // we can now use the interface that requires cloneability
        ptr_vector<X> vec1, vec2;
        ...
        vec2 = vec1.clone();                                 // 'clone()' requires cloning <g> 
        vec2.insert( vec2.end(), vec1.begin(), vec1.end() ); // inserting always means inserting clones 


.. _`Example 5`:

5. Objects are cloned before insertion, inserted pointers are owned by the container 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

::

        class X { ... };                     // assume 'X' is Cloneable 
        X x;                                 // and 'X' can be stack-allocated 
        ptr_list<X> list; 
        list.push_back( new_clone( x ) );    // insert a clone
        list.push_back( new X );             // always give the pointer directly to the container to avoid leaks
        list.push_back( &x );                // don't do this!!! 
        std::auto_ptr<X> p( new X );
        list.push_back( p );                 // give up ownership
        BOOST_ASSERT( p.get() == 0 );


.. _`Example 6`:

6. Transferring ownership of a single element 
+++++++++++++++++++++++++++++++++++++++++++++

::

        ptr_deque<T>                    deq; 
        typedef ptr_deque<T>::auto_type auto_type;
        
        // ... fill the container somehow
        
        auto_type ptr  = deq.release_back();             // remove back element from container and give up ownership
        auto_type ptr2 = deq.release( deq.begin() + 2 ); // use an iterator to determine the element to release
        ptr            = deq.release_front();            // supported for 'ptr_list' and 'ptr_deque'
                                        
        deq.push_back( ptr.release() );                  // give ownership back to the container
        

.. _`Example 7`:

7. Transferring ownership of pointers between different pointer containers 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

::


        ptr_list<X> list; ptr_vector<X> vec;
        ...
        //
        // note: no cloning happens in these examples                                
        //
        list.transfer( list.begin(), vec.begin(), vec );           // make the first element of 'vec' the first element of 'list'
        vec.transfer( vec.end(), list.begin(), list.end(), list ); // put all the lists element into the vector                                 
                      
We can also transfer objects from ``ptr_container<Derived>`` to ``ptr_container<Base>`` without any problems.              

.. _`Example 8`:



8. Selected test files 
++++++++++++++++++++++

:incomplete_type_test.cpp_: Shows how to implement the Composite pattern.
:simple_test.cpp_: Shows how the usage of pointer container compares with a 
  container of smart pointers
:view_example.cpp_: Shows how to use a pointer container as a view into other container
:tree_test.cpp_: Shows how to make a tree-structure
:array_test.cpp_: Shows how to make an n-ary tree 

.. _incomplete_type_test.cpp : ../test/incomplete_type_test.cpp
.. _simple_test.cpp : ../test/simple_test.cpp
.. _view_example.cpp : ../test/view_example.cpp
.. _tree_test.cpp : ../test/tree_test.cpp
.. _array_test.cpp : ../test/ptr_array.cpp



9. A large example
++++++++++++++++++

This example shows many of the most common
features at work. The example provide lots of comments.
The source code can also be found `here <../test/tut1.cpp>`_. 

.. raw:: html
        :file: tutorial_example.html

..
                10. Changing the Clone Allocator
                ++++++++++++++++++++++++++++++++

                This example shows how we can change 
                the Clone Allocator to use the pointer containers
                as view into other containers:

                .. raw:: html
                        :file: tut2.html

.. raw:: html 

        <hr>

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

=========
Reference
=========

The documentation is divided into an explanation for 
each container. When containers have the same interface, that common interface is explained only once,
but links are always provided to more relevant information.
Please make sure you understand 
the `Clonable <reference.html#the-Clonable-concept>`_ concept and 
the `Clone Allocator <reference.html#the-clone-allocator-concept>`_ concept. 

- `Conventions <conventions.html>`_
- `The Clonable concept`_
- `The Clone Allocator concept`_

- `Class hierarchy`_:

  - `reversible_ptr_container <reversible_ptr_container.html>`_

    - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

      - `ptr_vector <ptr_vector.html>`_
      - `ptr_list <ptr_list.html>`_ 
      - `ptr_deque <ptr_deque.html>`_
      - `ptr_array <ptr_array.html>`_
    
    - `associative_ptr_container <associative_ptr_container.html>`_ 
  
      - `ptr_set_adapter <ptr_set_adapter.html>`_
      - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
      - `ptr_map_adapter <ptr_map_adapter.html>`_
      - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

        - `ptr_set <ptr_set.html>`_
        - `ptr_multi_set <ptr_multiset.html>`_ 
        - `ptr_map <ptr_map.html>`_
        - `ptr_multimap <ptr_multimap.html>`_
      
- `Serialization`_  
- `Indirected functions <indirect_fun.html>`_  
- `Insert iterators <ptr_inserter.html>`_
- `Class nullable`_     
- `Exception classes`_   
- `Disabling the use of exceptions`_      


..
        - Class `reversible_ptr_container <reversible_ptr_container.html>`_
        - Class `associative_ptr_container <associative_ptr_container.html>`_
        - `Pointer container adapters`_
        
          - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_
          - `ptr_set_adapter <ptr_set_adapter.html>`_
          - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
          - `ptr_map_adapter <ptr_map_adapter.html>`_
          - `ptr_multimap_adapter <ptr_multimap_adapter.html>`_    
        - `Sequence containers`_
        
          - `ptr_vector <ptr_vector.html>`_
          - `ptr_deque <ptr_deque.html>`_
          - `ptr_list <ptr_list.html>`_
          - `ptr_array <ptr_array.html>`_
        - `Associative containers`_
        
          - `ptr_set <ptr_set.html>`_
          - `ptr_multiset <ptr_multiset.html>`_
          - `ptr_map <ptr_map.html>`_
          - `ptr_multimap <ptr_multimap.html>`_



The Clonable concept
++++++++++++++++++++

**Refinement of**

- Heap Allocable
- Heap Deallocable

The Clonable concept is introduced to formalize the requirements for 
copying heap-allocated objects.  A type ``T`` might be Clonable even though it 
is not Assignable or Copy Constructible.  Notice that many operations on 
the containers do not even require the stored type to be Clonable.  

**Notation**

======================= ============================================  =================== =====================
   **Type**                **Object** (``const`` or non-``const``)        **Pointer**        **Describes**
   ``T``                  ``a``                                           ``ptr``            A Clonable type
======================= ============================================  =================== =====================       
       
**Valid expressions**

===================================== =========================== ======================================================================================== ===================================
     **Expression**                          **Type**                  **Semantics**                                                                        **Postcondition**
   ``new_clone(a);``                         ``T*``                  Allocate a new object that can be considered equivalent to the ``a`` object            ``typeid(*new_clone(a)) == typeid(a)``
   ``delete_clone(ptr);``                    ``void``                Deallocate an object previously allocated with ``allocate_clone()``. Must not throw 
===================================== =========================== ======================================================================================== ===================================


Default implementation
----------------------

In the ``<boost/ptr_container/clone_allocator.hpp>`` header a default implementation
of the two functions is given:

.. parsed-literal::

    namespace boost
    {
        template< class T >
        inline T* new_clone( const T& t )
        {
            return new T( t );
        }
    
        template< class T >
        void delete_clone( const T* t )
        {
            checked_delete( t );
        }
    }


Notice that this implementation  makes normal Copy Constructible classes automatically 
Clonable unless ``operator new()`` or ``operator delete()`` are hidden. 

The two functions represent a layer of indirection which is necessary to support 
classes that are not Copy Constructible by default.  Notice that the implementation 
relies on argument-dependent lookup (ADL) to find the right version of 
``new_clone()`` and ``delete_clone()``. This means that one does not need to overload or specialize 
the function in the boost namespace, but it can be placed together with 
the rest of the interface of the class.  If you are implementing a class 
inline in headers, remember to forward declare the functions.
 
**Warning: We are considering the removal of default implementation above. Therefore always make sure that you overload the functions for your types and do not rely on the defaults in any way.**  

The Clone Allocator concept
+++++++++++++++++++++++++++

The Clone Allocator concept is introduced to formalize the way
pointer containers control memory of
the stored objects (and not the pointers to the stored objects).
The clone allocator allows
users to apply custom allocators/deallocators for the cloned objects.

More information can be found below:

..  contents:: :depth: 1 
               :local: 


Clone Allocator requirements
----------------------------

**Notation**

===================== ============================================= ==================================================
   **Type**               **Object** (``const`` or non-``const``)                 **Describes**
       ``T``                 ``a``                                   A type
       ``T*``                ``ptr``                                 A pointer to ``T`` 
===================== ============================================= ==================================================

**Valid expressions**

============================================== ============= ============================================================================= =============================================================
     **Expression**                              **Type**                              **Semantics**                                                                  **Postcondition**
  ``CloneAllocator::allocate_clone(a);``          ``T*``             Allocate a new object that can be considered equivalent to the 
                                                                     ``a`` object                                                          ``typeid(*CloneAllocator::allocate_clone(a)) == typeid(a)``
  ``CloneAllocator::deallocate_clone(ptr);``     ``void``            Deallocate an object previously allocated with 
                                                                     ``CloneAllocator::allocate_clone()`` or a compatible allocator. 
                                                                     Must not throw.
============================================== ============= ============================================================================= =============================================================



The library comes with two predefined clone allocators.

Class ``heap_clone_allocator``
------------------------------

This is the default clone allocator used by all pointer containers. For most
purposes you will never have to change this default. 

**Definition**

.. parsed-literal::

    namespace boost
    {        
        struct heap_clone_allocator
        {
            template< class U >
            static U* allocate_clone( const U& r )
            {
                return new_clone( r );
            }
    
            template< class U >
            static void deallocate_clone( const U* r )
            {
                delete_clone( r );
            }
        };
    }

Notice that the above definition allows you to support custom allocation
schemes by relying on ``new_clone()`` and ``delete_clone()``.
   
Class ``view_clone_allocator``
------------------------------

This class provides a way to remove ownership properties of the
pointer containers. As its name implies, this means that you can
instead use the pointer containers as a view into an existing
container.

**Definition**
 
.. parsed-literal::

    namespace boost
    {
        struct view_clone_allocator
        {
            template< class U >
            static U* allocate_clone( const U& r )
            {
                return const_cast<U*>(&r);
            }
    
            template< class U >
            static void deallocate_clone( const U* )
            {
                // empty
            }
        };
    }

.. **See also**

  - `Changing the clone allocator <examples.html#changing-the-clone-allocator>`_

Class hierarchy
+++++++++++++++

The library consists of the following types of classes:

1. Pointer container adapters

..

2. Pointer containers

The pointer container adapters are used when you
want to make a pointer container starting from
your own "normal" container. For example, you
might have a map class that extends ``std::map``
in some way; the adapter class then allows you
to use your map class as a basis for a new
pointer container.

The library provides an adapter for each type
of standard container highlighted as links below:

- ``reversible_ptr_container``

  - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

    - ``ptr_vector``
    - ``ptr_list``
    - ``ptr_deque``
    - ``ptr_array`` 
    
  - ``associative_ptr_container``
 
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - ``ptr_set``
      - ``ptr_multi_set``
      - ``ptr_map``
      - ``ptr_multimap``


The pointer containers of this library are all built using
the adapters. There is a pointer container
for each type of "normal" standard container highlighted as links below.

- ``reversible_ptr_container``

  - ``ptr_sequence_adapter``

    - `ptr_vector <ptr_vector.html>`_
    - `ptr_list <ptr_list.html>`_ 
    - `ptr_deque <ptr_deque.html>`_
    - `ptr_array <ptr_array.html>`_
    
  - ``associative_ptr_container`` 
  
    - ``ptr_set_adapter``
    - ``ptr_multiset_adapter``
    - ``ptr_map_adapter``
    - ``ptr_multi_map_adapter`` 

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

Serialization
+++++++++++++

As of version 1.34.0 of Boost, the library supports
serialization via `Boost.Serialization`__.

.. __: ../../serialization/index.html

Of course, for serialization to work it is required
that the stored type itself is serializable. For maps, both
the key type and the mapped type must be serializable.

When dealing with serialization (and serialization of polymophic objects in particular), 
pay special attention to these parts of Boost.Serialization:

1. Output/saving requires a const-reference::

        //
        // serialization helper: we can't save a non-const object
        // 
        template< class T >
        inline T const& as_const( T const& r )
        {
            return r;
        }
        ...
        Container cont;

        std::ofstream ofs("filename");
        boost::archive::text_oarchive oa(ofs);
        oa << as_const(cont);

   See `Compile time trap when saving a non-const value`__ for
   details.
   
.. __: ../../serialization/doc/rationale.html#trap

2. Derived classes need to call ``base_object()`` function::

        struct Derived : Base
        {
            template< class Archive >
            void serialize( Archive& ar, const unsigned int version )
            {
                ar & boost::serialization::base_object<Base>( *this );
                ...
            }   
        };
        
   For details, see `Derived Classes`_.
   
.. _`Derived Classes`: ../../serialization/doc/tutorial.html#derivedclasses
            
3. You need to use ``BOOST_CLASS_EXPORT`` to register the
   derived classes in your class hierarchy::
  
        BOOST_CLASS_EXPORT( Derived )

   See `Export Key`__ and `Object Tracking`_
   for details.
   
.. __: ../../serialization/doc/traits.html#export 
.. _`Object Tracking`: ../../serialization/doc/special.html
        
Remember these three issues and it might save you some trouble.

..
        Map iterator operations
        +++++++++++++++++++++++
        
        The map iterators are a bit different compared to the normal ones.  The 
        reason is that it is a bit clumsy to access the key and the mapped object 
        through i->first and i->second, and one tends to forget what is what. 
        Moreover, and more importantly, we also want to hide the pointer as much as possibble.
        The new style can be illustrated with a small example:: 
        
            typedef ptr_map<string,int> map_t;
            map_t  m;
            m[ "foo" ] = 4; // insert pair
            m[ "bar" ] = 5; // ditto
            ...
            for( map_t::iterator i = m.begin(); i != m.end(); ++i )
            {
                     *i += 42; // add 42 to each value
                     cout << "value=" << *i << ", key=" << i.key() << "n";
            } 
            
        So the difference from the normal map iterator is that 
        
        - ``operator*()`` returns a reference to the mapped object (normally it returns a reference to a ``std::pair``, and
        - that the key can be accessed through the ``key()`` function. 

Class ``nullable``
++++++++++++++++++

The purpose of the class is simply to tell the containers
that null values should be allowed. Its definition is
trivial::

    namespace boost
    {
        template< class T >
        struct nullable
        {
            typedef T type;
        };  
    }

Please notice that ``nullable`` has no effect on the containers
interface (except for ``is_null()`` functions). For example, it
does not make sense to do ::

    boost::ptr_vector< boost::nullable<T> > vec;
    vec.push_back( 0 );                      // ok
    vec.push_back( new boost::nullable<T> ); // no no!
    boost::nullable<T>& ref = vec[0];        // also no no!

Exception classes
+++++++++++++++++

There are three exceptions that are thrown by this library.  The exception 
hierarchy looks as follows::

 
        namespace boost
        {
            class bad_ptr_container_operation : public std::exception
            {
            public:
                bad_ptr_container_operation( const char* what );
            };
            
            class bad_index : public bad_ptr_container_operation
            {
            public:
                bad_index( const char* what );
            };
        
            class bad_pointer : public bad_ptr_container_operation
            {
            public:
                bad_pointer();
                bad_pointer( const char* what );
            };
        }
        
Disabling the use of exceptions
+++++++++++++++++++++++++++++++

As of version 1.34.0 of Boost, the library allows you to disable exceptions
completely. This means the library is more fit for domains where exceptions
are not used. Furthermore, it also speeds up a operations a little. Instead
of throwing an exception, the library simply calls `BOOST_ASSERT`__.

.. __: ../../utility/assert.html

To disable exceptions, simply define this macro before including any header::

        #define BOOST_PTR_CONTAINER_NO_EXCEPTIONS 1
        #include <boost/ptr_container/ptr_vector.hpp>
        
It is, however, recommended that you define the macro on the command-line, so
you are absolutely certain that all headers are compiled the same way. Otherwise
you might end up breaking the One Definition Rule.

If ``BOOST_NO_EXCEPTIONS`` is defined, then ``BOOST_PTR_CONTAINER_NO_EXCEPTIONS``
is also defined.

.. raw:: html 

        <hr>

**Navigate:**

- `home <ptr_container.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2007. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Insert Iterators
----------------

When you work with normal value-based containers and algorithms, you often
use insert iterators ::

       std::list<int> coll1;
       // ...
       std::vector<int> coll2;
       std::copy( coll1.begin(), coll1.end(),  
                  back_inserter(coll2) ); 

With the special insert iterators for pointer containers, 
you can do exactly the same ::
            
       boost::ptr_list<Base> coll1;
       // ...
       boost::ptr_vector<Base> coll2;
       std::copy( coll1.begin(), coll1.end(),  
                  boost::ptr_container::ptr_back_inserter(coll2) ); 

Each element is cloned and inserted into the container. Furthermore, 
if the source range iterates over pointers 
instead of references, ``NULL`` pointers
can be transfered as well.
 
**Navigate**

- `home <ptr_container.html>`_
- `reference <reference.html>`_
    
**Synopsis:**

::  
           
        namespace boost
        {      
            namespace ptr_container
            {
            
                template< class PtrContainer >
                class ptr_back_insert_iterator;
                
                template< class PtrContainer >
                class ptr_front_insert_iterator;
                
                template< class PtrContainer >
                class ptr_insert_iterator;
                
                template< class PtrContainer >
                ptr_back_insert_iterator<PtrContainer> 
                ptr_back_inserter( PtrContainer& cont );
                
                template< class PtrContainer >
                ptr_front_insert_iterator<PtrContainer> 
                ptr_front_inserter( PtrContainer& cont );
                
                template< class PtrContainer >
                ptr_insert_iterator<PtrContainer> 
                ptr_inserter( PtrContainer& cont, typename PtrContainer::iterator before );
                 
            } // namespace 'ptr_container'
        } // namespace 'boost'  
        
.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2008. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++

.. |Boost| image:: boost.png

===============
Library headers
===============

======================================================= =============================================================
             **Header**                                    **Includes**

``<boost/ptr_container/clone_allocator.hpp>``            classes heap_clone_allocator_  and view_clone_allocator_
                                                         and functions ``new_clone()`` and ``delete_clone()``

``<boost/ptr_container/ptr_deque.hpp>``                  class `ptr_deque <ptr_deque.html>`_ (and ``std::deque``)

``<boost/ptr_container/ptr_list.hpp>``                   class `ptr_list <ptr_list.html>`_  (and ``std::list``)

``<boost/ptr_container/ptr_vector.hpp>``                 class `ptr_vector <ptr_vector.html>`_ (and ``std::vector``)

``<boost/ptr_container/ptr_array.hpp>``                  class `ptr_array <ptr_array.html>`_ (and ``boost::array``)

``<boost/ptr_container/ptr_set.hpp>``                      classes `ptr_set <ptr_set.html>`_ and `ptr_multiset <ptr_multiset.html>`_
                                                           (and ``std::set`` and ``std::multiset``)

``<boost/ptr_container/ptr_map.hpp>``                      classes `ptr_map <ptr_map.html>`_ and `ptr_multimap <ptr_multimap.html>`_
                                                           (and ``std::map`` and ``std::multimap``)

``<boost/ptr_container/ptr_inserter.hpp>``                 functions `ptr_back_inserter <ptr_inserter.html>`_, `ptr_front_inserter <ptr_inserter.html>`_ and `ptr_inserter <ptr_inserter.html>`_ 

``<boost/ptr_container/ptr_container.hpp>``                all classes

``<boost/ptr_container/ptr_sequence_adapter.hpp>``       class `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

``<boost/ptr_container/ptr_set_adapter.hpp>``            classes `ptr_set_adapter <ptr_set_adapter.html>`_ and `ptr_multiset_adapter <ptr_multiset_adapter.html>`_

``<boost/ptr_container/ptr_map_adapter.hpp>``            classes `ptr_map_adapter <ptr_map_adapter.html>`_ and `ptr_multimap_adapter <ptr_multimap_adapter.html>`_

``<boost/ptr_container/exception.hpp>``                  classes `bad_ptr_container_operation`_, `bad_index`_ and `bad_pointer`_
``<boost/ptr_container/indirect_fun.hpp>``               class `indirect_fun`_

``<boost/ptr_container/nullable.hpp>``                   class `nullable`_

``<boost/ptr_container/serialize_ptr_deque.hpp>``                  class `ptr_deque <ptr_deque.html>`_ with serialization support

``<boost/ptr_container/serialize_ptr_list.hpp>``                   class `ptr_list <ptr_list.html>`_  with serialization support

``<boost/ptr_container/serialize_ptr_vector.hpp>``                 class `ptr_vector <ptr_vector.html>`_ with serialization support

``<boost/ptr_container/serialize_ptr_array.hpp>``                  class `ptr_array <ptr_array.html>`_ with serialization support

``<boost/ptr_container/serialize_ptr_set.hpp>``           classes `ptr_set <ptr_set.html>`_ and `ptr_multiset <ptr_multiset.html>`_ with serialization support

``<boost/ptr_container/serialize_ptr_map.hpp>``           classes `ptr_map <ptr_map.html>`_ and `ptr_multimap <ptr_multimap.html>`_ with serialization support

``<boost/ptr_container/serialize_ptr_container.hpp>``     all classes with serialization support

======================================================= =============================================================

.. _`heap_clone_allocator`: reference.html#the-clone-allocator-concept
.. _`view_clone_allocator`: reference.html#the-clone-allocator-concept
.. _`bad_ptr_container_operation`: reference.html#exception-classes
.. _`bad_index`: reference.html#exception-classes
.. _`bad_pointer`: reference.html#exception-classes
.. _`nullable`: reference.html#class-nullable
.. _`indirect_fun`: indirect_fun.html


**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_vector``
--------------------

A ``ptr_vector<T>`` is a pointer container that uses an underlying ``std::vector<void*>``
to store the pointers. 

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

    - ``ptr_vector``
    - `ptr_list <ptr_list.html>`_
    - `ptr_deque <ptr_deque.html>`_
    - `ptr_array <ptr_array.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

**Synopsis:**

.. parsed-literal::  
           
        namespace boost
        {      
        
            template
            < 
                class T, 
                class CloneAllocator = heap_clone_allocator,
                class Allocator      = std::allocator<void*>
            >
            class ptr_vector : public ptr_sequence_adapter
                                      <
                                          T,
                                          std::vector<void*,Allocator>,
                                          CloneAllocator
                                      >
            {
            public: // `construction`_
                explicit ptr_vector( size_type to_reserve );
            
            public: // capacity_
                size_type  capacity() const;
                void       reserve( size_type n );
            
            public: // `element access`_
                T&        operator[]( size_type n );
                const T&  operator[]( size_type n ) const;
                T&        at( size_type n );
                const T&  at( size_type n ) const;

            public: // `pointer container requirements`_
               auto_type replace( size_type idx, T* x );  
               template< class U >
               auto_type replace( size_type idx, std::auto_ptr<U> x );  
               bool      is_null( size_type idx ) const;
               
            public: // `C-array support`_
               void transfer( iterator before, T** from, size_type size, bool delete_from = true );
               T**  c_array();

            };
           
        } // namespace 'boost'  


Semantics
---------

.. _`construction`:

Semantics: construction
^^^^^^^^^^^^^^^^^^^^^^^

- ``explicit ptr_vector( size_type to_reserve );``

    - constructs an empty vector with a buffer
      of size least ``to_reserve``

.. _`capacity`:

Semantics: capacity
^^^^^^^^^^^^^^^^^^^

- ``size_type capacity() const;``

    - Effects: Returns the size of the allocated buffer

    - Throws: Nothing

- ``void reserve( size_type n );``

    - Requirements: ``n <= max_size()``
                 
    - Effects: Expands the allocated buffer

    - Postcondition: ``capacity() >= n``

    - Throws: ``std::length_error()`` if ``n > max_size()``


.. _`element access`:

Semantics: element access
^^^^^^^^^^^^^^^^^^^^^^^^^

- ``T& operator[]( size_type n );``
- ``const T& operator[]( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: Nothing

- ``T& at( size_type n );``
- ``const T& at( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: ``bad_index`` if ``n >= size()``


.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``auto_type replace( size_type idx, T* x );``    

    - Requirements: `` x != 0 and idx < size()``

    - Effects: returns the object indexed by ``idx`` and replaces it with ``x``.

    - Throws: ``bad_index`` if ``idx >= size()`` and ``bad_pointer`` if ``x == 0``.

    - Exception safety: Strong guarantee

- ``template< class U > auto_type replace( size_type idx, std::auto_ptr<U> x );``

    - Effects: ``return replace( idx, x.release() );``  

- ``bool is_null( size_type idx ) const;``

    - Requirements: ``idx < size()``

    - Effects: returns whether the pointer at index ``idx`` is null

    - Exception safety: Nothrow guarantee


.. _`C-array support`:

Semantics: C-array support
^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``void transfer( iterator before, T** from, size_type size, bool delete_from = true );``

    - Requirements:  ``from != 0``
    
    - Effects: Takes ownership of the dynamic array ``from``
    
    - Exception safety: Strong guarantee if ``delete_from == true``; if ``delete_from == false``,
      and an exception is thrown, the container fails to take ownership.                  
    
    - Remarks: Eventually calls ``delete[] from`` if ``delete_from == true``.   
         
- ``T** c_array();``

    - Returns: ``0`` if the container is empty; otherwise a pointer to the first element of the stored array

    - Throws: Nothing
    
.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2007. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``associative_ptr_container``
-------------------------------------

This section describes all the common operations for all associative
pointer containers (in addition to ``reversible_ptr_container``).

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - ``associative_ptr_container`` 
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

**See also:**

- `iterator_range <http://www.boost.org/libs/range/doc/utility_class.html#iter_range>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

**Synopsis:**

.. parsed-literal::

        namespace boost
        {
            template
            < 
                class Key, 
                class CloneAllocator = heap_clone_allocator 
            >
            class associative_ptr_container 
            {
            public: // typedefs_
                typedef ...   key_type;
                typedef ...   key_compare;
                typedef ...   value_compare;
        
            public: // `observers`_
                key_compare    key_comp() const;
                value_compare  value_comp() const;
        
            public: // `modifiers`_         
                template< typename InputIterator >
                void       insert( InputIterator first, InputIterator last );     
                template< class InputRange >
                void       insert( const InputRange& r );
                void       erase( iterator position ); 
                size_type  erase( const key_type& x );
                template< class Range >
                void       erase( const Range& r );
                void       erase( iterator first, iterator last );

            public: // `algorithms`_
                iterator                        find( const key_type& x );
                const_iterator                  find( const key_type& x ) const;
                size_type                       count( const key_type& x ) const;              
                iterator                        lower_bound( const key_type& x );                     
                const_iterator                  lower_bound( const key_type& x ) const;
                iterator                        upper_bound( const key_type& x );                           
                const_iterator                  upper_bound( const key_type& x ) const;
                iterator_range<iterator>        equal_range( const key_type& x );                 
                iterator_range<const_iterator>  equal_range( const key_type& x ) const;
             
            }; //  class 'associative_ptr_container'
            
        } // namespace 'boost'  

    
Semantics
---------

.. _typedefs:

Semantics: typedefs
^^^^^^^^^^^^^^^^^^^

- ``typedef ... key_type;``

    - if we are dealing with a map, then simply the key type
    - if we are dealing with a set, then the *indirected* key type, that is, 
      given ``ptr_set<T>``, ``key_type*`` will be ``T*``.

- ``typedef ... key_compare;``

    -  comparison object type that determines the order of elements in the container

- ``typedef ... value_compare;``

    - comparison object type that determines the order of elements in the container
    - if we are dealing with a map, then this comparison simply forwards to the ``key_compare`` comparison operation

.. _`observers`:

Semantics: observers
^^^^^^^^^^^^^^^^^^^^

- ``key_compare key_comp() const;``
- ``value_compare value_comp() const;``

    - returns copies of objects used to determine the order of elements

.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``template< typename InputIterator >
  void insert( InputIterator first, InputIterator last );``

    - Requirements: ``[first,last)`` is a valid range

    - Effects: Inserts a cloned range 

    - Exception safety: Basic guarantee

- ``template< class InputRange >
  void insert( const InputRange& r );``

    - Effects: ``insert( boost::begin(r), boost::end(r) );``

- ``void erase( iterator position );``

    - Requirements: ``position`` is a valid iterator from the container

    - Effects: Removes the element defined by ``position``.

    - Throws: Nothing

- ``size_type erase( const key_type& x );``

    - Effects: Removes all the elements in the container with a key equivalent to ``x`` and returns the number of erased elements.

    - Throws: Nothing

- ``void erase( iterator first, iterator last );``

    - Requirements: ``[first,last)`` is a valid range

    - Effects: Removes the range of elements defined by ``[first,last)``.

    - Throws: Nothing

- ``template< class Range > void erase( const Range& r );``

    - Effects: ``erase( boost::begin(r), boost::end(r) );``

.. _`algorithms`:

Semantics: algorithms
^^^^^^^^^^^^^^^^^^^^^

- ``iterator       find( const Key& x );``
- ``const_iterator find( const Key& x ) const;``

    - Effects: Searches for the key and returns ``end()`` on failure.

    - Complexity: Logarithmic

- ``size_type count( const Key& x ) const;``

    - Effects: Counts the elements with a key equivalent to ``x``

    - Complexity: Logarithmic

- ``iterator       lower_bound( const Key& x );``
- ``const_iterator lower_bound( const Key& x ) const;``

    - Effects: Returns an iterator pointing to the first element with a key not less than ``x``

    - Complexity: Logarithmic

- ``iterator       upper_bound( const Key& x );``
- ``const_iterator upper_bound( const Key& x ) const;``

    - Effects: Returns an iterator pointing to the first element with a key greater than ``x``

    - Complexity: Logarithmic

- ``iterator_range<iterator>       equal_range( const Key& x );`` 
- ``iterator_range<const_iterator> equal_range( const Key& x ) const;`` 

    - Effects: ``return boost::make_iterator_range( lower_bound( x ), upper_bound( x ) );``

    - Complexity: Logarithmic

..
        - ``reference       at( const key_type& key );``
        - ``const_reference at( const key_type& key ) const;`` 
    
        - Requirements: the key exists
    
        - Effects: returns the object with key ``key``
    
        - Throws: ``bad_ptr_container_operation`` if the key does not exist                                 
    

.. _`pointer container requirements`:

.. raw:: html 

        <hr>
	
:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt

++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_multimap``
----------------------

A ``ptr_multimap<Key,T>`` is a pointer container that uses an underlying ``std::multimap<Key,void*>``
to store the pointers.


**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - ``ptr_multimap``

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. _reversible_ptr_container: reversible_ptr_container.html 
.. _associative_ptr_container: associative_ptr_container.html
.. _ptr_multimap_adapter: ptr_multimap_adapter.html



**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {
            template
            < 
                class Key, 
                class T, 
                class Compare        = std::less<Key>,
                class CloneAllocator = heap_clone_allocator,
                class Allocator      = std::allocator< std::pair<const Key,void*> >
            >
            class ptr_multimap : public ptr_multimap_adapter
                                        <
                                            T,
                                            std::multimap<Key,void*,Compare,Allocator>,
                                            CloneAllocator
                                        >
            {
                // see references
                
            }; //  class 'ptr_multimap'
        
        } // namespace 'boost'  


:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_list``
------------------

A ``ptr_list<T>`` is a pointer container that uses an underlying ``std:list<void*>``
to store the pointers. 

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

    - `ptr_vector <ptr_vector.html>`_
    - ``ptr_list`` 
    - `ptr_deque <ptr_deque.html>`_
    - `ptr_array <ptr_array.html>`_
    
**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::  
           
        namespace boost
        {      
        
            template
            < 
                class T, 
                class CloneAllocator = heap_clone_allocator,
                class Allocator      = std::allocator<void*>
            >
            class ptr_list : public ptr_sequence_adapter
                                    <
                                        T,
                                        std::list<void*,Allocator>,
                                        CloneAllocator
                                    >
            {
            
            public: // modifiers_
                void                push_front( T* x );
		template< class U >
		void                push_front( std::auto_ptr<U> x );
                auto_type           pop_front();
             
            public: // `list operations`_
                void  reverse();

            }; // class 'ptr_list'

        } // namespace 'boost'  


Semantics
---------

.. _modifiers:
 
Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``void push_front( T* x );``

    - Requirements: ``x != 0``

    - Effects: Inserts the pointer into container and takes ownership of it
    
    - Throws: ``bad_pointer`` if ``x == 0``

    - Exception safety: Strong guarantee

- ``template< class U > void push_front( std::auto_ptr<U> x );``

    - Effects: ``push_front( x.release() );``
    
..
    - ``void push_front( const T& x );``
    
        - Effects: push_front( allocate_clone( x ) );
    
        - Exception safety: Strong guarantee

- ``auto_type pop_front():``

    - Requirements:``not empty()``
    
    - Effects: Removes the first element in the container

    - Postconditions: ``size()`` is one less

    - Throws: ``bad_ptr_container_operation`` if ``empty() == true``
    
    - Exception safety: Strong guarantee

.. _`list operations`:

Semantics: list operations
^^^^^^^^^^^^^^^^^^^^^^^^^^

..
    - ``void splice( iterator before, ptr_list& x );``
    
        - Requirements:``&x != this``
    
        - Effects: inserts the all of ``x``'s elements before ``before``
    
        - Postconditions: ``x.empty()``
        
        - Throws: nothing
    
        - Remark: prefer this to ``transfer( before, x );``
    
    - ``void  splice( iterator before, ptr_list& x, iterator i );``
    
        - Not ready yet
    
    - ``void splice( iterator before, ptr_list& x, iterator first, iterator last );``
    
        - Not ready yet

    - ``void merge( ptr_list& x );``
    
        - Not ready yet
         
    - ``template< typename Compare > 
      void merge( ptr_list& x, Compare comp );``
    
        - Not ready yet
    
- ``void reverse();``

    - Effects: reverses the underlying sequence

    - Throws: nothing

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Conventions
+++++++++++

There are a few design decisions that will affect how the classes are 
used.  Besides these the classes are much like normal standard containers 
and provides almost the same interface.  The new conventions are: 

.. contents:: :local:

Null pointers are not allowed by default
----------------------------------------

If the user tries to insert the null pointer, the operation will throw a 
``bad_pointer`` exception (see `Example 1 <examples.html>`_).  

Use `nullable <reference.html#class-nullable>`_ to allow null pointers.

Please notice that all preconditions of the form ::

    x != 0;

are not active when the you have instantiated a container
with ``nullable<T>`` as in ::

    boost::ptr_vector< boost::nullable<animal> > vec;
    vec.push_back( 0 ); // ok

All default iterators apply an extra layer of indirection 
--------------------------------------------------------- 

This is done to 
make the containers easier and safer to use.  It promotes a kind of 
pointer-less programming and the user of a class needs not worry about 
pointers except when allocating them (see `Example 2 <examples.html>`_).  Iterators that 
provide access to the naked pointers are also provided since they might be 
useful in rare cases. For example, whenever ``begin()`` returns an iterator, 
``ptr_begin()`` will return an iterator that allows one to iterate over the 
stored pointers.  

All comparison operations are done on the pointed to objects and not at the pointer level
-----------------------------------------------------------------------------------------

For example, in ``ptr_set<T>`` the ordering is by default done by 
``boost::ptr_less<T>`` which compares the indirected pointers. 
Similarly, ``operator==()`` for ``container<Foo>`` compares all objects
with ``operator==(const Foo&, const Foo&)``. 


Stored elements are required to be `Cloneable <reference.html#the-Cloneable-concept>`_ for a subset of the operations
---------------------------------------------------------------------------------------------------------------------

This is because most polymorphic objects cannot be copied directly, but 
they can often be so by a use of a member function (see `Example 4 <examples.html>`_).  Often 
it does not even make sense to clone an object in which case a large 
subset of the operations are still workable.  

Whenever objects are inserted into a container, they are cloned before insertion
--------------------------------------------------------------------------------

This is necessary because all pointer containers take ownerships of stored objects
(see `Example 5 <examples.html>`_).

Whenever pointers are inserted into a container, ownership is transferred to the container
------------------------------------------------------------------------------------------

All containers take ownership of the stored pointers and therefore a 
container needs to have its own copies (see `Example 5 <examples.html>`_).  

Ownership can be transferred from a container on a per pointer basis
--------------------------------------------------------------------

This can of course also be convenient.  Whenever it happens, an 
``SmartContainer::auto_type`` object is used to provide an exception-safe transfer 
(see `Example 6 <examples.html>`_).  

Ownership can be transferred from a container to another container on a per iterator range basis  
------------------------------------------------------------------------------------------------

This makes it possible to exchange data safely between different pointer 
containers without cloning the objects again (see `Example 7 <examples.html>`_).  

A container can be cheaply returned from functions either by making a clone or by giving up ownership of the container
----------------------------------------------------------------------------------------------------------------------

Two special member functions, ``clone()`` and ``release()``, both return an 
``auto_ptr<SmartContainer>`` which can be assigned to another pointer container.  This 
effectively reduces the cost of returning a container to one 
heap-allocation plus a call to ``swap()`` (see `Example 3 <examples.html>`_).

Iterators are invalidated as in the corresponding standard container
--------------------------------------------------------------------

Because the containers in this library wrap standard containers, the
rules for invalidation of iterators are the same as the rules
of the corresponding standard container.

For example, for both ``boost::ptr_vector<T>`` and ``std::vector<U>``
insertion and deletion only invalidates the deleted
element and elements following it; all elements before the inserted/deleted
element remain valid.

.. raw:: html 

        <hr>

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_multiset``
----------------------

A ``ptr_multiset<T>`` is a pointer container that uses an underlying ``std::multiset<void*>``
to store the pointers.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - ``ptr_multi_set`` 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

**See also:**

- `void_ptr_indirect_fun <indirect_fun.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {

            template
            < 
                class Key, 
                class Compare        = std::less<Key>,
                class CloneAllocator = heap_clone_allocator,
                class Allocator      = std::allocator<void*>
            >
            class ptr_multiset : public ptr_multiset_adapter
                                        <
                                            Key,
                                            std::multiset<void*,void_ptr_indirect_fun<Compare,Key>,Allocator>,
                                            CloneAllocator
                                        >
            {
                // see references
                
            }; //  class 'ptr_multiset'
        
        } // namespace 'boost'  

**Remarks:**

- Using ``nullable<T>`` as ``Key`` is meaningless and is not allowed

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_map_adapter``
-------------------------

This class is used to build custom pointer containers with
an underlying map-like container. The interface of the class is an extension
of the interface from ``associative_ptr_container``.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - ``ptr_map_adapter``
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_
      
**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {
            template
            < 
                class T,
                class VoidPtrMap, 
                class CloneAllocator = heap_clone_allocator 
            >
            class ptr_map_adapter 
            {
	    public: // `typedefs`_
		typedef VoidPtrMap::key_type key_type;
		typedef T*                   mapped_type;
		typedef T&                   mapped_reference;
		typedef const T&             const_mapped_reference;
		typedef ...                  value_type;
		typedef ...                  reference;
		typedef ...                  const_reference;
		typedef ...                  pointer;
		typedef ...                  const_pointer;  
                
            public: // `modifiers`_         
                std::pair<iterator,bool>  insert( key_type& k, T* x );                         
		template< class U >
		std::pair<iterator,bool>  insert( const key_type& k, std::auto_ptr<U> x );                         

            public; // `lookup`_
                T&       operator[]( const key_type& key );
                T&       at( const key_type& key );
                const T& at( const key_type& key ) const;
                
            public: // `pointer container requirements`_
                bool      transfer( iterator object, ptr_map_adapter& from );
                size_type transfer( iterator first, iterator last, ptr_map_adapter& from );
                template< class Range >
                size_type transfer( const Range& r, ptr_map_adapter& from );
                size_type transfer( ptr_map_adapter& from );
                    
            }; //  class 'ptr_map_adapter'
        
        } // namespace 'boost'  

            
Semantics
---------

.. _`typedefs`:

Semantics: typedefs
^^^^^^^^^^^^^^^^^^^

The following types are implementation defined::

	typedef ... value_type;
	typedef ... reference;
	typedef ... const_reference;
	typedef ... pointer;
	typedef ... const_pointer;  
        
However, the structure of the type mimics ``std::pair`` s.t. one
can use ``first`` and ``second`` members. The reference-types
are not real references and the pointer-types are not real pointers.
However, one may still write ::

    map_type::value_type       a_value      = *m.begin();
    a_value.second->foo();
    map_type::reference        a_reference  = *m.begin();
    a_reference.second->foo();
    map_type::const_reference  a_creference = *const_begin(m);
    map_type::pointer          a_pointer    = &*m.begin();
    a_pointer->second->foo();
    map_type::const_pointer    a_cpointer   = &*const_begin(m);

The difference compared to ``std::map<Key,T*>`` is that constness
is propagated to the pointer (that is, to ``second``) in ``const_itertor``. 	

.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``std::pair<iterator,bool> insert( key_type& k, value_type x );``

    - Requirements: ``x != 0``

    - Effects: Takes ownership of ``x`` and insert it iff there is no equivalent of it already. The bool part of the return value indicates insertion and the iterator points to the element with key ``x``.

    - Throws: bad_pointer if ``x == 0``

    - Exception safety: Strong guarantee


- ``template< class U > std::pair<iterator,bool> insert( const key_type& k, std::auto_ptr<U> x );``                         

   - Equivalent to (but without the ``const_cast``): ``return insert( const_cast<key_type&>(k), x.release() );``

..
        - ``std::pair<iterator,bool> insert( key_type& k, const_reference x );``
    
        - Effects: ``return insert( allocate_clone( x ) );``
    
        - Exception safety: Strong guarantee


.. _`lookup`: 

Semantics: lookup
^^^^^^^^^^^^^^^^^

- ``T& operator[]( const key_type& key );``

    - Effects: returns the object with key ``key`` if it exists; otherwise a new object is allocated and inserted and its reference returned.
    - Exception-safety: Strong guarantee           

- ``T&       at( const key_type& key );``
- ``const T& at( const key_type& jey ) const;``

    - Requirement: the key exists
    - Throws: ``bad_ptr_container_operation`` if the key does not exist                                 

.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``bool transfer( iterator object, ptr_map_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the object defined by ``object`` into the container and remove it from ``from`` 
     iff no equivalent object exists.

   - Returns: whether the object was transfered
   
   - Exception safety: Strong guarantee

- ``size_type transfer( iterator first, iterator last, ptr__set_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the objects defined by the range ``[first,last)`` into the container and remove it from ``from``.
     An object is only transferred if no equivalent object exists. 

   - Returns: the number of transfered objects
              
   - Exception safety: Basic guarantee

- ``template< class Range > void transfer( const Range& r, ptr_map_adapter& from );``

    - Effects: ``return transfer( boost::begin(r), boost::end(r), from );``
                   
- ``size_type transfer( ptr_set_adapter& from );``

   - Effects: ``return transfer( from.begin(), from.end(), from );``.

.. raw:: html 

        <hr>
 
:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_set_adapter``
-------------------------

This class is used to build custom pointer containers with
an underlying set-like container. The interface of the class is an extension
of the interface from ``associative_ptr_container``.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - ``ptr_set_adapter``
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. _reversible_ptr_container: reversible_ptr_container.html 
.. _associative_ptr_container: associative_ptr_container.html
.. _ptr_set: ptr_set.html

**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {
            template
            < 
                class Key, 
                class VoidPtrSet,
                class CloneAllocator = heap_clone_allocator 
            >
            class ptr_set_adapter 
            {
                
            public: // `modifiers`_         
                std::pair<iterator,bool>  insert( Key* x );   
		template< class Key2 >
		std::pair<iterator,bool>  insert( std::auto_ptr<Key2> x );   	                      
 
            public: // `pointer container requirements`_
                bool      transfer( iterator object, ptr_set_adapter& from );
                size_type transfer( iterator first, iterator last, ptr_set_adapter& from );
                template< class Range >
                size_type transfer( const Range& r, ptr_set_adapter& from );
                size_type transfer( ptr_set_adapter& from );
 
            }; //  class 'ptr_set_adapter'
        
        } // namespace 'boost'  

            
Semantics
---------

.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``std::pair<iterator,bool> insert( key_type* x );``

    - Requirements: ``x != 0``

    - Effects: Takes ownership of ``x`` and insert it if there is no equivalent of it already. The ``bool`` part of the return value indicates insertion and the iterator points to the element with key ``x``.

    - Throws: bad_pointer if ``x == 0``

    - Exception safety: Strong guarantee
    
- ``template< class Key2 > std::pair<iterator,bool>  insert( std::auto_ptr<Key2> x );``

    - Effects: ``return insert( x.release() );``   	                      


.. 
        - ``std::pair<iterator,bool> insert( const key_type& x );``

        - Effects: ``return insert( allocate_clone( x ) );``

        - Exception safety: Strong guarantee

.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``bool transfer( iterator object, ptr_set_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the object defined by ``object`` into the container and remove it from ``from`` 
     iff no equivalent object exists.

   - Returns: whether the object was transfered
   
   - Exception safety: Strong guarantee

- ``void transfer( iterator first, iterator last, ptr__set_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the objects defined by the range ``[first,last)`` into the container and remove it from ``from``.
     An object is only transferred if no equivalent object exists. 

   - Returns: the number of transfered objects
                 
   - Exception safety: Basic guarantee

- ``template< class Range > void transfer( const Range& r, ptr_set_adapter& from );``

    - Effects: ``return transfer( boost::begin(r), boost::end(r), from );``
                   
- ``size_type transfer( ptr_set_adapter& from );``

   - Effects: ``return transfer( from.begin(), from.end(), from );``.

.. raw:: html 

        <hr>
 
:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++

.. |Boost| image:: boost.png

Class ``ptr_sequence_adapter``
------------------------------

This section describes all the common operations for all the pointer
sequences:

- `ptr_vector <ptr_vector.html>`_
- `ptr_list <ptr_list.html>`_ 
- `ptr_deque <ptr_deque.html>`_


The ``ptr_sequence_adapter`` is also a concrete class that you can use to create custom pointer
containers from.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - ``ptr_sequence_adapter``

    - `ptr_vector <ptr_vector.html>`_
    - `ptr_list <ptr_list.html>`_ 
    - `ptr_deque <ptr_deque.html>`_
    - `ptr_array <ptr_array.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::

        namespace boost
        {

            template
            <
                class T,
                class VoidPtrSeq,
                class CloneAllocator = heap_clone_allocator
            >
            class ptr_sequence_adapter
            {
            public: // `construct/copy/destroy`_
                template< class InputIterator >
                assign( InputIterator first, InputIterator last );
                template< class InputRange >
                assign( const InputRange& e );

            public: // `element access`_
                T&        front();
                const T&  front() const;
                T&        back();
                const T&  back() const;

            public: // `modifiers`_
                void      push_back( T* x );
                template< class U >
                void      push_back( std::auto_ptr<U> x );
                auto_type pop_back();
                iterator  insert( iterator position, T* x );
                template< class U >
                iterator  insert( iterator position, std::auto_ptr<U> x );
                template< class InputIterator >
                void      insert( iterator position, InputIterator first, InputIterator last );
                template< class InputRange >
                void      insert( iterator position, const InputRange& r );
                iterator  erase( iterator position );
                iterator  erase( iterator first, iterator last );
                template< class Range >
                iterator  erase( const Range& r );
                void      resize( size_type size );
                void      resize( size_type size, T* to_clone );

            public: // `pointer container requirements`_
                template< class PtrSequence >
                void transfer( iterator before, typename PtrSequence::iterator object,
                               PtrSequence& from );                             
                template< class PtrSequence >
                void transfer( iterator before, typename PtrSequence::iterator first, typename PtrSequence::iterator last,
                               PtrSequence& from );
                void template< class PtrSequence, class Range >
                void transfer( iterator before, const Range& r, PtrSequence& from );
                template< class PtrSequence >
                void transfer( iterator before, PtrSequence& from );

            public: // `algorithms`_

                void sort();
                void sort( iterator first, iterator last );
                template< class Compare >
                void sort( Compare comp );
                template< class Compare >
                void sort( iterator begin, iterator end, Compare comp );

                void unique();
                void unique( iterator first, iterator last );
                template< class Compare >
                void unique( Compare comp );
                template< class Compare >
                void unique( iterator begin, iterator end, Compare comp );

                template< class Pred >
                void erase_if( Pred pred );
                template< class Pred >
                void erase_if( iterator begin, iterator end, Pred pred );

                void merge( ptr_sequence_adapter& r );
                template< class Compare >
                void merge( ptr_sequence_adapter& r, Compare comp );
                void merge( iterator first, iterator last, ptr_sequence_adapter& from );
                template< class Compare >
                void merge( iterator first, iterator last, ptr_sequence_adapter& from, Compare comp );

            public: // `ptr_list interface`_

            public: // `ptr_vector interface`_

            public: // `ptr_deque interface`_

            }; //  class 'ptr_sequence_adapter'

        } // namespace 'boost'

.. _`ptr_list interface`: ptr_list.html
.. _`ptr_vector interface`: ptr_vector.html
.. _`ptr_deque interface`: ptr_deque.html

Semantics
---------

.. _`construct/copy/destroy`:

Semantics: construct/copy/destroy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``template< class InputIterator >
  void assign( InputIterator first, InputIterator last );``

    - Requirements: ``(first,last]`` is a valid range

    - Effects: ``clear(); insert( first, last );``

    - Postconditions: ``size() == std::distance( first, last );``

    - Exception safety: strong guarantee

- ``template< class InputRange >
  void assign( const InputRange& r );``

    - Effects: ``assign( boost::begin(r), boost::end(r) );``


..
        - ``assign( size_type n, const T& u )``

        - Effects: ``clear(); insert( begin(), n, u );``

        - Postconditions: ``size() == n``

        - Exception safety: Strong guarantee


..
        void resize( size_type sz, const T& x );
        Effects:

        if ( sz > size() )
            insert( end(), sz-size(), x );
            else if ( sz < size() )
            erase( begin()+sz, end() );
            else
            ; //do nothing

        Postconditions: size() == sz

        Exception safety: Strong guarantee


.. _`element access`:

Semantics: element access
^^^^^^^^^^^^^^^^^^^^^^^^^

- ``T& front();``

    - Requirements: ``not empty();``

    - Effects: ``return *begin();``


- ``const T& front() const;``

    - Requirements: ``not empty();``

    - Effects: ``return *begin();``


- ``T& back();``

    - Requirements: ``not empty();``

    - Effects: ``return *--end();``


- ``const T& back() const;``

    - Requirements: ``not empty();``

    - Effects: ``return *--end();``


.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``void push_back( T* x );``

    - Requirements: ``x != 0``

    - Effects: Inserts the pointer into container and takes ownership of it

    - Throws: ``bad_pointer`` if ``x == 0``

    - Exception safety: Strong guarantee

- ``template< class U > void push_back( std::auto_ptr<U> x );``

    - Effects: ``push_back( x.release() );``
    
..
        - ``void push_back( const T& x );``

        - Effects: ``push_back( CloneAllocator::clone( x ) );``

        - Exception safety: Strong guarantee

- ``auto_type pop_back();``

    - Requirements:``not empty()``

    - Effects: Removes the last element in the container

    - Postconditions: ``size()`` is one less

    - Throws: ``bad_ptr_container_operation`` if ``empty() == true``

    - Exception safety: Strong guarantee


- ``iterator insert( iterator position, T* x );``

    - Requirements: ``position`` is a valid iterator from the container and
      ``x != 0``

    - Effects: Inserts ``x`` before ``position`` and returns an iterator pointing to it

    - Throws: ``bad_pointer`` if ``x == 0``

    - Exception safety: Strong guarantee
    
- ``template< class U > iterator insert( iterator position, std::auto_ptr<U> x );``

    - Effects: ``return insert( position, x.release() );``

..
        - ``iterator insert( iterator position, const T& x );``

        - Requirements: ``position`` is a valid iterator from the container

        - Effects: ``return insert( position, CloneAllocator::clone( x ) );``

        - Exception safety: Strong guarantee

        - ``void insert( iterator position, size_type n, const T& x );``

        - Requirements: ``position`` is a valid iterator from the container

        - Effects: Inserts ``n`` clones of ``x`` before position into the container

        - Exception safety: Strong guarantee

- ``template< class InputIterator >
  void insert( iterator position, InputIterator first, InputIterator last );``

    - Requirements: ``position`` is a valid iterator from the container

    - Effects: Inserts a cloned range before ``position``

    - Exception safety: Strong guarantee

- ``template< class InputRange >
  void insert( iterator position, const InputRange& r );``

    - Effects: ``insert( position, boost::begin(r), boost::end(r) );``

- ``iterator erase( iterator position );``

    - Requirements: ``position`` is a valid iterator from the container

    - Effects: Removes the element defined by ``position`` and returns an iterator to the following element

    - Throws: Nothing

- ``iterator erase( iterator first, iterator last );``

    - Requirements: ``[first,last)`` is a valid range

    - Effects: Removes the range of element defined by ``[first,last)`` and returns an iterator to the following element

    - Throws: Nothing

- ``template< class Range >
  void erase( const Range& r );``

    - Effects: ``erase( boost::begin(r), boost::end(r) );``

- ``void resize( size_type size );``

    - Effects: Resizes the container. If elements are erased, it happens from the back. If elements are inserted, it happens at the back.
    
    - Requirements: ``T`` is default constructible
    
    - Postcondition: ``size() == size;``
    
    - Exception safety: Basic guarantee under expansion; nothrow guarantee otherwise
    
- ``void resize( size_type size, T* to_clone );``

    - Effects: Resizes the container. If elements are erased, it happens from the back. If elements are inserted, clones of ``*to_clone`` are inserted at the back.
    
    - Postcondition: ``size() == size;``
    
    - Exception safety: Basic guarantee under expansion; nothrow guarantee otherwise

    - Remarks: ``to_clone == 0`` is valid if the container supports nulls. The container does not take ownership of ``to_clone``.

.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can use ``transfer()`` to move elements between two containers of the same type. Furthermore,
you can also move elements from a container of type ``T`` to a container of type ``U`` as long as
``T::value_type`` is convertible to ``U::value_type``. An example would be transferring from ``boost::ptr_vector<Derived>``
to ``boost::ptr_deque<Base>``.

(**Remark:** *When moving elements between two different containers, it is your responsibility to make sure the allocators are compatible.* 
*The special latitude of being able to transfer between two different containers is only available for Sequences and not for Associative Containers.*)

..

- ``template< class PtrSequence > void transfer( iterator before, typename PtrSequence::iterator object, PtrSequence& from );``   

    - Effects: Inserts the object defined by ``object`` into the container and remove it from ``from``.
      Insertion takes place before ``before``.

    - Postconditions: If ``from.empty()``, nothing happens. Otherwise
      ``size()`` is one more, ``from.size()`` is one less.

    - Exception safety: Strong guarantee


- ``template< class PtrSequence > void transfer( iterator before, typename PtrSequence::iterator first, typename PtrSequence::iterator last, PtrSequence& from );``

    - Requirements: ``from.size() >= std::distance(first,last)``

    - Effects: Inserts the objects defined by the range ``[first,last)`` into the container and remove it from ``from``.
      Insertion takes place before ``before``.

    - Postconditions: If ``from.empty()``, nothing happens. Otherwise, 
      let ``N == std::distance(first,last);`` then ``size()`` is ``N`` more, ``from.size()`` is ``N`` less.

    - Exception safety: Strong guarantee
    
    - Complexity: Linear or better

- ``void template< class PtrSequence, class Range > void transfer( iterator before, const Range& r, PtrSequence& from );``

    - Effects: ``transfer(before, boost::begin(r), boost::end(r), from);``

- ``template< class PtrSequence> void transfer( iterator before, PtrSequence& from );``

    - Effects: ``transfer(before, from, from);``

.. _`algorithms`:

Semantics: algorithms
^^^^^^^^^^^^^^^^^^^^^

The general requirement for these algorithms is that the container *does not
contain any nulls*.

- ``void sort();``
- ``void sort( iterator first, iterator last );``
- ``template< class Compare > void sort( Compare comp );``
- ``template< class Compare > void sort( iterator begin, iterator end, Compare comp );``

    - Requirements: (versions without ``Compare``) ``bool operator<( const T&, const T& )`` is defined
    - Requirements: (``Compare`` versions) ``Compare`` must take ``const T&`` arguments
    - Effects: sorts the entire container or the specified range
    - Exception safety: nothrow guarantee (the behavior is undefined if the comparison operator throws)
    - Remarks: The versions of ``sort()`` that take two iterators are not available for ``ptr_list``

- ``void unique();``
- ``void unique( iterator first, iterator last );``
- ``template< class Compare > void unique( Compare comp );``
- ``template< class Compare > void unique( iterator begin, iterator end, Compare comp );``

    - Requirements: (versions without ``Compare``) ``bool operator==( const T&, const T& )`` is defined
    - Requirements: (``Compare`` versions) ``Compare`` must take ``const T&`` arguments
    - Effects: removes adjacent and equal objects from the entire container or the specified range
    - Exception safety: nothrow guarantee (the behavior is undefined if the comparison operator throws)
    
- ``template< class Pred > void erase_if( Pred pred );``
- ``template< class Pred > void erase_if( iterator begin, iterator end, Pred pred );``

    - Requirements: ``Pred`` must take an ``const T&`` argument
    - Effects: removes all elements ``t`` for which ``pred(t)`` returns ``true`` from the entire container or the specified range
    - Exception safety: nothrow guarantee (the behavior is undefined if the comparison operator throws)
        
- ``void merge( ptr_sequence_adapter& r );``
- ``template< class Compare > void merge( ptr_sequence_adapter& r, Compare comp );``
- ``void merge( iterator first, iterator last, ptr_sequence_adapter& from );``
- ``template< class Compare > void merge( iterator first, iterator last, ptr_sequence_adapter& from, Compare comp );``

    - Requirements: (``Compare`` versions) ``Compare`` must take ``const T&`` arguments
    - Requirements: both sequences are sorted wrt. the same predicate
    - Effects: transfers the entire container or the specified sequence to the container while
      ensuring the new sequence is also sorted
    - Postconditions: (Container versions) ``r.empty()``  
    - Exception safety: nothrow guarantee (the behavior is undefined if the comparison operator throws)

.. raw:: html 

        <hr>
    
:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt

    
++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_multiset_adapter``
------------------------------

This class is used to build custom pointer containers with
an underlying multiset-like container. The interface of the class is an extension
of the interface from ``associative_ptr_container``.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - ``ptr_multiset_adapter``
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {
            template
            < 
                class Key,
                class VoidPtrMultiSet,
                class CloneAllocator = heap_clone_allocator
            >
            class ptr_multiset_adapter 
            {
                
            public: // `modifiers`_         
                iterator  insert( Key* x );    
		template< class Key2 >
		iterator  insert( std::auto_ptr<Key2> x );                     
 
            public: // `pointer container requirements`_
                void      transfer( iterator object, ptr_multiset_adapter& from );
                size_type transfer( iterator first, iterator last, ptr_multiset_adapter& from );
                template< class Range >
                size_type transfer( const Range& r, ptr_multiset_adapter& from );
                void      transfer( ptr_multiset_adapter& from );
 
            }; //  class 'ptr_multiset_adapter'
        
        } // namespace 'boost'  

            
Semantics
---------

.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``iterator insert( key_type* x );``

    - Requirements: ``x != 0``

    - Effects: Takes ownership of ``x``. The returned iterator points to the element with key ``x``.

    - Throws: bad_pointer if ``x == 0``

    - Exception safety: Strong guarantee

    
- ``template< class Key2 > iterator insert( std::auto_ptr<Key2> x );``

    - Effects: ``return insert( x.release() );``   	                      

.. 
        - ``iterator insert( const key_type& x );``
    
        - Effects: ``return insert( allocate_clone( x ) );``
    
        - Exception safety: Strong guarantee

.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``void transfer( iterator object, ptr_multiset_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the object defined by ``object`` into the container and remove it from ``from``. 

   - Postconditions: ``size()`` is one more, ``from.size()`` is one less.

   - Exception safety: Strong guarantee

- ``void transfer( iterator first, iterator last, ptr_multiset_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the objects defined by the range ``[first,last)`` into the container and remove it from ``from``.

   - Postconditions: Let ``N == std::distance(first,last);`` then ``size()`` is ``N`` more, ``from.size()`` is ``N`` less.
              
   - Exception safety: Basic guarantee

- ``template< class Range > void transfer( const Range& r, ptr_multiset_adapter& from );``

    - Effects: ``transfer( boost::begin(r), boost::end(r), from );``

- ``void transfer( ptr_multiset_adapter& from );``

   - Effects: ``transfer( from.begin(), from.end(), from );``.

   - Postconditions: ``from.empty();``

   - Exception safety: Basic guarantee
 
.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_set``
-----------------

A ``ptr_set<T>`` is a pointer container that uses an underlying ``std::set<void*>``
to store the pointers.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter  <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - `ptr_multi_map_adapter <ptr_multimap_adapter.html>`_

      - ``ptr_set``
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

    
**See also:**

- `void_ptr_indirect_fun <indirect_fun.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {

            template
            < 
                class Key, 
                class Compare        = std::less<Key>, 
                class CloneAllocator = heap_clone_allocator, 
                class Allocator      = std::allocator<void*>
            >
            class ptr_set : public  ptr_set_adapter
                                    <
                                        Key,
                                        std::set<void*,
                                        void_ptr_indirect_fun<Compare,Key>,Allocator>,
                                        CloneAllocator
                                    >
            {
                // see references
                
            }; //  class 'ptr_set'
        
        } // namespace 'boost'  

**Remarks:**

- Using ``nullable<T>`` as ``Key`` is meaningless and is not allowed

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_array``
-------------------

A ``ptr_array<T,size>`` is a pointer container that uses an underlying ``boost::array<void*,size>``
to store the pointers. The class is useful when there is no requirement
of dynamic expansion and when no overhead is tolerable.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

    - `ptr_vector <ptr_vector.html>`_
    - `ptr_list <ptr_list.html>`_ 
    - `ptr_deque <ptr_deque.html>`_
    - ``ptr_array``

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_



**Synopsis:**

.. parsed-literal::  
           
        namespace boost
        {      
        
            template
            < 
                class T, 
                size_t N, 
                CloneAllocator = heap_clone_allocator
            >
            class ptr_array : public *implementation-defined*
            {
            public: // `construct/copy/destroy`_
                ptr_array();
                explicit ptr_array( const ptr_array& r );
                template< class U >
                explicit ptr_array( const ptr_array<U,N>& r );                
                explicit ptr_array( std::auto_ptr<ptr_array>& r );
                
                ptr_array& operator=( const ptr_array& r );
                template< class U >
                ptr_array& operator=( const ptr_array<U,N>& r );
                ptr_array& operator=( std::auto_ptr<this_type> r );

            public: // `iterators`_

            public: // `capacity`_

            public: // `element access`_
                T&        front();
                const T&  front() const;
                T&        back();
                const T&  back() const;
                
                template< size_t idx >
                T&        at();
                template< size_t idx >
                const T&  at() const;
                T&        at( size_t );
                const T&  at( size_t );

                T&        operator[]( size_t );
                const T&  operator[]( size_t ) const;

            public: // `modifiers`_
                void  swap( ptr_array& r );
 
                template< size_t idx >
                auto_type replace( T* r );
                template< size_t idx, class U >
                auto_type replace( std::auto_ptr<U> r );
                auto_type replace( size_t idx, T* r );
                template< class U >
                auto_type replace( size_t idx, std::auto_ptr<U> r );

            public: // `pointer container requirements`_
                std::auto_ptr<ptr_array>  clone() const;    
                std::auto_ptr<ptr_array>  release();
                template< size_t idx >
                bool                      is_null() const;
                bool                      is_null( size_t idx ) const;
             
            }; //  class 'ptr_sequence_adapter'

        } // namespace 'boost'  

.. _iterators: reversible_ptr_container.html#iterators

.. _capacity: reversible_ptr_container.html#capacity

.. _`inherited element access`: reversible_ptr_container.html#element-access

Semantics
---------

.. _`construct/copy/destroy`:

Semantics: construct/copy/destroy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``ptr_array();``

    - Effects: constructs array where each element is null
    
-   ``explicit ptr_array( const ptr_array& r );``
-   ``template< class U >
    explicit ptr_array( const ptr_array<U,N>& r );``
    
    - Effects: Constructs array by cloning ``r``                 
         
- ``ptr_array( std::auto_ptr<ptr_array>& r );``

    - Effects: take ownership of the supplied pointers

- ``ptr_array& operator=( const ptr_array& r );``

- ``template< class U > ptr_array& operator=( const ptr_array<U,N>& r );``

    - Effects: Assigns a clone of ``r``
    
    - Exception safety: Strong guarantee
    
- ``ptr_array& operator=( std::auto_ptr<this_type> r );``

   - Effects: take ownership of the supplied pointers

   - Throws: Nothing

.. _`element access`:

Semantics: element access
^^^^^^^^^^^^^^^^^^^^^^^^^


- ``T&       front();``
- ``const T& front() const;``

    - Requirements: ``not empty();``

    - Effects: ``return *begin();``

    - Throws: ``bad_ptr_container_operation`` if ``empty() == true``


- ``T&       back();``
- ``const T& back() const;``

    - Requirements: ``not empty();``

    - Effects: ``return *--end();``

    - Throws: ``bad_ptr_container_operation`` if ``empty() == true``

- ``template< size_t idx > T&       at( size_type n );``
- ``template< size_t idx > const T& at( size_type n ) const;``

    - Requirements: ``idx < size()`` (compile-time enforced)

    - Effects: Returns a reference to the ``n``'th element

    - Throws: nothing

- ``T&       at( size_type n );``
- ``const T& at( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: ``bad_index`` if ``n >=size()``


- ``T&       operator[]( size_type n );``
- ``const T& operator[]( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: Nothing


.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``void swap( ptr_array& r );``

    - Effects: swaps the two arrays
    
    - Complexity: Linear

    - Throws: nothing
    
- ``template< size_t idx > auto_type replace( T* r );``

    - Requirements:
     
            - ``idx < size()`` (compile-time enforced)
            - ``r != 0``

    - Effects: returns the object indexed by ``idx`` and replaces it with ``r``.

    - Throws: ``bad_pointer`` if ``x == 0``.

    - Exception safety: Strong guarantee
    
- ``template< size_t idx, class U > auto_type replace( std::auto_ptr<U> r );``

    - Effects: ``return replace<idx>( r.release() );``

- ``auto_type replace( size_t idx, T* r );``
        
    - Requirements: `` x != 0 and idx < size()``

    - Effects: returns the object indexed by ``idx`` and replaces it with ``x``.

    - Throws: ``bad_index`` if ``idx >= size()`` and ``bad_pointer`` if ``x == 0``.

    - Exception safety: Strong guarantee

- ``template< class U > auto_type replace( size_t idx, std::auto_ptr<U> r );``

    - Effects: ``return replace( idx, r.release() );``
    
.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``std::auto_ptr<ptr_array>  clone() const;``

    - Effects: Returns a deep copy of the container

    - Throws: ``std::bad_alloc`` if there is not enough memory to make a clone of the container

    - Complexity: Linear

    
- ``std::auto_ptr<ptr_array>  release();``
     
    - Effects: Releases ownership of the container. This is a useful way of returning a container from a function.

    - Postconditions: ``empty() == true`` and all pointers are null

    - Throws: ``std::bad_alloc`` if the return value cannot be allocated

    - Exception safety: Strong guarantee


- ``template< size_t idx > bool is_null() const;``

    - Requirements: ``idx < size()`` (compile-time enforced)

    - Effects: returns whether the pointer at index ``idx`` is null

    - Exception safety: Nothrow guarantee

- ``bool is_null( size_type idx ) const;``

    - Requirements: ``idx < size()``

    - Effects: returns whether the pointer at index ``idx`` is null

    - Exception safety: Nothrow guarantee

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png


FAQ
===

.. contents:: :local:
 
Calling ``assign()`` is very costly and I do not really need to store cloned objects; I merely need to overwrite the existing ones; what do I do?
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Call ``std::copy( first, last, c.begin() );``.  
 
Which mutating algorithms are safe to use with pointers?
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Any mutating algorithm that moves elements around by swapping them.  An 
important example is ``std::sort()``; examples of unsafe algorithms are 
``std::unique()`` and ``std::remove()``. 

..  That is why these algorithms are 
    provided as member functions.  

Why does ``ptr_map<T>::insert()/replace()`` take two arguments (the key and the pointer) instead of one ``std::pair``? And why is the key passed by non-const reference?
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

This is the only way the function can be implemented in an exception-safe 
manner; since the copy-constructor of the key might throw, and since 
function arguments are not guaranteed to be evaluated from left to right, 
we need to ensure that evaluating the first argument does not throw.  
Passing the key as a reference achieves just that.  

When instantiating a pointer container with a type ``T``, is ``T`` then allowed to be incomplete at that point?
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

No. This is a distinct property of ``shared_ptr`` which implies some overhead.

However, one can leave ``T`` incomplete in the header file::

    // foo.hpp
    class Foo { ... };
    new_clone( const Foo& ) { ... }
    delete_clone( const Foo* )     { ... }
    
    // x.hpp
    class Foo; // Foo is incomplete here
    class X { ptr_deque<Foo> container; ... }

    // x.cpp
    #include <x.hpp>
    #include <foo.hpp> // now Foo is not incomplete anymore
    ...
    
    
 
Why do iterator-range inserts give the strong exception-safety guarantee?
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Is this not very inefficient?  It is because it is actually affordable to 
do so; the overhead is one heap-allocation which is relatively small 
compared to cloning N objects.  

What is the _`polymorphic class problem`? 
+++++++++++++++++++++++++++++++++++++++++

The problem refers to the relatively troublesome way C++ supports Object 
Oriented programming in connection with containers of pointers to 
polymorphic objects.  In a language without garbage collection, you end up 
using either a container of smart pointers or a container that takes 
ownership of the pointers.  The hard part is to find a safe, fast and 
elegant solution.  

Are the pointer containers faster and do they have a better memory  footprint than a container of smart pointers?  
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The short answer is yes: they are faster and they do use less memory; in 
fact, they are the only way to obtain the zero-overhead hallmark of C++.  
Smart pointers usually have one word or more of memory overhead per 
pointer because a reference count must be maintained.  And since the 
reference count must be maintained, there is also a runtime-overhead.  If 
your objects are big, then the memory overhead is often negligible, but if 
you have many small objects, it is not.  Further reading can be found in 
these references: `[11] <ptr_container.html#references>`_ and `[12] <ptr_container.html#references>`_.

When the stored pointers cannot be ``0``, how do I allow this "empty" behavior anyway?
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Storing a null-pointer among a list of pointers does not fit well into the Object Oriented paradigm. 
The most elegant design is to use the Null-Object Pattern where one basically makes a concrete
class with dummy implementations of the virtual functions. See `[13] <ptr_container.html#references>`_ for details.

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

======== 
Tutorial 
======== 

The tutorial shows you the most simple usage of the
library. It is assumed that the reader is familiar
with the use of standard containers. Although
the tutorial is devided into sections, it is recommended
that you read it all from top to bottom.

* `Basic usage`_
* `Indirected interface`_
* `Sequence containers`_
* `Associative containers`_
* `Null values`_
* `Cloneability`_
* `New functions`_
* `std::auto_ptr<U> overloads`_
* `Algorithms`_

Basic usage
-----------

The most important aspect of a pointer container is that it manages
memory for you. This means that you in most cases do not need to worry
about deleting memory. 

Let us assume that we have an OO-hierarchy of animals

.. parsed-literal::

    class animal : `boost::noncopyable <http://www.boost.org/libs/utility/utility.htm#Class_noncopyable>`_
    {
    public:
        virtual      ~animal()   {}
        virtual void eat()       = 0;
        virtual int  age() const = 0;
        // ...
    };
    
    class mammal : public animal
    {
        // ...
    };
    
    class bird : public animal
    {
        // ...
    };


Then the managing of the animals is straight-forward. Imagine a 
Zoo::

    class zoo
    {
        boost::ptr_vector<animal> the_animals;
    public:

        void add_animal( animal* a )
        {
            the_animals.push_back( a );
        }
    };

Notice how we just pass the class name to the container; there
is no ``*`` to indicate it is a pointer.
With this declaration we can now say::
    
    zoo the_zoo;
    the_zoo.add_animal( new mammal("joe") );
    the_zoo.add_animal( new bird("dodo") );

Thus we heap-allocate all elements of the container
and never rely on copy-semantics. 

Indirected interface
--------------------

A particular feature of the pointer containers is that
the query interface is indirected. For example, ::

    boost::ptr_vector<animal> vec;
    vec.push_back( new animal ); // you add it as pointer ...
    vec[0].eat();                // but get a reference back

This indirection also happens to iterators, so ::

    typedef std::vector<animal*> std_vec;
    std_vec vec;
    ...
    std_vec::iterator i = vec.begin();
    (*i)->eat(); // '*' needed
    
now becomes ::
   
    typedef boost::ptr_vector<animal>  ptr_vec;
    ptr_vec vec;
    ptr_vec::iterator i = vec.begin();
    i->eat(); // no indirection needed
    

Sequence containers
-------------------

The sequence containers are used when you do not need to
keep an ordering on your elements. You can basically
expect all operations of the normal standard containers
to be available. So, for example, with a  ``ptr_deque``
and ``ptr_list`` object you can say::

    boost::ptr_deque<animal> deq;
    deq.push_front( new animal );    
    deq.pop_front();

because ``std::deque`` and ``std::list`` have ``push_front()``
and ``pop_front()`` members. 

If the standard sequence supports
random access, so does the pointer container; for example::

    for( boost::ptr_deque<animal>::size_type i = 0u;
         i != deq.size(); ++i )
         deq[i].eat();

The ``ptr_vector`` also allows you to specify the size of
the buffer to allocate; for example ::

    boost::ptr_vector<animal> animals( 10u );

will reserve room for 10 animals.              

Associative containers
----------------------

To keep an ordering on our animals, we could use a ``ptr_set``::

    boost::ptr_set<animal> set;
    set.insert( new monkey("bobo") );
    set.insert( new whale("anna") );
    ...
    
This requires that ``operator<()`` is defined for animals. One
way to do this could be ::

    inline bool operator<( const animal& l, const animal& r )
    {
        return l.name() < r.name();
    }
    
if we wanted to keep the animals sorted by name.

Maybe you want to keep all the animals in zoo ordered wrt.
their name, but it so happens that many animals have the
same name. We can then use a ``ptr_multimap``::

    typedef boost::ptr_multimap<std::string,animal> zoo_type;
    zoo_type zoo;
    std::string bobo = "bobo",
                anna = "anna";
    zoo.insert( bobo, new monkey(bobo) );
    zoo.insert( bobo, new elephant(bobo) );
    zoo.insert( anna, new whale(anna) );
    zoo.insert( anna, new emu(anna) );
    
Note that must create the key as an lvalue 
(due to exception-safety issues); the following would not 
have compiled ::

    zoo.insert( "bobo", // this is bad, but you get compile error
                new monkey("bobo") );

If a multimap is not needed, we can use ``operator[]()``
to avoid the clumsiness::

    boost::ptr_map<std::string,animal> animals;
    animals["bobo"].set_name("bobo");

This requires a default constructor for animals and
a function to do the initialization, in this case ``set_name()``.

A better alternative is to use `Boost.Assign <../../assign/index.html>`_
to help you out. In particular, consider

- `ptr_push_back(), ptr_push_front(), ptr_insert() and ptr_map_insert() <../../assign/doc/index.html#ptr_push_back>`_

- `ptr_list_of() <../../assign/doc/index.html#ptr_list_of>`_

For example, the above insertion may now be written ::
        
     boost::ptr_multimap<std::string,animal> animals;

     using namespace boost::assign;
     ptr_map_insert<monkey>( animals )( "bobo", "bobo" );
     ptr_map_insert<elephant>( animals )( "bobo", "bobo" );
     ptr_map_insert<whale>( animals )( "anna", "anna" );
     ptr_map_insert<emu>( animals )( "anna", "anna" );
                                        
    
Null values
-----------

By default, if you try to insert null into a container, an exception
is thrown. If you want to allow nulls, then you must
say so explicitly when declaring the container variable ::

    boost::ptr_vector< boost::nullable<animal> > animals_type;
    animals_type animals;
    ...
    animals.insert( animals.end(), new dodo("fido") );
    animals.insert( animals.begin(), 0 ) // ok

Once you have inserted a null into the container, you must
always check if the value is null before accessing the object ::

    for( animals_type::iterator i = animals.begin();
         i != animals.end(); ++i )
    {
        if( !boost::is_null(i) ) // always check for validity
            i->eat();
    }

If the container support random access, you may also check this as ::

    for( animals_type::size_type i = 0u; 
         i != animals.size(); ++i )
    {
        if( !animals.is_null(i) )
             animals[i].eat();
    }

Note that it is meaningless to insert
null into ``ptr_set`` and ``ptr_multiset``. 

Cloneability
------------

In OO programming it is typical to prohibit copying of objects; the 
objects may sometimes be allowed to be Cloneable; for example,::

    animal* animal::clone() const
    {
        return do_clone(); // implemented by private virtual function
    }

If the OO hierarchy thus allows cloning, we need to tell the 
pointer containers how cloning is to be done. This is simply
done by defining a free-standing function, ``new_clone()``, 
in the same namespace as
the object hierarchy::

    inline animal* new_clone( const animal& a )
    {
        return a.clone();
    }

That is all, now a lot of functions in a pointer container
can exploit the cloneability of the animal objects. For example ::

    typedef boost::ptr_list<animal> zoo_type;
    zoo_type zoo, another_zoo;
    ...
    another_zoo.assign( zoo.begin(), zoo.end() );

will fill another zoo with clones of the first zoo. Similarly,
``insert()`` can now insert clones into your pointer container ::

    another_zoo.insert( another_zoo.begin(), zoo.begin(), zoo.end() );

The whole container can now also be cloned ::

    zoo_type yet_another_zoo = zoo.clone();

Copying or assigning the container has the same effect as cloning (though it is slightly cheaper)::    

    zoo_type yet_another_zoo = zoo;
    
Copying also support derived-to-base class conversions::

    boost::ptr_vector<monkey> monkeys = boost::assign::ptr_list_of<monkey>( "bobo" )( "bebe")( "uhuh" );
    boost::ptr_vector<animal> animals = monkeys;

This also works for maps::

    boost::ptr_map<std::string,monkey> monkeys = ...;
    boost::ptr_map<std::string,animal> animals = monkeys;
    
New functions
-------------

Given that we know we are working with pointers, a few new functions
make sense. For example, say you want to remove an
animal from the zoo ::

    zoo_type::auto_type the_animal = zoo.release( zoo.begin() );
    the_animal->eat();
    animal* the_animal_ptr = the_animal.release(); // now this is not deleted
    zoo.release(2); // for random access containers

You can think of ``auto_type`` as a non-copyable form of 
``std::auto_ptr``. Notice that when you release an object, the
pointer is removed from the container and the containers size
shrinks. For containers that store nulls, we can exploit that
``auto_type`` is convertible to ``bool``::

    if( ptr_vector< nullable<T> >::auto_type r = vec.pop_back() )
    {
      ...
    }  

You can also release the entire container if you
want to return it from a function ::

    std::auto_ptr< boost::ptr_deque<animal> > get_zoo()
    {
        boost::ptr_deque<animal>  result;
        ...
        return result.release(); // give up ownership
    }
    ...
    boost::ptr_deque<animal> animals = get_zoo();    

Let us assume we want to move an animal object from
one zoo to another. In other words, we want to move the 
animal and the responsibility of it to another zoo ::
    
    another_zoo.transfer( another_zoo.end(), // insert before end 
                          zoo.begin(),       // insert this animal ...
                          zoo );             // from this container
    
This kind of "move-semantics" is different from
normal value-based containers. You can think of ``transfer()``
as the same as ``splice()`` on ``std::list``.

If you want to replace an element, you can easily do so ::

    zoo_type::auto_type old_animal = zoo.replace( zoo.begin(), new monkey("bibi") ); 
    zoo.replace( 2, old_animal.release() ); // for random access containers

A map is slightly different to iterate over than standard maps.
Now we say ::

    typedef boost::ptr_map<std::string, boost::nullable<animal> > animal_map;
    animal_map map;
    ...
    for( animal_map::const_iterator i = map.begin(), e = map.end(); i != e; ++i )
    {
        std::cout << "\n key: " << i->first;
        std::cout << "\n age: ";
        
        if( boost::is_null(i) )
            std::cout << "unknown";
        else
            std::cout << i->second->age(); 
     }

Except for the check for null, this looks like it would with a normal map. But if ``age()`` had 
not been a ``const`` member function,
it would not have compiled.
            
Maps can also be indexed with bounds-checking ::

    try
    {
        animal& bobo = map.at("bobo");
    }
    catch( boost::bad_ptr_container_operation& e )
    {
        // "bobo" not found
    }        

``std::auto_ptr<U>`` overloads
------------------------------

Every time there is a function that takes a ``T*`` parameter, there is
also a function taking an ``std::auto_ptr<U>`` parameter. This is of course done
to make the library intregrate seamlessly with ``std::auto_ptr``. For example ::

  std::ptr_vector<Base> vec;
  vec.push_back( new Base );
  
is complemented by ::

  std::auto_ptr<Derived> p( new Derived );
  vec.push_back( p );   

Notice that the template argument for ``std::auto_ptr`` does not need to
follow the template argument for ``ptr_vector`` as long as ``Derived*``
can be implicitly converted to ``Base*``.

Algorithms
----------

Unfortunately it is not possible to use pointer containers with
mutating algorithms from the standard library. However,
the most useful ones
are instead provided as member functions::

    boost::ptr_vector<animal> zoo;
    ...
    zoo.sort();                               // assume 'bool operator<( const animal&, const animal& )'
    zoo.sort( std::less<animal>() );          // the same, notice no '*' is present
    zoo.sort( zoo.begin(), zoo.begin() + 5 ); // sort selected range

Notice that predicates are automatically wrapped in an `indirect_fun`_ object.

..  _`indirect_fun`: indirect_fun.html

You can remove equal and adjacent elements using ``unique()``::
   
    zoo.unique();                             // assume 'bool operator==( const animal&, const animal& )'
    zoo.unique( zoo.begin(), zoo.begin() + 5, my_comparison_predicate() ); 

If you just want to remove certain elements, use ``erase_if``::

    zoo.erase_if( my_predicate() );

Finally you may want to merge two sorted containers::

    boost::ptr_vector<animal> another_zoo = ...;
    another_zoo.sort();                      // sorted wrt. to same order as 'zoo'
    zoo.merge( another_zoo );
    BOOST_ASSERT( another_zoo.empty() );    
         
That is all; now you have learned all the basics!

.. raw:: html 

        <hr>
        
**See also**

- `Usage guidelines <guidelines.html>`_ 

- `Cast utilities <../../conversion/cast.htm#Polymorphic_castl>`_

**Navigate**

- `home <ptr_container.html>`_
- `examples <examples.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt

++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_deque``
--------------------

A ``ptr_deque<T>`` is a pointer container that uses an underlying ``std:deque<void*>``
to store the pointers. 

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `ptr_sequence_adapter <ptr_sequence_adapter.html>`_

    - `ptr_vector <ptr_vector.html>`_
    - `ptr_list <ptr_list.html>`_ 
    - ``ptr_deque``
    - `ptr_array <ptr_array.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_


**Synopsis:**

.. parsed-literal::  
           
        namespace boost
        {      
        
            template
            < 
                class T, 
                class CloneAllocator = heap_clone_allocator
                class Allocator      = std::allocator<void*>
            >
            class ptr_deque : public ptr_sequence_adapter
                                     <
                                        T,
                                        std::deque<void*,Allocator>,
                                        CloneAllocator
                                     >
            {

            public: // `element access`_
                T&        operator[]( size_type n );
                const T&  operator[]( size_type n ) const;
                T&        at( size_type n );
                const T&  at( size_type n ) const;
    
            public: // modifiers_
                void      push_front( T* x );
		template< class U >
		void      push_front( std::auto_ptr<U> x );
                auto_type pop_front();

            public: // `pointer container requirements`_
               auto_type replace( size_type idx, T* x );
	       template< class U >
	       auto_type replace( size_type idx, std::auto_ptr<U> x );    
               bool      is_null( size_type idx ) const;   
    
            };

        } // namespace 'boost'  


.. _`reversible_ptr_container`: reversible_ptr_container.html 

.. _`ptr_sequence_adapter`: ptr_sequence_adapter.html

Semantics
---------

.. _modifiers:
 
Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``void push_front( T* x );``

    - Requirements: ``x != 0``

    - Effects: Inserts the pointer into container and takes ownership of it
    
    - Throws: ``bad_pointer`` if ``x == 0``

    - Exception safety: Strong guarantee

- ``template< class U > void push_front( std::auto_ptr<U> x );``

    - Effects: ``push_front( x.release() );``

.. 
        - ``void push_front( const T& x );``
    
        - Effects: push_front( allocate_clone( x ) );
    
        - Exception safety: Strong guarantee

- ``auto_type pop_front():``

    - Requirements:``not empty()``
    
    - Effects: Removes the first element in the container

    - Postconditions: ``size()`` is one less

    - Throws: ``bad_ptr_container_operation`` if ``empty() == true``
    
    - Exception safety: Strong guarantee


.. _`element access`:

Semantics: element access
^^^^^^^^^^^^^^^^^^^^^^^^^

- ``T& operator[]( size_type n );``
- ``const T& operator[]( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: Nothing

- ``T& at( size_type n );``
- ``const T& at( size_type n ) const;``

    - Requirements: ``n < size()``

    - Effects: Returns a reference to the ``n``'th element

    - Throws: ``bad_index`` if ``n >=size()``


.. _`pointer container requirements`:

Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``auto_type replace( size_type idx, T* x );``    

    - Requirements: `` x != 0 and idx < size()``

    - Effects: returns the object indexed by ``idx`` and replaces it with ``x``.

    - Throws: ``bad_index`` if ``idx >= size()`` and ``bad_pointer`` if ``x == 0``.

    - Exception safety: Strong guarantee
    
- ``template< class U > auto_type replace( size_type idx, std::auto_ptr<U> x );``

    - Effects: ``return replace( idx, x.release() );``

- ``bool is_null( size_type idx ) const;``

    - Requirements: ``idx < size()``

    - Effects: returns whether the pointer at index ``idx`` is null

    - Exception safety: Nothrow guarantee

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

================
Usage Guidelines
================

.. contents:: :local: 

Choosing the right container
----------------------------

The recommended usage pattern of the container classes is the same as 
for normal standard containers.  

``ptr_vector``, ``ptr_list`` and ``ptr_deque`` offer the programmer different 
complexity tradeoffs and should be used accordingly.  ``ptr_vector`` is the 
type of sequence that should be used by default.  ``ptr_list`` should be used 
when there are frequent insertions and deletions from the middle of the 
sequence and if the container is fairly large (eg.  more than 100 
elements).  ``ptr_deque`` is the data structure of choice when most insertions 
and deletions take place at the beginning or at the end of the sequence.  
The special container ``ptr_array`` may be used when the size of the container is invariant
and known at compile time.

An associative container supports unique keys if it may contain at most 
one element for each key. Otherwise, it supports equivalent keys.  
``ptr_set`` and ``ptr_map`` support unique keys.  
``ptr_multiset`` and ``ptr_multimap`` 
support equivalent keys.  

Recommended practice for Object-Oriented Programming
----------------------------------------------------

Idiomatic Object-Oriented Programming in C++ looks a bit different from 
the way it is done in other languages. This is partly because C++ 
has both value and reference semantics, and partly because C++ is more flexible
than other languages. Below is a list of recommendations that you are
encouraged to follow:

1. Make base classes abstract and without data
++++++++++++++++++++++++++++++++++++++++++++++

This has the following advantages:

        a. It reduces *coupling* because you do not have to maintain or update state

        ..
                
        b. It helps you to avoid *slicing*
        
        ..
        
        c. It ensures you *override* the right function

You might also want to read the following articles:

- Kevlin Henney's `Six of the best`__

.. __: http://www.two-sdg.demon.co.uk/curbralan/papers/SixOfTheBest.pdf

- Jack Reeves' `Multiple Inheritance Considered Useful`__

.. __: http://www.ddj.com/documents/s=10011/q=1/cuj0602reeves/0602reeves.html

  
2. Make virtual functions private and provide a non-virtual public forwarding function
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In code::

        class Polymorphic
        {
        private:
            virtual int do_foo() = 0;
            
        public:
            int foo()
            {
                return do_foo();
            }
            ...
        };      
        
This has the following advantages:

        a. It makes sure all calls to the virtual function always goes through one place in your code
        
        ..
        
        b. It enables you to check preconditions and postconditions inside the forwarding function

You might also want to read Herb Sutter's article `Virtuality`__.

.. __: http://www.gotw.ca/publications/mill18.htm

3. Derive your base class from ``boost::noncopyable``
+++++++++++++++++++++++++++++++++++++++++++++++++++++

Having an abstact base class prevents slicing when the base class is involved, but
it does not prevent it for classes further down the hierarchy. This is where
`boost::noncopyable`__ is handy to use::

        class Polymorphic : boost::noncopyable
        {
          ...
        };

.. __ : http://www.boost.org/libs/utility/utility.htm#Class_noncopyable


4. Avoid null-pointers in containers (if possible)
++++++++++++++++++++++++++++++++++++++++++++++++++

By default the pointer containers do not allow you to store null-pointer in them.
As you might know, this behavior can be changed explicitly with the use
of `boost::nullable`__. 

The primary reason to avoid null-pointers 
is that you have to check for null-pointers every time the container is
used. This extra checking is easy to forget, and it is somewhat contradictory to
the spirit of OO where you replace special cases with dynamic dispatch.

.. __: reference.html#class-nullable

Often, however, you need to place some special object in the container because you
do not have enough information to construct a full object. In that case
you might be able to use the Null Object pattern which simply dictates that
you implement virtual functions from the abstract base-class 
as empty functions or with dummy return values. This means that
your OO-code still does not need to worry about null-pointers.

You might want to read

- Kevlin Henney's `Null Object - Something for Nothing`__

.. __: http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/NullObject.pdf

Finally you might end up in a situation where not even the Null Object can help
you. That is when you truly need ``container< nullable<T> >``. 

.. raw:: html 

        <hr>

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


++++++++++++++++++++++++++++++++++
 |Boost| Pointer Container Library
++++++++++++++++++++++++++++++++++
 
.. |Boost| image:: boost.png

Class ``ptr_multimap_adapter``
------------------------------

This class is used to build custom pointer containers with
an underlying multimap-like container. The interface of the class is an extension
of the interface from ``associative_ptr_container``.

**Hierarchy:**

- `reversible_ptr_container <reversible_ptr_container.html>`_

  - `associative_ptr_container <associative_ptr_container.html>`_
  
    - `ptr_set_adapter <ptr_set_adapter.html>`_
    - `ptr_multiset_adapter <ptr_multiset_adapter.html>`_
    - `ptr_map_adapter <ptr_map_adapter.html>`_
    - ``ptr_multi_map_adapter``

      - `ptr_set <ptr_set.html>`_
      - `ptr_multi_set <ptr_multiset.html>`_ 
      - `ptr_map <ptr_map.html>`_
      - `ptr_multimap <ptr_multimap.html>`_

**Navigate:**

- `home <ptr_container.html>`_
- `reference <reference.html>`_

**Synopsis:**

.. parsed-literal::

                     
        namespace boost
        {
            template
            < 
                T,
                class VoidPtrMultiMap,
                class CloneAllocator = heap_clone_allocator 
            >
            class ptr_multimap_adapter 
            {
    	    public: // `typedefs`_
		typedef VoidPtrMap::key_type key_type;
		typedef T*                   mapped_type;
		typedef T&                   mapped_reference;
		typedef const T&             const_mapped_reference;
		typedef ...                  value_type;
		typedef ...                  reference;
		typedef ...                  const_reference;
		typedef ...                  pointer;
		typedef ...                  const_pointer;  
                
            public: // `modifiers`_         
                iterator  insert( key_type& k, T* x ); 
		template< class U >
		iterator  insert( const key_type&, std::auto_ptr<U> x );                        

            public: // `pointer container requirements`_
                void      transfer( iterator object, ptr_multimap_adapter& from );
                size_type transfer( iterator first, iterator last, ptr_multimap_adapter& from );
                template< class Range >
                size_type transfer( const Range& r, ptr_multimap_adapter& from );
                void      transfer( ptr_multimap_adapter& from );

            }; //  class 'ptr_multimap_adapter'
        
        } // namespace 'boost'  

            
Semantics
---------

. _`typedefs`:

Semantics: typedefs
^^^^^^^^^^^^^^^^^^^

The following types are implementation defined::

	typedef ... value_type;
	typedef ... reference;
	typedef ... const_reference;
	typedef ... pointer;
	typedef ... const_pointer;  
        
However, the structure of the type mimics ``std::pair`` s.t. one
can use ``first`` and ``second`` members. The reference-types
are not real references and the pointer-types are not real pointers.
However, one may still write ::

    map_type::value_type       a_value      = *m.begin();
    a_value.second->foo();
    map_type::reference        a_reference  = *m.begin();
    a_reference.second->foo();
    map_type::const_reference  a_creference = *const_begin(m);
    map_type::pointer          a_pointer    = &*m.begin();
    a_pointer->second->foo();
    map_type::const_pointer    a_cpointer   = &*const_begin(m);

The difference compared to ``std::map<Key,T*>`` is that constness
is propagated to the pointer (that is, to ``second``) in ``const_itertor``. 	

.. _`modifiers`:

Semantics: modifiers
^^^^^^^^^^^^^^^^^^^^

- ``iterator insert( key_type& k, T* x );``

    - Requirements: ``x != 0``

    - Effects: Takes ownership of ``x`` and returns an iterator pointing to it.

    - Throws: bad_pointer if ``x == 0``

    - Exception safety: Strong guarantee

- ``template< class U > iterator insert( const key_type& k, std::auto_ptr<U> x );``                         

   - Equivalent to (but without the ``const_cast``): ``return insert( const_cast<key_type&>(k), x.release() );``

.. 
        - ``iterator insert( key_type& k, const_reference x );``
    
        - Effects: ``return insert( allocate_clone( x ) );``
    
        - Exception safety: Strong guarantee


.. _`lookup`: 

..
        Semantics: lookup
        ^^^^^^^^^^^^^^^^^
        
        - ``reference        operator[]( const Key& key );``
        - ``const_reference  operator[]( const Key& key ) const;``
        
            - Requirements: the key exists
        
            - Effects: returns the object with key ``key``
        
            - Throws: ``bad_ptr_container_operation`` if the key does not exist                                 

.. _`pointer container requirements`:
        
Semantics: pointer container requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``void transfer( iterator object, ptr_multimap_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the object defined by ``object`` into the container and remove it from ``from``. 

   - Postconditions: ``size()`` is one more, ``from.size()`` is one less.

   - Exception safety: Strong guarantee

- ``void transfer( iterator first, iterator last, ptr_multimap_adapter& from );``

   - Requirements: ``not from.empty()``

   - Effects: Inserts the objects defined by the range ``[first,last)`` into the container and remove it from ``from``.

   - Postconditions: Let ``N == std::distance(first,last);`` then ``size()`` is ``N`` more, ``from.size()`` is ``N`` less.
              
   - Exception safety: Basic guarantee

- ``template< class Range > void transfer( const Range& r, ptr_multimap_adapter& from );``

    - Effects: ``transfer( boost::begin(r), boost::end(r), from );``

- ``void transfer( ptr_multimap_adapter& from );``

   - Effects: ``transfer( from.begin(), from.end(), from );``.

   - Postconditions: ``from.empty();``

   - Exception safety: Basic guarantee
 
.. raw:: html 

        <hr>

:Copyright:     Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 The Boost Parameter Library Reference Documentation 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

:Authors:       David Abrahams, Daniel Wallin
:Contact:       dave@boost-consulting.com, daniel@boostpro.com
:organization:  `BoostPro Computing`_
:date:          $Date: 2005/07/17 19:53:01 $

:copyright:     Copyright David Abrahams, Daniel Wallin
                2005-2009. Distributed under the Boost Software License,
                Version 1.0. (See accompanying file LICENSE_1_0.txt
                or copy at http://www.boost.org/LICENSE_1_0.txt)

|(logo)|__

.. |(logo)| image:: ../../../../boost.png
   :alt: Boost

__ ../../../../index.htm

.. _`BoostPro Computing`: http://www.boostpro.com


//////////////////////////////////////////////////////////////////////////////

.. contents::
    :depth: 2

//////////////////////////////////////////////////////////////////////////////

.. role:: class
    :class: class

.. role:: concept
    :class: concept

.. role:: function
    :class: function

.. |ArgumentPack| replace:: :concept:`ArgumentPack`
.. |ForwardSequence| replace:: :concept:`Forward Sequence`
.. |ParameterSpec| replace:: :concept:`ParameterSpec`

.. role:: vellipsis
   :class: vellipsis

.. section-numbering::
    :depth: 2

Preliminaries
=============

This section covers some basic information you'll need to know in
order to understand this reference

Namespaces
----------

In this document, all unqualified identifiers should be assumed to
be defined in namespace ``boost::parameter`` unless otherwise
specified.

Exceptions
----------

No operation described in this document
throws an exception unless otherwise specified.

Thread Safety
-------------

All components of this library can be used safely from multiple
threads without synchronization.  [#thread]_

Typography
----------

Names written in :concept:`sans serif type` represent concepts_.

In code blocks, *italic type* represents unspecified text that
satisfies the requirements given in the detailed description that
follows the code block.

In a specification of the tokens generated by a macro, **bold
type** is used to highlight the position of the expanded macro
argument in the result.

The special character β represents the value of |BOOST_PARAMETER_MAX_ARITY|_.

//////////////////////////////////////////////////////////////////////////////

Terminology
===========

.. |kw| replace:: keyword
.. _kw:

keyword
  The name of a function parameter.

.. _keyword tag type:
.. |keyword tag type| replace:: `keyword tag type`_

keyword tag type
  A type used to uniquely identify a function parameter.  Typically
  its name will be the same as that of the parameter.

.. _positional:
.. |positional| replace:: `positional`_

positional argument
  An argument passed with no explicit |kw|.  Its parameter is
  determined in the usual C++ way: by position with respect to a
  parameter list.

.. _tag type:
.. |tag type| replace:: `tag type`_

tag type
  Shorthand for “\ |keyword tag type|.”

.. _keyword object:
.. |keyword object| replace:: `keyword object`_

keyword object
  An instance of |keyword|_ ``<T>`` for some |tag
  type| ``T``.

.. _tagged reference:
.. |tagged reference| replace:: `tagged reference`_

tagged reference
  An object whose type is associated with a |keyword tag type| (the
  object's *keyword*), and that holds a reference (to the object's
  *value*).  

  As a shorthand, a “tagged reference to ``x``\ ” means a tagged
  reference whose *value* is ``x``.

.. _tagged default:
.. |tagged default| replace:: `tagged default`_

tagged default 
  A |tagged reference| whose *value* represents the value of a
  default argument. 

.. _tagged lazy default:
.. |tagged lazy default| replace:: `tagged lazy default`_

tagged lazy default 
  A |tagged reference| whose *value*, when invoked with no
  arguments, computes a default argument value.

.. _intended argument type:
.. |intended argument type| replace:: `intended argument type`_

intended argument type
  The *intended argument type* of a single-element |ArgumentPack|_ is the
  type of its element's *value*.  The intended argument type of any other
  type ``X`` is ``X`` itself.

.. Note::

   In this reference, we will use concept names (and other names)
   to describe both types and objects, depending on context.  So
   for example, “an |ArgumentPack|_\ ” can refer to a type that
   models |ArgumentPack|_ *or* an object of such a type. 

//////////////////////////////////////////////////////////////////////////////

Concepts
========

This section describes the generic type concepts_ used by the Parameter library. 

.. _concepts: http://www.boost.org/more/generic_programming.html#concept

|ArgumentPack|
--------------

An |ArgumentPack| is a collection of |tagged reference|\ s to the
actual arguments passed to a function.  Every |ArgumentPack| is
also a valid MPL |ForwardSequence|__ consisting of the |keyword tag
type|\ s in its |tagged reference|\ s.

__ ../../../mpl/doc/refmanual/forward-sequence.html

Requirements
............

In the table below, 

* ``A`` is a model of |ArgumentPack|
* ``x`` is an instance of ``A``
* ``u`` is a |keyword object| of type ``K``
* ``v`` is a |tagged default| with |tag type| ``L`` and *value* of type ``D``
* ``w`` is a |tagged lazy default| with |tag type| ``M`` and *value* of type ``E const``
* ``z`` is an |ArgumentPack| containing a single element (as created by |keyword|_\ ``<…>::operator=``)

Any exceptions are thrown from the invocation of ``w``\ 's *value*
will be propagated to the caller.

.. table:: |ArgumentPack| requirements

   +----------+-----------------------------+------------------+--------------------------------------+
   |Expression| Type                        |Requirements      |Semantics/Notes                       |
   +==========+=============================+==================+======================================+
   |``x[u]``  |``binding<A,K>::type``       |``x`` contains an |Returns *b*\ 's *value* (by           |
   |          |                             |element *b* whose |reference).                           |
   |          |                             ||kw|_ is ``K``    |                                      |
   +----------+-----------------------------+------------------+--------------------------------------+
   |``x[u]``  |``binding<A,L,D>::type``     |*none*            |If ``x`` contains an element *b* whose|
   |          |                             |                  ||kw|_ is the same as ``u``\ 's,       |
   |          |                             |                  |returns *b*\ 's *value* (by           |
   |          |                             |                  |reference).  Otherwise, returns ``u``\|
   |          |                             |                  |'s *value*.                           |
   +----------+-----------------------------+------------------+--------------------------------------+
   |``x[w]``  |``lazy_binding<A,M,E>::type``|*none*            |If ``x`` contains an element *b* whose|
   |          |                             |                  ||kw|_ is the same as ``w``\ 's,       |
   |          |                             |                  |returns *b*\ 's *value* (by           |
   |          |                             |                  |reference).  Otherwise, invokes ``w``\|
   |          |                             |                  |'s *value* and returns the result.    |
   +----------+-----------------------------+------------------+--------------------------------------+
   |``x, z``  |Model of |ArgumentPack|      |*none*            |Returns an |ArgumentPack|_ containing |
   |          |                             |                  |all the elements of both ``x`` and    |
   |          |                             |                  |``z``.                                |
   +----------+-----------------------------+------------------+--------------------------------------+



.. _parameterspec:

|ParameterSpec|
---------------

A |ParameterSpec| describes the type requirements for arguments
corresponding to a given |kw|_ and indicates whether the argument
is optional or required.  The table below details the allowed forms
and describes their condition for satisfaction by an actual
argument type. In each row,

.. _conditions:

* ``K`` is the |ParameterSpec|\ 's |keyword tag type|
* ``A`` is an |intended argument type| associated with ``K``, if any
* ``F`` is a unary `MPL lambda expression`_

.. _`MPL lambda expression`: ../../../mpl/doc/refmanual/lambda-expression.html

.. table:: |ParameterSpec| allowed forms and conditions of satisfaction

   +----------------------+--------------+--------------------------------+
   |Type                  |``A`` required|Condition ``A`` must satisfy    |
   +======================+==============+================================+
   |``K``                 |no            |*n/a*                           |
   +----------------------+--------------+--------------------------------+
   ||optional|_\ ``<K,F>``|no            |``mpl::apply<F,A>::type::value``|
   |                      |              |is ``true``.                    |
   +----------------------+--------------+--------------------------------+
   ||required|_\ ``<K,F>``|yes           |``mpl::apply<F,A>::type::value``|
   |                      |              |is ``true``.                    |
   +----------------------+--------------+--------------------------------+

The information in a |ParameterSpec| is used to `limit`__ the
arguments that will be matched by `forwarding functions`_.  

__ overloadcontrol_
.. _overloadcontrol: index.html#controlling-overload-resolution
.. _forwarding functions: index.html#forwarding-functions


//////////////////////////////////////////////////////////////////////////////

Class Templates
===============

.. |keyword| replace:: ``keyword``
.. _keyword:

``keyword``
-----------

The type of every |keyword object| is a specialization of |keyword|.

:Defined in: `boost/parameter/keyword.hpp`__

__ ../../../../boost/parameter/keyword.hpp

.. parsed-literal::

    template <class Tag>
    struct keyword
    {
        template <class T> |ArgumentPack|_ `operator=`_\(T& value) const;
        template <class T> |ArgumentPack|_ `operator=`_\(T const& value) const;

        template <class T> *tagged default* `operator|`_\(T& x) const;
        template <class T> *tagged default* `operator|`_\(T const& x) const;

        template <class F> *tagged lazy default* `operator||`_\(F const&) const;

        static keyword<Tag>& get_\();
    };


.. |operator=| replace:: ``operator=``
.. _operator=:

``operator=``
  .. parsed-literal::

      template <class T> |ArgumentPack|_ operator=(T& value) const;
      template <class T> |ArgumentPack|_ operator=(T const& value) const;

  :Requires: nothing

  :Returns:
      an |ArgumentPack|_  containing a single |tagged reference| to
      ``value`` with |kw|_ ``Tag`` 

.. _operator|:

``operator|``
  .. parsed-literal::

      template <class T> *tagged default* operator|(T& x) const;
      template <class T> *tagged default* operator|(T const& x) const;

  :Returns: a |tagged default| with *value* ``x`` and |kw|_ ``Tag``.

.. _operator||:

``operator||``
  .. parsed-literal::

      template <class F> *tagged lazy default* operator||(F const& g) const;

  :Requires: ``g()`` is valid, with type ``boost::``\ |result_of|_\
    ``<F()>::type``.  [#no_result_of]_


  :Returns: a |tagged lazy default| with *value* ``g`` and |kw|_ ``Tag``.

.. _get:

``get``
  .. parsed-literal::

        static keyword<Tag>& get\();

  :Returns: a “singleton instance”: the same object will be
    returned on each invocation of ``get()``.

  :Thread Safety: ``get()`` can be called from multiple threads
    simultaneously.

``parameters``
--------------

Provides an interface for assembling the actual arguments to a
`forwarding function` into an |ArgumentPack|, in which any
|positional| arguments will be tagged according to the
corresponding template argument to ``parameters``.  

.. _forwarding function: `forwarding functions`_

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

.. parsed-literal::

    template <class P0 = *unspecified*, class P1 = *unspecified*, …class P\ β = *unspecified*>
    struct parameters
    {
        template <class A0, class A1 = *unspecified*, …class A\ β = *unspecified*>
        struct `match`_
        {
            typedef … type;
        };

        template <class A0>
        |ArgumentPack|_ `operator()`_\(A0& a0) const;

        template <class A0, class A1>
        |ArgumentPack|_ `operator()`_\(A0& a0, A1& a1) const; 

        :vellipsis:`⋮`

        template <class A0, class A1, …class A\ β>
        |ArgumentPack|_ `operator()`_\(A0& a0, A1& a1, …A\ β& a\ β) const;
    };


:Requires: ``P0``, ``P1``, … ``P``\ β are models of |ParameterSpec|_. 


.. Note::

  In this section, ``R``\ *i* and ``K``\ *i* are defined as
  follows, for any argument type ``A``\ *i*:


     | let ``D0`` the set [d0, …, d\ *j*] of all **deduced** *parameter specs* in [``P0``, …, ``P``\ β]
     | ``R``\ *i* is ``A``\ *i*\ 's |intended argument type|
     |
     | if ``A``\ *i* is a result type of ``keyword<T>::``\ |operator=|_
     | then 
     |     ``K``\ *i* is ``T``
     | else
     |     if some ``A``\ *j* where *j*\ ≤\ *i* is a result type of ``keyword<T>::``\ |operator=|_
     |     *or* some ``P``\ *j* in *j*\ ≤\ *i* is **deduced**
     |     then
     |         if some *parameter spec* ``d``\ *j* in ``D``\ *i* matches ``A``\ *i*
     |         then
     |             ``K``\ *i* is ``d``\ *j*\ 's |keyword tag type|.
     |             ``D``\ :sub:`i+1` is ``D``\ *i* - [``d``\ *j*]
     |     else
     |         ``K``\ *i* is ``P``\ *i*\ 's |keyword tag type|.


.. _match:

``match``
  A |Metafunction|_ used to remove a `forwarding function`_ from overload resolution.

  :Returns: if ``P0``, ``P1``, …\ ``P``\ β are *satisfied* (see
    below), then ``parameters<P0,P1,…Pβ>``.  Otherwise,
    ``match<A0,A1,…Aβ>::type`` is not defined.

  ``P0``, ``P1``, …\ ``P``\ β are **satisfied** if, for
  every *j* in 0…β, either:

  * ``P``\ *j* is the *unspecified* default
  * **or**, ``P``\ *j* is a *keyword tag type*

  * **or**, ``P``\ *j* is |optional|_ ``<X,F>`` and either

    - ``X`` is not ``K``\ *i* for any *i*,
    - **or** ``X`` is some ``K``\ *i*  and ``mpl::apply<F,R``\ *i*\
      ``>::type::value`` is ``true``

  * **or**, ``P``\ *j* is |required|_ ``<X,F>``, and

    - ``X`` is some ``K``\ *i*, **and**
    - ``mpl::apply<F,R``\ *i*\ ``>::type::value`` is ``true``

.. _operator():

``operator()``
  .. parsed-literal::

      template <class A0> |ArgumentPack|_ operator()(A0 const& a0) const; 

      :vellipsis:`⋮`

      template <class A0, …class A\ β> |ArgumentPack|_ `operator()`_\(A0 const& a0, …A\ β const& a\ β) const;

  :Returns:
      An |ArgumentPack|_ containing, for each ``a``\ *i*,  

      - if ``a``\ *i*,  is a single-element |ArgumentPack|, its element
      - Otherwise, a |tagged reference| with |kw|_ ``K``\ *i* and *value* ``a``\ *i*


.. |optional| replace:: ``optional``
.. |required| replace:: ``required``

.. _optional:
.. _required:

``optional``, ``required``
--------------------------

These templates describe the requirements on a function parameter.

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

:Specializations model: |ParameterSpec|_

.. parsed-literal::

    template <class Tag, class Predicate = *unspecified*>
    struct optional;

    template <class Tag, class Predicate = *unspecified*>
    struct required;

The default value of ``Predicate`` is an unspecified |Metafunction|_ that returns
``mpl::true_`` for any argument.

.. |Metafunction| replace:: :concept:`Metafunction`
.. _Metafunction: ../../../mpl/doc/refmanual/metafunction.html


``deduced``
-----------

This template is used to wrap the *keyword tag* argument to
``optional`` or ``required``.

:Defined in: `boost/parameter/parameters.hpp`__

__ ../../../../boost/parameter/parameters.hpp

.. parsed-literal::

    template <class Tag>
    struct deduced;


//////////////////////////////////////////////////////////////////////////////

Metafunctions
=============

A |Metafunction|_ is conceptually a function that operates on, and
returns, C++ types.

``binding``
-----------

Returns the result type of indexing an argument pack with a
|keyword tag type| or with a |tagged default|.

:Defined n: `boost/parameter/binding.hpp`__

__ ../../../../boost/parameter/binding.hpp

.. parsed-literal::

    template <class A, class K, class D = void>
    struct binding
    {
        typedef … type;
    };

:Requires: ``A`` is a model of |ArgumentPack|_.

:Returns: the reference type of the |tagged reference| in ``A``
  having |keyword tag type| ``K``, if any.  If no such |tagged
  reference| exists, returns ``D``.

``lazy_binding``
----------------

Returns the result type of indexing an argument pack with a |tagged
lazy default|.

:Defined in:
    `boost/parameter/binding.hpp`__

__ ../../../../boost/parameter/binding.hpp

.. parsed-literal::

    template <class A, class K, class F>
    struct lazy_binding
    {
        typedef … type;
    };

:Requires: ``A`` is a model of |ArgumentPack|_.

:Returns: the reference type of the |tagged reference| in ``A``
  having |keyword tag type| ``K``, if any.  If no such |tagged
  reference| exists, returns ``boost::``\ |result_of|_\ ``<F()>::type``. [#no_result_of]_


``value_type``
--------------

Returns the result type of indexing an argument pack with a
|keyword tag type| or with a |tagged default|.

:Defined n: `boost/parameter/value_type.hpp`__

__ ../../../../boost/parameter/value_type.hpp

.. parsed-literal::

    template <class A, class K, class D = void>
    struct value_type
    {
        typedef … type;
    };

:Requires: ``A`` is a model of |ArgumentPack|_.

:Returns: the type of the |tagged reference| in ``A``
  having |keyword tag type| ``K``, if any.  If no such |tagged
  reference| exists, returns ``D``. Equivalent to::

    typename remove_reference<
      typename binding<A, K, D>::type
    >::type

  … when ``D`` is not a reference type.


//////////////////////////////////////////////////////////////////////////////

Code Generation Macros
======================

Macros in this section can be used to ease the writing of code
using the Parameter libray by eliminating repetitive boilerplate.


``BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)``
-----------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

:Requires: ``result`` is the parenthesized return type of the function.
  ``name`` is the base name of the function, this is the name of the
  generated forwarding functions. ``tag_namespace`` is the namespace in
  which the keywords used by the function resides. ``arguments`` is
  a list of *argument specifiers*, as defined below.


:Argument specifiers syntax:
  .. parsed-literal::

    argument-specifiers ::= *specifier-group* {*specifier-group*}

    specifier-group0 ::= *specifier-group1* |
                         ( '**(**' '**deduced**' *specifier-group1* {*specifier-group1*} '**)**' )

    specifier-group1 ::= ( '**(**' '**optional**' *optional-specifier* {*optional-specifier*} '**)**' ) |
                         ( '**(**' '**required**' *required-specifier* {*required-specifier*} '**)**' )

    optional-specifier ::= '**(**' *name* '**,**' *restriction* '**,**' *default-value* ')'
    required-specifier ::= '**(**' *name* '**,**' *restriction* ')'

    restriction ::= ('*****' '**(**' *lambda-expression* '**)**' ) |
                    ( '**(**' *typename* '**)**' ) |
                    '*****'

  ``name`` is any valid C++ identifier. ``default-value`` is any valid
  C++ expression. ``typename`` is the name of a type.
  ``lambda-expression`` is an `MPL lambda expression`_.

.. _`MPL lambda expression`: ../../../mpl/doc/refmanual/lambda-expression.html

:Generated names in enclosing scope:
  * ``boost_param_result_ ## __LINE__ ## name``
  * ``boost_param_params_ ## __LINE__ ## name``
  * ``boost_param_parameters_ ## __LINE__ ## name``
  * ``boost_param_impl ## name``
  * ``boost_param_default_ ## __LINE__ ## name``


Approximate expansion:
  **Where**:

  * ``n`` denotes the *minimum* arity, as determined from ``arguments``.
  * ``m`` denotes the *maximum* arity, as determined from ``arguments``.

  .. parsed-literal::

    template <class T>
    struct boost_param_result\_ ## __LINE__ ## **name**
    {
        typedef **result** type;
    };

    struct boost_param_params\_ ## __LINE__ ## **name**
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {};

    typedef boost_param_params\_ ## __LINE__ ## **name** 
      boost_param_parameters\_ ## __LINE__ ## **name**;

    template <class A0, …, class A\ **n**>
    *result type* **name**\ (
        A0 *cv*\ & a0, …, A\ **n** *cv*\ & a\ **n**
      , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
          A0 *cv*, …, A\ **n** *cv*
        >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
    )
    {
        *… forward to implementation …*
    }

    :vellipsis:`⋮`

    template <class A0, …, class A\ **m**>
    *result type* **name**\ (
        A0 *cv*\ & a0, …, A\ **m** *cv*\ & a\ **m**
      , typename boost_param_parameters\_ ## __LINE__ ## **name**::match<
          A0 *cv*, …, A\ **m** *cv*
        >::type = boost_param_parameters\_ ## __LINE__ ## **name**\ ()
    )
    {
        *… forward to implementation …*
    }

    template <
        class ResultType
      , class *argument name*\ **0** ## _type
        …
      , class *argument name*\ **m** ## _type
    >
    ResultType boost_param_default\_ ## __LINE__ ## **name**\ (
        (ResultType(*)())
      , *argument name*\ **0** ## _type& *argument name*\ **0**
        …
      , *argument name*\ **m** ## _type& *argument name*\ **m**
    )



``BOOST_PARAMETER_MEMBER_FUNCTION(result,name,tag_namespace,arguments)``
------------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

See ``BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)``



``BOOST_PARAMETER_CONSTRUCTOR(cls, impl, tag_namespace, arguments)``
--------------------------------------------------------------------

:Defined in: `boost/parameter/preprocessor.hpp`__

__ ../../../../boost/parameter/preprocessor.hpp

:Requires: ``cls`` is the name of this class. ``impl`` is the 
  parenthesized implementation base class for ``cls``.
  ``tag_namespace`` is the namespace in which the keywords 
  used by the function resides. ``arguments`` is
  a list of *argument specifiers*, as defined in 
  ``BOOST_PARAMETER_FUNCTION(result,name,tag_namespace,arguments)``.

:Generated names in enclosing scope:
  * ``boost_param_params_ ## __LINE__ ## ctor``
  * ``constructor_parameters ## __LINE__``

Approximate expansion:
  **Where**:

  * ``n`` denotes the *minimum* arity, as determined from ``arguments``.
  * ``m`` denotes the *maximum* arity, as determined from ``arguments``.

  .. parsed-literal::

    struct boost_param_params\_ ## __LINE__ ## ctor
      : boost::parameter::parameters<
            *list of parameter specifications, based on arguments*
        >
    {};

    typedef boost_param_params\_ ## __LINE__ ## **name** 
      constructor_parameters ## __LINE__;

    template <class A0, …, class A\ **n**>
    *cls*\ (A0 const& a0, …, A\ **n** const& a\ **n**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a\ **n**))
    {}

    :vellipsis:`⋮`

    template <class A0, …, class A\ **m**>
    *cls*\ (A0 const& a0, …, A\ **n** const& a\ **m**)
      : *impl*\ (constructor_parameters ## __LINE__(a0, …, a\ **m**))
    {}


``BOOST_PARAMETER_NAME(name)``
------------------------------

Declares a tag-type and keyword object.

Expands to:

**If** *name* is of the form:

.. parsed-literal::

  (*tag-name*, *namespace-name*) *object-name*

**then**

.. parsed-literal::

  namespace *namespace-name* 
  {
    struct *tag-name*
    {
        static char const* keyword_name()
        {
            return ##\ *tag-name*;
        }

        typedef *unspecified* _;
        typedef *unspecified* _1;
    };
  }

  ::boost::parameter::keyword<*tag-namespace*\ ::\ *tag-name*\ > const& *object-name*
      = ::boost::parameter::keyword<*tag-namespace*\ ::\ *tag-name*\ >::instance;

**Else**

.. parsed-literal::

  namespace tag
  {
    struct *name*
    {
        static char const* keyword_name()
        {
            return ##\ *name*;
        }

        typedef *unspecified* _;
        typedef *unspecified* _1;
    };
  }

  ::boost::parameter::keyword<tag::\ *name*\ > const& _\ *name*
      = ::boost::parameter::keyword<tag::\ *name*\ >::instance;


``BOOST_PARAMETER_TEMPLATE_KEYWORD(name)``
------------------------------------------

Expands to:

.. parsed-literal::

  namespace tag
  {
    struct *name*;
  }

  template <class T>
  struct *name* 
    : ::boost::parameter::template_keyword<tag::\ *name*, T>
  {};


``BOOST_PARAMETER_FUN(r,n,l,h,p)``
----------------------------------

.. admonition:: Deprecated

  This macro has been deprecated in favor of
  ``BOOST_PARAMETER_FUNCTION``.

Generates a sequence of `forwarding function`_ templates named
``n``, with arities ranging from ``l`` to ``h`` , returning ``r``,
and using ``p`` to control overload resolution and assign tags to
positional arguments.

:Defined in: `boost/parameter/macros.hpp`__

__ ../../../../boost/parameter/macros.hpp

:Requires: ``l`` and ``h`` are nonnegative integer tokens such
  that ``l`` < ``h``

Generates
  .. parsed-literal::

    template <class A1, class A2, …class A##\ **l**>
    r name(
        A1 const& a1, A2 const& a2, …A\ **l** const& x\ **l**
      , typename **p**::match<A1,A2,…A\ **l**>::type p = **p**\ ())
    {
       return **name**\ _with_named_params(**p**\ (x1,x2,…x\ **l**));
    }

    template <class A1, class A2, …class A\ **l**, class A\ ##\ BOOST_PP_INC_\ (**l**)>
    r name(
        A1 const& a1, A2 const& a2, …A\ **l** const& x\ **l**
      , A\ ##\ BOOST_PP_INC_\ (**l**) const& x\ ##\ BOOST_PP_INC_\ (**l**)
      , typename **p**::match<A1,A2,…A\ **l**,A\ ##\ BOOST_PP_INC_\ (**l**)>::type p = **p**\ ())
    {
       return **name**\ _with_named_params(**p**\ (x1,x2,…x\ **l**,x\ ##\ BOOST_PP_INC_\ (**l**)));
    }

    :vellipsis:`⋮`

    template <class A1, class A2, …class A\ **h**>
    r name(
        A1 const& a1, A2 const& a2, …A\ **h** const& x\ **h**
      , typename **p**::match<A1,A2,…A\ **h**>::type p = **p**\ ())
    {
       return **name**\ _with_named_params(**p**\ (a1,a2,…a\ **h**));
    }


.. _BOOST_PP_INC: ../../../preprocessor/doc/ref/inc.html

``BOOST_PARAMETER_KEYWORD(n,k)``
--------------------------------

.. admonition:: Deprecated

  This macro has been deprecated in favor of
  ``BOOST_PARAMETER_NAME``.

Generates the declaration of a |keyword tag type| named ``k`` in
namespace ``n``, and a corresponding |keyword object| definition in
the enclosing namespace.

:Defined in: `boost/parameter/keyword.hpp`__

__ ../../../../boost/parameter/keyword.hpp

Generates
  .. parsed-literal::

      namespace **n** { struct **k**; }
      namespace { 
        boost::parameter::keyword<*tag-namespace*::**k**>& **k**
        = boost::parameter::keyword<*tag-namespace*::**k**>::get();
      }

``BOOST_PARAMETER_MATCH(p,a,x)``
--------------------------------

Generates a defaulted parameter declaration for a `forwarding
function`_.

:Defined in: `boost/parameter/match.hpp`__

__ ../../../../boost/parameter/match.hpp

:Requires: ``a`` is a `Boost.Preprocessor sequence`__ 
  of the form 

  .. parsed-literal::

   (A0)(A1)…(A\ *n*)

__ http://www.boost.org/libs/preprocessor/doc/data.html

Generates
  .. parsed-literal::

    typename **p**::match<**A0**\ ,\ **A1**\ …,\ **A**\ *n*>::type **x** = **p**\ ()


Configuration Macros
====================

``BOOST_PARAMETER_MAX_ARITY``
-----------------------------

Determines the maximum number of arguments supported by the
library.  Will only be ``#defined`` by the library if it is not
already ``#defined``.

.. |BOOST_PARAMETER_MAX_ARITY| replace:: ``BOOST_PARAMETER_MAX_ARITY``

:Defined in: `boost/parameter/config.hpp`__

__ ../../../../boost/parameter/config.hpp

:Default Value: ``8``

Tutorial
========

Follow `this link`__ to the Boost.Parameter tutorial
documentation.  

__ index.html#tutorial

//////////////////////////////////////////////////////////////

.. [#thread] References to tag objects may be initialized multiple
   times.  This scenario can only occur in the presence of
   threading.  Because the C++ standard doesn't consider threading,
   it doesn't explicitly allow or forbid multiple initialization of
   references.  That said, it's hard to imagine an implementation
   where it could make a difference. 

.. [#no_result_of] Where |BOOST_NO_RESULT_OF|_ is ``#defined``,
   ``boost::``\ |result_of|_\ ``<F()>::type`` is replaced by
   ``F::result_type``.

.. |result_of| replace:: ``result_of``
.. _result_of: ../../../utility/utility.htm#result_of

.. |BOOST_NO_RESULT_OF| replace:: ``BOOST_NO_RESULT_OF``
.. _BOOST_NO_RESULT_OF: ../../../utility/utility.htm#BOOST_NO_RESULT_OF

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 The Boost Parameter Library Python Binding Documentation 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

:Authors:       David Abrahams, Daniel Wallin
:Contact:       dave@boost-consulting.com, daniel@boostpro.com
:organization:  `BoostPro Computing`_
:date:          $Date: 2010-05-27 10:58:58 -0700 (Thu, 27 May 2010) $

:copyright:     Copyright David Abrahams, Daniel Wallin
                2005-2009. Distributed under the Boost Software License,
                Version 1.0. (See accompanying file LICENSE_1_0.txt
                or copy at http://www.boost.org/LICENSE_1_0.txt)

:abstract:      Makes it possible to bind Boost.Parameter-enabled
                functions, operators and constructors to Python.

|(logo)|__

.. |(logo)| image:: ../../../../boost.png
   :alt: Boost

__ ../../../../index.htm

.. _`BoostPro Computing`: http://www.boostpro.com


.. role:: class
    :class: class

.. role:: concept
    :class: concept

.. role:: function
    :class: function

.. |ParameterSpec| replace:: :concept:`ParameterSpec`

.. contents::
    :depth: 1

Introduction
------------

``boost/parameter/python.hpp`` introduces a group of |def_visitors|_ that can
be used to easily expose Boost.Parameter-enabled member functions to Python with 
Boost.Python. It also provides a function template ``def()`` that can be used
to expose Boost.Parameter-enabled free functions.

.. |def_visitor| replace:: ``def_visitor``
.. |def_visitors| replace:: ``def_visitors``

.. _def_visitor: def_visitors_
.. _def_visitors: ../../../python/doc/v2/def_visitor.html

When binding a Boost.Parameter enabled function, the keyword tags
must be specified.  Additionally, because Boost.Parameter enabled
functions are templates, the desired function signature must be
specified.

..  The keyword tags are specified as an `MPL Sequence`_, using the
    pointer qualifications described in |ParameterSpec|_ below.  The
    signature is also specifid as an `MPL sequence`_ of parameter
    types. Additionally, ``boost::parameter::python::function`` and
    ``boost::parameter::python::def`` requires a class with forwarding
    overloads. We will take a closer look at how this is done in the
    tutorial section below.

The keyword tags and associated argument types are specified as an `MPL
Sequence`_, using the function type syntax described in |ParameterSpec|_
below. Additionally, ``boost::parameter::python::function`` and
``boost::parameter::python::def`` requires a class with forwarding overloads.
We will take a closer look at how this is done in the tutorial section below.

.. The last two sentences are terribly vague.  Which namespace is
.. ``function`` in?  Isn't the return type always needed?  What
.. else are we going to do other than pass these sequences to
.. function?

.. _`MPL Sequence`: ../../../mpl/doc/refmanual/sequences.html
.. _parameterspec: `concept ParameterSpec`_

Tutorial
--------

In this section we will outline the steps needed to bind a simple
Boost.Parameter-enabled member function to Python. Knowledge of the
Boost.Parameter macros_ are required to understand this section.

.. _macros: index.html

The class and member function we are interested in binding looks
like this:

.. parsed-literal::

  #include <boost/parameter/keyword.hpp>
  #include <boost/parameter/preprocessor.hpp>
  #include <boost/parameter/python.hpp>
  #include <boost/python.hpp>

  // First the keywords
  BOOST_PARAMETER_KEYWORD(tag, title)
  BOOST_PARAMETER_KEYWORD(tag, width)
  BOOST_PARAMETER_KEYWORD(tag, height)

  class window
  {
  public:
      BOOST_PARAMETER_MEMBER_FUNCTION(
        (void), open, tag,
        (required (title, (std::string)))
        (optional (width, (unsigned), 400)
                  (height, (unsigned), 400))
      )
      {
          *… function implementation …*
      }
  };

.. @example.prepend('#include <cassert>')
.. @example.replace_emphasis('''
   assert(title == "foo");
   assert(height == 20);
   assert(width == 400);
   ''')

It defines a set of overloaded member functions called ``open`` with one
required parameter and two optional ones. To bind this member function to
Python we use the binding utility ``boost::parameter::python::function``.
``boost::parameter::python::function`` is a |def_visitor|_ that we'll instantiate
and pass to ``boost::python::class_::def()``.

To use ``boost::parameter::python::function`` we first need to define
a class with forwarding overloads. This is needed because ``window::open()``
is a function template, so we can't refer to it in any other way. 

::

  struct open_fwd
  {
      template <class A0, class A1, class A2>
      void operator()(
          boost::type<void>, window& self
        , A0 const& a0, A1 const& a1, A2 const& a2
      )
      {
          self.open(a0, a1, a2);
      }
  };

The first parameter, ``boost::type<void>``, tells the forwarding overload
what the return type should be. In this case we know that it's always void
but in some cases, when we are exporting several specializations of a
Boost.Parameter-enabled template, we need to use that parameter to
deduce the return type.

``window::open()`` takes a total of 3 parameters, so the forwarding function
needs to take three parameters as well.

.. Note::

    We only need one overload in the forwarding class, despite the
    fact that there are two optional parameters. There are special
    circumstances when several overload are needed; see 
    `special keywords`_.

Next we'll define the module and export the class:

::

  BOOST_PYTHON_MODULE(my_module)
  {
      using namespace boost::python;
      namespace py = boost::parameter::python;
      namespace mpl = boost::mpl;

      class_<window>("window")
          .def(
              "open", py::function<
                  open_fwd
                , mpl::vector<
                      void
                    , tag::title(std::string)
                    , tag::width*(unsigned)
                    , tag::height*(unsigned)
                  >
              >()
          );
  }

.. @jam_prefix.append('import python ;')
.. @jam_prefix.append('stage . : my_module /boost/python//boost_python ;')
.. @my_module = build(
        output = 'my_module'
      , target_rule = 'python-extension'
      , input = '/boost/python//boost_python'
      , howmany = 'all'
    )

.. @del jam_prefix[:]

``py::function`` is passed two parameters. The first one is the class with
forwarding overloads that we defined earlier. The second one is an `MPL
Sequence`_ with the keyword tag types and argument types for the function
specified as function types. The pointer syntax used in ``tag::width*`` and
``tag::height*`` means that the parameter is optional. The first element of
the `MPL Sequence`_ is the return type of the function, in this case ``void``,
which is passed as the first argument to ``operator()`` in the forwarding
class.

..  The
    pointer syntax means that the parameter is optional, so in this case
    ``width`` and ``height`` are optional parameters. The third parameter
    is an `MPL Sequence`_ with the desired function signature. The return type comes first, and
    then the parameter types:

    .. parsed-literal::

        mpl::vector<void,        std::string, unsigned, unsigned>
                    *return type*  *title*        *width*     *height*

    .. @ignore()

That's it! This class can now be used in Python with the expected syntax::

    >>> w = my_module.window()
    >>> w.open(title = "foo", height = 20)

.. @example.prepend('import my_module')
.. @run_python(module_path = my_module)

.. Sorry to say this at such a late date, but this syntax really
.. strikes me as cumbersome.  Couldn't we do something like:

    class_<window>("window")
          .def(
              "open", 
              (void (*)( 
                  tag::title(std::string), 
                  tag::width*(unsigned), 
                  tag::height*(unsigned)) 
              )0
          );

   or at least:

      class_<window>("window")
          .def(
              "open", 
              mpl::vector<
                  void, 
                  tag::title(std::string), 
                  tag::width*(unsigned), 
                  tag::height*(unsigned)
              >()
          );

   assuming, that is, that we will have to repeat the tags (yes,
   users of broken compilers will have to give us function pointer
   types instead).

------------------------------------------------------------------------------

concept |ParameterSpec|
-----------------------

A |ParameterSpec| is a function type ``K(T)`` that describes both the keyword tag,
``K``, and the argument type, ``T``, for a parameter.

``K`` is either:

* A *required* keyword of the form ``Tag``
* **or**, an *optional* keyword of the form ``Tag*``
* **or**, a *special* keyword of the form ``Tag**``

where ``Tag`` is a keyword tag type, as used in a specialization
of |keyword|__.

.. |keyword| replace:: ``boost::parameter::keyword``
__ ../../../parameter/doc/html/reference.html#keyword

The **arity range** for an `MPL Sequence`_ of |ParameterSpec|'s is
defined as the closed range:

.. parsed-literal::

  [ mpl::size<S> - number of *special* keyword tags in ``S``, mpl::size<S> ]

For example, the **arity range** of ``mpl::vector2<x(int),y(int)>`` is ``[2,2]``,
the **arity range** of ``mpl::vector2<x(int),y*(int)>`` is ``[2,2]`` and the
**arity range** of ``mpl::vector2<x(int),y**(int)>`` is ``[1,2]``.



*special* keywords
---------------------------------

Sometimes it is desirable to have a default value for a parameter that differ
in type from the parameter. This technique is useful for doing simple tag-dispatching
based on the presence of a parameter. For example:

.. An example_ of this is given in the Boost.Parameter
   docs. The example uses a different technique, but could also have been written like this:

.. parsed-literal::

  namespace core
  {
    template <class ArgumentPack>
    void dfs_dispatch(ArgumentPack const& args, mpl::false\_)
    {
        *…compute and use default color map…*
    }

    template <class ArgumentPack, class ColorMap>
    void dfs_dispatch(ArgumentPack const& args, ColorMap colormap)
    {
        *…use colormap…*
    }
  }

  template <class ArgumentPack>
  void depth_first_search(ArgumentPack const& args)
  {
      core::dfs_dispatch(args, args[color | mpl::false_()]);
  }

.. @example.prepend('''
   #include <boost/parameter/keyword.hpp>
   #include <boost/parameter/parameters.hpp>
   #include <boost/mpl/bool.hpp>
   #include <cassert>

   BOOST_PARAMETER_KEYWORD(tag, color);

   typedef boost::parameter::parameters<tag::color> params;

   namespace mpl = boost::mpl;
   ''')

.. @example.replace_emphasis('''
   assert(args[color | 1] == 1);
   ''')

.. @example.replace_emphasis('''
   assert(args[color | 1] == 0);
   ''')

.. @example.append('''
   int main()
   {
       depth_first_search(params()());
       depth_first_search(params()(color = 0));
   }''')

.. @build()

.. .. _example: index.html#dispatching-based-on-the-presence-of-a-default

In the above example the type of the default for ``color`` is ``mpl::false_``, a
type that is distinct from any color map that the user might supply.

When binding the case outlined above, the default type for ``color`` will not
be convertible to the parameter type. Therefore we need to tag the ``color``
keyword as a *special* keyword. This is done by specifying the tag as
``tag::color**`` when binding the function (see `concept ParameterSpec`_ for
more details on the tagging). By doing this we tell the binding functions that
it needs to generate two overloads, one with the ``color`` parameter present
and one without. Had there been two *special* keywords, four overloads would
need to be generated. The number of generated overloads is equal to 2\
:sup:`N`, where ``N`` is the number of *special* keywords.

------------------------------------------------------------------------------

class template ``init``
-----------------------

Defines a named parameter enabled constructor.

.. parsed-literal::

    template <class ParameterSpecs>
    struct init : python::def_visitor<init<ParameterSpecs> >
    {
        template <class Class> 
        void def(Class& class\_);

        template <class CallPolicies>
        *def\_visitor* operator[](CallPolicies const& policies) const;
    };

.. @ignore()

``init`` requirements 
~~~~~~~~~~~~~~~~~~~~~

* ``ParameterSpecs`` is an `MPL sequence`_ where each element is a
  model of |ParameterSpec|. 
* For every ``N`` in ``[U,V]``, where ``[U,V]`` is the **arity
  range** of ``ParameterSpecs``, ``Class`` must support these
  expressions: 

  ======================= ============= =========================================
  Expression              Return type   Requirements
  ======================= ============= =========================================
  ``Class(a0, …, aN)``    \-            ``a0``\ …\ ``aN`` are tagged arguments.
  ======================= ============= =========================================



``template <class CallPolicies> operator[](CallPolicies const&)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Returns a ``def_visitor`` equivalent to ``*this``, except that it
uses CallPolicies when creating the binding.


Example
~~~~~~~

.. parsed-literal::

    #include <boost/parameter/keyword.hpp>
    #include <boost/parameter/preprocessor.hpp>
    #include <boost/parameter/python.hpp>
    #include <boost/python.hpp>
    #include <boost/mpl/vector.hpp>

    BOOST_PARAMETER_KEYWORD(tag, x)
    BOOST_PARAMETER_KEYWORD(tag, y)

    struct base 
    { 
        template <class ArgumentPack>
        base(ArgumentPack const& args)
        {
            *… use args …*
        }
    };

    class X : base
    {
    public:
        BOOST_PARAMETER_CONSTRUCTOR(X, (base), tag,
            (required (x, \*))
            (optional (y, \*))
        )
    };

    BOOST_PYTHON_MODULE(*module name*)
    {
        using namespace boost::python;
        namespace py = boost::parameter::python;
        namespace mpl = boost::mpl;

        class_<X>("X", no_init)
            .def(
                py::init<
                    mpl::vector<tag::x(int), tag::y\*(int)>
                >()
            );
    }

.. @example.replace_emphasis('''
   assert(args[x] == 0);
   assert(args[y | 1] == 1);
   ''')

.. @example.replace_emphasis('my_module')

.. @jam_prefix.append('import python ;')
.. @jam_prefix.append('stage . : my_module /boost/python//boost_python ;')
.. @my_module = build(
        output = 'my_module'
      , target_rule = 'python-extension'
      , input = '/boost/python//boost_python'
    )

------------------------------------------------------------------------------

class template ``call``
-----------------------

Defines a ``__call__`` operator, mapped to ``operator()`` in C++.

.. parsed-literal::

    template <class ParameterSpecs>
    struct call : python::def_visitor<call<ParameterSpecs> >
    {
        template <class Class> 
        void def(Class& class\_);

        template <class CallPolicies>
        *def\_visitor* operator[](CallPolicies const& policies) const;
    };

.. @ignore()

``call`` requirements 
~~~~~~~~~~~~~~~~~~~~~

* ``ParameterSpecs`` is an `MPL sequence`_ where each element
  except the first models |ParameterSpec|. The first element
  is the result type of ``c(…)``.
* ``Class`` must support these expressions, where ``c`` is an 
  instance of ``Class``:

  =================== ==================== =======================================
  Expression          Return type          Requirements
  =================== ==================== =======================================
  ``c(a0, …, aN)``    Convertible to ``R`` ``a0``\ …\ ``aN`` are tagged arguments.
  =================== ==================== =======================================

  For every ``N`` in ``[U,V]``, where ``[U,V]`` is the **arity range** of ``ParameterSpecs``.


``template <class CallPolicies> operator[](CallPolicies const&)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Returns a ``def_visitor`` equivalent to ``*this``, except that it
uses CallPolicies when creating the binding.


Example
~~~~~~~

.. parsed-literal::

    #include <boost/parameter/keyword.hpp>
    #include <boost/parameter/preprocessor.hpp>
    #include <boost/parameter/python.hpp>
    #include <boost/python.hpp>
    #include <boost/mpl/vector.hpp>

    BOOST_PARAMETER_KEYWORD(tag, x)
    BOOST_PARAMETER_KEYWORD(tag, y)

    namespace parameter = boost::parameter;

    typedef parameter::parameters<
        parameter::required<tag::x>
      , parameter::optional<tag::y>
    > call_parameters;

    class X
    {
    public:
        template <class ArgumentPack>
        int call_impl(ArgumentPack const& args)
        {
            *… use args …*
        }

        template <class A0>
        int operator()(A0 const& a0)
        {
            return call_impl(call_parameters()(a0));
        }

        template <class A0, class A1>
        int operator()(A0 const& a0, A1 const& a1)
        {
            return call_impl(call_parameters()(a0,a1));
        }
    };

    BOOST_PYTHON_MODULE(*module name*)
    {
        using namespace boost::python;
        namespace py = parameter::python;
        namespace mpl = boost::mpl;

        class_<X>("X")
            .def(
                py::call<
                    mpl::vector<int, tag::x(int), tag::y\*(int)>
                >()
            );
    }    

.. @example.replace_emphasis('''
   assert(args[x] == 0);
   assert(args[y | 1] == 1);
   return 0;
   ''')

.. @example.replace_emphasis('my_module')

.. @my_module = build(
        output = 'my_module'
      , target_rule = 'python-extension'
      , input = '/boost/python//boost_python'
    )

------------------------------------------------------------------------------

class template ``function``
---------------------------

Defines a named parameter enabled member function.

.. parsed-literal::

    template <class Fwd, class ParameterSpecs>
    struct function : python::def_visitor<function<Fwd, ParameterSpecs> >
    {
        template <class Class, class Options> 
        void def(Class& class\_, char const* name, Options const& options);
    };

.. @ignore()

``function`` requirements 
~~~~~~~~~~~~~~~~~~~~~~~~~

* ``ParameterSpecs`` is an `MPL sequence`_ where each element
  except the first models |ParameterSpec|. The first element
  is the result type of ``c.f(…)``, where ``f`` is the member
  function.
* An instance of ``Fwd`` must support this expression:

  ============================================ ==================== =================================================
  Expression                                   Return type          Requirements
  ============================================ ==================== =================================================
  ``fwd(boost::type<R>(), self, a0, …, aN)``   Convertible to ``R`` ``self`` is a reference to the object on which
                                                                    the function should be invoked. ``a0``\ …\ ``aN``
                                                                    are tagged arguments.
  ============================================ ==================== =================================================

  For every ``N`` in ``[U,V]``, where ``[U,V]`` is the **arity range** of ``ParameterSpecs``.


Example
~~~~~~~

This example exports a member function ``f(int x, int y = …)`` to Python. The
sequence of |ParameterSpec|'s ``mpl::vector2<tag::x(int), tag::y*(int)>`` has
an **arity range** of [2,2], so we only need one forwarding overload.

.. parsed-literal::

    #include <boost/parameter/keyword.hpp>
    #include <boost/parameter/preprocessor.hpp>
    #include <boost/parameter/python.hpp>
    #include <boost/python.hpp>
    #include <boost/mpl/vector.hpp>

    BOOST_PARAMETER_KEYWORD(tag, x)
    BOOST_PARAMETER_KEYWORD(tag, y)

    class X
    {
    public:
        BOOST_PARAMETER_MEMBER_FUNCTION((void), f, tag,
            (required (x, \*))
            (optional (y, \*, 1))
        )
        {
            *…*
        }
    };

    struct f_fwd
    {
        template <class A0, class A1>
        void operator()(boost::type<void>, X& self, A0 const& a0, A1 const& a1)
        {
            self.f(a0, a1);
        }
    };

    BOOST_PYTHON_MODULE(*module name*)
    {
        using namespace boost::python;
        namespace py = boost::parameter::python;
        namespace mpl = boost::mpl;

        class_<X>("X")
            .def("f",
                py::function<
                    f_fwd
                  , mpl::vector<void, tag::x(int), tag::y\*(int)>
                >()
            );
    }

.. @example.replace_emphasis('''
   assert(x == 0);
   assert(y == 1);
   ''')

.. @example.replace_emphasis('my_module')

.. @my_module = build(
        output = 'my_module'
      , target_rule = 'python-extension'
      , input = '/boost/python//boost_python'
    )

------------------------------------------------------------------------------

function template ``def``
-------------------------

Defines a named parameter enabled free function in the current Python scope.

.. parsed-literal::

    template <class Fwd, class ParameterSpecs>
    void def(char const* name);

.. @ignore()

``def`` requirements 
~~~~~~~~~~~~~~~~~~~~

* ``ParameterSpecs`` is an `MPL sequence`_ where each element
  except the first models |ParameterSpec|. The first element
  is the result type of ``f(…)``, where ``f`` is the function.
* An instance of ``Fwd`` must support this expression:

  ====================================== ==================== =======================================
  Expression                             Return type          Requirements
  ====================================== ==================== =======================================
  ``fwd(boost::type<R>(), a0, …, aN)``   Convertible to ``R`` ``a0``\ …\ ``aN`` are tagged arguments.
  ====================================== ==================== =======================================

  For every ``N`` in ``[U,V]``, where ``[U,V]`` is the **arity range** of ``ParameterSpecs``.


Example
~~~~~~~

This example exports a function ``f(int x, int y = …)`` to Python. The
sequence of |ParameterSpec|'s ``mpl::vector2<tag::x(int), tag::y*(int)>`` has
an **arity range** of [2,2], so we only need one forwarding overload.

.. parsed-literal::

    BOOST_PARAMETER_FUNCTION((void), f, tag,
        (required (x, \*))
        (optional (y, \*, 1))
    )
    {
        *…*
    }

    struct f_fwd
    {
        template <class A0, class A1>
        void operator()(boost::type<void>, A0 const& a0, A1 const& a1)
        {
            f(a0, a1);
        }
    };

    BOOST_PYTHON_MODULE(…)
    {
        def<
            f_fwd
          , mpl::vector<
                void, tag::\ x(int), tag::\ y\*(int)
            >
        >("f");
    }

.. @ignore()

.. again, the undefined ``fwd`` identifier.

Portability
-----------

The Boost.Parameter Python binding library requires *partial template
specialization*.

+++++++++++++++++++++++++++++++++++++++++++++++++
 The Boost Parameter Library 
+++++++++++++++++++++++++++++++++++++++++++++++++

|(logo)|__

.. |(logo)| image:: ../../../../boost.png
   :alt: Boost

__ ../../../../index.htm

-------------------------------------

:Abstract: Use this library to write functions and class templates
  that can accept arguments by name:

  .. parsed-literal::

    new_window("alert", **_width=10**, **_titlebar=false**);

    smart_ptr<
       Foo 
     , **deleter<Deallocate<Foo> >**
     , **copy_policy<DeepCopy>** > p(new Foo);
    
  Since named arguments can be passed in any order, they are
  especially useful when a function or template has more than one
  parameter with a useful default value.  The library also supports
  *deduced* parameters; that is to say, parameters whose identity
  can be deduced from their types.

.. @jam_prefix.append('''
        project test : requirements <include>. <implicit-dependency>/boost//headers ;''')

.. @example.prepend('''
   #include <boost/parameter.hpp>
   
   namespace test
   {
     BOOST_PARAMETER_NAME(title)
     BOOST_PARAMETER_NAME(width)
     BOOST_PARAMETER_NAME(titlebar)
   
     BOOST_PARAMETER_FUNCTION(
        (int), new_window, tag, (required (title,*)(width,*)(titlebar,*)))
     {
        return 0;
     }
     
     BOOST_PARAMETER_TEMPLATE_KEYWORD(deleter)
     BOOST_PARAMETER_TEMPLATE_KEYWORD(copy_policy)

     template <class T> struct Deallocate {};
     struct DeepCopy {};

     namespace parameter = boost::parameter;
     
     struct Foo {};
     template <class T, class A0, class A1>
     struct smart_ptr
     {
         smart_ptr(Foo*);
     };
   }
   using namespace test;
   int x = ''');

.. @test('compile')


-------------------------------------

:Authors:       David Abrahams, Daniel Wallin
:Contact:       dave@boost-consulting.com, daniel@boostpro.com
:organization:  `BoostPro Computing`_
:date:          $Date: 2005/07/17 19:53:01 $

:copyright:     Copyright David Abrahams, Daniel Wallin
                2005-2009. Distributed under the Boost Software License,
                Version 1.0. (See accompanying file LICENSE_1_0.txt
                or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _`BoostPro Computing`: http://www.boostpro.com

.. _concepts: http://www.boost.org/more/generic_programming.html#concept

-------------------------------------

[Note: this tutorial does not cover all details of the library.  Please see also the `reference documentation`__\ ]

__ reference.html

.. contents:: **Table of Contents**
   :depth: 2

.. role:: concept
   :class: concept

.. role:: vellipsis
   :class: vellipsis

.. section-numbering::

-------------------------------------

============
 Motivation
============

In C++, arguments_ are normally given meaning by their positions
with respect to a parameter_ list: the first argument passed maps
onto the first parameter in a function's definition, and so on.
That protocol is fine when there is at most one parameter with a
default value, but when there are even a few useful defaults, the
positional interface becomes burdensome:

* .. compound::

    Since an argument's meaning is given by its position, we have to
    choose an (often arbitrary) order for parameters with default
    values, making some combinations of defaults unusable:

    .. parsed-literal::

      window* new_window(
         char const* name, 
         **int border_width = default_border_width,**
         bool movable = true,
         bool initially_visible = true
         );

      const bool movability = false;
      window* w = new_window("alert box", movability);

    In the example above we wanted to make an unmoveable window
    with a default ``border_width``, but instead we got a moveable
    window with a ``border_width`` of zero.  To get the desired
    effect, we'd need to write:

    .. parsed-literal::

       window* w = new_window(
          "alert box", **default_border_width**, movability);

* .. compound::

    It can become difficult for readers to understand the meaning of
    arguments at the call site::

      window* w = new_window("alert", 1, true, false);

    Is this window moveable and initially invisible, or unmoveable
    and initially visible?  The reader needs to remember the order
    of arguments to be sure.  

* The author of the call may not remember the order of the
  arguments either, leading to hard-to-find bugs.

.. @ignore(3)

-------------------------
Named Function Parameters
-------------------------

.. compound::

  This library addresses the problems outlined above by associating
  each parameter name with a keyword object.  Now users can identify
  arguments by name, rather than by position:

  .. parsed-literal::

    window* w = new_window("alert box", **movable_=**\ false); // OK!

.. @ignore()

---------------------------
Deduced Function Parameters
---------------------------

.. compound::

  A **deduced parameter** can be passed in any position *without*
  supplying an explicit parameter name.  It's not uncommon for a
  function to have parameters that can be uniquely identified based
  on the types of arguments passed.  The ``name`` parameter to
  ``new_window`` is one such example.  None of the other arguments,
  if valid, can reasonably be converted to a ``char const*``.  With
  a deduced parameter interface, we could pass the window name in
  *any* argument position without causing ambiguity:

  .. parsed-literal::

    window* w = new_window(movable_=false, **"alert box"**); // OK!
    window* w = new_window(**"alert box"**, movable_=false); // OK!

  Appropriately used, a deduced parameter interface can free the
  user of the burden of even remembering the formal parameter
  names.

.. @ignore()

--------------------------------
Class Template Parameter Support
--------------------------------

.. compound::

  The reasoning we've given for named and deduced parameter
  interfaces applies equally well to class templates as it does to
  functions.  Using the Parameter library, we can create interfaces
  that allow template arguments (in this case ``shared`` and
  ``Client``) to be explicitly named, like this:

  .. parsed-literal::

    smart_ptr<**ownership<shared>**, **value_type<Client>** > p;

  The syntax for passing named template arguments is not quite as
  natural as it is for function arguments (ideally, we'd be able to
  write ``smart_ptr<ownership=shared,…>``).  This small syntactic
  deficiency makes deduced parameters an especially big win when
  used with class templates:

  .. parsed-literal::

    // *p and q could be equivalent, given a deduced*
    // *parameter interface.*
    smart_ptr<**shared**, **Client**> p;
    smart_ptr<**Client**, **shared**> q;

.. @ignore(2)

==========
 Tutorial
==========

This tutorial shows all the basics—how to build both named- and deduced-parameter
interfaces to function templates and class templates—and several
more advanced idioms as well.

---------------------------
Parameter-Enabled Functions
---------------------------

In this section we'll show how the Parameter library can be used to
build an expressive interface to the `Boost Graph library`__\ 's
|dfs|_ algorithm. [#old_interface]_ 

.. Revisit this

  After laying some groundwork
  and describing the algorithm's abstract interface, we'll show you
  how to build a basic implementation with keyword support.  Then
  we'll add support for default arguments and we'll gradually refine the
  implementation with syntax improvements.  Finally we'll show how to
  streamline the implementation of named parameter interfaces,
  improve their participation in overload resolution, and optimize
  their runtime efficiency.

__ ../../../graph/index.html

.. _dfs: ../../../graph/doc/depth_first_search.html

.. |dfs| replace:: ``depth_first_search``


Headers And Namespaces
======================

Most components of the Parameter library are declared in a
header named for the component.  For example, ::

  #include <boost/parameter/keyword.hpp>

will ensure ``boost::parameter::keyword`` is known to the
compiler.  There is also a combined header,
``boost/parameter.hpp``, that includes most of the library's
components.  For the the rest of this tutorial, unless we say
otherwise, you can use the rule above to figure out which header
to ``#include`` to access any given component of the library.

.. @example.append('''
   using boost::parameter::keyword;
   ''')

.. @test('compile')

Also, the examples below will also be written as if the
namespace alias ::

  namespace parameter = boost::parameter;

.. @ignore()

has been declared: we'll write ``parameter::xxx`` instead of
``boost::parameter::xxx``.

The Abstract Interface to |dfs|
===============================

The Graph library's |dfs| algorithm is a generic function accepting
from one to four arguments by reference.  If all arguments were
required, its signature might be as follows::

   template <
       class Graph, class DFSVisitor, class Index, class ColorMap
   >
   void depth_first_search(
     , Graph const& graph 
     , DFSVisitor visitor
     , typename graph_traits<g>::vertex_descriptor root_vertex
     , IndexMap index_map
     , ColorMap& color);

.. @ignore()

However, most of the parameters have a useful default value, as
shown in the table below.

.. _`parameter table`: 
.. _`default expressions`: 

.. table:: ``depth_first_search`` Parameters

  +----------------+----------+---------------------------------+----------------------------------+
  | Parameter Name | Dataflow | Type                            | Default Value (if any)           |
  +================+==========+=================================+==================================+
  |``graph``       | in       |Model of |IncidenceGraph|_ and   |none - this argument is required. |
  |                |          ||VertexListGraph|_               |                                  |
  |                |          |                                 |                                  |
  +----------------+----------+---------------------------------+----------------------------------+
  |``visitor``     | in       |Model of |DFSVisitor|_           |``boost::dfs_visitor<>()``        |
  +----------------+----------+---------------------------------+----------------------------------+
  |``root_vertex`` | in       |``graph``'s vertex descriptor    |``*vertices(graph).first``        |
  |                |          |type.                            |                                  |
  +----------------+----------+---------------------------------+----------------------------------+
  |``index_map``   | in       |Model of |ReadablePropertyMap|_  |``get(boost::vertex_index,graph)``|
  |                |          |with key type := ``graph``'s     |                                  |
  |                |          |vertex descriptor and value type |                                  |
  |                |          |an integer type.                 |                                  |
  +----------------+----------+---------------------------------+----------------------------------+
  |``color_map``   | in/out   |Model of |ReadWritePropertyMap|_ |an ``iterator_property_map``      |
  |                |          |with key type := ``graph``'s     |created from a ``std::vector`` of |
  |                |          |vertex descriptor type.          |``default_color_type`` of size    |
  |                |          |                                 |``num_vertices(graph)`` and using |
  |                |          |                                 |``index_map`` for the index map.  |
  +----------------+----------+---------------------------------+----------------------------------+

.. |IncidenceGraph| replace:: :concept:`Incidence Graph`
.. |VertexListGraph| replace:: :concept:`Vertex List Graph`
.. |DFSVisitor| replace:: :concept:`DFS Visitor`
.. |ReadablePropertyMap| replace:: :concept:`Readable Property Map`
.. |ReadWritePropertyMap| replace:: :concept:`Read/Write Property Map`

.. _`IncidenceGraph`: ../../../graph/doc/IncidenceGraph.html
.. _`VertexListGraph`: ../../../graph/doc/VertexListGraph.html
.. _`DFSVisitor`: ../../../graph/doc/DFSVisitor.html
.. _`ReadWritePropertyMap`: ../../../property_map/doc/ReadWritePropertyMap.html
.. _`ReadablePropertyMap`: ../../../property_map/doc/ReadablePropertyMap.html

Don't be intimidated by the information in the second and third
columns above.  For the purposes of this exercise, you don't need
to understand them in detail.

Defining the Keywords
=====================

The point of this exercise is to make it possible to call
``depth_first_search`` with named arguments, leaving out any
arguments for which the default is appropriate:

.. parsed-literal::

  graphs::depth_first_search(g, **color_map_=my_color_map**);

.. @ignore()

To make that syntax legal, there needs to be an object called
“\ ``color_map_``\ ” whose assignment operator can accept a
``my_color_map`` argument.  In this step we'll create one such
**keyword object** for each parameter.  Each keyword object will be
identified by a unique **keyword tag type**.  

.. Revisit this

  We're going to define our interface in namespace ``graphs``.  Since
  users need access to the keyword objects, but not the tag types,
  we'll define the keyword objects so they're accessible through
  ``graphs``, and we'll hide the tag types away in a nested
  namespace, ``graphs::tag``.  The library provides a convenient
  macro for that purpose.

We're going to define our interface in namespace ``graphs``.  The
library provides a convenient macro for defining keyword objects::

  #include <boost/parameter/name.hpp>

  namespace graphs
  {
    BOOST_PARAMETER_NAME(graph)    // Note: no semicolon
    BOOST_PARAMETER_NAME(visitor)
    BOOST_PARAMETER_NAME(root_vertex)
    BOOST_PARAMETER_NAME(index_map)
    BOOST_PARAMETER_NAME(color_map)
  }

.. @test('compile')

The declaration of the ``graph`` keyword you see here is
equivalent to::

  namespace graphs 
  {
    namespace tag { struct graph; } // keyword tag type

    namespace // unnamed
    {
      // A reference to the keyword object
      boost::parameter::keyword<tag::graph>& _graph
      = boost::parameter::keyword<tag::graph>::get();
    }
  }

.. @example.prepend('#include <boost/parameter/keyword.hpp>')
.. @test('compile')

It defines a *keyword tag type* named ``tag::graph`` and a *keyword
object* reference named ``_graph``.

This “fancy dance” involving an unnamed namespace and references
is all done to avoid violating the One Definition Rule (ODR)
[#odr]_ when the named parameter interface is used by function
templates that are instantiated in multiple translation
units (MSVC6.x users see `this note`__).

__ `Compiler Can't See References In Unnamed Namespace`_

Writing the Function
====================

Now that we have our keywords defined, the function template
definition follows a simple pattern using the
``BOOST_PARAMETER_FUNCTION`` macro::

  #include <boost/parameter/preprocessor.hpp>

  namespace graphs
  {
    BOOST_PARAMETER_FUNCTION(
        (void),                // 1. parenthesized return type
        depth_first_search,    // 2. name of the function template

        tag,                   // 3. namespace of tag types

        (required (graph, *) ) // 4. one required parameter, and

        (optional              //    four optional parameters, with defaults
          (visitor,           *, boost::dfs_visitor<>()) 
          (root_vertex,       *, *vertices(graph).first) 
          (index_map,         *, get(boost::vertex_index,graph)) 
          (in_out(color_map), *, 
            default_color_map(num_vertices(graph), index_map) ) 
        )
    )
    {
        // ... body of function goes here...
        // use graph, visitor, index_map, and color_map
    }
  }

.. @example.prepend('''
   #include <boost/parameter/name.hpp>

   BOOST_PARAMETER_NAME(graph)
   BOOST_PARAMETER_NAME(visitor)
   BOOST_PARAMETER_NAME(root_vertex)
   BOOST_PARAMETER_NAME(index_map)
   BOOST_PARAMETER_NAME(color_map)

   namespace boost {

   template <class T = int>
   struct dfs_visitor
   {};

   int vertex_index = 0;

   }''')

.. @test('compile')

The arguments to ``BOOST_PARAMETER_FUNCTION`` are:

1. The return type of the resulting function template.  Parentheses
   around the return type prevent any commas it might contain from
   confusing the preprocessor, and are always required.

2. The name of the resulting function template.

3. The name of a namespace where we can find tag types whose names
   match the function's parameter names.

4. The function signature.  

Function Signatures
===================

Function signatures are described as one or two adjacent
parenthesized terms (a Boost.Preprocessor_ sequence_) describing
the function's parameters in the order in which they'd be expected
if passed positionally.  Any required parameters must come first,
but the ``(required … )`` clause can be omitted when all the
parameters are optional.

.. _Boost.Preprocessor: ../../../preprocessor/index.html

Required Parameters
-------------------

.. compound::

  Required parameters are given first—nested in a ``(required … )``
  clause—as a series of two-element tuples describing each parameter
  name and any requirements on the argument type.  In this case there
  is only a single required parameter, so there's just a single
  tuple:

  .. parsed-literal::

     (required **(graph, \*)** )

  Since ``depth_first_search`` doesn't require any particular type
  for its ``graph`` parameter, we use an asterix to indicate that
  any type is allowed.  Required parameters must always precede any
  optional parameters in a signature, but if there are *no*
  required parameters, the ``(required … )`` clause can be omitted
  entirely.

.. @example.prepend('''
   #include <boost/parameter.hpp>

   BOOST_PARAMETER_NAME(graph)

   BOOST_PARAMETER_FUNCTION((void), f, tag,
   ''')

.. @example.append(') {}')
.. @test('compile')

Optional Parameters
-------------------

.. compound::

  Optional parameters—nested in an ``(optional … )`` clause—are given
  as a series of adjacent *three*\ -element tuples describing the
  parameter name, any requirements on the argument type, *and* and an
  expression representing the parameter's default value:

  .. parsed-literal::

    (optional **\
        (visitor,           \*, boost::dfs_visitor<>()) 
        (root_vertex,       \*, \*vertices(graph).first) 
        (index_map,         \*, get(boost::vertex_index,graph)) 
        (in_out(color_map), \*, 
          default_color_map(num_vertices(graph), index_map) )**
    )

.. @example.prepend('''
   #include <boost/parameter.hpp>

   namespace boost
   {
     int vertex_index = 0;

     template <class T = int>
     struct dfs_visitor
     {};
   }

   BOOST_PARAMETER_NAME(graph)
   BOOST_PARAMETER_NAME(visitor)
   BOOST_PARAMETER_NAME(root_vertex)
   BOOST_PARAMETER_NAME(index_map)
   BOOST_PARAMETER_NAME(color_map)

   BOOST_PARAMETER_FUNCTION((void), f, tag,
     (required (graph, *))
   ''')

.. @example.append(') {}')
.. @test('compile')

Handling “Out” Parameters
-------------------------

.. compound::

  Within the function body, a parameter name such as ``visitor`` is
  a *C++ reference*, bound either to an actual argument passed by
  the caller or to the result of evaluating a default expression.
  In most cases, parameter types are of the form ``T const&`` for
  some ``T``.  Parameters whose values are expected to be modified,
  however, must be passed by reference to *non*\ -``const``.  To
  indicate that ``color_map`` is both read and written, we wrap
  its name in ``in_out(…)``:

  .. parsed-literal::

    (optional
        (visitor,            \*, boost::dfs_visitor<>()) 
        (root_vertex,        \*, \*vertices(graph).first) 
        (index_map,          \*, get(boost::vertex_index,graph)) 
        (**in_out(color_map)**, \*, 
          default_color_map(num_vertices(graph), index_map) )
    )

.. @example.prepend('''
   #include <boost/parameter.hpp>

   namespace boost
   {
     int vertex_index = 0;

     template <class T = int>
     struct dfs_visitor
     {};
   }

   BOOST_PARAMETER_NAME(graph)

   BOOST_PARAMETER_NAME(visitor)
   BOOST_PARAMETER_NAME(root_vertex)
   BOOST_PARAMETER_NAME(index_map)
   BOOST_PARAMETER_NAME(color_map)

   BOOST_PARAMETER_FUNCTION((void), f, tag,
     (required (graph, *))
   ''')

.. @example.append(') {}')
.. @test('compile')

If ``color_map`` were strictly going to be modified but not examined,
we could have written ``out(color_map)``.  There is no functional
difference between ``out`` and ``in_out``; the library provides
both so you can make your interfaces more self-documenting.

Positional Arguments
--------------------

When arguments are passed positionally (without the use of
keywords), they will be mapped onto parameters in the order the
parameters are given in the signature, so for example in this
call ::

  graphs::depth_first_search(x, y);

.. @ignore()

``x`` will always be interpreted as a graph and ``y`` will always
be interpreted as a visitor.

.. _sequence: http://boost-consulting.com/mplbook/preprocessor.html#sequences

Default Expression Evaluation
-----------------------------

.. compound::

  Note that in our example, the value of the graph parameter is
  used in the default expressions for ``root_vertex``,
  ``index_map`` and ``color_map``.  

  .. parsed-literal::

        (required (**graph**, \*) )
        (optional
          (visitor,           \*, boost::dfs_visitor<>()) 
          (root_vertex,       \*, \*vertices(**graph**).first) 
          (index_map,         \*, get(boost::vertex_index,\ **graph**)) 
          (in_out(color_map), \*, 
            default_color_map(num_vertices(**graph**), index_map) ) 
        )

  .. @ignore()

  A default expression is evaluated in the context of all preceding
  parameters, so you can use any of their values by name.

.. compound::

  A default expression is never evaluated—or even instantiated—if
  an actual argument is passed for that parameter.  We can actually
  demonstrate that with our code so far by replacing the body of
  ``depth_first_search`` with something that prints the arguments:

  .. parsed-literal::

    #include <boost/graph/depth_first_search.hpp> // for dfs_visitor

    BOOST_PARAMETER_FUNCTION(
        (void), depth_first_search, tag
        *…signature goes here…*
    )
    {
       std::cout << "graph=" << graph << std::endl;
       std::cout << "visitor=" << visitor << std::endl;
       std::cout << "root_vertex=" << root_vertex << std::endl;
       std::cout << "index_map=" << index_map << std::endl;
       std::cout << "color_map=" << color_map << std::endl;
    }

    int main()
    {
        depth_first_search(1, 2, 3, 4, 5);

        depth_first_search(
            "1", '2', _color_map = '5',
            _index_map = "4", _root_vertex = "3");
    }

  Despite the fact that default expressions such as
  ``vertices(graph).first`` are ill-formed for the given ``graph``
  arguments, both calls will compile, and each one will print
  exactly the same thing.

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>

   BOOST_PARAMETER_NAME(graph)
   BOOST_PARAMETER_NAME(visitor)
   BOOST_PARAMETER_NAME(root_vertex)
   BOOST_PARAMETER_NAME(index_map)
   BOOST_PARAMETER_NAME(color_map)''')

.. @example.replace_emphasis('''
   , (required 
       (graph, *)
       (visitor, *)
       (root_vertex, *)
       (index_map, *)
       (color_map, *)
     )
   ''')
.. @test('compile')

Signature Matching and Overloading
----------------------------------

In fact, the function signature is so general that any call to
``depth_first_search`` with fewer than five arguments will match
our function, provided we pass *something* for the required
``graph`` parameter.  That might not seem to be a problem at first;
after all, if the arguments don't match the requirements imposed by
the implementation of ``depth_first_search``, a compilation error
will occur later, when its body is instantiated.

There are at least three problems with very general function
signatures.  

1. By the time our ``depth_first_search`` is instantiated, it has
   been selected as the best matching overload.  Some other
   ``depth_first_search`` overload might've worked had it been
   chosen instead.  By the time we see a compilation error, there's
   no chance to change that decision.

2. Even if there are no overloads, error messages generated at
   instantiation time usually expose users to confusing
   implementation details.  For example, users might see references
   to names generated by ``BOOST_PARAMETER_FUNCTION`` such as
   ``graphs::detail::depth_first_search_with_named_params`` (or
   worse—think of the kinds of errors you get from your STL
   implementation when you make a mistake). [#ConceptCpp]_

3. The problems with exposing such permissive function template
   signatures have been the subject of much discussion, especially
   in the presence of `unqualified calls`__.  If all we want is to
   avoid unintentional argument-dependent lookup (ADL), we can
   isolate ``depth_first_search`` in a namespace containing no
   types [#using]_, but suppose we *want* it to found via ADL?

__ http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#225

It's usually a good idea to prevent functions from being considered
for overload resolution when the passed argument types aren't
appropriate.  The library already does this when the required
``graph`` parameter is not supplied, but we're not likely to see a
depth first search that doesn't take a graph to operate on.
Suppose, instead, that we found a different depth first search
algorithm that could work on graphs that don't model
|IncidenceGraph|_?  If we just added a simple overload,
it would be ambiguous::

  // new overload
  BOOST_PARAMETER_FUNCTION(
      (void), depth_first_search, (tag), (required (graph,*))( … ))
  {
      // new algorithm implementation
  }

  …

  // ambiguous!
  depth_first_search(boost::adjacency_list<>(), 2, "hello");

.. @ignore()

Adding Type Requirements
........................

We really don't want the compiler to consider the original version
of ``depth_first_search`` because the ``root_vertex`` argument,
``"hello"``, doesn't meet the requirement__ that it match the
``graph`` parameter's vertex descriptor type.  Instead, this call
should just invoke our new overload.  To take the original
``depth_first_search`` overload out of contention, we need to tell
the library about this requirement by replacing the ``*`` element
of the signature with the required type, in parentheses:

__ `parameter table`_

.. parsed-literal::

  (root_vertex,       
       **(typename boost::graph_traits<graph_type>::vertex_descriptor)**,
       \*vertices(graph).first) 

.. @ignore()

Now the original ``depth_first_search`` will only be called when
the ``root_vertex`` argument can be converted to the graph's vertex
descriptor type, and our example that *was* ambiguous will smoothly
call the new overload.

.. Note:: The *type* of the ``graph`` argument is available in the
   signature—and in the function body—as ``graph_type``.  In
   general, to access the type of any parameter *foo*, write *foo*\
   ``_type``.


Predicate Requirements
......................

The requirements on other arguments are a bit more interesting than
those on ``root_vertex``; they can't be described in terms of simple
type matching.  Instead, they must be described in terms of `MPL
Metafunctions`__.  There's no space to give a complete description
of metafunctions or of graph library details here, but we'll show
you the complete signature with maximal checking, just to give you
a feel for how it's done.  Each predicate metafunction is enclosed
in parentheses *and preceded by an asterix*, as follows:

.. parsed-literal::

    BOOST_PARAMETER_FUNCTION(
        (void), depth_first_search, graphs

      , (required 
          (graph 
           , **\ \*(boost::mpl::and_<
                   boost::is_convertible<
                       boost::graph_traits<_>::traversal_category
                     , boost::incidence_graph_tag
                   >
                 , boost::is_convertible<
                       boost::graph_traits<_>::traversal_category
                     , boost::vertex_list_graph_tag
                   >
               >)** ))

        (optional
          (visitor, \*, boost::dfs_visitor<>()) // not checkable

          (root_vertex
            , (typename boost::graph_traits<graphs::graph::_>::vertex_descriptor)
            , \*vertices(graph).first)
 
          (index_map
            , **\ \*(boost::mpl::and_<
                  boost::is_integral<
                      boost::property_traits<_>::value_type
                  >
                , boost::is_same<
                      typename boost::graph_traits<graphs::graph::_>::vertex_descriptor
                    , boost::property_traits<_>::key_type
                  >
              >)**
            , get(boost::vertex_index,graph))
 
          (in_out(color_map)
            , **\ \*(boost::is_same<
                  typename boost::graph_traits<graphs::graph::_>::vertex_descriptor
                , boost::property_traits<_>::key_type
              >)**
           , default_color_map(num_vertices(graph), index_map) ) 
        )
    )

.. @example.prepend('''
   #include <boost/parameter.hpp>

   BOOST_PARAMETER_NAME((_graph, graphs) graph) 
   BOOST_PARAMETER_NAME((_visitor, graphs) visitor) 
   BOOST_PARAMETER_NAME((_root_vertex, graphs) root_vertex) 
   BOOST_PARAMETER_NAME((_index_map, graphs) index_map) 
   BOOST_PARAMETER_NAME((_color_map, graphs) color_map)

   using boost::mpl::_;

   namespace boost
   {
     struct incidence_graph_tag {};
     struct vertex_list_graph_tag {};

     int vertex_index = 0;

     template <class T>
     struct graph_traits
     {
         typedef int traversal_category;
         typedef int vertex_descriptor;
     };

     template <class T>
     struct property_traits
     {
         typedef int value_type;
         typedef int key_type;
     };

     template <class T = int>
     struct dfs_visitor 
     {};
   }''')

.. @example.append('''
   {}''')

.. @test('compile')

__ ../../../mpl/doc/refmanual/metafunction.html

We acknowledge that this signature is pretty hairy looking.
Fortunately, it usually isn't necessary to so completely encode the
type requirements on arguments to generic functions.  However, it
is usally worth the effort to do so: your code will be more
self-documenting and will often provide a better user experience.
You'll also have an easier transition to an upcoming C++ standard
with `language support for concepts`__.

__ `ConceptC++`_

Deduced Parameters
------------------

To illustrate deduced parameter support we'll have to leave behind
our example from the Graph library.  Instead, consider the example
of the |def|_ function from Boost.Python_.  Its signature is
roughly as follows::

  template <
    class Function, Class KeywordExpression, class CallPolicies
  >
  void def(
      // Required parameters
      char const* name, Function func

      // Optional, deduced parameters
    , char const* docstring = ""
    , KeywordExpression keywords = no_keywords()
    , CallPolicies policies = default_call_policies()
  );

.. @ignore()

Try not to be too distracted by the use of the term “keywords” in
this example: although it means something analogous in Boost.Python
to what it means in the Parameter library, for the purposes of this
exercise you can think of it as being completely different.

When calling ``def``, only two arguments are required.  The
association between any additional arguments and their parameters
can be determined by the types of the arguments actually passed, so
the caller is neither required to remember argument positions or
explicitly specify parameter names for those arguments.  To
generate this interface using ``BOOST_PARAMETER_FUNCTION``, we need
only enclose the deduced parameters in a ``(deduced …)`` clause, as
follows: 

.. parsed-literal::

  namespace mpl = boost::mpl;

  BOOST_PARAMETER_FUNCTION(
      (void), def, tag,

      (required (name,(char const\*)) (func,\*) )   // nondeduced

      **(deduced** 
        (optional 
          (docstring, (char const\*), "")

          (keywords
             , \*(is_keyword_expression<mpl::_>) // see [#is_keyword_expression]_
             , no_keywords())

          (policies
             , \*(mpl::not_<
                   mpl::or_<
                       boost::is_convertible<mpl::_, char const\*>
                     , is_keyword_expression<mpl::_> // see [#is_keyword_expression]_
                   >
               >)
             , default_call_policies()
           )
         )
       **)**
   )
   {
      *…*
   }

.. @example.replace_emphasis('')

.. @example.prepend('''
   #include <boost/parameter.hpp>

   BOOST_PARAMETER_NAME(name)
   BOOST_PARAMETER_NAME(func)
   BOOST_PARAMETER_NAME(docstring)
   BOOST_PARAMETER_NAME(keywords)
   BOOST_PARAMETER_NAME(policies)

   struct default_call_policies
   {};

   struct no_keywords
   {};

   struct keywords
   {};

   template <class T>
   struct is_keyword_expression
     : boost::mpl::false_
   {};

   template <>
   struct is_keyword_expression<keywords>
     : boost::mpl::true_
   {};

   default_call_policies some_policies;

   void f()
   {}

   ''')

.. Admonition:: Syntax Note

  A ``(deduced …)`` clause always contains a ``(required …)``
  and/or an ``(optional …)`` subclause, and must follow any
  ``(required …)`` or ``(optional …)`` clauses indicating
  nondeduced parameters at the outer level.

With the declaration above, the following two calls are equivalent:

.. parsed-literal::

  def("f", &f, **some_policies**, **"Documentation for f"**);
  def("f", &f, **"Documentation for f"**, **some_policies**);

.. @example.prepend('''
   int main()
   {''')

If the user wants to pass a ``policies`` argument that was also,
for some reason, convertible to ``char const*``, she can always
specify the parameter name explicitly, as follows:

.. parsed-literal::

  def(
      "f", &f
     , **_policies = some_policies**, "Documentation for f");

.. @example.append('}')
.. @test('compile', howmany='all')

.. _Boost.Python: ../../../python/doc/index.html
.. |def| replace:: ``def``
.. _def: ../../../python/doc/v2/def.html

----------------------------------
Parameter-Enabled Member Functions
----------------------------------


The ``BOOST_PARAMETER_MEMBER_FUNCTION`` and
``BOOST_PARAMETER_CONST_MEMBER_FUNCTION`` macros accept exactly the
same arguments as ``BOOST_PARAMETER_FUNCTION``, but are designed to
be used within the body of a class::

  BOOST_PARAMETER_NAME(arg1)
  BOOST_PARAMETER_NAME(arg2)

  struct callable2
  {
      BOOST_PARAMETER_CONST_MEMBER_FUNCTION(
          (void), call, tag, (required (arg1,(int))(arg2,(int))))
      {
          std::cout << arg1 << ", " << arg2 << std::endl;
      }
  };

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>
   using namespace boost::parameter;
   ''')

.. @test('compile')

These macros don't directly allow a function's interface to be
separated from its implementation, but you can always forward
arguments on to a separate implementation function::

  struct callable2
  {
      BOOST_PARAMETER_CONST_MEMBER_FUNCTION(
          (void), call, tag, (required (arg1,(int))(arg2,(int))))
      {
          call_impl(arg1,arg2);
      }
   private:
      void call_impl(int, int); // implemented elsewhere.
  };

.. @example.prepend('''
   #include <boost/parameter.hpp>

   BOOST_PARAMETER_NAME(arg1)
   BOOST_PARAMETER_NAME(arg2)
   using namespace boost::parameter;
   ''')

.. @test('compile')

Static Member Functions
=======================

To expose a static member function, simply insert the keyword
“``static``” before the function name:

.. parsed-literal::

  BOOST_PARAMETER_NAME(arg1)

  struct somebody
  {
      BOOST_PARAMETER_MEMBER_FUNCTION(
          (void), **static** f, tag, (optional (arg1,(int),0)))
      {
          std::cout << arg1 << std::endl;
      }
  };

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>
   using namespace boost::parameter;
   ''')

.. @test('compile')


------------------------------
Parameter-Enabled Constructors
------------------------------

The lack of a “delegating constructor”
feature in C++
(http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf)
limits somewhat the quality of interface this library can provide
for defining parameter-enabled constructors.  The usual workaround
for a lack of constructor delegation applies: one must factor the
common logic into a base class.  

Let's build a parameter-enabled constructor that simply prints its
arguments.  The first step is to write a base class whose
constructor accepts a single argument known as an |ArgumentPack|_:
a bundle of references to the actual arguments, tagged with their
keywords.  The values of the actual arguments are extracted from
the |ArgumentPack| by *indexing* it with keyword objects::

  BOOST_PARAMETER_NAME(name)
  BOOST_PARAMETER_NAME(index)

  struct myclass_impl
  {
      template <class ArgumentPack>
      myclass_impl(ArgumentPack const& args)
      {
          std::cout << "name = " << args[_name] 
                    << "; index = " << args[_index | 42] 
                    << std::endl;
      }
  };

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>''')

Note that the bitwise or (“\ ``|``\ ”) operator has a special
meaning when applied to keyword objects that are passed to an
|ArgumentPack|\ 's indexing operator: it is used to indicate a
default value.  In this case if there is no ``index`` parameter in
the |ArgumentPack|, ``42`` will be used instead.

Now we are ready to write the parameter-enabled constructor
interface::

  struct myclass : myclass_impl
  {
      BOOST_PARAMETER_CONSTRUCTOR(
          myclass, (myclass_impl), tag
        , (required (name,*)) (optional (index,*))) // no semicolon
  };

Since we have supplied a default value for ``index`` but not for
``name``, only ``name`` is required.  We can exercise our new
interface as follows::

  myclass x("bob", 3);                     // positional
  myclass y(_index = 12, _name = "sally"); // named
  myclass z("june");                       // positional/defaulted

.. @example.wrap('int main() {', '}')
.. @test('run', howmany='all')

For more on |ArgumentPack| manipulation, see the `Advanced Topics`_
section.

---------------------------------
Parameter-Enabled Class Templates
---------------------------------

In this section we'll use Boost.Parameter to build Boost.Python_\
's `class_`_ template, whose “signature” is:

.. parsed-literal::

  template class<
      ValueType, BaseList = bases<>
    , HeldType = ValueType, Copyable = void
  >
  class class\_;

.. @ignore()

Only the first argument, ``ValueType``, is required.

.. _class_: http://www.boost.org/libs/python/doc/v2/class.html#class_-spec

Named Template Parameters
=========================

First, we'll build an interface that allows users to pass arguments
positionally or by name:

.. parsed-literal::

  struct B { virtual ~B() = 0; };
  struct D : B { ~D(); };

  class_<
       **class_type<B>**, **copyable<boost::noncopyable>** 
  > …;

  class_<
      **D**, **held_type<std::auto_ptr<D> >**, **base_list<bases<B> >**
  > …;

.. @ignore()

Template Keywords
-----------------

The first step is to define keywords for each template parameter::

  namespace boost { namespace python {

  BOOST_PARAMETER_TEMPLATE_KEYWORD(class_type)
  BOOST_PARAMETER_TEMPLATE_KEYWORD(base_list)
  BOOST_PARAMETER_TEMPLATE_KEYWORD(held_type)
  BOOST_PARAMETER_TEMPLATE_KEYWORD(copyable)

  }}

.. @example.prepend('#include <boost/parameter.hpp>')
.. @test('compile')

The declaration of the ``class_type`` keyword you see here is
equivalent to::

  namespace boost { namespace python {

  namespace tag { struct class_type; } // keyword tag type
  template <class T>
  struct class_type
    : parameter::template_keyword<tag::class_type,T>
  {};

  }}

.. @example.prepend('#include <boost/parameter.hpp>')
.. @test('compile')

It defines a keyword tag type named ``tag::class_type`` and a
*parameter passing template* named ``class_type``.

Class Template Skeleton
-----------------------

The next step is to define the skeleton of our class template,
which has three optional parameters.  Because the user may pass
arguments in any order, we don't know the actual identities of
these parameters, so it would be premature to use descriptive names
or write out the actual default values for any of them.  Instead,
we'll give them generic names and use the special type
``boost::parameter::void_`` as a default:

.. parsed-literal::

  namespace boost { namespace python {

  template <
      class A0
    , class A1 = parameter::void\_
    , class A2 = parameter::void\_
    , class A3 = parameter::void\_
  >
  struct class\_
  {
      *…*
  };

  }}

.. @example.prepend('#include <boost/parameter.hpp>')
.. @example.replace_emphasis('')
.. @test('compile')

Class Template Signatures
-------------------------

Next, we need to build a type, known as a |ParameterSpec|_,
describing the “signature” of ``boost::python::class_``.  A
|ParameterSpec|_ enumerates the required and optional parameters in
their positional order, along with any type requirements (note that
it does *not* specify defaults -- those will be dealt with
separately)::

  namespace boost { namespace python {

  using boost::mpl::_;

  typedef parameter::parameters<
      required<tag::class_type, boost::is_class<_> >
    , parameter::optional<tag::base_list, mpl::is_sequence<_> >
    , parameter::optional<tag::held_type>
    , parameter::optional<tag::copyable>
  > class_signature;

  }}

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <boost/mpl/is_sequence.hpp>
   #include <boost/noncopyable.hpp>
   #include <boost/type_traits/is_class.hpp>
   #include <memory>

   using namespace boost::parameter;

   namespace boost { namespace python {

   BOOST_PARAMETER_TEMPLATE_KEYWORD(class_type)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(base_list)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(held_type)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(copyable)

   template <class B = int>
   struct bases
   {};

   }}''')

.. |ParameterSpec| replace:: :concept:`ParameterSpec`

.. _ParameterSpec: reference.html#parameterspec

.. _binding_intro:

Argument Packs and Parameter Extraction
---------------------------------------

Next, within the body of ``class_`` , we use the |ParameterSpec|\ 's
nested ``::bind< … >`` template to bundle the actual arguments into an
|ArgumentPack|_ type, and then use the library's ``value_type< … >``
metafunction to extract “logical parameters”.  ``value_type< … >`` is
a lot like ``binding< … >``, but no reference is added to the actual
argument type.  Note that defaults are specified by passing it an
optional third argument::

  namespace boost { namespace python {

  template <
      class A0
    , class A1 = parameter::void_
    , class A2 = parameter::void_
    , class A3 = parameter::void_
  >
  struct class_
  {
      // Create ArgumentPack
      typedef typename 
        class_signature::bind<A0,A1,A2,A3>::type 
      args;

      // Extract first logical parameter.
      typedef typename parameter::value_type<
        args, tag::class_type>::type class_type;
      
      typedef typename parameter::value_type<
        args, tag::base_list, bases<> >::type base_list;
      
      typedef typename parameter::value_type<
        args, tag::held_type, class_type>::type held_type;
      
      typedef typename parameter::value_type<
        args, tag::copyable, void>::type copyable;
  };

  }}

.. |ArgumentPack| replace:: :concept:`ArgumentPack`
.. _ArgumentPack: reference.html#argumentpack

Exercising the Code So Far
==========================

.. compound::

  Revisiting our original examples, ::

    typedef boost::python::class_<
        class_type<B>, copyable<boost::noncopyable> 
    > c1;

    typedef boost::python::class_<
        D, held_type<std::auto_ptr<D> >, base_list<bases<B> > 
    > c2;

  .. @example.prepend('''
     using boost::python::class_type;
     using boost::python::copyable;
     using boost::python::held_type;
     using boost::python::base_list;
     using boost::python::bases;

     struct B {};
     struct D {};''')

  we can now examine the intended parameters::

    BOOST_MPL_ASSERT((boost::is_same<c1::class_type, B>));
    BOOST_MPL_ASSERT((boost::is_same<c1::base_list, bases<> >));
    BOOST_MPL_ASSERT((boost::is_same<c1::held_type, B>));
    BOOST_MPL_ASSERT((
         boost::is_same<c1::copyable, boost::noncopyable>
    ));

    BOOST_MPL_ASSERT((boost::is_same<c2::class_type, D>));
    BOOST_MPL_ASSERT((boost::is_same<c2::base_list, bases<B> >));
    BOOST_MPL_ASSERT((
        boost::is_same<c2::held_type, std::auto_ptr<D> >
    ));
    BOOST_MPL_ASSERT((boost::is_same<c2::copyable, void>));

.. @test('compile', howmany='all')

Deduced Template Parameters
===========================

To apply a deduced parameter interface here, we need only make the
type requirements a bit tighter so the ``held_type`` and
``copyable`` parameters can be crisply distinguished from the
others.  Boost.Python_ does this by requiring that ``base_list`` be
a specialization of its ``bases< … >`` template (as opposed to
being any old MPL sequence) and by requiring that ``copyable``, if
explicitly supplied, be ``boost::noncopyable``.  One easy way of
identifying specializations of ``bases< … >`` is to derive them all
from the same class, as an implementation detail:

.. parsed-literal::

  namespace boost { namespace python {

  namespace detail { struct bases_base {}; }

  template <class A0 = void, class A1 = void, class A2 = void *…* >
  struct bases **: detail::bases_base**
  {};

  }}  

.. @example.replace_emphasis('')
.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <boost/mpl/is_sequence.hpp>
   #include <boost/noncopyable.hpp>
   #include <memory>

   using namespace boost::parameter;
   using boost::mpl::_;

   namespace boost { namespace python {

   BOOST_PARAMETER_TEMPLATE_KEYWORD(class_type)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(base_list)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(held_type)
   BOOST_PARAMETER_TEMPLATE_KEYWORD(copyable)

   }}''')

Now we can rewrite our signature to make all three optional
parameters deducible::

  typedef parameter::parameters<
      required<tag::class_type, is_class<_> >

    , parameter::optional<
          deduced<tag::base_list>
        , is_base_and_derived<detail::bases_base,_>
      >

    , parameter::optional<
          deduced<tag::held_type>
        , mpl::not_<
              mpl::or_<
                  is_base_and_derived<detail::bases_base,_>
                , is_same<noncopyable,_>
              >
          >
      >

    , parameter::optional<deduced<tag::copyable>, is_same<noncopyable,_> >

  > class_signature;

.. @example.prepend('''
   #include <boost/type_traits/is_class.hpp>
   namespace boost { namespace python {''')

.. @example.append('''
   template <
       class A0
     , class A1 = parameter::void_
     , class A2 = parameter::void_
     , class A3 = parameter::void_
   >
   struct class_
   {
       // Create ArgumentPack
       typedef typename 
         class_signature::bind<A0,A1,A2,A3>::type 
       args;
 
       // Extract first logical parameter.
       typedef typename parameter::value_type<
         args, tag::class_type>::type class_type;
      
       typedef typename parameter::value_type<
         args, tag::base_list, bases<> >::type base_list;
      
       typedef typename parameter::value_type<
         args, tag::held_type, class_type>::type held_type;
      
       typedef typename parameter::value_type<
         args, tag::copyable, void>::type copyable;
   };

   }}''')

It may seem like we've added a great deal of complexity, but the
benefits to our users are greater.  Our original examples can now
be written without explicit parameter names:

.. parsed-literal::

  typedef boost::python::class_<**B**, **boost::noncopyable**> c1;

  typedef boost::python::class_<**D**, **std::auto_ptr<D>**, **bases<B>** > c2;

.. @example.prepend('''
   struct B {};
   struct D {};

   using boost::python::bases;''')

.. @example.append('''
   BOOST_MPL_ASSERT((boost::is_same<c1::class_type, B>));
   BOOST_MPL_ASSERT((boost::is_same<c1::base_list, bases<> >));
   BOOST_MPL_ASSERT((boost::is_same<c1::held_type, B>));
   BOOST_MPL_ASSERT((
        boost::is_same<c1::copyable, boost::noncopyable>
   ));

   BOOST_MPL_ASSERT((boost::is_same<c2::class_type, D>));
   BOOST_MPL_ASSERT((boost::is_same<c2::base_list, bases<B> >));
   BOOST_MPL_ASSERT((
       boost::is_same<c2::held_type, std::auto_ptr<D> >
   ));
   BOOST_MPL_ASSERT((boost::is_same<c2::copyable, void>));''')

.. @test('compile', howmany='all')

===============
Advanced Topics
===============

At this point, you should have a good grasp of the basics.  In this
section we'll cover some more esoteric uses of the library.

-------------------------
Fine-Grained Name Control
-------------------------

If you don't like the leading-underscore naming convention used
to refer to keyword objects, or you need the name ``tag`` for
something other than the keyword type namespace, there's another
way to use ``BOOST_PARAMETER_NAME``:

.. parsed-literal::

   BOOST_PARAMETER_NAME(\ **(**\ *object-name*\ **,** *tag-namespace*\ **)** *parameter-name*\ )

.. @ignore()

Here is a usage example:

.. parsed-literal::

  BOOST_PARAMETER_NAME((**pass_foo**, **keywords**) **foo**)

  BOOST_PARAMETER_FUNCTION(
    (int), f, 
    **keywords**, (required (**foo**, \*)))
  {
      return **foo** + 1;
  }

  int x = f(**pass_foo** = 41);

.. @example.prepend('#include <boost/parameter.hpp>')
.. @example.append('''
   int main()
   {}''')
.. @test('run')

Before you use this more verbose form, however, please read the
section on `best practices for keyword object naming`__.

__ `Keyword Naming`_

-----------------------
More |ArgumentPack|\ s
-----------------------

We've already seen |ArgumentPack|\ s when we looked at
`parameter-enabled constructors`_ and `class templates`__.  As you
might have guessed, |ArgumentPack|\ s actually lie at the heart of
everything this library does; in this section we'll examine ways to
build and manipulate them more effectively.

__ binding_intro_

Building |ArgumentPack|\ s
==========================

The simplest |ArgumentPack| is the result of assigning into a
keyword object::

   BOOST_PARAMETER_NAME(index)

   template <class ArgumentPack>
   int print_index(ArgumentPack const& args)
   {
       std::cout << "index = " << args[_index] << std::endl;
       return 0;
   }

   int x = print_index(_index = 3);  // prints "index = 3"

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>''')

Also, |ArgumentPack|\ s can be composed using the comma operator.
The extra parentheses below are used to prevent the compiler from
seeing two separate arguments to ``print_name_and_index``::

   BOOST_PARAMETER_NAME(name)

   template <class ArgumentPack>
   int print_name_and_index(ArgumentPack const& args)
   {
       std::cout << "name = " << args[_name] << "; ";
       return print_index(args);
   }

   int y = print_name_and_index((_index = 3, _name = "jones"));

To build an |ArgumentPack| with positional arguments, we can use a
|ParameterSpec|_.  As introduced described in the section on `Class
Template Signatures`_, a |ParameterSpec| describes the positional
order of parameters and any associated type requirements.  Just as
we can build an |ArgumentPack| *type* with its nested ``::bind< …
>`` template, we can build an |ArgumentPack| *object* by invoking
its function call operator:

.. parsed-literal::

  parameter::parameters<
      required<tag::\ name, is_convertible<_,char const*> >
    , optional<tag::\ index, is_convertible<_,int> >
  > spec;

  char const sam[] = "sam";
  int twelve = 12;

  int z0 = print_name_and_index( **spec(**\ sam, twelve\ **)** );

  int z1 = print_name_and_index( 
     **spec(**\ _index=12, _name="sam"\ **)** 
  );

.. @example.prepend('''
   namespace parameter = boost::parameter;
   using parameter::required;
   using parameter::optional;
   using boost::is_convertible;
   using boost::mpl::_;''')

.. @example.append('''
   int main()
   {}''')

.. @test('run', howmany='all')

Note that because of the `forwarding problem`_, ``parameter::parameters::operator()``
can't accept non-const rvalues.

.. _`forwarding problem`: http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2002/n1385.htm

Extracting Parameter Types
==========================

If we want to know the types of the arguments passed to
``print_name_and_index``, we have a couple of options.  The
simplest and least error-prone approach is to forward them to a
function template and allow *it* to do type deduction::

   BOOST_PARAMETER_NAME(name)
   BOOST_PARAMETER_NAME(index)

   template <class Name, class Index>
   int deduce_arg_types_impl(Name& name, Index& index)
   {
       Name& n2 = name;  // we know the types
       Index& i2 = index;
       return index;
   }

   template <class ArgumentPack>
   int deduce_arg_types(ArgumentPack const& args)
   {
       return deduce_arg_types_impl(args[_name], args[_index|42]);
   }

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <cassert>''')

.. @example.append('''
   int a1 = deduce_arg_types((_name = "foo"));
   int a2 = deduce_arg_types((_name = "foo", _index = 3));

   int main()
   {
       assert(a1 == 42);
       assert(a2 == 3);
   }''')

.. @test('run')

Occasionally one needs to deduce argument types without an extra
layer of function call.  For example, suppose we wanted to return
twice the value of the ``index`` parameter?  In that
case we can use the ``value_type< … >`` metafunction introduced
`earlier`__::

   BOOST_PARAMETER_NAME(index)

   template <class ArgumentPack>
   typename parameter::value_type<ArgumentPack, tag::index, int>::type
   twice_index(ArgumentPack const& args)
   {
       return 2 * args[_index|42];
   }

   int six = twice_index(_index = 3);

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <boost/type_traits/remove_reference.hpp>
   #include <cassert>

   namespace parameter = boost::parameter;
   ''')

.. @example.append('''
   int main()
   {
       assert(six == 6);
   }''')

.. @test('run', howmany='all')

Note that if we had used ``binding< … >`` rather than ``value_type< …
>``, we would end up returning a reference to the temporary created in
the ``2 * …`` expression.

__ binding_intro_

Lazy Default Computation
========================

When a default value is expensive to compute, it would be
preferable to avoid it until we're sure it's absolutely necessary.
``BOOST_PARAMETER_FUNCTION`` takes care of that problem for us, but
when using |ArgumentPack|\ s explicitly, we need a tool other than
``operator|``::

   BOOST_PARAMETER_NAME(s1)
   BOOST_PARAMETER_NAME(s2)
   BOOST_PARAMETER_NAME(s3)

   template <class ArgumentPack>
   std::string f(ArgumentPack const& args)
   {
       std::string const& s1 = args[_s1];
       std::string const& s2 = args[_s2];
       typename parameter::binding<
           ArgumentPack,tag::s3,std::string
       >::type s3 = args[_s3|(s1+s2)]; // always constructs s1+s2
       return s3;
   }

   std::string x = f((_s1="hello,", _s2=" world", _s3="hi world"));

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <string>
   
   namespace parameter = boost::parameter;''')

.. @example.append('''
   int main()
   {}''')

.. @test('run')

In the example above, the string ``"hello, world"`` is constructed
despite the fact that the user passed us a value for ``s3``.  To
remedy that, we can compute the default value *lazily* (that is,
only on demand), by using ``boost::bind()`` to create a function
object.

.. danielw: I'm leaving the text below in the source, because we might
.. want to change back to it after 1.34, and if I remove it now we
.. might forget about it.

.. by combining the logical-or (“``||``”) operator
.. with a function object built by the Boost Lambda_ library: [#bind]_

.. parsed-literal::

   typename parameter::binding<
       ArgumentPack, tag::s3, std::string
   >::type s3 = args[_s3
       **|| boost::bind(std::plus<std::string>(), boost::ref(s1), boost::ref(s2))** ];

.. @example.prepend('''
   #include <boost/bind.hpp>
   #include <boost/ref.hpp>
   #include <boost/parameter.hpp>
   #include <string>
   #include <functional>

   namespace parameter = boost::parameter;

   BOOST_PARAMETER_NAME(s1)
   BOOST_PARAMETER_NAME(s2)
   BOOST_PARAMETER_NAME(s3)

   template <class ArgumentPack>
   std::string f(ArgumentPack const& args)
   {
       std::string const& s1 = args[_s1];
       std::string const& s2 = args[_s2];''')

.. @example.append('''
       return s3;
   }

   std::string x = f((_s1="hello,", _s2=" world", _s3="hi world"));

   int main()
   {}''')

.. @test('run')

.. .. _Lambda: ../../../lambda/index.html

.. sidebar:: Mnemonics

   To remember the difference between ``|`` and ``||``, recall that
   ``||`` normally uses short-circuit evaluation: its second
   argument is only evaluated if its first argument is ``false``.
   Similarly, in ``color_map[param||f]``, ``f`` is only invoked if
   no ``color_map`` argument was supplied.

The expression ``bind(std::plus<std::string>(), ref(s1), ref(s2))`` yields
a *function object* that, when invoked, adds the two strings together.
That function will only be invoked if no ``s3`` argument is supplied by 
the caller.

.. The expression ``lambda::var(s1)+lambda::var(s2)`` yields a
.. *function object* that, when invoked, adds the two strings
.. together.  That function will only be invoked if no ``s3`` argument
.. is supplied by the caller.

================ 
 Best Practices
================

By now you should have a fairly good idea of how to use the
Parameter library.  This section points out a few more-marginal
issues that will help you use the library more effectively.

--------------
Keyword Naming
--------------

``BOOST_PARAMETER_NAME`` prepends a leading underscore to the names
of all our keyword objects in order to avoid the following
usually-silent bug:

.. parsed-literal::

  namespace people
  {
    namespace tag { struct name; struct age;  }

    namespace // unnamed
    {
      boost::parameter::keyword<tag::name>& **name**
      = boost::parameter::keyword<tag::name>::instance;
      boost::parameter::keyword<tag::age>& **age**
      = boost::parameter::keyword<tag::age>::instance;
    }

    BOOST_PARAMETER_FUNCTION(
        (void), g, tag, (optional (name, \*, "bob")(age, \*, 42)))
    {
        std::cout << name << ":" << age;
    }

    void f(int age)
    {
    :vellipsis:`\ 
       .
       .
       .
     ` 
       g(**age** = 3); // whoops!
    }
  }

.. @ignore()

Although in the case above, the user was trying to pass the value
``3`` as the ``age`` parameter to ``g``, what happened instead
was that ``f``\ 's ``age`` argument got reassigned the value 3,
and was then passed as a positional argument to ``g``.  Since
``g``'s first positional parameter is ``name``, the default value
for ``age`` is used, and g prints ``3:42``.  Our leading
underscore naming convention that makes this problem less likely
to occur.

In this particular case, the problem could have been detected if
f's ``age`` parameter had been made ``const``, which is always a
good idea whenever possible.  Finally, we recommend that you use
an enclosing namespace for all your code, but particularly for
names with leading underscores.  If we were to leave out the
``people`` namespace above, names in the global namespace
beginning with leading underscores—which are reserved to your C++
compiler—might become irretrievably ambiguous with those in our
unnamed namespace.

----------
Namespaces
----------

In our examples we've always declared keyword objects in (an
unnamed namespace within) the same namespace as the
Boost.Parameter-enabled functions using those keywords:

.. parsed-literal::

  namespace lib
  {
    **BOOST_PARAMETER_NAME(name)
    BOOST_PARAMETER_NAME(index)**

    BOOST_PARAMETER_FUNCTION(
      (int), f, tag, 
      (optional (name,*,"bob")(index,(int),1))
    )
    {
        std::cout << name << ":" << index << std::endl;
        return index;
    }
  }

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>''')
.. @namespace_setup = str(example)
.. @ignore()

Users of these functions have a few choices:

1. Full qualification:

  .. parsed-literal::

    int x = **lib::**\ f(**lib::**\ _name = "jill", **lib::**\ _index = 1);

  This approach is more verbose than many users would like.

.. @example.prepend(namespace_setup)
.. @example.append('int main() {}')
.. @test('run')

2. Make keyword objects available through
   *using-declarations*:

  .. parsed-literal::

    **using lib::_name;
    using lib::_index;**

    int x = lib::f(_name = "jill", _index = 1);

  This version is much better at the actual call site, but the
  *using-declarations* themselves can be verbose and hard-to
  manage.

.. @example.prepend(namespace_setup)
.. @example.append('int main() {}')
.. @test('run')

3. Bring in the entire namespace with a *using-directive*:

  .. parsed-literal::

    **using namespace lib;**
    int x = **f**\ (_name = "jill", _index = 3);

  This option is convenient, but it indiscriminately makes the
  *entire* contents of ``lib`` available without qualification.

.. @example.prepend(namespace_setup)
.. @example.append('int main() {}')
.. @test('run')

If we add an additional namespace around keyword declarations,
though, we can give users more control:

.. parsed-literal::

  namespace lib
  {
    **namespace keywords
    {**
       BOOST_PARAMETER_NAME(name)
       BOOST_PARAMETER_NAME(index)
    **}**

    BOOST_PARAMETER_FUNCTION(
      (int), f, **keywords::**\ tag, 
      (optional (name,*,"bob")(index,(int),1))
    )
    {
        std::cout << name << ":" << index << std::endl;
        return index;
    }
  }

.. @example.prepend('''
   #include <boost/parameter.hpp>
   #include <iostream>''')

Now users need only a single *using-directive* to bring in just the
names of all keywords associated with ``lib``:

.. parsed-literal::
  
  **using namespace lib::keywords;**
  int y = lib::f(_name = "bob", _index = 2);

.. @example.append('int main() {}')
.. @test('run', howmany='all')

-------------
Documentation
-------------

The interface idioms enabled by Boost.Parameter are completely new
(to C++), and as such are not served by pre-existing documentation
conventions.  

.. Note:: This space is empty because we haven't settled on any
   best practices yet.  We'd be very pleased to link to your
   documentation if you've got a style that you think is worth
   sharing.

============================
 Portability Considerations
============================

Use the `regression test results`_ for the latest Boost release of
the Parameter library to see how it fares on your favorite
compiler.  Additionally, you may need to be aware of the following
issues and workarounds for particular compilers.

.. _`regression test results`: http://www.boost.org/regression/release/user/parameter.html

-----------------
No SFINAE Support
-----------------

Some older compilers don't support SFINAE.  If your compiler meets
that criterion, then Boost headers will ``#define`` the preprocessor
symbol ``BOOST_NO_SFINAE``, and parameter-enabled functions won't be
removed from the overload set based on their signatures.

---------------------------
No Support for |result_of|_
---------------------------

.. |result_of| replace:: ``result_of``

.. _result_of: ../../../utility/utility.htm#result_of

`Lazy default computation`_ relies on the |result_of| class
template to compute the types of default arguments given the type
of the function object that constructs them.  On compilers that
don't support |result_of|, ``BOOST_NO_RESULT_OF`` will be
``#define``\ d, and the compiler will expect the function object to
contain a nested type name, ``result_type``, that indicates its
return type when invoked without arguments.  To use an ordinary
function as a default generator on those compilers, you'll need to
wrap it in a class that provides ``result_type`` as a ``typedef``
and invokes the function via its ``operator()``.

.. 
  Can't Declare |ParameterSpec| via ``typedef``
  =============================================

  In principle you can declare a |ParameterSpec| as a ``typedef``
  for a specialization of ``parameters<…>``, but Microsoft Visual C++
  6.x has been seen to choke on that usage.  The workaround is to use
  inheritance and declare your |ParameterSpec| as a class:

  .. parsed-literal::

       **struct dfs_parameters
         :** parameter::parameters<
             tag::graph, tag::visitor, tag::root_vertex
           , tag::index_map, tag::color_map
       > **{};**


  Default Arguments Unsupported on Nested Templates
  =================================================

  As of this writing, Borland compilers don't support the use of
  default template arguments on member class templates.  As a result,
  you have to supply ``BOOST_PARAMETER_MAX_ARITY`` arguments to every
  use of ``parameters<…>::match``.  Since the actual defaults used
  are unspecified, the workaround is to use
  |BOOST_PARAMETER_MATCH|_ to declare default arguments for SFINAE.

  .. |BOOST_PARAMETER_MATCH| replace:: ``BOOST_PARAMETER_MATCH``

--------------------------------------------------
Compiler Can't See References In Unnamed Namespace
--------------------------------------------------

If you use Microsoft Visual C++ 6.x, you may find that the compiler
has trouble finding your keyword objects.  This problem has been
observed, but only on this one compiler, and it disappeared as the
test code evolved, so we suggest you use it only as a last resort
rather than as a preventative measure.  The solution is to add
*using-declarations* to force the names to be available in the
enclosing namespace without qualification::

    namespace graphs
    {
      using graphs::graph;
      using graphs::visitor;
      using graphs::root_vertex;
      using graphs::index_map;
      using graphs::color_map;
    }

================
 Python Binding
================

.. _python: python.html

Follow `this link`__ for documentation on how to expose
Boost.Parameter-enabled functions to Python with `Boost.Python`_.

__ python.html

===========
 Reference
===========

.. _reference: reference.html

Follow `this link`__ to the Boost.Parameter reference
documentation.  

__ reference.html

==========
 Glossary
==========

.. _arguments:

:Argument (or “actual argument”): the value actually passed to a
  function or class template

.. _parameter:

:Parameter (or “formal parameter”): the name used to refer to an
  argument within a function or class template.  For example, the
  value of ``f``'s *parameter* ``x`` is given by the *argument*
  ``3``::

    int f(int x) { return x + 1 }
    int y = f(3);

==================
 Acknowledgements
==================

The authors would like to thank all the Boosters who participated
in the review of this library and its documentation, most
especially our review manager, Doug Gregor.

--------------------------

.. [#old_interface] As of Boost 1.33.0 the Graph library was still
   using an `older named parameter mechanism`__, but there are
   plans to change it to use Boost.Parameter (this library) in an
   upcoming release, while keeping the old interface available for
   backward-compatibility.  

__ ../../../graph/doc/bgl_named_params.html

.. [#odr] The **One Definition Rule** says that any given entity in
   a C++ program must have the same definition in all translation
   units (object files) that make up a program.

.. [#vertex_descriptor] If you're not familiar with the Boost Graph
   Library, don't worry about the meaning of any
   Graph-library-specific details you encounter.  In this case you
   could replace all mentions of vertex descriptor types with
   ``int`` in the text, and your understanding of the Parameter
   library wouldn't suffer.

.. [#ConceptCpp] This is a major motivation behind `ConceptC++`_.

.. _`ConceptC++`: http://www.generic-programming.org/software/ConceptGCC/

.. .. [#bind] The Lambda library is known not to work on `some
..   less-conformant compilers`__.  When using one of those you could
..   use `Boost.Bind`_ to generate the function object::

..      boost::bind(std::plus<std::string>(),s1,s2)

.. [#is_keyword_expression] Here we're assuming there's a predicate
   metafunction ``is_keyword_expression`` that can be used to
   identify models of Boost.Python's KeywordExpression concept.

.. .. __ http://www.boost.org/regression/release/user/lambda.html
.. _Boost.Bind: ../../../bind/index.html


.. [#using] You can always give the illusion that the function
   lives in an outer namespace by applying a *using-declaration*::

      namespace foo_overloads
      {
        // foo declarations here
        void foo() { ... }
        ...
      }
      using foo_overloads::foo;

    This technique for avoiding unintentional argument-dependent
    lookup is due to Herb Sutter.


.. [#sfinae] This capability depends on your compiler's support for SFINAE. 
   **SFINAE**: **S**\ ubstitution **F**\ ailure **I**\ s
   **N**\ ot **A**\ n **E** rror.  If type substitution during the
   instantiation of a function template results in an invalid type,
   no compilation error is emitted; instead the overload is removed
   from the overload set. By producing an invalid type in the
   function signature depending on the result of some condition,
   we can decide whether or not an overload is considered during overload
   resolution.  The technique is formalized in
   the |enable_if|_ utility.  Most recent compilers support SFINAE;
   on compilers that don't support it, the Boost config library
   will ``#define`` the symbol ``BOOST_NO_SFINAE``.
   See
   http://www.semantics.org/once_weakly/w02_SFINAE.pdf for more
   information on SFINAE.

.. |enable_if| replace:: ``enable_if``
.. _enable_if: ../../../utility/enable_if.html


============================
|(logo)|__ ``read_graphviz``
============================

.. |(logo)| image:: ../../../boost.png
   :align: middle
   :alt: Boost

.. Copyright (c) 2005-2009 Trustees of Indiana University
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
__ ../../../index.htm

::

  namespace boost {
  
    template <typename MutableGraph>
    bool read_graphviz(std::istream& in, MutableGraph& graph,
                       dynamic_properties& dp, 
                       const std::string& node_id = "node_id");
  
    template <typename MutableGraph>
    bool read_graphviz(std::string& str, MutableGraph& graph,
                       dynamic_properties& dp, 
                       const std::string& node_id = "node_id");
  
    template <typename InputIterator, typename MutableGraph>
    bool read_graphviz(InputIterator begin, InputIterator end,
                       MutableGraph& graph, dynamic_properties& dp, 
                       const std::string& node_id = "node_id");
  
  }

 
The ``read_graphviz`` function interprets a graph described using the
GraphViz_ DOT language and builds a BGL graph that captures that
description.  Using these functions, you can initialize a graph using
data stored as text.

The DOT language can specify both directed and undirected graphs, and
``read_graphviz`` differentiates between the two. One must pass
``read_graphviz`` an undirected graph when reading an undirected graph;
the same is true for directed graphs. Furthermore, ``read_graphviz``
will throw an exception if it encounters parallel edges and cannot add
them to the graph.

To handle properties expressed in the DOT language, ``read_graphviz``
takes a dynamic_properties_ object and operates on its collection of
property maps.  The reader passes all the properties encountered to
this object, using the GraphViz string keys as the property keys.
Furthermore, ``read_graphviz`` stores node identifier names under the
vertex property map named ``node_id``. 

Requirements:
 - The type of the graph must model the `Mutable Graph`_ concept.
 - The type of the iterator must model the `Input Iterator`_
   concept.
 - The property map value types must be default-constructible.


.. contents::

Where Defined
-------------
``<boost/graph/graphviz.hpp>``

Exceptions
----------

::

  struct graph_exception : public std::exception {
    virtual ~graph_exception() throw();
    virtual const char* what() const throw() = 0;
  };

  struct bad_parallel_edge : public graph_exception {
    std::string from;
    std::string to;

    bad_parallel_edge(const std::string&, const std::string&);
    virtual ~bad_parallel_edge() throw();
    const char* what() const throw();
  };

  struct directed_graph_error : public graph_exception {
    virtual ~directed_graph_error() throw();
    virtual const char* what() const throw();
  };

  struct undirected_graph_error : public graph_exception {
    virtual ~undirected_graph_error() throw();
    virtual const char* what() const throw();
  };

  struct bad_graphviz_syntax: public graph_exception {
    std::string errmsg;

    bad_graphviz_syntax(const std::string&);
    virtual ~bad_graphviz_syntax() throw();
    virtual const char* what() const throw();
  };

Under certain circumstances, ``read_graphviz`` will throw one of the
above exceptions.  The three concrete exceptions can all be caught
using the general ``graph_exception`` moniker when greater precision
is not needed.  In addition, all of the above exceptions derive from
the standard ``std::exception`` for even more generalized error
handling.

The ``bad_parallel_edge`` exception is thrown when an attempt to add a
parallel edge to the supplied MutableGraph fails.  The DOT language
supports parallel edges, but some BGL-compatible graph types do not.
One example of such a graph is ``boost::adjacency_list<setS,vecS>``,
which allows at most one edge can between any two vertices.


The ``directed_graph_error`` exception occurs when an undirected graph
type is passed to ``read_graph`` but the textual representation of the
graph is directed, as indicated by the ``digraph`` keyword in the DOT
language.

The ``undirected_graph_error`` exception occurs when a directed graph
type is passed to ``read_graph`` but the textual representation of the
graph is undirected, as indicated by the ``graph`` keyword in the DOT
language.

The ``bad_graphviz_syntax`` exception occurs when the graph input is not a
valid GraphViz graph.


Example
-------
The following example illustrates a relatively simple use of the
GraphViz reader to populate an ``adjacency_list`` graph

::

  // Vertex properties
  typedef property < vertex_name_t, std::string,
            property < vertex_color_t, float > > vertex_p;  
  // Edge properties
  typedef property < edge_weight_t, double > edge_p;
  // Graph properties
  typedef property < graph_name_t, std::string > graph_p;
  // adjacency_list-based type
  typedef adjacency_list < vecS, vecS, directedS,
    vertex_p, edge_p, graph_p > graph_t;

  // Construct an empty graph and prepare the dynamic_property_maps.
  graph_t graph(0);
  dynamic_properties dp;

  property_map<graph_t, vertex_name_t>::type name =
    get(vertex_name, graph);
  dp.property("node_id",name);

  property_map<graph_t, vertex_color_t>::type mass =
    get(vertex_color, graph);
  dp.property("mass",mass);

  property_map<graph_t, edge_weight_t>::type weight =
    get(edge_weight, graph);
  dp.property("weight",weight);

  // Use ref_property_map to turn a graph property into a property map
  boost::ref_property_map<graph_t*,std::string> 
    gname(get_property(graph,graph_name));
  dp.property("name",gname);

  // Sample graph as an std::istream;
  std::istringstream
    gvgraph("digraph { graph [name=\"graphname\"]  a  c e [mass = 6.66] }");

  bool status = read_graphviz(gvgraph,graph,dp,"node_id");




Building the GraphViz Readers
-----------------------------
To use the GraphViz readers, you will need to build and link against
the "boost_graph" and "boost_regex" libraries. These libraries can be built by following the
`Boost Jam Build Instructions`_ for the subdirectories ``libs/graph/build`` and ``libs/regex/build``.


Notes
-----

 - The ``read_graphviz`` function does not use any code from the
   GraphViz distribution to interpret the DOT Language.  Rather, the
   implementation was based on documentation found on the GraphViz web
   site, as well as experiments run using the dot application.  The
   resulting interpretation may be subtly different from dot for some
   corner cases that are not well specified.

 - On successful reading of a graph, every vertex and edge will have
   an associated value for every respective edge and vertex property
   encountered while interpreting the graph.  These values will be set
   using the ``dynamic_properties`` object.  Those edges and
   vertices that are not explicitly given a value for a property (and that
   property has no default) will be
   given the default constructed value of the value type.  **Be sure
   that property map value types are default constructible.**

 - ``read_graphviz`` treats subgraphs as syntactic sugar.  It does not
   reflect subgraphs as actual entities in the BGL.  Rather, they are
   used to shorten some edge definitions as well as to give a subset
   of all nodes or edges certain properties. For example, the
   DOT graphs ``digraph { a -> subgraph {b -> c} -> e }`` and 
   ``digraph { a -> b -> e ; a -> c -> e ; b -> c}`` are equivalent.

 - Subgraph IDs refer to subgraphs defined earlier in the graph
   description.  Undefined subgraphs behave as empty subgraphs
   (``{}``).  This is the same behavior as GraphViz.

See Also
--------

write_graphviz_


Future Work
-----------

 - Passing port information to BGL.

 - Expanding escape codes in the same way GraphViz does.

 - Support for optional recognition of subgraphs as distinct entities.


.. _GraphViz: http://graphviz.org/
.. _`Mutable Graph`: MutableGraph.html
.. _`Input Iterator`: http://www.sgi.com/tech/stl/InputIterator.html
.. _dynamic_properties: ../../property_map/doc/dynamic_property_map.html
.. _write_graphviz: write-graphviz.html
.. _Boost Jam Build Instructions: ../../../more/getting_started.html#Build_Install
============================
|(logo)|__ ``read_graphml``
============================

.. Copyright (C) 2006  Tiago de Paula Peixoto <tiago@forked.de>
  
   Distributed under the Boost Software License, Version 1.0. (See
   accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)
 
   Authors: Tiago de Paula Peixoto

.. |(logo)| image:: ../../../boost.png
   :align: middle
   :alt: Boost

__ ../../../index.htm

::

  void read_graphml(std::istream& in, MutableGraph& graph,
                    dynamic_properties& dp, size_t graph_index = 0);

 
The ``read_graphml`` function interprets a graph described using the
GraphML_ format and builds a BGL graph that captures that
description.  Using this function, you can initialize a graph using
data stored as text. 

The GraphML format can specify both directed and undirected graphs, and
``read_graphml`` differentiates between the two. One must pass
``read_graphml`` an undirected graph when reading an undirected graph;
the same is true for directed graphs. Furthermore, ``read_graphml``
will throw an exception if it encounters parallel edges and cannot add
them to the graph.

To handle attributes expressed in the GraphML format, ``read_graphml``
takes a dynamic_properties_ object and operates on its collection of
property maps.  The reader passes all the properties encountered to
this object, using the GraphML attribute names as the property names,
and with the appropriate C++ value type based on the GraphML attribute type
definition. Graph properties are also set with the same
dynamic_properties_ object, where the key type is the type of the graph itself.

If the file contains multiple graphs, the ``graph_index`` parameter controls
which graph will be loaded.  It defaults to ``0``, meaning that the first graph
in the file will be loaded.  If ``graph_index`` is greater than or equal to the
number of graphs in the file, an empty graph will be returned.

Requirements:
 - The type of the graph must model the `Mutable Graph`_ concept.
 - The type of the iterator must model the `Multi-Pass Iterator`_
   concept.
 - The property map value types must be default-constructible.


.. contents::

Where Defined
-------------
``<boost/graph/graphml.hpp>``

Exceptions
----------

::

  struct graph_exception : public std::exception {
    virtual ~graph_exception() throw();
    virtual const char* what() const throw() = 0;
  };

  struct bad_parallel_edge : public graph_exception {
    std::string from;
    std::string to;

    bad_parallel_edge(const std::string&, const std::string&);
    virtual ~bad_parallel_edge() throw();
    const char* what() const throw();
  };

  struct directed_graph_error : public graph_exception {
    virtual ~directed_graph_error() throw();
    virtual const char* what() const throw();
  };

  struct undirected_graph_error : public graph_exception {
    virtual ~undirected_graph_error() throw();
    virtual const char* what() const throw();
  };

  struct parse_error : public graph_exception {
    parse_error(const std::string&);
    virtual ~parse_error() throw() {}
    virtual const char* what() const throw();
    std::string statement;
    std::string error;
  };

Under certain circumstances, ``read_graphml`` will throw one of the
above exceptions.  The three concrete exceptions can all be caught
using the general ``graph_exception`` moniker when greater precision
is not needed.  In addition, all of the above exceptions derive from
the standard ``std::exception`` for even more generalized error
handling.

The ``bad_parallel_edge`` exception is thrown when an attempt to add a
parallel edge to the supplied MutableGraph fails.  The GraphML format
supports parallel edges, but some BGL-compatible graph types do not.
One example of such a graph is ``boost::adjacency_list<setS,vecS>``,
which allows at most one edge can between any two vertices.


The ``directed_graph_error`` exception occurs when an undirected graph
type is passed to ``read_graph``, but the graph defined in the GraphML
file contains at least one directed edge.

The ``undirected_graph_error`` exception occurs when a directed graph
type is passed to ``read_graph``,  but the graph defined in the GraphML
file contains at least one undirected edge.

The ``parse_error`` exception occurs when a syntax error is
encountered in the GraphML file. The error string will contain the
line and column where the error was encountered.


Building the GraphML reader
-----------------------------
To use the GraphML reader, you will need to build and link against
the "boost_graph" library. The library can be built by following the
`Boost Jam Build Instructions`_ for the subdirectory ``libs/graph/build``.


Notes
-----

 - On successful reading of a graph, every vertex and edge will have
   an associated value for every respective edge and vertex property
   encountered while interpreting the graph.  These values will be set
   using the ``dynamic_properties`` object.  Some properties may be
   ``put`` multiple times during the course of reading in order to
   ensure the GraphML semantics.  Those edges and vertices that are
   not explicitly given a value for a property (and that property has
   no default) will be given the default constructed value of the
   value type.  **Be sure that property map value types are default
   constructible.**

 - Nested graphs are supported as long as they are exactly of the same
   type as the root graph, i.e., are also directed or undirected. Note
   that since nested graphs are not directly supported by BGL, they
   are in fact completely ignored when building the graph, and the
   internal vertices or edges are interpreted as belonging to the root
   graph.

 - Hyperedges and Ports are not supported.

See Also
--------

write_graphml_


.. _GraphML: http://graphml.graphdrawing.org/
.. _`Mutable Graph`: MutableGraph.html
.. _`Multi-Pass Iterator`: ../../iterator/index.html
.. _dynamic_properties: ../../property_map/doc/dynamic_property_map.html
.. _write_graphml: write_graphml.html
.. _Boost Jam Build Instructions: ../../../more/getting_started.html#Build_Install
============================
|(logo)|__ ``write_graphml``
============================

.. Copyright (C) 2006  Tiago de Paula Peixoto <tiago@forked.de>
  
   Distributed under the Boost Software License, Version 1.0. (See
   accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)
 
   Authors: Tiago de Paula Peixoto

.. |(logo)| image:: ../../../boost.png
   :align: middle
   :alt: Boost

__ ../../../index.htm

::

  template<typename Graph>
  void
  write_graphml(std::ostream& out, const Graph& g, const dynamic_properties& dp, 
	        bool ordered_vertices=false);

  template<typename Graph, typename VertexIndexMap>
  void
  write_graphml(std::ostream& out, const Graph& g, VertexIndexMap vertex_index,
                const dynamic_properties& dp, bool ordered_vertices=false);

This is to write a BGL graph object into an output stream in the
GraphML_ format.  Both overloads of ``write_graphml`` will emit all of
the properties stored in the dynamic_properties_ object, thereby
retaining the properties that have been read in through the dual
function read_graphml_. The second overload must be used when the
graph doesn't have an internal vertex index map, which must then be
supplied with the appropriate parameter.

.. contents::

Where Defined
-------------
``<boost/graph/graphml.hpp>``

Parameters
----------

OUT: ``std::ostream& out``
  A standard ``std::ostream`` object.

IN: ``VertexListGraph& g`` 
  A directed or undirected graph.  The
  graph's type must be a model of VertexListGraph_. If the graph
  doesn't have an internal ``vertex_index`` property map, one
  must be supplied with the vertex_index parameter.

IN: ``VertexIndexMap vertex_index``
  A vertex property map containing the indexes in the range
  [0,num_vertices(g)].


IN: ``dynamic_properties& dp``
  Contains all of the vertex, edge, and graph properties that should be
  emitted by the GraphML writer.

IN: ``bool ordered_vertices``
  This tells whether or not the order of the vertices from vertices(g)
  matches the order of the indexes. If ``true``, the ``parse.nodeids``
  graph attribute will be set to ``canonical``. Otherwise it will be
  set to ``free``.



Example
-------

This example demonstrates using BGL-GraphML interface to write 
a BGL graph into a GraphML format file.

::

  enum files_e { dax_h, yow_h, boz_h, zow_h, foo_cpp,
                 foo_o, bar_cpp, bar_o, libfoobar_a,
                 zig_cpp, zig_o, zag_cpp, zag_o,
                 libzigzag_a, killerapp, N };
  const char* name[] = { "dax.h", "yow.h", "boz.h", "zow.h", "foo.cpp",
                         "foo.o", "bar.cpp", "bar.o", "libfoobar.a",
                         "zig.cpp", "zig.o", "zag.cpp", "zag.o",
                         "libzigzag.a", "killerapp" };

  int main(int,char*[])
  {
      typedef pair<int,int> Edge;
      Edge used_by[] = {
          Edge(dax_h, foo_cpp), Edge(dax_h, bar_cpp), Edge(dax_h, yow_h),
          Edge(yow_h, bar_cpp), Edge(yow_h, zag_cpp),
          Edge(boz_h, bar_cpp), Edge(boz_h, zig_cpp), Edge(boz_h, zag_cpp),
          Edge(zow_h, foo_cpp),
          Edge(foo_cpp, foo_o),
          Edge(foo_o, libfoobar_a),
          Edge(bar_cpp, bar_o),
          Edge(bar_o, libfoobar_a),
          Edge(libfoobar_a, libzigzag_a),
          Edge(zig_cpp, zig_o),
          Edge(zig_o, libzigzag_a),
          Edge(zag_cpp, zag_o),
          Edge(zag_o, libzigzag_a),
          Edge(libzigzag_a, killerapp)
       };

      const int nedges = sizeof(used_by)/sizeof(Edge);

      typedef adjacency_list< vecS, vecS, directedS,
          property< vertex_color_t, string >,
          property< edge_weight_t, int >
          > Graph;
      Graph g(used_by, used_by + nedges, N);

      graph_traits<Graph>::vertex_iterator v, v_end;
      for (tie(v,v_end) = vertices(g); v != v_end; ++v)
          put(vertex_color_t(), g, *v, name[*v]);

      graph_traits<Graph>::edge_iterator e, e_end;
      for (tie(e,e_end) = edges(g); e != e_end; ++e)
          put(edge_weight_t(), g, *e, 3);

      dynamic_properties dp;
      dp.property("name", get(vertex_color_t(), g));
      dp.property("weight", get(edge_weight_t(), g));

      write_graphml(std::cout, g, dp, true);
   }


The output will be:

::

  <?xml version="1.0" encoding="UTF-8"?>
  <graphml xmlns="http://graphml.graphdrawing.org/xmlns/graphml"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns/graphml http://graphml.graphdrawing.org/xmlns/graphml/graphml-attributes-1.0rc.xsd">
    <key id="key0" for="node" attr.name="name" attr.type="string" />
    <key id="key1" for="edge" attr.name="weight" attr.type="int" />
    <graph id="G" edgedefault="directed" parse.nodeids="canonical" parse.edgeids="canonical" parse.order="nodesfirst">
      <node id="n0">
        <data key="key0">dax.h</data>
      </node>
      <node id="n1">
        <data key="key0">yow.h</data>
      </node>
      <node id="n2">
        <data key="key0">boz.h</data>
      </node>
      <node id="n3">
        <data key="key0">zow.h</data>
      </node>
      <node id="n4">
        <data key="key0">foo.cpp</data>
      </node>
      <node id="n5">
        <data key="key0">foo.o</data>
      </node>
      <node id="n6">
        <data key="key0">bar.cpp</data>
      </node>
      <node id="n7">
        <data key="key0">bar.o</data>
      </node>
      <node id="n8">
        <data key="key0">libfoobar.a</data>
      </node>
      <node id="n9">
        <data key="key0">zig.cpp</data>
      </node>
      <node id="n10">
        <data key="key0">zig.o</data>
      </node>
      <node id="n11">
        <data key="key0">zag.cpp</data>
      </node>
      <node id="n12">
        <data key="key0">zag.o</data>
      </node>
      <node id="n13">
        <data key="key0">libzigzag.a</data>
      </node>
      <node id="n14">
        <data key="key0">killerapp</data>
      </node>
      <edge id="e0" source="n0" target="n4">
        <data key="key1">3</data>
      </edge>
      <edge id="e1" source="n0" target="n6">
        <data key="key1">3</data>
      </edge>
      <edge id="e2" source="n0" target="n1">
        <data key="key1">3</data>
      </edge>
      <edge id="e3" source="n1" target="n6">
        <data key="key1">3</data>
      </edge>
      <edge id="e4" source="n1" target="n11">
        <data key="key1">3</data>
      </edge>
      <edge id="e5" source="n2" target="n6">
        <data key="key1">3</data>
      </edge>
      <edge id="e6" source="n2" target="n9">
	 <data key="key1">3</data>
      </edge>
      <edge id="e7" source="n2" target="n11">
	<data key="key1">3</data>
      </edge>
      <edge id="e8" source="n3" target="n4">
	<data key="key1">3</data>
      </edge>
      <edge id="e9" source="n4" target="n5">
	<data key="key1">3</data>
      </edge>
      <edge id="e10" source="n5" target="n8">
	<data key="key1">3</data>
      </edge>
      <edge id="e11" source="n6" target="n7">
	<data key="key1">3</data>
      </edge>
      <edge id="e12" source="n7" target="n8">
	<data key="key1">3</data>
      </edge>
      <edge id="e13" source="n8" target="n13">
	<data key="key1">3</data>
      </edge>
      <edge id="e14" source="n9" target="n10">
	<data key="key1">3</data>
      </edge>
      <edge id="e15" source="n10" target="n13">
	<data key="key1">3</data>
      </edge>
      <edge id="e16" source="n11" target="n12">
	<data key="key1">3</data>
      </edge>
      <edge id="e17" source="n12" target="n13">
	<data key="key1">3</data>
      </edge>
      <edge id="e18" source="n13" target="n14">
	<data key="key1">3</data>
      </edge>
    </graph>
  </graphml>

See Also
--------

_read_graphml

Notes
-----

 - Note that you can use GraphML file write facilities without linking
   against the ``boost_graph`` library.

.. _GraphML: http://graphml.graphdrawing.org/
.. _dynamic_properties: ../../property_map/doc/dynamic_property_map.html
.. _read_graphml: read_graphml.html
.. _VertexListGraph: VertexListGraph.html

++++++++++++++++++++++++++++++++
 |Boost| Range MFC/ATL Extension
++++++++++++++++++++++++++++++++

.. |Boost| image:: http://www.boost.org/libs/ptr_container/doc/boost.png



:Author:        Shunsuke Sogame
:Contact:       mb2act@yahoo.co.jp
:date:          26th of May 2006
:copyright:     Shunsuke Sogame 2005-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see LICENSE_1_0.txt__).

__ http://www.boost.org/LICENSE_1_0.txt



========
Overview
========

Boost.Range MFC/ATL Extension provides `Boost.Range`_ support for MFC/ATL collection and string types.


.. parsed-literal::

        CTypedPtrArray<CPtrArray, CList<CString> \*> myArray;
        ...
        BOOST_FOREACH (CList<CString> \*theList, myArray)
        {
            BOOST_FOREACH (CString& str, \*theList)
            {
                boost::to_upper(str);
                std::sort(boost::begin(str), boost::end(str));
                ...
            }
        }



* `Requirements`_
* `MFC Ranges`_
* `ATL Ranges`_
* `const Ranges`_
* `References`_



============
Requirements
============

- `Boost C++ Libraries Version 1.34.0`__ or later (no compilation required)
- Visual C++ 7.1 or Visual C++ 8.0

__ Boost_



==========
MFC Ranges
==========

If the ``<boost/range/mfc.hpp>`` is included before or after `Boost.Range`_ headers,
the MFC collections and strings become models of Range.
The table below lists the Traversal Category and ``range_reference`` of MFC ranges.


============================= ================== =======================================
``Range``                     Traversal Category ``range_reference<Range>::type``
============================= ================== =======================================
``CArray<T,A>``               Random Access      ``T&``
----------------------------- ------------------ ---------------------------------------
``CList<T,A>``                Bidirectional      ``T&``
----------------------------- ------------------ ---------------------------------------
``CMap<K,AK,M,AM>``           Forward            ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CTypedPtrArray<B,T*>``      Random Access      ``T* const``
----------------------------- ------------------ ---------------------------------------
``CTypedPtrList<B,T*>``       Bidirectional      ``T* const``
----------------------------- ------------------ ---------------------------------------
``CTypedPtrMap<B,T*,V*>``     Forward            ``std::pair<T*,V*> const``
----------------------------- ------------------ ---------------------------------------
``CByteArray``                Random Access      ``BYTE&``
----------------------------- ------------------ ---------------------------------------
``CDWordArray``               Random Access      ``DWORD&``
----------------------------- ------------------ ---------------------------------------
``CObArray``                  Random Access      ``CObject* &``
----------------------------- ------------------ ---------------------------------------
``CPtrArray``                 Random Access      ``void* &``
----------------------------- ------------------ ---------------------------------------
``CStringArray``              Random Access      ``CString&``
----------------------------- ------------------ ---------------------------------------
``CUIntArray``                Random Access      ``UINT&``
----------------------------- ------------------ ---------------------------------------
``CWordArray``                Random Access      ``WORD&``
----------------------------- ------------------ ---------------------------------------
``CObList``                   Bidirectional      ``CObject* &``
----------------------------- ------------------ ---------------------------------------
``CPtrList``                  Bidirectional      ``void* &``
----------------------------- ------------------ ---------------------------------------
``CStringList``               Bidirectional      ``CString&``
----------------------------- ------------------ ---------------------------------------
``CMapPtrToWord``             Forward            ``std::pair<void*,WORD> const``
----------------------------- ------------------ ---------------------------------------
``CMapPtrToPtr``              Forward            ``std::pair<void*,void*> const``
----------------------------- ------------------ ---------------------------------------
``CMapStringToOb``            Forward            ``std::pair<String,CObject*> const``
----------------------------- ------------------ ---------------------------------------
``CMapStringToString``        Forward            ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CMapWordToOb``              Forward            ``std::pair<WORD,CObject*> const``
----------------------------- ------------------ ---------------------------------------
``CMapWordToPtr``             Forward            ``std::pair<WORD,void*> const``
============================= ================== =======================================


Other `Boost.Range`_ metafunctions are defined by the following.
Let ``Range`` be any type listed above and ``ReF`` be the same as ``range_reference<Range>::type``.
``range_value<Range>::type`` is the same as ``remove_reference<remove_const<Ref>::type>::type``,
``range_difference<Range>::type`` is the same as ``std::ptrdiff_t``, and
``range_pointer<Range>::type`` is the same as ``add_pointer<remove_reference<Ref>::type>::type``.
As for ``const Range``, see `const Ranges`_.



==========
ATL Ranges
==========

If the ``<boost/range/atl.hpp>`` is included before or after `Boost.Range`_ headers,
the ATL collections and strings become models of Range.
The table below lists the Traversal Category and ``range_reference`` of ATL ranges.


============================= ================== =======================================
``Range``                     Traversal Category ``range_reference<Range>::type``
============================= ================== =======================================
``CAtlArray<E,ET>``           Random Access      ``E&``
----------------------------- ------------------ ---------------------------------------
``CAutoPtrArray<E>``          Random Access      ``E&``
----------------------------- ------------------ ---------------------------------------
``CInterfaceArray<I,pi>``     Random Access      ``CComQIPtr<I,pi>&``
----------------------------- ------------------ ---------------------------------------
``CAtlList<E,ET>``            Bidirectional      ``E&``
----------------------------- ------------------ ---------------------------------------
``CAutoPtrList<E>``           Bidirectional      ``E&``
----------------------------- ------------------ ---------------------------------------
``CHeapPtrList<E,A>``         Bidirectional      ``E&``
----------------------------- ------------------ ---------------------------------------
``CInterfaceList<I,pi>``      Bidirectional      ``CComQIPtr<I,pi>&``
----------------------------- ------------------ ---------------------------------------
``CAtlMap<K,V,KT,VT>``        Forward            ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CRBTree<K,V,KT,VT>``        Bidirectional      ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CRBMap<K,V,KT,VT>``         Bidirectional      ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CRBMultiMap<K,V,KT,VT>``    Bidirectional      ``Range::CPair&``
----------------------------- ------------------ ---------------------------------------
``CSimpleStringT<B,b>``       Random Access      ``B&``
----------------------------- ------------------ ---------------------------------------
``CStringT<B,ST>``            Random Access      ``B&``
----------------------------- ------------------ ---------------------------------------
``CFixedStringT<S,n>``        Random Access      ``range_reference<S>::type``
----------------------------- ------------------ ---------------------------------------
``CStringT<B,ST>``            Random Access      ``B&``
----------------------------- ------------------ ---------------------------------------
``CComBSTR``                  Random Access      ``OLECHAR&``
----------------------------- ------------------ ---------------------------------------
``CSimpleArray<T,TE>``        Random Access      ``T&``
============================= ================== =======================================


Other `Boost.Range`_ metafunctions are defined by the following.
Let ``Range`` be any type listed above and ``ReF`` be the same as ``range_reference<Range>::type``.
``range_value<Range>::type`` is the same as ``remove_reference<Ref>::type``,
``range_difference<Range>::type`` is the same as ``std::ptrdiff_t``, and
``range_pointer<Range>::type`` is the same as ``add_pointer<remove_reference<Ref>::type>::type``.
As for ``const Range``, see `const Ranges`_.



============
const Ranges
============

``range_reference<const Range>::type`` is defined by the following algorithm.
Let ``Range`` be any type listed above and ``ReF`` be the same as ``range_reference<Range>::type``.


.. parsed-literal::

    if (Range is CObArray || Range is CObList)
        return CObject const \* &
    else if (Range is CPtrArray || Range is CPtrList)
        return void const \* &
    else if (there is a type X such that X& is the same as ReF)
        return X const &
    else if (there is a type X such that X* const is the same as ReF)
        return X const \* const
    else
        return ReF


Other `Boost.Range`_ metafunctions are defined by the following.
``range_value<const Range>::type`` is the same as ``range_value<Range>::type``,
``range_difference<const Range>::type`` is the same as ``std::ptrdiff_t``, and
``range_pointer<const Range>::type`` is the same as ``add_pointer<remove_reference<range_reference<const Range>::type>::type>::type``.



==========
References
==========
- `Boost.Range`_
- `MFC Collections`__
- `ATL Collection Classes`__

__ http://msdn2.microsoft.com/en-us/library/942860sh.aspx
__ http://msdn2.microsoft.com/en-US/library/15e672bd.aspx



.. _Boost C++ Libraries: http://www.boost.org/
.. _Boost: `Boost C++ Libraries`_
.. _Boost.Range: ../index.html
.. _forward: range.html#forward_range
.. _bidirectional: range.html#forward_range
.. _random access: range.html#random_access_range

===================================
 Boost.Python_ Internals |(logo)|__
===================================

.. |(logo)| image:: ../../../boost.png
   :alt: Boost
   :class: boost-logo

__ ../../../index.htm

.. _`Boost.Python`: index.html

.. _license: ../../../LICENSE_1_0.txt


-------------------------------------------------------
A conversation between Brett Calcott and David Abrahams
-------------------------------------------------------

:copyright: Copyright David Abrahams and Brett Calcott 2003. See
            accompanying license_ for terms of use.

In both of these cases, I'm quite capable of reading code - but the
thing I don't get from scanning the source is a sense of the
architecture, both structurally, and temporally (er, I mean in what
order things go on).

1) What happens when you do the following::

     struct boring {};
     ...etc...
     class_<boring>("boring")
         ;

There seems to be a fair bit going on.

 - Python needs a new ClassType to be registered.
 - We need to construct a new type that can hold our boring struct.
 - Inward and outward converters need to be registered for the type.

Can you gesture in the general direction where these things are done?

  I only have time for a "off-the-top-of-my-head" answer at the moment;
  I suggest you step through the code with a debugger after reading this
  to see how it works, fill in details, and make sure I didn't forget
  anything.

          A new (Python) subclass of Boost.Python.Instance (see
          libs/python/src/object/class.cpp) is created by invoking
          Boost.Python.class, the metatype::

                >>> boring = Boost.Python.class(
                ...     'boring'
                ...   , bases_tuple       # in this case, just ()
                ...   , { 
                ...         '__module__' : module_name
                ...       , '__doc__' : doc_string # optional
                ...     }
                ... )

          A handle to this object is stuck in the m_class_object field
          of the registration associated with ``typeid(boring)``.  The
          registry will keep that object alive forever, even if you
          wipe out the 'boring' attribute of the extension module
          (probably not a good thing).

          Because you didn't specify ``class<boring, non_copyable,
          ...>``, a to-python converter for boring is registered which
          copies its argument into a value_holder held by the the
          Python boring object.

          Because you didn't specify ``class<boring ...>(no_init)``,
          an ``__init__`` function object is added to the class
          dictionary which default-constructs a boring in a
          value_holder (because you didn't specify some smart pointer
          or derived wrapper class as a holder) held by the Python
          boring object.

          ``register_class_from_python`` is used to register a
          from-python converter for ``shared_ptr<boring>``.
          ``boost::shared_ptr``\ s are special among smart pointers
          because their Deleter argument can be made to manage the
          whole Python object, not just the C++ object it contains, no
          matter how the C++ object is held.

          If there were any ``bases<>``, we'd also be registering the
          relationship between these base classes and boring in the
          up/down cast graph (``inheritance.[hpp/cpp]``).

          In earlier versions of the code, we'd be registering lvalue
          from-python converters for the class here, but now
          from-python conversion for wrapped classes is handled as a
          special case, before consulting the registry, if the source
          Python object's metaclass is the Boost.Python metaclass.

          Hmm, that from-python converter probably ought to be handled
          the way class converters are, with no explicit conversions
          registered.

2) Can you give a brief overview of the data structures that are
   present in the registry

        The registry is simple: it's just a map from typeid ->
        registration (see boost/python/converter/registrations.hpp).
        ``lvalue_chain`` and ``rvalue_chain`` are simple endogenous
        linked lists.

        If you want to know more, just ask.

        If you want to know about the cast graph, ask me something specific in
        a separate message.

   and an overview of the process that happens as a type makes its
   way from c++ to python and back again.

  Big subject.  I suggest some background reading: look for relevant
  info in the LLNL progress reports and the messages they link to.
  Also, 

        http://mail.python.org/pipermail/c++-sig/2002-May/001023.html

        http://mail.python.org/pipermail/c++-sig/2002-December/003115.html

        http://aspn.activestate.com/ASPN/Mail/Message/1280898

        http://mail.python.org/pipermail/c++-sig/2002-July/001755.html

  from c++ to python:

       It depends on the type and the call policies in use or, for
       ``call<>(...)``, ``call_method<>(...)``, or ``object(...)``, if
       ``ref`` or ``ptr`` is used.  There are also two basic
       categories to to-python conversion, "return value" conversion
       (for Python->C++ calls) and "argument" conversion (for
       C++->Python calls and explicit ``object()`` conversions).  The
       behavior of these two categories differs subtly in various ways
       whose details I forget at the moment.  You can probably find
       the answers in the above references, and certainly in the code.

       The "default" case is by-value (copying) conversion, which uses
       to_python_value as a to-python converter.

           Since there can sensibly be only one way to convert any type
           to python (disregarding the idea of scoped registries for the
           moment), it makes sense that to-python conversions can be
           handled by specializing a template.  If the type is one of
           the types handled by a built-in conversion
           (builtin_converters.hpp), the corresponding template
           specialization of to_python_value gets used.

           Otherwise, to_python_value uses the ``m_to_python``
           function in the registration for the C++ type.

       Other conversions, like by-reference conversions, are only
       available for wrapped classes, and are requested explicitly by
       using ``ref(...)``, ``ptr(...)``, or by specifying different
       CallPolicies for a call, which can cause a different to-python
       converter to be used.  These conversions are never registered
       anywhere, though they do need to use the registration to find
       the Python class corresponding to the C++ type being referred
       to.  They just build a new Python instance and stick the
       appropriate Holder instance in it.


  from python to C++:

       Once again I think there is a distinction between "return value"
       and "argument" conversions, and I forget exactly what that is.

       What happens depends on whether an lvalue conversion is needed
       (see http://mail.python.org/pipermail/c++-sig/2002-May/001023.html)
       All lvalue conversions are also registered in a type's rvalue
       conversion chain, since when an rvalue will do, an lvalue is
       certainly good enough.

       An lvalue conversion can be done in one step (just get me the
       pointer to the object - it can be ``NULL`` if no conversion is
       possible) while an rvalue conversion requires two steps to
       support wrapped function overloading and multiple converters for
       a given C++ target type: first tell me if a conversion is
       possible, then construct the converted object as a second step.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

``indirect_iterator`` adapts an iterator by applying an
*extra* dereference inside of ``operator*()``. For example, this
iterator adaptor makes it possible to view a container of pointers
(e.g. ``list<foo*>``) as if it were a container of the pointed-to type
(e.g. ``list<foo>``).  ``indirect_iterator`` depends on two
auxiliary traits, ``pointee`` and ``indirect_reference``, to
provide support for underlying iterators whose ``value_type`` is
not an iterator.



.. Copyright David Abrahams 2004. Use, modification and distribution is
.. subject to the Boost Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

In this section we'll further refine the ``node_iter`` class
template we developed in the |fac_tut|_.  If you haven't already
read that material, you should go back now and check it out because
we're going to pick up right where it left off.

.. |fac_tut| replace:: ``iterator_facade`` tutorial
.. _fac_tut: iterator_facade.html#tutorial-example

.. sidebar:: ``node_base*`` really *is* an iterator

   It's not really a very interesting iterator, since ``node_base``
   is an abstract class: a pointer to a ``node_base`` just points
   at some base subobject of an instance of some other class, and
   incrementing a ``node_base*`` moves it past this base subobject
   to who-knows-where?  The most we can do with that incremented
   position is to compare another ``node_base*`` to it.  In other
   words, the original iterator traverses a one-element array.

You probably didn't think of it this way, but the ``node_base*``
object that underlies ``node_iterator`` is itself an iterator,
just like all other pointers.  If we examine that pointer closely
from an iterator perspective, we can see that it has much in common
with the ``node_iterator`` we're building.  First, they share most
of the same associated types (``value_type``, ``reference``,
``pointer``, and ``difference_type``).  Second, even some of the
core functionality is the same: ``operator*`` and ``operator==`` on
the ``node_iterator`` return the result of invoking the same
operations on the underlying pointer, via the ``node_iterator``\ 's
|dereference_and_equal|_).  The only real behavioral difference
between ``node_base*`` and ``node_iterator`` can be observed when
they are incremented: ``node_iterator`` follows the
``m_next`` pointer, while ``node_base*`` just applies an address offset.   

.. |dereference_and_equal| replace:: ``dereference`` and ``equal`` member functions
.. _dereference_and_equal: iterator_facade.html#implementing-the-core-operations

It turns out that the pattern of building an iterator on another
iterator-like type (the ``Base`` [#base]_ type) while modifying
just a few aspects of the underlying type's behavior is an
extremely common one, and it's the pattern addressed by
``iterator_adaptor``.  Using ``iterator_adaptor`` is very much like
using ``iterator_facade``, but because iterator_adaptor tries to
mimic as much of the ``Base`` type's behavior as possible, we
neither have to supply a ``Value`` argument, nor implement any core
behaviors other than ``increment``.  The implementation of
``node_iter`` is thus reduced to::

  template <class Value>
  class node_iter
    : public boost::iterator_adaptor<
          node_iter<Value>                // Derived
        , Value*                          // Base
        , boost::use_default              // Value
        , boost::forward_traversal_tag    // CategoryOrTraversal
      >
  {
   private:
      struct enabler {};  // a private type avoids misuse

   public:
      node_iter()
        : node_iter::iterator_adaptor_(0) {}

      explicit node_iter(Value* p)
        : node_iter::iterator_adaptor_(p) {}

      template <class OtherValue>
      node_iter(
          node_iter<OtherValue> const& other
        , typename boost::enable_if<
              boost::is_convertible<OtherValue*,Value*>
            , enabler
          >::type = enabler()
      )
        : node_iter::iterator_adaptor_(other.base()) {}

   private:
      friend class boost::iterator_core_access;
      void increment() { this->base_reference() = this->base()->next(); }
  };

Note the use of ``node_iter::iterator_adaptor_`` here: because
``iterator_adaptor`` defines a nested ``iterator_adaptor_`` type
that refers to itself, that gives us a convenient way to refer to
the complicated base class type of ``node_iter<Value>``. [Note:
this technique is known not to work with Borland C++ 5.6.4 and
Metrowerks CodeWarrior versions prior to 9.0]

You can see an example program that exercises this version of the
node iterators `here`__.

__ ../example/node_iterator3.cpp

In the case of ``node_iter``, it's not very compelling to pass
``boost::use_default`` as ``iterator_adaptor``\ 's ``Value``
argument; we could have just passed ``node_iter``\ 's ``Value``
along to ``iterator_adaptor``, and that'd even be shorter!  Most
iterator class templates built with ``iterator_adaptor`` are
parameterized on another iterator type, rather than on its
``value_type``.  For example, ``boost::reverse_iterator`` takes an
iterator type argument and reverses its direction of traversal,
since the original iterator and the reversed one have all the same
associated types, ``iterator_adaptor``\ 's delegation of default
types to its ``Base`` saves the implementor of
``boost::reverse_iterator`` from writing:

.. parsed-literal::

   std::iterator_traits<Iterator>::*some-associated-type*

at least four times.  

We urge you to review the documentation and implementations of
|reverse_iterator|_ and the other Boost `specialized iterator
adaptors`__ to get an idea of the sorts of things you can do with
``iterator_adaptor``.  In particular, have a look at
|transform_iterator|_, which is perhaps the most straightforward
adaptor, and also |counting_iterator|_, which demonstrates that
``iterator_adaptor``\ 's ``Base`` type needn't be an iterator.

.. |reverse_iterator| replace:: ``reverse_iterator``
.. _reverse_iterator: reverse_iterator.html

.. |counting_iterator| replace:: ``counting_iterator``
.. _counting_iterator: counting_iterator.html

.. |transform_iterator| replace:: ``transform_iterator``
.. _transform_iterator: transform_iterator.html

__ index.html#specialized-adaptors

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

    using namespace boost;
    int i = 0;

    typedef std::vector< int > element_range_type;
    typedef std::list< int > index_type;

    static const int element_range_size = 10;
    static const int index_size = 4;

    element_range_type elements( element_range_size );
    for(element_range_type::iterator el_it = elements.begin() ; el_it != elements.end() ; ++el_it)
      *el_it = std::distance(elements.begin(), el_it);

    index_type indices( index_size );
    for(index_type::iterator i_it = indices.begin() ; i_it != indices.end() ; ++i_it ) 
      *i_it = element_range_size - index_size + std::distance(indices.begin(), i_it);
    std::reverse( indices.begin(), indices.end() );

    typedef permutation_iterator< element_range_type::iterator, index_type::iterator > permutation_type;
    permutation_type begin = make_permutation_iterator( elements.begin(), indices.begin() );
    permutation_type it = begin;
    permutation_type end = make_permutation_iterator( elements.begin(), indices.end() );

    std::cout << "The original range is : ";
    std::copy( elements.begin(), elements.end(), std::ostream_iterator< int >( std::cout, " " ) );
    std::cout << "\n";

    std::cout << "The reindexing scheme is : ";
    std::copy( indices.begin(), indices.end(), std::ostream_iterator< int >( std::cout, " " ) );
    std::cout << "\n";

    std::cout << "The permutated range is : ";
    std::copy( begin, end, std::ostream_iterator< int >( std::cout, " " ) );
    std::cout << "\n";

    std::cout << "Elements at even indices in the permutation : ";
    it = begin;
    for(i = 0; i < index_size / 2 ; ++i, it+=2 ) std::cout << *it << " ";
    std::cout << "\n";

    std::cout << "Permutation backwards : ";
    it = begin + (index_size);
    assert( it != begin );
    for( ; it-- != begin ; ) std::cout << *it << " ";
    std::cout << "\n";

    std::cout << "Iterate backward with stride 2 : ";
    it = begin + (index_size - 1);
    for(i = 0 ; i < index_size / 2 ; ++i, it-=2 ) std::cout << *it << " ";
    std::cout << "\n";


The output is::

    The original range is : 0 1 2 3 4 5 6 7 8 9 
    The reindexing scheme is : 9 8 7 6 
    The permutated range is : 9 8 7 6 
    Elements at even indices in the permutation : 9 7 
    Permutation backwards : 6 7 8 9 
    Iterate backward with stride 2 : 6 8 


The source code for this example can be found `here`__.

__ ../example/permutation_iter_example.cpp
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Writable Iterator Concept
.........................

A class or built-in type ``X`` models the *Writable Iterator* concept
if, in addition to ``X`` being Copy Constructible, the following
expressions are valid and respect the stated semantics.  Writable
Iterators have an associated *set of value types*.

+---------------------------------------------------------------------+
|Writable Iterator Requirements (in addition to Copy Constructible)   |
+-------------------------+--------------+----------------------------+
|Expression               |Return Type   |Precondition                |
+=========================+==============+============================+
|``*a = o``               |              | pre: The type of ``o``     |
|                         |              | is in the set of           |
|                         |              | value types of ``X``       |
+-------------------------+--------------+----------------------------+
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++
 Zip Iterator
+++++++++++++

:Author: David Abrahams, Thomas Becker
:Contact: dave@boost-consulting.com, thomas@styleadvisor.com
:organization: `Boost Consulting`_, `Zephyr Associates, Inc.`_
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright David Abrahams and Thomas Becker 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

:abstract:

  .. include:: zip_iterator_abstract.rst

.. contents:: Table of Contents

``zip_iterator`` synopsis
...............................

.. include:: zip_iterator_ref.rst
.. include:: make_zip_iterator.rst
.. include:: zip_iterator_eg.rst
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++++
 Permutation Iterator
++++++++++++++++++++++

:Author: Toon Knapen, David Abrahams, Roland Richter, Jeremy Siek
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright Toon Knapen, David Abrahams, Roland Richter, and Jeremy Siek 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu

:abstract:

  .. include:: permutation_iter_abstract.rst

.. contents:: Table of Contents


Introduction
============

.. include:: permutation_iterator_body.rst


Reference
=========

.. include:: permutation_iterator_ref.rst


Example
=======

.. include:: permutation_iterator_eg.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

The following example prints an array of characters in reverse order
using ``reverse_iterator``.

::
    
    char letters_[] = "hello world!";
    const int N = sizeof(letters_)/sizeof(char) - 1;
    typedef char* base_iterator;
    base_iterator letters(letters_);
    std::cout << "original sequence of letters:\t\t\t" << letters_ << std::endl;

    boost::reverse_iterator<base_iterator>
      reverse_letters_first(letters + N),
      reverse_letters_last(letters);

    std::cout << "sequence in reverse order:\t\t\t";
    std::copy(reverse_letters_first, reverse_letters_last,
              std::ostream_iterator<char>(std::cout));
    std::cout << std::endl;

    std::cout << "sequence in double-reversed (normal) order:\t";
    std::copy(boost::make_reverse_iterator(reverse_letters_last),
              boost::make_reverse_iterator(reverse_letters_first),
              std::ostream_iterator<char>(std::cout));
    std::cout << std::endl;



The output is::

    original sequence of letters:                   hello world!
    sequence in reverse order:                      !dlrow olleh
    sequence in double-reversed (normal) order:     hello world!


The source code for this example can be found `here`__.

__ ../example/reverse_iterator_example.cpp
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Interoperable Iterator Concept
..............................

A class or built-in type ``X`` that models Single Pass Iterator is
*interoperable with* a class or built-in type ``Y`` that also models
Single Pass Iterator if the following expressions are valid and
respect the stated semantics. In the tables below, ``x`` is an object
of type ``X``, ``y`` is an object of type ``Y``, ``Distance`` is
``iterator_traits<Y>::difference_type``, and ``n`` represents a
constant object of type ``Distance``.

+-----------+-----------------------+---------------------------------------------------+
|Expression |Return Type            |Assertion/Precondition/Postcondition               |
+===========+=======================+===================================================+
|``y = x``  |``Y``                  |post: ``y == x``                                   |
+-----------+-----------------------+---------------------------------------------------+
|``Y(x)``   |``Y``                  |post: ``Y(x) == x``                                |
+-----------+-----------------------+---------------------------------------------------+
|``x == y`` |convertible to ``bool``|``==`` is an equivalence relation over its domain. |
+-----------+-----------------------+---------------------------------------------------+
|``y == x`` |convertible to ``bool``|``==`` is an equivalence relation over its domain. |
+-----------+-----------------------+---------------------------------------------------+
|``x != y`` |convertible to ``bool``|``bool(a==b) != bool(a!=b)`` over its domain.      |
+-----------+-----------------------+---------------------------------------------------+
|``y != x`` |convertible to ``bool``|``bool(a==b) != bool(a!=b)`` over its domain.      |
+-----------+-----------------------+---------------------------------------------------+

If ``X`` and ``Y`` both model Random Access Traversal Iterator then
the following additional requirements must be met.

+-----------+-----------------------+---------------------+--------------------------------------+
|Expression |Return Type            |Operational Semantics|Assertion/ Precondition               |
+===========+=======================+=====================+======================================+
|``x < y``  |convertible to ``bool``|``y - x > 0``        |``<`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y < x``  |convertible to ``bool``|``x - y > 0``        |``<`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x > y``  |convertible to ``bool``|``y < x``            |``>`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y > x``  |convertible to ``bool``|``x < y``            |``>`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x >= y`` |convertible to ``bool``|``!(x < y)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y >= x`` |convertible to ``bool``|``!(y < x)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x <= y`` |convertible to ``bool``|``!(x > y)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y <= x`` |convertible to ``bool``|``!(y > x)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y - x``  |``Distance``           |``distance(Y(x),y)`` |pre: there exists a value ``n`` of    |
|           |                       |                     |``Distance`` such that ``x + n == y``.|
|           |                       |                     |``y == x + (y - x)``.                 |
+-----------+-----------------------+---------------------+--------------------------------------+ 
|``x - y``  |``Distance``           |``distance(y,Y(x))`` |pre: there exists a value ``n`` of    |
|           |                       |                     |``Distance`` such that ``y + n == x``.|
|           |                       |                     |``x == y + (x - y)``.                 |
+-----------+-----------------------+---------------------+--------------------------------------+
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Examples
........

There are two main types of applications of the ``zip_iterator``. The first
one concerns runtime efficiency: If one has several controlled sequences
of the same length that must be somehow processed, e.g., with the 
``for_each`` algorithm, then it is more efficient to perform just
one parallel-iteration rather than several individual iterations. For an 
example, assume that ``vect_of_doubles`` and ``vect_of_ints``
are two vectors of equal length containing doubles and ints, respectively,
and consider the following two iterations:

::


    std::vector<double>::const_iterator beg1 = vect_of_doubles.begin();
    std::vector<double>::const_iterator end1 = vect_of_doubles.end();
    std::vector<int>::const_iterator beg2 = vect_of_ints.begin();
    std::vector<int>::const_iterator end2 = vect_of_ints.end();

    std::for_each(beg1, end1, func_0());
    std::for_each(beg2, end2, func_1());

These two iterations can now be replaced with a single one as follows:

::


    std::for_each(
      boost::make_zip_iterator(
        boost::make_tuple(beg1, beg2)
        ),
      boost::make_zip_iterator(
        boost::make_tuple(end1, end2)
        ),
      zip_func()
      );

A non-generic implementation of ``zip_func`` could look as follows:

::


      struct zip_func : 
        public std::unary_function<const boost::tuple<const double&, const int&>&, void>
      {
        void operator()(const boost::tuple<const double&, const int&>& t) const
        {
          m_f0(t.get<0>());
          m_f1(t.get<1>());
        }

      private:
        func_0 m_f0;
        func_1 m_f1;
      };

The second important application of the ``zip_iterator`` is as a building block
to make combining iterators. A combining iterator is an iterator
that parallel-iterates over several controlled sequences and, upon
dereferencing, returns the result of applying a functor to the values of the
sequences at the respective positions. This can now be achieved by using the
``zip_iterator`` in conjunction with the ``transform_iterator``. 

Suppose, for example, that you have two vectors of doubles, say 
``vect_1`` and ``vect_2``, and you need to expose to a client
a controlled sequence containing the products of the elements of 
``vect_1`` and ``vect_2``. Rather than placing these products
in a third vector, you can use a combining iterator that calculates the
products on the fly. Let us assume that ``tuple_multiplies`` is a
functor that works like ``std::multiplies``, except that it takes
its two arguments packaged in a tuple. Then the two iterators 
``it_begin`` and ``it_end`` defined below delimit a controlled
sequence containing the products of the elements of ``vect_1`` and
``vect_2``:

::


    typedef boost::tuple<
      std::vector<double>::const_iterator,
      std::vector<double>::const_iterator
      > the_iterator_tuple;

    typedef boost::zip_iterator<
      the_iterator_tuple
      > the_zip_iterator;

    typedef boost::transform_iterator<
      tuple_multiplies<double>,
      the_zip_iterator
      > the_transform_iterator;

    the_transform_iterator it_begin(
      the_zip_iterator(
        the_iterator_tuple(
          vect_1.begin(),
          vect_2.begin()
          )
        ),
      tuple_multiplies<double>()
      );

    the_transform_iterator it_end(
      the_zip_iterator(
        the_iterator_tuple(
          vect_1.end(),
          vect_2.end()
          )
        ),
      tuple_multiplies<double>()
      );
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++
 Iterator Archetype
++++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@styleadvisor.com
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, `Zephyr Associates, Inc.`_
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2004. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

:abstract: The ``iterator_archetype`` class constructs a minimal implementation of
  one of the iterator access concepts and one of the iterator traversal concepts.
  This is used for doing a compile-time check to see if a the type requirements
  of a template are really enough to cover the implementation of the template.
  For further information see the documentation for the |concepts|_ library.

.. |concepts| replace:: ``boost::concept_check``
.. _concepts: ../../concept_check/index.html


.. contents:: Table of Contents

Reference
=========

``iterator_archetype`` Synopsis
...............................

::

    namespace iterator_archetypes
    {
        // Access categories

        typedef /*implementation  defined*/ readable_iterator_t;
        typedef /*implementation  defined*/ writable_iterator_t;
        typedef /*implementation  defined*/ readable_writable_iterator_t;
        typedef /*implementation  defined*/ readable_lvalue_iterator_t;
        typedef /*implementation  defined*/ writable_lvalue_iterator_t;

    }

    template <
        class Value
      , class AccessCategory
      , class TraversalCategory
    >
    class iterator_archetype
    {
        typedef /* see below */ value_type;
        typedef /* see below */ reference;
        typedef /* see below */ pointer;
        typedef /* see below */ difference_type;
        typedef /* see below */ iterator_category;
    };

``Access Category Tags``
........................

The access category types provided correspond to the following
standard iterator access concept combinations:

::

    readable_iterator_t :=
  
      Readable Iterator

    writable_iterator_t :=
  
      Writeable Iterator

    readable_writable_iterator_t :=
  
      Readable Iterator & Writeable Iterator & Swappable Iterator

    readable_lvalue_iterator_t :=
  
      Readable Iterator & Lvalue Iterator

    writeable_lvalue_iterator_t :=
  
      Readable Iterator & Writeable Iterator & Swappable Iterator & Lvalue Iterator

``iterator_archetype`` Requirements
...................................

The ``AccessCategory`` argument must be one of the predefined access
category tags. The ``TraversalCategory`` must be one of the standard
traversal tags. The ``Value`` type must satisfy the requirements of
the iterator concept specified by ``AccessCategory`` and
``TraversalCategory`` as implied by the nested traits types.

``iterator_archetype`` Models
.............................

``iterator_archetype`` models the iterator concepts specified by the
``AccessCategory`` and ``TraversalCategory``
arguments. ``iterator_archetype`` does not model any other access
concepts or any more derived traversal concepts.

``Traits``
..........

The nested trait types are defined as follows:

::

   if (AccessCategory == readable_iterator_t)
     
     value_type = Value
     reference  = Value
     pointer    = Value*

   else if (AccessCategory == writable_iterator_t)
 
     value_type = void
     reference  = void
     pointer    = void

   else if (AccessCategory == readable_writable_iterator_t)
 
     value_type = Value

     reference :=

       A type X that is convertible to Value for which the following
       expression is valid. Given an object x of type X and v of type 
       Value.

       x = v

     pointer    = Value*

   else if (AccessCategory == readable_lvalue_iterator_t)
     
     value_type = Value
     reference  = Value const&
     pointer    = Value const*

   else if (AccessCategory == writable_lvalue_iterator_t)
     
     value_type = Value
     reference  = Value&
     pointer    = Value*

   if ( TraversalCategory is convertible to forward_traversal_tag )

     difference_type := ptrdiff_t

   else
  
     difference_type := unspecified type

   
   iterator_category := 

     A type X satisfying the following two constraints:

        1. X is convertible to X1, and not to any more-derived
           type, where X1 is defined by:

             if (reference is a reference type
                 && TraversalCategory is convertible to forward_traversal_tag)
             {
                 if (TraversalCategory is convertible to random_access_traversal_tag)
                     X1 = random_access_iterator_tag
                 else if (TraversalCategory is convertible to bidirectional_traversal_tag)
                     X1 = bidirectional_iterator_tag
                 else
                     X1 = forward_iterator_tag
             }
             else
             {
                 if (TraversalCategory is convertible to single_pass_traversal_tag
                     && reference != void)
                     X1 = input_iterator_tag
                 else
                     X1 = output_iterator_tag
             }

        2. X is convertible to TraversalCategory

        
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The reverse iterator adaptor iterates through the adapted iterator
range in the opposite direction.






.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.1 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG for TR1.

.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 


While the iterator interface is rich, there is a core subset of the
interface that is necessary for all the functionality.  We have
identified the following core behaviors for iterators:

* dereferencing
* incrementing
* decrementing
* equality comparison
* random-access motion
* distance measurement

In addition to the behaviors listed above, the core interface elements
include the associated types exposed through iterator traits:
``value_type``, ``reference``, ``difference_type``, and
``iterator_category``.

Iterator facade uses the Curiously Recurring Template
Pattern (CRTP) [Cop95]_ so that the user can specify the behavior
of ``iterator_facade`` in a derived class.  Former designs used
policy objects to specify the behavior, but that approach was
discarded for several reasons:

  1. the creation and eventual copying of the policy object may create
     overhead that can be avoided with the current approach.

  2. The policy object approach does not allow for custom constructors
     on the created iterator types, an essential feature if
     ``iterator_facade`` should be used in other library
     implementations.

  3. Without the use of CRTP, the standard requirement that an
     iterator's ``operator++`` returns the iterator type itself
     would mean that all iterators built with the library would
     have to be specializations of ``iterator_facade<...>``, rather
     than something more descriptive like
     ``indirect_iterator<T*>``.  Cumbersome type generator
     metafunctions would be needed to build new parameterized
     iterators, and a separate ``iterator_adaptor`` layer would be
     impossible.

Usage
-----

The user of ``iterator_facade`` derives his iterator class from a
specialization of ``iterator_facade`` and passes the derived
iterator class as ``iterator_facade``\ 's first template parameter.
The order of the other template parameters have been carefully
chosen to take advantage of useful defaults.  For example, when
defining a constant lvalue iterator, the user can pass a
const-qualified version of the iterator's ``value_type`` as
``iterator_facade``\ 's ``Value`` parameter and omit the
``Reference`` parameter which follows.

The derived iterator class must define member functions implementing
the iterator's core behaviors.  The following table describes
expressions which are required to be valid depending on the category
of the derived iterator type.  These member functions are described
briefly below and in more detail in the iterator facade
requirements.

   +------------------------+-------------------------------+
   |Expression              |Effects                        |
   +========================+===============================+
   |``i.dereference()``     |Access the value referred to   |
   +------------------------+-------------------------------+
   |``i.equal(j)``          |Compare for equality with ``j``|
   +------------------------+-------------------------------+
   |``i.increment()``       |Advance by one position        |
   +------------------------+-------------------------------+
   |``i.decrement()``       |Retreat by one position        |
   +------------------------+-------------------------------+
   |``i.advance(n)``        |Advance by ``n`` positions     |
   +------------------------+-------------------------------+
   |``i.distance_to(j)``    |Measure the distance to ``j``  |
   +------------------------+-------------------------------+

.. Should we add a comment that a zero overhead implementation of iterator_facade
   is possible with proper inlining?

In addition to implementing the core interface functions, an iterator
derived from ``iterator_facade`` typically defines several
constructors. To model any of the standard iterator concepts, the
iterator must at least have a copy constructor. Also, if the iterator
type ``X`` is meant to be automatically interoperate with another
iterator type ``Y`` (as with constant and mutable iterators) then
there must be an implicit conversion from ``X`` to ``Y`` or from ``Y``
to ``X`` (but not both), typically implemented as a conversion
constructor. Finally, if the iterator is to model Forward Traversal
Iterator or a more-refined iterator concept, a default constructor is
required.



Iterator Core Access
--------------------

``iterator_facade`` and the operator implementations need to be able
to access the core member functions in the derived class.  Making the
core member functions public would expose an implementation detail to
the user.  The design used here ensures that implementation details do
not appear in the public interface of the derived iterator type.

Preventing direct access to the core member functions has two
advantages.  First, there is no possibility for the user to accidently
use a member function of the iterator when a member of the value_type
was intended.  This has been an issue with smart pointer
implementations in the past.  The second and main advantage is that
library implementers can freely exchange a hand-rolled iterator
implementation for one based on ``iterator_facade`` without fear of
breaking code that was accessing the public core member functions
directly.

In a naive implementation, keeping the derived class' core member
functions private would require it to grant friendship to
``iterator_facade`` and each of the seven operators.  In order to
reduce the burden of limiting access, ``iterator_core_access`` is
provided, a class that acts as a gateway to the core member functions
in the derived iterator class.  The author of the derived class only
needs to grant friendship to ``iterator_core_access`` to make his core
member functions available to the library.

.. This is no long uptodate -thw 
.. Yes it is; I made sure of it! -DWA

``iterator_core_access`` will be typically implemented as an empty
class containing only private static member functions which invoke the
iterator core member functions. There is, however, no need to
standardize the gateway protocol.  Note that even if
``iterator_core_access`` used public member functions it would not
open a safety loophole, as every core member function preserves the
invariants of the iterator.

``operator[]``
--------------

The indexing operator for a generalized iterator presents special
challenges.  A random access iterator's ``operator[]`` is only
required to return something convertible to its ``value_type``.
Requiring that it return an lvalue would rule out currently-legal
random-access iterators which hold the referenced value in a data
member (e.g. |counting|_), because ``*(p+n)`` is a reference
into the temporary iterator ``p+n``, which is destroyed when
``operator[]`` returns.

.. |counting| replace:: ``counting_iterator``

Writable iterators built with ``iterator_facade`` implement the
semantics required by the preferred resolution to `issue 299`_ and
adopted by proposal n1550_: the result of ``p[n]`` is an object
convertible to the iterator's ``value_type``, and ``p[n] = x`` is
equivalent to ``*(p + n) = x`` (Note: This result object may be
implemented as a proxy containing a copy of ``p+n``).  This approach
will work properly for any random-access iterator regardless of the
other details of its implementation.  A user who knows more about
the implementation of her iterator is free to implement an
``operator[]`` that returns an lvalue in the derived iterator
class; it will hide the one supplied by ``iterator_facade`` from
clients of her iterator.

.. _n1550: http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html

.. _`issue 299`: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#299

.. _`operator arrow`:


``operator->``
--------------

The ``reference`` type of a readable iterator (and today's input
iterator) need not in fact be a reference, so long as it is
convertible to the iterator's ``value_type``.  When the ``value_type``
is a class, however, it must still be possible to access members
through ``operator->``.  Therefore, an iterator whose ``reference``
type is not in fact a reference must return a proxy containing a copy
of the referenced value from its ``operator->``.

The return types for ``iterator_facade``\ 's ``operator->`` and
``operator[]`` are not explicitly specified. Instead, those types
are described in terms of a set of requirements, which must be
satisfied by the ``iterator_facade`` implementation.

.. [Cop95] [Coplien, 1995] Coplien, J., Curiously Recurring Template
   Patterns, C++ Report, February 1995, pp. 24-27.

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++++
 Indirect Iterator
+++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: indirect_iterator_abstract.rst

.. contents:: Table of Contents

``indirect_iterator`` synopsis
..............................

.. include:: indirect_iterator_ref.rst
.. include:: indirect_iterator_eg.rst

.. _iterator-category: iterator_facade.html#iterator-category
.. |iterator-category| replace:: *iterator-category*
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Incrementable Iterator Concept
..............................

A class or built-in type ``X`` models the *Incrementable Iterator*
concept if, in addition to ``X`` being Assignable and Copy
Constructible, the following expressions are valid and respect the
stated semantics.


+-------------------------------------------------------------------------------------+
|Incrementable Iterator Requirements (in addition to Assignable, Copy Constructible)  |
|                                                                                     |
+--------------------------------+-------------------------------+--------------------+
|Expression                      |Return Type                    |Assertion/Semantics |
+================================+===============================+====================+
|``++r``                         |``X&``                         |``&r == &++r``      |
+--------------------------------+-------------------------------+--------------------+
|``r++``                         |``X``                          |::                  |
|                                |                               |                    |
|                                |                               | {                  |
|                                |                               |    X tmp = r;      |
|                                |                               |    ++r;            |
|                                |                               |    return tmp;     |
|                                |                               | }                  |
+--------------------------------+-------------------------------+--------------------+
|``iterator_traversal<X>::type`` |Convertible to                 |                    |
|                                |``incrementable_traversal_tag``|                    |
+--------------------------------+-------------------------------+--------------------+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Problem with ``reference`` and old/new iterator category correspondance
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. _N1550: http://www.boost-consulting.com/writing/n1550.html
.. _N1530: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1530.html

:Author: David Abrahams and Jeremy Siek
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu
:Organization: `Boost Consulting`_, Indiana University Bloomington
:date: $Date: 2003-11-17 08:52:29 -0800 (Mon, 17 Nov 2003) $
:Copyright: Copyright David Abrahams, Jeremy Siek 2003. Use, modification and
      distribution is subject to the Boost Software License,
      Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
      at http://www.boost.org/LICENSE_1_0.txt)

.. _`Boost Consulting`: http://www.boost-consulting.com

==============
 Introduction
==============

The new iterator categories are intended to correspond to the old
iterator categories, as specified in a diagram in N1550_. For example,
an iterator categorized as a mutable Forward Iterator under the old
scheme is now a Writable, Lvalue, and Foward Traversal iterator.
However, there is a problem with this correspondance, the new iterator
categories place requirements on the ``iterator_traits<X>::reference``
type whereas the standard iterator requirements say nothing about the
``reference`` type . In particular, the new Readable Iterator
requirements say that the return type of ``*a`` must be
``iterator_traits<X>::reference`` and the Lvalue Iterator requirements
says that ``iterator_traits<X>::reference`` must be ``T&`` or ``const
T&``.


====================
 Proposed Resolution
====================

Change the standard requirements to match the requirements of the new
iterators. (more details to come)


==========
 Rationale
==========

The lack of specification in the standard of the ``reference`` type is
certainly a defect. Without specification, it is entirely useless in a
generic function. The current practice in the community is generally
to assume there are requirements on the ``reference`` type, such as
those proposed in the new iterator categories.

There is some danger in *adding* requirements to existing concepts.
This will mean that some existing iterator types will no longer meet
the iterator requirements. However, we feel that the impact of this is
small enough to warrant going ahead with this change.

An alternative solution would be to leave the standard requirements as
is, and to remove the requirements for the ``reference`` type in the
new iterator concepts. We are not in favor of this approach because it
extends what we see as a defect further into the future.
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Bidirectional Traversal Concept
...............................

A class or built-in type ``X`` models the *Bidirectional Traversal*
concept if, in addition to ``X`` meeting the requirements of Forward
Traversal Iterator, the following expressions are valid and respect
the stated semantics.

+--------------------------------------------------------------------------------------+
|Bidirectional Traversal Iterator Requirements (in addition to Forward Traversal       |
|Iterator)                                                                             |
+--------------------------------+-------------------------------+---------------------+
|Expression                      |Return Type                    |Assertion/Semantics /|
|                                |                               |Pre-/Post-condition  |
+================================+===============================+=====================+
|``--r``                         |``X&``                         |pre: there exists    |
|                                |                               |``s`` such that ``r  |
|                                |                               |== ++s``.  post:     |
|                                |                               |``s`` is             |
|                                |                               |dereferenceable.     |
|                                |                               |``--(++r) == r``.    |
|                                |                               |``--r == --s``       |
|                                |                               |implies ``r ==       |
|                                |                               |s``. ``&r == &--r``. |
+--------------------------------+-------------------------------+---------------------+
|``r--``                         |convertible to ``const X&``    |::                   |
|                                |                               |                     |
|                                |                               | {                   |
|                                |                               |   X tmp = r;        |
|                                |                               |   --r;              |
|                                |                               |   return tmp;       |
|                                |                               | }                   |
+--------------------------------+-------------------------------+---------------------+
|``iterator_traversal<X>::type`` |Convertible to                 |                     |
|                                |``bidirectional_traversal_tag``|                     |
|                                |                               |                     |
+--------------------------------+-------------------------------+---------------------+
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++
 Iterator Concepts
++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@styleadvisor.com
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, `Zephyr Associates, Inc.`_
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2004. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

:abstract:  The iterator concept checking classes provide a mechanism for
  a template to report better error messages when a user instantiates
  the template with a type that does not meet the requirements of
  the template.


For an introduction to using concept checking classes, see
the documentation for the |concepts|_ library.

.. |concepts| replace:: ``boost::concept_check``
.. _concepts: ../../concept_check/index.html


Reference
=========

Iterator Access Concepts
........................

* |Readable|_ 
* |Writable|_ 
* |Swappable|_ 
* |Lvalue|_ 

.. |Readable| replace:: *Readable Iterator*
.. _Readable: ReadableIterator.html

.. |Writable| replace:: *Writable Iterator*
.. _Writable: WritableIterator.html

.. |Swappable| replace:: *Swappable Iterator*
.. _Swappable: SwappableIterator.html

.. |Lvalue| replace:: *Lvalue Iterator*
.. _Lvalue: LvalueIterator.html


Iterator Traversal Concepts
...........................

* |Incrementable|_
* |SinglePass|_
* |Forward|_
* |Bidir|_
* |Random|_


.. |Incrementable| replace:: *Incrementable Iterator*
.. _Incrementable: IncrementableIterator.html

.. |SinglePass| replace:: *Single Pass Iterator*
.. _SinglePass: SinglePassIterator.html

.. |Forward| replace:: *Forward Traversal*
.. _Forward: ForwardTraversal.html

.. |Bidir| replace:: *Bidirectional Traversal*
.. _Bidir: BidirectionalTraversal.html

.. |Random| replace:: *Random Access Traversal*
.. _Random: RandomAccessTraversal.html



``iterator_concepts.hpp`` Synopsis
..................................

::

    namespace boost_concepts {

        // Iterator Access Concepts

        template <typename Iterator>
        class ReadableIteratorConcept;

        template <
            typename Iterator
          , typename ValueType = std::iterator_traits<Iterator>::value_type
        >
        class WritableIteratorConcept;

        template <typename Iterator>
        class SwappableIteratorConcept;

        template <typename Iterator>
        class LvalueIteratorConcept;

        // Iterator Traversal Concepts

        template <typename Iterator>
        class IncrementableIteratorConcept;

        template <typename Iterator>
        class SinglePassIteratorConcept;

        template <typename Iterator>
        class ForwardTraversalConcept;

        template <typename Iterator>
        class BidirectionalTraversalConcept;

        template <typename Iterator>
        class RandomAccessTraversalConcept;

        // Interoperability

        template <typename Iterator, typename ConstIterator>
        class InteroperableIteratorConcept;

    }
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Single Pass Iterator Concept
............................

A class or built-in type ``X`` models the *Single Pass Iterator*
concept if the following expressions are valid and respect the stated
semantics.


+------------------------------------------------------------------------------------------+
|Single Pass Iterator Requirements (in addition to Incrementable Iterator and Equality     |
|Comparable)                                                                               |
+--------------------------------+-----------------------------+---------------------------+
|Expression                      |Return Type                  |Assertion/Semantics /      | 
|                                |                             |Pre-/Post-condition        |
+================================+=============================+===========================+
|``++r``                         |``X&``                       |pre: ``r`` is              |
|                                |                             |dereferenceable; post:     |
|                                |                             |``r`` is dereferenceable or|
|                                |                             |``r`` is past-the-end      |
+--------------------------------+-----------------------------+---------------------------+
|``a == b``                      |convertible to ``bool``      |``==`` is an equivalence   |
|                                |                             |relation over its domain   |
+--------------------------------+-----------------------------+---------------------------+
|``a != b``                      |convertible to ``bool``      |``!(a == b)``              |
+--------------------------------+-----------------------------+---------------------------+
|``iterator_traversal<X>::type`` |Convertible to               |                           |
|                                |``single_pass_traversal_tag``|                           |
+--------------------------------+-----------------------------+---------------------------+
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.2 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG for TR1.

.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

The ``iterator_adaptor`` class template adapts some ``Base`` [#base]_
type to create a new iterator.  Instantiations of ``iterator_adaptor``
are derived from a corresponding instantiation of ``iterator_facade``
and implement the core behaviors in terms of the ``Base`` type. In
essence, ``iterator_adaptor`` merely forwards all operations to an
instance of the ``Base`` type, which it stores as a member.

.. [#base] The term "Base" here does not refer to a base class and is
   not meant to imply the use of derivation. We have followed the lead
   of the standard library, which provides a base() function to access
   the underlying iterator object of a ``reverse_iterator`` adaptor.

The user of ``iterator_adaptor`` creates a class derived from an
instantiation of ``iterator_adaptor`` and then selectively
redefines some of the core member functions described in the
``iterator_facade`` core requirements table. The ``Base`` type need
not meet the full requirements for an iterator; it need only
support the operations used by the core interface functions of
``iterator_adaptor`` that have not been redefined in the user's
derived class.

Several of the template parameters of ``iterator_adaptor`` default
to ``use_default``. This allows the
user to make use of a default parameter even when she wants to
specify a parameter later in the parameter list.  Also, the
defaults for the corresponding associated types are somewhat
complicated, so metaprogramming is required to compute them, and
``use_default`` can help to simplify the implementation.  Finally,
the identity of the ``use_default`` type is not left unspecified
because specification helps to highlight that the ``Reference``
template parameter may not always be identical to the iterator's
``reference`` type, and will keep users from making mistakes based on
that assumption.

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++
 Iterator Facade
++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: iterator_facade_abstract.rst

.. contents:: Table of Contents

Overview
========

.. include:: iterator_facade_body.rst


Reference
=========

.. include:: iterator_facade_ref.rst

.. _counting: counting_iterator.html

Tutorial Example
================

.. include:: iterator_facade_tutorial.rst

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Forward Traversal Concept
.........................

A class or built-in type ``X`` models the *Forward Traversal*
concept if, in addition to ``X`` meeting the requirements of Default
Constructible and Single Pass Iterator, the following expressions are
valid and respect the stated semantics.

+--------------------------------------------------------------------------------------------------------+
|Forward Traversal Iterator Requirements (in addition to Default Constructible and Single Pass Iterator) |
+---------------------------------------+-----------------------------------+----------------------------+
|Expression                             |Return Type                        |Assertion/Note              |
+=======================================+===================================+============================+
|``X u;``                               |``X&``                             |note: ``u`` may have a      |
|                                       |                                   |singular value.             |
+---------------------------------------+-----------------------------------+----------------------------+
|``++r``                                |``X&``                             |``r == s`` and ``r`` is     |
|                                       |                                   |dereferenceable implies     |
|                                       |                                   |``++r == ++s.``             |
+---------------------------------------+-----------------------------------+----------------------------+
|``iterator_traits<X>::difference_type``|A signed integral type representing|                            |
|                                       |the distance between iterators     |                            |
|                                       |                                   |                            |
+---------------------------------------+-----------------------------------+----------------------------+
|``iterator_traversal<X>::type``        |Convertible to                     |                            |
|                                       |``forward_traversal_tag``          |                            |
+---------------------------------------+-----------------------------------+----------------------------+
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

    template <class Incrementable>
    counting_iterator<Incrementable> make_counting_iterator(Incrementable x);

:Returns: An instance of ``counting_iterator<Incrementable>``
    with ``current`` constructed from ``x``.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <
      class Iterator
    , class Value = use_default
    , class CategoryOrTraversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class indirect_iterator
  {
   public:
      typedef /* see below */ value_type;
      typedef /* see below */ reference;
      typedef /* see below */ pointer;
      typedef /* see below */ difference_type;
      typedef /* see below */ iterator_category;

      indirect_iterator();
      indirect_iterator(Iterator x);

      template <
          class Iterator2, class Value2, class Category2
        , class Reference2, class Difference2
      >
      indirect_iterator(
          indirect_iterator<
               Iterator2, Value2, Category2, Reference2, Difference2
          > const& y
        , typename enable_if_convertible<Iterator2, Iterator>::type* = 0 // exposition
      );

      Iterator const& base() const;
      reference operator*() const;
      indirect_iterator& operator++();
      indirect_iterator& operator--();
  private:
     Iterator m_iterator; // exposition
  };


The member types of ``indirect_iterator`` are defined according to
the following pseudo-code, where ``V`` is
``iterator_traits<Iterator>::value_type``

.. parsed-literal::

  if (Value is use_default) then
      typedef remove_const<pointee<V>::type>::type value_type;
  else
      typedef remove_const<Value>::type value_type;

  if (Reference is use_default) then
      if (Value is use_default) then
          typedef indirect_reference<V>::type reference;
      else
          typedef Value& reference;
  else
      typedef Reference reference;

  if (Value is use_default) then 
      typedef pointee<V>::type\* pointer;
  else 
      typedef Value\* pointer;

  if (Difference is use_default)
      typedef iterator_traits<Iterator>::difference_type difference_type;
  else
      typedef Difference difference_type;

  if (CategoryOrTraversal is use_default)
      typedef *iterator-category* (
          iterator_traversal<Iterator>::type,``reference``,``value_type``
      ) iterator_category;
  else
      typedef *iterator-category* (
          CategoryOrTraversal,``reference``,``value_type``
      ) iterator_category;


``indirect_iterator`` requirements
..................................

The expression ``*v``, where ``v`` is an object of
``iterator_traits<Iterator>::value_type``, shall be valid
expression and convertible to ``reference``.  ``Iterator`` shall
model the traversal concept indicated by ``iterator_category``.
``Value``, ``Reference``, and ``Difference`` shall be chosen so
that ``value_type``, ``reference``, and ``difference_type`` meet
the requirements indicated by ``iterator_category``.

[Note: there are further requirements on the
``iterator_traits<Iterator>::value_type`` if the ``Value``
parameter is not ``use_default``, as implied by the algorithm for
deducing the default for the ``value_type`` member.]

``indirect_iterator`` models
............................

In addition to the concepts indicated by ``iterator_category``
and by ``iterator_traversal<indirect_iterator>::type``, a
specialization of ``indirect_iterator`` models the following
concepts, Where ``v`` is an object of
``iterator_traits<Iterator>::value_type``:

  * Readable Iterator if ``reference(*v)`` is convertible to
    ``value_type``.
   
  * Writable Iterator if ``reference(*v) = t`` is a valid
    expression (where ``t`` is an object of type
    ``indirect_iterator::value_type``)

  * Lvalue Iterator if ``reference`` is a reference type.

``indirect_iterator<X,V1,C1,R1,D1>`` is interoperable with
``indirect_iterator<Y,V2,C2,R2,D2>`` if and only if ``X`` is
interoperable with ``Y``.


``indirect_iterator`` operations
................................

In addition to the operations required by the concepts described
above, specializations of ``indirect_iterator`` provide the
following operations.


``indirect_iterator();``

:Requires: ``Iterator`` must be Default Constructible.
:Effects: Constructs an instance of ``indirect_iterator`` with 
   a default-constructed ``m_iterator``.


``indirect_iterator(Iterator x);``

:Effects: Constructs an instance of ``indirect_iterator`` with
    ``m_iterator`` copy constructed from ``x``.

::

  template <
      class Iterator2, class Value2, unsigned Access, class Traversal
    , class Reference2, class Difference2
  >
  indirect_iterator(
      indirect_iterator<
           Iterator2, Value2, Access, Traversal, Reference2, Difference2
      > const& y
    , typename enable_if_convertible<Iterator2, Iterator>::type* = 0 // exposition
  );

:Requires: ``Iterator2`` is implicitly convertible to ``Iterator``.
:Effects: Constructs an instance of ``indirect_iterator`` whose 
    ``m_iterator`` subobject is constructed from ``y.base()``.


``Iterator const& base() const;``

:Returns: ``m_iterator``


``reference operator*() const;``

:Returns:  ``**m_iterator``


``indirect_iterator& operator++();``

:Effects: ``++m_iterator``
:Returns: ``*this``


``indirect_iterator& operator--();``

:Effects: ``--m_iterator``
:Returns: ``*this``
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. parsed-literal::

  template< class ElementIterator
	  , class IndexIterator
	  , class ValueT        = use_default
	  , class CategoryT     = use_default
	  , class ReferenceT    = use_default
	  , class DifferenceT   = use_default >
  class permutation_iterator
  {
  public:
    permutation_iterator();
    explicit permutation_iterator(ElementIterator x, IndexIterator y);

    template< class OEIter, class OIIter, class V, class C, class R, class D >
    permutation_iterator(
	permutation_iterator<OEIter, OIIter, V, C, R, D> const& r
	, typename enable_if_convertible<OEIter, ElementIterator>::type* = 0
	, typename enable_if_convertible<OIIter, IndexIterator>::type* = 0
	);
    reference operator*() const;
    permutation_iterator& operator++();
    ElementIterator const& base() const;
  private:
    ElementIterator m_elt;      // exposition only
    IndexIterator m_order;      // exposition only
  };

  template <class ElementIterator, class IndexIterator>
  permutation_iterator<ElementIterator, IndexIterator> 
  make_permutation_iterator( ElementIterator e, IndexIterator i);



``permutation_iterator`` requirements
-------------------------------------

``ElementIterator`` shall model Random Access Traversal Iterator.
``IndexIterator`` shall model Readable Iterator.  The value type of
the ``IndexIterator`` must be convertible to the difference type of
``ElementIterator``.


``permutation_iterator`` models
-------------------------------

``permutation_iterator`` models the same iterator traversal concepts
as ``IndexIterator`` and the same iterator access concepts as
``ElementIterator``.

If ``IndexIterator`` models Single Pass Iterator and 
``ElementIterator`` models Readable Iterator then
``permutation_iterator`` models Input Iterator.

If ``IndexIterator`` models Forward Traversal Iterator and 
``ElementIterator`` models Readable Lvalue Iterator then
``permutation_iterator`` models Forward Iterator.

If ``IndexIterator`` models Bidirectional Traversal Iterator and 
``ElementIterator`` models Readable Lvalue Iterator then
``permutation_iterator`` models Bidirectional Iterator.

If ``IndexIterator`` models Random Access Traversal Iterator and
``ElementIterator`` models Readable Lvalue Iterator then
``permutation_iterator`` models Random Access Iterator.

``permutation_iterator<E1, X, V1, C2, R1, D1>`` is interoperable
with ``permutation_iterator<E2, Y, V2, C2, R2, D2>`` if and only if
``X`` is interoperable with ``Y`` and ``E1`` is convertible
to ``E2``.


``permutation_iterator`` operations
-----------------------------------

In addition to those operations required by the concepts that
``permutation_iterator`` models, ``permutation_iterator`` provides the
following operations.

``permutation_iterator();``

:Effects: Default constructs ``m_elt`` and ``m_order``.


``explicit permutation_iterator(ElementIterator x, IndexIterator y);``

:Effects: Constructs ``m_elt`` from ``x`` and ``m_order`` from ``y``.


::

    template< class OEIter, class OIIter, class V, class C, class R, class D >
    permutation_iterator(
	permutation_iterator<OEIter, OIIter, V, C, R, D> const& r
	, typename enable_if_convertible<OEIter, ElementIterator>::type* = 0
	, typename enable_if_convertible<OIIter, IndexIterator>::type* = 0
	);

:Effects: Constructs ``m_elt`` from ``r.m_elt`` and
  ``m_order`` from ``y.m_order``.


``reference operator*() const;``

:Returns: ``*(m_elt + *m_order)``


``permutation_iterator& operator++();``

:Effects: ``++m_order``
:Returns: ``*this``


``ElementIterator const& base() const;``

:Returns: ``m_order``


::

  template <class ElementIterator, class IndexIterator>
  permutation_iterator<ElementIterator, IndexIterator> 
  make_permutation_iterator(ElementIterator e, IndexIterator i);

:Returns: ``permutation_iterator<ElementIterator, IndexIterator>(e, i)``

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++
 Reverse Iterator
++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: reverse_iterator_abstract.rst

.. contents:: Table of Contents

``reverse_iterator`` synopsis
.............................

.. include:: reverse_iterator_ref.rst
.. include:: make_reverse_iterator.rst

.. include:: reverse_iterator_eg.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Swappable Iterator Concept
..........................

A class or built-in type ``X`` models the *Swappable Iterator* concept
if, in addition to ``X`` being Copy Constructible, the following
expressions are valid and respect the stated semantics.

+---------------------------------------------------------------------+
|Swappable Iterator Requirements (in addition to Copy Constructible)  |
+-------------------------+-------------+-----------------------------+
|Expression               |Return Type  |Postcondition                |
+=========================+=============+=============================+
|``iter_swap(a, b)``      |``void``     |the pointed to values are    |
|                         |             |exchanged                    |
+-------------------------+-------------+-----------------------------+

[*Note:* An iterator that is a model of the *Readable* and *Writable Iterator* concepts
  is also a model of *Swappable Iterator*.  *--end note*]

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++
 Iterator Traits
+++++++++++++++++

:Author: David Abrahams
:Contact: dave@boost-consulting.com
:organization: `Boost Consulting`_
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright David Abrahams 2004. 

.. _`Boost Consulting`: http://www.boost-consulting.com

:abstract: Header ``<boost/iterator/iterator_traits.hpp>`` provides
  the ability to access an iterator's associated types using
  MPL-compatible metafunctions_.

.. _metafunctions: ../../mpl/doc/index.html#metafunctions

Overview
========

``std::iterator_traits`` provides access to five associated types
of any iterator: its ``value_type``, ``reference``, ``pointer``,
``iterator_category``, and ``difference_type``.  Unfortunately,
such a "multi-valued" traits template can be difficult to use in a
metaprogramming context.  ``<boost/iterator/iterator_traits.hpp>``
provides access to these types using a standard metafunctions_.

Summary
=======

Header ``<boost/iterator/iterator_traits.hpp>``::

  template <class Iterator>
  struct iterator_value
  {
      typedef typename 
        std::iterator_traits<Iterator>::value_type 
      type;
  };

  template <class Iterator>
  struct iterator_reference
  {
      typedef typename 
        std::iterator_traits<Iterator>::reference
      type;
  };


  template <class Iterator>
  struct iterator_pointer
  {
      typedef typename 
        std::iterator_traits<Iterator>::pointer 
      type;
  };

  template <class Iterator>
  struct iterator_difference
  {
      typedef typename
        detail::iterator_traits<Iterator>::difference_type
      type;
  };

  template <class Iterator>
  struct iterator_category
  {
      typedef typename
        detail::iterator_traits<Iterator>::iterator_category
      type;
  };

Broken Compiler Notes
=====================

Because of workarounds in Boost, you may find that these
metafunctions_ actually work better than the facilities provided by
your compiler's standard library.

On compilers that don't support partial specialization, such as
Microsoft Visual C++ 6.0 or 7.0, you may need to manually invoke
BOOST_BROKEN_COMPILER_TYPE_TRAITS_SPECIALIZATION_ on the
``value_type`` of pointers that are passed to these metafunctions.

Because of bugs in the implementation of GCC-2.9x, the name of
``iterator_category`` is changed to ``iterator_category_`` on that
compiler.  A macro, ``BOOST_ITERATOR_CATEGORY``, that expands to
either ``iterator_category`` or ``iterator_category_``, as
appropriate to the platform, is provided for portability.

.. _BOOST_BROKEN_COMPILER_TYPE_TRAITS_SPECIALIZATION: ../../type_traits/index.html#transformations

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <
      class Incrementable
    , class CategoryOrTraversal = use_default
    , class Difference = use_default
  >
  class counting_iterator
  {
  public:
      typedef Incrementable value_type;
      typedef const Incrementable& reference;
      typedef const Incrementable* pointer;
      typedef /* see below */ difference_type;
      typedef /* see below */ iterator_category;

      counting_iterator();
      counting_iterator(counting_iterator const& rhs);
      explicit counting_iterator(Incrementable x);
      Incrementable const& base() const;
      reference operator*() const;
      counting_iterator& operator++();
      counting_iterator& operator--();
  private:
      Incrementable m_inc; // exposition
  };


If the ``Difference`` argument is ``use_default`` then
``difference_type`` is an unspecified signed integral
type. Otherwise ``difference_type`` is ``Difference``.

``iterator_category`` is determined according to the following
algorithm:

.. parsed-literal::

   if (CategoryOrTraversal is not use_default)
       return CategoryOrTraversal
   else if (numeric_limits<Incrementable>::is_specialized)
       return |iterator-category|_\ (
           random_access_traversal_tag, Incrementable, const Incrementable&)
   else
       return |iterator-category|_\ (
            iterator_traversal<Incrementable>::type, 
            Incrementable, const Incrementable&)
        
[*Note:* implementers are encouraged to provide an implementation of
  ``operator-`` and a ``difference_type`` that avoids overflows in
  the cases where ``std::numeric_limits<Incrementable>::is_specialized``
  is true.]

``counting_iterator`` requirements
..................................

The ``Incrementable`` argument shall be Copy Constructible and Assignable.

If ``iterator_category`` is convertible to ``forward_iterator_tag``
or ``forward_traversal_tag``, the following must be well-formed::

    Incrementable i, j;
    ++i;         // pre-increment
    i == j;      // operator equal


If ``iterator_category`` is convertible to
``bidirectional_iterator_tag`` or ``bidirectional_traversal_tag``,
the following expression must also be well-formed::

    --i

If ``iterator_category`` is convertible to
``random_access_iterator_tag`` or ``random_access_traversal_tag``,
the following must must also be valid::

    counting_iterator::difference_type n;
    i += n;
    n = i - j;
    i < j;

``counting_iterator`` models
............................

Specializations of ``counting_iterator`` model Readable Lvalue
Iterator. In addition, they model the concepts corresponding to the
iterator tags to which their ``iterator_category`` is convertible.
Also, if ``CategoryOrTraversal`` is not ``use_default`` then
``counting_iterator`` models the concept corresponding to the iterator
tag ``CategoryOrTraversal``.  Otherwise, if
``numeric_limits<Incrementable>::is_specialized``, then
``counting_iterator`` models Random Access Traversal Iterator.
Otherwise, ``counting_iterator`` models the same iterator traversal
concepts modeled by ``Incrementable``.

``counting_iterator<X,C1,D1>`` is interoperable with
``counting_iterator<Y,C2,D2>`` if and only if ``X`` is
interoperable with ``Y``.



``counting_iterator`` operations
................................

In addition to the operations required by the concepts modeled by
``counting_iterator``, ``counting_iterator`` provides the following
operations.


``counting_iterator();``

:Requires: ``Incrementable`` is Default Constructible.
:Effects: Default construct the member ``m_inc``.


``counting_iterator(counting_iterator const& rhs);``

:Effects: Construct member ``m_inc`` from ``rhs.m_inc``.



``explicit counting_iterator(Incrementable x);``

:Effects: Construct member ``m_inc`` from ``x``.


``reference operator*() const;``

:Returns: ``m_inc``


``counting_iterator& operator++();``

:Effects: ``++m_inc``
:Returns: ``*this``


``counting_iterator& operator--();``

:Effects: ``--m_inc``
:Returns: ``*this``  


``Incrementable const& base() const;``

:Returns: ``m_inc``
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++
 Filter Iterator
+++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: filter_iterator_abstract.rst

.. contents:: Table of Contents

``filter_iterator`` synopsis
............................

.. include:: filter_iterator_ref.rst
.. include:: make_filter_iterator.rst

.. include:: filter_iterator_eg.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

    template <class Predicate, class Iterator>
    filter_iterator<Predicate,Iterator>
    make_filter_iterator(Predicate f, Iterator x, Iterator end = Iterator());

:Returns: filter_iterator<Predicate,Iterator>(f, x, end)

::

    template <class Predicate, class Iterator>
    filter_iterator<Predicate,Iterator>
    make_filter_iterator(Iterator x, Iterator end = Iterator());

:Returns: filter_iterator<Predicate,Iterator>(x, end)
++++++++++++++++++++++++++++
 Interoperability Revisited 
++++++++++++++++++++++++++++

:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright Thomas Witt 2004.

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Problem
=======

The current iterator_facade specification makes it unneccessarily tedious to
implement interoperable iterators.

In the following text a simplified example of the current iterator_facade specification is used to
illustrate the problem.

In the current specification binary operators are implemented in the following way::

  template <class Derived>
  struct Facade
  {
  };

  template <class T1, T2>
  struct is_interoperable :
    or_< 
         is_convertible<T1, T2>
       , is_convertible<T2, T1>
    > 
  {};

  template<
      class Derived1
    , class Derived2
  >
  enable_if<is_interoperable<Derived1, Derived2>, bool> operator==(
      Derived1 const& lhs
    , Derived2 const& rhs
  )
  {
    return static_cast<Derived1 const&>(lhs).equal_to(static_cast<Derived2 const&(rhs));
  } 

The problem with this is that operator== always forwards to Derived1::equal_to. The net effect is that the
following "obvious" implementation of to interoperable types does
not quite work. ::

  struct Mutable : Facade<Mutable>
  {
    bool equal_to(Mutable const&);  
  };

  struct Constant : Facade<Constant>
  {
    Constant();
    Constant(Constant const&);
    Constant(Mutable const&);

    ...

    bool equal_to(Constant const&);  
  };

  Constant c;
  Mutable  m;

  c == m; // ok, dispatched to Constant::equal_to
  m == c; // !! error, dispatched to Mutable::equal_to

  Instead the following "slightly" more complicated implementation is necessary

  struct Mutable : Facade<Mutable>
  {
    template <class T>
    enable_if<is_convertible<Mutable, T> || is_convertible<T, Mutable>, bool>::type equal_to(T const&);  
  };

  struct Constant : Tag<Constant>
  {
    Constant();
    Constant(Constant const&);
    Constant(Mutable const&);

    template <class T>
    enable_if<is_convertible<Constant, T> || is_convertible<T, Constant>, bool>::type equal_to(T const&);  
  };

Beside the fact that the code is significantly more complex to understand and to teach there is
a major design problem lurking here. Note that in both types equal_to is a function template with 
an unconstrained argument T. This is necessary so that further types can be made interoperable with
Mutable or Constant. Would Mutable be defined as   ::

  struct Mutable : Facade<Mutable>
  {
    bool equal_to(Mutable const&);  
    bool equal_to(Constant const&);  
  };

Constant and Mutable would still be interoperable but no further interoperable could be added 
without changing Mutable. Even if this would be considered acceptable the current specification forces
a two way dependency between interoperable types. Note in the templated equal_to case this dependency 
is implicitly created when specializing equal_to.

Solution
========

The two way dependency can be avoided by enabling type conversion in the binary operator
implementation. Note that this is the usual way interoperability betwween types is achieved
for binary operators and one reason why binary operators are usually implemented as non-members.

A simple implementation of this strategy would look like this ::

  template<
      class T1
    , class T2
  >
  struct interoperable_base :
      if_< 
          is_convertible<
              T2
            , T1
          >
        , T1
        , T2>
  {};


  template<
      class Derived1
    , class Derived2
  >
  enable_if<is_interoperable<Derived1, Derived2>, bool> operator==(
      Derived1 const& lhs
    , Derived2 const& rhs
  )
  {
    typedef interoperable_base<
                Derived1
              , Derived2
            >::type Base;

    return static_cast<Base const&>(lhs).equal_to(static_cast<Derived2 const&(rhs));
  } 

This way our original simple and "obvious" implementation would
work again. ::

  c == m; // ok, dispatched to Constant::equal_to
  m == c; // ok, dispatched to Constant::equal_to, m converted to Constant

The backdraw of this approach is that a possibly costly conversion of iterator objects
is forced on the user even in cases where direct comparison could be implemented
in a much more efficient way. This problem arises especially for iterator_adaptor
specializations and can be significantly slow down the iteration over ranges. Given the fact
that iteration is a very basic operation this possible performance degradation is not 
acceptable.

Luckily whe can have our cake and eat it by a slightly more clever implementation of the binary 
operators. ::

  template<
      class Derived1
    , class Derived2
  >
  enable_if<is_convertible<Derived2, Derived1>, bool> operator==(
      Derived1 const& lhs
    , Derived2 const& rhs
  )
  {
    return static_cast<Derived1 const&>(lhs).equal_to(static_cast<Derived2 const&(rhs));
  } 

  template<
      class Derived1
    , class Derived2
  >
  enable_if<is_convertible<Derived1, Derived2>, bool> operator==(
      Derived1 const& lhs
    , Derived2 const& rhs
  )
  {
    return static_cast<Derived2 const&>(rhs).equal_to(static_cast<Derived1 const&(lhs));
  } 

Given our simple and obvious definition of Mutable and Constant nothing has changed yet. ::

  c == m; // ok, dispatched to Constant::equal_to, m converted to Constant
  m == c; // ok, dispatched to Constant::equal_to, m converted to Constant

But now the user can avoid the type conversion by supplying the
appropriate overload in Constant :: 

  struct Constant : Facade<Constant>
  {
    Constant();
    Constant(Constant const&);
    Constant(Mutable const&);

    ...

    bool equal_to(Constant const&);  
    bool equal_to(Mutable const&);  
  };

  c == m; // ok, dispatched to Constant::equal_to(Mutable const&), no conversion
  m == c; // ok, dispatched to Constant::equal_to(Mutable const&), no conversion

This definition of operator== introduces a possible ambiguity when both types are convertible
to each other. I don't think this is a problem as this behaviour is the same with concrete types.
I.e.  ::

  struct A {};

  bool operator==(A, A);

  struct B { B(A); }; 

  bool operator==(B, B);

  A a;
  B b(a);

  a == b; // error, ambiguous overload

Effect
======

Iterator implementations using iterator_facade look exactly as if they were
"hand-implemented" (I am working on better wording).

a) Less burden for the user

b) The definition (standardese) of specialized adpters might be easier 
   (This has to be proved yet)
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++++++++++++++
 Iterator Facade and Adaptor
+++++++++++++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@styleadvisor.com
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, `Zephyr Associates, Inc.`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $

:Number: This is a revised version of N1530_\ =03-0113, which was
         accepted for Technical Report 1 by the C++ standard
         committee's library working group.  

.. Version 1.9 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG.

.. _n1530: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1530.html

:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

:abstract: We propose a set of class templates that help programmers
           build standard-conforming iterators, both from scratch and
           by adapting other iterators.

.. contents:: Table of Contents

============
 Motivation
============

Iterators play an important role in modern C++ programming. The
iterator is the central abstraction of the algorithms of the Standard
Library, allowing algorithms to be re-used in in a wide variety of
contexts.  The C++ Standard Library contains a wide variety of useful
iterators. Every one of the standard containers comes with constant
and mutable iterators [#mutable]_, and also reverse versions of those
same iterators which traverse the container in the opposite direction.
The Standard also supplies ``istream_iterator`` and
``ostream_iterator`` for reading from and writing to streams,
``insert_iterator``, ``front_insert_iterator`` and
``back_insert_iterator`` for inserting elements into containers, and
``raw_storage_iterator`` for initializing raw memory [7].

Despite the many iterators supplied by the Standard Library, obvious
and useful iterators are missing, and creating new iterator types is
still a common task for C++ programmers.  The literature documents
several of these, for example line_iterator [3] and Constant_iterator
[9].  The iterator abstraction is so powerful that we expect
programmers will always need to invent new iterator types.

Although it is easy to create iterators that *almost* conform to the
standard, the iterator requirements contain subtleties which can make
creating an iterator which *actually* conforms quite difficult.
Further, the iterator interface is rich, containing many operators
that are technically redundant and tedious to implement.  To automate
the repetitive work of constructing iterators, we propose
``iterator_facade``, an iterator base class template which provides
the rich interface of standard iterators and delegates its
implementation to member functions of the derived class.  In addition
to reducing the amount of code necessary to create an iterator, the
``iterator_facade`` also provides compile-time error detection.
Iterator implementation mistakes that often go unnoticed are turned
into compile-time errors because the derived class implementation must
match the expectations of the ``iterator_facade``.

A common pattern of iterator construction is the adaptation of one
iterator to form a new one.  The functionality of an iterator is
composed of four orthogonal aspects: traversal, indirection, equality
comparison and distance measurement.  Adapting an old iterator to
create a new one often saves work because one can reuse one aspect of
functionality while redefining the other.  For example, the Standard
provides ``reverse_iterator``, which adapts any Bidirectional Iterator
by inverting its direction of traversal.  As with plain iterators,
iterator adaptors defined outside the Standard have become commonplace
in the literature:

* Checked iter[13] adds bounds-checking to an existing iterator.

* The iterators of the View Template Library[14], which adapts
  containers, are themselves adaptors over the underlying iterators.

* Smart iterators [5] adapt an iterator's dereferencing behavior by
  applying a function object to the object being referenced and
  returning the result.

* Custom iterators [4], in which a variety of adaptor types are enumerated.

* Compound iterators [1], which access a slice out of a container of containers.

* Several iterator adaptors from the MTL [12].  The MTL contains a
  strided iterator, where each call to ``operator++()`` moves the
  iterator ahead by some constant factor, and a scaled iterator, which
  multiplies the dereferenced value by some constant.

.. [#concept] We use the term concept to mean a set of requirements
   that a type must satisfy to be used with a particular template
   parameter.

.. [#mutable] The term mutable iterator refers to iterators over objects that
   can be changed by assigning to the dereferenced iterator, while
   constant iterator refers to iterators over objects that cannot be
   modified.

To fulfill the need for constructing adaptors, we propose the
``iterator_adaptor`` class template.  Instantiations of
``iterator_adaptor`` serve as a base classes for new iterators,
providing the default behavior of forwarding all operations to the
underlying iterator.  The user can selectively replace these features
in the derived iterator class.  This proposal also includes a number
of more specialized adaptors, such as the ``transform_iterator`` that
applies some user-specified function during the dereference of the
iterator.

========================
 Impact on the Standard
========================

This proposal is purely an addition to the C++ standard library.
However, note that this proposal relies on the proposal for New
Iterator Concepts.

========
 Design
========

Iterator Concepts
=================

This proposal is formulated in terms of the new ``iterator concepts``
as proposed in n1550_, since user-defined and especially adapted
iterators suffer from the well known categorization problems that are
inherent to the current iterator categories.

.. _n1550: http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/papers/2003/n1550.html

This proposal does not strictly depend on proposal n1550_, as there
is a direct mapping between new and old categories. This proposal
could be reformulated using this mapping if n1550_ was not accepted.

Interoperability
================

The question of iterator interoperability is poorly addressed in the
current standard.  There are currently two defect reports that are
concerned with interoperability issues.

Issue 179_ concerns the fact that mutable container iterator types
are only required to be convertible to the corresponding constant
iterator types, but objects of these types are not required to
interoperate in comparison or subtraction expressions.  This situation
is tedious in practice and out of line with the way built in types
work.  This proposal implements the proposed resolution to issue
179_, as most standard library implementations do nowadays. In other
words, if an iterator type A has an implicit or user defined
conversion to an iterator type B, the iterator types are interoperable
and the usual set of operators are available.

Issue 280_ concerns the current lack of interoperability between
reverse iterator types. The proposed new reverse_iterator template
fixes the issues raised in 280. It provides the desired
interoperability without introducing unwanted overloads.

.. _179: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#179
.. _280: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#280


Iterator Facade
===============

.. include:: iterator_facade_body.rst

Iterator Adaptor
================

.. include:: iterator_adaptor_body.rst

Specialized Adaptors
====================

This proposal also contains several examples of specialized adaptors
which were easily implemented using ``iterator_adaptor``:

* ``indirect_iterator``, which iterates over iterators, pointers,
  or smart pointers and applies an extra level of dereferencing.

* A new ``reverse_iterator``, which inverts the direction of a Base
  iterator's motion, while allowing adapted constant and mutable
  iterators to interact in the expected ways (unlike those in most
  implementations of C++98).

* ``transform_iterator``, which applies a user-defined function object
  to the underlying values when dereferenced.

* ``filter_iterator``, which provides a view of an iterator range in
  which some elements of the underlying range are skipped.

.. _counting: 

* ``counting_iterator``, which adapts any incrementable type
  (e.g. integers, iterators) so that incrementing/decrementing the
  adapted iterator and dereferencing it produces successive values of
  the Base type.

* ``function_output_iterator``, which makes it easier to create custom
  output iterators.

Based on examples in the Boost library, users have generated many new
adaptors, among them a permutation adaptor which applies some
permutation to a random access iterator, and a strided adaptor, which
adapts a random access iterator by multiplying its unit of motion by a
constant factor.  In addition, the Boost Graph Library (BGL) uses
iterator adaptors to adapt other graph libraries, such as LEDA [10]
and Stanford GraphBase [8], to the BGL interface (which requires C++
Standard compliant iterators).

===============
 Proposed Text
===============


Header ``<iterator_helper>`` synopsis    [lib.iterator.helper.synopsis]
=======================================================================


::

  struct use_default;

  struct iterator_core_access { /* implementation detail */ };
  
  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference  = Value&
    , class Difference = ptrdiff_t
  >
  class iterator_facade;

  template <
      class Derived
    , class Base
    , class Value      = use_default
    , class CategoryOrTraversal  = use_default
    , class Reference  = use_default
    , class Difference = use_default
  >
  class iterator_adaptor;
  
  template <
      class Iterator
    , class Value = use_default
    , class CategoryOrTraversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class indirect_iterator;
  
  template <class Dereferenceable>
  struct pointee;

  template <class Dereferenceable>
  struct indirect_reference;

  template <class Iterator>
  class reverse_iterator;

  template <
      class UnaryFunction
    , class Iterator
    , class Reference = use_default
    , class Value = use_default
  >
  class transform_iterator;

  template <class Predicate, class Iterator>
  class filter_iterator;

  template <
      class Incrementable
    , class CategoryOrTraversal  = use_default
    , class Difference = use_default
  >
  class counting_iterator;

  template <class UnaryFunction>
  class function_output_iterator;



Iterator facade [lib.iterator.facade]
=====================================

.. include:: iterator_facade_abstract.rst

Class template ``iterator_facade``
----------------------------------

.. include:: iterator_facade_ref.rst

Iterator adaptor [lib.iterator.adaptor]
=======================================

.. include:: iterator_adaptor_abstract.rst

Class template ``iterator_adaptor``
-----------------------------------

.. include:: iterator_adaptor_ref.rst


Specialized adaptors [lib.iterator.special.adaptors]
====================================================


The ``enable_if_convertible<X,Y>::type`` expression used in
this section is for exposition purposes. The converting constructors
for specialized adaptors should be only be in an overload set provided
that an object of type ``X`` is implicitly convertible to an object of
type ``Y``.  
The signatures involving ``enable_if_convertible`` should behave
*as-if* ``enable_if_convertible`` were defined to be::

  template <bool> enable_if_convertible_impl
  {};

  template <> enable_if_convertible_impl<true>
  { struct type; };

  template<typename From, typename To>
  struct enable_if_convertible
    : enable_if_convertible_impl<is_convertible<From,To>::value>
  {};

If an expression other than the default argument is used to supply
the value of a function parameter whose type is written in terms
of ``enable_if_convertible``, the program is ill-formed, no
diagnostic required.

[*Note:* The ``enable_if_convertible`` approach uses SFINAE to
take the constructor out of the overload set when the types are not
implicitly convertible.  
]


Indirect iterator
-----------------

.. include:: indirect_iterator_abstract.rst

Class template ``pointee``
....................................

.. include:: pointee_ref.rst

Class template ``indirect_reference``
.....................................

.. include:: indirect_reference_ref.rst

Class template ``indirect_iterator``
....................................

.. include:: indirect_iterator_ref.rst

Reverse iterator
----------------

.. include:: reverse_iterator_abstract.rst

Class template ``reverse_iterator``
...................................

.. include:: reverse_iterator_ref.rst


Transform iterator
------------------

.. include:: transform_iterator_abstract.rst

Class template ``transform_iterator``
.....................................

.. include:: transform_iterator_ref.rst


Filter iterator
---------------

.. include:: filter_iterator_abstract.rst


Class template ``filter_iterator``
..................................

.. include:: filter_iterator_ref.rst


Counting iterator
-----------------

.. include:: counting_iterator_abstract.rst

Class template ``counting_iterator``
....................................

.. include:: counting_iterator_ref.rst


Function output iterator
------------------------

.. include:: func_output_iter_abstract.rst

Class template ``function_output_iterator``
...........................................

.. include:: func_output_iter_ref.rst




.. LocalWords:  Abrahams Siek Witt istream ostream iter MTL strided interoperate
   LocalWords:  CRTP metafunctions inlining lvalue JGS incrementable BGL LEDA cv
   LocalWords:  GraphBase struct ptrdiff UnaryFunction const int typename bool pp
   LocalWords:  lhs rhs SFINAE markup iff tmp OtherDerived OtherIterator DWA foo
   LocalWords:  dereferenceable subobject AdaptableUnaryFunction impl pre ifdef'd
   LocalWords:  OtherIncrementable Coplien
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Random Access Traversal Concept
...............................

A class or built-in type ``X`` models the *Random Access Traversal*
concept if the following expressions are valid and respect the stated
semantics.  In the table below, ``Distance`` is
``iterator_traits<X>::difference_type`` and ``n`` represents a
constant object of type ``Distance``.

+------------------------------------------------------------------------------------------------------------------+
|Random Access Traversal Iterator Requirements (in addition to Bidirectional Traversal)                            |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|Expression                     |Return Type                      |Operational Semantics    |Assertion/            |
|                               |                                 |                         |Precondition          |
+===============================+=================================+=========================+======================+
|``r += n``                     |``X&``                           |::                       |                      |
|                               |                                 |                         |                      |
|                               |                                 | {                       |                      |
|                               |                                 |   Distance m = n;       |                      |
|                               |                                 |   if (m >= 0)           |                      |
|                               |                                 |     while (m--)         |                      |
|                               |                                 |       ++r;              |                      |
|                               |                                 |   else                  |                      |
|                               |                                 |     while (m++)         |                      |
|                               |                                 |       --r;              |                      |
|                               |                                 |   return r;             |                      |
|                               |                                 | }                       |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a + n``, ``n + a``           |``X``                            |``{ X tmp = a; return tmp|                      |
|                               |                                 |+= n; }``                |                      |
|                               |                                 |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``r -= n``                     |``X&``                           |``return r += -n``       |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a - n``                      |``X``                            |``{ X tmp = a; return tmp|                      |
|                               |                                 |-= n; }``                |                      |
|                               |                                 |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``b - a``                      |``Distance``                     |``a < b ?  distance(a,b) |pre: there exists a   |
|                               |                                 |: -distance(b,a)``       |value ``n`` of        |
|                               |                                 |                         |``Distance`` such that|
|                               |                                 |                         |``a + n == b``.  ``b  |
|                               |                                 |                         |== a + (b - a)``.     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a[n]``                       |convertible to T                 |``*(a + n)``             |pre: a is a *Readable |
|                               |                                 |                         |Iterator*             |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a[n] = v``                   |convertible to T                 |``*(a + n) = v``         |pre: a is a *Writable |
|                               |                                 |                         |iterator*             |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a < b``                      |convertible to ``bool``          |``b - a > 0``            |``<`` is a total      |
|                               |                                 |                         |ordering relation     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a > b``                      |convertible to ``bool``          |``b < a``                |``>`` is a total      |
|                               |                                 |                         |ordering relation     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a >= b``                     |convertible to ``bool``          |``!(a < b)``             |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a <= b``                     |convertible to ``bool``          |``!(a > b)``             |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``iterator_traversal<X>::type``|Convertible to                   |                         |                      |
|                               |``random_access_traversal_tag``  |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++++
 New Iterator Concepts
++++++++++++++++++++++

.. Version 1.25 of this ReStructuredText document is the same as
   n1550_, the paper accepted by the LWG.

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@styleadvisor.com
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, `Zephyr Associates, Inc.`_
:date: $Date: 2007-11-25 10:38:02 -0800 (Sun, 25 Nov 2007) $

:Number: This is a revised version of n1550_\ =03-0133, which was
         accepted for Technical Report 1 by the C++ standard
         committee's library working group. This proposal is a
         revision of paper n1297_, n1477_, and n1531_.

:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt
         2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

.. _`Institute for Transport Railway Operation and Construction`:
   http://www.ive.uni-hannover.de 

:Abstract: We propose a new system of iterator concepts that treat
           access and positioning independently. This allows the
           concepts to more closely match the requirements
           of algorithms and provides better categorizations
           of iterators that are used in practice. 
          
.. contents:: Table of Contents

.. _n1297: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1297.html
.. _n1477: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1477.html
.. _n1531: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1531.html
.. _n1550: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1550.html

============
 Motivation
============

The standard iterator categories and requirements are flawed because
they use a single hierarchy of concepts to address two orthogonal
issues: *iterator traversal* and *value access*. As a result, many
algorithms with requirements expressed in terms of the iterator
categories are too strict. Also, many real-world iterators can not be
accurately categorized.  A proxy-based iterator with random-access
traversal, for example, may only legally have a category of "input
iterator", so generic algorithms are unable to take advantage of its
random-access capabilities.  The current iterator concept hierarchy is
geared towards iterator traversal (hence the category names), while
requirements that address value access sneak in at various places. The
following table gives a summary of the current value access
requirements in the iterator categories.

+------------------------------------------------------------------------------+
|Value Access Requirements in Existing Iterator Categories                     |
+========================+=====================================================+
|Output Iterator         |``*i = a``                                           |
+------------------------+-----------------------------------------------------+
|Input Iterator          |``*i`` is convertible to ``T``                       |
+------------------------+-----------------------------------------------------+
|Forward Iterator        |``*i`` is ``T&`` (or ``const T&`` once `issue 200`_  |
|                        |is resolved)                                         |
+------------------------+-----------------------------------------------------+
|Random Access Iterator  |``i[n]`` is convertible to ``T`` (also ``i[n] = t``  |
|                        |is required for mutable iterators once `issue 299`_  |
|                        |is resolved)                                         |
+------------------------+-----------------------------------------------------+

.. _issue 200: http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#200
.. _issue 299: http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#299


Because iterator traversal and value access are mixed together in a
single hierarchy, many useful iterators can not be appropriately
categorized. For example, ``vector<bool>::iterator`` is almost a
random access iterator, but the return type is not ``bool&`` (see
`issue 96`_ and Herb Sutter's paper J16/99-0008 = WG21
N1185). Therefore, the iterators of ``vector<bool>`` only meet the
requirements of input iterator and output iterator.  This is so
nonintuitive that the C++ standard contradicts itself on this point.
In paragraph 23.2.4/1 it says that a ``vector`` is a sequence that
supports random access iterators.

.. _issue 96: http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-active.html#96

Another difficult-to-categorize iterator is the transform iterator, an
adaptor which applies a unary function object to the dereferenced
value of the some underlying iterator (see `transform_iterator`_).
For unary functions such as ``times``, the return type of
``operator*`` clearly needs to be the ``result_type`` of the function
object, which is typically not a reference.  Because random access
iterators are required to return lvalues from ``operator*``, if you
wrap ``int*`` with a transform iterator, you do not get a random
access iterator as might be expected, but an input iterator.

.. _`transform_iterator`: http://www.boost.org/libs/utility/transform_iterator.htm

A third example is found in the vertex and edge iterators of the
`Boost Graph Library`_. These iterators return vertex and edge
descriptors, which are lightweight handles created on-the-fly. They
must be returned by-value. As a result, their current standard
iterator category is ``input_iterator_tag``, which means that,
strictly speaking, you could not use these iterators with algorithms
like ``min_element()``. As a temporary solution, the concept
`Multi-Pass Input Iterator`_ was introduced to describe the vertex and
edge descriptors, but as the design notes for the concept suggest, a
better solution is needed.

.. _Boost Graph Library: http://www.boost.org/libs/graph/doc/table_of_contents.html
.. _Multi-Pass Input Iterator: http://www.boost.org/libs/utility/MultiPassInputIterator.html

In short, there are many useful iterators that do not fit into the
current standard iterator categories. As a result, the following bad
things happen:

- Iterators are often mis-categorized. 

- Algorithm requirements are more strict than necessary, because they
  cannot separate the need for random access or bidirectional
  traversal from the need for a true reference return type.


========================
 Impact on the Standard
========================

This proposal for TR1 is a pure extension. Further, the new iterator
concepts are backward-compatible with the old iterator requirements,
and old iterators are forward-compatible with the new iterator
concepts. That is to say, iterators that satisfy the old requirements
also satisfy appropriate concepts in the new system, and iterators
modeling the new concepts will automatically satisfy the appropriate
old requirements.

.. I think we need to say something about the resolution to allow
   convertibility to any of the old-style tags as a TR issue (hope it
   made it). -DWA

.. Hmm, not sure I understand. Are you talking about whether a
   standards conforming input iterator is allowed to have
   a tag that is not input_iterator_tag but that
   is convertible to input_iterator_tag? -JGS

Possible (but not proposed) Changes to the Working Paper
========================================================

The extensions in this paper suggest several changes we might make
to the working paper for the next standard.  These changes are not
a formal part of this proposal for TR1.

Changes to Algorithm Requirements
+++++++++++++++++++++++++++++++++

The algorithms in the standard library could benefit from the new
iterator concepts because the new concepts provide a more accurate way
to express their type requirements. The result is algorithms that are
usable in more situations and have fewer type requirements.

For the next working paper (but not for TR1), the committee should
consider the following changes to the type requirements of algorithms.
These changes are phrased as textual substitutions, listing the
algorithms to which each textual substitution applies.

Forward Iterator -> Forward Traversal Iterator and Readable Iterator

  ``find_end, adjacent_find, search, search_n, rotate_copy,
  lower_bound, upper_bound, equal_range, binary_search,
  min_element, max_element``

Forward Iterator (1) -> Single Pass Iterator and Readable Iterator,
Forward Iterator (2) -> Forward Traversal Iterator and Readable Iterator

  ``find_first_of``

Forward Iterator -> Readable Iterator and Writable Iterator

  ``iter_swap``

Forward Iterator -> Single Pass Iterator and Writable Iterator

  ``fill, generate``

Forward Iterator -> Forward Traversal Iterator and Swappable Iterator

  ``rotate``

Forward Iterator (1) -> Swappable Iterator and Single Pass Iterator,
Forward Iterator (2) -> Swappable Iterator and  Incrementable Iterator

  ``swap_ranges``

Forward Iterator -> Forward Traversal Iterator and Readable Iterator and Writable Iterator
  ``remove, remove_if, unique``

Forward Iterator -> Single Pass Iterator and Readable Iterator and Writable Iterator

  ``replace, replace_if``

Bidirectional Iterator -> Bidirectional Traversal Iterator and Swappable Iterator
  ``reverse``

Bidirectional Iterator -> Bidirectional Traversal Iterator and Readable and Swappable Iterator
  ``partition``

Bidirectional Iterator (1) -> Bidirectional Traversal Iterator and Readable Iterator, 
Bidirectional Iterator (2) -> Bidirectional Traversal Iterator and Writable Iterator

  ``copy_backwards``

Bidirectional Iterator -> Bidirectional Traversal Iterator and Swappable Iterator and Readable Iterator
  ``next_permutation, prev_permutation``

Bidirectional Iterator -> Bidirectional Traversal Iterator and Readable Iterator and Writable Iterator
  ``stable_partition, inplace_merge``

Bidirectional Iterator -> Bidirectional Traversal Iterator and Readable Iterator
  ``reverse_copy``

Random Access Iterator -> Random Access Traversal Iterator and Readable and Writable Iterator
  ``random_shuffle, sort, stable_sort, partial_sort, nth_element, push_heap, pop_heap
  make_heap, sort_heap``

Input Iterator (2) -> Incrementable Iterator and Readable Iterator
  ``equal, mismatch``

Input Iterator (2) -> Incrementable Iterator and Readable Iterator
  ``transform``

Deprecations
++++++++++++

For the next working paper (but not for TR1), the committee should
consider deprecating the old iterator tags, and
std::iterator_traits, since it will be superceded by individual
traits metafunctions.

``vector<bool>``
++++++++++++++++

For the next working paper (but not for TR1), the committee should
consider reclassifying ``vector<bool>::iterator`` as a Random
Access Traversal Iterator and Readable Iterator and Writable
Iterator.

========
 Design
========

The iterator requirements are to be separated into two groups. One set
of concepts handles the syntax and semantics of value access:

- Readable Iterator
- Writable Iterator
- Swappable Iterator
- Lvalue Iterator

The access concepts describe requirements related to ``operator*`` and
``operator->``, including the ``value_type``, ``reference``, and
``pointer`` associated types.

The other set of concepts handles traversal:

- Incrementable Iterator
- Single Pass Iterator
- Forward Traversal Iterator
- Bidirectional Traversal Iterator
- Random Access Traversal Iterator

The refinement relationships for the traversal concepts are in the
following diagram.

.. image:: traversal.png

In addition to the iterator movement operators, such as
``operator++``, the traversal concepts also include requirements on
position comparison such as ``operator==`` and ``operator<``.  The
reason for the fine grain slicing of the concepts into the
Incrementable and Single Pass is to provide concepts that are exact
matches with the original input and output iterator requirements.

This proposal also includes a concept for specifying when an iterator
is interoperable with another iterator, in the sense that ``int*`` is
interoperable with ``int const*``.

- Interoperable Iterators


The relationship between the new iterator concepts and the old are
given in the following diagram.

.. image:: oldeqnew.png

Like the old iterator requirements, we provide tags for purposes of
dispatching based on the traversal concepts.  The tags are related via
inheritance so that a tag is convertible to another tag if the concept
associated with the first tag is a refinement of the second tag.

Our design reuses ``iterator_traits<Iter>::iterator_category`` to
indicate an iterator's traversal capability.  To specify
capabilities not captured by any old-style iterator category, an
iterator designer can use an ``iterator_category`` type that is
convertible to both the the most-derived old iterator category tag
which fits, and the appropriate new iterator traversal tag.

.. dwa2003/1/2: Note that we are not *requiring* convertibility to
   a new-style traversal tag in order to meet new concepts.
   Old-style iterators still fit, after all.

We do not provide tags for the purposes of dispatching based on the
access concepts, in part because we could not find a way to
automatically infer the right access tags for old-style iterators.
An iterator's writability may be dependent on the assignability of
its ``value_type`` and there's no known way to detect whether an
arbitrary type is assignable.  Fortunately, the need for
dispatching based on access capability is not as great as the need
for dispatching based on traversal capability.

A difficult design decision concerned the ``operator[]``. The direct
approach for specifying ``operator[]`` would have a return type of
``reference``; the same as ``operator*``. However, going in this
direction would mean that an iterator satisfying the old Random Access
Iterator requirements would not necessarily be a model of Readable or
Writable Lvalue Iterator.  Instead we have chosen a design that
matches the preferred resolution of `issue 299`_: ``operator[]`` is
only required to return something convertible to the ``value_type``
(for a Readable Iterator), and is required to support assignment
``i[n] = t`` (for a Writable Iterator).


===============
 Proposed Text
===============

Addition to [lib.iterator.requirements]
=======================================

Iterator Value Access Concepts [lib.iterator.value.access]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In the tables below, ``X`` is an iterator type, ``a`` is a constant
object of type ``X``, ``R`` is
``std::iterator_traits<X>::reference``, ``T`` is
``std::iterator_traits<X>::value_type``, and ``v`` is a constant
object of type ``T``.

.. _Readable Iterator:

Readable Iterators [lib.readable.iterators]
-------------------------------------------

A class or built-in type ``X`` models the *Readable Iterator* concept
for value type ``T`` if, in addition to ``X`` being Assignable and
Copy Constructible, the following expressions are valid and respect
the stated semantics. ``U`` is the type of any specified member of
type ``T``.

+-----------------------------------------------------------------------------------------------------------------------------+
|Readable Iterator Requirements (in addition to Assignable and Copy Constructible)                                            |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|Expression                         |Return Type             |Note/Precondition                                               |
+===================================+========================+================================================================+
|``iterator_traits<X>::value_type`` |``T``                   |Any non-reference,                                              |
|                                   |                        |non-cv-qualified type                                           |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|``*a``                             | Convertible to ``T``   |pre: ``a`` is dereferenceable. If ``a == b`` then ``*a``        |
|                                   |                        | is equivalent to ``*b``.                                       |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|``a->m``                           |``U&``                  |pre: ``pre: (*a).m`` is well-defined. Equivalent to ``(*a).m``. |
+-----------------------------------+------------------------+----------------------------------------------------------------+

.. We won't say anything about iterator_traits<X>::reference until the DR is resolved. -JGS

.. _Writable Iterator:

Writable Iterators [lib.writable.iterators]
-------------------------------------------

A class or built-in type ``X`` models the *Writable Iterator* concept
if, in addition to ``X`` being Copy Constructible, the following
expressions are valid and respect the stated semantics.  Writable
Iterators have an associated *set of value types*.

+---------------------------------------------------------------------+
|Writable Iterator Requirements (in addition to Copy Constructible)   |
+-------------------------+--------------+----------------------------+
|Expression               |Return Type   |Precondition                |
+=========================+==============+============================+
|``*a = o``               |              | pre: The type of ``o``     |
|                         |              | is in the set of           |
|                         |              | value types of ``X``       |
+-------------------------+--------------+----------------------------+

Swappable Iterators [lib.swappable.iterators]
---------------------------------------------

A class or built-in type ``X`` models the *Swappable Iterator* concept
if, in addition to ``X`` being Copy Constructible, the following
expressions are valid and respect the stated semantics.

+---------------------------------------------------------------------+
|Swappable Iterator Requirements (in addition to Copy Constructible)  |
+-------------------------+-------------+-----------------------------+
|Expression               |Return Type  |Postcondition                |
+=========================+=============+=============================+
|``iter_swap(a, b)``      |``void``     |the pointed to values are    |
|                         |             |exchanged                    |
+-------------------------+-------------+-----------------------------+

[*Note:* An iterator that is a model of the `Readable Iterator`_ and
`Writable Iterator`_ concepts is also a model of *Swappable
Iterator*.  *--end note*]


Lvalue Iterators [lib.lvalue.iterators]
---------------------------------------

The *Lvalue Iterator* concept adds the requirement that the return
type of ``operator*`` type be a reference to the value type of the
iterator.  

+-------------------------------------------------------------+
| Lvalue Iterator Requirements                                |
+-------------+-----------+-----------------------------------+
|Expression   |Return Type|Note/Assertion                     |
+=============+===========+===================================+
|``*a``       | ``T&``    |``T`` is *cv*                      |
|             |           |``iterator_traits<X>::value_type`` |
|             |           |where *cv* is an optional          |
|             |           |cv-qualification.  pre: ``a`` is   |
|             |           |dereferenceable.                   |
+-------------+-----------+-----------------------------------+

If ``X`` is a `Writable Iterator`_ then ``a == b`` if and only if
``*a`` is the same object as ``*b``.  If ``X`` is a `Readable
Iterator`_ then ``a == b`` implies ``*a`` is the same object as
``*b``.


Iterator Traversal Concepts [lib.iterator.traversal]
++++++++++++++++++++++++++++++++++++++++++++++++++++

In the tables below, ``X`` is an iterator type, ``a`` and ``b`` are
constant objects of type ``X``, ``r`` and ``s`` are mutable objects of
type ``X``, ``T`` is ``std::iterator_traits<X>::value_type``, and
``v`` is a constant object of type ``T``.

Incrementable Iterators [lib.incrementable.iterators]
-----------------------------------------------------

A class or built-in type ``X`` models the *Incrementable Iterator*
concept if, in addition to ``X`` being Assignable and Copy
Constructible, the following expressions are valid and respect the
stated semantics.

+------------------------------------------------------------------------------------+
|Incrementable Iterator Requirements (in addition to Assignable, Copy Constructible) |
|                                                                                    |
+--------------------------------+-------------------------------+-------------------+
|Expression                      |Return Type                    |Assertion          |
+================================+===============================+===================+
|``++r``                         |``X&``                         |``&r == &++r``     |
+--------------------------------+-------------------------------+-------------------+
|``r++``                         |                               |                   |
+--------------------------------+-------------------------------+-------------------+
|``*r++``                        |                               |                   |
+--------------------------------+-------------------------------+-------------------+
|``iterator_traversal<X>::type`` |Convertible to                 |                   |
|                                |``incrementable_traversal_tag``|                   |
+--------------------------------+-------------------------------+-------------------+


If ``X`` is a `Writable Iterator`_ then ``X a(r++);`` is equivalent
to ``X a(r); ++r;`` and ``*r++ = o`` is equivalent
to  ``*r = o; ++r``.
If ``X`` is a `Readable Iterator`_ then ``T z(*r++);`` is equivalent
to ``T z(*r); ++r;``. 

.. TR1: incrementable_iterator_tag changed to
   incrementable_traversal_tag for consistency.

Single Pass Iterators [lib.single.pass.iterators]
-------------------------------------------------

A class or built-in type ``X`` models the *Single Pass Iterator*
concept if the following expressions are valid and respect the stated
semantics.


+----------------------------------------------------------------------------------------------------------------+
|Single Pass Iterator Requirements (in addition to Incrementable Iterator and Equality Comparable)               |
|                                                                                                                |
+----------------------------------------+-----------------------------+-------------+---------------------------+
|Expression                              |Return Type                  | Operational |Assertion/                 | 
|                                        |                             | Semantics   |Pre-/Post-condition        |
+========================================+=============================+=============+===========================+
|``++r``                                 |``X&``                       |             |pre: ``r`` is              |
|                                        |                             |             |dereferenceable; post:     |
|                                        |                             |             |``r`` is dereferenceable or|
|                                        |                             |             |``r`` is past-the-end      |
+----------------------------------------+-----------------------------+-------------+---------------------------+
|``a == b``                              |convertible to ``bool``      |             |``==`` is an equivalence   |
|                                        |                             |             |relation over its domain   |
+----------------------------------------+-----------------------------+-------------+---------------------------+
|``a != b``                              |convertible to ``bool``      |``!(a == b)``|                           |
+----------------------------------------+-----------------------------+-------------+---------------------------+
|``iterator_traits<X>::difference_type`` |A signed integral type       |             |                           |
|                                        |representing the distance    |             |                           |
|                                        |between iterators            |             |                           |
+----------------------------------------+-----------------------------+-------------+---------------------------+
|``iterator_traversal<X>::type``         |Convertible to               |             |                           |
|                                        |``single_pass_traversal_tag``|             |                           |
+----------------------------------------+-----------------------------+-------------+---------------------------+

.. TR1: single_pass_iterator_tag changed to
   single_pass_traversal_tag for consistency


Forward Traversal Iterators [lib.forward.traversal.iterators]
-------------------------------------------------------------

A class or built-in type ``X`` models the *Forward Traversal Iterator*
concept if, in addition to ``X`` meeting the requirements of Default
Constructible and Single Pass Iterator, the following expressions are
valid and respect the stated semantics. 

+--------------------------------------------------------------------------------------------------------+
|Forward Traversal Iterator Requirements (in addition to Default Constructible and Single Pass Iterator) |
+---------------------------------------+-----------------------------------+----------------------------+
|Expression                             |Return Type                        |Assertion/Note              |
+=======================================+===================================+============================+
|``X u;``                               |``X&``                             |note: ``u`` may have a      |
|                                       |                                   |singular value.             |
+---------------------------------------+-----------------------------------+----------------------------+
|``++r``                                |``X&``                             |``r == s`` and ``r`` is     |
|                                       |                                   |dereferenceable implies     |
|                                       |                                   |``++r == ++s.``             |
+---------------------------------------+-----------------------------------+----------------------------+
|``iterator_traversal<X>::type``        |Convertible to                     |                            |
|                                       |``forward_traversal_tag``          |                            |
+---------------------------------------+-----------------------------------+----------------------------+



.. TR1: forward_traversal_iterator_tag changed to
   forward_traversal_tag for consistency


Bidirectional Traversal Iterators [lib.bidirectional.traversal.iterators]
-------------------------------------------------------------------------

A class or built-in type ``X`` models the *Bidirectional Traversal
Iterator* concept if, in addition to ``X`` meeting the requirements of
Forward Traversal Iterator, the following expressions are valid and
respect the stated semantics.

+-----------------------------------------------------------------------------------------------------+
|Bidirectional Traversal Iterator Requirements (in addition to Forward Traversal                      |
|Iterator)                                                                                            |
+--------------------------------+-------------------------------+--------------+---------------------+
|Expression                      |Return Type                    |  Operational |Assertion/           |
|                                |                               |  Semantics   |Pre-/Post-condition  |
+================================+===============================+==============+=====================+
|``--r``                         |``X&``                         |              |pre: there exists    |
|                                |                               |              |``s`` such that ``r  |
|                                |                               |              |== ++s``.  post:     |
|                                |                               |              |``s`` is             |
|                                |                               |              |dereferenceable.     |
|                                |                               |              |                     |
|                                |                               |              |``++(--r) == r``.    |
|                                |                               |              |``--r == --s``       |
|                                |                               |              |implies ``r ==       |
|                                |                               |              |s``. ``&r == &--r``. |
+--------------------------------+-------------------------------+--------------+---------------------+
|``r--``                         |convertible to ``const X&``    |::            |                     |
|                                |                               |              |                     |
|                                |                               | {            |                     |
|                                |                               |   X tmp = r; |                     |
|                                |                               |   --r;       |                     |
|                                |                               |   return tmp;|                     |
|                                |                               | }            |                     |
+--------------------------------+-------------------------------+--------------+---------------------+
|``iterator_traversal<X>::type`` |Convertible to                 |              |                     |
|                                |``bidirectional_traversal_tag``|              |                     |
|                                |                               |              |                     |
+--------------------------------+-------------------------------+--------------+---------------------+

.. TR1: bidirectional_traversal_iterator_tag changed to
   bidirectional_traversal_tag for consistency

Random Access Traversal Iterators [lib.random.access.traversal.iterators]
-------------------------------------------------------------------------

A class or built-in type ``X`` models the *Random Access Traversal
Iterator* concept if the following expressions are valid and respect
the stated semantics.  In the table below, ``Distance`` is
``iterator_traits<X>::difference_type`` and ``n`` represents a
constant object of type ``Distance``.

+------------------------------------------------------------------------------------------------------------------+
|Random Access Traversal Iterator Requirements (in addition to Bidirectional Traversal Iterator)                   |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|Expression                     |Return Type                      |Operational Semantics    |Assertion/            |
|                               |                                 |                         |Precondition          |
+===============================+=================================+=========================+======================+
|``r += n``                     |``X&``                           |::                       |                      |
|                               |                                 |                         |                      |
|                               |                                 | {                       |                      |
|                               |                                 |   Distance m = n;       |                      |
|                               |                                 |   if (m >= 0)           |                      |
|                               |                                 |     while (m--)         |                      |
|                               |                                 |       ++r;              |                      |
|                               |                                 |   else                  |                      |
|                               |                                 |     while (m++)         |                      |
|                               |                                 |       --r;              |                      |
|                               |                                 |   return r;             |                      |
|                               |                                 | }                       |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a + n``, ``n + a``           |``X``                            |``{ X tmp = a; return tmp|                      |
|                               |                                 |+= n; }``                |                      |
|                               |                                 |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``r -= n``                     |``X&``                           |``return r += -n``       |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a - n``                      |``X``                            |``{ X tmp = a; return tmp|                      |
|                               |                                 |-= n; }``                |                      |
|                               |                                 |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``b - a``                      |``Distance``                     |``a < b ?  distance(a,b) |pre: there exists a   |
|                               |                                 |: -distance(b,a)``       |value ``n`` of        |
|                               |                                 |                         |``Distance`` such that|
|                               |                                 |                         |``a + n == b``.  ``b  |
|                               |                                 |                         |== a + (b - a)``.     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a[n]``                       |convertible to T                 |``*(a + n)``             |pre: a is a `Readable |
|                               |                                 |                         |Iterator`_            |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a[n] = v``                   |convertible to T                 |``*(a + n) = v``         |pre: a is a `Writable |
|                               |                                 |                         |Iterator`_            |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a < b``                      |convertible to ``bool``          |``b - a > 0``            |``<`` is a total      |
|                               |                                 |                         |ordering relation     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a > b``                      |convertible to ``bool``          |``b < a``                |``>`` is a total      |
|                               |                                 |                         |ordering relation     |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a >= b``                     |convertible to ``bool``          |``!(a < b)``             |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``a <= b``                     |convertible to ``bool``          |``!(a > b)``             |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+
|``iterator_traversal<X>::type``|Convertible to                   |                         |                      |
|                               |``random_access_traversal_tag``  |                         |                      |
+-------------------------------+---------------------------------+-------------------------+----------------------+

.. TR1: random_access_traversal_iterator_tag changed to
   random_access_traversal_tag for consistency


Interoperable Iterators [lib.interoperable.iterators]
-----------------------------------------------------

A class or built-in type ``X`` that models Single Pass Iterator is
*interoperable with* a class or built-in type ``Y`` that also models
Single Pass Iterator if the following expressions are valid and
respect the stated semantics. In the tables below, ``x`` is an object
of type ``X``, ``y`` is an object of type ``Y``, ``Distance`` is
``iterator_traits<Y>::difference_type``, and ``n`` represents a
constant object of type ``Distance``.

+-----------+-----------------------+---------------------------------------------------+
|Expression |Return Type            |Assertion/Precondition/Postcondition               |
+===========+=======================+===================================================+
|``y = x``  |``Y``                  |post: ``y == x``                                   |
+-----------+-----------------------+---------------------------------------------------+
|``Y(x)``   |``Y``                  |post: ``Y(x) == x``                                |
+-----------+-----------------------+---------------------------------------------------+
|``x == y`` |convertible to ``bool``|``==`` is an equivalence relation over its domain. |
+-----------+-----------------------+---------------------------------------------------+
|``y == x`` |convertible to ``bool``|``==`` is an equivalence relation over its domain. |
+-----------+-----------------------+---------------------------------------------------+
|``x != y`` |convertible to ``bool``|``bool(a==b) != bool(a!=b)`` over its domain.      |
+-----------+-----------------------+---------------------------------------------------+
|``y != x`` |convertible to ``bool``|``bool(a==b) != bool(a!=b)`` over its domain.      |
+-----------+-----------------------+---------------------------------------------------+

If ``X`` and ``Y`` both model Random Access Traversal Iterator then
the following additional requirements must be met.

+-----------+-----------------------+---------------------+--------------------------------------+
|Expression |Return Type            |Operational Semantics|Assertion/ Precondition               |
+===========+=======================+=====================+======================================+
|``x < y``  |convertible to ``bool``|``y - x > 0``        |``<`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y < x``  |convertible to ``bool``|``x - y > 0``        |``<`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x > y``  |convertible to ``bool``|``y < x``            |``>`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y > x``  |convertible to ``bool``|``x < y``            |``>`` is a total ordering relation    |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x >= y`` |convertible to ``bool``|``!(x < y)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y >= x`` |convertible to ``bool``|``!(y < x)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``x <= y`` |convertible to ``bool``|``!(x > y)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y <= x`` |convertible to ``bool``|``!(y > x)``         |                                      |
+-----------+-----------------------+---------------------+--------------------------------------+
|``y - x``  |``Distance``           |``distance(Y(x),y)`` |pre: there exists a value ``n`` of    |
|           |                       |                     |``Distance`` such that ``x + n == y``.|
|           |                       |                     |``y == x + (y - x)``.                 |
+-----------+-----------------------+---------------------+--------------------------------------+ 
|``x - y``  |``Distance``           |``distance(y,Y(x))`` |pre: there exists a value ``n`` of    |
|           |                       |                     |``Distance`` such that ``y + n == x``.|
|           |                       |                     |``x == y + (x - y)``.                 |
+-----------+-----------------------+---------------------+--------------------------------------+



Addition to [lib.iterator.synopsis]
===================================


::

  // lib.iterator.traits, traits and tags
  template <class Iterator> struct is_readable_iterator;
  template <class Iterator> struct iterator_traversal;

  struct incrementable_traversal_tag { };
  struct single_pass_traversal_tag : incrementable_traversal_tag { };
  struct forward_traversal_tag : single_pass_traversal_tag { };
  struct bidirectional_traversal_tag : forward_traversal_tag { };
  struct random_access_traversal_tag : bidirectional_traversal_tag { };

Addition to [lib.iterator.traits]
=================================

The ``is_readable_iterator`` class
template satisfies the UnaryTypeTrait_ requirements.  

Given an iterator type ``X``, ``is_readable_iterator<X>::value``
yields ``true`` if, for an object ``a`` of type ``X``, ``*a`` is
convertible to ``iterator_traits<X>::value_type``, and ``false``
otherwise.

``iterator_traversal<X>::type`` is 

.. parsed-literal::

  *category-to-traversal*\ (iterator_traits<X>::iterator_category) 

where *category-to-traversal* is defined as follows

.. _`category-to-traversal`:

.. parsed-literal::

   *category-to-traversal*\ (C) =
       if (C is convertible to incrementable_traversal_tag)
           return C;
       else if (C is convertible to random_access_iterator_tag)
           return random_access_traversal_tag;
       else if (C is convertible to bidirectional_iterator_tag)
           return bidirectional_traversal_tag;
       else if (C is convertible to forward_iterator_tag)
           return forward_traversal_tag;
       else if (C is convertible to input_iterator_tag)
           return single_pass_traversal_tag;
       else if (C is convertible to output_iterator_tag)
           return incrementable_traversal_tag;
       else
           *the program is ill-formed*


===========
 Footnotes
===========

.. _UnaryTypeTrait: n1519_

The UnaryTypeTrait concept is defined in n1519_; the LWG is
considering adding the requirement that specializations are derived
from their nested ``::type``.

.. _n1519: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1519.htm

..
 LocalWords:  Abrahams Siek Witt const bool Sutter's WG int UL LI href Lvalue
 LocalWords:  ReadableIterator WritableIterator SwappableIterator cv pre iter
 LocalWords:  ConstantLvalueIterator MutableLvalueIterator CopyConstructible TR
 LocalWords:  ForwardTraversalIterator BidirectionalTraversalIterator lvalue
 LocalWords:  RandomAccessTraversalIterator dereferenceable Incrementable tmp
 LocalWords:  incrementable xxx min prev inplace png oldeqnew AccessTag struct
 LocalWords:  TraversalTag typename lvalues DWA Hmm JGS mis enum
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.4 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG for TR1.

.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. parsed-literal::
  
  template <
      class Derived
    , class Base
    , class Value               = use_default
    , class CategoryOrTraversal = use_default
    , class Reference           = use_default
    , class Difference = use_default
  >
  class iterator_adaptor 
    : public iterator_facade<Derived, *V'*, *C'*, *R'*, *D'*> // see details__
  {
      friend class iterator_core_access;
   public:
      iterator_adaptor();
      explicit iterator_adaptor(Base const& iter);
      typedef Base base_type;
      Base const& base() const;
   protected:
      typedef iterator_adaptor iterator_adaptor\_;
      Base const& base_reference() const;
      Base& base_reference();
   private: // Core iterator interface for iterator_facade.  
      typename iterator_adaptor::reference dereference() const;

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >   
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const;
  
      void advance(typename iterator_adaptor::difference_type n);
      void increment();
      void decrement();

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >   
      typename iterator_adaptor::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const;

   private:
      Base m_iterator; // exposition only
  };

__ base_parameters_

.. _requirements:

``iterator_adaptor`` requirements
---------------------------------

``static_cast<Derived*>(iterator_adaptor*)`` shall be well-formed.
The ``Base`` argument shall be Assignable and Copy Constructible.


.. _base_parameters:

``iterator_adaptor`` base class parameters
------------------------------------------

The *V'*, *C'*, *R'*, and *D'* parameters of the ``iterator_facade``
used as a base class in the summary of ``iterator_adaptor``
above are defined as follows:

.. parsed-literal::

   *V'* = if (Value is use_default)
             return iterator_traits<Base>::value_type
         else
             return Value

   *C'* = if (CategoryOrTraversal is use_default)
             return iterator_traversal<Base>::type
         else
             return CategoryOrTraversal

   *R'* = if (Reference is use_default)
             if (Value is use_default)
                 return iterator_traits<Base>::reference
             else
                 return Value&
         else
             return Reference

   *D'* = if (Difference is use_default)
             return iterator_traits<Base>::difference_type
         else
             return Difference

.. ``iterator_adaptor`` models
   ---------------------------

   In order for ``Derived`` to model the iterator concepts corresponding
   to ``iterator_traits<Derived>::iterator_category``, the expressions
   involving ``m_iterator`` in the specifications of those private member
   functions of ``iterator_adaptor`` that may be called by
   ``iterator_facade<Derived, V, C, R, D>`` in evaluating any valid
   expression involving ``Derived`` in those concepts' requirements.

.. The above is confusing and needs a rewrite. -JGS
.. That's why it's removed.  We're embracing inheritance, remember?

``iterator_adaptor`` public operations
--------------------------------------

``iterator_adaptor();``

:Requires: The ``Base`` type must be Default Constructible.
:Returns: An instance of ``iterator_adaptor`` with 
    ``m_iterator`` default constructed.


``explicit iterator_adaptor(Base const& iter);``

:Returns: An instance of ``iterator_adaptor`` with
    ``m_iterator`` copy constructed from ``iter``.

``Base const& base() const;``

:Returns: ``m_iterator``

``iterator_adaptor`` protected member functions
-----------------------------------------------

``Base const& base_reference() const;``

:Returns: A const reference to ``m_iterator``.


``Base& base_reference();``

:Returns: A non-const reference to ``m_iterator``.


``iterator_adaptor`` private member functions
---------------------------------------------

``typename iterator_adaptor::reference dereference() const;``

:Returns: ``*m_iterator``

::

  template <
  class OtherDerived, class OtherIterator, class V, class C, class R, class D
  >   
  bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const;

:Returns: ``m_iterator == x.base()``


``void advance(typename iterator_adaptor::difference_type n);``

:Effects: ``m_iterator += n;``

``void increment();``

:Effects: ``++m_iterator;``

``void decrement();``

:Effects: ``--m_iterator;``

::

  template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
  >   
  typename iterator_adaptor::difference_type distance_to(
      iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const;

:Returns: ``y.base() - m_iterator``
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

    template <class UnaryFunction, class Iterator>
    transform_iterator<UnaryFunction, Iterator>
    make_transform_iterator(Iterator it, UnaryFunction fun);

:Returns: An instance of ``transform_iterator<UnaryFunction, Iterator>`` with ``m_f``
  initialized to ``f`` and ``m_iterator`` initialized to ``x``.



::

    template <class UnaryFunction, class Iterator>
    transform_iterator<UnaryFunction, Iterator>
    make_transform_iterator(Iterator it);

:Returns: An instance of ``transform_iterator<UnaryFunction, Iterator>`` with ``m_f``
  default constructed and ``m_iterator`` initialized to ``x``.
.. Copyright David Abrahams 2004. Use, modification and distribution is
.. subject to the Boost Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <class Dereferenceable>
  struct indirect_reference
  {
      typedef /* see below */ type;
  };

:Requires: For an object ``x`` of type ``Dereferenceable``, ``*x``
  is well-formed.  If ``++x`` is ill-formed it shall neither be
  ambiguous nor shall it violate access control, and
  ``pointee<Dereferenceable>::type&`` shall be well-formed.
  Otherwise ``iterator_traits<Dereferenceable>::reference`` shall
  be well formed.  [Note: These requirements need not apply to
  explicit or partial specializations of ``indirect_reference``]

``type`` is determined according to the following algorithm, where
``x`` is an object of type ``Dereferenceable``::

  if ( ++x is ill-formed )
      return ``pointee<Dereferenceable>::type&``
  else
      std::iterator_traits<Dereferenceable>::reference

  .. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The transform iterator adapts an iterator by modifying the
``operator*`` to apply a function object to the result of
dereferencing the iterator and returning the result.
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

::

    struct string_appender
    {
	string_appender(std::string& s)
	    : m_str(&s)
	{}

	void operator()(const std::string& x) const
	{
	    *m_str += x;
	}

	std::string* m_str;
    };

    int main(int, char*[])
    {
      std::vector<std::string> x;
      x.push_back("hello");
      x.push_back(" ");
      x.push_back("world");
      x.push_back("!");

      std::string s = "";
      std::copy(x.begin(), x.end(), 
		boost::make_function_output_iterator(string_appender(s)));

      std::cout << s << std::endl;

      return 0;
    }
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Readable Iterator Concept
.........................

A class or built-in type ``X`` models the *Readable Iterator* concept
for value type ``T`` if, in addition to ``X`` being Assignable and
Copy Constructible, the following expressions are valid and respect
the stated semantics. ``U`` is the type of any specified member of
type ``T``.

+-----------------------------------------------------------------------------------------------------------------------------+
|Readable Iterator Requirements (in addition to Assignable and Copy Constructible)                                            |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|Expression                         |Return Type             |Note/Precondition                                               |
+===================================+========================+================================================================+
|``iterator_traits<X>::value_type`` |``T``                   |Any non-reference,                                              |
|                                   |                        |non-cv-qualified type                                           |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|``*a``                             | Convertible to ``T``   |pre: ``a`` is dereferenceable. If ``a == b`` then ``*a``        |
|                                   |                        | is equivalent to ``*b``.                                       |
+-----------------------------------+------------------------+----------------------------------------------------------------+
|``a->m``                           |``U&``                  |pre: ``pre: (*a).m`` is well-defined. Equivalent to ``(*a).m``. |
+-----------------------------------+------------------------+----------------------------------------------------------------+
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The adaptor takes two arguments:

  * an iterator to the range V on which the permutation
    will be applied
  * the reindexing scheme that defines how the
    elements of V will be permuted.

Note that the permutation iterator is not limited to strict
permutations of the given range V.  The distance between begin and end
of the reindexing iterators is allowed to be smaller compared to the
size of the range V, in which case the permutation iterator only
provides a permutation of a subrange of V.  The indexes neither need
to be unique. In this same context, it must be noted that the past the
end permutation iterator is completely defined by means of the
past-the-end iterator to the indices.
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

This is a simple example of using the transform_iterators class to
generate iterators that multiply (or add to) the value returned by
dereferencing the iterator. It would be cooler to use lambda library
in this example.

::

    int x[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const int N = sizeof(x)/sizeof(int);

    typedef boost::binder1st< std::multiplies<int> > Function;
    typedef boost::transform_iterator<Function, int*> doubling_iterator;

    doubling_iterator i(x, boost::bind1st(std::multiplies<int>(), 2)),
      i_end(x + N, boost::bind1st(std::multiplies<int>(), 2));

    std::cout << "multiplying the array by 2:" << std::endl;
    while (i != i_end)
      std::cout << *i++ << " ";
    std::cout << std::endl;

    std::cout << "adding 4 to each element in the array:" << std::endl;
    std::copy(boost::make_transform_iterator(x, boost::bind1st(std::plus<int>(), 4)),
	      boost::make_transform_iterator(x + N, boost::bind1st(std::plus<int>(), 4)),
	      std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;


The output is::

    multiplying the array by 2:
    2 4 6 8 10 12 14 16 
    adding 4 to each element in the array:
    5 6 7 8 9 10 11 12


The source code for this example can be found `here`__.

__ ../example/transform_iterator_example.cpp
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.3 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG for TR1.

.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 


.. parsed-literal::

  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference  = Value&
    , class Difference = ptrdiff_t
  >
  class iterator_facade {
   public:
      typedef remove_const<Value>::type value_type;
      typedef Reference reference;
      typedef Value\* pointer;
      typedef Difference difference_type;
      typedef /* see below__ \*/ iterator_category;

      reference operator\*() const;
      /* see below__ \*/ operator->() const;
      /* see below__ \*/ operator[](difference_type n) const;
      Derived& operator++();
      Derived operator++(int);
      Derived& operator--();
      Derived operator--(int);
      Derived& operator+=(difference_type n);
      Derived& operator-=(difference_type n);
      Derived operator-(difference_type n) const;
   protected:
      typedef iterator_facade iterator_facade\_;
  };

  // Comparison operators
  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type // exposition
  operator ==(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator !=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator <(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
             iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator <=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator >(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
             iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator >=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  // Iterator difference
  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  /* see below__ \*/
  operator-(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
            iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

  // Iterator addition
  template <class Dr, class V, class TC, class R, class D>
  Derived operator+ (iterator_facade<Dr,V,TC,R,D> const&,
                     typename Derived::difference_type n);

  template <class Dr, class V, class TC, class R, class D>
  Derived operator+ (typename Derived::difference_type n,
                     iterator_facade<Dr,V,TC,R,D> const&);

__ `iterator category`_

__ `operator arrow`_

__ brackets_

__ minus_

.. _`iterator category`:

The ``iterator_category`` member of ``iterator_facade`` is

.. parsed-literal::

  *iterator-category*\ (CategoryOrTraversal, value_type, reference)

where *iterator-category* is defined as follows:

.. include:: facade_iterator_category.rst

The ``enable_if_interoperable`` template used above is for exposition
purposes.  The member operators should only be in an overload set
provided the derived types ``Dr1`` and ``Dr2`` are interoperable, 
meaning that at least one of the types is convertible to the other.  The
``enable_if_interoperable`` approach uses SFINAE to take the operators
out of the overload set when the types are not interoperable.  
The operators should behave *as-if* ``enable_if_interoperable``
were defined to be::

  template <bool, typename> enable_if_interoperable_impl
  {};

  template <typename T> enable_if_interoperable_impl<true,T>
  { typedef T type; };

  template<typename Dr1, typename Dr2, typename T>
  struct enable_if_interoperable
    : enable_if_interoperable_impl<
          is_convertible<Dr1,Dr2>::value || is_convertible<Dr2,Dr1>::value
        , T
      >
  {};


``iterator_facade`` Requirements
--------------------------------

The following table describes the typical valid expressions on
``iterator_facade``\ 's ``Derived`` parameter, depending on the
iterator concept(s) it will model.  The operations in the first
column must be made accessible to member functions of class
``iterator_core_access``.  In addition,
``static_cast<Derived*>(iterator_facade*)`` shall be well-formed.

In the table below, ``F`` is ``iterator_facade<X,V,C,R,D>``, ``a`` is an
object of type ``X``, ``b`` and ``c`` are objects of type ``const X``,
``n`` is an object of ``F::difference_type``, ``y`` is a constant
object of a single pass iterator type interoperable with ``X``, and ``z``
is a constant object of a random access traversal iterator type
interoperable with ``X``.

.. _`core operations`:

.. topic:: ``iterator_facade`` Core Operations

   +--------------------+----------------------+-------------------------+---------------------------+
   |Expression          |Return Type           |Assertion/Note           |Used to implement Iterator |
   |                    |                      |                         |Concept(s)                 |
   +====================+======================+=========================+===========================+
   |``c.dereference()`` |``F::reference``      |                         |Readable Iterator, Writable|
   |                    |                      |                         |Iterator                   |
   +--------------------+----------------------+-------------------------+---------------------------+
   |``c.equal(y)``      |convertible to bool   |true iff ``c`` and ``y`` |Single Pass Iterator       |
   |                    |                      |refer to the same        |                           |
   |                    |                      |position.                |                           |
   +--------------------+----------------------+-------------------------+---------------------------+
   |``a.increment()``   |unused                |                         |Incrementable Iterator     |
   +--------------------+----------------------+-------------------------+---------------------------+
   |``a.decrement()``   |unused                |                         |Bidirectional Traversal    |
   |                    |                      |                         |Iterator                   |
   +--------------------+----------------------+-------------------------+---------------------------+
   |``a.advance(n)``    |unused                |                         |Random Access Traversal    |
   |                    |                      |                         |Iterator                   |
   +--------------------+----------------------+-------------------------+---------------------------+
   |``c.distance_to(z)``|convertible to        |equivalent to            |Random Access Traversal    |
   |                    |``F::difference_type``|``distance(c, X(z))``.   |Iterator                   |
   +--------------------+----------------------+-------------------------+---------------------------+



``iterator_facade`` operations
------------------------------

The operations in this section are described in terms of operations on
the core interface of ``Derived`` which may be inaccessible
(i.e. private).  The implementation should access these operations
through member functions of class ``iterator_core_access``.

``reference operator*() const;``

:Returns: ``static_cast<Derived const*>(this)->dereference()``

``operator->() const;`` (see below__)

__ `operator arrow`_

:Returns: If ``reference`` is a reference type, an object
  of type ``pointer`` equal to::

    &static_cast<Derived const*>(this)->dereference()

  Otherwise returns an object of unspecified type such that, 
  ``(*static_cast<Derived const*>(this))->m`` is equivalent to ``(w = **static_cast<Derived const*>(this),
  w.m)`` for some temporary object ``w`` of type ``value_type``.

.. _brackets:

*unspecified* ``operator[](difference_type n) const;``

:Returns: an object convertible to ``value_type``. For constant
     objects ``v`` of type ``value_type``, and ``n`` of type
     ``difference_type``, ``(*this)[n] = v`` is equivalent to
     ``*(*this + n) = v``, and ``static_cast<value_type
     const&>((*this)[n])`` is equivalent to
     ``static_cast<value_type const&>(*(*this + n))``



``Derived& operator++();``

:Effects: 

  ::

    static_cast<Derived*>(this)->increment();
    return *static_cast<Derived*>(this);

``Derived operator++(int);``

:Effects:

  ::

    Derived tmp(static_cast<Derived const*>(this));
    ++*this;
    return tmp;


``Derived& operator--();``

:Effects:

   ::

      static_cast<Derived*>(this)->decrement();
      return *static_cast<Derived*>(this);


``Derived operator--(int);``

:Effects:

  ::

    Derived tmp(static_cast<Derived const*>(this));
    --*this;
    return tmp;


``Derived& operator+=(difference_type n);``

:Effects:

  ::

      static_cast<Derived*>(this)->advance(n);
      return *static_cast<Derived*>(this);


``Derived& operator-=(difference_type n);``

:Effects:
 
  ::

      static_cast<Derived*>(this)->advance(-n);
      return *static_cast<Derived*>(this);


``Derived operator-(difference_type n) const;``

:Effects:

  ::

    Derived tmp(static_cast<Derived const*>(this));
    return tmp -= n;

::

  template <class Dr, class V, class TC, class R, class D>
  Derived operator+ (iterator_facade<Dr,V,TC,R,D> const&,
                     typename Derived::difference_type n);

  template <class Dr, class V, class TC, class R, class D>
  Derived operator+ (typename Derived::difference_type n,
                     iterator_facade<Dr,V,TC,R,D> const&);

:Effects:

  ::

    Derived tmp(static_cast<Derived const*>(this));
    return tmp += n;


::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator ==(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``((Dr1 const&)lhs).equal((Dr2 const&)rhs)``.

  Otherwise, 
    ``((Dr2 const&)rhs).equal((Dr1 const&)lhs)``.

::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator !=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``!((Dr1 const&)lhs).equal((Dr2 const&)rhs)``.

  Otherwise, 
    ``!((Dr2 const&)rhs).equal((Dr1 const&)lhs)``.

::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator <(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
             iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``((Dr1 const&)lhs).distance_to((Dr2 const&)rhs) < 0``.

  Otherwise, 
    ``((Dr2 const&)rhs).distance_to((Dr1 const&)lhs) > 0``.

::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator <=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``((Dr1 const&)lhs).distance_to((Dr2 const&)rhs) <= 0``.

  Otherwise, 
    ``((Dr2 const&)rhs).distance_to((Dr1 const&)lhs) >= 0``.

::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator >(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
             iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``((Dr1 const&)lhs).distance_to((Dr2 const&)rhs) > 0``.

  Otherwise, 
    ``((Dr2 const&)rhs).distance_to((Dr1 const&)lhs) < 0``.


::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,bool>::type
  operator >=(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
              iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``((Dr1 const&)lhs).distance_to((Dr2 const&)rhs) >= 0``.

  Otherwise, 
    ``((Dr2 const&)rhs).distance_to((Dr1 const&)lhs) <= 0``.

.. _minus:

::

  template <class Dr1, class V1, class TC1, class R1, class D1,
            class Dr2, class V2, class TC2, class R2, class D2>
  typename enable_if_interoperable<Dr1,Dr2,difference>::type
  operator -(iterator_facade<Dr1,V1,TC1,R1,D1> const& lhs,
             iterator_facade<Dr2,V2,TC2,R2,D2> const& rhs);

:Return Type: 
  if ``is_convertible<Dr2,Dr1>::value``

   then 
    ``difference`` shall be
    ``iterator_traits<Dr1>::difference_type``.

   Otherwise 
    ``difference`` shall be ``iterator_traits<Dr2>::difference_type``

:Returns: 
  if ``is_convertible<Dr2,Dr1>::value``

  then 
    ``-((Dr1 const&)lhs).distance_to((Dr2 const&)rhs)``.

  Otherwise, 
    ``((Dr2 const&)rhs).distance_to((Dr1 const&)lhs)``.
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The function output iterator adaptor makes it easier to create custom
output iterators. The adaptor takes a unary function and creates a
model of Output Iterator. Each item assigned to the output iterator is
passed as an argument to the unary function.  The motivation for this
iterator is that creating a conforming output iterator is non-trivial,
particularly because the proper implementation usually requires a
proxy object.

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++++++++
 Function Output Iterator
++++++++++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: func_output_iter_abstract.rst

.. contents:: Table of Contents

.. include:: func_output_iter_ref.rst
.. include:: function_output_iterator_eg.rst.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++++++++++++++++++++++
 ``pointee`` and ``indirect_reference`` 
++++++++++++++++++++++++++++++++++++++++

:Author: David Abrahams
:Contact: dave@boost-consulting.com
:organization: `Boost Consulting`_
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:copyright: Copyright David Abrahams 2004. 

.. _`Boost Consulting`: http://www.boost-consulting.com

:abstract: Provides the capability to deduce the referent types of
  pointers, smart pointers and iterators in generic code.

Overview
========

Have you ever wanted to write a generic function that can operate
on any kind of dereferenceable object?  If you have, you've
probably run into the problem of how to determine the type that the
object "points at":

.. parsed-literal::

   template <class Dereferenceable>
   void f(Dereferenceable p)
   {
       *what-goes-here?* value = \*p;
       ...
   }


``pointee``
-----------

It turns out to be impossible to come up with a fully-general
algorithm to do determine *what-goes-here* directly, but it is
possible to require that ``pointee<Dereferenceable>::type`` is
correct. Naturally, ``pointee`` has the same difficulty: it can't
determine the appropriate ``::type`` reliably for all
``Dereferenceable``\ s, but it makes very good guesses (it works
for all pointers, standard and boost smart pointers, and
iterators), and when it guesses wrongly, it can be specialized as
necessary::

  namespace boost
  {
    template <class T>
    struct pointee<third_party_lib::smart_pointer<T> >
    {
        typedef T type;
    };
  }

``indirect_reference``
----------------------

``indirect_reference<T>::type`` is rather more specialized than
``pointee``, and is meant to be used to forward the result of
dereferencing an object of its argument type.  Most dereferenceable
types just return a reference to their pointee, but some return
proxy references or return the pointee by value.  When that
information is needed, call on ``indirect_reference``.

Both of these templates are essential to the correct functioning of
|indirect_iterator|_.

.. |indirect_iterator| replace:: ``indirect_iterator``
.. _indirect_iterator: indirect_iterator.html

Reference
=========

``pointee``
-----------

.. include:: pointee_ref.rst

``indirect_reference``
----------------------

.. include:: indirect_reference_ref.rst

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++
 Iterator Adaptor
+++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

.. include:: iterator_adaptor_abstract.rst

.. contents:: Table of Contents

Overview
========

.. include:: iterator_adaptor_body.rst


Reference
=========

.. include:: iterator_adaptor_ref.rst

Tutorial Example
================

.. include:: iterator_adaptor_tutorial.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template<typename IteratorTuple>
  class zip_iterator
  {  

  public:
    typedef /* see below */ reference;
    typedef reference value_type;
    typedef value_type* pointer;
    typedef /* see below */ difference_type;
    typedef /* see below */ iterator_category;

    zip_iterator();
    zip_iterator(IteratorTuple iterator_tuple);

    template<typename OtherIteratorTuple>
    zip_iterator(
          const zip_iterator<OtherIteratorTuple>& other
        , typename enable_if_convertible<
                OtherIteratorTuple
              , IteratorTuple>::type* = 0     // exposition only
    );

    const IteratorTuple& get_iterator_tuple() const;

  private:
    IteratorTuple m_iterator_tuple;     // exposition only
  };

  template<typename IteratorTuple> 
  zip_iterator<IteratorTuple> 
  make_zip_iterator(IteratorTuple t);


The ``reference`` member of ``zip_iterator`` is the type of the tuple
made of the reference types of the iterator types in the ``IteratorTuple``
argument.

The ``difference_type`` member of ``zip_iterator`` is the ``difference_type``
of the first of the iterator types in the ``IteratorTuple`` argument.

The ``iterator_category`` member of ``zip_iterator`` is convertible to the
minimum of the traversal categories of the iterator types in the ``IteratorTuple``
argument. For example, if the ``zip_iterator`` holds only vector
iterators, then ``iterator_category`` is convertible to 
``boost::random_access_traversal_tag``. If you add a list iterator, then
``iterator_category`` will be convertible to ``boost::bidirectional_traversal_tag``,
but no longer to ``boost::random_access_traversal_tag``.


``zip_iterator`` requirements
...................................

All iterator types in the argument ``IteratorTuple`` shall model Readable Iterator.  


``zip_iterator`` models
.............................

The resulting ``zip_iterator`` models Readable Iterator.

The fact that the ``zip_iterator`` models only Readable Iterator does not 
prevent you from modifying the values that the individual iterators point
to. The tuple returned by the ``zip_iterator``'s ``operator*`` is a tuple 
constructed from the reference types of the individual iterators, not 
their value types. For example, if ``zip_it`` is a ``zip_iterator`` whose
first member iterator is an ``std::vector<double>::iterator``, then the
following line will modify the value which the first member iterator of
``zip_it`` currently points to:

::

    zip_it->get<0>() = 42.0;


Consider the set of standard traversal concepts obtained by taking
the most refined standard traversal concept modeled by each individual
iterator type in the ``IteratorTuple`` argument.The ``zip_iterator`` 
models the least refined standard traversal concept in this set.

``zip_iterator<IteratorTuple1>`` is interoperable with
``zip_iterator<IteratorTuple2>`` if and only if ``IteratorTuple1``
is interoperable with ``IteratorTuple2``.



``zip_iterator`` operations
.................................

In addition to the operations required by the concepts modeled by
``zip_iterator``, ``zip_iterator`` provides the following
operations.


``zip_iterator();``

:Returns: An instance of ``zip_iterator`` with ``m_iterator_tuple``
  default constructed.


``zip_iterator(IteratorTuple iterator_tuple);``

:Returns: An instance of ``zip_iterator`` with ``m_iterator_tuple``
  initialized to ``iterator_tuple``.


::

    template<typename OtherIteratorTuple>
    zip_iterator(
          const zip_iterator<OtherIteratorTuple>& other
        , typename enable_if_convertible<
                OtherIteratorTuple
              , IteratorTuple>::type* = 0     // exposition only
    );

:Returns: An instance of ``zip_iterator`` that is a copy of ``other``.
:Requires: ``OtherIteratorTuple`` is implicitly convertible to ``IteratorTuple``.


``const IteratorTuple& get_iterator_tuple() const;``

:Returns: ``m_iterator_tuple``


``reference operator*() const;``

:Returns: A tuple consisting of the results of dereferencing all iterators in
  ``m_iterator_tuple``.


``zip_iterator& operator++();``

:Effects: Increments each iterator in ``m_iterator_tuple``.
:Returns: ``*this``


``zip_iterator& operator--();``

:Effects: Decrements each iterator in ``m_iterator_tuple``.
:Returns: ``*this``

::

    template<typename IteratorTuple> 
    zip_iterator<IteratorTuple> 
    make_zip_iterator(IteratorTuple t);

:Returns: An instance of ``zip_iterator<IteratorTuple>`` with ``m_iterator_tuple``
  initialized to ``t``.
.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt
.. 2004. Use, modification and distribution is subject to the Boost
.. Software License, Version 1.0. (See accompanying  file
.. LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) 

::

  template <class Predicate, class Iterator>
  class filter_iterator
  {
   public:
      typedef iterator_traits<Iterator>::value_type value_type;
      typedef iterator_traits<Iterator>::reference reference;
      typedef iterator_traits<Iterator>::pointer pointer;
      typedef iterator_traits<Iterator>::difference_type difference_type;
      typedef /* see below */ iterator_category;

      filter_iterator();
      filter_iterator(Predicate f, Iterator x, Iterator end = Iterator());
      filter_iterator(Iterator x, Iterator end = Iterator());
      template<class OtherIterator>
      filter_iterator(
          filter_iterator<Predicate, OtherIterator> const& t
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0 // exposition
          );
      Predicate predicate() const;
      Iterator end() const;
      Iterator const& base() const;
      reference operator*() const;
      filter_iterator& operator++();
  private:
      Predicate m_pred; // exposition only
      Iterator m_iter;  // exposition only
      Iterator m_end;   // exposition only
  };


If ``Iterator`` models Readable Lvalue Iterator and Bidirectional Traversal
Iterator then ``iterator_category`` is convertible to
``std::bidirectional_iterator_tag``. 
Otherwise, if ``Iterator`` models Readable Lvalue Iterator and Forward Traversal
Iterator then ``iterator_category`` is convertible to
``std::forward_iterator_tag``. 
Otherwise ``iterator_category`` is
convertible to ``std::input_iterator_tag``.


``filter_iterator`` requirements
................................

The ``Iterator`` argument shall meet the requirements of Readable
Iterator and Single Pass Iterator or it shall meet the requirements of
Input Iterator.

The ``Predicate`` argument must be Assignable, Copy Constructible, and
the expression ``p(x)`` must be valid where ``p`` is an object of type
``Predicate``, ``x`` is an object of type
``iterator_traits<Iterator>::value_type``, and where the type of
``p(x)`` must be convertible to ``bool``.


``filter_iterator`` models
..........................

The concepts that ``filter_iterator`` models are dependent on which
concepts the ``Iterator`` argument models, as specified in the
following tables.

+---------------------------------+------------------------------------------+
|If ``Iterator`` models           |then ``filter_iterator`` models           |
+=================================+==========================================+
|Single Pass Iterator             |Single Pass Iterator                      |
+---------------------------------+------------------------------------------+
|Forward Traversal Iterator       |Forward Traversal Iterator                |
+---------------------------------+------------------------------------------+
|Bidirectional Traversal Iterator |Bidirectional Traversal Iterator          |
+---------------------------------+------------------------------------------+

+--------------------------------+----------------------------------------------+
| If ``Iterator`` models         | then ``filter_iterator`` models              |
+================================+==============================================+
| Readable Iterator              | Readable Iterator                            |
+--------------------------------+----------------------------------------------+
| Writable Iterator              | Writable Iterator                            |
+--------------------------------+----------------------------------------------+
| Lvalue Iterator                | Lvalue Iterator                              |
+--------------------------------+----------------------------------------------+

+-------------------------------------------------------+---------------------------------+
|If ``Iterator`` models                                 | then ``filter_iterator`` models |
+=======================================================+=================================+
|Readable Iterator, Single Pass Iterator                | Input Iterator                  |
+-------------------------------------------------------+---------------------------------+
|Readable Lvalue Iterator, Forward Traversal Iterator   | Forward Iterator                |
+-------------------------------------------------------+---------------------------------+
|Writable Lvalue Iterator, Forward Traversal Iterator   | Mutable Forward Iterator        |
+-------------------------------------------------------+---------------------------------+
|Writable Lvalue Iterator, Bidirectional Iterator       | Mutable Bidirectional Iterator  |
+-------------------------------------------------------+---------------------------------+


``filter_iterator<P1, X>`` is interoperable with ``filter_iterator<P2, Y>`` 
if and only if ``X`` is interoperable with ``Y``.


``filter_iterator`` operations
..............................

In addition to those operations required by the concepts that
``filter_iterator`` models, ``filter_iterator`` provides the following
operations.


``filter_iterator();``

:Requires: ``Predicate`` and ``Iterator`` must be Default Constructible.
:Effects: Constructs a ``filter_iterator`` whose``m_pred``,  ``m_iter``, and ``m_end`` 
  members are a default constructed.


``filter_iterator(Predicate f, Iterator x, Iterator end = Iterator());``

:Effects: Constructs a ``filter_iterator`` where ``m_iter`` is either
    the first position in the range ``[x,end)`` such that ``f(*m_iter) == true`` 
    or else``m_iter == end``. The member ``m_pred`` is constructed from
    ``f`` and ``m_end`` from ``end``.



``filter_iterator(Iterator x, Iterator end = Iterator());``

:Requires: ``Predicate`` must be Default Constructible and
  ``Predicate`` is a class type (not a function pointer).
:Effects: Constructs a ``filter_iterator`` where ``m_iter`` is either
    the first position in the range ``[x,end)`` such that ``m_pred(*m_iter) == true`` 
    or else``m_iter == end``. The member ``m_pred`` is default constructed.


::

    template <class OtherIterator>
    filter_iterator(
        filter_iterator<Predicate, OtherIterator> const& t
        , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0 // exposition
        );``

:Requires: ``OtherIterator`` is implicitly convertible to ``Iterator``.
:Effects: Constructs a filter iterator whose members are copied from ``t``.


``Predicate predicate() const;``

:Returns: ``m_pred``


``Iterator end() const;``

:Returns: ``m_end``


``Iterator const& base() const;``

:Returns: ``m_iterator``



``reference operator*() const;``

:Returns: ``*m_iter``


``filter_iterator& operator++();``

:Effects: Increments ``m_iter`` and then continues to
  increment ``m_iter`` until either ``m_iter == m_end``
  or ``m_pred(*m_iter) == true``.
:Returns: ``*this``  
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Problem with ``is_writable`` and ``is_swappable`` in N1550_
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. _N1550: http://www.boost-consulting.com/writing/n1550.html
.. _N1530: http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1530.html

:Author: David Abrahams and Jeremy Siek
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu
:Organization: `Boost Consulting`_, Indiana University Bloomington
:date: $Date: 2008-03-22 14:45:55 -0700 (Sat, 22 Mar 2008) $
:Copyright: Copyright David Abrahams, Jeremy Siek 2003. Use, modification and
      distribution is subject to the Boost Software License,
      Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
      at http://www.boost.org/LICENSE_1_0.txt)

.. _`Boost Consulting`: http://www.boost-consulting.com

.. contents:: Table of Contents

==============
 Introduction
==============

The ``is_writable`` and ``is_swappable`` traits classes in N1550_
provide a mechanism for determining at compile time if an iterator
type is a model of the new Writable Iterator and Swappable Iterator
concepts, analogous to ``iterator_traits<X>::iterator_category``
for the old iterator concepts. For backward compatibility,
``is_writable`` and ``is_swappable`` not only work with new
iterators, but they also are intended to work for old
iterators (iterators that meet the requirements for one of the
iterator concepts in the current standard). In the case of old
iterators, the writability and swapability is deduced based on the
``iterator_category`` and also the ``reference`` type. The
specification for this deduction gives false positives for forward
iterators that have non-assignable value types.

To review, the part of the ``is_writable`` trait definition which
applies to old iterators is::

  if (cat is convertible to output_iterator_tag)
      return true;
  else if (cat is convertible to forward_iterator_tag
           and iterator_traits<Iterator>::reference is a 
               mutable reference)
      return true;
  else
      return false;

Suppose the ``value_type`` of the iterator ``It`` has a private
assignment operator::

  class B {
  public:
    ...
  private:
    B& operator=(const B&);
  };

and suppose the ``reference`` type of the iterator is ``B&``.  In
that case, ``is_writable<It>::value`` will be true when in fact
attempting to write into ``B`` will cause an error.

The same problem applies to ``is_swappable``.


====================
 Proposed Resolution
====================

1. Remove the ``is_writable`` and ``is_swappable`` traits, and remove the
   requirements in the Writable Iterator and Swappable Iterator concepts
   that require their models to support these traits.

2. Change the ``is_readable`` specification to be:
   ``is_readable<X>::type`` is ``true_type`` if the
   result type of ``X::operator*`` is convertible to
   ``iterator_traits<X>::value_type`` and is ``false_type``
   otherwise. Also, ``is_readable`` is required to satisfy
   the requirements for the UnaryTypeTrait concept
   (defined in the type traits proposal).
   
   Remove the requirement for support of the ``is_readable`` trait from
   the Readable Iterator concept.


3. Remove the ``iterator_tag`` class.

4. Change the specification of ``traversal_category`` to::

    traversal-category(Iterator) =
        let cat = iterator_traits<Iterator>::iterator_category
        if (cat is convertible to incrementable_iterator_tag)
          return cat; // Iterator is a new iterator
        else if (cat is convertible to random_access_iterator_tag)
            return random_access_traversal_tag;
        else if (cat is convertible to bidirectional_iterator_tag)
            return bidirectional_traversal_tag;
        else if (cat is convertible to forward_iterator_tag)
            return forward_traversal_tag;
        else if (cat is convertible to input_iterator_tag)
            return single_pass_iterator_tag;
        else if (cat is convertible to output_iterator_tag)
            return incrementable_iterator_tag;
        else
            return null_category_tag;


==========
 Rationale
==========

1. There are two reasons for removing ``is_writable``
   and ``is_swappable``. The first is that we do not know of
   a way to fix the specification so that it gives the correct
   answer for all iterators. Second, there was only a weak
   motivation for having ``is_writable`` and ``is_swappable``
   there in the first place.  The main motivation was simply
   uniformity: we have tags for the old iterator categories
   so we should have tags for the new iterator categories.
   While having tags and the capability to dispatch based
   on the traversal categories is often used, we see
   less of a need for dispatching based on writability
   and swappability, since typically algorithms
   that need these capabilities have no alternative if
   they are not provided.

2. We discovered that the ``is_readable`` trait can be implemented
   using only the iterator type itself and its ``value_type``.
   Therefore we remove the requirement for ``is_readable`` from the
   Readable Iterator concept, and change the definition of
   ``is_readable`` so that it works for any iterator type.

3. The purpose of the ``iterator_tag`` class was to
   bundle the traversal and access category tags
   into the ``iterator_category`` typedef.
   With ``is_writable`` and ``is_swappable`` gone, and
   ``is_readable`` no longer in need of special hints,
   there is no reason for iterators to provide
   information about the access capabilities of an iterator.
   Thus there is no need for the ``iterator_tag``. The
   traversal tag can be directly used for the
   ``iterator_category``. If a new iterator is intended to be backward
   compatible with old iterator concepts, a tag type
   that is convertible to both one of the new traversal tags 
   and also to an old iterator tag can be created and use
   for the ``iterator_category``.

4. The changes to the specification of ``traversal_category`` are a 
   direct result of the removal of ``iterator_tag``.

.. |iterator-category| replace:: *iterator-category*
.. _iterator-category:

.. parsed-literal::
  
  *iterator-category*\ (C,R,V) :=
     if (C is convertible to std::input_iterator_tag
         || C is convertible to std::output_iterator_tag
     )
         return C

     else if (C is not convertible to incrementable_traversal_tag)
         *the program is ill-formed*

     else return a type X satisfying the following two constraints:

        1. X is convertible to X1, and not to any more-derived
           type, where X1 is defined by:

             if (R is a reference type
                 && C is convertible to forward_traversal_tag)
             {
                 if (C is convertible to random_access_traversal_tag)
                     X1 = random_access_iterator_tag
                 else if (C is convertible to bidirectional_traversal_tag)
                     X1 = bidirectional_iterator_tag
                 else
                     X1 = forward_iterator_tag
             }
             else
             {
                 if (C is convertible to single_pass_traversal_tag
                     && R is convertible to V)
                     X1 = input_iterator_tag
                 else
                     X1 = C
             }

        2. |category-to-traversal|_\ (X) is convertible to the most
           derived traversal tag type to which X is also
           convertible, and not to any more-derived traversal tag
           type.

.. |category-to-traversal| replace:: *category-to-traversal*
.. _`category-to-traversal`: new-iter-concepts.html#category-to-traversal

[Note: the intention is to allow ``iterator_category`` to be one of
the five original category tags when convertibility to one of the
traversal tags would add no information]

.. Copyright David Abrahams 2004. Use, modification and distribution is
.. subject to the Boost Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

    template<typename IteratorTuple> 
    zip_iterator<IteratorTuple> 
    make_zip_iterator(IteratorTuple t);

:Returns: An instance of ``zip_iterator<IteratorTuple>`` with ``m_iterator_tuple``
  initialized to ``t``.
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++++++++++++++++++++++++++++++++++
 The Boost.Iterator Library |(logo)|__
+++++++++++++++++++++++++++++++++++++++++++++++++

.. |(logo)| image:: ../../../boost.png
   :alt: Boost

__ ../../../index.htm


-------------------------------------


:Authors:       David Abrahams, Jeremy Siek, Thomas Witt
:Contact:       dave@boost-consulting.com, jsiek@osl.iu.edu, witt@styleadvisor.com
:organizations: `Boost Consulting`_, Indiana University `Open Systems
                Lab`_, `Zephyr Associates, Inc.`_
:date:          $Date: 2011-03-29 14:17:11 -0700 (Tue, 29 Mar 2011) $

:copyright:     Copyright David Abrahams, Jeremy Siek, Thomas Witt 2003.

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Zephyr Associates, Inc.`: http://www.styleadvisor.com

:Abstract: The Boost Iterator Library contains two parts. The first
           is a system of concepts_ which extend the C++ standard
           iterator requirements. The second is a framework of
           components for building iterators based on these
           extended concepts and includes several useful iterator
           adaptors. The extended iterator concepts have been
           carefully designed so that old-style iterators
           can fit in the new concepts and so that new-style
           iterators will be compatible with old-style algorithms,
           though algorithms may need to be updated if they want to
           take full advantage of the new-style iterator
           capabilities.  Several components of this library have
           been accepted into the C++ standard technical report.
           The components of the Boost Iterator Library replace the
           older Boost Iterator Adaptor Library.

.. _concepts: http://www.boost.org/more/generic_programming.html#concept

.. contents:: **Table of Contents**


-------------------------------------


=====================
 New-Style Iterators
=====================

The iterator categories defined in C++98 are extremely limiting
because they bind together two orthogonal concepts: traversal and
element access.  For example, because a random access iterator is
required to return a reference (and not a proxy) when dereferenced,
it is impossible to capture the capabilities of
``vector<bool>::iterator`` using the C++98 categories.  This is the
infamous "``vector<bool>`` is not a container, and its iterators
aren't random access iterators", debacle about which Herb Sutter
wrote two papers for the standards comittee (n1185_ and n1211_),
and a `Guru of the Week`__.  New-style iterators go well beyond
patching up ``vector<bool>``, though: there are lots of other
iterators already in use which can't be adequately represented by
the existing concepts.  For details about the new iterator
concepts, see our

.. _n1185: http://www.gotw.ca/publications/N1185.pdf
.. _n1211: http://www.gotw.ca/publications/N1211.pdf
__ http://www.gotw.ca/gotw/050.htm


   `Standard Proposal For New-Style Iterators`__ (PDF__)

__ new-iter-concepts.html
__ new-iter-concepts.pdf

=============================
 Iterator Facade and Adaptor
=============================

Writing standard-conforming iterators is tricky, but the need comes
up often.  In order to ease the implementation of new iterators,
the Boost.Iterator library provides the |facade| class template,
which implements many useful defaults and compile-time checks
designed to help the iterator author ensure that his iterator is
correct.  

It is also common to define a new iterator that is similar to some
underlying iterator or iterator-like type, but that modifies some
aspect of the underlying type's behavior.  For that purpose, the
library supplies the |adaptor| class template, which is specially
designed to take advantage of as much of the underlying type's
behavior as possible.

The documentation for these two classes can be found at the following
web pages:

* |facade|_ (PDF__)

* |adaptor|_ (PDF__)


.. |facade| replace:: ``iterator_facade``
.. _facade: iterator_facade.html
__ iterator_facade.pdf

.. |adaptor| replace:: ``iterator_adaptor``
.. _adaptor: iterator_adaptor.html
__ iterator_adaptor.pdf

Both |facade| and |adaptor| as well as many of the `specialized
adaptors`_ mentioned below have been proposed for standardization,
and accepted into the first C++ technical report; see our

   `Standard Proposal For Iterator Facade and Adaptor`__ (PDF__)

for more details.

__ facade-and-adaptor.html
__ facade-and-adaptor.pdf

======================
 Specialized Adaptors
======================

The iterator library supplies a useful suite of standard-conforming
iterator templates based on the Boost `iterator facade and adaptor`_.

* |counting|_ (PDF__): an iterator over a sequence of consecutive values.
  Implements a "lazy sequence"

* |filter|_ (PDF__): an iterator over the subset of elements of some
  sequence which satisfy a given predicate

* |function_input|_ (PDF__): an input iterator wrapping a generator (nullary
  function object); each time the iterator is dereferenced, the function object
  is called to get the value to return.

* |function_output|_ (PDF__): an output iterator wrapping a unary function
  object; each time an element is written into the dereferenced
  iterator, it is passed as a parameter to the function object.

* |indirect|_ (PDF__): an iterator over the objects *pointed-to* by the
  elements of some sequence.

* |permutation|_ (PDF__): an iterator over the elements of some random-access
  sequence, rearranged according to some sequence of integer indices.

* |reverse|_ (PDF__): an iterator which traverses the elements of some
  bidirectional sequence in reverse.  Corrects many of the
  shortcomings of C++98's ``std::reverse_iterator``.

* |shared|_: an iterator over elements of a container whose
  lifetime is maintained by a |shared_ptr|_ stored in the iterator.

* |transform|_ (PDF__): an iterator over elements which are the result of
  applying some functional transformation to the elements of an
  underlying sequence.  This component also replaces the old
  ``projection_iterator_adaptor``.

* |zip|_ (PDF__): an iterator over tuples of the elements at corresponding
  positions of heterogeneous underlying iterators.

.. |counting| replace:: ``counting_iterator``
.. _counting: counting_iterator.html
__ counting_iterator.pdf

.. |filter| replace:: ``filter_iterator``
.. _filter: filter_iterator.html
__ filter_iterator.pdf

.. |function_input| replace:: ``function_input_iterator``
.. _function_input: function_input_iterator.html
__ function_input_iterator.pdf

.. |function_output| replace:: ``function_output_iterator``
.. _function_output: function_output_iterator.html
__ function_output_iterator.pdf

.. |indirect| replace:: ``indirect_iterator``
.. _indirect: indirect_iterator.html
__ indirect_iterator.pdf

.. |permutation| replace:: ``permutation_iterator``
.. _permutation: permutation_iterator.html
__ permutation_iterator.pdf

.. |reverse| replace:: ``reverse_iterator``
.. _reverse: reverse_iterator.html
__ reverse_iterator.pdf

.. |shared| replace:: ``shared_container_iterator``
.. _shared: ../../utility/shared_container_iterator.html

.. |transform| replace:: ``transform_iterator``
.. _transform: transform_iterator.html
__ transform_iterator.pdf

.. |zip| replace:: ``zip_iterator``
.. _zip: zip_iterator.html
__ zip_iterator.pdf

.. |shared_ptr| replace:: ``shared_ptr``
.. _shared_ptr: ../../smart_ptr/shared_ptr.htm

====================
 Iterator Utilities
====================

Traits
------

* |pointee|_ (PDF__): Provides the capability to deduce the referent types
  of pointers, smart pointers and iterators in generic code.  Used
  in |indirect|.

* |iterator_traits|_ (PDF__): Provides MPL_\ -compatible metafunctions which
  retrieve an iterator's traits.  Also corrects for the deficiencies
  of broken implementations of ``std::iterator_traits``.

.. * |interoperable|_ (PDF__): Provides an MPL_\ -compatible metafunction for
     testing iterator interoperability

.. |pointee| replace:: ``pointee.hpp``
.. _pointee: pointee.html
__ pointee.pdf

.. |iterator_traits| replace:: ``iterator_traits.hpp``
.. _iterator_traits: iterator_traits.html
__ iterator_traits.pdf

.. |interoperable| replace:: ``interoperable.hpp``
.. _interoperable: interoperable.html
.. comment! __ interoperable.pdf

.. _MPL: ../../mpl/doc/index.html

Testing and Concept Checking
----------------------------

* |iterator_concepts|_ (PDF__): Concept checking classes for the new iterator concepts.

* |iterator_archetypes|_ (PDF__): Concept archetype classes for the new iterators concepts.

.. |iterator_concepts| replace:: ``iterator_concepts.hpp``
.. _iterator_concepts: iterator_concepts.html
__ iterator_concepts.pdf

.. |iterator_archetypes| replace:: ``iterator_archetypes.hpp``
.. _iterator_archetypes: iterator_archetypes.html
__ iterator_archetypes.pdf

=======================================================
 Upgrading from the old Boost Iterator Adaptor Library
=======================================================

.. _Upgrading:

If you have been using the old Boost Iterator Adaptor library to
implement iterators, you probably wrote a ``Policies`` class which
captures the core operations of your iterator.  In the new library
design, you'll move those same core operations into the body of the
iterator class itself.  If you were writing a family of iterators,
you probably wrote a `type generator`_ to build the
``iterator_adaptor`` specialization you needed; in the new library
design you don't need a type generator (though may want to keep it
around as a compatibility aid for older code) because, due to the
use of the Curiously Recurring Template Pattern (CRTP) [Cop95]_,
you can now define the iterator class yourself and acquire
functionality through inheritance from ``iterator_facade`` or
``iterator_adaptor``.  As a result, you also get much finer control
over how your iterator works: you can add additional constructors,
or even override the iterator functionality provided by the
library.

.. _`type generator`: http://www.boost.org/more/generic_programming.html#type_generator

If you're looking for the old ``projection_iterator`` component,
its functionality has been merged into ``transform_iterator``: as
long as the function object's ``result_type`` (or the ``Reference``
template argument, if explicitly specified) is a true reference
type, ``transform_iterator`` will behave like
``projection_iterator`` used to.

=========
 History
=========

In 2000 Dave Abrahams was writing an iterator for a container of
pointers, which would access the pointed-to elements when
dereferenced.  Naturally, being a library writer, he decided to
generalize the idea and the Boost Iterator Adaptor library was born.
Dave was inspired by some writings of Andrei Alexandrescu and chose a
policy based design (though he probably didn't capture Andrei's idea
very well - there was only one policy class for all the iterator's
orthogonal properties).  Soon Jeremy Siek realized he would need the
library and they worked together to produce a "Boostified" version,
which was reviewed and accepted into the library.  They wrote a paper
and made several important revisions of the code.

Eventually, several shortcomings of the older library began to make
the need for a rewrite apparent.  Dave and Jeremy started working
at the Santa Cruz C++ committee meeting in 2002, and had quickly
generated a working prototype.  At the urging of Mat Marcus, they
decided to use the GenVoca/CRTP pattern approach, and moved the
policies into the iterator class itself.  Thomas Witt expressed
interest and became the voice of strict compile-time checking for
the project, adding uses of the SFINAE technique to eliminate false
converting constructors and operators from the overload set.  He
also recognized the need for a separate ``iterator_facade``, and
factored it out of ``iterator_adaptor``.  Finally, after a
near-complete rewrite of the prototype, they came up with the
library you see today.

.. [Cop95] [Coplien, 1995] Coplien, J., Curiously Recurring Template
   Patterns, C++ Report, February 1995, pp. 24-27.

..
 LocalWords:  Abrahams Siek Witt const bool Sutter's WG int UL LI href Lvalue
 LocalWords:  ReadableIterator WritableIterator SwappableIterator cv pre iter
 LocalWords:  ConstantLvalueIterator MutableLvalueIterator CopyConstructible TR
 LocalWords:  ForwardTraversalIterator BidirectionalTraversalIterator lvalue
 LocalWords:  RandomAccessTraversalIterator dereferenceable Incrementable tmp
 LocalWords:  incrementable xxx min prev inplace png oldeqnew AccessTag struct
 LocalWords:  TraversalTag typename lvalues DWA Hmm JGS
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.1 of this ReStructuredText document corresponds to
   n1530_, the paper accepted by the LWG.

.. Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

Each specialization of the ``iterator_adaptor`` class template is derived from
a specialization of ``iterator_facade``. The core interface functions
expected by ``iterator_facade`` are implemented in terms of the
``iterator_adaptor``\ 's ``Base`` template parameter. A class derived
from ``iterator_adaptor`` typically redefines some of the core
interface functions to adapt the behavior of the ``Base`` type.
Whether the derived class models any of the standard iterator concepts
depends on the operations supported by the ``Base`` type and which
core interface functions of ``iterator_facade`` are redefined in the
``Derived`` class.
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Header
......

::
  
  #include <boost/function_output_iterator.hpp>

::

  template <class UnaryFunction>
  class function_output_iterator {
  public:
    typedef std::output_iterator_tag iterator_category;
    typedef void                     value_type;
    typedef void                     difference_type;
    typedef void                     pointer;
    typedef void                     reference;

    explicit function_output_iterator();

    explicit function_output_iterator(const UnaryFunction& f);

    /* see below */ operator*();
    function_output_iterator& operator++();
    function_output_iterator& operator++(int);
  private:
    UnaryFunction m_f;     // exposition only
  };



``function_output_iterator`` requirements
.........................................

``UnaryFunction`` must be Assignable and Copy Constructible.  



``function_output_iterator`` models
...................................

``function_output_iterator`` is a model of the Writable and
Incrementable Iterator concepts.



``function_output_iterator`` operations
.......................................

``explicit function_output_iterator(const UnaryFunction& f = UnaryFunction());``

:Effects: Constructs an instance of ``function_output_iterator`` 
  with ``m_f`` constructed from ``f``.


``operator*();``

:Returns: An object ``r`` of unspecified type such that ``r = t``
  is equivalent to ``m_f(t)`` for all ``t``.
  

``function_output_iterator& operator++();``

:Returns: ``*this``


``function_output_iterator& operator++(int);``

:Returns: ``*this``
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

+++++++++++++++++++
 Counting Iterator
+++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract: How would you fill up a vector with the numbers zero
  through one hundred using ``std::copy()``?  The only iterator
  operation missing from builtin integer types is an
  ``operator*()`` that returns the current value of the integer.
  The counting iterator adaptor adds this crucial piece of
  functionality to whatever type it wraps.  One can use the
  counting iterator adaptor not only with integer types, but with
  any incrementable type.

  .. include:: counting_iterator_abstract.rst

.. contents:: Table of Contents

``counting_iterator`` synopsis
..............................

.. include:: counting_iterator_ref.rst
.. include:: make_counting_iterator.rst

.. include:: counting_iterator_eg.rst

.. _iterator-category: iterator_facade.html#iterator-category
.. |iterator-category| replace:: *iterator-category*
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

This example fills an array with numbers and a second array with
pointers into the first array, using ``counting_iterator`` for both
tasks. Finally ``indirect_iterator`` is used to print out the numbers
into the first array via indirection through the second array.

::

    int N = 7;
    std::vector<int> numbers;
    typedef std::vector<int>::iterator n_iter;
    std::copy(boost::counting_iterator<int>(0),
             boost::counting_iterator<int>(N),
             std::back_inserter(numbers));

    std::vector<std::vector<int>::iterator> pointers;
    std::copy(boost::make_counting_iterator(numbers.begin()),
	      boost::make_counting_iterator(numbers.end()),
	      std::back_inserter(pointers));

    std::cout << "indirectly printing out the numbers from 0 to " 
	      << N << std::endl;
    std::copy(boost::make_indirect_iterator(pointers.begin()),
	      boost::make_indirect_iterator(pointers.end()),
	      std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;


The output is::

    indirectly printing out the numbers from 0 to 7
    0 1 2 3 4 5 6 

The source code for this example can be found `here`__.

__ ../example/counting_iterator_example.cpp

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <class BidirectionalIterator>
  reverse_iterator<BidirectionalIterator>n
  make_reverse_iterator(BidirectionalIterator x);

:Returns: An instance of ``reverse_iterator<BidirectionalIterator>``
  with a ``current`` constructed from ``x``.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The filter iterator adaptor creates a view of an iterator range in
which some elements of the range are skipped. A predicate function
object controls which elements are skipped. When the predicate is
applied to an element, if it returns ``true`` then the element is
retained and if it returns ``false`` then the element is skipped
over. When skipping over elements, it is necessary for the filter
adaptor to know when to stop so as to avoid going past the end of the
underlying range. A filter iterator is therefore constructed with pair
of iterators indicating the range of elements in the unfiltered
sequence to be traversed.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The zip iterator provides the ability to parallel-iterate
over several controlled sequences simultaneously. A zip 
iterator is constructed from a tuple of iterators. Moving
the zip iterator moves all the iterators in parallel.
Dereferencing the zip iterator returns a tuple that contains
the results of dereferencing the individual iterators. 
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <class Iterator>
  class reverse_iterator
  {
  public:
    typedef iterator_traits<Iterator>::value_type value_type;
    typedef iterator_traits<Iterator>::reference reference;
    typedef iterator_traits<Iterator>::pointer pointer;
    typedef iterator_traits<Iterator>::difference_type difference_type;
    typedef /* see below */ iterator_category;

    reverse_iterator() {}
    explicit reverse_iterator(Iterator x) ;

    template<class OtherIterator>
    reverse_iterator(
        reverse_iterator<OtherIterator> const& r
      , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0 // exposition
    );
    Iterator const& base() const;
    reference operator*() const;
    reverse_iterator& operator++();
    reverse_iterator& operator--();
  private:
    Iterator m_iterator; // exposition
  };


If ``Iterator`` models Random Access Traversal Iterator and Readable
Lvalue Iterator, then ``iterator_category`` is convertible to
``random_access_iterator_tag``. Otherwise, if
``Iterator`` models Bidirectional Traversal Iterator and Readable
Lvalue Iterator, then ``iterator_category`` is convertible to
``bidirectional_iterator_tag``. Otherwise, ``iterator_category`` is
convertible to ``input_iterator_tag``.



``reverse_iterator`` requirements
.................................

``Iterator`` must be a model of Bidirectional Traversal Iterator.  The
type ``iterator_traits<Iterator>::reference`` must be the type of
``*i``, where ``i`` is an object of type ``Iterator``.



``reverse_iterator`` models
...........................

A specialization of ``reverse_iterator`` models the same iterator
traversal and iterator access concepts modeled by its ``Iterator``
argument.  In addition, it may model old iterator concepts
specified in the following table:

+---------------------------------------+-----------------------------------+
| If ``I`` models                       |then ``reverse_iterator<I>`` models|
+=======================================+===================================+
| Readable Lvalue Iterator,             | Bidirectional Iterator            |
| Bidirectional Traversal Iterator      |                                   |
+---------------------------------------+-----------------------------------+
| Writable Lvalue Iterator,             | Mutable Bidirectional Iterator    |
| Bidirectional Traversal Iterator      |                                   |
+---------------------------------------+-----------------------------------+
| Readable Lvalue Iterator,             | Random Access Iterator            |
| Random Access Traversal Iterator      |                                   |
+---------------------------------------+-----------------------------------+
| Writable Lvalue Iterator,             | Mutable Random Access Iterator    |
| Random Access Traversal Iterator      |                                   |
+---------------------------------------+-----------------------------------+


``reverse_iterator<X>`` is interoperable with
``reverse_iterator<Y>`` if and only if ``X`` is interoperable with
``Y``.

``reverse_iterator`` operations
...............................

In addition to the operations required by the concepts modeled by
``reverse_iterator``, ``reverse_iterator`` provides the following
operations.



``reverse_iterator();``

:Requires: ``Iterator`` must be Default Constructible.
:Effects: Constructs an instance of ``reverse_iterator`` with ``m_iterator`` 
  default constructed.

``explicit reverse_iterator(Iterator x);``

:Effects: Constructs an instance of ``reverse_iterator`` with
    ``m_iterator`` copy constructed from ``x``.


::

    template<class OtherIterator>
    reverse_iterator(
        reverse_iterator<OtherIterator> const& r
      , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0 // exposition
    );

:Requires: ``OtherIterator`` is implicitly convertible to ``Iterator``.
:Effects: Constructs instance of ``reverse_iterator`` whose 
    ``m_iterator`` subobject is constructed from ``y.base()``.



``Iterator const& base() const;``

:Returns: ``m_iterator``


``reference operator*() const;``

:Effects: 

::

    Iterator tmp = m_iterator;
    return *--tmp;


``reverse_iterator& operator++();``

:Effects: ``--m_iterator``
:Returns: ``*this``


``reverse_iterator& operator--();``

:Effects: ``++m_iterator``
:Returns: ``*this``
.. Copyright David Abrahams 2004. Use, modification and distribution is
.. subject to the Boost Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

::

  template <class Dereferenceable>
  struct pointee
  {
      typedef /* see below */ type;
  };

:Requires: For an object ``x`` of type ``Dereferenceable``, ``*x``
  is well-formed.  If ``++x`` is ill-formed it shall neither be
  ambiguous nor shall it violate access control, and
  ``Dereferenceable::element_type`` shall be an accessible type.
  Otherwise ``iterator_traits<Dereferenceable>::value_type`` shall
  be well formed.  [Note: These requirements need not apply to
  explicit or partial specializations of ``pointee``]

``type`` is determined according to the following algorithm, where
``x`` is an object of type ``Dereferenceable``::

  if ( ++x is ill-formed )
  {
      return ``Dereferenceable::element_type``
  }
  else if (``*x`` is a mutable reference to
           std::iterator_traits<Dereferenceable>::value_type)
  {
      return iterator_traits<Dereferenceable>::value_type
  }
  else
  {
      return iterator_traits<Dereferenceable>::value_type const
  }

  :Author:
    `Dean Michael Berris <mailto:me@deanberris.com>`_

:License:
    Distributed under the Boost Software License, Version 1.0
    (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

:Copyright:
    Copyright 2012 Google, Inc.

Function Input Iterator
=======================

The Function Input Iterator allows for creating iterators that encapsulate
a nullary function object and a state object which tracks the number of times
the iterator has been incremented. A Function Input Iterator models the
`InputIterator`_ concept and is useful for creating bounded input iterators.

.. _InputIterator: http://www.sgi.com/tech/stl/InputIterator.html

The Function Input Iterator takes a function that models the Generator_ concept
(which is basically a nullary or 0-arity function object). The first dereference
of the iterator at a given position invokes the generator function and stores
and returns the result; subsequent dereferences at the same position simply
return the same stored result. Incrementing the iterator places it at a new
position, hence a subsequent dereference will generate a new value via another
invokation of the generator function. This ensures the generator function is
invoked precisely when the iterator is requested to return a (new) value.

.. _Generator: http://www.sgi.com/tech/stl/Generator.html

The Function Input Iterator encapsulates a state object which models the
`Incrementable Concept`_ and the EqualityComparable_ Concept. These concepts are
described below as:

.. _EqualityComparable: http://www.sgi.com/tech/stl/EqualityComparable.html

Incrementable Concept
---------------------

A type models the Incrementable Concept when it supports the pre- and post-
increment operators. For a given object ``i`` with type ``I``, the following 
constructs should be valid:

=========  =================  ===========
Construct  Description        Return Type
-----------------------------------------
i++        Post-increment i.  I
++i        Pre-increment i.   I&
=========  =================  ===========

NOTE: An Incrementable type should also be DefaultConstructible_.

.. _DefaultConstructible: http://www.sgi.com/tech/stl/DefaultConstructible.html

Synopsis
--------

::

    namespace {
        template <class Function, class State>
        class function_input_iterator;

        template <class Function, class State>
        typename function_input_iterator<Function, State>
        make_function_input_iterator(Function & f, State s);

        struct infinite;
    }

Function Input Iterator Class
-----------------------------

The class Function Input Iterator class takes two template parameters
``Function`` and ``State``. These two template parameters tell the
Function Input Iterator the type of the function to encapsulate and
the type of the internal state value to hold.

The ``State`` parameter is important in cases where you want to
control the type of the counter which determines whether two iterators 
are at the same state. This allows for creating a pair of iterators which 
bound the range of the invocations of the encapsulated functions.

Examples
--------

The following example shows how we use the function input iterator class
in cases where we want to create bounded (lazy) generated ranges.

::

    struct generator {
        typedef int result_type;
        generator() { srand(time(0)); }
        result_type operator() () const {
            return rand();
        }
    };

    int main(int argc, char * argv[]) {
        generator f;
        copy(
                make_function_input_iterator(f, 0),
                make_function_input_iterator(f, 10),
                ostream_iterator<int>(cout, " ")
            );
        return 0;
    }

Here we can see that we've bounded the number of invocations using an ``int``
that counts from ``0`` to ``10``. Say we want to create an endless stream
of random numbers and encapsulate that in a pair of integers, we can do
it with the ``boost::infinite`` helper class.

::

    copy(
            make_function_input_iterator(f,infinite()),
            make_function_input_iterator(f,infinite()),
            ostream_iterator<int>(cout, " ")
        );
   
Above, instead of creating a huge vector we rely on the STL copy algorithm
to traverse the function input iterator and call the function object f
as it increments the iterator. The special property of ``boost::infinite``
is that equating two instances always yield false -- and that incrementing
an instance of ``boost::infinite`` doesn't do anything. This is an efficient
way of stating that the iterator range provided by two iterators with an
encapsulated infinite state will definitely be infinite.


.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

This example uses ``filter_iterator`` and then
``make_filter_iterator`` to output only the positive integers from an
array of integers. Then ``make_filter_iterator`` is is used to output
the integers greater than ``-2``.

::

    struct is_positive_number {
      bool operator()(int x) { return 0 < x; }
    };

    int main()
    {
      int numbers_[] = { 0, -1, 4, -3, 5, 8, -2 };
      const int N = sizeof(numbers_)/sizeof(int);

      typedef int* base_iterator;
      base_iterator numbers(numbers_);

      // Example using filter_iterator
      typedef boost::filter_iterator<is_positive_number, base_iterator>
	FilterIter;

      is_positive_number predicate;
      FilterIter filter_iter_first(predicate, numbers, numbers + N);
      FilterIter filter_iter_last(predicate, numbers + N, numbers + N);

      std::copy(filter_iter_first, filter_iter_last, std::ostream_iterator<int>(std::cout, " "));
      std::cout << std::endl;

      // Example using make_filter_iterator()
      std::copy(boost::make_filter_iterator<is_positive_number>(numbers, numbers + N),
		boost::make_filter_iterator<is_positive_number>(numbers + N, numbers + N),
		std::ostream_iterator<int>(std::cout, " "));
      std::cout << std::endl;

      // Another example using make_filter_iterator()
      std::copy(
	  boost::make_filter_iterator(
	      std::bind2nd(std::greater<int>(), -2)
	    , numbers, numbers + N)

	, boost::make_filter_iterator(
	      std::bind2nd(std::greater<int>(), -2)
	    , numbers + N, numbers + N)

	, std::ostream_iterator<int>(std::cout, " ")
      );

      std::cout << std::endl;

      return boost::exit_success;
    }


The output is::

    4 5 8 
    4 5 8 
    0 -1 4 5 8 


The source code for this example can be found `here`__.

__ ../example/filter_iterator_example.cpp
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

``iterator_facade`` is a base class template that implements the
interface of standard iterators in terms of a few core functions
and associated types, to be supplied by a derived iterator class.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Example
.......

This example prints an array of characters, using
``indirect_iterator`` to access the array of characters through an
array of pointers. Next ``indirect_iterator`` is used with the
``transform`` algorithm to copy the characters (incremented by one) to
another array. A constant indirect iterator is used for the source and
a mutable indirect iterator is used for the destination. The last part
of the example prints the original array of characters, but this time
using the ``make_indirect_iterator`` helper function.


::

    char characters[] = "abcdefg";
    const int N = sizeof(characters)/sizeof(char) - 1; // -1 since characters has a null char
    char* pointers_to_chars[N];                        // at the end.
    for (int i = 0; i < N; ++i)
      pointers_to_chars[i] = &characters[i];

    // Example of using indirect_iterator

    boost::indirect_iterator<char**, char>
      indirect_first(pointers_to_chars), indirect_last(pointers_to_chars + N);

    std::copy(indirect_first, indirect_last, std::ostream_iterator<char>(std::cout, ","));
    std::cout << std::endl;


    // Example of making mutable and constant indirect iterators

    char mutable_characters[N];
    char* pointers_to_mutable_chars[N];
    for (int j = 0; j < N; ++j)
      pointers_to_mutable_chars[j] = &mutable_characters[j];

    boost::indirect_iterator<char* const*> mutable_indirect_first(pointers_to_mutable_chars),
      mutable_indirect_last(pointers_to_mutable_chars + N);
    boost::indirect_iterator<char* const*, char const> const_indirect_first(pointers_to_chars),
      const_indirect_last(pointers_to_chars + N);

    std::transform(const_indirect_first, const_indirect_last,
		   mutable_indirect_first, std::bind1st(std::plus<char>(), 1));

    std::copy(mutable_indirect_first, mutable_indirect_last,
	      std::ostream_iterator<char>(std::cout, ","));
    std::cout << std::endl;


    // Example of using make_indirect_iterator()

    std::copy(boost::make_indirect_iterator(pointers_to_chars), 
	      boost::make_indirect_iterator(pointers_to_chars + N),
	      std::ostream_iterator<char>(std::cout, ","));
    std::cout << std::endl;


The output is::

    a,b,c,d,e,f,g,
    b,c,d,e,f,g,h,
    a,b,c,d,e,f,g,


The source code for this example can be found `here`__.

__ ../example/indirect_iterator_example.cpp

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The permutation iterator adaptor provides a permuted view of a given
range. That is, the view includes every element of the given range but
in a potentially different order.

.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

++++++++++++++++++++
 Transform Iterator
++++++++++++++++++++

:Author: David Abrahams, Jeremy Siek, Thomas Witt
:Contact: dave@boost-consulting.com, jsiek@osl.iu.edu, witt@ive.uni-hannover.de
:organization: `Boost Consulting`_, Indiana University `Open Systems
               Lab`_, University of Hanover `Institute for Transport
               Railway Operation and Construction`_
:date: $Date: 2006-09-11 15:27:29 -0700 (Mon, 11 Sep 2006) $
:copyright: Copyright David Abrahams, Jeremy Siek, and Thomas Witt 2003. 

.. _`Boost Consulting`: http://www.boost-consulting.com
.. _`Open Systems Lab`: http://www.osl.iu.edu
.. _`Institute for Transport Railway Operation and Construction`: http://www.ive.uni-hannover.de

:abstract:

  .. include:: transform_iterator_abstract.rst

.. contents:: Table of Contents

``transform_iterator`` synopsis
...............................

.. include:: transform_iterator_ref.rst
.. include:: make_transform_iterator.rst
.. include:: transform_iterator_eg.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. Version 1.3 of this document was accepted for TR1

::

  template <class UnaryFunction,
            class Iterator, 
            class Reference = use_default, 
            class Value = use_default>
  class transform_iterator
  {
  public:
    typedef /* see below */ value_type;
    typedef /* see below */ reference;
    typedef /* see below */ pointer;
    typedef iterator_traits<Iterator>::difference_type difference_type;
    typedef /* see below */ iterator_category;

    transform_iterator();
    transform_iterator(Iterator const& x, UnaryFunction f);

    template<class F2, class I2, class R2, class V2>
    transform_iterator(
          transform_iterator<F2, I2, R2, V2> const& t
        , typename enable_if_convertible<I2, Iterator>::type* = 0      // exposition only
        , typename enable_if_convertible<F2, UnaryFunction>::type* = 0 // exposition only
    );
    UnaryFunction functor() const;
    Iterator const& base() const;
    reference operator*() const;
    transform_iterator& operator++();
    transform_iterator& operator--();
  private:
    Iterator m_iterator; // exposition only
    UnaryFunction m_f;   // exposition only
  };


If ``Reference`` is ``use_default`` then the ``reference`` member of
``transform_iterator`` is
``result_of<const UnaryFunction(iterator_traits<Iterator>::reference)>::type``.
Otherwise, ``reference`` is ``Reference``.

If ``Value`` is ``use_default`` then the ``value_type`` member is
``remove_cv<remove_reference<reference> >::type``.  Otherwise,
``value_type`` is ``Value``.


If ``Iterator`` models Readable Lvalue Iterator and if ``Iterator``
models Random Access Traversal Iterator, then ``iterator_category`` is
convertible to ``random_access_iterator_tag``. Otherwise, if
``Iterator`` models Bidirectional Traversal Iterator, then
``iterator_category`` is convertible to
``bidirectional_iterator_tag``.  Otherwise ``iterator_category`` is
convertible to ``forward_iterator_tag``. If ``Iterator`` does not
model Readable Lvalue Iterator then ``iterator_category`` is
convertible to ``input_iterator_tag``.


``transform_iterator`` requirements
...................................

The type ``UnaryFunction`` must be Assignable, Copy Constructible, and
the expression ``f(*i)`` must be valid where ``f`` is a const object of
type ``UnaryFunction``, ``i`` is an object of type ``Iterator``, and
where the type of ``f(*i)`` must be
``result_of<const UnaryFunction(iterator_traits<Iterator>::reference)>::type``.

The argument ``Iterator`` shall model Readable Iterator.  


``transform_iterator`` models
.............................

The resulting ``transform_iterator`` models the most refined of the
following that is also modeled by ``Iterator``.

  * Writable Lvalue Iterator if ``transform_iterator::reference`` is a non-const reference. 

  * Readable Lvalue Iterator if ``transform_iterator::reference`` is a const reference.

  * Readable Iterator otherwise. 

The ``transform_iterator`` models the most refined standard traversal
concept that is modeled by the ``Iterator`` argument.

If ``transform_iterator`` is a model of Readable Lvalue Iterator then
it models the following original iterator concepts depending on what
the ``Iterator`` argument models.

+-----------------------------------+---------------------------------------+
| If ``Iterator`` models            | then ``transform_iterator`` models    |
+===================================+=======================================+
| Single Pass Iterator              | Input Iterator                        |
+-----------------------------------+---------------------------------------+
| Forward Traversal Iterator        | Forward Iterator                      |
+-----------------------------------+---------------------------------------+
| Bidirectional Traversal Iterator  | Bidirectional Iterator                |
+-----------------------------------+---------------------------------------+
| Random Access Traversal Iterator  | Random Access Iterator                |
+-----------------------------------+---------------------------------------+

If ``transform_iterator`` models Writable Lvalue Iterator then it is a
mutable iterator (as defined in the old iterator requirements).

``transform_iterator<F1, X, R1, V1>`` is interoperable with
``transform_iterator<F2, Y, R2, V2>`` if and only if ``X`` is
interoperable with ``Y``.



``transform_iterator`` operations
.................................

In addition to the operations required by the concepts modeled by
``transform_iterator``, ``transform_iterator`` provides the following
operations.


``transform_iterator();``

:Returns: An instance of ``transform_iterator`` with ``m_f``
  and ``m_iterator`` default constructed.


``transform_iterator(Iterator const& x, UnaryFunction f);``

:Returns: An instance of ``transform_iterator`` with ``m_f``
  initialized to ``f`` and ``m_iterator`` initialized to ``x``.


::

    template<class F2, class I2, class R2, class V2>
    transform_iterator(
          transform_iterator<F2, I2, R2, V2> const& t
        , typename enable_if_convertible<I2, Iterator>::type* = 0      // exposition only
        , typename enable_if_convertible<F2, UnaryFunction>::type* = 0 // exposition only
    );

:Returns: An instance of ``transform_iterator`` with ``m_f``
  initialized to ``t.functor()`` and ``m_iterator`` initialized to
  ``t.base()``.
:Requires: ``OtherIterator`` is implicitly convertible to ``Iterator``.


``UnaryFunction functor() const;``

:Returns: ``m_f``


``Iterator const& base() const;``

:Returns: ``m_iterator``


``reference operator*() const;``

:Returns: ``m_f(*m_iterator)``


``transform_iterator& operator++();``

:Effects: ``++m_iterator``
:Returns: ``*this``


``transform_iterator& operator--();``

:Effects: ``--m_iterator``
:Returns: ``*this``

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Lvalue Iterator Concept
.......................

The *Lvalue Iterator* concept adds the requirement that the return
type of ``operator*`` type be a reference to the value type of the
iterator.

+-------------------------------------------------------------+
| Lvalue Iterator Requirements                                |
+-------------+-----------+-----------------------------------+
|Expression   |Return Type|Note/Assertion                     |
+=============+===========+===================================+
|``*a``       | ``T&``    |``T`` is *cv*                      |
|             |           |``iterator_traits<X>::value_type`` |
|             |           |where *cv* is an optional          |
|             |           |cv-qualification.                  |
|             |           |pre: ``a`` is                      |
|             |           |dereferenceable. If ``a            |
|             |           |== b`` then ``*a`` is              |
|             |           |equivalent to ``*b``.              |
+-------------+-----------+-----------------------------------+
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

``counting_iterator`` adapts an object by adding an ``operator*`` that
returns the current value of the object. All other iterator operations
are forwarded to the adapted object.

================================
|(logo)|__ Dynamic Property Maps
================================

.. Copyright 2004-5 The Trustees of Indiana University.
 
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

.. |(logo)| image:: ../../../boost.png
   :align: middle
   :alt: Boost

__ ../../../index.htm

Summary
-------
The dynamic property map interfaces provides access to a collection of
property maps through a dynamically-typed interface. An algorithm can
use it to manipulate property maps without knowing their key or
value types at compile-time. Type-safe codes can use dynamic property
maps to interface more easily and completely with scripting languages
and other text-based representations of key-value data.

.. contents::

Introduction
------------
The Boost Property Map library specifies statically type-safe
interfaces through which key-value pairs can be manipulated by 
generic algorithms. Typically, an algorithm that uses property maps is
parameterized on the types of the property maps it uses, and it
manipulates them using the interfaces specified by the
Boost Property Map Library.
 
The following generic function illustrates property map basics.


::

  template <typename AgeMap, typename GPAMap>
  void 
  manipulate_freds_info(AgeMap ages, GPAMap gpas) {

    typedef typename boost::property_traits<AgeMap>::key_type name_type;
    typedef typename boost::property_traits<AgeMap>::value_type age_type;
    typedef typename boost::property_traits<GPAMap>::value_type gpa_type;

    name_type fred = "Fred";

    age_type old_age = get(ages, fred);
    gpa_type old_gpa = get(gpas, fred);

    std::cout << "Fred's old age: " << old_age << "\n"
	      << "Fred's old gpa: " << old_gpa << "\n";

    age_type new_age = 18;
    gpa_type new_gpa = 3.9;
    put(ages, fred, new_age);
    put(gpas, fred, new_gpa);
  }

The function is parameterized on two property map types, ``AgeMap`` and
``GPAMap``, and takes a value parameter for each of those types.  The
function uses the ``property_traits`` interface to ascertain, at
compile-time, the value and key types of the property maps.  The code
then retrieves Fred's old information, using the ``get`` function, and
updates it using the ``put`` function. The ``get`` function is required by the
Readable Property Map concept and both ``get`` and ``put`` are required by the
Read/Write Property Map concept.

The above function not only requires the two type parameters to model
property map concepts, but also makes some extra assumptions.
``AgeMap`` and ``GPAMap`` must have the same key type, and that type must be
constructable from a string.  Furthermore, ``AgeMap``'s value type must be
constructable from an ``int``.  Although these requirements are not
explicitly stated, they are statically checked during compilation and
failure to meet them yields compile-time errors.

Although the static typing of property map interfaces usually provides
desirable compile-time safety, some algorithms require a more dynamic
interface to property maps. For example, the Boost Graph Library (BGL)
provides functions that can initialize a graph by interpreting the
contents of a textual graph description (i.e. a GraphML file).  Such
general-purpose graph description languages can specify an arbitrary
number of edge and vertex properties, using strings to represent the
key-value pairs.  A graph reader function should capture these
arbitrary properties, but since function templates can only be
parameterized on a fixed number of property maps, the traditional
techniques for handling property maps do not suffice to implement them.

Dynamic property maps specifically address the need for an interface
to property maps whose checking is delayed to runtime.  Several
components combine to provide support for dynamic property maps. The
``dynamic_properties`` class collects a
group of heterogenous objects that model concepts from
the Boost Property Map library. Each property map is assigned a
string-based key when it is added to the collection, and it can be
addressed using that key.  Internally, ``dynamic_properties`` adapts
each contained property map with the dynamic property map interface,
which provides ``get`` and ``put`` functions that
can be called using values of any type that meets a few requirements.
Internally, the dynamic property map converts key and value pairs to
meet the requirements of the underlying property map or signals a
runtime exception if it cannot.


"Fred's Info" Revisited
~~~~~~~~~~~~~~~~~~~~~~~
Here's what the example above looks like using the
``dynamic_properties`` interface:

::

  void manipulate_freds_info(boost::dynamic_properties& properties)
  {
    using boost::get;
    std::string fred = "Fred";

    int old_age = get<int>("age", properties, fred);
    std::string old_gpa = get("gpa", properties, fred);

    std::cout << "Fred's old age: " << old_age << "\n"
	      << "Fred's old gpa: " << old_gpa << "\n";

    std::string new_age = "18";
    double new_gpa = 3.9;
    put("age",properties,fred,new_age);
    put("gpa",properties,fred,new_gpa);
  }

The new function is not a template parameterized on the property map
types but instead a concrete function that takes a ``dynamic_properties``
object.  Furthermore, the code no longer makes reference to key or
value types: keys and values are represented with strings.
Nonetheless the function still uses non-string types where they are
useful.  For instance, Fred's old age is represented using an ``int``.
It's value is retreived by calling ``get`` with a
type parameter, which determines its return type.  Finally, the
``get`` and ``put`` functions are each supplied a string-based key that
differs depending on the property of concern.  

Here's an example of how the above function might be called.

::

  int main()
  {
    using boost::get;

    // build property maps using associative_property_map
    std::map<std::string, int> name2age;
    std::map<std::string, double> name2gpa;
    boost::associative_property_map< std::map<std::string, int> >
      age_map(name2age);
    boost::associative_property_map< std::map<std::string, double> >
      gpa_map(name2gpa);

    std::string fred("Fred");
    // add key-value information
    name2age.insert(make_pair(fred,17));
    name2gpa.insert(make_pair(fred,2.7));

    // build and populate dynamic interface
    boost::dynamic_properties properties;
    properties.property("age",age_map);
    properties.property("gpa",gpa_map);

    manipulate_freds_info(properties);

    std::cout << "Fred's age: " << get(age_map,fred) << "\n"
	      << "Fred's gpa: " << get(gpa_map,fred) << "\n";	    
  }

The code first creates two property maps using ``std::map`` and the
``associative_property_map`` adaptor.  After initializing the
property maps with key-value data, it constructs a
``dynamic_properties`` object and adds to it both property maps,
keyed on the strings "age" and "gpa".  Finally ``manipulate_freds_info``
is passed the ``dynamic_properties`` object and the results of its changes are
displayed.  

As shown above, the ``dynamic_properties`` object provides, where needed, a
dynamically-typed interface to property maps yet preserves the static
typing of property map uses elsewhere in an application.

Reference
---------
::

  class dynamic_properties

The ``dynamic_properties`` class provides a dynamically-typed interface to
a set of property maps. To use it, one must populate
an object of this class with property maps using the ``property`` member
function.

Member Functions
~~~~~~~~~~~~~~~~

::

  dynamic_properties()
  dynamic_properties(
    const boost::function<
      boost::shared_ptr<dynamic_property_map> (
	const std::string&, const boost::any&, const boost::any&)
      >& fn)

A ``dynamic_properties`` object can be constructed with a function object
that, when called, creates a new property map.  The library provides the 
``ignore_other_properties`` function object, which lets the ``dynamic_properties`` object ignore any properties that it hasn't been prepared to record.
If an attempt is made
to ``put`` a key-value pair to a nonexistent ``dynamic_properties`` key,
then this function is called with the ``dynamic_properties`` key and the
intended property key and value .  If ``dynamic_properties`` is
default-constructed, such a ``put`` attempt throws 
``property_not_found``. 


::

  template<typename PropertyMap>
  dynamic_properties& 
  property(const std::string& name, PropertyMap property_map)

This member function adds a property map to the set of maps contained,
using ``name`` as its key.

Requirements: ``PropertyMap`` must model Readable Property Map or
Read/Write Property Map.

::

  void insert(const std::string& name, boost::shared_ptr<dynamic_property_map> pm)

This member function directly adds a ``dynamic_property_map``
to the collection, using ``name`` as its key.

::

  iterator begin()
  const_iterator begin() const

This member function returns an iterator over the set of property maps
held by the ``dynamic_properties`` object.

::

  iterator end()
  const_iterator end() const

This member function returns a terminal iterator over the set of
dynamic property maps held by the ``dynamic_properties`` object.  It is used to
terminate traversals over the set of dynamic property maps

::

  iterator lower_bound(const std::string& name) 

This member function returns an iterator that points to the first
property map whose ``dynamic_properties`` key is ``name``.  
Bear in mind that multiple property maps may have the same
``dynamic_properties`` key, so long as their property map key types differ.

Invariant: The range [ lower_bound(name), end() ) contains every
property map that has name for its ``dynamic_properties`` key.

Free functions
~~~~~~~~~~~~~~

::

  boost::shared_ptr<boost::dynamic_property_map> 
  ignore_other_properties(const std::string&,
                          const boost::any&,
                          const boost::any&)

When passed to the ``dynamic_properties`` constructor, this function
allows the ``dynamic_properties`` object to disregard attempts to put
values to unknown keys without signaling an error.

::

  template<typename Key, typename Value>
  bool put(const std::string& name, dynamic_properties& dp, const Key& key, 
           const Value& value)

This function adds a key-value pair to the property map with the
matching name and key type. If no matching property map is found,
behavior depends on the availability of a property map generator.  If
a property map generator was supplied when the ``dynamic_properties``
object was constructed, then that function is used to create a new
property map.  If the generator fails to generate a property map
(returns a null ``shared_ptr``), then the ``put`` function returns
``false``.  If, on the other hand, the ``dynamic_properties`` object
has no property map generator (meaning it was default-constructed),
then ``property_not_found`` is thrown. If a candidate property map is
found but it does not support ``put``, ``dynamic_const_put_error`` is
thrown.

::

  template<typename Value, typename Key>
  Value get(const std::string& name, const dynamic_properties& dp, 
            const Key& key)

This function gets the value from the property-map whose namee is
given and whose key type matches. If ``Value`` is ``std::string``, then the
property map's value type must either be ``std::string`` or model
OutputStreamable.  In the latter case, the ``get`` function converts the
value to a string.  If no matching property map is found,
``dynamic_get_failure`` is thrown.


=============================================================================

::

  class dynamic_property_map

This class describes the interface used by ``dynamic_properties`` to
interact with a user's property maps polymorphically. 

::

  boost::any get(const any& key)

Given a representation of a key, return the value associated with that key. 

Requirement:
1) The object passed as the key must be convertible to a value of the
map's key type. Details of that conversion are unspecified.
2) For this expression to be valid, the key must be
associated with some value, otherwise the result is undefined.

::

  std::string get_string(const any& key) 

Given a representation of a key, return the string representation
of the value associated with that key.

Requirements:
1) The object passed as the key must be convertible to the
property map's key type. Details of that conversion are unspecified.
2) For this expression to be valid, the key must be
associated with some value, otherwise the result is undefined.
3) The value type of the property map must model Output Streamable.

::

  void put(const any& key, const any& value) 

Given a representation of a key and a representation of a value, the
key and value are associated in the property map.

Requirements:
1) The object passed as the key must be convertible to the
property map's key type. Details of that conversion are unspecified.
2) The object passed as the value must be convertible to the
property map's value type. Details of that conversion are unspecified.
3) The property map need not support this member function, in which
case an error will be signaled.  This is the runtime analogue of the
Readable Property Map concept.

::

  const std::type_info& key() const 

Returns a ``type_info`` object that represents the property map's key type.

::

  const std::type_info& value() const 

Returns a ``type_info`` object that represents the property map's value type.


Exceptions
~~~~~~~~~~

::

  struct dynamic_property_exception : public std::exception {
    virtual ~dynamic_property_exception() throw() {}
  };

  struct property_not_found : public std::exception {
    std::string property;
    property_not_found(const std::string& property);
    virtual ~property_not_found() throw();

    const char* what() const throw();
  };

  struct dynamic_get_failure : public std::exception {
    std::string property;
    dynamic_get_failure(const std::string& property);
    virtual ~dynamic_get_failure() throw();

    const char* what() const throw();
  };

  struct dynamic_const_put_error  : public std::exception {
    virtual ~dynamic_const_put_error() throw();

    const char* what() const throw();
  };


Under certain circumstances, calls to ``dynamic_properties`` member
functions will throw one of the above exceptions.  The three concrete
exceptions can all be caught using the general
``dynamic_property_exception`` moniker when greater precision is not
needed.  In addition, all of the above exceptions derive from the
standard ``std::exception`` for even more generalized error handling.
The specific circumstances that result in these exceptions are
described above.
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

==============================================
|Logo| Dijkstra's Single-Source Shortest Paths
==============================================

::

  // named parameter version
  template <typename Graph, typename P, typename T, typename R>
  void
  dijkstra_shortest_paths(Graph& g,
    typename graph_traits<Graph>::vertex_descriptor s,
    const bgl_named_params<P, T, R>& params);

  // non-named parameter version
  template <typename Graph, typename DijkstraVisitor, 
            typename PredecessorMap, typename DistanceMap,
            typename WeightMap, typename VertexIndexMap, typename CompareFunction, typename CombineFunction, 
            typename DistInf, typename DistZero>
  void dijkstra_shortest_paths
    (const Graph& g,
     typename graph_traits<Graph>::vertex_descriptor s, 
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
     VertexIndexMap index_map,
     CompareFunction compare, CombineFunction combine, DistInf inf, DistZero zero,
     DijkstraVisitor vis);

The ``dijkstra_shortest_paths()`` function solves the single-source
shortest paths problem on a weighted, undirected or directed
distributed graph. There are two implementations of distributed
Dijkstra's algorithm, which offer different performance
tradeoffs. Both are accessible via the ``dijkstra_shortest_paths()``
function (for compatibility with sequential BGL programs). The
distributed Dijkstra algorithms are very similar to their sequential
counterparts. Only the differences are highlighted here; please refer
to the `sequential Dijkstra implementation`_ for additional
details. The best-performing implementation for most cases is the
`Delta-Stepping algorithm`_; however, one can also employ the more
conservative `Crauser et al.'s algorithm`_ or the simlistic  `Eager
Dijkstra's algorithm`_. 

.. contents::

Where Defined
-------------
<``boost/graph/dijkstra_shortest_paths.hpp``>

Parameters 
----------

All parameters of the `sequential Dijkstra implementation`_ are
supported and have essentially the same meaning. The distributed
Dijkstra implementations introduce a new parameter that allows one to
select `Eager Dijkstra's algorithm`_ and control the amount of work it
performs. Only differences and new parameters are documented here.

IN: ``Graph& g``
  The graph type must be a model of `Distributed Graph`_. 


IN: ``vertex_descriptor s``
  The start vertex must be the same in every process.


OUT: ``predecessor_map(PredecessorMap p_map)``
  The predecessor map must be a `Distributed Property Map`_ or 
  ``dummy_property_map``, although only the local portions of the map
  will be written. 

  **Default:** ``dummy_property_map``


UTIL/OUT: ``distance_map(DistanceMap d_map)``
  The distance map must be either a `Distributed Property Map`_ or
  ``dummy_property_map``. It will be given the ``vertex_distance``
  role. 


IN: ``visitor(DijkstraVisitor vis)``
  The visitor must be a distributed Dijkstra visitor. The suble differences
  between sequential and distributed Dijkstra visitors are discussed in the
  section `Visitor Event Points`_.


UTIL/OUT: ``color_map(ColorMap color)``
  The color map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose colors must monotonically
  darken (white -> gray -> black). The default value is a distributed
  ``iterator_property_map`` created from a ``std::vector`` of
  ``default_color_type``. 


IN: ``lookahead(distance_type look)``

  When this parameter is supplied, the implementation will use the
  `Eager Dijkstra's algorithm`_ with the given lookahead value.
  Lookahead permits distributed Dijkstra's algorithm to speculatively
  process vertices whose shortest distance from the source may not
  have been found yet. When the distance found is the shortest
  distance, parallelism is improved and the algorithm may terminate
  more quickly. However, if the distance is not the shortest distance,
  the vertex will need to be reprocessed later, resulting in more
  work.

  The type ``distance_type`` is the value type of the ``DistanceMap``
  property map. It is a nonnegative value specifying how far ahead
  Dijkstra's algorithm may process values.

  **Default:** no value (lookahead is not employed; uses `Crauser et
  al.'s algorithm`_).

Visitor Event Points
--------------------
The `Dijkstra Visitor`_ concept defines 7 event points that will be
triggered by the `sequential Dijkstra implementation`_. The distributed
Dijkstra retains these event points, but the sequence of events
triggered and the process in which each event occurs will change
depending on the distribution of the graph, lookahead, and edge
weights. 

``initialize_vertex(s, g)``
  This will be invoked by every process for each local vertex.


``discover_vertex(u, g)``
  This will be invoked each type a process discovers a new vertex
  ``u``. Due to incomplete information in distributed property maps,
  this event may be triggered many times for the same vertex ``u``.


``examine_vertex(u, g)``
  This will be invoked by the process owning the vertex ``u``. This
  event may be invoked multiple times for the same vertex when the
  graph contains negative edges or lookahead is employed. 


``examine_edge(e, g)``
  This will be invoked by the process owning the source vertex of
  ``e``. As with ``examine_vertex``, this event may be invoked
  multiple times for the same edge.


``edge_relaxed(e, g)``
  Similar to ``examine_edge``, this will be invoked by the process
  owning the source vertex and may be invoked multiple times (even
  without lookahead or negative edges).


``edge_not_relaxed(e, g)``
  Similar to ``edge_relaxed``. Some ``edge_not_relaxed`` events that
  would be triggered by sequential Dijkstra's will become
  ``edge_relaxed`` events in distributed Dijkstra's algorithm. 


``finish_vertex(e, g)``
  See documentation for ``examine_vertex``. Note that a "finished"
  vertex is not necessarily finished if lookahead is permitted or
  negative edges exist in the graph.


Crauser et al.'s algorithm
--------------------------

::

  namespace graph {
    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap, typename WeightMap,
             typename IndexMap, typename ColorMap, typename Compare,
             typename Combine, typename DistInf, typename DistZero>
    void
    crauser_et_al_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
       IndexMap index_map, ColorMap color_map,
       Compare compare, Combine combine, DistInf inf, DistZero zero,
       DijkstraVisitor vis);

    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap, typename WeightMap>
    void
    crauser_et_al_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance, WeightMap weight);

    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap>
    void
    crauser_et_al_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance);
  }

The formulation of Dijkstra's algorithm by Crauser, Mehlhorn, Meyer,
and Sanders [CMMS98a]_ improves the scalability of parallel Dijkstra's
algorithm by increasing the number of vertices that can be processed
in a given superstep. This algorithm adapts well to various graph
types, and is a simple algorithm to use, requiring no additional user
input to achieve reasonable performance. The disadvantage of this
algorithm is that the implementation is required to manage three
priority queues, which creates a large amount of work at each node.

This algorithm is used by default in distributed
``dijkstra_shortest_paths()``. 

Where Defined
~~~~~~~~~~~~~
<``boost/graph/distributed/crauser_et_al_shortest_paths.hpp``>

Complexity
~~~~~~~~~~
This algorithm performs *O(V log V)* work in *d + 1* BSP supersteps,
where *d* is at most *O(V)* but is generally much smaller. On directed
Erdos-Renyi graphs with edge weights in [0, 1), the expected number of
supersteps *d* is *O(n^(1/3))* with high probability.

Performance
~~~~~~~~~~~
The following charts illustrate the performance of the Parallel BGL implementation of Crauser et al.'s
algorithm on graphs with edge weights uniformly selected from the
range *[0, 1)*.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeSparse&columns=4
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeSparse&columns=4&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeDense&columns=4
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeDense&columns=4&speedup=1


Eager Dijkstra's algorithm
--------------------------

::

  namespace graph {
    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap, typename WeightMap,
             typename IndexMap, typename ColorMap, typename Compare,
             typename Combine, typename DistInf, typename DistZero>
    void
    eager_dijkstra_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance, 
       typename property_traits<DistanceMap>::value_type lookahead,
       WeightMap weight, IndexMap index_map, ColorMap color_map,
       Compare compare, Combine combine, DistInf inf, DistZero zero,
       DijkstraVisitor vis);

    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap, typename WeightMap>
    void
    eager_dijkstra_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance, 
       typename property_traits<DistanceMap>::value_type lookahead,
       WeightMap weight);

    template<typename DistributedGraph, typename DijkstraVisitor,
             typename PredecessorMap, typename DistanceMap>
    void
    eager_dijkstra_shortest_paths
      (const DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       PredecessorMap predecessor, DistanceMap distance,
       typename property_traits<DistanceMap>::value_type lookahead);
  }

In each superstep, parallel Dijkstra's algorithm typically only
processes nodes whose distances equivalent to the global minimum
distance, because these distances are guaranteed to be correct. This
variation on the algorithm allows the algorithm to process all
vertices whose distances are within some constant value of the
minimum distance. The value is called the "lookahead" value and is
provided by the user as the fifth parameter to the function. Small
values of the lookahead parameter will likely result in limited
parallelization opportunities, whereas large values will expose more
parallelism but may introduce (non-infinite) looping and result in
extra work. The optimal value for the lookahead parameter depends on
the input graph; see [CMMS98b]_ and [MS98]_.

This algorithm will be used by ``dijkstra_shortest_paths()`` when it
is provided with a lookahead value.

Where Defined
~~~~~~~~~~~~~
<``boost/graph/distributed/eager_dijkstra_shortest_paths.hpp``>

Complexity
~~~~~~~~~~
This algorithm performs *O(V log V)* work in *d
+ 1* BSP supersteps, where *d* is at most *O(V)* but may be smaller
depending on the lookahead value. the algorithm may perform more work
when a large lookahead is provided, because vertices will be
reprocessed. 

Performance
~~~~~~~~~~~
The performance of the eager Dijkstra's algorithm varies greatly
depending on the lookahead value. The following charts illustrate the
performance of the Parallel BGL on graphs with edge weights uniformly
selected from the range *[0, 1)* and a constant lookahead of 0.1.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeSparse&columns=5
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeSparse&columns=5&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeDense&columns=5
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?cluster=Odin&generator=ER,SF,SW&dataset=TimeDense&columns=5&speedup=1

Delta-Stepping algorithm
--------------------------

::

  namespace boost { namespace graph { namespace distributed {

    template <typename Graph, typename PredecessorMap, 
              typename DistanceMap, typename WeightMap>
    void delta_stepping_shortest_paths
      (const Graph& g,
       typename graph_traits<Graph>::vertex_descriptor s, 
       PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
       typename property_traits<WeightMap>::value_type delta)


    template <typename Graph, typename PredecessorMap, 
              typename DistanceMap, typename WeightMap>
    void delta_stepping_shortest_paths
      (const Graph& g,
       typename graph_traits<Graph>::vertex_descriptor s, 
       PredecessorMap predecessor, DistanceMap distance, WeightMap weight)
    }

  } } } 


The delta-stepping algorithm [MS98]_ is another variant of the parallel
Dijkstra algorithm. Like the eager Dijkstra algorithm, it employs a
lookahead (``delta``) value that allows processors to process vertices
before we are guaranteed to find their minimum distances, permitting
more parallelism than a conservative strategy. Delta-stepping also
introduces a multi-level bucket data structure that provides more
relaxed ordering constraints than the priority queues employed by the
other Dijkstra variants, reducing the complexity of insertions,
relaxations, and removals from the central data structure. The
delta-stepping algorithm is the best-performing of the Dijkstra
variants.

The lookahead value ``delta`` determines how large each of the
"buckets" within the delta-stepping queue will be, where the ith
bucket contains edges within tentative distances between ``delta``*i
and ``delta``*(i+1). ``delta`` must be a positive value. When omitted,
``delta`` will be set to the maximum edge weight divided by the
maximum degree.

Where Defined
~~~~~~~~~~~~~
<``boost/graph/distributed/delta_stepping_shortest_paths.hpp``>

Example
-------
See the separate `Dijkstra example`_.


Bibliography
------------

.. [CMMS98a] Andreas Crauser, Kurt Mehlhorn, Ulrich Meyer, and Peter Sanders. A
  Parallelization of Dijkstra's Shortest Path Algorithm. In
  *Mathematical Foundations of Computer Science (MFCS)*, volume 1450 of
  Lecture Notes in Computer Science, pages 722--731, 1998. Springer.

.. [CMMS98b] Andreas Crauser, Kurt Mehlhorn, Ulrich Meyer, and Peter
  Sanders. Parallelizing Dijkstra's shortest path algorithm. Technical
  report, MPI-Informatik, 1998. 

.. [MS98] Ulrich Meyer and Peter Sanders. Delta-stepping: A parallel
  shortest path algorithm. In *6th ESA*, LNCS. Springer, 1998.

-----------------------------------------------------------------------------

Copyright (C) 2004, 2005, 2006, 2007, 2008 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _sequential Dijkstra implementation: http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html
.. _distributed breadth-first search: breadth_first_search.html
.. _Distributed Graph: DistributedGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. _Dijkstra Visitor: http://www.boost.org/libs/graph/doc/DijkstraVisitor.html
.. _Dijkstra example: dijkstra_example.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| Connected Components
===========================

::
  
  template<typename Graph, typename ComponentMap>
  inline typename property_traits<ComponentMap>::value_type
  strong_components( const Graph& g, ComponentMap c);

  namespace graph {
    template<typename Graph, typename VertexComponentMap>
    void
    fleischer_hendrickson_pinar_strong_components(const Graph& g, VertexComponentMap r);

    template<typename Graph, typename ReverseGraph, 
             typename ComponentMap, typename IsoMapFR, typename IsoMapRF>
    inline typename property_traits<ComponentMap>::value_type
    fleischer_hendrickson_pinar_strong_components(const Graph& g, 
                                                  ComponentMap c,
                                                  const ReverseGraph& gr, 
                                                  IsoMapFR fr, IsoMapRF rf);
  }
    
The ``strong_components()`` function computes the strongly connected
components of a directed graph.  The distributed strong components
algorithm uses the `sequential strong components`_ algorithm to
identify components local to a processor.  The distributed portion of
the algorithm is built on the `distributed breadth first search`_
algorithm and is based on the work of Fleischer, Hendrickson, and
Pinar [FHP00]_. The interface is a superset of the interface to the
BGL `sequential strong components`_ algorithm. The number of
strongly-connected components in the graph is returned to all
processes. 

The distributed strong components algorithm works on both ``directed``
and ``bidirectional`` graphs.  In the bidirectional case, a reverse
graph adapter is used to produce the required reverse graph.  In 
the directed case, a separate graph is constructed in which all the
edges are reversed.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/strong_components.hpp``>

also accessible from

<``boost/graph/strong_components.hpp``>

Parameters
----------

IN:  ``const Graph& g``
  The graph type must be a model of `Distributed Graph`_.  The graph
  type must also model the `Incidence Graph`_ and be directed.

OUT:  ``ComponentMap c``
  The algorithm computes how many strongly connected components are in the
  graph, and assigns each component an integer label.  The algorithm
  then records to which component each vertex in the graph belongs by
  recording the component number in the component property map.  The
  ``ComponentMap`` type must be a `Distributed Property Map`_.  The
  value type must be the ``vertices_size_type`` of the graph.  The key
  type must be the graph's vertex descriptor type.

UTIL:  ``VertexComponentMap r``
  The algorithm computes a mapping from each vertex to the
  representative of the strong component, stored in this property map.
  The ``VertexComponentMap`` type must be a `Distributed Property Map`_.
  The value and key types must be the vertex descriptor of the graph.

IN: ``const ReverseGraph& gr``
  The reverse (or transpose) graph of ``g``, such that for each
  directed edge *(u, v)* in ``g`` there exists a directed edge
  *(fr(v), fr(u))* in ``gr`` and for each edge *(v', u')* in *gr*
  there exists an edge *(rf(u'), rf(v'))* in ``g``. The functions
  *fr* and *rf* map from vertices in the graph to the reverse graph
  and vice-verse, and are represented as property map arguments. The
  concept requirements on this graph type are equivalent to those on
  the ``Graph`` type, but the types need not be the same.

  **Default**: Either a ``reverse_graph`` adaptor over the original
  graph (if the graph type is bidirectional, i.e., models the
  `Bidirectional Graph`_ concept) or a `distributed adjacency list`_
  constructed from the input graph.

IN: ``IsoMapFR fr``
  A property map that maps from vertices in the input graph ``g`` to
  vertices in the reversed graph ``gr``. The type ``IsoMapFR`` must
  model the `Readable Property Map`_ concept and have the graph's
  vertex descriptor as its key type and the reverse graph's vertex
  descriptor as its value type.

  **Default**: An identity property map (if the graph type is
  bidirectional) or a distributed ``iterator_property_map`` (if the
  graph type is directed).

IN: ``IsoMapRF rf``
  A property map that maps from vertices in the reversed graph ``gr``
  to vertices in the input graph ``g``. The type ``IsoMapRF`` must
  model the `Readable Property Map`_ concept and have the reverse
  graph's vertex descriptor as its key type and the graph's vertex
  descriptor as its value type.

  **Default**: An identity property map (if the graph type is
  bidirectional) or a distributed ``iterator_property_map`` (if the
  graph type is directed).

Complexity
----------

The local phase of the algorithm is *O(V + E)*.  The parallel phase of
the algorithm requires at most *O(V)* supersteps each containing two 
breadth first searches which are *O(V + E)* each. 


Algorithm Description
---------------------

Prior to executing the sequential phase of the algorithm, each process
identifies any completely local strong components which it labels and
removes from the vertex set considered in the parallel phase of the
algorithm.

The parallel phase of the distributed strong components algorithm
consists of series of supersteps.  Each superstep starts with one
or more vertex sets which are guaranteed to completely contain
any remaining strong components.  A `distributed breadth first search`_
is performed starting from the first vertex in each vertex set.
All of these breadth first searches are performed in parallel by having
each processor call ``breadth_first_search()`` with a different starting
vertex, and if necessary inserting additional vertices into the 
``distributed queue`` used for breadth first search before invoking
the algorithm.  A second `distributed breadth first search`_ is
performed on the reverse graph in the same fashion.  For each initial
vertex set, the successor set (the vertices reached in the forward 
breadth first search), and the predecessor set (the vertices reached
in the backward breadth first search) is computed.  The intersection
of the predecessor and successor sets form a strongly connected 
component which is labeled as such.  The remaining vertices in the 
initial vertex set are partitioned into three subsets each guaranteed
to completely contain any remaining strong components.  These three sets
are the vertices in the predecessor set not contained in the identified
strongly connected component, the vertices in the successor set not 
in the strongly connected component, and the remaing vertices in the 
initial vertex set not in the predecessor or successor sets.  Once
new vertex sets are identified, the algorithm begins a new superstep.
The algorithm halts when no vertices remain.

To boost performance in sparse graphs when identifying small components,
when less than a given portion of the initial number of vertices 
remain in active vertex sets, a filtered graph adapter is used
to limit the graph seen by the breadth first search algorithm to the
active vertices.

Bibliography
------------

.. [FHP00] Lisa Fleischer, Bruce Hendrickson, and Ali Pinar. On
  Identifying Strongly Connected Components in Parallel. In Parallel and
  Distributed Processing (IPDPS), volume 1800 of Lecture Notes in
  Computer Science, pages 505--511, 2000. Springer.

-----------------------------------------------------------------------------

Copyright (C) 2004, 2005 The Trustees of Indiana University.

Authors: Nick Edmonds, Douglas Gregor, and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Sequential strong components: http://www.boost.org/libs/graph/doc/strong_components.html
.. _Distributed breadth first search: breadth_first_search.html
.. _Distributed Graph: DistributedGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. _Bidirectional Graph: http://www.boost.org/libs/graph/doc/BidirectionalGraph.html
.. _distributed adjacency list: distributed_adjacency_list.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. 
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

============================
|Logo| Simple Triggers
============================

.. contents::

Introduction
------------

Triggers in the `process group`_ interface are used to asynchronously
receive and process messages destined for distributed data
structures. The trigger interface is relatively versatile, permitting
one to attach any function object to handle requests. The
``simple_trigger`` function simplifies a common case for triggers:
attaching a trigger that invokes a specific member function of the
distributed data structure.

Where Defined
-------------

Header ``<boost/graph/parallel/simple_trigger.hpp>``

Reference
---------

  ::

    template<typename ProcessGroup, typename Class, typename T>
      void 
      simple_trigger(ProcessGroup& pg, int tag, Class* self, 
                     void (Class::*pmf)(int source, int tag, const T& data, 
                                        trigger_receive_context context))

    template<typename ProcessGroup, typename Class, typename T, typename Result>
      void 
      simple_trigger(ProcessGroup& pg, int tag, Class* self, 
                     Result (Class::*pmf)(int source, int tag, const T& data, 
                                          trigger_receive_context context))

The ``simple_trigger`` function registers a trigger that invokes the
given member function (``pmf``) on the object ``self`` whenever a
message is received. If the member function has a return value, then
the trigger has a reply, and can only be used via out-of-band sends
that expect a reply. Otherwise, the member function returns ``void``,
and the function is registered as a normal trigger.


-----------------------------------------------------------------------------

Copyright (C) 2007 Douglas Gregor

Copyright (C) 2007 Matthias Troyer

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _process group: process_group.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| s-t Connectivity
===========================

::

  namespace graph { namespace distributed {
    template<typename DistributedGraph, typename ColorMap>
    inline bool 
    st_connected(const DistributedGraph& g, 
                 typename graph_traits<DistributedGraph>::vertex_descriptor s,
                 typename graph_traits<DistributedGraph>::vertex_descriptor t,
                 ColorMap color)

    template<typename DistributedGraph>
    inline bool 
    st_connected(const DistributedGraph& g, 
                 typename graph_traits<DistributedGraph>::vertex_descriptor s,
                 typename graph_traits<DistributedGraph>::vertex_descriptor t)

    template<typename DistributedGraph, typename ColorMap, typename OwnerMap>
    bool 
    st_connected(const DistributedGraph& g, 
                 typename graph_traits<DistributedGraph>::vertex_descriptor s,
                 typename graph_traits<DistributedGraph>::vertex_descriptor t,
                 ColorMap color, OwnerMap owner)
  } }

The ``st_connected()`` function determines whether there exists a path
from ``s`` to ``t`` in a graph ``g``.  If a path exists the function
returns ``true``, otherwise it returns ``false``.

This algorithm is currently *level-synchronized*, meaning that all
vertices in a given level of the search tree will be processed
(potentially in parallel) before any vertices from a successive level
in the tree are processed.  This is not necessary for the correctness
of the algorithm but rather is an implementation detail.  This
algorithm could be rewritten fully-asynchronously using triggers which
would remove the level-synchronized behavior.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/st_connected.hpp``>

Parameters
----------

IN:  ``const DistributedGraph& g``
  The graph type must be a model of `Distributed Graph`_.  The graph
  type must also model the `Incidence Graph`_.

IN:  ``vertex_descriptor s``

IN:  ``vertex_descriptor t``

UTIL/OUT: ``color_map(ColorMap color)``
  The color map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose colors must monotonically
  darken (white -> gray/green -> black). The default value is a
  distributed ``two_bit_color_map``.

IN:  ``OwnerMap owner``
  The owner map must map from vertices to the process that owns them
  as described in the `GlobalDescriptor`_ concept.

OUT:  ``bool``
  The algorithm returns ``true`` if a path from ``s`` to ``t`` is
  found, and false otherwise.

Complexity
----------

This algorithm performs *O(V + E)* work in *d/2 + 1* BSP supersteps,
where *d* is the shortest distance from ``s`` to ``t``. Over all
supersteps, *O(E)* messages of constant size will be transmitted.

Algorithm Description
---------------------

The algorithm consists of two simultaneous breadth-first traversals
from ``s`` and ``t`` respectively.  The algorithm utilizes a single
queue for both traversals with the traversal from ``s`` being denoted
by a ``gray`` entry in the color map and the traversal from ``t``
being denoted by a ``green`` entry.  The traversal method is similar
to breadth-first search except that no visitor event points are
called.  When any process detects a collision in the two traversals
(by attempting to set a ``gray`` vertex to ``green`` or vice-versa),
it signals all processes to terminate on the next superstep and all
processes return ``true``.  If the queues on all processes are empty
and no collision is detected then all processes terminate and return
``false``.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Distributed Graph: DistributedGraph.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. _GlobalDescriptor: GlobalDescriptor.html.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

====================================
|Logo| Sorted unique R-MAT generator
====================================

::
 
  template<typename RandomGenerator, typename Graph,
           typename EdgePredicate = keep_all_edges>
  class sorted_unique_rmat_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef void difference_type;

    sorted_unique_rmat_iterator();
    sorted_unique_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                                edges_size_type m, double a, double b, double c, 
                                double d, bool bidirectional = true,
                                bool permute_vertices = true,
                                EdgePredicate ep = keep_all_edges());
    // Iterator operations
    reference operator*() const;
    pointer operator->() const;
    sorted_unique_rmat_iterator& operator++();
    sorted_unique_rmat_iterator operator++(int);
    bool operator==(const sorted_unique_rmat_iterator& other) const;
    bool operator!=(const sorted_unique_rmat_iterator& other) const;
 };

This class template implements a generator for R-MAT graphs [CZF04]_,
suitable for initializing an adjacency_list or other graph structure
with iterator-based initialization. An R-MAT graph has a scale-free
distribution w.r.t. vertex degree and is implemented using
Recursive-MATrix partitioning.  The output of this generator is sorted
for use with a `compressed sparse row graph`_. The edge list produced by
this iterator is guaranteed not to contain parallel edges.

Where Defined
-------------
<``boost/graph/rmat_graph_generator.hpp``>

Constructors
------------

::

  sorted_unique_rmat_iterator();

Constructs a past-the-end iterator.

::

  sorted_unique_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                              edges_size_type m, double a, double b, double c, 
                              double d, bool bidirectional = false, 
                              bool permute_vertices = true,
                              EdgePredicate ep = keep_all_edges());

Constructs an R-MAT generator iterator that creates a graph with ``n``
vertices and ``m`` edges.  ``a``, ``b``, ``c``, and ``d`` represent
the probability that a generated edge is placed of each of the 4
quadrants of the partitioned adjacency matrix.  Probabilities are
drawn from the random number generator ``gen``.  Vertex indices are
permuted to eliminate locality when ``permute_vertices`` is true.
When ``bidirectional`` is ``true`` for every edge s-t, the
corresponding anti-edge t-s is added as well, these anti-edges are not
counted towards ``m``. ``ep`` allows the user to specify which edges
are retained, this is useful in the case where the user wishes to
refrain from storing remote edges locally during generation to reduce
memory consumption.

Example
-------

::

  #include <boost/graph/distributed/mpi_process_group.hpp>
  #include <boost/graph/compressed_sparse_row_graph.hpp>
  #include <boost/graph/rmat_graph_generator.hpp>
  #include <boost/random/linear_congruential.hpp>

  using boost::graph::distributed::mpi_process_group;

  typedef compressed_sparse_row_graph<directedS, no_property, no_property, no_property,
                                      distributedS<mpi_process_group> > Graph;
  typedef keep_local_edges<boost::parallel::variant_distribution<mpi_process_group>,
                           mpi_process_group::process_id_type> EdgeFilter; 
  typedef boost::sorted_unique_rmat_iterator<boost::minstd_rand, Graph> RMATGen;

  int main()
  {
    boost::minstd_rand gen;
    mpi_process_group pg;

    int N = 100;

    boost::parallel::variant_distribution<ProcessGroup> distrib 
      = boost::parallel::block(pg, N);

    mpi_process_group::process_id_type id = process_id(pg);

    // Create graph with 100 nodes and 400 edges 
    Graph g(RMATGen(gen, N, 400, 0.57, 0.19, 0.19, 0.05, true, 
                    true, EdgeFilter(distrib, id)), 
            RMATGen(), N, pg, distrib);
    return 0;
  }


Bibliography
------------

.. [CZF04] D Chakrabarti, Y Zhan, and C Faloutsos.  R-MAT: A Recursive
  Model for Graph Mining. In Proceedings of 4th International Conference
  on Data Mining, pages 442--446, 2004.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _compressed sparse row graph: http://www.boost.org/libs/graph/doc/compressed_sparse_row.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================================
|Logo| Connected Components Parallel Search
===========================================

::

   namespace graph { namespace distributed {
     template<typename Graph, typename ComponentMap>
     typename property_traits<ComponentMap>::value_type
     connected_components_ps(const Graph& g, ComponentMap c)
   } }

The ``connected_components_ps()`` function computes the connected
components of a graph by performing a breadth-first search from
several sources in parallel while recording and eventually resolving
the collisions.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/connected_components_parallel_search.hpp``>

Parameters
----------

IN:  ``const Graph& g``
  The graph type must be a model of `Distributed Graph`_.  The graph
  type must also model the `Incidence Graph`_ and be directed.

OUT:  ``ComponentMap c``
  The algorithm computes how many connected components are in the
  graph, and assigns each component an integer label.  The algorithm
  then records to which component each vertex in the graph belongs by
  recording the component number in the component property map.  The
  ``ComponentMap`` type must be a `Distributed Property Map`_.  The
  value type must be the ``vertices_size_type`` of the graph.  The key
  type must be the graph's vertex descriptor type.

Complexity
----------

*O(PN^2 + VNP)* work, in *O(N + V)* time, where N is the
number of mappings and V is the number of local vertices.

Algorithm Description
---------------------

Every *N* th nodes starts a parallel search from the first vertex in
their local vertex list during the first superstep (the other nodes
remain idle during the first superstep to reduce the number of
conflicts in numbering the components).  At each superstep, all new
component mappings from remote nodes are handled.  If there is no work
from remote updates, a new vertex is removed from the local list and
added to the work queue.

Components are allocated from the ``component_value_allocator``
object, which ensures that a given component number is unique in the
system, currently by using the rank and number of processes to stride
allocations.

When two components are discovered to actually be the same component,
a collision is recorded.  The lower component number is prefered in
the resolution, so component numbering resolution is consistent.
After the search has exhausted all vertices in the graph, the mapping
is shared with all processes and they independently resolve the
comonent mapping.  This phase can likely be significantly sped up if a
clever algorithm for the reduction can be found.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Brian Barrett, Douglas Gregor, and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Distributed Graph: DistributedGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

================================
|Logo| Concept Distributed Graph
================================

.. contents::

Description
-----------

A Distributed Graph is a graph whose vertices or edges are
distributed across multiple processes or address spaces. The
descriptors of a Distributed Graph must model the `Global
Descriptor`_ concept. 

Notation
--------

G
  A type that models the Distributed Graph concept.


Refinement of
-------------

  - Graph_

Associated types
----------------

+----------------+---------------------------------------+---------------------------------+
|Vertex          |``graph_traits<G>::vertex_descriptor`` |Must model the                   |
|descriptor type |                                       |`Global Descriptor`_ concept.    |
+----------------+---------------------------------------+---------------------------------+
|Edge            |``graph_traits<G>::edge_descriptor``   |Must model the                   |
|descriptor type |                                       |`Global Descriptor`_ concept.    |
+----------------+---------------------------------------+---------------------------------+


Models
------

  - `Distributed adjacency list`_

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Graph: http://www.boost.org/libs/graph/doc/Graph.html
.. _Global descriptor: GlobalDescriptor.html
.. _Distributed adjacency list: distributed_adjacency_list.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===============================
|Logo| Distributed Property Map
===============================

A distributed property map adaptor is a property map whose stored
values are distributed across multiple non-overlapping memory spaces
on different processes. Values local to the current process are stored
within a local property map and may be immediately accessed via
``get`` and ``put``. Values stored on remote processes may also be
accessed via ``get`` and ``put``, but the behavior differs slightly:

 - ``put`` operations update a local ghost cell and send a "put"
   message to the process that owns the value. The owner is free to
   update its own "official" value or may ignore the put request.

 - ``get`` operations returns the contents of the local ghost
   cell. If no ghost cell is available, one is created using a
   (customizable) default value. 

Using distributed property maps requires a bit more care than using
local, sequential property maps. While the syntax and semantics are
similar, distributed property maps may contain out-of-date
information that can only be guaranteed to be synchronized by
calling the ``synchronize`` function in all processes.

To address the issue of out-of-date values, distributed property
maps support multiple `consistency models`_ and may be supplied with a
`reduction operation`_.

Distributed property maps meet the requirements of the `Readable
Property Map`_ and, potentially, the `Writable Property Map`_ and
`Read/Write Property Map`_ concepts. Distributed property maps do
*not*, however, meet the requirements of the `Lvalue Property Map`_
concept, because elements residing in another process are not
directly addressible. There are several forms of distributed property
maps:

  - `Distributed property map adaptor`_
  - `Distributed iterator property map`_
  - `Distributed safe iterator property map`_
  - `Local property map`_

------------------
Consistency models
------------------

Distributed property maps offer many consistency models, which affect
how the values read from and written to remote keys relate to the
"official" value for that key stored in the owning process. The
consistency model of a distributed property map can be set with the
member function ``set_consistency_model`` to a bitwise-OR of the
flags in the ``boost::parallel::consistency_model`` enumeration. The
individual flags are:

  - ``cm_forward``: The default consistency model, which propagates
    values forward from ``put`` operations on remote processors to
    the owner of the value being changed. 
  
  - ``cm_backward``: After all values have been forwarded or flushed
    to the owning processes, each process receives updates values for
    each of its ghost cells. After synchronization, the values in
    ghost cells are guaranteed to match the values stored on the
    owning processor.

  - ``cm_bidirectional``: A combination of both ``cm_forward`` and
    ``cm_backward``. 

  - ``cm_flush``: At the beginning of synchronization, all of the
    values stored locally in ghost cells are sent to their owning
    processors. 

  - ``cm_reset``: Executes a ``reset()`` operation after
    synchronization, setting the values in each ghost cell to their
    default value.

  - ``cm_clear``: Executes a ``clear()`` operation after
    synchronizing, eliminating all ghost cells.


There are several common combinations of flags that result in
interesting consistency models. Some of these combinations are:

  - ``cm_forward``: By itself, the forward consistency model enables
    algorithms such as `Dijkstra's shortest paths`_ and
    `Breadth-First Search`_ to operate correctly.

  - ``cm_flush & cm_reset``: All updates values are queued locally,
    then flushed during the synchronization step. Once the flush has
    occurred, the ghost cells are restored to their default
    values. This consistency model is used by the PageRank_
    implementation to locally accumulate rank for each node.


-------------------
Reduction operation
-------------------

The reduction operation maintains consistency by determining how
multiple writes to a property map are resolved and what the property
map should do if unknown values are requested. More specifically, a
reduction operation is used in two cases:

  1. When a value is needed for a remote key but no value is
     immediately available, the reduction operation provides a
     suitable default. For instance, a distributed property map
     storing distances may have a reduction operation that returns
     an infinite value as the default, whereas a distributed
     property map for vertex colors may return white as the
     default.

  2. When a value is received from a remote process, the process
     owning the key associated with that value must determine which
     value---the locally stored value, the value received from a
     remote process, or some combination of the two---will be
     stored as the "official" value in the property map. The
     reduction operation transforms the local and remote values
     into the "official" value to be stored.

The reduction operation of a distributed property map can be set with
the ``set_reduce`` method of ``distributed_property_map``. The reduce
operation is a function object with two signatures. The first
signature takes a (remote) key and returns a default value for it,
whereas the second signatures takes a key and two values (local first,
then remote) and will return the combined value that will be stored in
the local property map.  Reduction operations must also contain a
static constant ``non_default_resolver", which states whether the
reduction operation's default value actually acts like a default
value. It should be ``true`` when the default is meaningful (e.g.,
infinity for a distance) and ``false`` when the default should not be
used. 

The following reduction operation is used by the distributed PageRank
algorithm. The default rank for a remote node is 0. Rank is
accumulated locally, and then the reduction operation combines local
and remote values by adding them. Combined with a consistency model
that flushes all values to the owner and then resets the values
locally in each step, the resulting property map will compute partial 
sums on each processor and then accumulate the results on the owning
processor. The PageRank reduction operation is defined as follows.
 
::

  template<typename T>
  struct rank_accumulate_reducer {
    static const bool non_default_resolver = true;

    // The default rank of an unknown node 
    template<typename K>
    T operator()(const K&) const { return T(0); }

    template<typename K>
    T operator()(const K&, const T& x, const T& y) const { return x + y; }
  };


--------------------------------
Distributed property map adaptor
--------------------------------

The distributed property map adaptor creates a distributed property
map from a local property map, a `process group`_ over which
distribution should occur, and a `global descriptor`_ type that
indexes the distributed property map. 
  

Synopsis
~~~~~~~~

::

  template<typename ProcessGroup, typename LocalPropertyMap, typename Key,
           typename GhostCellS = gc_mapS>
  class distributed_property_map
  {
  public:
    typedef ... ghost_regions_type;
 
    distributed_property_map();

    distributed_property_map(const ProcessGroup& pg, 
                             const LocalPropertyMap& pm);

    template<typename Reduce>
    distributed_property_map(const ProcessGroup& pg, 
                             const LocalPropertyMap& pm,
                             const Reduce& reduce);

    template<typename Reduce> void set_reduce(const Reduce& reduce);
    void set_consistency_model(int model);

    void flush();
    void reset();
    void clear();
  };

  reference get(distributed_property_map pm, const key_type& key);

  void
  put(distributed_property_map pm, const key_type& key, const value_type& value);
  local_put(distributed_property_map pm, const key_type& key, const value_type& value);

  void request(distributed_property_map pm, const key_type& key);

  void synchronize(distributed_property_map& pm);

  template<typename Key, typename ProcessGroup, typename LocalPropertyMap>
  distributed_property_map<ProcessGroup, LocalPropertyMap, Key>
  make_distributed_property_map(const ProcessGroup& pg, LocalPropertyMap pmap);

  template<typename Key, typename ProcessGroup, typename LocalPropertyMap,
           typename Reduce>
  distributed_property_map<ProcessGroup, LocalPropertyMap, Key>
  make_distributed_property_map(const ProcessGroup& pg, LocalPropertyMap pmap,
                                Reduce reduce);

Template parameters
~~~~~~~~~~~~~~~~~~~

**ProcessGroup**:
  The type of the process group over which the
  property map is distributed and is also the medium for
  communication.


**LocalPropertyMap**:
  The type of the property map that will store values
  for keys local to this processor. The ``value_type`` of this
  property map will become the ``value_type`` of the distributed
  property map. The distributed property map models the same property
  map concepts as the ``LocalPropertyMap``, with one exception: a
  distributed property map cannot be an `Lvalue Property Map`_
  (because remote values are not addressable), and is therefore
  limited to `Read/Write Property Map`_.


**Key**:
  The ``key_type`` of the distributed property map, which
  must model the `Global Descriptor`_ concept. The process ID type of
  the ``Key`` parameter must match the process ID type of the
  ``ProcessGroup``, and the local descriptor type of the ``Key`` must
  be convertible to the ``key_type`` of the ``LocalPropertyMap``.


**GhostCellS**:
  A selector type that indicates how ghost cells should be stored in
  the distributed property map. There are either two or three
  options, depending on your compiler:

    - ``boost::parallel::gc_mapS`` (default): Uses an STL ``map`` to
      store the ghost cells for each process. 
    
    - ``boost::parallel::gc_vector_mapS``: Uses a sorted STL
      ``vector`` to store the ghost cells for each process. This
      option works well when there are likely to be few insertions
      into the ghost cells; for instance, if the only ghost cells used
      are for neighboring vertices, the property map can be
      initialized with cells for each neighboring vertex, providing
      faster lookups than a ``map`` and using less space.

    - ``boost::parallel::gc_hash_mapS``: Uses the GCC ``hash_map`` to
      store ghost cells. This option may improve performance over
      ``map`` for large problems sizes, where the set of ghost cells
      cannot be predetermined.


Member functions
~~~~~~~~~~~~~~~~

::

  distributed_property_map();

Default-construct a distributed property map. The property map is in
an invalid state, and may only be used if it is reassigned to a valid
property map. 

------------------------------------------------------------------------------

::

    distributed_property_map(const ProcessGroup& pg, 
                             const LocalPropertyMap& pm);

    template<typename Reduce>
    distributed_property_map(const ProcessGroup& pg, 
                             const LocalPropertyMap& pm,
                             const Reduce& reduce);

Construct a property map from a process group and a local property
map. If a ``reduce`` operation is not supplied, a default of
``basic_reduce<value_type>`` will be used. 

------------------------------------------------------------------------------

::

  template<typename Reduce> void set_reduce(const Reduce& reduce);

Replace the current reduction operation with the new operation
``reduce``.

------------------------------------------------------------------------------

::

  void set_consistency_model(int model);

Sets the consistency model of the distributed property map, which will
take effect on the next synchronization step. See the section
`Consistency models`_ for a description of the effect of various
consistency model flags.

------------------------------------------------------------------------------

::
  
  void flush();

Emits a message sending the contents of all local ghost cells to the
owners of those cells. 

------------------------------------------------------------------------------

::
  
  void reset();

Replaces the values stored in each of the ghost cells with the default
value generated by the reduction operation. 

------------------------------------------------------------------------------

::
  
  void clear();

Removes all ghost cells from the property map.


Free functions
~~~~~~~~~~~~~~

::

  reference get(distributed_property_map pm, const key_type& key);

Retrieves the element in ``pm`` associated with the given ``key``. If
the key refers to data stored locally, returns the actual value
associated with the key. If the key refers to nonlocal data, returns
the value of the ghost cell. If no ghost cell exists, the behavior
depends on the current reduction operation: if a reduction operation
has been set and has ``non_default_resolver`` set ``true``, then a
ghost cell will be created according to the default value provided by
the reduction operation. Otherwise, the call to ``get`` will abort
because no value exists for this remote cell. To avoid this problem,
either set a reduction operation that generates default values,
``request()`` the value and then perform a synchronization step, or
``put`` a value into the cell before reading it.

------------------------------------------------------------------------------

::

  void
  put(distributed_property_map pm, const key_type& key, const value_type& value);

Places the given ``value`` associated with ``key`` into property map
``pm``. If the key refers to data stored locally, the value is
immediately updates. If the key refers to data stored in a remote
process, updates (or creates) a local ghost cell containing this
value for the key and sends the new value to the owning process. Note
that the owning process may reject this value based on the reduction
operation, but this will not be detected until the next
synchronization step.

------------------------------------------------------------------------------

::

  void
  local_put(distributed_property_map pm, const key_type& key, const value_type& value);

Equivalent to ``put(pm, key, value)``, except that no message is sent
to the owning process when the value is changed for a nonlocal key.

------------------------------------------------------------------------------

::

  void synchronize(distributed_property_map& pm);

Synchronize the values stored in the distributed property maps. Each
process much execute ``synchronize`` at the same time, after which
the ghost cells in every process will reflect the actual value stored
in the owning process.

------------------------------------------------------------------------------

::

 void request(distributed_property_map pm, const key_type& key);

Request that the element "key" be available after the next
synchronization step. For a non-local key, this means establishing a
ghost cell and requesting.

------------------------------------------------------------------------------

::

  template<typename Key, typename ProcessGroup, typename LocalPropertyMap>
  distributed_property_map<ProcessGroup, LocalPropertyMap, Key>
  make_distributed_property_map(const ProcessGroup& pg, LocalPropertyMap pmap);

  template<typename Key, typename ProcessGroup, typename LocalPropertyMap,
           typename Reduce>
  distributed_property_map<ProcessGroup, LocalPropertyMap, Key>
  make_distributed_property_map(const ProcessGroup& pg, LocalPropertyMap pmap,
                                Reduce reduce);

Create a distributed property map over process group ``pg`` and local
property map ``pmap``. A default reduction operation will be generated
if it is not provided.

---------------------------------
Distributed iterator property map
---------------------------------

The distributed iterator property map adaptor permits the creation of
distributed property maps from random access iterators using the same
syntax as non-distributed iterator property maps. The specialization
is based on a `local property map`_, which contains the
indices for local descriptors and is typically returned to describe
the vertex indices of a distributed graph.

Synopsis
~~~~~~~~

::

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap, typename ValueType,
           typename Reference>
  class iterator_property_map<RandomAccessIterator, 
                              local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                              ValueType, Reference>
  {
  public:
    typedef local_property_map<ProcessGroup, GlobalKey, LocalMap> index_map_type;

    iterator_property_map();
    iterator_property_map(RandomAccessIterator iter, const index_map_type& id);
  };

  reference get(iterator_property_map pm, const key_type& key);
  void put(iterator_property_map pm, const key_type& key, const value_type& value);

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap>
  iterator_property_map<RandomAccessIterator, 
                        local_property_map<ProcessGroup, GlobalKey, LocalMap> >
  make_iterator_property_map(RandomAccessIterator iter, 
                             local_property_map<ProcessGroup, GlobalKey, LocalMap> id);


Member functions
~~~~~~~~~~~~~~~~

::

    iterator_property_map();

Default-constructs a distributed iterator property map. The property
map is in an invalid state, and must be reassigned before it may be
used. 

------------------------------------------------------------------------------

::

    iterator_property_map(RandomAccessIterator iter, const index_map_type& id);

Constructs a distributed iterator property map using the property map
``id`` to map global descriptors to local indices. The random access
iterator sequence ``[iter, iter + n)`` must be a valid range, where
``[0, n)`` is the range of local indices. 

Free functions
~~~~~~~~~~~~~~

::

  reference get(iterator_property_map pm, const key_type& key);

Returns the value associated with the given ``key`` from the
distributed property map.

------------------------------------------------------------------------------

::
 
  void put(iterator_property_map pm, const key_type& key, const value_type& value);

Associates the value with the given key in the distributed property map.

------------------------------------------------------------------------------

::

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap, typename ValueType,
           typename Reference>
  iterator_property_map<RandomAccessIterator, 
                        local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                           ValueType, Reference>
  make_iterator_property_map(RandomAccessIterator iter, 
                             local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                                ValueType, Reference> id);

Creates a distributed iterator property map using the given iterator
``iter`` and local index property map ``id``.

--------------------------------------
Distributed safe iterator property map
--------------------------------------

The distributed safe iterator property map adaptor permits the
creation of distributed property maps from random access iterators
using the same syntax as non-distributed safe iterator property
maps. The specialization is based on a `local property map`_, which
contains the indices for local descriptors and is typically returned
to describe the vertex indices of a distributed graph. Safe iterator
property maps check the indices of accesses to ensure that they are
not out-of-bounds before attempting to access an value.

Synopsis
~~~~~~~~

::

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap, typename ValueType,
           typename Reference>
  class safe_iterator_property_map<RandomAccessIterator, 
                                   local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                   ValueType, Reference>
  {
  public:
    typedef local_property_map<ProcessGroup, GlobalKey, LocalMap> index_map_type;

    safe_iterator_property_map();
    safe_iterator_property_map(RandomAccessIterator iter, std::size_t n, 
                               const index_map_type& id);
  };

  reference get(safe_iterator_property_map pm, const key_type& key);
  void put(safe_iterator_property_map pm, const key_type& key, const value_type& value);

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap, typename ValueType,
           typename Reference>
  safe_iterator_property_map<RandomAccessIterator, 
                             local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                                ValueType, Reference>
  make_safe_iterator_property_map(RandomAccessIterator iter, 
                                  std::size_t n,
                                  local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                                     ValueType, Reference> id);

Member functions
~~~~~~~~~~~~~~~~

::

    safe_iterator_property_map();

Default-constructs a distributed safe iterator property map. The property
map is in an invalid state, and must be reassigned before it may be
used. 

------------------------------------------------------------------------------

::

    safe_iterator_property_map(RandomAccessIterator iter, std::size_t n,
                               const index_map_type& id);

Constructs a distributed safe iterator property map using the property map
``id`` to map global descriptors to local indices. The random access
iterator sequence ``[iter, iter + n)``. 

Free functions
~~~~~~~~~~~~~~

::

  reference get(safe_iterator_property_map pm, const key_type& key);

Returns the value associated with the given ``key`` from the
distributed property map.

------------------------------------------------------------------------------

::
 
  void put(safe_iterator_property_map pm, const key_type& key, const value_type& value);

Associates the value with the given key in the distributed property map.

------------------------------------------------------------------------------

::

  template<typename RandomAccessIterator, typename ProcessGroup,
           typename GlobalKey, typename LocalMap, typename ValueType,
           typename Reference>
  safe_iterator_property_map<RandomAccessIterator, 
                             local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                                ValueType, Reference>
  make_safe_iterator_property_map(RandomAccessIterator iter, 
                                  std::size_t n,
                                  local_property_map<ProcessGroup, GlobalKey, LocalMap>,
                                                     ValueType, Reference> id);

Creates a distributed safe iterator property map using the given iterator
``iter`` and local index property map ``id``. The indices in ``id`` must

------------------
Local property map
------------------

A property map adaptor that accesses an underlying property map whose
key type is the local part of the ``Key`` type for the local subset
of keys. Local property maps are typically used by distributed graph
types for vertex index properties.

Synopsis
~~~~~~~~

::

  template<typename ProcessGroup, typename GlobalKey, typename LocalMap>
    class local_property_map
    {
    public:
    typedef typename property_traits<LocalMap>::value_type value_type;
    typedef GlobalKey                                      key_type;
    typedef typename property_traits<LocalMap>::reference  reference;
    typedef typename property_traits<LocalMap>::category   category;

    explicit 
    local_property_map(const ProcessGroup& process_group = ProcessGroup(),
                       const LocalMap& local_map = LocalMap());

    reference operator[](const key_type& key);
  };

  reference get(const local_property_map& pm, key_type key);
  void put(local_property_map pm, const key_type& key, const value_type& value);

Template parameters
~~~~~~~~~~~~~~~~~~~

:ProcessGroup: the type of the process group over which the global
  keys are distributed.

:GlobalKey: The ``key_type`` of the local property map, which
  must model the `Global Descriptor`_ concept. The process ID type of
  the ``GlobalKey`` parameter must match the process ID type of the
  ``ProcessGroup``, and the local descriptor type of the ``GlobalKey``
  must be convertible to the ``key_type`` of the ``LocalMap``.

:LocalMap: the type of the property map that will store values
  for keys local to this processor. The ``value_type`` of this
  property map will become the ``value_type`` of the local
  property map. The local property map models the same property
  map concepts as the ``LocalMap``.

Member functions
~~~~~~~~~~~~~~~~

::

  explicit 
  local_property_map(const ProcessGroup& process_group = ProcessGroup(),
                     const LocalMap& local_map = LocalMap());

Constructs a local property map whose keys are distributed across the
given process group and which accesses the given local map.

------------------------------------------------------------------------------

::

  reference operator[](const key_type& key);

Access the value associated with the given key, which must be local
to this process.

Free functions
~~~~~~~~~~~~~~

::

  reference get(const local_property_map& pm, key_type key);

Return the value associated with the given key, which must be local
to this process.

------------------------------------------------------------------------------

::

  void put(local_property_map pm, const key_type& key, const value_type& value);

Set the value associated with the given key, which must be local to
this process.

-----------------------------------------------------------------------------

Copyright (C) 2004, 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Writable Property Map: http://www.boost.org/libs/property_map/WritablePropertyMap.html
.. _Read/Write Property Map: http://www.boost.org/libs/property_map/ReadWritePropertyMap.html
.. _Lvalue Property Map: http://www.boost.org/libs/property_map/LvaluePropertyMap.html
.. _Process Group: process_group.html
.. _Global Descriptor: GlobalDescriptor.html
.. _Dijkstra's shortest paths: dijkstra_shortest_paths.html
.. _Breadth-First Search: breadth_first_search.html
.. _PageRank: page_rank.html

.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

================================
|Logo| Distributed queue adaptor
================================

::

  template<typename ProcessGroup, typename Buffer>
  class distributed_queue
  {
  public:
    typedef ProcessGroup                     process_group_type;
    typedef Buffer                           buffer_type;
    typedef typename buffer_type::value_type value_type;
    typedef typename buffer_type::size_type  size_type;

    explicit 
    distributed_queue(const ProcessGroup& process_group = ProcessGroup(), 
                      const Buffer& buffer = Buffer(),
                      bool polling = false);

    distributed_queue(const ProcessGroup& process_group, bool polling);

    void push(const value_type& x);
    void pop(); 
    value_type& top();
    const value_type& top() const;
    bool empty() const;
    size_type size() const;
  };

  template<typename ProcessGroup, typename Buffer>
  inline distributed_queue<ProcessGroup, Buffer>
  make_distributed_queue(const ProcessGroup& process_group, const Buffer& buffer,
                         bool polling = false);
  
Class template ``distributed_queue`` implements a distributed queue
across a process group. The distributed queue is an adaptor over an
existing (local) queue, which must model the Buffer_ concept. Each
process stores a distinct copy of the local queue, from which it draws
or removes elements via the ``pop`` and ``top`` members.

The value type of the local queue must be a model of the 
`Global Descriptor`_ concept. The ``push`` operation of the
distributed queue passes (via a message) the value to its owning
processor. Thus, the elements within a particular local queue are
guaranteed to have the process owning that local queue as an owner.

Synchronization of distributed queues occurs in the ``empty`` and
``size`` functions, which will only return "empty" values (true or 0,
respectively) when the entire distributed queue is empty. If the local
queue is empty but the distributed queue is not, the operation will
block until either condition changes. When the ``size`` function of a
nonempty queue returns, it returns the size of the local queue. These
semantics were selected so that sequential code that processes
elements in the queue via the following idiom can be parallelized via
introduction of a distributed queue:

::

  distributed_queue<...> Q;
  Q.push(x);
  while (!Q.empty()) {
    // do something, that may push a value onto Q
  }

In the parallel version, the initial ``push`` operation will place
the value ``x`` onto its owner's queue. All processes will
synchronize at the call to empty, and only the process owning ``x``
will be allowed to execute the loop (``Q.empty()`` returns
false). This iteration may in turn push values onto other remote
queues, so when that process finishes execution of the loop body
and all processes synchronize again in ``empty``, more processes
may have nonempty local queues to execute. Once all local queues
are empty, ``Q.empty()`` returns ``false`` for all processes.

The distributed queue can receive messages at two different times:
during synchronization and when polling ``empty``. Messages are
always received during synchronization, to ensure that accurate
local queue sizes can be determines. However, whether ``empty``
should poll for messages is specified as an option to the
constructor. Polling may be desired when the order in which
elements in the queue are processed is not important, because it
permits fewer synchronization steps and less communication
overhead. However, when more strict ordering guarantees are
required, polling may be semantically incorrect. By disabling
polling, one ensures that parallel execution using the idiom above
will not process an element at a later "level" before an earlier
"level". 

The distributed queue nearly models the Buffer_
concept. However, the ``push`` routine does not necessarily
increase the result of ``size()`` by one (although the size of the
global queue does increase by one).

Member Functions
----------------

::

  explicit 
  distributed_queue(const ProcessGroup& process_group = ProcessGroup(), 
                    const Buffer& buffer = Buffer(),
                    bool polling = false);

Build a new distributed queue that communicates over the given
``process_group``, whose local queue is initialized via ``buffer`` and
which may or may not poll for messages.

-----------------------------------------------------------------------------

::

  distributed_queue(const ProcessGroup& process_group, bool polling);

Build a new distributed queue that communicates over the given 
``process_group``, whose local queue is default-initalized and which
may or may not poll for messages.

-----------------------------------------------------------------------------

::

  void push(const value_type& x);

Push an element onto the distributed queue.

The element will be sent to its owner process to be added to that
process's local queue. If polling is enabled for this queue and
the owner process is the current process, the value will be
immediately pushed onto the local queue.

Complexity: O(1) messages of size O(``sizeof(value_type)``) will be
transmitted.


-----------------------------------------------------------------------------

::

  void pop();

Pop an element off the local queue. The queue must not be ``empty()``.

-----------------------------------------------------------------------------

::

  value_type& top();
  const value_type& top();

Returns the top element in the local queue. The queue must not be
``empty()``.

-----------------------------------------------------------------------------

::

  bool empty() const;

Determines if the queue is empty.

When the local queue is nonempty, returns true. If the local queue is
empty, synchronizes with all other processes in the process group
until either (1) the local queue is nonempty (returns true) (2) the
entire distributed queue is empty (returns false).

-----------------------------------------------------------------------------

::

  size_type size() const;


Determines the size of the local queue.

The behavior of this routine is equivalent to the behavior of
``empty``, except that when ``empty`` returns true this
function returns the size of the local queue and when ``empty``
returns false this function returns zero.

Free Functions
--------------

::

  template<typename ProcessGroup, typename Buffer>
  inline distributed_queue<ProcessGroup, Buffer>
  make_distributed_queue(const ProcessGroup& process_group, const Buffer& buffer,
                         bool polling = false);

Constructs a distributed queue.

-----------------------------------------------------------------------------

Copyright (C) 2004, 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Global descriptor: GlobalDescriptor.html
.. _Buffer: http://www.boost.org/libs/graph/doc/Buffer.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===================================
|Logo| Sorted R-MAT generator
===================================

::
 
  template<typename RandomGenerator, typename Graph,
           typename EdgePredicate = keep_all_edges>
  class sorted_rmat_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef void difference_type;

    sorted_rmat_iterator();
    sorted_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                         edges_size_type m, double a, double b, double c, 
                         double d, bool permute_vertices = true);
    // Iterator operations
    reference operator*() const;
    pointer operator->() const;
    sorted_rmat_iterator& operator++();
    sorted_rmat_iterator operator++(int);
    bool operator==(const sorted_rmat_iterator& other) const;
    bool operator!=(const sorted_rmat_iterator& other) const;
 };

This class template implements a generator for R-MAT graphs [CZF04]_,
suitable for initializing an adjacency_list or other graph structure
with iterator-based initialization. An R-MAT graph has a scale-free
distribution w.r.t. vertex degree and is implemented using
Recursive-MATrix partitioning.  The output of this generator is sorted
for use with `compressed sparse row graph`_.

Where Defined
-------------
<``boost/graph/rmat_graph_generator.hpp``>

Constructors
------------

::

  sorted_rmat_iterator();

Constructs a past-the-end iterator.

::


  sorted_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                       edges_size_type m, double a, double b, double c, 
                       double d, bool permute_vertices = true,
                       EdgePredicate ep = keep_all_edges());

Constructs an R-MAT generator iterator that creates a graph with ``n``
vertices and ``m`` edges.  ``a``, ``b``, ``c``, and ``d`` represent
the probability that a generated edge is placed of each of the 4
quadrants of the partitioned adjacency matrix.  Probabilities are
drawn from the random number generator ``gen``.  Vertex indices are
permuted to eliminate locality when ``permute_vertices`` is true.
``ep`` allows the user to specify which edges are retained, this is
useful in the case where the user wishes to refrain from storing
remote edges locally during generation to reduce memory consumption.

Example
-------

::

  #include <boost/graph/compressed_sparse_row_graph.hpp>
  #include <boost/graph/rmat_graph_generator.hpp>
  #include <boost/random/linear_congruential.hpp>

  typedef boost::compressed_sparse_row_graph<> Graph;
  typedef boost::sorted_rmat_iterator<boost::minstd_rand, Graph> 
    RMATGen;

  int main()
  {
    boost::minstd_rand gen;
    // Create graph with 100 nodes and 400 edges 
    Graph g(RMATGen(gen, 100, 400, 0.57, 0.19, 0.19, 0.05), 
            RMATGen(), 100);
    return 0;
  }

Bibliography
------------

.. [CZF04] D Chakrabarti, Y Zhan, and C Faloutsos.  R-MAT: A Recursive
  Model for Graph Mining. In Proceedings of 4th International Conference
  on Data Mining, pages 442--446, 2004.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _compressed sparse row graph: http://www.boost.org/libs/graph/doc/compressed_sparse_row.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===================================
|Logo| Scalable R-MAT generator
===================================

::
 
  template<typename ProcessGroup, typename Distribution, 
           typename RandomGenerator, typename Graph>
  class scalable_rmat_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef void difference_type;

    scalable_rmat_iterator();
    scalable_rmat_iterator(ProcessGroup pg, Distribution distrib,
                           RandomGenerator& gen, vertices_size_type n, 
                           edges_size_type m, double a, double b, double c, 
                           double d, bool permute_vertices = true);

    // Iterator operations
    reference operator*() const;
    pointer operator->() const;
    scalable_rmat_iterator& operator++();
    scalable_rmat_iterator operator++(int);
    bool operator==(const scalable_rmat_iterator& other) const;
    bool operator!=(const scalable_rmat_iterator& other) const;
 };

This class template implements a generator for R-MAT graphs [CZF04]_,
suitable for initializing an adjacency_list or other graph structure
with iterator-based initialization. An R-MAT graph has a scale-free
distribution w.r.t. vertex degree and is implemented using
Recursive-MATrix partitioning.

Where Defined
-------------
<``boost/graph/rmat_graph_generator.hpp``>

Constructors
------------

::

  scalable_rmat_iterator();

Constructs a past-the-end iterator.

::

  scalable_rmat_iterator(ProcessGroup pg, Distribution distrib,
                         RandomGenerator& gen, vertices_size_type n, 
                         edges_size_type m, double a, double b, double c, 
                         double d, bool permute_vertices = true);

Constructs an R-MAT generator iterator that creates a graph with ``n``
vertices and ``m`` edges.  Inside the ``scalable_rmat_iterator``
processes communicate using ``pg`` to generate their local edges as
defined by ``distrib``.  ``a``, ``b``, ``c``, and ``d`` represent the
probability that a generated edge is placed of each of the 4 quadrants
of the partitioned adjacency matrix.  Probabilities are drawn from the
random number generator ``gen``.  Vertex indices are permuted to
eliminate locality when ``permute_vertices`` is true.

Example
-------

::

  #include <boost/graph/distributed/mpi_process_group.hpp>
  #include <boost/graph/compressed_sparse_row_graph.hpp>
  #include <boost/graph/rmat_graph_generator.hpp>
  #include <boost/random/linear_congruential.hpp>

  using boost::graph::distributed::mpi_process_group;

  typedef compressed_sparse_row_graph<directedS, no_property, no_property, no_property,
                                      distributedS<mpi_process_group> > Graph;
  typedef boost::scalable_rmat_iterator<boost::minstd_rand, Graph> RMATGen;

  int main()
  {
    boost::minstd_rand gen;
    mpi_process_group pg;

    int N = 100;

    boost::parallel::variant_distribution<ProcessGroup> distrib 
      = boost::parallel::block(pg, N);

    // Create graph with 100 nodes and 400 edges 
    Graph g(RMATGen(pg, distrib, gen, N, 400, 0.57, 0.19, 0.19, 0.05), 
            RMATGen(), N, pg, distrib);
    return 0;
  }

Bibliography
------------

.. [CZF04] D Chakrabarti, Y Zhan, and C Faloutsos.  R-MAT: A Recursive
  Model for Graph Mining. In Proceedings of 4th International Conference
  on Data Mining, pages 442--446, 2004.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds, Brian Barrett, and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Sequential connected components: http://www.boost.org/libs/graph/doc/connected_components.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

==================================
|Logo| Parallel BGL Process Groups
==================================

.. contents::

Introduction
------------

Process groups are an abstraction of a set of communicating processes
that coordinate to solve the same problem. Process groups contain
facilities for identifying the processes within that group, sending
and receiving messages between the processes in that group, and
performing collective communications involving all processes in the
group simultaneously. 

Communication model
-------------------

Process groups are based on an extended version of the Bulk
Synchronous Parallel (BSP) model of computation. Parallel computations
in the BSP model are organized into *supersteps*, each of which
consists of a computation phase followed by a communication
phase. During the computation phase, all processes in the process
group work exclusively on local data, and there is no inter-process
communication. During the communication phase, all of the processes
exchange message with each other. Messages sent in the communication
phase of a superstep will be received in the next superstep.

The boundary between supersteps in the Parallel BGL corresponds to the
``synchronize`` operation. Whenever a process has completed its local
computation phase and sent all of the messages required for that
superstep, it invokes the ``synchronize`` operation on the process
group. Once all processes in the process group have entered
``synchronize``, they exchange messages and then continue with the
next superstep. 

The Parallel BGL loosens the BSP model significantly, to provide a
more natural programming model that also provides some performance
benefits over the strict BSP model. The primary extension is the
ability to receive messages sent within the same superstep
"asynchronously", either to free up message buffers or to respond to
an immediate request for information. For particularly unstructured
computations, the ability to send a message and get an immediate reply
can simplify many computations that would otherwise need to be split
into two separate supersteps. Additionally, the Parallel BGL augments
the BSP model with support for multiple distributed data structures,
each of which are provided with a different communication space but
whose messages will all be synchronized concurrently. 

Distributed data structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~

A typical computation with the Parallel BGL involves several
distributed data structures working in concern. For example, a simple
breadth-first search involves the distributed graph data structure
containing the graph itself, a distributed queue that manages the
traversal through the graph, and a distributed property map that
tracks which vertices have already been visited as part of the
search. 

The Parallel BGL manages these distributed data structures by allowing
each of the data structures to attach themselves to the process group
itself. When a distributed data structure attaches to the process
group, it receives its own copy of the process group that allows the
distributed data structure to communicate without colliding with the
communications from other distributed data structures. When the
process group is synchronized, all of the distributed data structures
attached to that process group are automatically synchronized, so that
all of the distributed data structures in a computation remain
synchronized. 

A distributed data structure attaches itself to the process group by
creating a copy of the process group and passing an
``attach_distributed_object`` flag to the process group
constructor. So long as this copy of the process group persists, the
distributed data structure is attached the process group. For this
reason, most distributed data structures keep a copy of the process
group as member data, constructing the member with
``attach_distributed_object``, e.g.,

::

  template<typename ProcessGroup>
  struct distributed_data_structure 
  {
    explicit distributed_data_structure(const ProcessGroup& pg)
      : process_group(pg, boost::parallel::attach_distributed_object())
    { }

  private:
    ProcessGroup process_group;
  };


Asynchronous receives
~~~~~~~~~~~~~~~~~~~~~

Distributed data structures in the Parallel BGL can "asynchronously"
receive and process messages before the end of a BSP
superstep. Messages can be received any time that a process is inside
the process group operations, and the scheduling of message receives
is entirely managed by the process group. 

Distributed data structures receive messages through
"triggers". Triggers are function objects responsible for processing a
received message. Each trigger is registered with the ``trigger``
method of the process group using a specific message
tag (an integer) and the type of data that is expected to be
contained within that message. Whenever a message with that tag
becomes available, the progress group will call the trigger with the
source of the message, the message tag, the data contained in the
message, and the "context" of the message.

The majority of triggers have no return value, although it is common
that the triggers send messages back to the source process. In certain
cases where the trigger's purpose is to immediately reply with a
value, the trigger should be registered with the
``trigger_with_reply`` method and should return the value that will be
sent back to the caller. The ``trigger_with_reply`` facility is only
useful in conjunction with out-of-band messaging, discussed next.

Out-of-band messaging
~~~~~~~~~~~~~~~~~~~~~

The majority of messages sent by the Parallel BGL are sent through the
normal send operations, to be received in the next superstep or, in
some cases, received "early" by a trigger. These messages are not
time-sensitive, so they will be delivered whenever the process group
processes them. 

Some messages, however, require immediate responses. For example, if a
process needs to determine the current value associated with a vertex
owned by another process, the first process must send a request to the
second process and block while waiting for a response. For such
messages, the Parallel BGL's process groups provide an out-of-band
messaging mechanism. Out-of-band messages are transmitted immediately,
with a much higher priority than other messages. The sending of
out-of-band messages can be coupled with a receive operation that
waits until the remote process has received the message and sent its
reply. For example, in the following code the process sends a message
containing the string ``name`` to process ``owner`` with tag
``msg_get_descriptor_by_name`` via an out-of-band message. The
receiver of that message will immediately deliver the message via a
trigger, that returns the resulting value--a
``vertex_descriptor``--that will be passed back to the process that
initiated the communication. The full communication happens
immediately, within the current superstep.

::
 
  std::string name;
  vertex_descriptor descriptor;
  send_oob_with_reply(process_group, owner, msg_get_descriptor_by_name,
                      name, descriptor);

Reference
---------

The Parallel BGL process groups specify an interface that can be
implemented by various communication subsystems. In this reference
section, we use the placeholder type ``ProcessGroup`` to stand in for
the various process group implementations that exist. There is only
one implementation of the process group interface at this time:

  - `MPI BSP process group`_

::

  enum trigger_receive_context {
    trc_none,
    trc_in_synchronization,
    trc_early_receive,
    trc_out_of_band
  };
  
  class ProcessGroup 
  {
    // Process group constructors
    ProcessGroup();
    ProcessGroup(const ProcessGroup&, boost::parallel::attach_distributed_object);

    // Triggers
    template<typename Type, typename Handler>
      void trigger(int tag, const Handler& handler);

    template<typename Type, typename Handler>
      void trigger_with_reply(int tag, const Handler& handler);

    trigger_receive_context trigger_context() const;

    // Helper operations
    void poll();
    ProcessGroup base() const;
  };

  // Process query
  int process_id(const ProcessGroup&);
  int num_processes(const ProcessGroup&);

  // Message transmission
  template<typename T>
    void send(const ProcessGroup& pg, int dest, int tag, const T& value);

  template<typename T>
    void receive(const ProcessGroup& pg, int source, int tag, T& value);

  optional<std::pair<int, int> > probe(const ProcessGroup& pg);

  // Synchronization
  void synchronize(const ProcessGroup& pg);

  // Out-of-band communication
  template<typename T>
    void send_oob(const ProcessGroup& pg, int dest, int tag, const T& value);

  template<typename T, typename U>
    void 
    send_oob_with_reply(const ProcessGroup& pg, int dest, int
                        tag, const T& send_value, U& receive_value);

  template<typename T>
    void receive_oob(const ProcessGroup& pg, int source, int tag, T& value);


Process group constructors
~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    ProcessGroup();

Constructs a new process group with a different communication space
from any other process group.

-----------------------------------------------------------------------------

::

    ProcessGroup(const ProcessGroup& pg, boost::parallel::attach_distributed_object);

Attaches a new distributed data structure to the process group
``pg``. The resulting process group can be used for communication
within that new distributed data structure. When the newly-constructed
process group is eventually destroyed, the distributed data structure
is detached from the process group.

Triggers
~~~~~~~~

::

    template<typename Type, typename Handler>
      void trigger(int tag, const Handler& handler);

Registers a trigger with the given process group. The trigger will
watch for messages with the given ``tag``. When such a message is
available, it will be received into a value of type ``Type``, and the
function object ``handler`` will be invoked with four parameters: 

source
  The rank of the source process (an ``int``)

tag
  The tag used to send the message (also an ``int``)

data:
  The data transmitted with the message. The data will have the type
  specified when the trigger was registered.

context:
  The context in which the trigger is executed. This will be a value of
  type ``trigger_receive_context``, which stages whether the trigger
  is being executed during synchronization, asynchronously in response
  to an "early" receive (often to free up communication buffers), or
  in response to an "out-of-band" message.

Triggers can only be registered by process groups that result from
attaching a distributed data structure. A trigger can be invoked in
response to either a normal send operation or an out-of-band send
operation. There is also a `simple trigger interface`_ for defining
triggers in common cases.

-----------------------------------------------------------------------------

::

    template<typename Type, typename Handler>
      void trigger_with_reply(int tag, const Handler& handler);

Like the ``trigger`` method, registers a trigger with the given
process group. The trigger will watch for messages with the given
``tag``. When such a message is available, it will be received into a
value of type ``Type`` and ``handler`` will be invoked, just as with a
normal trigger. However, a trigger registered with
``trigger_with_reply`` must return a value, which will be immediately
sent back to the process that initiated the send resulting in this
trigger. Thus, ``trigger_with_reply`` should only be used for messages
that need immediate responses. These triggers can only be invoked via
the out-of-band sends that wait for the reply, via
``send_oob_with_reply``. There is also a `simple trigger interface`_
for defining triggers in common cases.

-----------------------------------------------------------------------------

::

    trigger_receive_context trigger_context() const;

Retrieves the current context of the process group with respect to the
invocation of triggers. When ``trc_none``, the process group is not
currently invoking any triggers. Otherwise, this value describes in
what context the currently executing trigger is being invoked.


Helper operations
~~~~~~~~~~~~~~~~~

::

  void poll();

Permits the process group to receive any incomining messages,
processing them via triggers. If you have a long-running computation
that does not invoke any of the process group's communication
routines, you should call ``poll`` occasionally to along incoming
messages to be processed. 

-----------------------------------------------------------------------------

::

    ProcessGroup base() const;

Retrieves the "base" process group for this process group, which is a
copy of the underlying process group that does not reference any
specific distributed data structure.

Process query
~~~~~~~~~~~~~

::

  int process_id(const ProcessGroup& pg);

Retrieves the ID (or "rank") of the calling process within the process
group. Process IDs are values in the range [0, ``num_processes(pg)``)
that uniquely identify the process. Process IDs can be used to
initiate communication with another process.

-----------------------------------------------------------------------------

::

  int num_processes(const ProcessGroup& pg);

Returns the number of processes within the process group.


Message transmission
~~~~~~~~~~~~~~~~~~~~

::

  template<typename T>
    void send(const ProcessGroup& pg, int dest, int tag, const T& value);

Sends a message with the given ``tag`` and carrying the given
``value`` to the process with ID ``dest`` in the given process
group. All message sends are non-blocking, meaning that this send
operation will not block while waiting for the communication to
complete. There is no guarantee when the message will be received,
except that it will become available to the destination process by the
end of the superstep, in the collective call to ``synchronize``.

Any type of value can be transmitted via ``send``, so long as it
provides the appropriate functionality to be serialized with the
Boost.Serialization library.

-----------------------------------------------------------------------------

::

  template<typename T>
    void receive(const ProcessGroup& pg, int source, int tag, T& value);

Receives a message with the given ``tag`` sent from the process
``source``, updating ``value`` with the payload of the message. This
receive operation can only receive messages sent within the previous
superstep via the ``send`` operation. If no such message is available
at the time ``receive`` is called, the program is ill-formed.

-----------------------------------------------------------------------------

::

  optional<std::pair<int, int> > probe(const ProcessGroup& pg);

Determines whether a message is available. The probe operation checks
for any messages that were sent in the previous superstep but have not
yet been received. If such a message exists, ``probe`` returns a
(source, tag) pair describing the message. Otherwise, ``probe`` will
return an empty ``boost::optional``. 

A typical use of ``probe`` is to continually probe for messages at the
beginning of the superstep, receiving and processing those messages
until no messages remain.


Synchronization
~~~~~~~~~~~~~~~

::

  void synchronize(const ProcessGroup& pg);

The ``synchronize`` function is a collective operation that must be
invoked by all of the processes within the process group. A call to
``synchronize`` marks the end of a superstep in the parallel
computation. All messages sent before the end of the superstep will be
received into message buffers, and can be processed by the program in
the next superstep. None of the processes will leave the
``synchronize`` function until all of the processes have entered the
function and exchanged messages, so that all processes are always on
the same superstep.

Out-of-band communication
~~~~~~~~~~~~~~~~~~~~~~~~~

::

  template<typename T>
    void send_oob(const ProcessGroup& pg, int dest, int tag, const T& value);

Sends and out-of-band message. This out-of-band send operation acts
like the normal ``send`` operation, except that out-of-band messages
are delivered immediately through a high-priority channel. 

-----------------------------------------------------------------------------

::

  template<typename T, typename U>
    void 
    send_oob_with_reply(const ProcessGroup& pg, int dest, int
                        tag, const T& send_value, U& receive_value);

Sends an out-of-band message and waits for a reply. The
``send_oob_with_reply`` function can only be invoked with message tags
that correspond to triggers registered with
``trigger_with_reply``. This operation will send the message
immediately (through the high-priority, out-of-band channel), then
wait until the remote process sends a reply. The data from the reply
is stored into ``receive_value``. 

-----------------------------------------------------------------------------

::

  template<typename T>
    void receive_oob(const ProcessGroup& pg, int source, int tag, T& value);

Receives an out-of-band message with the given ``source`` and
``tag``. As with the normal ``receive`` operation, it is an error to
call ``receive_oob`` if no message matching the source and tag is
available. This routine is used only rarely; for most circumstances,
use ``send_oob_with_reply`` to perform an immediate send with a
reply. 

-----------------------------------------------------------------------------

Copyright (C) 2007 Douglas Gregor

Copyright (C) 2007 Matthias Troyer

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _MPI BSP process group: mpi_bsp_process_group.html
.. _Simple trigger interface: simple_trigger.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| Mesh Generator
===========================


-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=================================
|Logo| Distributed Adjacency List
=================================

.. contents::

Introduction
------------

The distributed adjacency list implements a graph data structure using
an adjacency list representation. Its interface and behavior are
roughly equivalent to the Boost Graph Library's adjacency_list_
class template. However, the distributed adjacency list partitions the
vertices of the graph across several processes (which need not share
an address space). Edges outgoing from any vertex stored by a process
are also stored on that process, except in the case of undirected
graphs, where either the source or the target may store the edge.

::

  template<typename OutEdgeListS, typename ProcessGroup, typename VertexListS,
           typename DirectedS, typename VertexProperty, typename EdgeProperty, 
           typename GraphProperty, typename EdgeListS>
  class adjacency_list<OutEdgeListS, 
                       distributedS<ProcessGroup, VertexListS>,
                       DirectedS, VertexProperty,
                       EdgeProperty, GraphProperty, EdgeListS>;

Defining a Distributed Adjacency List
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To create a distributed adjacency list, first determine the
representation of the graph in a single address space using these
guidelines_. Next, replace the vertex list selector (``VertexListS``)
with an instantiation of distributedS_, which includes:

- Selecting a `process group`_ type that represents the various
  coordinating processes that will store the distributed graph. For
  example, the `MPI process group`_.

- A selector indicating how the vertex lists in each process will be
  stored. Only the ``vecS`` and ``listS`` selectors are well-supported
  at this time.


The following ``typedef`` defines a distributed adjacency list
containing directed edges. The vertices in the graph will be
distributed over several processes, using the MPI process group
for communication. In each process, the vertices and outgoing edges
will be stored in STL vectors. There are no properties attached to the
vertices or edges of the graph.

::

  using namespace boost;
  typedef adjacency_list<vecS, 
                         distributedS<parallel::mpi::bsp_process_group, vecS>,
                         directedS> 
    Graph;


Distributed Vertex and Edge Properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Vertex and edge properties for distributed graphs mirror their
counterparts for non-distributed graphs. With a distributed graph,
however, vertex and edge properties are stored only in the process
that owns the vertex or edge. 

The most direct way to attach properties to a distributed graph is to
create a structure that will be attached to each of the vertices and
edges of the graph. For example, if we wish to model a simplistic map
of the United States interstate highway system, we might state that
the vertices of the graph are cities and the edges are highways, then
define the information that we maintain for each city and highway:

::

  struct City {
    City() { }
    City(const std::string& name, const std::string& mayor = "Unknown", int population = 0)
      : name(name), mayor(mayor), population(population) { }

    std::string name;
    std::string mayor;
    int population;

    // Serialization support is required!
    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/) {
      ar & name & mayor & population;
    }
  };

  struct Highway {
    Highway() { }
    Highway(const std::string& name, int lanes, int miles_per_hour, int length) 
      : name(name), lanes(lanes), miles_per_hour(miles_per_hour), length(length) { }

    std::string name;
    int lanes;
    int miles_per_hour;
    int length;

    // Serialization support is required!
    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/) {
      ar & name & lanes & miles_per_hour & length;
    }
  };


To create a distributed graph for a road map, we supply ``City`` and
``Highway`` as the fourth and fifth parameters to ``adjacency_list``,
respectively:

::

  typedef adjacency_list<vecS, 
                         distributedS<parallel::mpi::bsp_process_group, vecS>,
                         directedS,
                         City, Highway> 
    RoadMap;


Property maps for internal properties retain their behavior with
distributed graphs via `distributed property maps`_, which automate
communication among processes so that ``put`` and ``get`` operations
may be applied to non-local vertices and edges. However, for
distributed adjacency lists that store vertices in a vector
(``VertexListS`` is ``vecS``), the automatic ``vertex_index``
property map restricts the domain of ``put`` and ``get`` operations
to vertices local to the process executing the operation. For example,
we can create a property map that accesses the length of each highway
as follows:

::

  RoadMap map; // distributed graph instance

  typedef property_map<RoadMap, int Highway::*>::type 
    road_length = get(&Highway::length, map);


Now, one can access the length of any given road based on its edge
descriptor ``e`` with the expression ``get(road_length, e)``,
regardless of which process stores the edge ``e``. 

Named Vertices
~~~~~~~~~~~~~~

The vertices of a graph typically correspond to named entities within
the application domain. In the road map example from the previous
section, the vertices in the graph represent cities. The distributed
adjacency list supports named vertices, which provides an implicit
mapping from the names of the vertices in the application domain
(e.g., the name of a city, such as "Bloomington") to the actual vertex
descriptor stored within the distributed graph (e.g., the third vertex
on processor 1). By enabling support for named vertices, one can refer
to vertices by name when manipulating the graph. For example, one can
add a highway from Indianapolis to Chicago:

::
  
  add_edge("Indianapolis", "Chicago", Highway("I-65", 4, 65, 151), map);

The distributed adjacency list will find vertices associated with the
names "Indianapolis" and "Chicago", then add an edge between these
vertices that represents I-65. The vertices may be stored on any
processor, local or remote. 

To enable named vertices, specialize the ``internal_vertex_name``
property for the structure attached to the vertices in your
graph. ``internal_vertex_name`` contains a single member, ``type``,
which is the type of a function object that accepts a vertex property
and returns the name stored within that vertex property. In the case
of our road map, the ``name`` field contains the name of each city, so
we use the ``member`` function object from the `Boost.MultiIndex`_
library to extract the name, e.g.,

::

  namespace boost { namespace graph { 

  template<>
  struct internal_vertex_name<City>
  {
    typedef multi_index::member<City, std::string, &City::name> type;
  };
  
  } }


That's it! One can now refer to vertices by name when interacting with
the distributed adjacency list.

What happens when one uses the name of a vertex that does not exist?
For example, in our ``add_edge`` call above, what happens if the
vertex named "Indianapolis" has not yet been added to the graph? By
default, the distributed adjacency list will throw an exception if a
named vertex does not yet exist. However, one can customize this
behavior by specifying a function object that constructs an instance
of the vertex property (e.g., ``City``) from just the name of the
vertex. This customization occurs via the
``internal_vertex_constructor`` trait. For example, using the
``vertex_from_name`` template (provided with the Parallel BGL), we can
state that a ``City`` can be constructed directly from the name of the
city using its second constructor:

::

  namespace boost { namespace graph {

  template<>
  struct internal_vertex_constructor<City>
  {
    typedef vertex_from_name<City> type;
  };

  } }

Now, one can add edges by vertex name freely, without worrying about
the explicit addition of vertices. The ``mayor`` and ``population``
fields will have default values, but the graph structure will be
correct. 

Building a Distributed Graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you have determined the layout of your graph type, including the
specific data structures and properties, it is time to construct an
instance of the graph by adding the appropriate vertices and
edges. Construction of distributed graphs can be slightly more
complicated than construction of normal, non-distributed graph data
structures, because one must account for both the distribution of the
vertices and edges and the multiple processes executing
concurrently. There are three main ways to construct distributed
graphs:

1. *Sequence constructors*: if your data can easily be generated by a
pair of iterators that produce (source, target) pairs, you can use the
sequence constructors to build the distributed graph in parallel. This
method is often preferred when creating benchmarks, because random
graph generators like the sorted_erdos_renyi_iterator_ create the
appropriate input sequence. Note that one must provide the same input
iterator sequence on all processes. This method has the advantage that
the sequential graph-building code is identical to the parallel
graph-building code. An example constructing a random graph this way:

  ::

    typedef boost::sorted_erdos_renyi_iterator<boost::minstd_rand, Graph> ERIter;
    boost::minstd_rand gen;
    unsigned long n = 1000000; // 1M vertices
    Graph g(ERIter(gen, n, 0.00005), ERIter(), n);

2. *Adding edges by vertex number*: if you are able to map your
vertices into values in the random [0, *n*), where *n* is the number
of vertices in the distributed graph. Use this method rather than the
sequence constructors when your algorithm cannot easily be moved into
input iterators, or if you can't replicate the input sequence. For
example, you might be reading the graph from an input file:

  ::

    Graph g(n); // initialize with the total number of vertices, n
    if (process_id(g.process_group()) == 0) {
      // Only process 0 loads the graph, which is distributed automatically
      int source, target;
      for (std::cin >> source >> target)
        add_edge(vertex(source, g), vertex(target, g), g);
    }

    // All processes synchronize at this point, then the graph is complete
    synchronize(g.process_group());

3. *Adding edges by name*: if you are using named vertices, you can
construct your graph just by calling ``add_edge`` with the names of
the source and target vertices. Be careful to make sure that each edge
is added by only one process (it doesn't matter which process it is),
otherwise you will end up with multiple edges. For example, in the
following program we read edges from the standard input of process 0,
adding those edges by name. Vertices and edges will be created and
distributed automatically.

  ::

    Graph g;
    if (process_id(g.process_group()) == 0) {
      // Only process 0 loads the graph, which is distributed automatically
      std:string source, target;
      for(std::cin >> source >> target)
        add_edge(source, target, g);
    }

    // All processes synchronize at this point, then the graph is complete
    synchronize(g.process_group());


Graph Concepts
~~~~~~~~~~~~~~

The distributed adjacency list models the Graph_ concept, and in
particular the `Distributed Graph`_ concept. It also models the
`Incidence Graph`_ and `Adjacency Graph`_ concept, but restricts the
input domain of the operations to correspond to local vertices
only. For instance, a process may only access the outgoing edges of a
vertex if that vertex is stored in that process. Undirected and
bidirectional distributed adjacency lists model the `Bidirectional
Graph`_ concept, with the same domain restrictions. Distributed
adjacency lists also model the `Mutable Graph`_ concept (with domain
restrictions; see the Reference_ section), `Property Graph`_ concept,
and `Mutable Property Graph`_ concept.

Unlike its non-distributed counterpart, the distributed adjacency
list does **not** model the `Vertex List Graph`_ or `Edge List
Graph`_ concepts, because one cannot enumerate all vertices or edges
within a distributed graph. Instead, it models the weaker
`Distributed Vertex List Graph`_ and `Distributed Edge List Graph`_
concepts, which permit access to the local edges and vertices on each
processor. Note that if all processes within the process group over
which the graph is distributed iterator over their respective vertex
or edge lists, all vertices and edges will be covered once. 

Reference
---------
Since the distributed adjacency list closely follows the
non-distributed adjacency_list_, this reference documentation
only describes where the two implementations differ.

Where Defined
~~~~~~~~~~~~~

<boost/graph/distributed/adjacency_list.hpp>

Associated Types
~~~~~~~~~~~~~~~~

::

  adjacency_list::process_group_type

The type of the process group over which the graph will be
distributed.

-----------------------------------------------------------------------------

  adjacency_list::distribution_type

The type of distribution used to partition vertices in the graph.

-----------------------------------------------------------------------------

  adjacency_list::vertex_name_type

If the graph supports named vertices, this is the type used to name
vertices. Otherwise, this type is not present within the distributed
adjacency list. 


Member Functions
~~~~~~~~~~~~~~~~

::

    adjacency_list(const ProcessGroup& pg = ProcessGroup());

    adjacency_list(const GraphProperty& g, 
                   const ProcessGroup& pg = ProcessGroup());

Construct an empty distributed adjacency list with the given process
group (or default) and graph property (or default).

-----------------------------------------------------------------------------

::

    adjacency_list(vertices_size_type n, const GraphProperty& p,
                   const ProcessGroup& pg, const Distribution& distribution);

    adjacency_list(vertices_size_type n, const ProcessGroup& pg,
                   const Distribution& distribution);

    adjacency_list(vertices_size_type n, const GraphProperty& p,
                   const ProcessGroup& pg = ProcessGroup());
      
    adjacency_list(vertices_size_type n, 
                   const ProcessGroup& pg = ProcessGroup());

Construct a distributed adjacency list with ``n`` vertices,
optionally providing the graph property, process group, or
distribution. The ``n`` vertices will be distributed via the given
(or default-constructed) distribution. This operation is collective,
requiring all processes with the process group to execute it
concurrently.

-----------------------------------------------------------------------------

::

    template <class EdgeIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                   vertices_size_type n, 
                   const ProcessGroup& pg = ProcessGroup(),
                   const GraphProperty& p = GraphProperty());

    template <class EdgeIterator, class EdgePropertyIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                   EdgePropertyIterator ep_iter,
                   vertices_size_type n,
                   const ProcessGroup& pg = ProcessGroup(),
                   const GraphProperty& p = GraphProperty());

    template <class EdgeIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                   vertices_size_type n, 
                   const ProcessGroup& process_group,
                   const Distribution& distribution,
                   const GraphProperty& p = GraphProperty());

    template <class EdgeIterator, class EdgePropertyIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                   EdgePropertyIterator ep_iter,
                   vertices_size_type n,
                   const ProcessGroup& process_group,
                   const Distribution& distribution,
                   const GraphProperty& p = GraphProperty());

Construct a distributed adjacency list with ``n`` vertices and with
edges specified in the edge list given by the range ``[first, last)``. The
``EdgeIterator`` must be a model of InputIterator_. The value type of the
``EdgeIterator`` must be a ``std::pair``, where the type in the pair is an
integer type. The integers will correspond to vertices, and they must
all fall in the range of ``[0, n)``. When provided, ``ep_iter``
refers to an edge property list ``[ep_iter, ep_iter + m)`` contains
properties for each of the edges.

This constructor is a collective operation and must be executed
concurrently by each process with the same argument list. Most
importantly, the edge lists provided to the constructor in each process
should be equivalent. The vertices will be partitioned among the
processes according to the ``distribution``, with edges placed on the
process owning the source of the edge. Note that this behavior
permits sequential graph construction code to be parallelized
automatically, regardless of the underlying distribution. 

-----------------------------------------------------------------------------

::

  void clear()

Removes all of the edges and vertices from the local graph. To
eliminate all vertices and edges from the graph, this routine must be
executed in all processes.

-----------------------------------------------------------------------------

::

  process_group_type& process_group();
  const process_group_type& process_group() const;

Returns the process group over which this graph is distributed.

-----------------------------------------------------------------------------

::

  distribution_type&       distribution();
  const distribution_type& distribution() const;

Returns the distribution used for initial placement of vertices.

-----------------------------------------------------------------------------

::

  template<typename VertexProcessorMap>
    void redistribute(VertexProcessorMap vertex_to_processor);

Redistributes the vertices (and, therefore, the edges) of the
graph. The property map ``vertex_to_processor`` provides, for each
vertex, the process identifier indicating where the vertex should be
moved. Once this collective routine has completed, the distributed
graph will reflect the new distribution. All vertex and edge
descsriptors and internal and external property maps are invalidated
by this operation.

-----------------------------------------------------------------------------

::

  template<typename OStreamConstructibleArchive>
    void save(std::string const& filename) const;

  template<typename IStreamConstructibleArchive>
    void load(std::string const& filename);

Serializes the graph to a Boost.Serialization archive. 
``OStreamConstructibleArchive`` and ``IStreamConstructibleArchive``
are models of Boost.Serialization *Archive* with the extra
requirement that they can be constructed from a ``std::ostream`` 
and ``std::istream``.
``filename`` names a directory that will hold files for
the different processes.


Non-Member Functions
~~~~~~~~~~~~~~~~~~~~

::

  std::pair<vertex_iterator, vertex_iterator>
  vertices(const adjacency_list& g);

Returns an iterator-range providing access to the vertex set of graph
``g`` stored in this process. Each of the processes that contain ``g``
will get disjoint sets of vertices.

-----------------------------------------------------------------------------

::

  std::pair<edge_iterator, edge_iterator>
  edges(const adjacency_list& g);

Returns an iterator-range providing access to the edge set of graph
``g`` stored in this process.

-----------------------------------------------------------------------------

::

  std::pair<adjacency_iterator, adjacency_iterator>
  adjacent_vertices(vertex_descriptor u, const adjacency_list& g);

Returns an iterator-range providing access to the vertices adjacent to
vertex ``u`` in graph ``g``. The vertex ``u`` must be local to this process.

-----------------------------------------------------------------------------

::

  std::pair<out_edge_iterator, out_edge_iterator>
  out_edges(vertex_descriptor u, const adjacency_list& g);

Returns an iterator-range providing access to the out-edges of vertex
``u`` in graph ``g``. If the graph is undirected, this iterator-range
provides access to all edges incident on vertex ``u``. For both
directed and undirected graphs, for an out-edge ``e``, ``source(e, g)
== u`` and ``target(e, g) == v`` where ``v`` is a vertex adjacent to
``u``. The vertex ``u`` must be local to this process.

-----------------------------------------------------------------------------

::

  std::pair<in_edge_iterator, in_edge_iterator>
  in_edges(vertex_descriptor v, const adjacency_list& g);

Returns an iterator-range providing access to the in-edges of vertex
``v`` in graph ``g``. This operation is only available if
``bidirectionalS`` was specified for the ``Directed`` template
parameter. For an in-edge ``e``, ``target(e, g) == v`` and ``source(e,
g) == u`` for some vertex ``u`` that is adjacent to ``v``, whether the
graph is directed or undirected. The vertex ``v`` must be local to
this process.

-----------------------------------------------------------------------------

::

  degree_size_type
  out_degree(vertex_descriptor u, const adjacency_list& g);

Returns the number of edges leaving vertex ``u``. Vertex ``u`` must
be local to the executing process.

-----------------------------------------------------------------------------

::

  degree_size_type
  in_degree(vertex_descriptor u, const adjacency_list& g);

Returns the number of edges entering vertex ``u``. This operation is
only available if ``bidirectionalS`` was specified for the
``Directed`` template parameter. Vertex ``u`` must be local to the
executing process.

-----------------------------------------------------------------------------

::

  vertices_size_type
  num_vertices(const adjacency_list& g);

Returns the number of vertices in the graph ``g`` that are stored in
the executing process.

-----------------------------------------------------------------------------

::

  edges_size_type
  num_edges(const adjacency_list& g);

Returns the number of edges in the graph ``g`` that are stored in the
executing process.

-----------------------------------------------------------------------------

::

  vertex_descriptor
  vertex(vertices_size_type n, const adjacency_list& g);

Returns the ``n``th vertex in the graph's vertex list, according to the
distribution used to partition the graph. ``n`` must be a value
between zero and the sum of ``num_vertices(g)`` in each process (minus
one). Note that it is not necessarily the case that ``vertex(0, g) ==
*num_vertices(g).first``. This function is only guaranteed to be
accurate when no vertices have been added to or removed from the
graph after its initial construction.

-----------------------------------------------------------------------------

::

  std::pair<edge_descriptor, bool>
  edge(vertex_descriptor u, vertex_descriptor v,
       const adjacency_list& g);

Returns an edge connecting vertex ``u`` to vertex ``v`` in graph
``g``. For bidirectional and undirected graphs, either vertex ``u`` or
vertex ``v`` must be local; for directed graphs, vertex ``u`` must be
local.

-----------------------------------------------------------------------------

::

  std::pair<out_edge_iterator, out_edge_iterator>
  edge_range(vertex_descriptor u, vertex_descriptor v,
             const adjacency_list& g);

TODO: Not implemented.  Returns a pair of out-edge iterators that give
the range for all the parallel edges from ``u`` to ``v``. This function only
works when the ``OutEdgeList`` for the ``adjacency_list`` is a container that
sorts the out edges according to target vertex, and allows for
parallel edges. The ``multisetS`` selector chooses such a
container. Vertex ``u`` must be stored in the executing process.

Structure Modification
~~~~~~~~~~~~~~~~~~~~~~

::

  unspecified add_edge(vertex_descriptor u, vertex_descriptor v, adjacency_list& g);
  unspecified add_edge(vertex_name_type u, vertex_descriptor v, adjacency_list& g);
  unspecified add_edge(vertex_descriptor u, vertex_name_type v, adjacency_list& g);
  unspecified add_edge(vertex_name_type u, vertex_name_type v, adjacency_list& g);

Adds edge ``(u,v)`` to the graph. The return type itself is
unspecified, but the type can be copy-constructed and implicitly
converted into a ``std::pair<edge_descriptor,bool>``. The edge
descriptor describes the added (or found) edge. For graphs that do not
allow parallel edges, if the edge 
is already in the graph then a duplicate will not be added and the
``bool`` flag will be ``false``. Also, if u and v are descriptors for
the same vertex (creating a self loop) and the graph is undirected,
then the edge will not be added and the flag will be ``false``. When
the flag is ``false``, the returned edge descriptor points to the
already existing edge. 

The parameters ``u`` and ``v`` can be either vertex descriptors or, if
the graph uses named vertices, the names of vertices. If no vertex
with the given name exists, the internal vertex constructor will be
invoked to create a new vertex property and a vertex with that
property will be added to the graph implicitly. The default internal
vertex constructor throws an exception.

-----------------------------------------------------------------------------

::

  unspecified add_edge(vertex_descriptor u, vertex_descriptor v, const EdgeProperties& p, adjacency_list& g);
  unspecified add_edge(vertex_name_type u, vertex_descriptor v, const EdgeProperties& p, adjacency_list& g);
  unspecified add_edge(vertex_descriptor u, vertex_name_type v, const EdgeProperties& p, adjacency_list& g);
  unspecified add_edge(vertex_name_type u, vertex_name_type v, const EdgeProperties& p, adjacency_list& g);


Adds edge ``(u,v)`` to the graph and attaches ``p`` as the value of the edge's
internal property storage. See the previous ``add_edge()`` member
function for more details.  

-----------------------------------------------------------------------------

::

  void 
  remove_edge(vertex_descriptor u, vertex_descriptor v, 
              adjacency_list& g);

Removes the edge ``(u,v)`` from the graph. If the directed selector is
``bidirectionalS`` or ``undirectedS``, either the source or target
vertex of the graph must be local. If the directed selector is
``directedS``, then the source vertex must be local.

-----------------------------------------------------------------------------

::

  void 
  remove_edge(edge_descriptor e, adjacency_list& g);

Removes the edge ``e`` from the graph. If the directed selector is
``bidirectionalS`` or ``undirectedS``, either the source or target
vertex of the graph must be local. If the directed selector is
``directedS``, then the source vertex must be local.

-----------------------------------------------------------------------------

::

  void remove_edge(out_edge_iterator iter, adjacency_list& g);

This has the same effect as ``remove_edge(*iter, g)``. For directed
(but not bidirectional) graphs, this will be more efficient than
``remove_edge(*iter, g)``.

-----------------------------------------------------------------------------

::

  template <class Predicate >
  void remove_out_edge_if(vertex_descriptor u, Predicate predicate,
                          adjacency_list& g);

Removes all out-edges of vertex ``u`` from the graph that satisfy the
predicate. That is, if the predicate returns ``true`` when applied to an
edge descriptor, then the edge is removed. The vertex ``u`` must be local.

The affect on descriptor and iterator stability is the same as that of
invoking remove_edge() on each of the removed edges.

-----------------------------------------------------------------------------

::

  template <class Predicate >
  void remove_in_edge_if(vertex_descriptor v, Predicate predicate,
                         adjacency_list& g);

Removes all in-edges of vertex ``v`` from the graph that satisfy the
predicate. That is, if the predicate returns true when applied to an
edge descriptor, then the edge is removed. The vertex ``v`` must be local.

The affect on descriptor and iterator stability is the same as that of
invoking ``remove_edge()`` on each of the removed edges.

This operation is available for undirected and bidirectional
adjacency_list graphs, but not for directed.  

-----------------------------------------------------------------------------

::

  template <class Predicate> 
  void remove_edge_if(Predicate predicate, adjacency_list& g);

Removes all edges from the graph that satisfy the predicate. That is,
if the predicate returns true when applied to an edge descriptor, then
the edge is removed. 

The affect on descriptor and iterator stability is the same as that
of invoking ``remove_edge()`` on each of the removed edges.

-----------------------------------------------------------------------------

::

  vertex_descriptor add_vertex(adjacency_list& g);

Adds a vertex to the graph and returns the vertex descriptor for the
new vertex. The vertex will be stored in the local process. This
function is not available when using named vertices.

-----------------------------------------------------------------------------

::

  unspecified add_vertex(const VertexProperties& p, adjacency_list& g);
  unspecified add_vertex(const vertex_name_type& p, adjacency_list& g);

Adds a vertex to the graph with the specified properties. If the graph
is using vertex names, the vertex will be added on whichever process
"owns" that name. Otherwise, the vertex will be stored in the local
process. Note that the second constructor will invoke the
user-customizable internal vertex constructor, which (by default)
throws an exception when it sees an unknown vertex. 

The return type is of unspecified type, but can be copy-constructed
and can be implicitly converted into a vertex descriptor.

-----------------------------------------------------------------------------

::

  void clear_vertex(vertex_descriptor u, adjacency_list& g);

Removes all edges to and from vertex ``u``. The vertex still appears
in the vertex set of the graph.

The affect on descriptor and iterator stability is the same as that of
invoking ``remove_edge()`` for all of the edges that have ``u`` as the source
or target.

This operation is not applicable to directed graphs, because the
incoming edges to vertex ``u`` are not known.

-----------------------------------------------------------------------------

::

  void clear_out_edges(vertex_descriptor u, adjacency_list& g);

Removes all out-edges from vertex ``u``. The vertex still appears in
the vertex set of the graph. 

The affect on descriptor and iterator stability is the same as that of
invoking ``remove_edge()`` for all of the edges that have ``u`` as the
source. 

This operation is not applicable to undirected graphs (use
``clear_vertex()`` instead).

-----------------------------------------------------------------------------

::

  void clear_in_edges(vertex_descriptor u, adjacency_list& g);

Removes all in-edges from vertex ``u``. The vertex still appears in
the vertex set of the graph.

The affect on descriptor and iterator stability is the same as that of
invoking ``remove_edge()`` for all of the edges that have ``u`` as the
target. 

This operation is only applicable to bidirectional graphs.

-----------------------------------------------------------------------------

::

  void remove_vertex(vertex_descriptor u, adjacency_list& g);

Remove vertex ``u`` from the vertex set of the graph. It is assumed
that there are no edges to or from vertex ``u`` when it is
removed. One way to make sure of this is to invoke ``clear_vertex()``
beforehand. The vertex ``u`` must be stored locally.

Property Map Accessors
~~~~~~~~~~~~~~~~~~~~~~

::

  template <class PropertyTag>
  property_map<adjacency_list, PropertyTag>::type
  get(PropertyTag, adjacency_list& g);

  template <class PropertyTag>
  property_map<adjacency_list, Tag>::const_type
  get(PropertyTag, const adjacency_list& g);

Returns the property map object for the vertex property specified by
``PropertyTag``. The ``PropertyTag`` must match one of the properties
specified in the graph's ``VertexProperty`` template argument. The
returned property map will be a `distributed property map`_.

-----------------------------------------------------------------------------

::

  template <class PropertyTag , class X>
  typename property_traits<property_map<adjacency_list, PropertyTag>::const_type>::value_type
  get(PropertyTag, const adjacency_list& g, X x);

This returns the property value for ``x``, where ``x`` is either a vertex or
edge descriptor.  The entity referred to by descriptor ``x`` must be
stored in the local process.

-----------------------------------------------------------------------------

::

  template <class PropertyTag , class X, class Value>
  void put(PropertyTag, const adjacency_list& g, X x, const Value& value);

This sets the property value for ``x`` to value. ``x`` is either a
vertex or edge descriptor. ``Value`` must be convertible to ``typename
property_traits<property_map<adjacency_list,
PropertyTag>::type>::value_type``. 

-----------------------------------------------------------------------------

::

  template <class GraphProperties, class GraphPropertyTag>
  typename graph_property<adjacency_list, GraphPropertyTag>::type&
  get_property(adjacency_list& g, GraphPropertyTag);

  template <class GraphProperties, class GraphPropertyTag >
  const typename graph_property<adjacency_list, GraphPropertyTag>::type&
  get_property(const adjacency_list& g, GraphPropertyTag);

TODO: not implemented.

Return the property specified by ``GraphPropertyTag`` that is attached
to the graph object ``g``. The ``graph_property`` traits class is
defined in ``boost/graph/adjacency_list.hpp``.

-----------------------------------------------------------------------------

Copyright (C) 2004 The Trustees of Indiana University.

Copyright (C) 2007 Douglas Gregor

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _adjacency_list: http://www.boost.org/libs/graph/doc/adjacency_list.html
.. _guidelines: http://www.boost.org/libs/graph/doc/using_adjacency_list.html
.. _process group: process_group.html
.. _mpi process group: process_group.html
.. _distributedS: distributedS.html
.. _Graph: http://www.boost.org/libs/graph/doc/Graph.html
.. _Distributed graph: DistributedGraph.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. _Adjacency Graph: http://www.boost.org/libs/graph/doc/AdjacencyGraph.html
.. _Bidirectional Graph: http://www.boost.org/libs/graph/doc/BidirectionalGraph.html
.. _Mutable Graph: http://www.boost.org/libs/graph/doc/MutableGraph.html
.. _Property Graph: http://www.boost.org/libs/graph/doc/PropertyGraph.html
.. _Mutable Property Graph: http://www.boost.org/libs/graph/doc/MutablePropertyGraph.html
.. _Vertex List Graph: http://www.boost.org/libs/graph/doc/VertexListGraph.html
.. _Edge List Graph: http://www.boost.org/libs/graph/doc/EdgeListGraph.html
.. _Distribution: concepts/Distribution.html
.. _distributed property map: distributed_property_map.html
.. _distributed property maps: distributed_property_map.html
.. _Distributed Vertex List Graph: DistributedVertexListGraph.html
.. _Distributed Edge List Graph: DistributedEdgeListGraph.html
.. _InputIterator: http://www.boost.org/doc/html/InputIterator.html
.. _member: http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#member_synopsis
.. _Boost.MultiIndex: http://www.boost.org/libs/multi_index/doc/index.html
.. _sorted_erdos_renyi_iterator: http://www.boost.org/libs/graph/doc/sorted_erdos_renyi_gen.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

========================
|Logo| Depth-First Visit
========================

::

  template<typename DistributedGraph, typename DFSVisitor>
  void
  depth_first_visit(const DistributedGraph& g,
                    typename graph_traits<DistributedGraph>::vertex_descriptor s,
                    DFSVisitor vis);

  namespace graph {
    template<typename DistributedGraph, typename DFSVisitor, 
           typename VertexIndexMap>
    void
    tsin_depth_first_visit(const DistributedGraph& g,
                           typename graph_traits<DistributedGraph>::vertex_descriptor s,
                           DFSVisitor vis);

    template<typename DistributedGraph, typename DFSVisitor, 
             typename VertexIndexMap>
    void
    tsin_depth_first_visit(const DistributedGraph& g,
                           typename graph_traits<DistributedGraph>::vertex_descriptor s,
                           DFSVisitor vis, VertexIndexMap index_map);

    template<typename DistributedGraph, typename ColorMap, typename ParentMap,
             typename ExploreMap, typename NextOutEdgeMap, typename DFSVisitor>
    void
    tsin_depth_first_visit(const DistributedGraph& g,
                           typename graph_traits<DistributedGraph>::vertex_descriptor s,
                           DFSVisitor vis, ColorMap color, ParentMap parent, ExploreMap explore, 
                           NextOutEdgeMap next_out_edge);
  } 

The ``depth_first_visit()`` function performs a distributed
depth-first traversal of an undirected graph using Tsin's corrections
[Tsin02]_ to Cidon's algorithm [Cidon88]_. The distributed DFS is
syntactically similar to its `sequential counterpart`_, which provides
additional background and discussion. Differences in semantics are
highlighted here, and we refer the reader to the documentation of the
`sequential depth-first search`_ for the remainder of the
details. Visitors passed to depth-first search need to account for the
distribution of vertices across processes, because events will be
triggered on certain processes but not others. See the section
`Visitor Event Points`_ for details.

Where Defined
-------------
<``boost/graph/distributed/depth_first_search.hpp``>

also available in 

<``boost/graph/depth_first_search.hpp``>

Parameters
----------

IN: ``const Graph& g``
  The graph type must be a model of `Distributed Graph`_. The graph
  must be undirected.

IN: ``vertex_descriptor s``
  The start vertex must be the same in every process.

IN: ``DFSVisitor vis``
  The visitor must be a distributed DFS visitor. The suble differences
  between sequential and distributed DFS visitors are discussed in the
  section `Visitor Event Points`_.

IN: ``VertexIndexMap map``
  A model of `Readable Property Map`_ whose key type is the vertex
  descriptor type of the graph ``g`` and whose value type is an
  integral type. The property map should map from vertices to their
  (local) indices in the range *[0, num_vertices(g))*.

  **Default**: ``get(vertex_index, g)``

UTIL/OUT: ``ColorMap color``
  The color map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose colors must monotonically
  darken (white -> gray -> black). 

  **Default**: A distributed ``iterator_property_map`` created from a
  ``std::vector`` of ``default_color_type``.

UTIL/OUT: ``ParentMap parent``
  The parent map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose key and values types are the
  same as the vertex descriptor type of the graph ``g``. This
  property map holds the parent of each vertex in the depth-first
  search tree.

  **Default**: A distributed ``iterator_property_map`` created from a
  ``std::vector`` of the vertex descriptor type of the graph.

UTIL: ``ExploreMap explore``
  The explore map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose key and values types are the
  same as the vertex descriptor type of the graph ``g``. 

  **Default**: A distributed ``iterator_property_map`` created from a
  ``std::vector`` of the vertex descriptor type of the graph.

UTIL: ``NextOutEdgeMap next_out_edge``
  The next out-edge map must be a `Distributed Property Map`_ with the
  same process group as the graph ``g`` whose key type is the vertex
  descriptor of the graph ``g`` and whose value type is the
  ``out_edge_iterator`` type of the graph. It is used internally to
  keep track of the next edge that should be traversed from each
  vertex.

  **Default**: A distributed ``iterator_property_map`` created from a
  ``std::vector`` of the ``out_edge_iterator`` type of the graph.

Complexity
----------
Depth-first search is inherently sequential, so parallel speedup is
very poor. Regardless of the number of processors, the algorithm will
not be faster than *O(V)*; see [Tsin02]_ for more details.

Visitor Event Points
--------------------
The `DFS Visitor`_ concept defines 8 event points that will be
triggered by the `sequential depth-first search`_. The distributed
DFS retains these event points, but the sequence of events
triggered and the process in which each event occurs will change
depending on the distribution of the graph. 

``initialize_vertex(s, g)``
  This will be invoked by every process for each local vertex.


``discover_vertex(u, g)``
  This will be invoked each time a process discovers a new vertex
  ``u``. 


``examine_vertex(u, g)``
  This will be invoked by the process owning the vertex ``u``. 

``examine_edge(e, g)``
  This will be invoked by the process owning the source vertex of
  ``e``. 


``tree_edge(e, g)``
  Similar to ``examine_edge``, this will be invoked by the process
  owning the source vertex and may be invoked only once. 


``back_edge(e, g)``
  Some edges that would be forward or cross edges in the sequential
  DFS may be detected as back edges by the distributed DFS, so extra
  ``back_edge`` events may be received.

``forward_or_cross_edge(e, g)``
  Some edges that would be forward or cross edges in the sequential
  DFS may be detected as back edges by the distributed DFS, so fewer
  ``forward_or_cross_edge`` events may be received in the distributed
  algorithm than in the sequential case.

``finish_vertex(e, g)``
  See documentation for ``examine_vertex``.

Making Visitors Safe for Distributed DFS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The three most important things to remember when updating an existing
DFS visitor for distributed DFS or writing a new distributed DFS
visitor are:

1. Be sure that all state is either entirely local or in a
   distributed data structure (most likely a property map!) using
   the same process group as the graph.

2. Be sure that the visitor doesn't require precise event sequences
   that cannot be guaranteed by distributed DFS, e.g., requiring
   ``back_edge`` and ``forward_or_cross_edge`` events to be completely
   distinct.

3. Be sure that the visitor can operate on incomplete
   information. This often includes using an appropriate reduction
   operation in a `distributed property map`_ and verifying that
   results written are "better" that what was previously written. 

Bibliography
------------

.. [Cidon88] Isreal Cidon. Yet another distributed depth-first-search
  algorithm. Information Processing Letters, 26(6):301--305, 1988.


.. [Tsin02] Y. H. Tsin. Some remarks on distributed depth-first
  search. Information Processing Letters, 82(4):173--178, 2002.

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _sequential counterpart: http://www.boost.org/libs/graph/doc/depth_first_visit.html
.. _sequential depth-first search: http://www.boost.org/libs/graph/doc/depth_first_visit.html
.. _Distributed Graph: DistributedGraph.html
.. _Immediate Process Group: concepts/ImmediateProcessGroup.html
.. _Distributed Property Map: distributed_property_map.html
.. _DFS Visitor: http://www.boost.org/libs/graph/doc/DFSVisitor.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| Breadth-First Search
===========================

::

  // named parameter version
  template <class Graph, class P, class T, class R>
  void breadth_first_search(Graph& G, 
    typename graph_traits<Graph>::vertex_descriptor s, 
    const bgl_named_params<P, T, R>& params);

  // non-named parameter version
  template <class Graph, class Buffer, class BFSVisitor, 
            class ColorMap>
  void breadth_first_search(const Graph& g, 
     typename graph_traits<Graph>::vertex_descriptor s, 
     Buffer& Q, BFSVisitor vis, ColorMap color);

The ``breadth_first_search()`` function performs a distributed breadth-first
traversal of a directed or undirected graph. The distributed BFS is
syntactically equivalent to its `sequential counterpart`_, which
provides additional background and discussion. Differences in
semantics are highlighted here, and we refer the reader to the
documentation of the `sequential breadth-first search`_ for the
remainder of the details.

This distributed breadth-first search algorithm implements a
*level-synchronized* breadth-first search, meaning that all vertices
in a given level of the BFS tree will be processed (potentially in
parallel) before any vertices from a successive level in the tree are
processed. Distributed breadth-first search visitors should account
for this behavior, a topic discussed further in `Visitor Event
Points`_. 

.. contents::

Where Defined
-------------
<``boost/graph/breadth_first_search.hpp``>

Parameter Defaults
------------------
All parameters of the `sequential breadth-first search`_ are supported
and have essentially the same meaning. Only differences are documented
here.

IN: ``Graph& g``
  The graph type must be a model of `Distributed Graph`_. 


IN: ``vertex_descriptor s``
  The start vertex must be the same in every process.


IN: ``visitor(BFSVisitor vis)``
  The visitor must be a distributed BFS visitor. The suble differences
  between sequential and distributed BFS visitors are discussed in the
  section `Visitor Event Points`_.

UTIL/OUT: ``color_map(ColorMap color)``
  The color map must be a `Distributed Property Map`_ with the same
  process group as the graph ``g`` whose colors must monotonically
  darken (white -> gray -> black). The default value is a distributed
  ``iterator_property_map`` created from a ``std::vector`` of
  ``default_color_type``. 


UTIL: ``buffer(Buffer& Q)``
  The queue must be a distributed queue that passes vertices to their
  owning process. If already-visited vertices should not be visited
  again (as is typical for BFS), the queue must filter duplicates
  itself. The queue controls synchronization within the algorithm: its
  ``empty()`` method must not return ``true`` until all local queues
  are empty. 
  
  **Default:** A ``distributed_queue`` of a ``filtered_queue`` over a
    standard ``boost::queue``. This queue filters out duplicate
    vertices and distributes vertices appropriately.

Complexity
----------
This algorithm performs *O(V + E)* work in *d + 1* BSP supersteps,
where *d* is the diameter of the connected component being
searched. Over all supersteps, *O(E)* messages of constant size will
be transmitted.

Visitor Event Points
--------------------
The `BFS Visitor`_ concept defines 9 event points that will be
triggered by the `sequential breadth-first search`_. The distributed
BFS retains these nine event points, but the sequence of events
triggered and the process in which each event occurs will change
depending on the distribution of the graph. 

``initialize_vertex(s, g)``
  This will be invoked by every process for each local vertex.


``discover_vertex(u, g)``
  This will be invoked each time a process discovers a new vertex
  ``u``. Due to incomplete information in distributed property maps,
  this event may be triggered many times for the same vertex ``u``.


``examine_vertex(u, g)``
  This will be invoked by the process owning the vertex ``u``. If the
  distributed queue prevents duplicates, it will be invoked only
  once for a particular vertex ``u``.


``examine_edge(e, g)``
  This will be invoked by the process owning the source vertex of
  ``e``. If the distributed queue prevents duplicates, it will be
  invoked only once for a particular edge ``e``.


``tree_edge(e, g)``
  Similar to ``examine_edge``, this will be invoked by the process
  owning the source vertex and may be invoked only once. Unlike the
  sequential BFS, this event may be triggered even when the target has
  already been discovered (but by a different process). Thus, some
  ``non_tree_edge`` events in a sequential BFS may become
  ``tree_edge`` in a distributed BFS.


``non_tree_edge(e, g)``
  Some ``non_tree_edge`` events in a sequential BFS may become
  ``tree_edge`` events in a distributed BFS. See the description of
  ``tree_edge`` for additional details.


``gray_target(e, g)``
  As with ``tree_edge`` not knowing when another process has already
  discovered a vertex, ``gray_target`` events may occur in a
  distributed BFS when ``black_target`` events may occur in a
  sequential BFS, due to a lack of information on a given
  processor. The source of edge ``e`` will be local to the process
  executing this event.


``black_target(e, g)``
  See documentation for ``gray_target``


``finish_vertex(e, g)``
  See documentation for ``examine_vertex``.

Making Visitors Safe for Distributed BFS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The three most important things to remember when updating an existing
BFS visitor for distributed BFS or writing a new distributed BFS
visitor are:

1. Be sure that all state is either entirely local or in a
   distributed data structure (most likely a property map!) using
   the same process group as the graph.

2. Be sure that the visitor doesn't require precise event sequences
   that cannot be guaranteed by distributed BFS, e.g., requiring
   ``tree_edge`` and ``non_tree_edge`` events to be completely
   distinct.

3. Be sure that the visitor can operate on incomplete
   information. This often includes using an appropriate reduction
   operation in a `distributed property map`_ and verifying that
   results written are "better" that what was previously written. 

Distributed BFS Visitor Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To illustrate the differences between sequential and distributed BFS
visitors, we consider a BFS visitor that places the distance from the
source vertex to every other vertex in a property map. The sequential
visitor is very simple::

  template<typename DistanceMap>
  struct bfs_discovery_visitor : bfs_visitor<> 
  {
    bfs_discovery_visitor(DistanceMap distance) : distance(distance) {}

    template<typename Edge, typename Graph>
    void tree_edge(Edge e, const Graph& g)
    {
      std::size_t new_distance = get(distance, source(e, g)) + 1;
      put(distance, target(e, g), new_distance);
    }
    
   private:
    DistanceMap distance;
  };

To revisit this code for distributed BFS, we consider the three points
in the section `Making Visitors Safe for Distributed BFS`_:

1. The distance map will need to become distributed, because the
   distance to each vertex should be stored in the process owning the
   vertex. This is actually a requirement on the user to provide such
   a distributed property map, although in many cases the property map
   will automatically be distributed and no syntactic changes will be
   required. 

2. This visitor *does* require a precise sequence of events that may
   change with a distributed BFS. The extraneous ``tree_edge`` events
   that may occur could result in attempts to put distances into the
   distance map multiple times for a single vertex. We therefore need
   to consider bullet #3.

3. Since multiple distance values may be written for each vertex, we
   must always choose the best value we can find to update the
   distance map. The distributed property map ``distance`` needs to
   resolve distances to the smallest distance it has seen. For
   instance, process 0 may find vertex ``u`` at level 3 but process 1
   finds it at level 5: the distance must remain at 3. To do this, we
   state that the property map's *role* is as a distance map, which
   introduces an appropriate reduction operation::

          set_property_map_role(vertex_distance, distance);

The resulting distributed BFS visitor (which also applies, with no
changes, in the sequential BFS) is very similar to our original
sequential BFS visitor. Note the single-line difference in the
constructor::

  template<typename DistanceMap>
  struct bfs_discovery_visitor : bfs_visitor<> 
  {
    bfs_discovery_visitor(DistanceMap distance) : distance(distance) 
    {
      set_property_map_role(vertex_distance, distance);
    }

    template<typename Edge, typename Graph>
    void tree_edge(Edge e, const Graph& g)
    {
      std::size_t new_distance = get(distance, source(e, g)) + 1;
      put(distance, target(e, g), new_distance);
    }
    
   private:
    DistanceMap distance;
  };


Performance
-----------
The performance of Breadth-First Search is illustrated by the
following charts. Scaling and performance is reasonable for all of the
graphs we have tried. 

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=4
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=4&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=4
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=4&speedup=1

-----------------------------------------------------------------------------

Copyright (C) 2004 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _sequential counterpart: http://www.boost.org/libs/graph/doc/breadth_first_search.html
.. _sequential breadth-first search: http://www.boost.org/libs/graph/doc/breadth_first_search.html
.. _Distributed Graph: DistributedGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. _BFS Visitor: http://www.boost.org/libs/graph/doc/BFSVisitor.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=======================
Parallel Shortest Paths
=======================
To illustrate the use of the Parallel Boost Graph Library, we
illustrate the use of both the sequential and parallel BGL to find
the shortest paths from vertex A to every other vertex in the
following simple graph:

.. image:: ../dijkstra_seq_graph.png

With the sequential BGL_, the program to calculate shortest paths has
three stages. Readers familiar with the BGL may wish to skip ahead to
the section `Distributing the graph`_.


  - `Define the graph type`_
  - `Construct the graph`_
  - `Invoke Dijkstra's algorithm`_

Define the graph type
~~~~~~~~~~~~~~~~~~~~~

For this problem we use an adjacency list representation of the graph,
using the BGL ``adjacency_list``_ class template. It will be a directed
graph (``directedS`` parameter ) whose vertices are stored in an
``std::vector`` (``vecS`` parameter) where the outgoing edges of each
vertex are stored in an ``std::list`` (``listS`` parameter). To each
of the edges we attach an integral weight.

::

  typedef adjacency_list<listS, vecS, directedS,
                         no_property,                 // Vertex properties 
                         property<edge_weight_t, int> // Edge properties
                         > graph_t;
  typedef graph_traits < graph_t >::vertex_descriptor vertex_descriptor;
  typedef graph_traits < graph_t >::edge_descriptor edge_descriptor;

Construct the graph
~~~~~~~~~~~~~~~~~~~
To build the graph, we declare an enumeration containing the node
names (for our own use) and create two arrays: the first,
``edge_array``, contains the source and target of each edge, whereas
the second, ``weights``, contains the integral weight of each
edge. We pass the contents of the arrays via pointers (used here as
iterators) to the graph constructor to build our graph:

::

  typedef std::pair<int, int> Edge;
  const int num_nodes = 5;
  enum nodes { A, B, C, D, E };
  char name[] = "ABCDE";
  Edge edge_array[] = { Edge(A, C), Edge(B, B), Edge(B, D), Edge(B, E),
    Edge(C, B), Edge(C, D), Edge(D, E), Edge(E, A), Edge(E, B)
  };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1 };
  int num_arcs = sizeof(edge_array) / sizeof(Edge);

  graph_t g(edge_array, edge_array + num_arcs, weights, num_nodes);


Invoke Dijkstra's algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~~~
To invoke Dijkstra's algorithm, we need to first decide how we want
to receive the results of the algorithm, namely the distance to each
vertex and the predecessor of each vertex (allowing reconstruction of
the shortest paths themselves). In our case, we will create two
vectors, ``p`` for predecessors and ``d`` for distances. 

Next, we determine our starting vertex ``s`` using the ``vertex``
operation on the ``adjacency_list``_ and call
``dijkstra_shortest_paths``_ with the graph ``g``, starting vertex
``s``, and two ``property maps``_ that instruct the algorithm to
store predecessors in the ``p`` vector and distances in the ``d``
vector. The algorithm automatically uses the edge weights stored
within the graph, although this capability can be overridden.

::

  // Keeps track of the predecessor of each vertex
  std::vector<vertex_descriptor> p(num_vertices(g));
  // Keeps track of the distance to each vertex
  std::vector<int> d(num_vertices(g));

  vertex_descriptor s = vertex(A, g);
  dijkstra_shortest_paths
    (g, s, 
     predecessor_map(
       make_iterator_property_map(p.begin(), get(vertex_index, g))).
     distance_map(
       make_iterator_property_map(d.begin(), get(vertex_index, g)))
     );

Distributing the graph
~~~~~~~~~~~~~~~~~~~~~~
The prior computation is entirely sequential, with the graph stored
within a single address space. To distribute the graph across several
processors without a shared address space, we need to represent the
processors and communication among them and alter the graph type. 

Processors and their interactions are abstracted via a *process
group*. In our case, we will use MPI_ for communication with
inter-processor messages sent immediately:
  
::

  typedef mpi::process_group<mpi::immediateS> process_group_type;

Next, we instruct the ``adjacency_list`` template
to distribute the vertices of the graph across our process group,
storing the local vertices in an ``std::vector``::

  typedef adjacency_list<listS, 
                         distributedS<process_group_type, vecS>, 
                         directedS,
                         no_property,                 // Vertex properties 
                         property<edge_weight_t, int> // Edge properties
                         > graph_t;
  typedef graph_traits < graph_t >::vertex_descriptor vertex_descriptor;
  typedef graph_traits < graph_t >::edge_descriptor edge_descriptor;

Note that the only difference from the sequential BGL is the use of
the ``distributedS`` selector, which identifies a distributed
graph. The vertices of the graph will be distributed among the
various processors, and the processor that owns a vertex also stores
the edges outgoing from that vertex and any properties associated
with that vertex or its edges. With three processors and the default
block distribution, the graph would be distributed in this manner:

.. image:: ../dijkstra_dist3_graph.png

Processor 0 (red) owns vertices A and B, including all edges outoing
from those vertices, processor 1 (green) owns vertices C and D (and
their edges), and processor 2 (blue) owns vertex E. Constructing this
graph uses the same syntax is the sequential graph, as in the section
`Construct the graph`_. 

The call to ``dijkstra_shortest_paths`` is syntactically equivalent to
the sequential call, but the mechanisms used are very different. The
property maps passed to ``dijkstra_shortest_paths`` are actually
*distributed* property maps, which store properties for local edges
or vertices and perform implicit communication to access properties
of remote edges or vertices when needed. The formulation of Dijkstra's
algorithm is also slightly different, because each processor can
only attempt to relax edges outgoing from local vertices: as shorter
paths to a vertex are discovered, messages to the processor owning
that vertex indicate that the vertex may require reprocessing. 

----------------------------------------------------------------------

Return to the `Parallel BGL home page`_

.. _Parallel BGL home page: index.html
.. _dijkstra_shortest_paths: http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html
.. _property maps: http://www.boost.org/libs/graph/doc/using_property_maps.html
.. _adjacency_list: http://www.boost.org/libs/graph/doc/adjacency_list.html
.. _MPI: http://www-unix.mcs.anl.gov/mpi/
.. _BGL: http://www.boost.org/libs/graph/doc
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| SSCA Generator
===========================

Generator from the Scalable Synthetic Compact Application #2 Graph Analysis benchmark.


-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

============================
|Logo| MPI BSP Process Group
============================

.. contents::

Introduction
------------

The MPI ``mpi_process_group`` is an implementation of the `process
group`_ interface using the Message Passing Interface (MPI). It is the
primary process group used in the Parallel BGL at this time.

Where Defined
-------------

Header ``<boost/graph/distributed/mpi_process_group.hpp>``

Reference
---------

::

  namespace boost { namespace graph { namespace distributed {

  class mpi_process_group 
  {
  public:
    typedef boost::mpi::communicator communicator_type;
    
    // Process group constructors
    mpi_process_group(communicator_type comm = communicator_type());
    mpi_process_group(std::size_t num_headers, std::size_t buffer_size, 
                      communicator_type comm = communicator_type());
    
    mpi_process_group();
    mpi_process_group(const mpi_process_group&, boost::parallel::attach_distributed_object);

    // Triggers
    template<typename Type, typename Handler>
      void trigger(int tag, const Handler& handler);

    template<typename Type, typename Handler>
      void trigger_with_reply(int tag, const Handler& handler);

    trigger_receive_context trigger_context() const;

    // Helper operations
    void poll();
    mpi_process_group base() const;
  };

  // Process query
  int process_id(const mpi_process_group&);
  int num_processes(const mpi_process_group&);

  // Message transmission
  template<typename T>
    void send(const mpi_process_group& pg, int dest, int tag, const T& value);

  template<typename T>
    void receive(const mpi_process_group& pg, int source, int tag, T& value);

  optional<std::pair<int, int> > probe(const mpi_process_group& pg);

  // Synchronization
  void synchronize(const mpi_process_group& pg);

  // Out-of-band communication
  template<typename T>
    void send_oob(const mpi_process_group& pg, int dest, int tag, const T& value);

  template<typename T, typename U>
    void 
    send_oob_with_reply(const mpi_process_group& pg, int dest, int
                        tag, const T& send_value, U& receive_value);

  template<typename T>
    void receive_oob(const mpi_process_group& pg, int source, int tag, T& value);

  } } }

Since the ``mpi_process_group`` is an implementation of the `process
group`_ interface, we omit the description of most of the functions in
the prototype. Two constructors need special mentioning:

::
  
      mpi_process_group(communicator_type comm = communicator_type());

The constructor can take an optional MPI communicator. As default a communicator
constructed from MPI_COMM_WORLD is used.

::
  
    mpi_process_group(std::size_t num_headers, std::size_t buffer_size, 
                      communicator_type comm = communicator_type());


For performance fine tuning the maximum number of headers in a message batch
(num_headers) and the maximum combined size of batched messages (buffer_size) 
can be specified. The maximum message size of a batch is 
16*num_headers+buffer_size. Sensible default values have been found by optimizing
a typical application on a cluster with Ethernet network, and are num_header=64k
and buffer_size=1MB, for a total maximum batches message size of 2MB.



-----------------------------------------------------------------------------

Copyright (C) 2007 Douglas Gregor

Copyright (C) 2007 Matthias Troyer

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _process group: process_group.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===================================
|Logo| R-MAT generator
===================================

::
 
  template<typename RandomGenerator, typename Graph>
  class rmat_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef void difference_type;

    rmat_iterator();
    rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                  edges_size_type m, double a, double b, double c, 
                  double d, bool permute_vertices = true);
    // Iterator operations
    reference operator*() const;
    pointer operator->() const;
    rmat_iterator& operator++();
    rmat_iterator operator++(int);
    bool operator==(const rmat_iterator& other) const;
    bool operator!=(const rmat_iterator& other) const;
 };

This class template implements a generator for R-MAT graphs [CZF04]_,
suitable for initializing an adjacency_list or other graph structure
with iterator-based initialization. An R-MAT graph has a scale-free
distribution w.r.t. vertex degree and is implemented using
Recursive-MATrix partitioning.

Where Defined
-------------
<``boost/graph/rmat_graph_generator.hpp``>

Constructors
------------

::

  rmat_iterator();

Constructs a past-the-end iterator.

::

  rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                edges_size_type m, double a, double b, double c, 
                double d, bool permute_vertices = true);

Constructs an R-MAT generator iterator that creates a graph with ``n``
vertices and ``m`` edges.  ``a``, ``b``, ``c``, and ``d`` represent
the probability that a generated edge is placed of each of the 4
quadrants of the partitioned adjacency matrix.  Probabilities are
drawn from the random number generator gen.  Vertex indices are
permuted to eliminate locality when ``permute_vertices`` is true.

Example
-------

::

  #include <boost/graph/adjacency_list.hpp>
  #include <boost/graph/rmat_graph_generator.hpp>
  #include <boost/random/linear_congruential.hpp>

  typedef boost::adjacency_list<> Graph;
  typedef boost::rmat_iterator<boost::minstd_rand, Graph> RMATGen;

  int main()
  {
    boost::minstd_rand gen;
    // Create graph with 100 nodes and 400 edges 
    Graph g(RMATGen(gen, 100, 400, 0.57, 0.19, 0.19, 0.05), RMATGen(), 100);
    return 0;
  }


Bibliography
------------

.. [CZF04] D Chakrabarti, Y Zhan, and C Faloutsos.  R-MAT: A Recursive
  Model for Graph Mining. In Proceedings of 4th International Conference
  on Data Mining, pages 442--446, 2004.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=============================================
|Logo| Non-Distributed Betweenness Centrality
=============================================

::

  // named parameter versions
  template<typename ProcessGroup, typename Graph, typename Param, typename Tag, typename Rest>
  void 
  non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                                 const bgl_named_params<Param,Tag,Rest>& params);

  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                                 CentralityMap centrality, Buffer sources);

  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename EdgeCentralityMap, typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                                 CentralityMap centrality,
                                                 EdgeCentralityMap edge_centrality_map, 
                                                 Buffer sources);

  // non-named parameter versions
  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename EdgeCentralityMap, typename IncomingMap, typename DistanceMap, 
           typename DependencyMap, typename PathCountMap, typename VertexIndexMap, 
           typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg,
                                                 const Graph& g, 
                                                 CentralityMap centrality,
                                                 EdgeCentralityMap edge_centrality_map,
                                                 IncomingMap incoming, 
                                                 DistanceMap distance, 
                                                 DependencyMap dependency,     
                                                 PathCountMap path_count,      
                                                 VertexIndexMap vertex_index,
                                                 Buffer sources);

  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename EdgeCentralityMap, typename IncomingMap, typename DistanceMap, 
           typename DependencyMap, typename PathCountMap, typename VertexIndexMap, 
           typename WeightMap, typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg,
                                                 const Graph& g, 
                                                 CentralityMap centrality,
                                                 EdgeCentralityMap edge_centrality_map,
                                                 IncomingMap incoming, 
                                                 DistanceMap distance, 
                                                 DependencyMap dependency,
                                                 PathCountMap path_count, 
                                                 VertexIndexMap vertex_index,
                                                 WeightMap weight_map,
                                                 Buffer sources);

  // helper functions
  template<typename Graph, typename CentralityMap>
  typename property_traits<CentralityMap>::value_type
  central_point_dominance(const Graph& g, CentralityMap centrality);

The ``non_distributed_betweenness_centrality()`` function computes the
betweenness centrality of the vertices and edges in a graph.  The name
is somewhat confusing, the graph ``g`` is not a distributed graph,
however the algorithm does run in parallel.  Rather than parallelizing
the individual shortest paths calculations that are required by
betweenness centrality, this variant of the algorithm performs the
shortest paths calculations in parallel with each process in ``pg``
calculating the shortest path from a different set of source vertices
using the BGL's implementation of `Dijkstra shortest paths`_.  Each
process accumulates into it's local centrality map and once all the
shortest paths calculations are performed a reduction is performed to
combine the centrality from all the processes.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/betweenness_centrality.hpp``>

Parameters
----------

IN: ``const ProcessGroup& pg`` 
  The process group over which the the processes involved in
  betweenness centrality communicate.  The process group type must
  model the `Process Group`_ concept.

IN: ``const Graph& g`` 
  The graph type must be a model of the `Incidence Graph`_ concept.

IN: ``CentralityMap centrality`` 
  A centrality map may be supplied to the algorithm, if one is not
  supplied a ``dummy_property_map`` will be used and no vertex
  centrality information will be recorded.  The key type of the
  ``CentralityMap`` must be the graph's vertex descriptor type.

  **Default**: A ``dummy_property_map``.

IN:  ``EdgeCentralityMap edge_centrality_map``
  An edge centrality map may be supplied to the algorithm, if one is
  not supplied a ``dummy_property_map`` will be used and no edge
  centrality information will be recorded.  The key type of the
  ``EdgeCentralityMap`` must be the graph's vertex descriptor type.

  **Default**: A ``dummy_property_map``.

IN:  ``IncomingMap incoming``
  The incoming map contains the incoming edges to a vertex that are
  part of shortest paths to that vertex.  Its key type must be the
  graph's vertex descriptor type and its value type must be the
  graph's edge descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of ``std::vector`` of the graph's edge descriptor
    type.

IN:  ``DistanceMap distance``
  The distance map records the distance to vertices during the
  shortest paths portion of the algorithm.  Its key type must be the
  graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the value type of the ``CentralityMap``.

IN: ``DependencyMap dependency`` 
  The dependency map records the dependency of each vertex during the
  centrality calculation portion of the algorithm.  Its key type must
  be the graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the value type of the ``CentralityMap``.

IN:  ``PathCountMap path_count``
  The path count map records the number of shortest paths each vertex
  is on during the centrality calculation portion of the algorithm.
  Its key type must be the graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the graph's degree size type.

IN:  ``VertexIndexMap vertex_index``
  A model of `Readable Property Map`_ whose key type is the vertex
  descriptor type of the graph ``g`` and whose value type is an
  integral type. The property map should map from vertices to their
  (local) indices in the range *[0, num_vertices(g))*.

  **Default**: ``get(vertex_index, g)``

IN:  ``WeightMap weight_map``
  A model of `Readable Property Map`_ whose key type is the edge
  descriptor type of the graph ``g``.  If not supplied the betweenness
  centrality calculation will be unweighted.

IN: ``Buffer sources`` 
  A model of Buffer_ containing the starting vertices for the
  algorithm.  If ``sources`` is empty a complete betweenness
  centrality calculation using all vertices in ``g`` will be
  performed.  The value type of the Buffer must be the graph's vertex
  descriptor type.

  **Default**: An empty ``boost::queue`` of int.

Complexity
----------

Each of the shortest paths calculations is *O(V log V)* and each of
them may be run in parallel (one per process in ``pg``).  The
reduction phase to calculate the total centrality at the end of the
shortest paths phase is *O(V log V)*.

Algorithm Description
---------------------

The algorithm uses a non-distributed (sequential) graph, as well as
non-distributed property maps.  Each process contains a separate copy
of the sequential graph ``g``.  In order for the algorithm to be
correct, these copies of ``g`` must be identical.  The ``sources``
buffer contains the vertices to use as the source of single source
shortest paths calculations when approximating betweenness centrality
using a subset of the vertices in the graph.  If ``sources`` is empty
then a complete betweenness centrality calculation is performed using
all vertices.

In the sequential phase of the algorithm each process computes
shortest paths from a subset of the vertices in the graph using the
Brandes shortest paths methods from the BGL's betweenness centrality
implementation.  In the parallel phase of the algorithm a reduction is
performed to sum the values computed by each process for all vertices
in the graph.

Either weighted or unweighted betweenness centrality is calculated
depending on whether a ``WeightMap`` is passed.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Process Group: process_group.html
.. _Buffer: http://www.boost.org/libs/graph/doc/Buffer.html
.. _Dijkstra shortest paths: http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| Fruchterman Reingold
===========================

::

    namespace graph { namespace distributed {

      template<typename Graph, typename PositionMap, 
               typename AttractiveForce, typename RepulsiveForce,
               typename ForcePairs, typename Cooling, typename DisplacementMap>
      void
      fruchterman_reingold_force_directed_layout
      (const Graph&    g,
       PositionMap     position,
       typename property_traits<PositionMap>::value_type const& origin,
       typename property_traits<PositionMap>::value_type const& extent,
       AttractiveForce attractive_force,
       RepulsiveForce  repulsive_force,
       ForcePairs      force_pairs,
       Cooling         cool,
       DisplacementMap displacement)

      template<typename Graph, typename PositionMap, 
               typename AttractiveForce, typename RepulsiveForce,
               typename ForcePairs, typename Cooling, typename DisplacementMap>
      void
      fruchterman_reingold_force_directed_layout
      (const Graph&    g,
       PositionMap     position,
       typename property_traits<PositionMap>::value_type const& origin,
       typename property_traits<PositionMap>::value_type const& extent,
       AttractiveForce attractive_force,
       RepulsiveForce  repulsive_force,
       ForcePairs      force_pairs,
       Cooling         cool,
       DisplacementMap displacement,
       simple_tiling   tiling)
    } }

.. contents::

Where Defined
-------------
<``boost/graph/distributed/fruchterman_reingold.hpp``>

also accessible from

<``boost/graph/fruchterman_reingold.hpp``>

Parameters
----------

IN:  ``const Graph& g``
  The graph type must be a model of `Distributed Graph`_.  The graph
  type must also model the `Incidence Graph`_.

OUT:  ``PositionMap position``

IN:  ``property_traits<PositionMap>::value_type origin``

IN:  ``property_traits<PositionMap>::value_type extent``

IN:  ``AttractiveForce attractive_force``

IN:  ``RepulsiveForce repulsive_force``

IN:  ``ForcePairs force_pairs``

IN:  ``Cooling cool``

IN:  ``DisplacementMap displacement``

..
 Complexity
 ----------

..
 Algorithm Description
 ---------------------

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Distributed Graph: DistributedGraph.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===================================
|Logo| Unique R-MAT generator
===================================

::
 
  template<typename RandomGenerator, typename Graph>
  class unique_rmat_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef void difference_type;

    unique_rmat_iterator();
    unique_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                  edges_size_type m, double a, double b, double c, 
                  double d, bool permute_vertices = true);
    // Iterator operations
    reference operator*() const;
    pointer operator->() const;
    unique_rmat_iterator& operator++();
    unique_rmat_iterator operator++(int);
    bool operator==(const unique_rmat_iterator& other) const;
    bool operator!=(const unique_rmat_iterator& other) const;
 };

This class template implements a generator for R-MAT graphs [CZF04]_,
suitable for initializing an adjacency_list or other graph structure
with iterator-based initialization. An R-MAT graph has a scale-free
distribution w.r.t. vertex degree and is implemented using
Recursive-MATrix partitioning.  The edge list produced by this iterator
is guaranteed not to contain parallel edges.

Where Defined
-------------
<``boost/graph/rmat_graph_generator.hpp``>

Constructors
------------

::

  unique_rmat_iterator();

Constructs a past-the-end iterator.

::

  unique_rmat_iterator(RandomGenerator& gen, vertices_size_type n, 
                       edges_size_type m, double a, double b, double c, 
                       double d, bool permute_vertices = true,
                       EdgePredicate ep = keep_all_edges());

Constructs an R-MAT generator iterator that creates a graph with ``n``
vertices and ``m`` edges.  ``a``, ``b``, ``c``, and ``d`` represent
the probability that a generated edge is placed of each of the 4
quadrants of the partitioned adjacency matrix.  Probabilities are
drawn from the random number generator ``gen``.  Vertex indices are
permuted to eliminate locality when ``permute_vertices`` is true.
``ep`` allows the user to specify which edges are retained, this is
useful in the case where the user wishes to refrain from storing
remote edges locally during generation to reduce memory consumption.

Example
-------

::

  #include <boost/graph/adjacency_list.hpp>
  #include <boost/graph/rmat_graph_generator.hpp>
  #include <boost/random/linear_congruential.hpp>

  typedef boost::adjacency_list<> Graph;
  typedef boost::unique_rmat_iterator<boost::minstd_rand, Graph> RMATGen;

  int main()
  {
    boost::minstd_rand gen;
    // Create graph with 100 nodes and 400 edges 
    Graph g(RMATGen(gen, 100, 400, 0.57, 0.19, 0.19, 0.05,), 
            RMATGen(), 100);
    return 0;
  }


Bibliography
------------

.. [CZF04] D Chakrabarti, Y Zhan, and C Faloutsos.  R-MAT: A Recursive
  Model for Graph Mining. In Proceedings of 4th International Conference
  on Data Mining, pages 442--446, 2004.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=============================
|Logo| Betweenness Centrality
=============================

::

  // named parameter versions
  template<typename Graph, typename Param, typename Tag, typename Rest>
  void 
  brandes_betweenness_centrality(const Graph& g, 
                                 const bgl_named_params<Param,Tag,Rest>& params);

  template<typename Graph, typename CentralityMap>
  void 
  brandes_betweenness_centrality(const Graph& g, CentralityMap centrality);

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap>
  void 
  brandes_betweenness_centrality(const Graph& g, CentralityMap centrality,
                                 EdgeCentralityMap edge_centrality_map);

  // non-named parameter versions
  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, typename DependencyMap, 
           typename PathCountMap, typename VertexIndexMap, typename Buffer>
  void  
  brandes_betweenness_centrality(const Graph& g, 
                                 CentralityMap centrality,
                                 EdgeCentralityMap edge_centrality_map,
                                 IncomingMap incoming, 
                                 DistanceMap distance, 
                                 DependencyMap dependency,     
                                 PathCountMap path_count,   
                                 VertexIndexMap vertex_index,
                                 Buffer sources,
                                 typename property_traits<DistanceMap>::value_type delta);

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap, 
           typename IncomingMap, typename DistanceMap, typename DependencyMap, 
           typename PathCountMap, typename VertexIndexMap, typename WeightMap, 
           typename Buffer>    
  void 
  brandes_betweenness_centrality(const Graph& g, 
                                 CentralityMap centrality,
                                 EdgeCentralityMap edge_centrality_map,
                                 IncomingMap incoming, 
                                 DistanceMap distance, 
                                 DependencyMap dependency,
                                 PathCountMap path_count, 
                                 VertexIndexMap vertex_index,
                                 Buffer sources,
                                 typename property_traits<WeightMap>::value_type delta,
                                 WeightMap weight_map);

  // helper functions
  template<typename Graph, typename CentralityMap>
  typename property_traits<CentralityMap>::value_type
  central_point_dominance(const Graph& g, CentralityMap centrality);

The ``brandes_betweenness_centrality()`` function computes the
betweenness centrality of the vertices and edges in a graph.  The
method of calculating betweenness centrality in *O(V)* space is due to
Brandes [Brandes01]_.  The algorithm itself is a modification of
Brandes algorithm by Edmonds [Edmonds09]_.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/betweenness_centrality.hpp``>

also accessible from

<``boost/graph/betweenness_centrality.hpp``>

Parameters
----------

IN:  ``const Graph& g``
  The graph type must be a model of `Distributed Graph`_.  The graph
  type must also model the `Incidence Graph`_ concept.  0-weighted
  edges in ``g`` will result in undefined behavior.

IN: ``CentralityMap centrality`` 
  A centrality map may be supplied to the algorithm, if not supplied a
  ``dummy_property_map`` will be used and no vertex centrality
  information will be recorded.  The ``CentralityMap`` type must be a
  `Distributed Property Map`_.  The key type must be the graph's
  vertex descriptor type.

  **Default**: A ``dummy_property_map``.

IN:  ``EdgeCentralityMap edge_centrality_map``
  An edge centrality map may be supplied to the algorithm, if not
  supplied a ``dummy_property_map`` will be used and no edge
  centrality information will be recorded.  The ``EdgeCentralityMap``
  type must be a `Distributed Property Map`_.  The key type must be
  the graph's vertex descriptor type.

  **Default**: A ``dummy_property_map``.

IN:  ``IncomingMap incoming``
  The incoming map contains the incoming edges to a vertex that are
  part of shortest paths to that vertex.  The ``IncomingMap`` type
  must be a `Distributed Property Map`_.  Its key type and value type
  must both be the graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of ``std::vector`` of the graph's vertex
    descriptor type.

IN:  ``DistanceMap distance``
  The distance map records the distance to vertices during the
  shortest paths portion of the algorithm.  The ``DistanceMap`` type
  must be a `Distributed Property Map`_.  Its key type must be the
  graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the value type of the ``CentralityMap``.

IN: ``DependencyMap dependency`` 
  The dependency map records the dependency of each vertex during the
  centrality calculation portion of the algorithm.  The
  ``DependencyMap`` type must be a `Distributed Property Map`_.  Its
  key type must be the graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the value type of the ``CentralityMap``.

IN:  ``PathCountMap path_count``

  The path count map records the number of shortest paths each vertex
  is on during the centrality calculation portion of the algorithm.
  The ``PathCountMap`` type must be a `Distributed Property Map`_.
  Its key type must be the graph's vertex descriptor type.

  **Default**: An ``iterator_property_map`` created from a
    ``std::vector`` of the graph's degree size type.

IN:  ``VertexIndexMap vertex_index``
  A model of `Readable Property Map`_ whose key type is the vertex
  descriptor type of the graph ``g`` and whose value type is an
  integral type. The property map should map from vertices to their
  (local) indices in the range *[0, num_vertices(g))*.

  **Default**: ``get(vertex_index, g)``

IN:  ``WeightMap weight_map``
  A model of `Readable Property Map`_ whose key type is the edge
  descriptor type of the graph ``g``.  If not supplied the betweenness
  centrality calculation will be unweighted.

IN: ``Buffer sources`` 
  A model of Buffer_ containing the starting vertices for the
  algorithm.  If ``sources`` is empty a complete betweenness
  centrality calculation using all vertices in ``g`` will be
  performed.  The value type of the Buffer must be the graph's vertex
  descriptor type.

  **Default**: An empty ``boost::queue`` of int.

Complexity
----------

Computing the shortest paths, counting them, and computing the
contribution to the centrality map is *O(V log V)*.  Calculating exact
betweenness centrality requires counting the shortest paths from all
vertices in ``g``, thus exact betweenness centrality is *O(V^2 log
V)*.

Algorithm Description
---------------------

For the vertices in ``sources`` (or all vertices in ``g`` when
``sources`` is empty) the algorithm first calls a customized
implementation of delta_stepping_shortest_paths_ which maintains a
shortest path tree using an ``IncomingMap``.  The ``IncomingMap``
contains the source of all incoming edges on shortest paths.

The ``IncomingMap`` defines the shortest path DAG at the target of the
edges in the shortest paths tree.  In the bidirectional case edge
flags could be used to translate the shortest paths information to the
source of the edges.  Setting edge flags during the shortest path
computation rather than using an ``IncomingMap`` would result in
adding an *O(V)* factor to the inner loop of the shortest paths
computation to account for having to clear edge flags when a new
shortest path is found.  This would increase the complexity of the
algorithm.  Asymptotically, the current implementation is better,
however using edge flags in the bidirectional case would reduce the
number of supersteps required by the depth of the shortest paths DAG
for each vertex.  Currently an ``outgoing`` map is explicitly
constructed by simply reversing the edges in the incoming map.  Once
the ``outgoing`` map is constructed it is traversed in dependency
order from the source of the shortest paths calculation in order to
compute path counts.  Once path counts are computed the shortest paths
DAG is again traversed in dependency order from the source to
calculate the dependency and centrality of each vertex.

The algorithm is complete when the centrality has been computed from
all vertices in ``g``.

Bibliography
------------

.. [Brandes01] Ulrik Brandes.  A Faster Algorithm for Betweenness
  Centrality. In the Journal of Mathematical Sociology, volume 25
  number 2, pages 163--177, 2001.

.. [Edmonds09] Nick Edmonds, Torsten Hoefler, and Andrew Lumsdaine.
  A Space-Efficient Parallel Algorithm for Computing Betweenness
  Centrality in Sparse Networks.  Indiana University tech report.
  2009.

-----------------------------------------------------------------------------

Copyright (C) 2009 The Trustees of Indiana University.

Authors: Nick Edmonds and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _delta_stepping_shortest_paths: dijkstra_shortest_paths.html
.. _Distributed Graph: DistributedGraph.html
.. _Incidence Graph: http://www.boost.org/libs/graph/doc/IncidenceGraph.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Buffer: http://www.boost.org/libs/graph/doc/Buffer.html
.. _Process Group: process_group.html
.. _Distributed Property Map: distributed_property_map.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===========================
|Logo| Connected Components
===========================

::
 
  namespace graph {
    // Default constructed ParentMap
    template<typename Graph, typename ComponentMap, typename ParentMap>
    typename property_traits<ComponentMap>::value_type
    connected_components( const Graph& g, ComponentMap c);

    // User supplied ParentMap
    template<typename Graph, typename ComponentMap, typename ParentMap>
    typename property_traits<ComponentMap>::value_type
    connected_components( const Graph& g, ComponentMap c, ParentMap p);
  }

The ``connected_components()`` function computes the connected
components of an undirected graph.  The distributed connected
components algorithm uses the sequential version of the connected
components algorithm to compute the connected components of the local
subgraph, then executes the parallel phase of the algorithm.  The
parallel portion of the connected components algorithm is loosely
based on the work of Goddard, Kumar, and Prins. The interface is a
superset of the interface to the BGL `sequential connected
components`_ algorithm.

Prior to executing the sequential phase of the algorithm, each process
identifies the roots of its local components.  An adjacency list of
all vertices adjacent to members of the component is then constructed
at the root vertex of each component.

The parallel phase of the distributed connected components algorithm
consists of a series of supersteps.  In each superstep, each root
attempts to hook to a member of it's adjacency list by assigning it's
parent pointer to that vertex.  Hooking is restricted to vertices
which are logically less than the current vertex to prevent looping.
Vertices which hook successfully are removed from the list of roots
and placed on another list of completed vertices.  All completed
vertices now execute a pointer jumping step until every completed
vertex has as its parent the root of a component.  This pointer
jumping step may be further optimized by the addition of Cycle
Reduction (CR) rules developed by Johnson and Metaxas, however current
performance evaluations indicate that this would have a negligible
impact on the overall performance of the algorithm.  These CR rules
reduce the number of pointer jumping steps from *O(n)* to *O(log n)*.
Following this pointer jumping step, roots which have hooked in this
phase transmit their adjacency list to their new parent.  The
remaining roots receive these edges and execute a pruning step on
their adjacency lists to remove vertices that are now members of their
component.  The parallel phase of the algorithm is complete when no
root successfully hooks.  Once the parallel phase is complete a final
pointer jumping step is performed on all vertices to assign the parent
pointers of the leaves of the initial local subgraph components to
their final parent which has now been determined.

The single largest performance bottleneck in the distributed connected
components algorithm is the effect of poor vertex distribution on the
algorithm.  For sparse graphs with a single large component, many
roots may hook to the same component, resulting in severe load
imbalance at the process owning this component.  Several methods of
modifying the hooking strategy to avoid this behavior have been
implemented but none has been successful as of yet.

.. contents::

Where Defined
-------------
<``boost/graph/connected_components.hpp``>

Parameters
----------

IN:  ``Graph& g``
  The graph typed must be a model of `Distributed Graph`_.

OUT:  ``ComponentMap c``
  The algorithm computes how many connected components are in the
  graph, and assigns each component an integer label.  The algorithm
  then records to which component each vertex in the graph belongs by
  recording the component number in the component property map.  The
  ``ComponentMap`` type must be a `Distributed Property Map`_.  The
  value type must be the ``vertices_size_type`` of the graph.  The key
  type must be the graph's vertex descriptor type. If you do not wish
  to compute component numbers, pass ``dummy_property_map`` as the
  component map and parent information will be provided in the parent
  map. 

UTIL:  ``ParentMap p``
  A parent map may be supplied to the algorithm, if not supplied the
  parent map will be constructed automatically.  The ``ParentMap`` type
  must be a `Distributed Property Map`_.  The value type and key type
  must be the graph's vertex descriptor type.

OUT:  ``property_traits<ComponentMap>::value_type``
  The number of components found will be returned as the value type of
  the component map.

Complexity
----------

The local phase of the algorithm is *O(V + E)*.  The parallel phase of
the algorithm requires at most *O(d)* supersteps where *d* is the
number of initial roots.  *d* is at most *O(V)* but becomes
significantly smaller as *E* increases.  The pointer jumping phase
within each superstep requires at most *O(c)* steps on each of the
completed roots where *c* is the length of the longest cycle.
Application of CR rules can reduce this to *O(log c)*.

Performance
-----------
The following charts illustrate the performance of the Parallel BGL
connected components algorithm. It performs well on very sparse and
very dense graphs. However, for cases where the graph has a medium
density with a giant connected component, the algorithm will perform
poorly. This is a known problem with the algorithm and as far as we
know all implemented algorithms have this degenerate behavior.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=9
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=9&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=9
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=9&speedup=1


-----------------------------------------------------------------------------

Copyright (C) 2004 The Trustees of Indiana University.

Authors: Nick Edmonds, Douglas Gregor, and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Sequential connected components: http://www.boost.org/libs/graph/doc/connected_components.html
.. _Distributed Graph: DistributedGraph.html
.. _Distributed Property Map: distributed_property_map.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

================================
|Logo| Concept Global Descriptor
================================

.. contents::

Description
-----------

A global descriptor is an object that represents an entity that is
owned by some process and may reside in an address space not
accessible to the currently-executing process. The global descriptor
consists of two parts: the *owner* of the entity, which is the
identifier of that process in which the entity resides, and a *local
descriptor*, that uniquely identifies the entity with the address
space of the owner. 

Refinement of
-------------

  - `Default Constructible`_
  - Assignable_

Notation
--------
X
  A type that models the Global Descriptor concept.

x
  Object of type X


Associated types
----------------

+----------------+--------------------+---------------------------------+
|Process ID type |``process_id_type`` |Determined by the process group  |
|                |                    |associated with type X.          |
+----------------+--------------------+---------------------------------+
|Local descriptor|``local_type``      |Determined by the data structure |
|type            |                    |the descriptor accesses.         |
|                |                    |Must model `Equality Comparable`_|
|                |                    |and `Copy Constructible`_.       |
+----------------+--------------------+---------------------------------+

Valid Expressions
-----------------

+----------------+---------------------+---------------------+-------------------------------------+
|Name            |Expression           |Type                 |Semantics                            |
+================+=====================+=====================+=====================================+
|Owner           |``owner(x)``         |``process_id_type``  |Returns the owner of ``x``.          |
+----------------+---------------------+---------------------+-------------------------------------+
|Local descriptor|``local(x)``         |``local_type``       |Returns the local descriptor         |
|                |                     |                     |uniquely identifying ``x``.          |
+----------------+---------------------+---------------------+-------------------------------------+


-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Assignable: http://www.sgi.com/tech/stl/Assignable.html
.. _Copy constructible: http://www.sgi.com/tech/stl/CopyConstructible.html
.. _Default constructible: http://www.sgi.com/tech/stl/DefaultConstructible.html
.. _Equality comparable: http://www.sgi.com/tech/stl/EqualityComparable.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=================================
|Logo| Boman et al graph coloring
=================================

::
  
  namespace graph { 
    template<typename DistributedGraph, typename ColorMap>
    typename property_traits<ColorMap>::value_type
    boman_et_al_graph_coloring
      (const DistributedGraph& g,
       ColorMap color,
       typename graph_traits<DistributedGraph>::vertices_size_type s = 100);

    template<typename DistributedGraph, typename ColorMap, typename ChooseColor>
    typename property_traits<ColorMap>::value_type
    boman_et_al_graph_coloring
      (const DistributedGraph& g,
       ColorMap color,
       typename graph_traits<DistributedGraph>::vertices_size_type s,
       ChooseColor choose_color);

    template<typename DistributedGraph, typename ColorMap, typename ChooseColor, 
             typename VertexOrdering>
    typename property_traits<ColorMap>::value_type
    boman_et_al_graph_coloring
      (const DistributedGraph& g, ColorMap color,
       typename graph_traits<DistributedGraph>::vertices_size_type s,
       ChooseColor choose_color, VertexOrdering ordering);

    template<typename DistributedGraph, typename ColorMap, typename ChooseColor,
             typename VertexOrdering, typename VertexIndexMap>
    typename property_traits<ColorMap>::value_type
    boman_et_al_graph_coloring
      (const DistributedGraph& g,
       ColorMap color,
       typename graph_traits<DistributedGraph>::vertices_size_type s,
       ChooseColor choose_color,
       VertexOrdering ordering, VertexIndexMap vertex_index);
  } 
  
The ``boman_et_al_graph_coloring`` function colors the vertices of an
undirected, distributed graph such that no two adjacent vertices have
the same color. All of the vertices of a given color form an
independent set in the graph. Graph coloring has been used to solve
various problems, including register allocation in compilers,
optimization problems, and scheduling problems.

.. image:: ../vertex_coloring.png
  :width: 462
  :height: 269
  :alt: Vertex coloring example
  :align: right

The problem of coloring a graph with the fewest possible number of
colors is NP-complete, so many algorithms (including the one
implemented here) are heuristic algorithms that try to minimize the
number of colors but are not guaranteed to provide an optimal
solution. This algorithm [BBC05]_ is similar to the
``sequential_vertex_coloring`` algorithm, that iterates through the
vertices once and selects the lowest-numbered color that the current
vertex can have. The coloring and the number of colors is therefore
related to the ordering of the vertices in the sequential case.

The distributed ``boman_et_al_graph_coloring`` algorithm will produce
different colorings depending on the ordering and distribution of the
vertices and the number of parallel processes cooperating to perform
the coloring. 

The algorithm returns the number of colors ``num_colors`` used to
color the graph.

.. contents::

Where Defined
~~~~~~~~~~~~~
<``boost/graph/distributed/boman_et_al_graph_coloring.hpp``>

Parameters
~~~~~~~~~~

IN: ``Graph& g``
  The graph type must be a model of `Distributed Vertex List Graph`_ and
  `Distributed Edge List Graph`_. 



UTIL/OUT: ``ColorMap color``
  Stores the color of each vertex, which will be a value in the range
  [0, ``num_colors``). The type ``ColorMap`` must model the
  `Read/Write Property Map`_ concept and must be a `distributed
  property map`_.



IN: ``vertices_size_type s``
  The number of vertices to color within each superstep. After
  ``s`` vertices have been colored, the colors of boundary vertices
  will be sent to their out-of-process neighbors. Smaller values
  communicate more often but may reduce the risk of conflicts,
  whereas larger values do more work in between communication steps
  but may create many conflicts.

  **Default**: 100

IN: ``ChooseColor choose_color``
  A function object that chooses the color for a vertex given the
  colors of its neighbors. The function object will be passed a vector
  of values (``marked``) and a ``marked_true`` value, and should
  return a ``color`` value such that ``color >= marked.size()`` or
  ``marked[color] != marked_true``. 

  **Default**:
  ``boost::graph::distributed::first_fit_color<color_type>()``, where
  ``color_type`` is the value type of the ``ColorMap`` property map.

IN: ``VertexOrdering ordering``
  A binary predicate function object that provides total ordering on
  the vertices in the graph. Whenever a conflict arises, only one of
  the processes involved will recolor the vertex in the next round,
  and this ordering determines which vertex should be considered
  conflicting (its owning process will then handle the
  conflict). Ideally, this predicate should order vertices so that
  conflicting vertices will be spread uniformly across
  processes. However, this predicate *must* resolve the same way on
  both processors. 

  **Default**: *unspecified*

IN: ``VertexIndexMap index``
  A mapping from vertex descriptors to indices in the range *[0,
  num_vertices(g))*. This must be a `Readable Property Map`_ whose
  key type is a vertex descriptor and whose value type is an integral
  type, typically the ``vertices_size_type`` of the graph.

  **Default:** ``get(vertex_index, g)``

Complexity
~~~~~~~~~~
The complexity of this algorithm is hard to characterize,
because it depends greatly on the number of *conflicts* that occur
during the algorithm. A conflict occurs when a *boundary vertex*
(i.e., a vertex that is adjacent to a vertex stored on a different
processor) is given the same color is a boundary vertex adjacency to
it (but on another processor). Conflicting vertices must be assigned
new colors, requiring additional work and communication. The work
involved in reassigning a color for a conflicting vertex is *O(d)*,
where *d* is the degree of the vertex and *O(1)* messages of *O(1)*
size are needed to resolve the conflict. Note that the number of
conflicts grows with (1) the number of processes and (2) the number
of inter-process edges.

Performance 
~~~~~~~~~~~

The performance of this implementation of Bomen et al's graph coloring
algorithm is illustrated by the following charts. Scaling and
performance is reasonable for all of the graphs we have tried.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&cluster=Odin&columns=11
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&cluster=Odin&columns=11&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&cluster=Odin&columns=11
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&cluster=Odin&columns=11&speedup=1

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Distributed Vertex List Graph: DistributedVertexListGraph.html
.. _Distributed Edge List Graph: DistributedEdgeListGraph.html
.. _Distributed property map: distributed_property_map.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Read/Write Property Map: http://www.boost.org/libs/property_map/ReadWritePropertyMap.html
.. [BBC05] Erik G. Boman, Doruk Bozdag, Umit Catalyurek, Assefaw
   H. Gebremedhin, and Fredrik Manne. A Scalable Parallel Graph Coloring
   Algorithm for Distributed Memory Computers. [preprint]
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===============================================
An Overview of the Parallel Boost Graph Library
===============================================

.. image:: ../graph.png
  :width: 206
  :height: 184
  :alt: An example graph
  :align: right

The Parallel Boost Graph Library (Parallel BGL) is a C++ library for
parallel, distributed computation on graphs. The Parallel BGL contains
distributed graph data structures, distributed graph algorithms,
abstractions over the communication medium (such as MPI), and
supporting data structures. A graph (also called a *network*) consists
of a set of *vertices* and a set of relationships between vertices,
called *edges*. The edges may be *undirected*, meaning that the
relationship between vertices is mutual, e.g., "X is related to Y", or
they can be *directed*, meaning that the relationship goes only one
way, e.g., "X is the child of Y". The following figure illustrates a
typical directed graph, where *a-i* are the vertices and the arrows
represent edges.

.. image:: ../distributed-graph.png
  :width: 229
  :height: 199
  :alt: A distributed graph
  :align: right

The Parallel BGL is primarily concerned with *distributed*
graphs. Distributed graphs are conceptually graphs, but their storage
is spread across multiple processors. The following figure
demonstrates a distributed version of the graph above, where the graph
has been divided among three processors (represented by the grey
rectangles). Edges in the graph may be either local (with both
endpoints stored on the same processor) or remote (the target of the
edge is stored on a different processor).

The Parallel BGL is a generic library. At its core are *generic*
distributed graph algorithms, which can operate on any distributed
graph data structure provided that data structure meets certain
requirements. For instance, the algorithm may need to enumerate the
set of vertices stored on the current processor, enumerate the set of
outgoing edges from a particular vertex, and determine on which
processor the target of each edge resides. The graph algorithms in the
Parallel BGL are also generic with respect to the *properties*
attached to edges and vertices in a graph; for instance, the weight of
each edge can be stored as part of the graph or allocated in a
completely separate data structure. 

The genericity available in the algorithms of the Parallel BGL allows
them to be applied to existing graph data structures. However, most
users will instead be writing new code that takes advantage of the
Parallel BGL. The Parallel BGL provides distributed graph data
structures that meet the requirements of the Parallel BGL
algorithms. The primary data structure is the `distributed adjacency
list`_, which allows storage and manipulation of a (distributed)
graph. The vertices in the graph are divided among the various
processors, and each of the edges outgoing from a vertex are stored on
the processor that "owns" (stores) that vertex. The following figure
illustrates the distributed adjacency list representation.

.. image:: ../dist-adjlist.png
  :width: 446
  :height: 154
  :alt: A distributed adjacency list
  :align: center

.. image:: ../dist-pmap.png
  :width: 271
  :height: 175
  :alt: A distributed property map
  :align: right

The `distributed adjacency list`_ distributes the structure of a graph
over multiple processors. While graph structure is in important part
of many graph problems, there are typically other properties attached
to the vertices and edges, such as edge weights or the position of
vertices within a grid. These properties are stored in *property
maps*, which associate a single piece of data with each edge or vertex
in a graph. Distributed property maps extend this notion to
distributed computing, where properties are stored on the same
processor as the vertex or edge. The following figure illustrates the
distribution of a property map storing colors (white, gray, black) for
each vertex. In addition to the storage for each vertex, the
processors store some "ghost cells" that cache values actually stored
on other processors, represented by the dashed boxes.

Tying together all of the distributed data structures of the Parallel
BGL are its process groups and distributed graph algorithms. Process
groups coordinate the interactions between multiple processes and
distributed data structures by abstracting the communication
mechanism. The algorithms are typically written using the SPMD model
(Single Program, Multiple Data) and interact with both the distributed
data structures and the process group itself. At various points in the
algorithm's execution, all processes execute a synchronization point,
which allows all of the distributed data structures to ensure an
appropriate degree of consistency across processes. The following
diagram illustrates the communication patterns within the the
execution of a distributed algorithm in the Parallel BGL. In
particular, the diagram illustrates the distributed data structures
used in a distributed breadth-first search, from the top-left and
proceeding clockwise:

   - a user-defined property map that tracks the distance from the
     source vertex to all other vertices,

   - an automatically-generated property map that tracks the "color"
     of vertices in the (distributed) graph, to determine which
     vertices have been seen before,

   - a distributed queue, which coordinates the breadth-first search
     and distributes new vertices to search, and

   - a distributed graph, on which the breadth-first search is
     operating.

.. image:: ../architecture.png
  :width: 485
  :height: 410
  :alt: Parallel Boost Graph Library architecture
  :align: center

----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. _Distributed adjacency list: distributed_adjacency_list.html
.. _Process groups: 
.. Copyright (C) 2004-2009 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===================================
|Logo| Parallel Boost Graph Library
===================================

Overview
--------

The Parallel Boost Graph Library is an extension to the `Boost Graph
Library`_ (BGL) for parallel and distributed computing. It offers
distributed graphs and graph algorithms to exploit coarse-grained
parallelism along with parallel algorithms that exploit fine-grained
parallelism, while retaining the same interfaces as the (sequential)
BGL. Code written using the sequential BGL should be easy to
parallelize with the parallel BGL. Visitors new to the Parallel BGL
should read our `architectural overview`_.

1. `Process groups`_

  - `MPI process group`_
  - `Simple trigger interface`_

2. Auxiliary data structures

  - `Distributed queue`_
  - `Distributed property map`_
 
3. Distributed graph concepts

  - `Distributed Graph`_
  - `Distributed Vertex List Graph`_
  - `Distributed Edge List Graph`_
  - `Global Descriptor`_

4. Graph data structures

  - `Distributed adjacency list`_

5. Graph adaptors

  - `Local subgraph adaptor`_
  - `Vertex list graph adaptor`_

6. Graph input/output

  - Graphviz output
  - `METIS input`_

7. Synthetic data generators

  - `R-MAT generator`_
  - `Sorted R-MAT generator`_
  - `Sorted unique R-MAT generator`_
  - `Unique R-MAT generator`_
  - `Scalable R-MAT generator`_
  - `Erdos-Renyi generator`_
  - `Sorted Erdos-Renyi generator`_
  - `Small world generator`_
  - `SSCA generator`_
  - `Mesh generator`_

8. Algorithms

  - Distributed algorithms 

    - `Breadth-first search`_
    - `Dijkstra's single-source shortest paths`_

      - `Eager Dijkstra shortest paths`_
      - `Crauser et al. Dijkstra shortest paths`_
      - `Delta-Stepping shortest paths`_

    - `Depth-first search`_
    - `Minimum spanning tree`_

      - `Boruvka's minimum spanning tree`_
      - `Merging local minimum spanning forests`_
      - `Boruvka-then-merge`_
      - `Boruvka-mixed-merge`_

    - Connected components

      - `Connected components`_
      - `Connected components parallel search`_
      - `Strongly-connected components`_
    
    - PageRank_
    - `Boman et al. Graph coloring`_
    - `Fruchterman Reingold force-directed layout`_
    - `s-t connectivity`_
    - `Betweenness centrality`_
    - `Non-distributed betweenness centrality`_

----------------------------------------------------------------------------

Copyright (C) 2005-2009 The Trustees of Indiana University.

Authors: Nick Edmonds, Douglas Gregor, and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Parallel Dijkstra example: dijkstra_example.html
.. _Boost Graph Library: http://www.boost.org/libs/graph/doc
.. _adjacency_list: http://www.boost.org/libs/graph/doc/adjacency_list.html
.. _local subgraph adaptor: local_subgraph.html
.. _vertex list graph adaptor: vertex_list_adaptor.html
.. _MPI: http://www-unix.mcs.anl.gov/mpi/
.. _generic programming: http://www.cs.rpi.edu/~musser/gp/
.. _development page: design/index.html
.. _process groups: process_group.html
.. _MPI process group: process_group.html
.. _Simple trigger interface: simple_trigger.html
.. _Open Systems Laboratory: http://www.osl.iu.edu
.. _Indiana University: http://www.indiana.edu
.. _Distributed adjacency list: distributed_adjacency_list.html
.. _Distributed queue: distributed_queue.html
.. _Distributed property map: distributed_property_map.html
.. _R-MAT generator: rmat_generator.html
.. _Sorted R-MAT generator: sorted_rmat_generator.html
.. _Sorted Unique R-MAT generator: sorted_unique_rmat_generator.html
.. _Unique R-MAT generator: unique_rmat_generator.html
.. _Scalable R-MAT generator: scalable_rmat_generator.html
.. _Erdos-Renyi generator: http://www.boost.org/libs/graph/doc/erdos_renyi_generator.html
.. _Sorted Erdos-Renyi generator: http://www.boost.org/libs/graph/doc/sorted_erdos_renyi_gen.html
.. _Small world generator: http://www.boost.org/libs/graph/doc/small_world_generator.html
.. _SSCA generator: ssca_generator.html
.. _Mesh generator: mesh_generator.html
.. _Breadth-first search: breadth_first_search.html
.. _Depth-first search: tsin_depth_first_visit.html
.. _Dijkstra's single-source shortest paths: dijkstra_shortest_paths.html
.. _Eager Dijkstra shortest paths: dijkstra_shortest_paths.html#eager-dijkstra-s-algorithm
.. _Crauser et al. Dijkstra shortest paths: dijkstra_shortest_paths.html#crauser-et-al-s-algorithm
.. _Delta-Stepping shortest paths: dijkstra_shortest_paths.html#delta-stepping-algorithm
.. _Minimum spanning tree: dehne_gotz_min_spanning_tree.html
.. _Boruvka's minimum spanning tree: dehne_gotz_min_spanning_tree.html#dense-boruvka-minimum-spanning-tree
.. _Merging local minimum spanning forests: dehne_gotz_min_spanning_tree.html#merge-local-minimum-spanning-trees
.. _Boruvka-then-merge: dehne_gotz_min_spanning_tree.html#boruvka-then-merge
.. _Boruvka-mixed-merge: dehne_gotz_min_spanning_tree.html#boruvka-mixed-merge
.. _PageRank: page_rank.html
.. _Boman et al. Graph coloring: boman_et_al_graph_coloring.html
.. _Connected components: connected_components.html
.. _Connected components parallel search: connected_components_parallel_search.html
.. _Strongly-connected components: strong_components.html
.. _Distributed Graph: DistributedGraph.html
.. _Distributed Vertex List Graph: DistributedVertexListGraph.html
.. _Distributed Edge List Graph: DistributedEdgeListGraph.html
.. _Global Descriptor: GlobalDescriptor.html
.. _METIS Input: metis.html
.. _architectural overview: overview.html
.. _Fruchterman Reingold force-directed layout: fruchterman_reingold.html
.. _s-t connectivity: st_connected.html
.. _Betweenness centrality: betweenness_centrality.html
.. _Non-distributed betweenness centrality: non_distributed_betweenness_centrality.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=========================================
|Logo| METIS Input Routines
=========================================

:: 

  namespace boost { 
    namespace graph {
      class metis_reader;
      class metis_exception;
      class metis_input_exception;
      class metis_distribution;
    }
  }


METIS_ is a set of programs for partitioning graphs (among other
things). The Parallel BGL can read the METIS graph format and
partition format, allowing one to easily load METIS-partitioned
graphs into the Parallel BGL's data structures.

.. contents::

Where Defined
~~~~~~~~~~~~~
<``boost/graph/metis.hpp``>


Graph Reader
------------------

::

  class metis_reader
  {
   public:
    typedef std::size_t vertices_size_type;
    typedef std::size_t edges_size_type;
    typedef double vertex_weight_type;
    typedef double edge_weight_type;

    class edge_iterator;
    class edge_weight_iterator;
    
    metis_reader(std::istream& in);

    edge_iterator begin();
    edge_iterator end();
    edge_weight_iterator weight_begin();

    vertices_size_type num_vertices() const;
    edges_size_type num_edges() const;

    std::size_t num_vertex_weights() const;

    vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n);

    bool has_edge_weights() const;
  };


Usage
~~~~~

The METIS reader provides an iterator interface to the METIS graph
file. The iterator interface is most useful when constructing Parallel
BGL graphs on-the-fly. For instance, the following code builds a graph
``g`` from a METIS graph stored in ``argv[1]``. 

::

  std::ifstream in_graph(argv[1]);
  metis_reader reader(in_graph);
  Graph g(reader.begin(), reader.end(),
          reader.weight_begin(),
          reader.num_vertices());


The calls to ``begin()`` and ``end()`` return an iterator range for
the edges in the graph; the call to ``weight_begin()`` returns an
iterator that will enumerate the weights of the edges in the
graph. For a distributed graph, the distribution will be determined
automatically by the graph; to use a METIS partitioning, see the
section `Partition Reader`_.

Associated Types 
~~~~~~~~~~~~~~~~

::

  metis_reader::edge_iterator

An `Input Iterator`_ that enumerates the edges in the METIS graph, and
is suitable for use as the ``EdgeIterator`` of an adjacency_list_.
The ``value_type`` of this iterator is a pair of vertex numbers.

-----------------------------------------------------------------------------

::

  metis_reader::edge_weight_iterator

An `Input Iterator`_ that enumerates the edge weights in the METIS
graph. The ``value_type`` of this iterator is ``edge_weight_type``. If
the edges in the METIS graph are unweighted, the result of
dereferencing this iterator will always be zero.

Member Functions
~~~~~~~~~~~~~~~~

::

  metis_reader(std::istream& in);

Constructs a new METIS reader that will retrieve edges from the input
stream ``in``. If any errors are encountered while initially parsing
``in``, ``metis_input_exception`` will be thrown.

-----------------------------------------------------------------------------

::

  edge_iterator begin();

Returns an iterator to the first edge in the METIS file. 

-----------------------------------------------------------------------------

::

  edge_iterator end();

Returns an iterator one past the last edge in the METIS file.

-----------------------------------------------------------------------------

::

  edge_weight_iterator weight_begin();

Returns an iterator to the first edge weight in the METIS file. The
weight iterator should be moved in concert with the edge iterator;
when the edge iterator moves, the edge weight changes. If the edges
in the graph are unweighted, the weight returned will always be zero.

-----------------------------------------------------------------------------

::

  vertices_size_type num_vertices() const;

Returns the number of vertices in the graph.


-----------------------------------------------------------------------------

::

    edges_size_type num_edges() const;

Returns the number of edges in the graph.

-----------------------------------------------------------------------------

::

    std::size_t num_vertex_weights() const;

Returns the number of weights attached to each vertex.

-----------------------------------------------------------------------------

::

    vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n);

-----------------------------------------------------------------------------

::

    bool has_edge_weights() const;  

Returns ``true`` when the edges of the graph have weights, ``false``
otherwise. When ``false``, the edge weight iterator is still valid
but returns zero for the weight of each edge.


Partition Reader
----------------

::

  class metis_distribution
  {
   public:  
    typedef int process_id_type;
    typedef std::size_t size_type;

    metis_distribution(std::istream& in, process_id_type my_id);
    
    size_type block_size(process_id_type id, size_type) const;
    process_id_type operator()(size_type n);
    size_type local(size_type n) const;
    size_type global(size_type n) const;
    size_type global(process_id_type id, size_type n) const;

   private:
    std::istream& in;
    process_id_type my_id;
    std::vector<process_id_type> vertices;
  };


Usage
~~~~~

The class ``metis_distribution`` loads a METIS partition file and
makes it available as a Distribution suitable for use with the
`distributed adjacency list`_ graph type. To load a METIS graph using
a METIS partitioning, use a ``metis_reader`` object for the graph and
a ``metis_distribution`` object for the distribution, as in the
following example.

::

  std::ifstream in_graph(argv[1]);
  metis_reader reader(in_graph);

  std::ifstream in_partitions(argv[2]);
  metis_distribution dist(in_partitions, process_id(pg));
  Graph g(reader.begin(), reader.end(),
          reader.weight_begin(),
          reader.num_vertices(),
          pg,
          dist);

In this example, ``argv[1]`` is the graph and ``argv[2]`` is the
partition file generated by ``pmetis``. The ``dist`` object loads the
partitioning information from the input stream it is given and uses
that to distributed the adjacency list. Note that the input stream
must be in the METIS partition file format and must have been
partitioned for the same number of processes are there are in the
process group ``pg``.

Member Functions
~~~~~~~~~~~~~~~~

::

  metis_distribution(std::istream& in, process_id_type my_id);

Creates a new METIS distribution from the input stream
``in``. ``my_id`` is the process ID of the current process in the
process group over which the graph will be distributed.

-----------------------------------------------------------------------------

::

  size_type block_size(process_id_type id, size_type) const;

Returns the number of vertices to be stored in the process
``id``. The second parameter, ``size_type``, is unused and may be any
value. 

-----------------------------------------------------------------------------

::

  process_id_type operator()(size_type n);

Returns the ID for the process that will store vertex number ``n``.

-----------------------------------------------------------------------------

::

  size_type local(size_type n) const;

Returns the local index of vertex number ``n`` within its owning
process. 

-----------------------------------------------------------------------------

::

  size_type global(size_type n) const;

Returns the global index of the current processor's local vertex ``n``. 

-----------------------------------------------------------------------------


::

  size_type global(process_id_type id, size_type n) const;
  
Returns the global index of the process ``id``'s local vertex ``n``.

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. _METIS: http://www-users.cs.umn.edu/~karypis/metis/metis/
.. _distributed adjacency list: distributed_adjacency_list.html
.. _adjacency_list: http://www.boost.org/libs/graph/doc/adjacency_list.html
.. _input iterator: http://www.sgi.com/tech/stl/InputIterator.html

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl
          
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

=============================
|Logo| Local Subgraph Adaptor
=============================

The local subgraph adaptor takes an existing `Distributed Graph` and
filters out all of the nonlocal edges and vertices, presenting only
the local portion of the distributed graph to the user. The behavior
is equivalent to (and implemented with) a `filtered graph`_, and is a
noncopying view into the graph itself. Changes made through the
filtered graph will be reflected in the original graph and vice-versa.

::

  template<typename DistributedGraph> class local_subgraph;

  template<typename DistributedGraph>
  local_subgraph<DistributedGraph> make_local_subgraph(DistributedGraph& g);

Where Defined
-------------
<boost/graph/distributed/local_subgraph.hpp>

Reference
---------
The local subgraph adaptor adapts and forwards all operations of
distributed graphs, the signatures of which will be omitted. Only
operations unique to the local subgraph adaptor are presented.

Member Functions
~~~~~~~~~~~~~~~~

::

  local_subgraph(DistributedGraph& g);

Constructs a local subgraph presenting the local portion of the
distributed graph ``g``.

--------------------------------------------------------------------------

::
 
  DistributedGraph&         base()               { return g; }
  const DistributedGraph&   base() const         { return g; }

Returns the underlying distributed graph.

Free Functions
~~~~~~~~~~~~~~

::

  template<typename DistributedGraph>
  local_subgraph<DistributedGraph> make_local_subgraph(DistributedGraph& g);

Constructs a local subgraph presenting the local portion of the
distributed graph ``g``.

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _filtered graph: http://www.boost.org/libs/graph/doc/filtered_graph.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

============================
|Logo| Minimum Spanning Tree
============================

The Parallel BGL contains four `minimum spanning tree`_ (MST)
algorithms [DG98]_ for use on undirected, weighted, distributed
graphs. The graphs need not be connected: each algorithm will compute
a minimum spanning forest (MSF) when provided with a disconnected
graph.

The interface to each of the four algorithms is similar to the
implementation of 'Kruskal's algorithm'_ in the sequential BGL. Each
accepts, at a minimum, a graph, a weight map, and an output
iterator. The edges of the MST (or MSF) will be output via the output
iterator on process 0: other processes may receive edges on their
output iterators, but the set may not be complete, depending on the
algorithm. The algorithm parameters are documented together, because
they do not vary greatly. See the section `Selecting an MST
algorithm`_ for advice on algorithm selection.

The graph itself must model the `Vertex List Graph`_ concept and the
Distributed Edge List Graph concept. Since the most common
distributed graph structure, the `distributed adjacency list`_, only
models the Distributed Vertex List Graph concept, it may only be used
with these algorithms when wrapped in a suitable adaptor, such as the
`vertex_list_adaptor`_. 

.. contents::

Where Defined
-------------
<``boost/graph/distributed/dehne_gotz_min_spanning_tree.hpp``>

Parameters
----------

IN: ``Graph& g``
  The graph type must be a model of `Vertex List Graph`_ and
  `Distributed Edge List Graph`_. 



IN/OUT: ``WeightMap weight``
  The weight map must be a `Distributed Property Map`_ and a `Readable
  Property Map`_ whose key type is the edge descriptor of the graph
  and whose value type is numerical.


  
IN/OUT: ``OutputIterator out``
  The output iterator through which the edges of the MSF will be
  written. Must be capable of accepting edge descriptors for output. 




IN: ``VertexIndexMap index``
  A mapping from vertex descriptors to indices in the range *[0,
  num_vertices(g))*. This must be a `Readable Property Map`_ whose
  key type is a vertex descriptor and whose value type is an integral
  type, typically the ``vertices_size_type`` of the graph.

  **Default:** ``get(vertex_index, g)``


IN/UTIL: ``RankMap rank_map``
  Stores the rank of each vertex, which is used for maintaining
  union-find data structures. This must be a `Read/Write Property Map`_
  whose key type is a vertex descriptor and whose value type is an
  integral type. 

  **Default:** An ``iterator_property_map`` built from an STL vector
  of the ``vertices_size_type`` of the graph and the vertex index map.


IN/UTIL: ``ParentMap parent_map``
  Stores the parent (representative) of each vertex, which is used for
  maintaining union-find data structures. This must be a `Read/Write
  Property Map`_ whose key type is a vertex descriptor and whose value
  type is also a vertex descriptor.

  **Default:** An ``iterator_property_map`` built from an STL vector
  of the ``vertex_descriptor`` of the graph and the vertex index map.


IN/UTIL: ``SupervertexMap supervertex_map``
  Stores the supervertex index of each vertex, which is used for
  maintaining the supervertex list data structures. This must be a
  `Read/Write Property Map`_ whose key type is a vertex descriptor and
  whose value type is an integral type.

  **Default:** An ``iterator_property_map`` built from an STL vector
  of the ``vertices_size_type`` of the graph and the vertex index map.



``dense_boruvka_minimum_spanning_tree``
---------------------------------------

:: 

  namespace graph {
    template<typename Graph, typename WeightMap, typename OutputIterator, 
             typename VertexIndexMap, typename RankMap, typename ParentMap, 
             typename SupervertexMap>
    OutputIterator
    dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                      OutputIterator out, 
                                      VertexIndexMap index,
                                      RankMap rank_map, ParentMap parent_map,
                                      SupervertexMap supervertex_map);

    template<typename Graph, typename WeightMap, typename OutputIterator, 
             typename VertexIndex>
    OutputIterator
    dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                      OutputIterator out, VertexIndex index);

    template<typename Graph, typename WeightMap, typename OutputIterator>
    OutputIterator
    dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                      OutputIterator out);
  }

Description
~~~~~~~~~~~

The dense Boruvka distributed minimum spanning tree algorithm is a
direct parallelization of the sequential MST algorithm by
Boruvka. The algorithm first creates a *supervertex* out of each
vertex. Then, in each iteration, it finds the smallest-weight edge
incident to each vertex, collapses supervertices along these edges,
and removals all self loops. The only difference between the
sequential and parallel algorithms is that the parallel algorithm
performs an all-reduce operation so that all processes have the
global minimum set of edges.

Unlike the other three algorithms, this algorithm emits the complete
list of edges in the minimum spanning forest via the output iterator
on all processes. It may therefore be more useful than the others
when parallelizing sequential BGL programs.

Complexity
~~~~~~~~~~

The distributed algorithm requires *O(log n)* BSP supersteps, each of
which requires *O(m/p + n)* time and *O(n)* communication per
process. 

Performance
~~~~~~~~~~~

The following charts illustrate the performance of this algorithm on
various random graphs. We see that the algorithm scales well up to 64
or 128 processors, depending on the type of graph, for dense
graphs. However, for sparse graphs performance tapers off as the
number of processors surpases *m/n*, i.e., the average degree (which
is 30 for this graph). This behavior is expected from the algorithm.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=5
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=5&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=5
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=5&speedup=1

``merge_local_minimum_spanning_trees``
--------------------------------------

::

  namespace graph {
    template<typename Graph, typename WeightMap, typename OutputIterator,
             typename VertexIndexMap>
    OutputIterator
    merge_local_minimum_spanning_trees(const Graph& g, WeightMap weight,
                                       OutputIterator out, 
                                       VertexIndexMap index);

    template<typename Graph, typename WeightMap, typename OutputIterator>
    inline OutputIterator
    merge_local_minimum_spanning_trees(const Graph& g, WeightMap weight,
                                       OutputIterator out);
  }

Description
~~~~~~~~~~~

The merging local MSTs algorithm operates by computing minimum
spanning forests from the edges stored on each process. Then the
processes merge their edge lists along a tree. The child nodes cease
participating in the computation, but the parent nodes recompute MSFs
from the newly acquired edges. In the final round, the root of the
tree computes the global MSFs, having received candidate edges from
every other process via the tree.

Complexity
~~~~~~~~~~

This algorithm requires *O(log_D p)* BSP supersteps (where *D* is the
number of children in the tree, and is currently fixed at 3). Each
superstep requires *O((m/p) log (m/p) + n)* time and *O(m/p)*
communication per process.

Performance
~~~~~~~~~~~

The following charts illustrate the performance of this algorithm on
various random graphs. The algorithm only scales well for very dense
graphs, where most of the work is performed in the initial stage and
there is very little work in the later stages. 

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=6
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=6&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=6
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=6&speedup=1


``boruvka_then_merge``
----------------------

::

  namespace graph {
    template<typename Graph, typename WeightMap, typename OutputIterator,
             typename VertexIndexMap, typename RankMap, typename ParentMap,
             typename SupervertexMap>
    OutputIterator
    boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out,
                       VertexIndexMap index, RankMap rank_map, 
                       ParentMap parent_map, SupervertexMap
                       supervertex_map);

    template<typename Graph, typename WeightMap, typename OutputIterator,
             typename VertexIndexMap>
    inline OutputIterator
    boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out,
                        VertexIndexMap index);

    template<typename Graph, typename WeightMap, typename OutputIterator>
    inline OutputIterator
    boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out);
  }

Description
~~~~~~~~~~~

This algorithm applies both Boruvka steps and local MSF merging steps
together to achieve better asymptotic performance than either
algorithm alone. It first executes Boruvka steps until only *n/(log_d
p)^2* supervertices remain, then completes the MSF computation by
performing local MSF merging on the remaining edges and
supervertices. 

Complexity
~~~~~~~~~~

This algorithm requires *log_D p* + *log log_D p* BSP supersteps. The
time required by each superstep depends on the type of superstep
being performed; see the distributed Boruvka or merging local MSFS
algorithms for details.

Performance
~~~~~~~~~~~

The following charts illustrate the performance of this algorithm on
various random graphs. We see that the algorithm scales well up to 64
or 128 processors, depending on the type of graph, for dense
graphs. However, for sparse graphs performance tapers off as the
number of processors surpases *m/n*, i.e., the average degree (which
is 30 for this graph). This behavior is expected from the algorithm.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=7
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=7&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=7
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=7&speedup=1

``boruvka_mixed_merge``
-----------------------

::

  namespace {
    template<typename Graph, typename WeightMap, typename OutputIterator,
             typename VertexIndexMap, typename RankMap, typename ParentMap,
             typename SupervertexMap>
    OutputIterator
    boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out,
                        VertexIndexMap index, RankMap rank_map, 
                        ParentMap parent_map, SupervertexMap
                        supervertex_map);

    template<typename Graph, typename WeightMap, typename OutputIterator,
             typename VertexIndexMap>
    inline OutputIterator
    boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out,
                        VertexIndexMap index);

    template<typename Graph, typename WeightMap, typename OutputIterator>
    inline OutputIterator
    boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out);
  }

Description
~~~~~~~~~~~

This algorithm applies both Boruvka steps and local MSF merging steps
together to achieve better asymptotic performance than either method
alone. In each iteration, the algorithm first performs a Boruvka step
and then merges the local MSFs computed based on the supervertex
graph. 

Complexity
~~~~~~~~~~

This algorithm requires *log_D p* BSP supersteps. The
time required by each superstep depends on the type of superstep
being performed; see the distributed Boruvka or merging local MSFS
algorithms for details. However, the algorithm is
communication-optional (requiring *O(n)* communication overall) when
the graph is sufficiently dense, i.e., *m/n >= p*.

Performance
~~~~~~~~~~~

The following charts illustrate the performance of this algorithm on
various random graphs. We see that the algorithm scales well up to 64
or 128 processors, depending on the type of graph, for dense
graphs. However, for sparse graphs performance tapers off as the
number of processors surpases *m/n*, i.e., the average degree (which
is 30 for this graph). This behavior is expected from the algorithm.

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeSparse&columns=8&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER,SF,SW&dataset=TimeDense&columns=8&speedup=1


Selecting an MST algorithm
--------------------------

Dehne and Gotz reported [DG98]_ mixed results when evaluating these
four algorithms. No particular algorithm was clearly better than the
others in all cases. However, the asymptotically best algorithm
(``boruvka_mixed_merge``) seemed to perform more poorly in their tests
than the other merging-based algorithms. The following performance
charts illustrate the performance of these four minimum spanning tree
implementations. 

Overall, ``dense_boruvka_minimum_spanning_tree`` gives the most
consistent performance and scalability for the graphs we
tested. Additionally, it may be more suitable for sequential programs
that are being parallelized, because it emits complete MSF edge lists
via the output iterators in every process.

Performance on Sparse Graphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER&dataset=TimeSparse&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER&dataset=TimeSparse&columns=5,6,7,8&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SF&dataset=TimeSparse&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SF&dataset=TimeSparse&columns=5,6,7,8&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SW&dataset=TimeSparse&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SW&dataset=TimeSparse&columns=5,6,7,8&speedup=1

Performance on Dense Graphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER&dataset=TimeDense&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=ER&dataset=TimeDense&columns=5,6,7,8&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SF&dataset=TimeDense&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SF&dataset=TimeDense&columns=5,6,7,8&speedup=1

.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SW&dataset=TimeDense&columns=5,6,7,8
  :align: left
.. image:: http://www.osl.iu.edu/research/pbgl/performance/chart.php?generator=SW&dataset=TimeDense&columns=5,6,7,8&speedup=1

-----------------------------------------------------------------------------

Copyright (C) 2004 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _minimum spanning tree: http://www.boost.org/libs/graph/doc/graph_theory_review.html#sec:minimum-spanning-tree
.. _Kruskal's algorithm: http://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html
.. _Vertex list graph: http://www.boost.org/libs/graph/doc/VertexListGraph.html
.. _distributed adjacency list: distributed_adjacency_list.html
.. _vertex_list_adaptor: vertex_list_adaptor.html
.. _Distributed Edge List Graph: DistributedEdgeListGraph.html
.. _Distributed property map: distributed_property_map.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Read/Write Property Map: http://www.boost.org/libs/property_map/ReadWritePropertyMap.html

.. [DG98] Frank Dehne and Silvia Gotz. *Practical Parallel Algorithms
    for Minimum Spanning Trees*. In Symposium on Reliable Distributed Systems, 
    pages 366--371, 1998.

.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

===============
|Logo| PageRank
===============

::
  
  namespace graph { 
    template<typename Graph, typename RankMap, typename Done>
    inline void
    page_rank(const Graph& g, RankMap rank_map, Done done, 
              typename property_traits<RankMap>::value_type damping = 0.85);

    template<typename Graph, typename RankMap>
    inline void
    page_rank(const Graph& g, RankMap rank_map);
  } 
  
The ``page_rank`` algorithm computes the ranking of vertices in a
graph, based on the connectivity of a directed graph [PBMW98]_. The
idea of PageRank is based on a random model of a Web surfer, who
starts a random web page and then either follows a link from that web
page (choosing from the links randomly) or jumps to a completely
different web page (not necessarily linked from the current
page). The PageRank of each page is the probability of the random web
surfer visiting that page.

.. contents::

Where Defined
~~~~~~~~~~~~~
<``boost/graph/distributed/page_rank.hpp``>

also accessible from

<``boost/graph/page_rank.hpp``>

Parameters
~~~~~~~~~~

IN: ``Graph& g``
  The graph type must be a model of `Distributed Vertex List Graph`_ and
  `Distributed Edge List Graph`_. The graph must be directed.

OUT: ``RankMap rank``
  Stores the rank of each vertex. The type ``RankMap`` must model the
  `Read/Write Property Map`_ concept and must be a `distributed
  property map`_. Its key type must be the vertex descriptor of the
  graph type and its value type must be a floating-point or rational
  type. 

IN: ``Done done``
  A function object that determines when the PageRank algorithm
  should complete. It will be passed two parameters, the rank map and
  a reference to the graph, and should return ``true`` when the
  algorithm should terminate.

  **Default**: ``graph::n_iterations(20)``

IN: ``typename property_traits<RankMap>::value_type damping``
  The damping factor is the probability that the Web surfer will
  select an outgoing link from the current page instead of jumping to
  a random page. 

  **Default**: 0.85

Complexity
~~~~~~~~~~
Each iteration of PageRank requires *O((V + E)/p)* time on *p*
processors and performs *O(V)* communication. The number of
iterations is dependent on the input to the algorithm.

Bibliography
------------

.. [PBMW98] Lawrence Page, Sergey Brin, Rajeev Motwani, and Terry
  Winograd. The PageRank Citation Ranking: Bringing Order to the
  Web. Technical report, Stanford Digital Library Technologies Project,
  November 1998.

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Distributed Vertex List Graph: DistributedVertexListGraph.html
.. _Distributed Edge List Graph: DistributedEdgeListGraph.html
.. _Distributed property map: distributed_property_map.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Read/Write Property Map: http://www.boost.org/libs/property_map/ReadWritePropertyMap.html

.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

============================================
|Logo| Concept Distributed Vertex List Graph
============================================

.. contents::

Description
-----------

A Distributed Vertex List Graph is a graph whose vertices are
distributed across multiple processes or address spaces. The
``vertices`` and ``num_vertices`` functions retain the same
signatures as in the `Vertex List Graph`_ concept, but return only
the local set (and size of the local set) of vertices. 

Notation
--------

G
  A type that models the Distributed Vertex List Graph concept.

g
  An object of type ``G``.

Refinement of
-------------

  - `Graph`_

Associated types
----------------

+----------------+---------------------------------------+---------------------------------+
|Vertex          |``graph_traits<G>::vertex_descriptor`` |Must model the                   |
|descriptor type |                                       |`Global Descriptor`_ concept.    |
+----------------+---------------------------------------+---------------------------------+
|Vertex iterator |``graph_traits<G>::vertex_iterator``   |Iterates over vertices stored    |
|type            |                                       |locally. The value type must be  |
|                |                                       |``vertex_descriptor``.           |
+----------------+---------------------------------------+---------------------------------+
|Vertices size   |``graph_traits<G>::vertices_size_type``|The unsigned integral type used  |
|type            |                                       |to store the number of vertices  |
|                |                                       |in the local subgraph.           |
+----------------+---------------------------------------+---------------------------------+

Valid Expressions
-----------------

+----------------+---------------------+----------------------+-------------------------------------+
|Name            |Expression           |Type                  |Semantics                            |
+================+=====================+======================+=====================================+
|Local vertex set|``vertices(g)``      |``std::pair<``        |Returns an iterator range            |
|                |                     |``vertex_iterator,``  |providing access to the local        |
|                |                     |``vertex_iterator>``  |vertices in the graph.               |
+----------------+---------------------+----------------------+-------------------------------------+
|Number of local |``num_vertices(g)``  |``vertices_size_type``|Returns the number of vertices       |
|vertices.       |                     |                      |stored locally in the graph.         |
+----------------+---------------------+----------------------+-------------------------------------+


Models
------

  - `Distributed adjacency list`_

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Graph: http://www.boost.org/libs/graph/doc/Graph.html
.. _Vertex List Graph: http://www.boost.org/libs/graph/doc/VertexListGraph.html
.. _Distributed Graph: DistributedGraph.html
.. _Global descriptor: GlobalDescriptor.html
.. _Distributed adjacency list: distributed_adjacency_list.html
.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

======================================
``distributedS`` Distribution Selector
======================================

The Boost Graph Library's class template adjacency_list_ supports
several selectors that indicate what data structure should be used for
the storage of edges or vertices. The selector ``vecS``, for instance,
indicates storage in a ``std::vector`` whereas ``listS`` indicates
storage in a ``std::list``. The Parallel BGL's `distributed
adjacency list`_ supports an additional selector, ``distributedS``,
that indicates that the storage should be distributed across multiple
processes. This selector can transform a sequential adjacency list
into a distributed adjacency list.

::

  template<typename ProcessGroup, typename LocalSelector = vecS>
  struct distributedS;


Template parameters
~~~~~~~~~~~~~~~~~~~

**ProcessGroup**:
  The type of the process group over which the property map is
  distributed and also the medium for communication. This type must
  model the `Process Group`_ concept, but certain data structures may
  place additional requirements on this parameter.

**LocalSelector**:
  A selector type (e.g., ``vecS``) that indicates how vertices or
  edges should be stored in each process. 

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine


.. _adjacency_list: http://www.boost.org/libs/graph/doc/adjacency_list.html
.. _Distributed adjacency list: distributed_adjacency_list.html
.. _Process group: process_group.html

.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

================================
|Logo| Vertex List Graph Adaptor
================================

::

  template<typename Graph, typename GlobalIndexMap>
  class vertex_list_adaptor
  {
  public:
    vertex_list_adaptor(const Graph& g, 
                        const GlobalIndexMap& index_map = GlobalIndexMap());
  };

  template<typename Graph, typename GlobalIndexMap>
  vertex_list_adaptor<Graph, GlobalIndexMap>
  make_vertex_list_adaptor(const Graph& g, const GlobalIndexMap& index_map);

  template<typename Graph>
  vertex_list_adaptor<Graph, *unspecified*>
  make_vertex_list_adaptor(const Graph& g);


The vertex list graph adaptor adapts any model of `Distributed Vertex List
Graph`_ in a `Vertex List Graph`_. In the former type of graph, the
set of vertices is distributed across the process group, so no
process has access to all vertices. In the latter type of graph,
however, every process has access to every vertex in the graph. This
is required by some distributed algorithms, such as the
implementations of `Minimum spanning tree`_ algorithms.

.. contents::

Where Defined
-------------
<``boost/graph/distributed/vertex_list_adaptor.hpp``>


Class template ``vertex_list_adaptor``
--------------------------------------

The ``vertex_list_adaptor`` class template takes a `Distributed
Vertex List Graph`_ and a mapping from vertex descriptors to global
vertex indices, which must be in the range *[0, n)*, where *n* is the
number of vertices in the entire graph. The mapping is a `Readable
Property Map`_ whose key type is a vertex descriptor.

The vertex list adaptor stores only a reference to the underlying
graph, forwarding all operations not related to the vertex list on to
the underlying graph. For instance, if the underlying graph models
`Adjacency Graph`_, then the adaptor will also model `Adjacency
Graph`_. Note, however, that no modifications to the underlying graph
can occur through the vertex list adaptor. Modifications made to the
underlying graph directly will be reflected in the vertex list
adaptor, but modifications that add or remove vertices invalidate the
vertex list adaptor. Additionally, the vertex list adaptor provides
access to the global index map via the ``vertex_index`` property.

On construction, the vertex list adaptor performs an all-gather
operation to create a list of all vertices in the graph within each
process. It is this list that is accessed via *vertices* and the
length of this list that is accessed via *num_vertices*. Due to the
all-gather operation, the creation of this adaptor is a collective
operation. 

Function templates ``make_vertex_list_adaptor``
-----------------------------------------------

These function templates construct a vertex list adaptor from a graph
and, optionally, a property map that maps vertices to global index
numbers. 

Parameters
~~~~~~~~~~

IN: ``Graph& g``
  The graph type must be a model of `Distributed Vertex List Graph`_.

IN: ``GlobalIndexMap index_map``
  A `Distributed property map`_ whose type must model `Readable
  property map`_ that maps from vertices to a global index. If
  provided, this map must be initialized prior to be passed to the
  vertex list adaptor.

  **Default:** A property map of unspecified type constructed from a
  distributed ``iterator_property_map`` that uses the
  ``vertex_index`` property map of the underlying graph and a vector
  of ``vertices_size_type``.

Complexity
~~~~~~~~~~
These operations require *O(n)* time, where *n* is the number of
vertices in the graph, and *O(n)* communication per node in the BSP model.

-----------------------------------------------------------------------------

Copyright (C) 2004 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Kruskal's algorithm: http://www.boost.org/libs/graph/doc/kruskal_min_spanning_tree.html
.. _Vertex list graph: http://www.boost.org/libs/graph/doc/VertexListGraph.html
.. _Adjacency graph: http://www.boost.org/libs/graph/doc/AdjacencyGraph.html
.. _distributed adjacency list: distributed_adjacency_list.html
.. _Minimum spanning tree: dehne_gotz_min_spanning_tree.html
.. _Distributed Vertex List Graph: DistributedVertexListGraph.html
.. _Distributed property map: distributed_property_map.html
.. _Readable Property Map: http://www.boost.org/libs/property_map/ReadablePropertyMap.html
.. _Read/Write Property Map: http://www.boost.org/libs/property_map/ReadWritePropertyMap.html


.. Copyright (C) 2004-2008 The Trustees of Indiana University.
   Use, modification and distribution is subject to the Boost Software
   License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt)

==========================================
|Logo| Concept Distributed Edge List Graph
==========================================

.. contents::

Description
-----------

A Distributed Edge List Graph is a graph whose vertices are
distributed across multiple processes or address spaces. The
``vertices`` and ``num_vertices`` functions retain the same
signatures as in the `Edge List Graph`_ concept, but return only
the local set (and size of the local set) of vertices. 

Notation
--------

G
  A type that models the Distributed Edge List Graph concept.

g
  An object of type ``G``.

Refinement of
-------------

  - `Graph`_

Associated types
----------------

+----------------+---------------------------------------+---------------------------------+
|Edge            |``graph_traits<G>::edge_descriptor``   |Must model the                   |
|descriptor type |                                       |`Global Descriptor`_ concept.    |
+----------------+---------------------------------------+---------------------------------+
|Edge iterator   |``graph_traits<G>::edge_iterator``     |Iterates over edges stored       |
|type            |                                       |locally. The value type must be  |
|                |                                       |``edge_descriptor``.             |
+----------------+---------------------------------------+---------------------------------+
|Edges size      |``graph_traits<G>::edges_size_type``   |The unsigned integral type used  |
|type            |                                       |to store the number of edges     |
|                |                                       |in the local subgraph.           |
+----------------+---------------------------------------+---------------------------------+

Valid Expressions
-----------------

+----------------+---------------------+----------------------+-------------------------------------+
|Name            |Expression           |Type                  |Semantics                            |
+================+=====================+======================+=====================================+
|Local edge set  |``edges(g)``         |``std::pair<``        |Returns an iterator range            |
|                |                     |``edge_iterator,``    |providing access to the local        |
|                |                     |``edge_iterator>``    |edges in the graph.                  |
+----------------+---------------------+----------------------+-------------------------------------+
|Number of local |``num_edges(g)``     |``edges_size_type``   |Returns the number of edges          |
|edges.          |                     |                      |stored locally in the graph.         |
+----------------+---------------------+----------------------+-------------------------------------+


Models
------

  - `Distributed adjacency list`_

-----------------------------------------------------------------------------

Copyright (C) 2005 The Trustees of Indiana University.

Authors: Douglas Gregor and Andrew Lumsdaine

.. |Logo| image:: pbgl-logo.png
            :align: middle
            :alt: Parallel BGL
            :target: http://www.osl.iu.edu/research/pbgl

.. _Graph: http://www.boost.org/libs/graph/doc/Graph.html
.. _Edge List Graph: http://www.boost.org/libs/graph/doc/EdgeListGraph.html
.. _Distributed Graph: DistributedGraph.html
.. _Global descriptor: GlobalDescriptor.html
.. _Distributed adjacency list: distributed_adjacency_list.html
.. Macros/Introspection//BOOST_MPL_HAS_XXX_TEMPLATE_DEF

.. Copyright Daniel Walker 2007.
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

BOOST_MPL_HAS_XXX_TEMPLATE_DEF
==============================

Synopsis
--------

.. parsed-literal::

    #define BOOST_MPL_HAS_XXX_TEMPLATE_DEF(name) \\
        |unspecified-token-seq| \\
    /\*\*/


Description
-----------

Expands into the definition of a boolean |Metafunction| ``has_name``
such that for any type ``x`` ``has_name<x>::value == true`` if and
only if ``x`` is a class type and has a nested template member
``x::template name`` with no more than
|BOOST_MPL_LIMIT_METAFUNCTION_ARITY| parameters.

On deficient compilers not capable of performing the detection,
``has_name<x>::value`` is always ``false``. A boolean configuration
macro, |BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE|, is provided to signal or
override the "deficient" status of a particular compiler.

|Note:| |BOOST_MPL_HAS_XXX_TEMPLATE_DEF| is a simplified front end to
the |BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF| introspection macro |-- end
note|


Header
------

.. parsed-literal::
    
    #include <boost/mpl/has_xxx.hpp>


Parameters
----------


+---------------+-------------------------------+---------------------------------------------------+
| Parameter     | Requirement                   | Description                                       |
+===============+===============================+===================================================+
| ``name``      | A legal identifier token      | A name of the template member being detected.     |
+---------------+-------------------------------+---------------------------------------------------+


Expression semantics
--------------------

For any legal C++ identifier ``name``:

.. parsed-literal::

    BOOST_MPL_HAS_XXX_TEMPLATE_DEF(name)

:Precondition:
    Appears at namespace scope.

:Return type:
    None.

:Semantics:
    Equivalent to

    .. parsed-literal::

        BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(
              BOOST_PP_CAT(has\_,name), name, false
            )


Example
-------

.. parsed-literal::
    
    BOOST_MPL_HAS_XXX_TEMPLATE_DEF(xxx)
    
    struct test1  {};
    struct test2  { void xxx(); };
    struct test3  { int xxx; };
    struct test4  { static int xxx(); };
    struct test5  { typedef int xxx; };
    struct test6  { struct xxx; };
    struct test7  { typedef void (\*xxx)(); };
    struct test8  { typedef void (xxx)(); };
    struct test9  { template< class T > struct xxx {}; };
    
    BOOST_MPL_ASSERT_NOT(( has_xxx<test1> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test2> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test3> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test4> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test5> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test6> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test7> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test8> ));
    
    #if !defined(BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE)
    BOOST_MPL_ASSERT(( has_xxx<test9> ));
    #endif
    
    BOOST_MPL_ASSERT(( has_xxx<test9, true\_> ));


See also
--------

|Macros|, |BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF|,
|BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE|, |BOOST_MPL_LIMIT_METAFUNCTION_ARITY|

.. Macros/Configuration//BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE |20

.. Copyright Daniel Walker 2007.
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE
=================================

Synopsis
--------

.. parsed-literal::

    // #define BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE


Description
-----------

``BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE`` is a boolean configuration
macro signaling availability of the |BOOST_MPL_HAS_XXX_TEMPLATE_DEF| /
|BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF| introspection macros'
functionality on a particular compiler.


See also
--------

|Macros|, |Configuration|, |BOOST_MPL_HAS_XXX_TEMPLATE_DEF|, |BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF|


.. copyright:: Copyright   2009 Eric Niebler
   Distributed under the Boost Software License, Version 1.0. (See accompanying
   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
.. Macros/Introspection//BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF

.. Copyright Daniel Walker 2007.
.. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF
====================================

Synopsis
--------

.. parsed-literal::

    #define BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait, name, default\_) \\
        |unspecified-token-seq| \\
    /\*\*/


Description
-----------

Expands into the definition of a boolean |Metafunction| ``trait`` such
that for any type ``x`` ``trait<x>::value == true`` if and only if
``x`` is a class type and has a nested template member ``x::template
name`` with no more than |BOOST_MPL_LIMIT_METAFUNCTION_ARITY|
parameters.

On deficient compilers not capable of performing the detection,
``trait<x>::value`` always returns a fallback value ``default_``.  A
boolean configuration macro, |BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE|, is
provided to signal or override the "deficient" status of a particular
compiler.  |Note:| The fallback value can also be provided at the
point of the metafunction invocation; see the `Expression semantics`
section for details |-- end note|


Header
------

.. parsed-literal::
    
    #include <boost/mpl/has_xxx.hpp>


Parameters
----------

+---------------+-------------------------------+---------------------------------------------------+
| Parameter     | Requirement                   | Description                                       |
+===============+===============================+===================================================+
| ``trait``     | A legal identifier token      | A name of the metafunction to be generated.       |
+---------------+-------------------------------+---------------------------------------------------+
| ``name``      | A legal identifier token      | A name of the member being detected.              |
+---------------+-------------------------------+---------------------------------------------------+
| ``default_``  | An boolean constant           | A fallback value for the deficient compilers.     |
+---------------+-------------------------------+---------------------------------------------------+


Expression semantics
--------------------

For any legal C++ identifiers ``trait`` and ``name``, boolean constant
expression ``c1``, boolean |Integral Constant| ``c2``, and arbitrary
type ``x``:

.. parsed-literal::

    BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait, name, c1)

:Precondition:
    Appears at namespace scope.

:Return type:
    None.

:Semantics:
    Expands into an equivalent of the following class template
    definition

    .. parsed-literal::

        template<
            typename X
          , typename fallback = boost::mpl::bool\_<c1>
        >
        struct trait
        {
            // |unspecified|
            // ...
        };
    
    where ``trait`` is a boolean |Metafunction| with the following
    semantics:
    
    .. parsed-literal::

        typedef trait<x>::type r;

    :Return type:
        |Integral Constant|.

    :Semantics:
        If |BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE| is defined, ``r::value
        == c1``; otherwise, ``r::value == true`` if and only if ``x``
        is a class type that has a nested template member ``x::template
        name`` with no more than |BOOST_MPL_LIMIT_METAFUNCTION_ARITY|.
    
    
    .. parsed-literal::

        typedef trait< x, c2 >::type r;

    :Return type:
        |Integral Constant|.

    :Semantics:
        If |BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE| is defined, ``r::value
        == c2::value``; otherwise, equivalent to

        .. parsed-literal::

            typedef trait<x>::type r;


Example
-------

.. parsed-literal::
    
    BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(
        has_xxx, xxx, false
    )

    struct test1  {};
    struct test2  { void xxx(); };
    struct test3  { int xxx; };
    struct test4  { static int xxx(); };
    struct test5  { typedef int xxx; };
    struct test6  { struct xxx; };
    struct test7  { typedef void (\*xxx)(); };
    struct test8  { typedef void (xxx)(); };
    struct test9  { template< class T > struct xxx {}; };

    BOOST_MPL_ASSERT_NOT(( has_xxx<test1> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test2> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test3> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test4> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test5> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test6> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test7> ));
    BOOST_MPL_ASSERT_NOT(( has_xxx<test8> ));

    #if !defined(BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE)
    BOOST_MPL_ASSERT(( has_xxx<test9> ));
    #endif

    BOOST_MPL_ASSERT(( has_xxx<test9, true\_> ));


See also
--------

|Macros|, |BOOST_MPL_HAS_XXX_TEMPLATE_DEF|,
|BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE|, |BOOST_MPL_LIMIT_METAFUNCTION_ARITY|

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=============================================
 |(logo)|__ Getting Started on Unix Variants
=============================================

.. meta::
    :description: Getting Started with Boost on Unix Variants (including Linux and MacOS)

.. |(logo)| image:: ../../boost.png
   :alt: Boost
   :class: boost-logo

__ ../../index.htm

.. section-numbering::

.. maybe we don't need this
   .. Admonition:: A note to Cygwin_ and MinGW_ users

     If you plan to build from the Cygwin_ bash shell, you're in the
     right place.  If you plan to use your tools from the Windows
     command prompt, you should follow the instructions for `getting
     started on Windows`_.  Other command shells, such as MinGW_\ 's
     MSYS, are not supported—they may or may not work.

     .. _`Getting Started on Windows`: windows.html
     .. _Cygwin: http://www.cygwin.com
     .. _MinGW: http://mingw.org

.. Contents:: Index

Get Boost
=========

The most reliable way to get a copy of Boost is to download a
distribution from SourceForge_:

.. _SourceForge: `sf-download`_

1. Download |boost.tar.bz2|_.  

2. In the directory where you want to put the Boost installation,
   execute

   .. parsed-literal::

      tar --bzip2 -xf */path/to/*\ |boost_ver|\ .tar.bz2

.. |boost.tar.bz2| replace:: |boost_ver|\ ``.tar.bz2``

.. _`boost.tar.bz2`: `sf-download`_

.. Admonition:: Other Packages

   RedHat, Debian, and other distribution packagers supply Boost
   library packages, however you may need to adapt these
   instructions if you use third-party packages, because their
   creators usually choose to break Boost up into several packages,
   reorganize the directory structure of the Boost distribution,
   and/or rename the library binaries. [#packagers]_ If you have
   any trouble, we suggest using an official Boost distribution
   from SourceForge_.

.. include:: detail/distro.rst

.. include:: detail/header-only.rst

.. include:: detail/build-simple-head.rst

Now, in the directory where you saved ``example.cpp``, issue the
following command:

.. parsed-literal::

  c++ -I |root| example.cpp -o example

To test the result, type:

.. parsed-literal::

  echo 1 2 3 | ./example

.. include:: detail/errors-and-warnings.rst

.. include:: detail/binary-head.rst

Easy Build and Install
----------------------

Issue the following commands in the shell (don't type ``$``; that
represents the shell's prompt):

.. parsed-literal::

  **$** cd |root|
  **$** ./bootstrap.sh --help

Select your configuration options and invoke ``./bootstrap.sh`` again
without the ``--help`` option.  Unless you have write permission in
your system's ``/usr/local/`` directory, you'll probably want to at
least use

.. parsed-literal::

  **$** ./bootstrap.sh **--prefix=**\ *path*\ /\ *to*\ /\ *installation*\ /\ *prefix* 

to install somewhere else.  Also, consider using the
``--show-libraries`` and ``--with-libraries=``\ *library-name-list* options to limit the
long wait you'll experience if you build everything.  Finally,

.. parsed-literal::

  **$** ./b2 install

will leave Boost binaries in the ``lib/`` subdirectory of your
installation prefix.  You will also find a copy of the Boost
headers in the ``include/`` subdirectory of the installation
prefix, so you can henceforth use that directory as an ``#include``
path in place of the Boost root directory.

|next|__

__ `Link Your Program to a Boost Library`_

Or, Build Custom Binaries
-------------------------

If you're using a compiler other than your system's default, you'll
need to use Boost.Build_ to create binaries.

You'll also
use this method if you need a nonstandard build variant (see the
`Boost.Build documentation`_ for more details).

.. Admonition:: Boost.CMake

  There is also an experimental CMake build for boost, supported and distributed
  separately.  See the `Boost.CMake`_ wiki page for more information.

  .. _`Boost.CMake`:
       https://svn.boost.org/trac/boost/wiki/CMake

.. include:: detail/build-from-source-head.rst

For example, your session might look like this:

.. parsed-literal::

   $ cd ~/|boost_ver|
   $ b2 **--build-dir=**\ /tmp/build-boost **toolset=**\ gcc stage

That will build static and shared non-debug multi-threaded variants of the libraries. To build all variants, pass the additional option, “``--build-type=complete``”.

.. include:: detail/build-from-source-tail.rst

.. include:: detail/link-head.rst

There are two main ways to link to libraries:

A. You can specify the full path to each library:

   .. parsed-literal::

     $ c++ -I |root| example.cpp -o example **\\**
        **~/boost/stage/lib/libboost_regex-gcc34-mt-d-1_36.a**

B. You can separately specify a directory to search (with ``-L``\
   *directory*) and a library name to search for (with ``-l``\
   *library*, [#lowercase-l]_ dropping the filename's leading ``lib`` and trailing
   suffix (``.a`` in this case): 

   .. parsed-literal::

     $ c++ -I |root| example.cpp -o example **\\**
        **-L~/boost/stage/lib/ -lboost_regex-gcc34-mt-d-1_36**

   As you can see, this method is just as terse as method A for one
   library; it *really* pays off when you're using multiple
   libraries from the same directory.  Note, however, that if you
   use this method with a library that has both static (``.a``) and
   dynamic (``.so``) builds, the system may choose one
   automatically for you unless you pass a special option such as
   ``-static`` on the command line.

In both cases above, the bold text is what you'd add to `the
command lines we explored earlier`__.

__ `build a simple program using boost`_

Library Naming
--------------

.. include:: detail/library-naming.rst

.. include:: detail/test-head.rst

If you linked to a shared library, you may need to prepare some
platform-specific settings so that the system will be able to find
and load it when your program is run.  Most platforms have an
environment variable to which you can add the directory containing
the library.  On many platforms (Linux, FreeBSD) that variable is
``LD_LIBRARY_PATH``, but on MacOS it's ``DYLD_LIBRARY_PATH``, and
on Cygwin it's simply ``PATH``.  In most shells other than ``csh``
and ``tcsh``, you can adjust the variable as follows (again, don't
type the ``$``\ —that represents the shell prompt):

.. parsed-literal::

   **$** *VARIABLE_NAME*\ =\ *path/to/lib/directory*\ :${\ *VARIABLE_NAME*\ }
   **$** export *VARIABLE_NAME*

On ``csh`` and ``tcsh``, it's

.. parsed-literal::

   **$** setenv *VARIABLE_NAME* *path/to/lib/directory*\ :${\ *VARIABLE_NAME*\ }

Once the necessary variable (if any) is set, you can run your
program as follows:

.. parsed-literal::

   **$** *path*\ /\ *to*\ /\ *compiled*\ /\ example < *path*\ /\ *to*\ /\ jayne.txt

The program should respond with the email subject, “Will Success
Spoil Rock Hunter?”

.. include:: detail/conclusion.rst

------------------------------

.. [#packagers] If developers of Boost packages would like to work
   with us to make sure these instructions can be used with their
   packages, we'd be glad to help.  Please make your interest known
   to the `Boost developers' list`_.

   .. _Boost developers' list: http://www.boost.org/more/mailing_lists.htm#main

.. [#lowercase-l] That option is a dash followed by a lowercase “L”
   character, which looks very much like a numeral 1 in some fonts.

.. |build-type-complete| replace:: `` `` 

.. include:: detail/common-footnotes.rst
.. include:: detail/release-variables.rst
.. include:: detail/common-unix.rst
.. include:: detail/links.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

============================
 |(logo)|__ Getting Started
============================

.. |(logo)| image:: ../../boost.png
   :alt: Boost
   :class: boost-logo

__ ../../index.htm

.. Admonition:: Use the latest version of this Getting Started guide

  The `Boost website version of this Getting Started guide`_ may
  have updated information, such as the location of additional installers
  or improved installation procedures, so you might want use that version
  if you've got an Internet connection available.

  .. _`Boost website version of this Getting Started guide`:
       http://www.boost.org/more/getting_started/index.html

Welcome
-------

Welcome to the Boost libraries!  By the time you've completed this
tutorial, you'll be at least somewhat comfortable with the contents
of a Boost distribution and how to go about using it.  

What's Here
-----------

This document is designed to be an *extremely* gentle introduction,
so we included a fair amount of material that may already be very
familiar to you.  To keep things simple, we also left out some
information intermediate and advanced users will probably want.  At
the end of this document, we'll refer you on to resources that can
help you pursue these topics further.

Preliminaries
-------------

We use one typographic convention that might not be immediately
obvious: *italic* text in examples is meant as a descriptive
placeholder for something else, usually information that you'll
provide.  For example:

.. parsed-literal::

   **$** echo "My name is *your name*\ "

Here you're expected to imagine replacing the text “your name” with
your actual name.

Ready?
------

Let's go!

.. footer::
  .. class:: nextpage

     | **Next:** `Getting Started on Microsoft Windows`__
     | **or:** `Getting Started on Unix variants (e.g. Linux, MacOS)`__

__ windows.html
__ unix-variants.html

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

=======================================
 |(logo)|__ Getting Started on Windows
=======================================

.. |(logo)| image:: ../../boost.png
   :alt: Boost
   :class: boost-logo

.. role:: raw-html(raw)
   :format: html

__ ../../index.htm

.. section-numbering::

.. Admonition:: A note to Cygwin_ and MinGW_ users

  If you plan to use your tools from the Windows command prompt,
  you're in the right place.  If you plan to build from the Cygwin_
  bash shell, you're actually running on a POSIX platform and
  should follow the instructions for `getting started on Unix
  variants`_.  Other command shells, such as MinGW_\ 's MSYS, are
  not supported—they may or may not work.

  .. _`Getting Started on Unix Variants`: unix-variants.html
  .. _Cygwin: http://www.cygwin.com
  .. _MinGW: http://mingw.org

.. Contents:: Index

Get Boost
=========

The most reliable way to get a copy of Boost is to
download |boost.7z|_ or |boost_zip|_ and unpack it to install a complete Boost
distribution. [#zip]_

.. |boost.7z| replace:: |boost_ver|\ ``.7z``

.. _`boost.7z`: `sf-download`_

.. |boost_zip| replace:: |boost_ver|\ ``.zip``

.. _`boost_zip`: `sf-download`_

.. include:: detail/distro.rst

.. include:: detail/header-only.rst

.. include:: detail/build-simple-head.rst

.. _`command prompt`:
.. _`command-line tool`:

.. Note:: To build the examples in this guide, you can use an
   Integrated Development Environment (IDE) like Visual Studio, or
   you can issue commands from the `command prompt`_.  Since every
   IDE and compiler has different options and Microsoft's are by
   far the dominant compilers on Windows, we only give specific
   directions here for Visual Studio 2005 and .NET 2003 IDEs and
   their respective command prompt compilers (using the command
   prompt is a bit simpler).  If you are using another compiler or
   IDE, it should be relatively easy to adapt these instructions to
   your environment.

.. sidebar:: Command Prompt Basics
   :class: small

   In Windows, a command-line tool is invoked by typing its name,
   optionally followed by arguments, into a *Command Prompt* window
   and pressing the Return (or Enter) key.

   To open a generic *Command Prompt*, click the *Start* menu
   button, click *Run*, type “cmd”, and then click *OK*.

   .. _current directory:

   All commands are executed within the context of a **current
   directory** in the filesystem.  To set the current directory,
   type:

   .. parsed-literal::

      cd *path*\ \\\ *to*\ \\\ *some*\ \\\ *directory*

   followed by Return.  For example,

   .. parsed-literal::

      cd |default-root|

   Long commands can be continued across several lines by typing a
   caret (``^``) at the end of all but the last line.  Some examples
   on this page use that technique to save horizontal space.

.. _vs-header-only:

Build From the Visual Studio IDE
--------------------------------

* From Visual Studio's *File* menu, select *New* > *Project…*
* In the left-hand pane of the resulting *New Project* dialog,
  select *Visual C++* > *Win32*.
* In the right-hand pane, select *Win32 Console Application*
  (VS8.0) or *Win32 Console Project* (VS7.1).
* In the *name* field, enter “example”
* Right-click **example** in the *Solution Explorer* pane and
  select *Properties* from the resulting pop-up menu
* In *Configuration Properties* > *C/C++* > *General* > *Additional Include
  Directories*, enter the path to the Boost root directory, for example

    |default-root|

* In *Configuration Properties* > *C/C++* > *Precompiled Headers*, change
  *Use Precompiled Header (/Yu)* to *Not Using Precompiled
  Headers*. [#pch]_
* Replace the contents of the ``example.cpp`` generated by the IDE
  with the example code above.
* From the *Build* menu, select *Build Solution*.

To test your application, hit the F5 key and type the following
into the resulting window, followed by the Return key::

  1 2 3

Then hold down the control key and press "Z", followed by the
Return key.

|next|__

__ `Errors and Warnings`_

Or, Build From the Command Prompt
---------------------------------

From your computer's *Start* menu, if you are a Visual
Studio 2005 user, select

  *All Programs* > *Microsoft Visual Studio 2005* 
  > *Visual Studio Tools* > *Visual Studio 2005 Command Prompt*

or, if you're a Visual Studio .NET 2003 user, select

  *All Programs* > *Microsoft Visual Studio .NET 2003* 
  > *Visual Studio .NET Tools* > *Visual Studio .NET 2003 Command Prompt*

to bring up a special `command prompt`_ window set up for the
Visual Studio compiler.  In that window, set the `current
directory`_ to a suitable location for creating some temporary
files and type the following command followed by the Return key:

.. parsed-literal::

  cl /EHsc /I |root| *path*\ \\\ *to*\ \\example.cpp

To test the result, type:

.. parsed-literal::

  echo 1 2 3 | example

.. include:: detail/errors-and-warnings.rst

.. include:: detail/binary-head.rst

Simplified Build From Source
----------------------------

If you wish to build from source with Visual C++, you can use a 
simple build procedure described in this section. Open the command prompt
and change your current directory to the Boost root directory. Then, type
the following commands::

  bootstrap
  .\b2

The first command prepares the Boost.Build system for use. The second
command invokes Boost.Build to build the separately-compiled Boost
libraries. Please consult the `Boost.Build documentation`__ for a list
of allowed options.

__ http://www.boost.org/boost-build2/doc/html/bbv2/overview/invocation.html

Or, Build Binaries From Source
------------------------------

If you're using an earlier version of Visual C++, or a compiler
from another vendor, you'll need to use Boost.Build_ to create your
own binaries.

.. Admonition:: Boost.CMake

  There is also an experimental CMake build for boost, supported and distributed
  separately.  See the `Boost.CMake`_ wiki page for more information.

  .. _`Boost.CMake`:
       https://svn.boost.org/trac/boost/wiki/CMake

.. include:: detail/build-from-source-head.rst

For example, your session might look like this: [#continuation]_

.. parsed-literal::

   C:\\WINDOWS> cd |default-root|
   |default-root|> b2 **^**
   More? **--build-dir=**\ "C:\\Documents and Settings\\dave\\build-boost" **^**
   More? **--build-type=complete** **msvc** stage

Be sure to read `this note`__ about the appearance of ``^``,
``More?`` and quotation marks (``"``) in that line.

The option “\ **--build-type=complete**\ ” causes Boost.Build to build
all supported variants of the libraries.  For instructions on how to
build only specific variants, please ask on the `Boost.Build mailing
list`_.

__ continuation_

.. include:: detail/build-from-source-tail.rst

.. _auto-linking:

.. include:: detail/link-head.rst

.. Admonition:: Auto-Linking

   Most Windows compilers and linkers have so-called “auto-linking
   support,” which eliminates the second challenge.  Special code in
   Boost header files detects your compiler options and uses that
   information to encode the name of the correct library into your
   object files; the linker selects the library with that name from
   the directories you've told it to search.

   The GCC toolchains (Cygwin and MinGW) are notable exceptions;
   GCC users should refer to the `linking instructions for Unix
   variant OSes`__ for the appropriate command-line options to use.

__ unix-variants.html#link-your-program-to-a-boost-library


Link From Within the Visual Studio IDE
--------------------------------------

Starting with the `header-only example project`__ we created
earlier:

__ vs-header-only_

1. Right-click **example** in the *Solution Explorer* pane and
   select *Properties* from the resulting pop-up menu
2. In *Configuration Properties* > *Linker* > *Additional Library
   Directories*, enter the path to the Boost binaries,
   e.g. |default-root|\ ``\lib\``.
3. From the *Build* menu, select *Build Solution*.

|next|__

__ `Test Your Program`_

Or, Link From the Command Prompt
--------------------------------

For example, we can compile and link the above program from the
Visual C++ command-line by simply adding the **bold** text below to
the command line we used earlier, assuming your Boost binaries are
in |default-root|\ ``\lib``:

.. parsed-literal::

   cl /EHsc /I |root| example.cpp   **^**
        **/link /LIBPATH:**\ |default-root-bold|\ **\\lib**

Library Naming
--------------

.. Note:: If, like Visual C++, your compiler supports auto-linking,
   you can probably |next|__.

     __ `Test Your Program`_

.. include:: detail/library-naming.rst

.. include:: detail/test-head.rst

Now, in a `command prompt`_ window, type:

.. parsed-literal::

   *path*\ \\\ *to*\ \\\ *compiled*\ \\example < *path*\ \\\ *to*\ \\\ jayne.txt

The program should respond with the email subject, “Will Success
Spoil Rock Hunter?”

.. include:: detail/conclusion.rst

------------------------------

.. [#zip] We recommend
   downloading |boost.7z|_ and using 7-Zip_ to decompress
   it.  We no longer recommend .zip files for Boost because they are twice
   as large as the equivalent .7z files.  We don't recommend using Windows'
   built-in decompression as it can be painfully slow for large archives.
   
.. _7-Zip: http://www.7-zip.org  

.. [#pch] There's no problem using Boost with precompiled headers;
   these instructions merely avoid precompiled headers because it
   would require Visual Studio-specific changes to the source code
   used in the examples.

.. [#continuation] In this example, the caret character ``^`` is a
   way of continuing the command on multiple lines, and must be the
   **final character** used on the line to be continued (i.e. do
   not follow it with spaces).  The command prompt responds with
   ``More?`` to prompt for more input.  Feel free to omit the
   carets and subsequent newlines; we used them so the example
   would fit on a page of reasonable width.  

   The command prompt treats each bit of whitespace in the command
   as an argument separator.  That means quotation marks (``"``)
   are required to keep text together whenever a single
   command-line argument contains spaces, as in

   .. parsed-literal::

     --build-dir=\ :raw-html:`<strong style="background-color:#B4FFB4">"</strong>`\ C:\\Documents\ :raw-html:`<strong style="color:#B4B4B4; background-color:#B4FFB4">_</strong>`\ and\ :raw-html:`<strong style="color:#B4B4B4; background-color:#B4FFB4">_</strong>`\ Settings\\dave\\build-boost\ \ :raw-html:`<strong style="background-color:#B4FFB4">"</strong>`

   Also, for example, you can't add spaces around the ``=`` sign as in

   .. parsed-literal::

     --build-dir\ :raw-html:`<strong style="color:#B4B4B4; background-color:#FFB4B4">_</strong>`\ =\ :raw-html:`<strong style="color:#B4B4B4; background-color:#FFB4B4">_</strong>`\ "C:\\Documents and Settings\\dave\\build-boost"

.. |boost.zip| replace:: |boost_ver|\ ``.zip``

.. _`boost.zip`: `sf-download`_

.. |build-type-complete| replace:: **--build-type=complete**

.. include:: detail/common-footnotes.rst
.. include:: detail/release-variables.rst
.. include:: detail/common-windows.rst
.. include:: detail/links.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Header-Only Libraries
=====================

The first thing many people want to know is, “how do I build
Boost?”  The good news is that often, there's nothing to build.

.. admonition:: Nothing to Build?

  Most Boost libraries are **header-only**: they consist *entirely
  of header files* containing templates and inline functions, and
  require no separately-compiled library binaries or special
  treatment when linking.

.. .. _separate: 

The only Boost libraries that *must* be built separately are:

* Boost.Chrono_
* Boost.Context_
* Boost.Filesystem_
* Boost.GraphParallel_
* Boost.IOStreams_
* Boost.Locale_
* Boost.MPI_
* Boost.ProgramOptions_
* Boost.Python_ (see the `Boost.Python build documentation`__
  before building and installing it)
* Boost.Regex_
* Boost.Serialization_
* Boost.Signals_
* Boost.System_
* Boost.Thread_
* Boost.Timer_
* Boost.Wave_

__ ../../libs/python/doc/building.html

A few libraries have optional separately-compiled binaries:

* Boost.DateTime_ has a binary component that is only needed if
  you're using its ``to_string``\ /\ ``from_string`` or serialization
  features, or if you're targeting Visual C++ 6.x or Borland.

* Boost.Graph_ also has a binary component that is only needed if
  you intend to `parse GraphViz files`__.

* Boost.Math_ has binary components for the TR1 and C99
  cmath functions.

* Boost.Random_ has a binary component which is only needed if
  you're using ``random_device``.

* Boost.Test_ can be used in “header-only” or “separately compiled”
  mode, although **separate compilation is recommended for serious
  use**.

* Boost.Exception_ provides non-intrusive implementation of
  exception_ptr for 32-bit _MSC_VER==1310 and _MSC_VER==1400
  which requires a separately-compiled binary. This is enabled by
  #define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR.

__ ../../libs/graph/doc/read_graphviz.html
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. This file contains all the definitions that need to be updated
.. for each new release of Boost.

.. |boost-version-number| replace:: 1.55.0
.. |boost_ver| replace:: ``boost_1_55_0``
.. |boost_ver-bold| replace:: **boost_1_55_0**

.. _sf-download: http://www.boost.org/users/history/version_1_55_0.html
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Test Your Program
-----------------

To test our subject extraction, we'll filter the following text
file.  Copy it out of your browser and save it as ``jayne.txt``::

   To: George Shmidlap
   From: Rita Marlowe
   Subject: Will Success Spoil Rock Hunter?
   ---
   See subject.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. |//| replace:: **/**
.. |/| replace:: ``/``

.. |default-root| replace:: ``/usr/local/``\ |boost_ver|
.. |default-root-bold| replace:: **/usr/local/**\ |boost_ver-bold|

.. |root| replace:: *path/to/*\ |boost_ver|

.. |forward-slashes| replace:: `` ``

.. |precompiled-dir| replace:: `` ``

.. |include-paths| replace:: `` ``

.. |windows-version-name-caveat| replace:: `` ``

.. |command-line tool| replace:: command-line tool

.. |pathsep| replace:: colon

.. |path| replace:: ``echo $PATH``

.. |bootstrap| replace:: ``bootstrap.sh``

.. include:: common.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Errors and Warnings
-------------------

Don't be alarmed if you see compiler warnings originating in Boost
headers.  We try to eliminate them, but doing so isn't always
practical.  [#warnings]_ **Errors are another matter**.  If you're
seeing compilation errors at this point in the tutorial, check to
be sure you've copied the `example program`__ correctly and that you've
correctly identified the `Boost root directory`_.

__ `Build a Simple Program Using Boost`_

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

In order to choose the right binary for your build configuration
you need to know how Boost binaries are named.  Each library
filename is composed of a common sequence of elements that describe
how it was built.  For example,
``libboost_regex-vc71-mt-d-1_34.lib`` can be broken down into the
following elements:

``lib`` 
  *Prefix*: except on Microsoft Windows, every Boost library
  name begins with this string.  On Windows, only ordinary static
  libraries use the ``lib`` prefix; import libraries and DLLs do
  not. [#distinct]_

``boost_regex``
  *Library name*: all boost library filenames begin with ``boost_``.

``-vc71``
   *Toolset tag*: identifies the toolset_ and version used to build
   the binary.

``-mt``
   *Threading tag*: indicates that the library was
   built with multithreading support enabled.  Libraries built
   without multithreading support can be identified by the absence
   of ``-mt``.

``-d``
   *ABI tag*: encodes details that affect the library's
   interoperability with other compiled code.  For each such
   feature, a single letter is added to the tag:

     +-----+------------------------------------------------------------------------------+---------------------+
     |Key  |Use this library when:                                                        |Boost.Build option   |
     +=====+==============================================================================+=====================+
     |``s``|linking statically to the C++ standard library and compiler runtime support   |runtime-link=static  |
     |     |libraries.                                                                    |                     |
     +-----+------------------------------------------------------------------------------+---------------------+
     |``g``|using debug versions of the standard and runtime support libraries.           |runtime-debugging=on |
     +-----+------------------------------------------------------------------------------+---------------------+
     |``y``|using a special `debug build of Python`__.                                    |python-debugging=on  |
     +-----+------------------------------------------------------------------------------+---------------------+
     |``d``|building a debug version of your code. [#debug-abi]_                          |variant=debug        |
     +-----+------------------------------------------------------------------------------+---------------------+
     |``p``|using the STLPort standard library rather than the default one supplied with  |stdlib=stlport       |
     |     |your compiler.                                                                |                     |
     +-----+------------------------------------------------------------------------------+---------------------+

   For example, if you build a debug version of your code for use
   with debug versions of the static runtime library and the
   STLPort standard library in “native iostreams” mode,
   the tag would be: ``-sgdpn``.  If none of the above apply, the
   ABI tag is ommitted.

``-1_34``
  *Version tag*: the full Boost release number, with periods
  replaced by underscores. For example, version 1.31.1 would be
  tagged as "-1_31_1".

``.lib``
  *Extension*: determined according to the operating system's usual
  convention.  On most unix-style platforms the extensions are
  ``.a`` and ``.so`` for static libraries (archives) and shared
  libraries, respectively.  On Windows, ``.dll`` indicates a shared
  library and ``.lib`` indicates a
  static or import library.  Where supported by toolsets on unix
  variants, a full version extension is added (e.g. ".so.1.34") and
  a symbolic link to the library file, named without the trailing
  version number, will also be created.

.. .. _Boost.Build toolset names: toolset-name_

__ ../../libs/python/doc/building.html#python-debugging-builds

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. [#warnings] Remember that warnings are specific to each compiler
   implementation.  The developer of a given Boost library might
   not have access to your compiler.  Also, some warnings are
   extremely difficult to eliminate in generic code, to the point
   where it's not worth the trouble.  Finally, some compilers don't
   have any source code mechanism for suppressing warnings.

.. [#distinct] This convention distinguishes the static version of
   a Boost library from the import library for an
   identically-configured Boost DLL, which would otherwise have the
   same name.

.. [#debug-abi] These libraries were compiled without optimization
   or inlining, with full debug symbols enabled, and without
   ``NDEBUG`` ``#define``\ d.  Although it's true that sometimes
   these choices don't affect binary compatibility with other
   compiled code, you can't count on that with Boost libraries.

.. [#native] This feature of STLPort is deprecated because it's
   impossible to make it work transparently to the user; we don't
   recommend it.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. |//| replace:: **\\**
.. |/| replace:: ``\``

.. |default-root| replace:: ``C:\Program Files\boost\``\ |boost_ver|
.. |default-root-bold| replace:: **C:\\Program Files\\boost\\**\ |boost_ver-bold|

.. |root| replace:: *path\\to\\*\ |boost_ver|

.. |include-paths| replace:: Specific steps for setting up ``#include``
   paths in Microsoft Visual Studio follow later in this document;
   if you use another IDE, please consult your product's
   documentation for instructions.

.. |forward-slashes| replace:: Even Windows users can (and, for
   portability reasons, probably should) use forward slashes in
   ``#include`` directives; your compiler doesn't care.

.. |precompiled-dir| replace:: 

    **lib**\ |//| .....................\ *precompiled library binaries*


.. |windows-version-name-caveat| replace:: **On Windows, append a version
   number even if you only have one version installed** (unless you
   are using the msvc or gcc toolsets, which have special version
   detection code) or `auto-linking`_ will fail.

.. |command-line tool| replace:: `command-line tool`_

.. |pathsep| replace:: semicolon

.. |path| replace:: ``PATH``

.. |bootstrap| replace:: ``bootstrap.bat``

.. include:: common.rst
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. |next| replace:: *skip to the next step*
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Prepare to Use a Boost Library Binary
=====================================

If you want to use any of the separately-compiled Boost libraries,
you'll need to acquire library binaries.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Conclusion and Further Resources
================================

This concludes your introduction to Boost and to integrating it
with your programs.  As you start using Boost in earnest, there are
surely a few additional points you'll wish we had covered.  One day
we may have a “Book 2 in the Getting Started series” that addresses
them.  Until then, we suggest you pursue the following resources.
If you can't find what you need, or there's anything we can do to
make this document clearer, please post it to the `Boost Users'
mailing list`_.

* `Boost.Build reference manual`_
* `Boost Users' mailing list`_
* `Boost.Build mailing list`_
* `Index of all Boost library documentation`_

.. _Index of all Boost library documentation: ../../libs/index.html

.. Admonition:: Onward

  .. epigraph::

     Good luck, and have fun!

     -- the Boost Developers

.. _Boost.Build reference manual: ../../tools/build/v2/index.html
.. _Boost Users' mailing list: http://www.boost.org/more/mailing_lists.htm#users
.. _Boost.Build mailing list: http://www.boost.org/more/mailing_lists.htm#jamboost

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _Boost.Chrono: ../../libs/chrono/index.html
.. _Boost.Context: ../../libs/context/index.html
.. _Boost.DateTime: ../../libs/date_time/index.html
.. _Boost.Exception: ../../libs/exception/index.html
.. _Boost.Filesystem: ../../libs/filesystem/index.html
.. _Boost.Graph: ../../libs/graph/index.html
.. _Boost.GraphParallel: ../../libs/graph_parallel/index.html
.. _Boost.IOStreams: ../../libs/iostreams/index.html
.. _Boost.Locale: ../../libs/locale/index.html
.. _Boost.Math: ../../libs/math/index.html
.. _Boost.MPI: ../../libs/mpi/index.html
.. _Boost.ProgramOptions: ../../libs/program_options/index.html
.. _Boost.Python: ../../libs/python/doc/building.html
.. _Boost.Random: ../../libs/random/index.html
.. _Boost.Regex: ../../libs/regex/index.html
.. _Boost.Serialization: ../../libs/serialization/index.html
.. _Boost.Signals: ../../libs/signals/index.html
.. _Boost.System: ../../libs/system/index.html
.. _Boost.Test: ../../libs/test/index.html
.. _Boost.Thread: ../../libs/thread/index.html
.. _Boost.Timer: ../../libs/timer/index.html
.. _Boost.Wave: ../../libs/wave/index.html
.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

The Boost Distribution
======================

This is a sketch of the resulting directory structure:

.. parsed-literal::

 |boost_ver-bold|\ |//| .................\ *The “boost root directory”* 
    **index.htm** .........\ *A copy of www.boost.org starts here*
    **boost**\ |//| .........................\ *All Boost Header files*
    |precompiled-dir|    
    **libs**\ |//| ............\ *Tests, .cpp*\ s\ *, docs, etc., by library*
      **index.html** ........\ *Library documentation starts here*
      **algorithm**\ |//|
      **any**\ |//|
      **array**\ |//|
                      *…more libraries…*
    **status**\ |//| .........................\ *Boost-wide test suite*
    **tools**\ |//| ...........\ *Utilities, e.g. Boost.Build, quickbook, bcp*
    **more**\ |//| ..........................\ *Policy documents, etc.*
    **doc**\ |//| ...............\ *A subset of all Boost library docs*

.. sidebar:: Header Organization

   .. class:: pre-wrap

     The organization of Boost library headers isn't entirely uniform,
     but most libraries follow a few patterns:

     * Some older libraries and most very small libraries place all
       public headers directly into ``boost``\ |/|.

     * Most libraries' public headers live in a subdirectory of
       ``boost``\ |/|, named after the library.  For example, you'll find
       the Python library's ``def.hpp`` header in

       .. parsed-literal::

         ``boost``\ |/|\ ``python``\ |/|\ ``def.hpp``.

     * Some libraries have an “aggregate header” in ``boost``\ |/| that
       ``#include``\ s all of the library's other headers.  For
       example, Boost.Python_'s aggregate header is

       .. parsed-literal::

         ``boost``\ |/|\ ``python.hpp``.

     * Most libraries place private headers in a subdirectory called
       ``detail``\ |/|, or ``aux_``\ |/|.  Don't expect to find
       anything you can use in these directories.

It's important to note the following:

.. _Boost root directory:

1. The path to the **boost root directory** (often |default-root|) is
   sometimes referred to as ``$BOOST_ROOT`` in documentation and
   mailing lists .

2. To compile anything in Boost, you need a directory containing
   the ``boost``\ |/| subdirectory in your ``#include`` path.  |include-paths|

3. Since all of Boost's header files have the ``.hpp`` extension,
   and live in the ``boost``\ |/| subdirectory of the boost root, your
   Boost ``#include`` directives will look like:

   .. parsed-literal::

     #include <boost/\ *whatever*\ .hpp>

   or

   .. parsed-literal::

     #include "boost/\ *whatever*\ .hpp"

   depending on your preference regarding the use of angle bracket
   includes.  |forward-slashes|

4. Don't be distracted by the ``doc``\ |/| subdirectory; it only
   contains a subset of the Boost documentation.  Start with
   ``libs``\ |/|\ ``index.html`` if you're looking for the whole enchilada.

.. Copyright David Abrahams 2006. Distributed under the Boost
.. Software License, Version 1.0. (See accompanying
.. file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Link Your Program to a Boost Library
====================================

To demonstrate linking with a Boost binary library, we'll use the
following simple program that extracts the subject lines from
emails.  It uses the Boost.Regex_ library, which has a
separately-compiled binary component. ::

  #include <boost/regex.hpp>
  #include <iostream>
  #include <string>

  int main()
  {
      std::string line;
      boost::regex pat( "^Subject: (Re: |Aw: )*(.*)" );

      while (std::cin)
      {
          std::getline(std::cin, line);
          boost::smatch matches;
          if (boost::regex_match(line, matches, pat))
              std::cout << matches[2] << std::endl;
      }
  }

There are two main challenges associated with linking:

1. Tool configuration, e.g. choosing command-line options or IDE
   build settings.

2. Identifying the library binary, among all the build variants,
   whose compile configuration is compatible with the rest of your
   project.

