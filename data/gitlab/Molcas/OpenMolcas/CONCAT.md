Attribution
===========

If you add a new file, please include the OpenMolcas header and copyright
information, for example:

```
************************************************************************
* This file is part of OpenMolcas.                                     *
*                                                                      *
* OpenMolcas is free software; you can redistribute it and/or modify   *
* it under the terms of the GNU Lesser General Public License, v. 2.1. *
* OpenMolcas is distributed in the hope that it will be useful, but it *
* is provided "as is" and without any express or implied warranties.   *
* For more details see the full text of the license in the file        *
* LICENSE or in <http://www.gnu.org/licenses/>.                        *
*                                                                      *
* Copyright (C) 2014,2016, John Doe                                    *
*               2017, Jane Doe                                         *
************************************************************************
```

* Use full names when possible
* Use a single line for each author, and a single author on each line
* Include all years where modifications were done, use ranges only if there
  were modifications in all the intermediate years.

If you modify an existing file, and the modification is significant enough, add
your name to the header in the same format, or the year if your name is already
there. What exactly is "significant enough" is rather subjective; changing a
format to print more decimal figures is probably not, rearranging the loop
structure can be. It is up to you to decide whether or not your modifications
are significant enough.

If you copy a file, copy the header too, and then do as above if you modify it.
Do not remove any name unless you are absolutely sure that all contributions by
that person have been removed from the file.

You can include more detailed information about yourself, the origin of any
external code, the nature of the modifications, etc. below the header.

Finally, add any new names to the list in `CONTRIBUTORS.md`. Note that in order
to maintain the formatting with online tools (see
[here](https://gitlab.com/Molcas/OpenMolcas/blob/master/CONTRIBUTORS.md)), each
name is a separate line that *ends with two spaces*. The list is sorted
alphabetically by last name (using "international" sorting order, where Á = A,
Ö = O etc.).


Commit messages
===============

When writing commit messages with `git`, try to be informative but brief. The
best is to follow a simple format (see
[here](https://chris.beams.io/posts/git-commit/)):

1. One line with a short title.
2. A blank line.
3. Some explanation of what was modified and why it was needed or useful.

For example:

```
Start work on new_shiny_feature

The old_dull_feature has some limitations, this new_shiny_feature
will solve them. For the moment just add a dummy keyword.
```

In many tools and on the [online
viewer](https://gitlab.com/Molcas/OpenMolcas/commits/master) only the first
line is displayed by default and the rest of the message is available if
desired.
OpenMolcas
==========

OpenMolcas is free software: you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, version 2.1.

OpenMolcas is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with OpenMolcas. If not, see <http://www.gnu.org/licenses/>.

Copyright (C) 1989-2022, The OpenMolcas Authors


NOTE: Some of the files distributed with OpenMolcas may be subject to a more
permissive or otherwise compatible license. Some of the files from external
sources may be subject to a more restrictive or otherwise incompatible license.


General citations
=================

* **OpenMolcas**:
  *J. Chem. Theory Comput.* **15** (2019) 5925-5964. [doi:10.1021/acs.jctc.9b00532](https://doi.org/10.1021/acs.jctc.9b00532)

* **Molcas 8**:
  *J. Comput. Chem.* **37** (2016) 506-541. [doi:10.1002/jcc.24221](https://doi.org/10.1002/jcc.24221)

* **Molcas 7**:
  *J. Comput. Chem.* **31** (2010) 224-247. [doi:10.1002/jcc.21318](https://doi.org/10.1002/jcc.21318)

* **Molcas 6**:
  *Comput. Mat. Sci.* **28** (2003) 222-239. [doi:10.1016/S0927-0256(03)00109-5](https://doi.org/10.1016/S0927-0256(03)00109-5)

* **Code development**:
  *Wiley Interdiscip. Rev. Comput. Mol. Sci.* **3** (2013) 143-149. [doi:10.1002/wcms.1117](https://doi.org/10.1002/wcms.1117);
  *Int. J. Quantum Chem.* **100** (2004) 626-635. [doi:10.1002/qua.20166](https://doi.org/10.1002/qua.20166)


Contributors
============

The following is a list of people who have contributed at some point to the
code of OpenMolcas. They are hereby acknowledged and collectively identified as
"The OpenMolcas Authors".

Christian Ander  
Kerstin Andersson  
János G. Ángyán  
Imaad Ansari  
Francesco Aquilante  
Jochen Autschbach  
Jie J. Bao  
Maria Barysz  
Stefano Battaglia  
Eugeniusz Bednarz  
Nelson H. F. Beebe  
Anders Bernhardsson  
Margareta R. A. Blomberg  
Sergey I. Bokarev  
Piotr Borowski  
Jonas Boström  
Per Boussard  
John Burkardt  
Yannick Carissan  
Liviu Chibotaru  
Christophe Chipot  
Jonathan R. Church  
Aron Cohen  
David L. Cooper  
Maurizio Cossi  
Joel Creutzberg  
Oleh Danyliv  
Mickaël G. Delcey  
Ajitha Devarajan  
Luca De Vico  
Michael Diedenhofen  
Werner Dobrautz  
Sijia S. Dong  
Thomas Dresselhaus  
Thomas J. Duignan  
Daniel Fairhead  
Ignacio Fdez. Galván  
Rulin Feng  
Nicolas Ferré  
Timo Fleig  
Niclas Forsberg  
Leon Freitag  
Luis Manuel Frutos  
Markus P. Fülscher  
Alexander Gaenko  
Laura Gagliardi  
Walter Gautschi  
Giovanni Ghigo  
Coen de Graaf  
Joseph Golub  
Gene H. Golub  
Sergey Gusarov  
Daniel Hagberg  
Jun-ya Hasegawa  
Matthew R. Hermes  
José Manuel Hermida-Ramón  
Bernd Artur Heß  
Asbjørn Holt  
Chad E. Hoyer  
Denis Jelovina  
Marcus Johansson  
Erik Källman  
Gunnar Karlström  
Stefan Knecht  
Vladislav Kochetov  
Jesper Wisborg Krogh  
Teodoro Laino  
Susi Lehtola  
Giovanni Li Manni  
Roland Lindh  
Johan Lorentzon  
Dongxia Ma  
Yingjin Ma  
Per Åke Malmqvist  
Neil Martinsen-Burrell  
Andy May  
Manuela Merchán  
Isabella C. D. Merritt  
Samuel Mikes  
Abdul Rehaman Moughal Shahi  
Thomas Müller  
Takahito Nakajima  
Naoki Nakatani  
Pavel Neogrády  
Jesper Norell  
Anders Öhrn  
Jeppe Olsen  
Markus Oppel  
Thomas Bondo Pedersen  
Daoling Peng  
Kurt Pfingst  
Quan Phung  
Michal Pitoňák  
Felix Plasser  
Christian Pomelli  
Ben Pritchard  
Juraj Raab  
Gerardo Raggi  
Markus Reiher  
H. Rieger  
Björn O. Roos  
Ulf Ryde  
Andrzej J. Sadlej  
Pawel Salek  
Andrew M. Sand  
Michael A. Saunders  
Igor Schapiro  
Bernd Schimmelpfennig  
Martin Schütz  
Thais Scott  
Luis Seijo  
Luis Serrano-Andrés  
Kamal Sharkas  
Grigory A. Shamov  
Prachi Sharma  
Per E. M. Siegbahn  
Pär Söderhjelm  
Lasse Kragh Sørensen  
Jonna Stålring  
Hermann Stoll  
Bingbing Suo  
Ben Swerts  
Akio Takatsuka  
Thorstein Thorsteinsson  
Takashi Tsuchiya  
Liviu Ungur  
Morgane Vacher  
Alessio Valentini  
Valérie Vallet  
Steven Vancoillie  
Valera Veryazov  
Victor P. Vysotskiy  
Ulf Wahlgren  
Yubin Wang  
Mark A. Watson  
Hans-Joachim Werner  
Oskar Weser  
Per-Olof Widmark  
Małgorzata Wierzbowska  
Alexander Wolf  
Sebastian Wouters  
Felipe Zapata  
Alexander Zech  
Yan Zhao  
Chen Zhou  
J. Patrick Zobel  

OpenMolcas
==========

OpenMolcas is a quantum chemistry software package developed by scientists
and intended to be used by scientists. It includes programs to apply many
different electronic structure methods to chemical systems, but its key
feature is the multiconfigurational approach, with methods like CASSCF and
CASPT2.

OpenMolcas is not a fork or reimplementation of
[Molcas](http://www.molcas.org), it *is* a large part of the Molcas codebase
that has been released as free and open-source software (FOSS) under the Lesser
General Public License (LGPL). Some parts of Molcas remain under a different
license by decision of their authors (or impossibility to reach them), and are
therefore not included in OpenMolcas.

**Latest references**:

* "OpenMolcas: From Source Code to Insight."
  *J. Chem. Theory Comput.* **15** (2019) 5925-5964.
  [doi:10.1021/acs.jctc.9b00532](https://doi.org/10.1021/acs.jctc.9b00532)

* "Modern quantum chemistry with [Open]Molcas."
  *J. Chem. Phys.* **152** (2020) 214117.
  [doi:10.1063/5.0004835](https://doi.org/10.1063/5.0004835)

Installation
------------

For more detailed information, please refer to the [wiki
pages](https://gitlab.com/Molcas/OpenMolcas/-/wikis/home).

OpenMolcas is configured with [CMake](https://cmake.org). A quick way to get it
up and running is the following:

1.  Clone the repository:

    ```
    git clone https://gitlab.com/Molcas/OpenMolcas.git
    ```

2.  Get the `lapack` submodule (only needed if you don't use another linear
    algebra library like MKL or OpenBLAS):

    ```
    cd OpenMolcas
    git submodule update --init External/lapack
    cd ..
    ```

3.  Create a new directory and run `cmake` from it:

    ```
    mkdir build
    cd build
    cmake ../OpenMolcas
    ```

4.  Compile with `make`:

    ```
    make
    ```

5.  Run the verification suite (failures in "grayzone" tests are expected):

    ```
    pymolcas verify
    ```

For running other calculations you should define the `MOLCAS` environment
variable to point to the `build` directory. Run `pymolcas --help` to see the
available options of the script. In particular it is recommended to run:
```
pymolcas -setup
```
for your first installation.

Documentation
-------------

The documentation can be found in the
[`doc`](https://gitlab.com/Molcas/OpenMolcas/tree/master/doc) directory, you
can read it in [HTML format](https://molcas.gitlab.io/OpenMolcas/sphinx/) or
[PDF format](https://molcas.gitlab.io/OpenMolcas/Manual.pdf). Note that most
of it precedes the creation of OpenMolcas and it is probably outdated in
several points. It may also mention features not available in OpenMolcas.

Help
----

OpenMolcas is a community-supported software and as such it doesn't have an
official technical support. If you have any problems or questions, you can use
the [Issues](/../issues) page or the [Molcas
forum](https://cobalt.itc.univie.ac.at/molcasforum/index.php), and hopefully
some other user or developer will be able to help you.

If you need technical support, you can acquire a [Molcas
license](http://www.molcas.org/order.html).

Contributing
------------

Since OpenMolcas is FOSS, you can download it, modify it and distribute it
freely (according to the terms of the LGPL). If you would like your
contributions to be included in the main repository, please contact one of the
developers, write a message in the
[forum](https://cobalt.itc.univie.ac.at/molcasforum/index.php) or submit a
[merge
request](https://docs.gitlab.com/ee/user/project/merge_requests/getting_started.html).
Everyone is welcome to send patches, suggestions and bug reports, but please
let us know if you would like to be a "developer" member of the `Molcas` group.
This directory contains different pieces of documentation.

The main part is the OpenMolcas documentation in
[reStructuredText](http://docutils.sourceforge.net/rst.html) markup format.
HTML and PDF versions can be generated with
[Sphinx](http://www.sphinx-doc.org). Note that most of this precedes the
creation of OpenMolcas and it is probably outdated in several points. It may
also mention features not available in OpenMolcas.

The `.rst` files contain embedded blocks that are used to generate command-line
help (accessed with `pymolcas help_doc`) and an XML input description for
MolGUI. These blocks use the `.. xmldoc::` directive and follow a format
similar to that described
[here](https://gitlab.com/Molcas/OpenMolcas/wikis/Programming%20guide/Documentation).

To build the documentation, after configuring OpenMolcas with `cmake`, run
`make doc_html` or `make doc_pdf`.

In addition, some subdirectories have other content:

`doxygen`

Configuration and auxiliary files to generate source code documentation with
[Doxygen](http://www.doxygen.org/). The documentation itself, where it exists,
is included in the source files.

To build the doxygen documentation just run `doxygen` inside this directory.
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

Overview
========

.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

.. include:: ../CONTRIBUTING.rst
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

.. include:: ../AUTHORS.rst
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

============
Installation
============

At the command line::

    pip install analyze-molcas
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

========
Contents
========

.. toctree::
   :maxdepth: 2

   readme
   installation
   usage
   reference/index
   contributing
   authors
   changelog

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

.. include:: ../CHANGELOG.rst
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

=====
Usage
=====

To use analyze_molcas in a project::

	import analyze_molcas
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

.. include:: ../README.rst
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

analyze_molcas
============

.. testsetup::

    from analyze_molcas import *

.. automodule:: analyze_molcas
    :members:
.. ***********************************************************************
.. This file is part of OpenMolcas.                                      *
..                                                                       *
.. OpenMolcas is free software; you can redistribute it and/or modify    *
.. it under the terms of the GNU Lesser General Public License, v. 2.1.  *
.. OpenMolcas is distributed in the hope that it will be useful, but it  *
.. is provided "as is" and without any express or implied warranties.    *
.. For more details see the full text of the license in the file         *
.. LICENSE or in <http://www.gnu.org/licenses/>.                         *
..                                                                       *
.. Copyright (C) 2020, Oskar Weser                                       *
.. ***********************************************************************

Reference
=========

.. toctree::
    :glob:

    analyze_molcas*
Citation for |openmolcas| and |molcas|
======================================

The recommended citations for |openmolcas| are:

  **OpenMolcas:** Ignacio Fdez. Galván, Morgane Vacher, Ali Alavi, Celestino
  Angeli, Francesco Aquilante, Jochen Autschbach, Jie J. Bao, Sergey I. Bokarev,
  Nikolay A. Bogdanov, Rebecca K. Carlson, Liviu F. Chibotaru, Joel Creutzberg,
  Nike Dattani, Mickaël G. Delcey, Sijia S. Dong, Andreas Dreuw, Leon Freitag,
  Luis Manuel Frutos, Laura Gagliardi, Frédéric Gendron, Angelo Giussani, Leticia
  González, Gilbert Grell, Meiyuan Guo, Chad E. Hoyer, Marcus Johansson,
  Sebastian Keller, Stefan Knecht, Goran Kovačević, Erik Källman, Giovanni Li
  Manni, Marcus Lundberg, Yingjin Ma, Sebastian Mai, João Pedro Malhado, Per Åke
  Malmqvist, Philipp Marquetand, Stefanie A. Mewes, Jesper Norell, Massimo
  Olivucci, Markus Oppel, Quan Manh Phung, Kristin Pierloot, Felix Plasser,
  Markus Reiher, Andrew M. Sand, Igor Schapiro, Prachi Sharma, Christopher J.
  Stein, Lasse Kragh Sørensen, Donald G. Truhlar, Mihkel Ugandi, Liviu Ungur,
  Alessio Valentini, Steven Vancoillie, Valera Veryazov, Oskar Weser, Tomasz A.
  Wesołowski, Per-Olof Widmark, Sebastian Wouters, Alexander Zech, J. Patrick
  Zobel, Roland Lindh. "OpenMolcas: From Source Code to Insight." *Journal of
  Chemical Theory and Computation*, **15** (2019), 5925--5964.
  `doi:10.1021/acs.jctc.9b00532 <https://doi.org/10.1021/acs.jctc.9b00532>`_

  **Applications:** Francesco Aquilante, Jochen Autschbach, Alberto Baiardi,
  Stefano Battaglia, Veniamin A. Borin, Liviu F. Chibotaru, Irene Conti, Luca De
  Vico, Mikael Delcey, Ignacio Fdez. Galván, Nicolas Ferré, Leon Freitag, Marco
  Garavelli, Xuejun Gong, Stefan Knecht, Ernst D. Larsson, Roland Lindh, Marcus
  Lundberg, Per Åke Malmqvist, Artur Nenov, Jesper Norell, Michael Odelius,
  Massimo Olivucci, Thomas B. Pedersen, Laura Pedraza-González, Quan M. Phung,
  Kristine Pierloot, Markus Reiher, Igor Schapiro, Javier Segarra-Martí,
  Francesco Segatta, Luis Seijo, Saumik Sen, Dumitru-Claudiu Sergentu,
  Christopher J. Stein, Liviu Ungur, Morgane Vacher, Alessio Valentini, Valera
  Veryazov. "Modern quantum chemistry with [Open]Molcas." *The Journal of
  Chemical Physics*, **152** (2020), 214117. `doi:10.1063/5.0004835
  <https://doi.org/10.1063/5.0004835>`_

Earlier citations for |molcas| are:

  **Molcas 8:** F. Aquilante, J. Autschbach, R. K. Carlson, L. F. Chibotaru, M.
  G. Delcey, L. De Vico, I. Fdez. Galván, N. Ferré, L. M. Frutos, L. Gagliardi,
  M. Garavelli, A. Giussani, C. E. Hoyer, G. Li Manni, H. Lischka, D. Ma, P. Å.
  Malmqvist, T. Müller, A. Nenov, M. Olivucci, T. B. Pedersen, D. Peng, F.
  Plasser, B. Pritchard, M. Reiher, I. Rivalta, I. Schapiro, J. Segarra-Martí, M.
  Stenrup, D. G. Truhlar, L. Ungur, A. Valentini, S. Vancoillie, V. Veryazov, V.
  P. Vysotskiy, O. Weingart, F. Zapata, R. Lindh. ":sc:`Molcas` 8: New
  capabilities for multiconfigurational quantum chemical calculations across the
  periodic table." *Journal of Computational Chemistry*, **37** (2016), 506--541.
  `doi:10.1002/jcc.24221 <https://doi.org/10.1002/jcc.24221>`_

  **Cholesky infrastructure:** F. Aquilante, T. B. Pedersen, V. Veryazov, R.
  Lindh. "MOLCAS---a software for multiconfigurational quantum chemistry
  calculations." *Wiley Interdisciplinary Reviews: Computational Molecular
  Science*, **3** (2013), 143--149. `doi:10.1002/wcms.1117
  <https://doi.org/10.1002/wcms.1117>`_

  **Molcas 7:** F. Aquilante, L. De Vico, N. Ferré, G. Ghigo, P.-Å. Malmqvist, P.
  Neogrády, T. B. Pedersen, M. Pitoňák, M. Reiher, B. O. Roos, L. Serrano-Andrés,
  M. Urban, V. Veryazov, R. Lindh. "MOLCAS 7: The Next Generation." *Journal of
  Computational Chemistry*, **31** (2010), 224-247. `doi:10.1002/jcc.21318
  <https://doi.org/10.1002/jcc.21318>`_

  **Code development:** V. Veryazov, P.-O. Widmark, L. Serrano-Andrés, R. Lindh,
  B. O. Roos. "2MOLCAS as a development platform for quantum chemistry software."
  *International Journal of Quantum Chemistry*, **100** (2004), 626--635.
  `doi:10.1002/qua.20166 <https://doi.org/10.1002/qua.20166>`_

  **Molcas 6:** G. Karlström, R. Lindh, P.-Å. Malmqvist, B. O. Roos, U. Ryde, V.
  Veryazov, P.-O. Widmark, M. Cossi, B. Schimmelpfennig, P. Neogrády, L. Seijo.
  "MOLCAS: a program package for computational chemistry." *Computational
  Material Science*, **28** (2003), 222-239. `doi:10.1016/S0927-0256(03)00109-5
  <https://doi.org/10.1016/S0927-0256(03)00109-5>`_

The following people have contributed to the development of the
|openmolcas| software:

.. In alphabetical order (treating Å as A, etc.)

..

  Christian Ander, Kerstin Andersson, János G. Ángyán, Francesco Aquilante,
  Jochen Autschbach, Jie J. Bao, Maria Barysz, Stefano Battaglia, Eugeniusz
  Bednarz, Nelson H. F. Beebe, Anders Bernhardsson, Margareta R. A. Blomberg,
  Piotr Borowski, Jonas Boström, Per Boussard, John Burkardt, Yannick Carissan,
  Liviu Chibotaru, Christophe Chipot, Aron Cohen, David L. Cooper, Maurizio
  Cossi, Joel Creutzberg, Oleh Danyliv, Mickaël G. Delcey, Ajitha Devarajan, Luca
  De Vico, Michael Diedenhofen, Sijia S. Dong, Thomas Dresselhaus, Daniel
  Fairhead, Ignacio Fdez. Galván, Nicolas Ferré, Timo Fleig, Leon Freitag, Luis
  Manuel Frutos, Markus P. Fülscher, Alexander Gaenko, Laura Gagliardi, Walter
  Gautschi, Giovanni Ghigo, Coen de Graaf, Gene H. Golub, Sergey Gusarov, Daniel
  Hagberg, Jun-ya Hasegawa, José Manuel Hermida-Ramón, Bernd Artur Heß, Asbjørn
  Holt, Chad E. Hoyer, Denis Jelovina, Marcus Johansson, Erik Källman, Gunnar
  Karlström, Stefan Knecht, Jesper Wisborg Krogh, Teodoro Laino, Giovanni Li
  Manni, Roland Lindh, Johan Lorentzon, Dongxia Ma, Yingjin Ma, Per Åke
  Malmqvist, Neil Martinsen-Burrell, Andy May, Manuela Merchán, Samuel Mikes,
  Abdul Rehaman Moughal Shahi, Thomas Müller, Takahito Nakajima, Naoki Nakatani,
  Pavel Neogrády, Jesper Norell, Anders Öhrn, Jeppe Olsen, Markus Oppel, Thomas
  Bondo Pedersen, Daoling Peng, Kurt Pfingst, Quan Phung, Michal Pitoňák, Felix
  Plasser, Christian Pomelli, Ben Pritchard, Juraj Raab, Gerardo Raggi, Markus Reiher, H.
  Rieger, Björn O. Roos, Ulf Ryde, Pawel Salek, Andrew M. Sand, Michael A.
  Saunders, Igor Schapiro, Bernd Schimmelpfennig, Martin Schütz, Luis Seijo, Luis
  Serrano-Andrés, Kamal Sharkas, Grigory A. Shamov, Prachi Sharma, Per E. M.
  Siegbahn, Pär Söderhjelm, Lasse Kragh Sørensen, Jonna Stålring, Hermann Stoll,
  Bingbing Suo, Ben Swerts, Akio Takatsuka, Thorstein Thorsteinsson, Takashi
  Tsuchiya, Liviu Ungur, Morgane Vacher, Alessio Valentini, Valérie Vallet,
  Steven Vancoillie, Valera Veryazov, Victor P. Vysotskiy, Ulf Wahlgren, Yubin
  Wang, Mark A. Watson, Hans-Joachim Werner, Oskar Weser, Per-Olof Widmark,
  Małgorzata Wierzbowska, Alexander Wolf, Sebastian Wouters, Felipe Zapata,
  Alexander Zech, Yan Zhao, J. Patrick Zobel.
.. _sec\:about_this_manual:

The |molcas| Manual
===================

.. _sec\:who_should_read:

Manual in Four Parts
--------------------

This manual is designed for use with the *ab initio* Quantum
chemistry software package |molcas| developed at the
by the world-wide |molcas| team where its base and origin is the
Department of Theoretical Chemistry, Lund University, Sweden. |molcas| is designed for use
by Theoretical Chemists and requires knowledge of the
Chemistry involved in the calculations in order to produce and
interpret the results correctly. The package can be moderately difficult to use
because of this "knowledge requirement", but the results are often more
meaningful than those produced by :bdit:`blackbox` packages which may not be
sufficiently chemically precise in either input or output.

The |molcas| manual is divided in four parts to facilitate its use.

#. The |molcas| :bdit:`Installation Guide` describes simple and more complex aspects on how to install, tailor, and
   control the |molcas| package.

#. The :bdit:`Short Guide` to |molcas| is a brief introductory guide which addresses the needs of the novice and intermediate users
   and is designed for all those who want to start using |molcas| as soon as possible.
   Only basic environment definitions, simple input examples, and minimal description of output results are included in the short guide.

   Two types of introductory tutorials are given in the short guide: problem-based and program-specific.

   #. Problem-based tutorials are exercises focused on solving a simple Quantum
      Chemical project and contain all the required input files. Examples include
      computing electronic energy of a molecule at different levels of
      theory, optimizing the geometry of a molecule, calculating the transition state in the ground
      state of a chemical system, and computing an excited state.
      The input files for this section can be found in the directory :file:`$MOLCAS/doc/samples/problem_based_tutorials`.
      These examples are also employed in |molcas| workshops that the |molcas| team has organized in recent years.

   #. Another type of tutorial is designed for the first-time user to provide an understanding of program modules
      contained in |molcas| include simple, easy-to-follow examples for many of these modules.

   The systems covered in the short guide are not necessarily calculated with most suitable methods or produce highly significant results,
   but provide both several tips for the beginner and actual input file formats.

   The :bdit:`Short Guide` to |molcas| can be independently printed as a booklet.

#. The |molcas| :bdit:`User's Guide` contains a complete listing of the input
   keywords for each of the program modules and a information regarding
   files used in each calculation. Here the user will find all keywords that can be
   used together with a specific program and thus how to set up the input for a
   |molcas| run.

#. :bdit:`Advanced Examples` and :bdit:`Annexes` include outlines of
   actual research performed using |molcas|.

   The approach to a research project is outlined including input files and shell scripts. More
   importantly, however, the value of the calculations is evaluated and
   advanced features of |molcas| are used and explained to improve the
   value of the results.

The complete manual is available on the net in HTML and PDF formats
(|MolcasWWW|).

.. _notation:

Notation
--------

For clarity, some words are printed using special typefaces.

* Keywords, i.e. words used in input files, are typeset in
  the small-caps typeface, for example :kword:`EndOfInput`.

* Programs (or modules) are typeset in the teletype typeface.
  This will eliminate some potential confusion. For example,
  when discussing the RASSCF method, regular uppercase letters
  are used, while the program will look like :program:`RASSCF`.

* Files are typeset in the slanted teletype typeface, like
  :file:`InpOrb`.

* Commands, unix or other, are typeset in a sans serif typeface,
  like :command:`ln -fs`.

* Complete examples, like input files, shell scripts, etc,
  are typeset in the teletype typeface.
Acknowledgment
==============

The |molcas| project is carried out by the Lund University quantum chemistry
group supported by the Swedish Science Research Council (VR).

The MOLCAS group is a member of the Linnaeus project *Organising Molecular
Matter, OMM*.

The MOLCAS group acknowledges the contributions from the scientists in the
MOLCAS Network, who are members of the MOLCAS developers team.

The Lund University Center for Scientific and Technical Computing (LUNARC) has
provided computer resources for the project.
Contents
========

.. note::

   Most of this documentation precedes the creation of |openmolcas|.
   It is probably outdated in several points, and it may mention
   features not available in |openmolcas|.

.. toctree::
   :maxdepth: 3
   :numbered:

   intro
   installation.guide/ig
   tutorials/tut
   users.guide/ug
   advanced.examples/ae

.. only:: html

  * :ref:`references`
  * :ref:`genindex`

.. * :ref:`search`

.. toctree::
   :hidden:

   xrefs
.. _sec\:disclaimer:

Disclaimer
==========

|molcas| is shipped on an "as is" basis without warranties of any kind.
The authors of |molcasviii| therefore assume no responsibility of any kind from
the use of the supplied material. Permission is granted to use the
package, but not to reproduce or redistribute any part of this material by
any means. Material in the software may
not be included in any commercial product. The authors reserve the right to
change plans and existing material without notice.
New features and updates
========================

Below is presented a list of the major new features of |molcas|.
These features comprise a number of new codes and
introduction of new methods, but also considerable updates of many of the
programs in |molcas|. We keep some history, so that people who are using older
versions of |molcas| can get a feeling for what has happened on later versions

.. rubric:: New features in 8.0:

* General improvements:

  * includes major bug fixes;
  * enhanced performance;
  * better parallelization;
  * better support for the Intel, and GCC compilers;

* New codes and major updates:

  * Stochastic-CASSCF allows to choose large active spaces (currently active spaces containing up to 50 electrons and 50 orbitals have been tested) in part circumventing the exponential scaling limitation of the standard CASSCF method;
  * MC-PDFT combines multiconfigurational wavefunctions with density functional theory to recover both static and dynamical correlation energy;
  * GASSCF allows for more flexibility in choosing the active space;
  * EMBQ is general purpose embedding technique;
  * FALCON is fragment-based approach for computing an electronic energy of the large systems;
  * GEO/HYPER module for constrained multi-fragment geometry optimisation in internal coordinates;
  * enhanced I/O via the Files In Memory technology;
  * SINGLE_ANISO code received several important updates:

    * CRYS: extraction of the parameters of the multiplet-specific crystal field for lanthanides;
    * UBAR: construction of the blocking barriers of single-molecule magnets;
    * ABCC: magnetic and anisotropy axes are given in the crystallographic :math:`abc` system;

* New features in existing codes:

  * Relativistic exact decoupling (X2C/BSS/infinite-order DKH);
  * Local X2C/BSS/infinite-order DKH;
  * RICD analytical gradients are available for the MBPT2, and CASSCF methods;
  * auto-segmentation in CD-based coupled cluster CHCC and CHT3 modules;
  * Orbital-free density embedding;
  * more robust and efficient SLAPAF module;
  * enhanced EMIL functional;

* Installation and tools:

  * first release of the Global Arrays free MOLCAS; a new parallel framework of MOLCAS requires only MPI-2 library;
  * better support for Mac OS X (including the both serial and parallel installations);

.. rubric:: New features in 7.6:

* Bug fixing release
* Short guide for Molcas
* GUI-ready release

.. rubric:: New features in 7.4:

* New codes and major updates:

  * There is a new set of coupled cluster codes added.
  * The M06 DFT functional have been implemented.
  * There are added constraints in :program:`slapaf`.
  * New method for transition state search and reaction coordinate analysis.

* New features in existing codes:

  * There are improvements in the capabilities of the emil input.
  * It is now possible to specify the actual name of the orbital
    input files in modules :program:`SCF` and :program:`GRID_IT`.

* Changes in usage of the package:

  * You can now get properties broken down by orbital contributions
    by setting environment variable.

* Installation and tools

  * You can now tell |molcas| at configuration time to use an externally
    installed version of Global Arrays.
  * There are prebuilt versions of the GUI that can be installed in a very
    simple manner.
  * The default compiler on linux system is now gfortran.

.. rubric:: New features in 7.2:

* New codes and major updates:

  * pre-release version of GUI for input generation and |molcas| job submition (MING).
  * Module Seward has been split into Gateway (set up of molecular system)
    and Seward itself (computation of integrals).
  * Major improvements in runtime settings for the package, and new flags for |molcas| command
  * New manual for novice |molcas| users

* Performance enhancements:

  * A new version of GA has been included.
  * Default integral thresholds are now changed to 1.0D-10.
  * RI code has been improved

* New features in existing codes:

  * The exchange-hole dipole moments in :program:`LoProp` code
  * Better handling of supersymmetry in :program:`RASSCF` code
  * Localized natural orbitals in :program:`Localisation` code
  * BSSE calculations in :program:`SCF` code
  * A second finite nuclei charge distribution model, the so-called modified Gaussian charge distribution,
    has been implemented
  * Frequency calculations for :program:`MBPT2`
  * The :program:`ESPF` module can be used in order to compute electrostatic potential derived charges
  * Frozen Natural Orbital approach in :program:`CASPT2`
  * On-the-fly generation of RI auxiliary basis set
  * Flexible selection of orbitals in :program:`GRID_IT`
  * New features in GV code: visualization of molden files, selection of atomic groups, symmetry operations

* Changes in usage of the package:

  * No shell scripts are needed to run |molcas|.
  * New EMIL commands for file handling
  * Control of the print level of the code

* Installation and tools

  * New tools for memory and I/O profiling
  * New configuration files has been included

.. rubric:: New features in 7.0:

* New codes and major updates:

  * CHOLESKY --- a new approach to ab initio and first principle QM methods free
    from explicit two-electron integrals. SCF/DFT, RASSCF, RASSI and MP2 energy
    calculation can now be done with considerable improvement of performance
    and with controlled accuracy of the results.
  * The 1-center approximation of the Cholesky decomposition, 1-CCD
  * Resolution of Identity (RI)/ Density fitting (DF) scheme for SCF, DFT,
    CASSCF, RASSI and CASPT2
  * The :program:`CASPT2` module can be used in connection with Cholesky and RI/DF approximations,
    allowing for the treatment of larger systems
  * Update of guessorb code
  * Electrostatic potential fitted (ESPF) QM/MM interface for SCF, DFT,
    CASSCF, CASPT2, and CC. ESPF analytic gradients for SCF, DFT, and CASSCF.
  * Gradients for "pure" DFT for the 1-CCD, and RI/DF approximations
  * Scaled Opposite-Spin (SOS) and Scaled Spin Component (SCS) MP2 are implemented when
    using Cholesky or RI/DF approximation.
  * NEMO program: fitting of potential surfaces, energy optimizations, potential curves
    and simulation parameters.
  * interface to MOLSIM code
  * Major update for GUI code :program:`GV`, with a possibility to edit coordinates and
    visually select active space for RASSCF calculations.
  * A new program, :program:`EXPBAS`, has been introduced that allows expanding an
    orbital file from a small to a larger basis set.
  * Several different procedures for constructing localized orbitals have been
    implemented. Among them is one based on a Cholesky decomposition of the density
    matrix.

* Performance enhancements:

  * Use of external blas libraries: lapack, GotoBLAS, Atlas, Intel MKL, ACML
  * New version of GA has been included.
  * Improved diagonalization routines and improved convergence in scf and rasscf
  * Some size limits in :program:`RASSCF` and :program:`CASPT2` have been increased or eliminated.
  * Automatic generation of starting orbitals for arbitrary valence and
    ECP basis sets.

* New features in existing codes:

  * Natural orbitals for UHF calculations. Can, for example be used as
    starting orbitals for :program:`RASSCF`.
  * Natural Bond Order (NBO) based on the LoProp partitioning.
  * Arbitrary order Douglas--Kroll--Hess (DKH) transformation to include
    scalar relativistic effects.
  * Picture-change-corrected electric potential, electric field, and
    electric field gradient properties.
  * Automatic generation of rydberg orbitals in genano.
  * RASSI can compute g-tensors.
  * CASPT2 is able to run with Cholesky vectors instead of integrals.
  * Transverse constraint for geometry optimizations.
  * Numerical gradients for several methods.
  * Numerical IR intensities for Numerical Hessian.
  * Computation of charge capacitances for bonds using Loprop.
  * Localized exchange-hole dipole moments in Loprop.
  * Possibility to use loprop with user-defined densities.
  * Evaluation of transition density between two states.
  * Mulliken type multicenter multipole expansion and localized
    polarizablilites based on the uncoupled HF approach.
  * Several improvements and enhancements in the visualization program GV.
  * The ANO-RCC basis set is now complete covering all atoms H--Cm.
  * The GUESSORB facility is now included in :program:`SEWARD`, which automatically
    produces starting orbitals for arbitrary basis sets.

* Changes in usage of the package:

  * Improvements in |molcas| input language.
  * |molcas| job can be submitted without shell scripts.
  * The programs are making extensive use of the runfile to simplify
    the input and eliminate unnecessary inputs.
  * automatic saving of output files (molden files, and orbital files)
  * The starting orbitals for :program:`RASSCF` can be taken from a number of sources
    (Guessorb, runfile, etc.), and this is done in a semi-intelligent
    way unless specified in user input.
  * simplified RASSCF input: number of
    orbitals, spin, etc can sometimes be deduced by the program from
    information available on the runfile or an orbital file.
    One can use CHARGE instead of the number of active electrons.
  * If used in multiple runs in one job, the RASSCF automatically
    selects suitable individual names for the JOBIPH files. The choice
    can be overridden by keyword input, but if not, it matches the
    default selection of JOBIPH names in :program:`RASSI`.
  * RASSI can use default selection of JOBIPH names, when used together with multiple
    RASSCF runs in one job.
  * RASSCF can use natural orbitals from a preceeding UHF calculation as input
    orbitals.

* Installation and tools

  * improved installation procedure, with possibility to select compilers,
    BLAS libraries, and parallel environment.
  * Configuration files for new compilers, including gfortran, g95, SunStudio
  * Configuration files for OpenMP parallelization.
  * Tools for extracting information from RUNFILE and JOBIPH files.
Web Site
========

| Please contact on the web at:
| URL: |MolcasWWW|
Introduction
============

.. index::
   single: MOLCAS; Introduction
   single: Introduction

Introduction to |molcas|
------------------------

.. toctree::

   introduction
   aboutthismanual
   news
   parallelization
   ack
   citation
   web
   disclaimer
Parallelization efforts for |molcas| modules
============================================

Presented below is a table of modules in |molcas| that *can* benifit from
parallel execution through distribution of work and/or resources. If a module
is not listed in this table, and the module-specific documentation does not
mention anything about parallelization, then you have to assume the module is
not (efficiently) parallelized. This means that even though it will get
executed in parallel, all processes will perform the same serial calculation!
Be aware that for parallel modules with serial components, the use of the
serial components (indirectly or through the use of a keyword) might adversely
affect CPU and memory usage for large calculations. In that case, you might
have to increase the runtime or memory, or avoid/use keywords that
activate/deactivate the serial components.

.. table:: Modules in |molcas| which benefit from parallel processing.
   :name: tab:mpp_effort:

   ================= ============================================== =============================
   Module            Parallel speed-up expected for                 Notable non-parallel parts
   ================= ============================================== =============================
   :program:`seward` | conventional 2-el integrals                  | 1-el integrals
                     | Cholesky vectors                             | Douglas--Kroll--Hess
                                                                    | properties
   :program:`scf`    | orbital optimization                         | properties
   :program:`rasscf` | orbital optimization                         | CI optimization
                                                                    | properties
   :program:`mbpt2`
   :program:`caspt2` | Cholesky vectors                             | conventional 2-el integrals
                                                                    | properties
                                                                    | multi-state interaction
   :program:`alaska` | displacements (if using numerical gradients)
   :program:`geo`    | displacements
   ================= ============================================== =============================
Bibliography and Index
======================

.. raw:: latex

   % Workaround for bug #8087
   \setcounter{secnumdepth}{-99}

.. toctree::

   references
|molcas|, Quantum Chemistry Software
====================================

|molcas| is a Quantum Chemistry software package developed by scientists to be used by
scientists. It is neither a commercial product nor is it sold for significant profit gain
by its owner, Lund University. The authors
of |molcas| have assembled their collected experience and knowledge in
computational Quantum Chemistry to produce a research product which is used
as a platform by the scientists in the |molcas| network to
develop new and improved computational tools in Quantum Chemistry. Several of
the codes in the |molcas| software have newly developed leading-edge features. Along with these new
capabilities, users should not be surprised to ocasionally discover bugs when using |molcas|.

The basic philosophy behind |molcas| is to develop methods that allow
accurate *ab initio* treatment of very general electronic structure problems
for molecular systems in both ground and excited states which is not an easy
task. Nowadays, knowledge about how to obtain accurate properties for single-reference
dominated ground states is well developed, and |molcas| contains
a number of codes that can perform such calculations (MP2, CC, CPF, DFT etc).
All these methods treat the electron correlation starting from a single
determinant (closed or open shell) reference state. Such codes are today's
standard in most Quantum Chemistry program.

However, |molcas| is to be able to treat,
highly degenerate states, such as those occurring in
excited states, transition states in chemical reactions, diradicaloid systems, heavy metal systems,
as well as other chemically important problems, all at the same level of accuracy.
This is a much more difficult problem,
since a single-determinant approach does not work well in these cases. The key
feature of |molcas| is the multiconfigurational approach. |molcas| contains
codes for general and effective multi-configurational SCF calculations at the
Complete Active Space (CASSCF) level, but also employs more restricted MCSCF
wave functions such as the Restricted Active Space, RASSCF, and the Generalized Active Space, GASSCF.
It is also possible using either CASSCF or RASSCF to
employ optimization techniques and obtain equilibrium geometries, transition-state structures,
force fields, and vibrational energies using gradient techniques.

Since |molcasviii| the Stochastic-CASSCF method :cite:`limanni2016` is also available to treat systems requiring large active spaces.
Routine calculations have been presented with active spaces of size of 40 electrons in 40 orbitals :cite:`limanni2018,limanni2019` and larger active space are currently tested.

Although the RASSCF approach is known to give reasonable structures for
degenerate systems both in ground and excited states, in
general it is not capable of recovering more than a fraction of the correlation
energy. Therefore, it becomes necessary to supplement the multi-configurational SCF
treatment with a calculation of dynamic correlation effects. In the earliest
version of |molcas|, this was achieved by means of the multi-reference (MR) CI
method. This method has severe limitations in the number of electrons
that can be correlated and the size of the reference space which limits
study to excited states of small molecules.
However, the MRCI code in |molcas| does have the capacity to produce very accurate wave functions and
potential energy surfaces, and is used by many groups for this purpose.
In fact, it is also possible to run the COLUMBUS MRCI code together with |molcas|.

During the period of 1986--90, a new method called CASPT2 was developed, which
computes dynamic electron correlation effects for multi-configurational wave
functions based on second order perturbation theory and was included into the second version of
|molcas|. From the beginning it was not clear whether or not the CASPT2 method would be
sufficiently accurate to be useful in practice, but it turned out to be surprisingly
accurate in a number of different types of chemical applications.
The CASPT2 approach has become especially important in
studies of excited states and spectroscopic properties of large
molecules, where no other *ab initio* method has, so far, been applicable.
Since the CASPT2 method is based on second order perturbation theory and has, therefore,
limitations in accuracy, the error limits have been investigated in a
large number of applications. The relative energy errors are
small in almost all cases leading to results which can be used for conclusive
predictions of molecular properties in ground and excited states.
Important application areas for the CASPT2 method are potential energy
surfaces for chemical reactions, photochemistry, transition metal chemistry, and
heavy element chemistry.

A multi-state version of CASPT2 is available, which allows for the simultaneous
study of several electronic states, including their interaction to second order.
This code is especially useful in cases where two or more energy surfaces are
close in energy. An analytical CASPT2 gradient code is in the process of development,
but this work is as yet unfinished. In place of the analytical gradient capability,
|molcas| includes a numerical procedure, which allows
automatic geometry optimization at the CASPT2 level of theory. It is applicable
to all states and systems for which the CASPT2 energy can be computed including the
calculation of vibrational frequencies. It is important to note that the CASPT2
method is under constant development.

Since |molcasviii| the Multiconfiguration Pair-Density Functional Theory, MC-PDFT,
is also available to treat dynamical correlation.

If only a few electrons are correlated, the active space can be quite large
without too many configurations being generated, but in most cases the number of
active electrons is comparable to the number of active orbitals.
Occasionally, a larger active space would be preferred, but would result in too
many configurations (more than a few million CSF's). The more general RASSCF
scheme can be useful, at the price of less efficient calculations, and the risk
of bad convergence properties in the orbital optimization. The CASPT2 program
handles also such wave functions, but will not include correlation within the
active space, i.e., interaction with states that would have been included in
the full CASSCF but are excluded by the RASSCF restrictions. The RASSCF wave
function is regarded as an accurate approximation to the full CASSCF
wave function, and the CASPT2 program evaluates only dynamic correlation that
involves at least one non-active orbital.

|molcas| not only contains the ability to produce various types of wave functions,
but also can compute molecular properties using formulas of expectation values or finite
perturbation theory using the RASSI program.
The RASSI program has the capacity to compute the interaction between several
RASSCF wave functions based on different orbitals which are generally non-orthonormal
(i.e. a non-orthogonal CI). RASSI is routinely used to compute transition dipole
moments in spectroscopy, to study electron transfer, and to obtain eigenstates
of a relativistic Hamiltonian with inclusion of spin-orbit interaction.

Scalar, i.e. spin-averaged, relativistic effects are typically included
in any calculations by using Douglas--Kroll--Hess transformation of one-electron
integrals. The standard basis set library
ANO-RCC :cite:`Roos:03c,Roos:03g,Roos:05a,Roos:05b,Roos:08b`
is optimized for use with these integrals and to include correlation of
semi-core orbitals, and to to have uniform quality across the periodic system
up to element 96, Curium. For heavier elements, typical calculations include
the spin-orbit interaction by using CASSCF wave functions as a many-electron basis
set, letting RASSI compute a Hamiltonian matrix over the set of all spin-components
of these functions, correct for dynamic correlation using CASPT2 and include
a one-electron spin-orbit Hamiltonian. This procedure has been shown to give
accurate results in a number of studies for actinides and other
heavy atom systems :cite:`Roos:03a`.

It is also possible to model solvent effects by adding a
reaction field Hamiltonian (PCM). A new QM/MM model is also included in |molcas|.

The release of |molcasvii| leads to many important enhancements. The sizes of the systems
that can be treated with |molcas| were previously restricted because of limitations in
storing two-electron integrals for large basis sets. This system size limitation has
been substantially reduced by the introduction of a Cholesky decomposition of the
two-electron integrals. This feature is used in |molcasvii| at all levels
of theory :cite:`Aquilante:07b,Aquilante:08a,Aquilante:08b` and speeds up calculations
by orders of magnitude, extending the size of basis sets that can be used.
Accuracy can be controlled by the threshold used in the decomposition. The same
approach can be used to generate RI auxiliary basis sets on the fly,
allowing the calculation of energy derivatives for HF, MP2, DFT, and CASSCF levels of theory.

It is important to emphasize that important problems in Quantum Chemistry cannot be solved
by simply applying :bdit:`black box` techniques.
Nor is |molcas| a :bdit:`black box` tool. A typical |molcas| user should be
someone with a high degree of chemical insight, who has some knowledge of different
Quantum Chemical models in use today, and, most importantly, is able to apply these
models to the appropriate chemical problem while understanding the inherent accuracy
of these methods.
The typical |molcas| user should also apply critical analysis of results, take nothing
for granted, and always check that the results are consistent with the model that was used.
The skill to use |molcas| effectively will not come immediately, but
the user has several resources including this manual and examples which
explain how different key projects were solved using |molcas|.
Users are certain to find them helpful in their own attempts to master the software
for use in chemical applications. The |molcas| group also arranges regular workshops,
which provide a more intimate environment on learning how to use |molcas|.

.. \ifmanual
   \input news
   \fi
.. _references:

Bibliography
============

.. bibliography:: molcas.bib
   :cited:
   :style: molcas

.. not cited
  .. bibliography:: molcas.bib
     :notcited:
.. _sec\:chemps2_installation:

Installation of CheMPS2--|molcas| interface for DMRG calculations
=================================================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

The CheMPS2--|molcas| interface requires the following components:
The CheMPS2--|molcas| interface :cite:`Phung2016,Wouters2016`,
based on the Block--|molcas| interface :cite:`Nakatani2017`,
can support DMRG-SS-CASPT2 and DMRG-SA-CASPT2 calculations.

It requires the CheMPS2 binary. For installation of CheMPS2, consult
http://sebwouters.github.io/CheMPS2/index.html if it is not already
available in your OS.

Note that only the version with the Open Multi-Processing (OpenMP) is supported,
thus build CheMPS2 with:

::

  -D WITH_MPI=OFF

In order to efficiently run the CheMPS2--|molcas| interface,
it is advisible to compile either serial or parallel |molcas| with MPI.
An example:

::

  ./configure -compiler intel -parallel -64 -mpiroot /path/to/mpi/root \
              -mpirun /path/to/mpi/bin/mpirun -blas MKL -blas_lib -mkl=sequential \
              -hdf5_inc /path/to/hdf5/include \
              -hdf5_lib /path/to/hdf5/lib \
              -chemps2 /path/to/chemps2/binary

The CheMPS2--|molcas| interface can also be activated with CMake:

::

  -D CHEMPS2=ON -D CHEMPS2_DIR=/path/to/chemps2/binary

Before testing the CheMPS2--|molcas| interface, make sure to increase stack size,
export :variable:`OMP_NUM_THREADS`, the CheMPS2 binary, and all the required libraries for CheMPS2.

::

  ulimit -s unlimited
  [export OMP_NUM_THREADS=...]
  export PATH=/path/to/chemps2/binary:$PATH

Verify the installation:

::

  molcas verify extra:850,851
  molcas verify benchmark:970
Installation Guide
==================

.. toctree::
   :maxdepth: 2

   install
   parainst
   dmrginst
   stochcas
   maintain
Installation
============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

The present installation guide describes the necessary steps for installing
and tailoring |molcas|. It also describes the steps for applying updates
whenever necessary.

The installation procedure can be reduced to a few simple steps:

#. Extract the contents of the tar
#. Configure the package
#. Build the package
#. Build GUI and documentation (optional)
#. Make the package generally available

Prerequisites
-------------

Prerequisite hardware
.....................

In general, |molcas| can be built on any hardware that runs under a UNIX operating system.
Some of these variants of hardware and software have been tested by us, and you
should not have any problems to install |molcas| on any of these.
For other platforms you will most likely need to put some extra effort into the installation.
In many cases the only effort on your part is setting some compiler flags,
paths to system software etc.
For a list of the platforms where we have
successfully installed |molcas| see our homepage:
|MolcasWWW|.

To load the executables resident, sufficient memory is required.
In addition, the programs are enabled to allocate work space dynamically.
To avoid excessive paging we recommend that your machine should be
equipped with at least 2 GB of memory per running application. Note, that
|molcas| will run faster with more memory.

To build |molcas| you may need up to 2 GB of free disk space depending on
what you choose to install and how (e.g. CMake keeps the object files around).
The actual size of a |molcas| installation is around 300-600 MB.
To run the verification tests of |molcas| you should have a scratch disk
with up to 1 GB of free disk space, depending on the suite you run. For the
"small" set about 400 MB will suffice.
To perform larger calculations, ample amount of scratch disk space is necessary.
The exact amount varies with the type of systems studied, but a general
recommendation is at least 4 GB of disk space, per production run.

Prerequisite software
.....................

If you obtain the source code of |molcas|, then you need to
make certain that the necessary software is available to build |molcas|.
The minimum requirements are:

* A Fortran compiler (with support for Fortran 2003 and later)
* A C compiler
* GNU make
  See URL |GnuWWW| and navigate to the gnumake page or go directly
  to |GnuMakeWWW|
* Perl (version 5.008 or higher)

Also, you can benefit from following optional dependencies:

* CMake (version 2.8.11 or higher, recommendeded for easier configuration)
* an optimized BLAS/LAPACK library (alternative for the slow built-in library based on Netlib)
* MPI-2 (to enable parallelization features of |molcas|)
* Global Arrays (version 5 or higher, an alternative to the built-in DGA library)

.. warning::

   The DGA library is not available in |openmolcas|.

The Graphical User Interface codes in |molcas| require additional software,
including OpenGL and glut library. However, in most of the cases there is no need
to install these libraries, since executables for GUI are included into the
distribution, or they can be downloaded from |molcas| webpage (|MolcasWWW|).

In order to get TaskFarm working, the following packages should be installed
on your system:

* Debian/Ubuntu: :file:`libipc-shareable-perl`, :file:`libparallel-forkmanager-perl`
* RedHat/CentOS: :file:`perl-IPC-Shareable`, :file:`perl-Parallel-ForkManager`
* Other OS: :file:`Shareable.pm`, and :file:`ForkManager.pm` should be available from
  :variable:`$PERL5LIB`

Windows
^^^^^^^

To install |molcas| under MS Windows (98/NT/XP/7/8) one should install Cygwin
(freeware from RedHat Inc., which can be downloaded from |CygwinWWW|).
The minimal installation of Cygwin to run |molcas| includes:

* check that user name (under Windows) does not contain spaces
* select a disk, which has enough space for installation of Cygwin and |molcas|
* install Cygwin to the root of selected disk with all defaults
* run setup again and install the following packages: Devel\ :math:`\rightarrow`\gcc-fortran,
  Devel\ :math:`\rightarrow`\make, Devel\ :math:`\rightarrow`\gcc-gcc, Utils\ :math:`\rightarrow`\time, Perl\ :math:`\rightarrow`\perl
* optionally install editors: Editors\ :math:`\rightarrow`\mc, Editors\ :math:`\rightarrow`\vim
* run cygwin.bat to create Cygwin environment for the user
* copy |molcas| tar file into your home directory in Cygwin, and
  proceed with installation in the same way as under Linux.

MacOS
^^^^^

Installation of |molcas| under MacOS requires installation of the Apple
Developer Tools (Xcode) and a Fortran compiler. These programs could be
downloaded from:

| https://developer.apple.com/xcode/downloads/
| https://opensource.apple.com/
| https://gcc.gnu.org/wiki/GFortranBinaries#MacOS
| http://hpc.sourceforge.net/
| https://www.macports.org

However, if you are looking for an out of the box solution, you can download a Free PGI for Mac OS X
distribution available at https://www.pgroup.com/products/freepgi/index.htm

Preparing the installation
..........................

In order to install |molcas| you need to choose a directory
where the |molcas| driver script is to be installed. The driver
executes scripts and programs form the |molcas| package and must be
located in a directory included into the :variable:`PATH` variable.
Usually this will be :file:`/usr/bin` when installing as root,
and :file:`~/bin` when installing as an unprivileged user.

The driver script :file:`molcas` uses the value of the environment variable
:variable:`MOLCAS` to identify which version to use. The major advantage with this
mechanism is that it is easy to switch between different versions of |molcas|
by simply changing the environment variable :variable:`MOLCAS`.
However if the current directory is a subdirectory (up to 3rd level) of a
|molcas| tree, the latter will be used regardless of the value of the :variable:`MOLCAS` variable.

|molcas| itself can be located in any place on the disk.
The installation can be done by root, or by an unprivileged user.
In the later case you can copy the :file:`molcas` driver script to an appropriate
location, e.g. :file:`/usr/local/bin`, after the installation.

All files are contained in a tar archive file
with the name :file:`molcasXX.tar.gz`, where :file:`XX` depends on the version number, you need to
uncompress the file with the command
:command:`gunzip molcasXX.tar.gz`, and untar the package with
:command:`tar -xvf molcasXX.tar`.

.. _sec\:configure_molcas:

Configuring |molcas|
--------------------

Before you can build |molcas| you have to configure it.
Most common platforms have been setup by the |molcas| developers, so for a serial
installation with default settings for compiler and compiler flags configuration
of |molcas| can be done without specifying any special extra options.

There are two ways to configure |molcas|: using the :command:`configure` script (alternative 1)
or using :command:`cmake` (alternative 2). The latter is more recent and does not support all the
original platforms, but it supports most commonly used environments
and is easier as it is usually able to autodetect the necessary libraries.
The CMake alternative also makes it easier to synchronize different installations
based on the same source. Therefore, we recommend you to use alternative 2.
If you are already familiar with building |molcas| 8.0 or an earlier version,
it might be easier to keep using alternative 1, as you can then port your exisiting
configuration options.
Note that for certain external software (e.g. DMRG), CMake is mandatory,
and thus alternative 2 is needed.

For new users, use of the :command:`setup` script is recommended. It will also allow
you to choose between the two configuration alternatives if CMake is detected.

Simple configuration with the setup script
..........................................

If you are new to building |molcas|, it is recommended that you use the
:file:`setup` script to configure |molcas|. Advanced users and/or users that need
further customization should skip this section and use one of the alternatives
in the next sections to configure |molcas|.

.. compound::

  The :file:`setup` script will prompt you interactively about the most important settings.
  To get started, first unpack the |molcas| source and then run::

    ./setup

  in the main |molcas| directory. Answer the questions and then proceed to
  :numref:`sec:building_molcas` to build |molcas|.

For advanced users that need further customization, one of the alternatives
in the next sections will be needed.

Advanced configuration with the configure script (alternative 1)
................................................................

You can start the configuration by running the :file:`configure` script::

  ./configure

To know which flags can be used, run :command:`{./configure -h`. The above command
(without any flags) will use a default configuration, i.e. a serial |molcas|
installation using built-in BLAS/LAPACK.

When configuration is finished, you should review the log file
:file:`configure.log`
to see if everything is ok.
There is no harm in running the configuration script even if it should fail,
you simply rerun it with correct parameters.

If the configuration step was not successful, you probably are missing some
prerequisite software, or this software is located in an unusual location on the disk.
In the later case you might need to update your :variable:`PATH`, or use flag :command:`-path`
in :command:`configure`.

|molcas| supports out-of-source installation. If for some reason,
you would like to install molcas under a separate tree, you can create
a directory, and call :command:`configure` with appropriate flags, e.g. ::

  mkdir $HOME/molcas
  cd $HOME/molcas
  /sw/molcas_dist/configure -speed safe

The list all the options for :command:`configure`, run ::

  ./configure -help

Advanced configuration with CMake (alternative 2)
.................................................

Start configuration by creating a build directory and then running the :command:`cmake`
program with the location of the |molcas| source. You can create the build directory
as a subdirectory of the |molcas| root directory, but we recommend you create it
outside. For example, suppose the |molcas| root is located at :file:`molcas` in your
home directory and you want to build it at :file:`molcas-build`::

  mkdir ~/molcas-build
  cd ~/molcas-build/
  cmake ~/molcas/

After the first run, CMake keeps a cache of the configuration around
as a file :file:`CMakeCache.txt`.
If you want to change certain options (e.g. use a different compiler),
you need to remove this file first. As an example, if we wish to reconfigure
with the intel compilers instead we do::

  rm CMakeCache.txt
  CC=icc FC=ifort cmake ~/molcas/

Once the cache file is there, subsequent additional options do not
require pointing to the |molcas| source, just to the build directory
itself. Here we add an option to build parallel |molcas|::

  cmake -DMPI=ON .

When using MPI, CMake will pick up the correct compiler and MPI library from the wrappers.
So if you configure with MPI or you later wish to use a different MPI library/compiler wrapper, it is better
to remove the cache file first, then (re)configure pointing to the wrappers::

  rm CMakeCache.txt
  CC=mpicc FC=mpifort cmake -DMPI=ON ~/molcas/

Summary of main options for CMake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To see all the CMake options, you can run the :command:`ccmake` command to interactively
select the options and their values. The following is a list of some of the most
important options.

* ``BUILD_SHARED_LIBS`` --- (``ON``/``OFF``): Enable building shared libraries (reduced disk space).
* ``CMAKE_BUILD_TYPE`` --- (``Debug``/``Garble``/``RelWithDebInfo``/``Release``/``Fast``): Normally
  use ``Release``. ``RelWithDebInfo`` may be useful for reporting a problem. ``Fast`` in unsupported
  and may give wrong results in some cases.
* ``CMAKE_INSTALL_PREFIX`` --- Specify the directory where |molcas| will be installed when running
  :command:`make install`.
* ``MPI`` --- (``ON``/``OFF``): Enable multi-process parallelization.
* ``GA`` --- (``ON``/``OFF``): Enable interface with Global Arrays (see :numref:`sec:parallel_installation`).
* ``HDF5`` --- (``ON``/``OFF``): Enable HDF5 files (portable binary format) in some programs.
* ``LINALG`` --- (``Internal``/``Runtime``/``MKL``/``ACML``/``OpenBLAS``): Select the linear algebra library (BLAS + LAPACK)
  against which to link |molcas|. ``Internal`` uses the default (and slow) Netlib version included with |molcas|. ``Runtime``
  (experimental) offers the possibility of choosing the library at run time.
* ``OPENMP`` --- (``ON``/``OFF``): Enable multi-thread parallelization (usually restricted to using
  a multi-threaded version of linear algebra libraries.
* ``TOOLS`` --- (``ON``/``OFF``): Compile the tools that have CMake support.

Example 1: GCC C/Fortran compilers with GA/OpenMPI and OpenBLAS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* 64-bit Linux OS
* MPI preinstalled (install OpenMPI or MPICH with package manager)

::

  # OpenBLAS
  tar zxvf OpenBLAS-v0.2.15.tar.gz
  cd OpenBLAS-0.2.15/
  make USE_OPENMP=1 NO_LAPACK=0 INTERFACE64=1 BINARY=64 DYNAMIC_ARCH=1 libs netlib shared
  [sudo] make PREFIX=/opt/openblas-lapack-ilp64 install
  # GA
  tar zxvf /path/to/ga-5-4b.tgz
  cd ga-5-4b/
  ./configure --enable-i8 --with-blas8 --with-lapack8 --with-scalapack8 --prefix=/opt/ga54b-ilp64.OpenMPI
  make
  [sudo] make install
  # Molcas
  tar zxvf molcas.tgz
  cd molcas
  mkdir build && cd build/
  export GA=/opt/ga54b-ilp64.OpenMPI
  export OPENBLASROOT=/opt/openblas-lapack-ilp64
  CC=mpicc FC=mpifort cmake -DMPI=ON -DGA=ON -DLINALG=OpenBLAS ../
  make -j4

Any other configurations can be easily derived from the above by simply
removing the unneeded optional stuff.

Example 2: Intel C/Fortran compilers with GA/IntelMPI and MKL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* 64-bit Linux OS
* Intel Compilers/MPI preinstalled (usually on a cluster as a module)
* Infiniband (OpenIB)

::

  # make sure Intel compilers/MPI are loaded
  module load ...
  # check compilers/environment
  type mpiicc
  type mpiifort
  echo $MKLROOT
  # GA
  tar zxvf /path/to/ga-5-4b.tgz
  cd ga-5-4b/
  ./configure --prefix=/opt/ga54b-ilp64.IntelMPI --enable-i8 --with-openib \
              --with-blas8="-L$MKLROOT/lib/intel64 -lmkl_intel_ilp64
                            -lmkl_intel_thread -lmkl_core -liomp5 -lpthread -lm" \
              --with-scalapack8="-L$MKLROOT/lib/intel64 -lmkl_scalapack_ilp64
                                 -lmkl_intel_ilp64 -lmkl_intel_thread -lmkl_core
                                 -lmkl_blacs_intelmpi_ilp64 -liomp5 -lpthread -lm"
  make
  [sudo]make install
  # Molcas
  tar zxvf molcas.tgz
  cd molcas
  mkdir build && cd build/
  export GA=/opt/ga54b-ilp64.IntelMPI
  CC=mpiicc FC=mpiifort cmake -DMPI=ON -DGA=ON -DLINALG=MKL ../
  make -j4

.. _sec\:building_molcas:

Building |molcas|
-----------------

When the configuration step (:numref:`sec:configure_molcas`) is completed
successfully, you can build |molcas|.
This is simply done by typing :command:`make` in the |molcas| root directory.
It is recommended that you save the output from :command:`make` in a log file
for tracing of potential problems. ::

  make > make.log 2>&1

.. compound::

  In order to speed up the build process, you can perform a parallel compilation.
  When you configure |molcas| with CMake, a simple ::

    make -jN

  will suffice, while if you configured |molcas| with the :command:`configure` script,
  you need to build in two steps::

    make -jN build
    make install

  In the above commands, ``N`` should be replaced with the number of threads
  you wish to use for building. Typically, a number equal to the number of cores
  will be fine.

When |molcas| is being compiled some compilers give a lot of warnings.
These are not serious in most cases. We are working on eliminating them, but
the job is not yet completely finished.

After |molcas| has been built correctly, you should absolutely run a basic
verification to ensure that the installation is sane. See the :ref:`next section <sec:verify>`
for details on verification.

.. _sec\:verify:

Verifying the |molcas| installation
...................................

After a successful build of |molcas| you should verify that the various
modules run correctly. Directory :file:`test/`
contains various subdirectories with test inputs for |molcas|. Use the command
:command:`molcas verify [parameters]` to start verification.
Running this command without parameters will check
the main modules and features of |molcas| and we recommend this default
for verifying the installation.
You can also specify a keyword as argument that translates into a
sequence of test jobs,
or you can specify a list of test jobs yourself.
The script has extended documentation, just run
:command:`molcas verify --help`.

To generate a report after performance tests you should execute
a command :command:`molcas timing`. The report is then located in the file
:file:`test/timing/user.timing`. The results of benchmark tests
for some machines are collected on our webpage
http://www.molcas.org/benchmark.html
At the completion of the test suite a log of the results is generated
in the file :file:`test/results`. If installation was performed
by another user (e.g. root), you can redefine the location of
output files by adding the flag :command:`-path PATH`.
Each test job is signaled as either
ok of failed. If there are any failed jobs, the outputs are saved in
:file:`Test/Failed_Tests`. Each test job tests for a resulting checksum
for the modules tested. This checksum is typically the energy for a
wavefunction program such as :program:`RASSCF`, whereas other types of
codes use other checksums.

The checksums will not match exactly with our reference values since
different machines use different arithmetics. We have tried to make
the acceptable tolerances as small as possible and at the same time
make all tests pass successfully. It might be the case that your
particular platform will produce one or more results that are
just outside our tolerances, and in such a case the test is most
likely ok.

.. _sec\:building_html_doc:

GUI and documentation
---------------------

Normally, there is no need to build the GUI used in |molcas|, since we
provide executables for most common platforms.
You can download executables for the GUI from the |molcas| webpage (|MolcasWWW|).

In order to build documentation in various formats, use the command :command:`make doc`.
Alternatively the documentation is also available no the web page (|MolcasWWW|).

.. _sec\:StochCAS_installation:

Installation of |molcas| for Stochastic-CASSCF calculations
===========================================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

The Stochastic-CASSCF method is based on the interface of the RASSCF program of |molcas|,
responsible for the orbital rotations via Super-CI, and the :program:`NECI` program,
responsible for the FCIQMC dynamics, replacing the deterministic Direct-CI based algorithm for large active space selection.
In principle, two installation protocols can be adopted that are referred to as embedded and uncoupled
forms. In the embedded form, the :program:`NECI` program is treated as a dependent subroutine of the
RASSCF program. This form effectively leads to an automatized version of the
Stochastic-CASSCF within the |openmolcas| software.
In the uncoupled form of Stochastic-CASSCF, :program:`NECI` is installed as a stand-alone program
and the |molcas|-:program:`NECI` interface is controlled manually by the user.
In this guide the uncoupled form will be discussed. It is the form preferred by
the developers of the method due to the non-black-box nature of the approach.

Uncoupled Form
++++++++++++++

The necessary routines in |molcas| are installed automatically,
but for improved communication between |molcas| and :program:`NECI` it is
recommended to compile with HDF5.

The :program:`NECI` code is available at https://github.com/ghb24/NECI_STABLE.

The :program:`NECI` code requires some external software and libraries:

* MPI: For builds intended to be run in parallel. OpenMPI, MPICH2 and its derivatives (IBM MPI, Cray MPI, and Intel MPI) have been tested.
* Linear algebra: ACML, MKL, BLAS/LAPACK combination.
* HDF5: To make use of the structured HDF5 format for reading/writing POPSFILES
   (files storing the population of walkers, and other information, to restart calculations).
   This library should be built with MPI and fortran support.

For configuring and compiling :program:`NECI` cmake is recommended::

  cmake -DENABLE_BUILD_HDF5=ON -DENABLE_HDF5=ON -DCMAKE_BUILD_TYPE=Cluster ~/neci/
  make -j hdf5
  make -j neci dneci

Cmake flag ``-DENABLE_BUILD_HDF5=ON`` builds the HDF5 library from source, and use that instead of one provided by the system.
Cmake flag ``-DENABLE_HDF5=ON`` makes use of HDF5 for popsfiles (default=on).

Two executable files will be generated: :file:`neci.exe` and :file:`dneci.exe`. The latter is compulsory for sampling one- and two-body
density matrices necessary for performing the orbital optimization. For a more detailed description of the :program:`NECI` configuration
the users are invited to read the available :program:`NECI` documentation.

More details about configuration/installation of the :program:`NECI` code can be found in the :program:`NECI` documentation.

There are currently no default verification tests for the Stochastic-CASSCF method. However, after installation of |molcas| one test is possible
to verify that MO integrals are correctly dumped into the FCIDUMP file. Simply use: ::

  molcas verify limannig


Embedded form
+++++++++++++

For the embedded form the :program:`NECI` source code has to be downloaded into the
|molcas| source directory.
Just execute in the |molcas| repository::

   git submodule update --init External/NECI

Then compile |molcas| with the ``-DNECI=ON`` cmake flag.
Maintaining the package
=======================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Tailoring
---------

|molcas|, as shipped, is configured with some default settings. You can change
some of these easily.
You can change default settings used in |molcas| (like memory usage, default
scratch area, policy in saving files, etc.)
by editing |molcas| resource file: global resource file :file:`$MOLCAS/molcasrc` or
user resource file :file:`$HOME/.Molcas/molcasrc`.

.. _sec\:dynamic_memory:

Dynamic memory
..............

Most modules in |molcas| utilize dynamic memory allocation. The amount of
memory each module allocate is controlled by the environment variable
:variable:`MOLCAS_MEM`. The amount of memory allocated is

* :variable:`MOLCAS_MEM` is undefined --- 1024 MB of memory is allocated
  (on 32 bit installation)
* :variable:`MOLCAS_MEM`\=\ ``nn`` --- ``nn`` MB is allocated.
  If this amount cannot be allocated, the module stops.

.. _sec\:disk_usage:

Disk usage
..........

Today many workstations utilize 64-bit integers
and addressing. However, old UNIX workstations and PC's had 32-bit integers
resulting in a file size limit of 2 GB.
To circumvent these limitations, the I/O routines
of |molcas| support multifile files, where a "file" is in reality a
logical file consisting of several physical files. The size limit of
these physical files is controlled by the environment variable
:variable:`MOLCAS_DISK` according to

* :variable:`MOLCAS_DISK` is undefined --- The modules will use a 2 GB size of the
  physical files. This might be the appropriate setting for machines
  with 32-bit addressing.
* :variable:`MOLCAS_DISK`\=\ ``nn`` --- The modules will use a ``nn`` MB size
  of the physical files.

To use files with a size bigger than 2 GB |molcas| should be compiled as 64-bit
executable.

Improving CPU performance
.........................

|molcas| is shipped with a number of default setup files located
in directory :file:`cfg/`. The defaults in these files are set to
a fairly safe level, but not necessary optimal. What you can change
to improve performance is

* Compiler flags
* Mathematical (blas) libraries

The simplest way to set up optimization level, and/or compile |molcas|
with various BLAS libraries is to use :command:`configure -setup`. This
interactive script helps to make a proper selection of flags for
improvement of |molcas| performance.

If you do decide to try to improve the performance we recommend that you
create a new setup file, for example, :file:`cfg/local.cfg` and
modify this file. It is not unlikely that your attempts to optimize
the codes will lead you to a case where some modules work and others do not.
In such a scenario it can be fruitful to have two copies of
|molcas|, one "safe" where all modules work and one "fast" where
some modules do not function properly.

Changing the compiler flags is the easiest. Using the most
aggressive optimization flags do sometimes lead to problems for
some of the modules. We have tried to choose an optimization level
that yields functioning code, but still reasonable fast.
For some systems there is a predefined set of compiler flags for
aggressive optimization. To compile |molcas| with these flags you
should run :command:`configure` with flag :command:`-speed fast`.
Note that this aggressive optimization level is not supported
by the |molcas| team. In other words, you are using it at your own
risk.

For some platforms you can utilize the vendor blas libraries. This
will certainly yield better performance, but may not work on all
platforms.

.. compound::

  During configuration of |molcas| it is possible to specify
  an external BLAS/LAPACK library. Use a flag :command:`-blas TYPE`
  to specify the type of BLAS libary: lapack (for a standard lapack
  library), Goto (for GotoBLAS), Atlas (for ATLAS), MKL (for Intel MKL).
  You should also specify a flag ::

    -blas_lib -Wl,--start-group -L/path/to/blas -lmy-blas -Wl,--end-group

  specifying the link options.
  For example, to configure |molcas| with Intel MKL library,
  you should issue a command ::

    ./configure -compiler intel -blas MKL -blas_lib -Wl,--start-group /opt/intel/mkl/lib/intel64 -lmkl_gf_ilp64 -lmkl_sequential -lmkl_core -Wl,--end-group

.. compound::

  To compile |molcas| with CUDA BLAS library, first, you have to compile
  the fortran wrapper provided by nVIDIA: ::

    CUDA=/path/to/cuda/
    FLAGS=-m64
    gcc $FLAGS -I$CUDA/include/ -I$CUDA/src/ -c $CUDA/src/fortran_thunking.c -o \
    $MOLCAS/lib/fortran.o
    ./configure -blas CUDA -blas_dir $CUDA/lib

  or, if on a 64bit system: ::

    ./configure -blas CUDA -blas_dir $CUDA/lib64

.. It is also possible to make a manual installation of a vendor
   supplied BLAS library.
   One should issue commands :command:`molcas uninstall blas_util`,
   :command:`molcas uninstall essl_util` and :command:`molcas uninstall %lapack_util` to remove BLAS/LAPACK related directories
   from the |molcas| source code, then export XLIB variable to set the
   location of blas library, e.g. :command:`XLIB="-lblas"; export XLIB`,
   and finally reconfigure and build |molcas|. If the library is in a
   nonstandard location you may have to issue the command
   :command:`XLIB="-Lpath_to_lib -lblas"; export XLIB`. Alternatively,
   define XLIB in the system specific configuration file.

After making changes to the setup files you have to issue the commands
:command:`make veryclean`, :command:`./configure` and :command:`make` in the |molcas| root
directory. It is highly recommended to run the verification suite after
any changes in configuration file.

.. MT:sec:prgm:

Customizing handling of files
.............................

The location and attributes of files used by |molcas| are defined in PRGM files.
The master copy of these files is located at the :file:`data` directory in the |molcas| root.
A user can copy these files and modify them. The highest priority is given
to the files located in the subdirectory :file:`prgm` in the current (:variable:`CurrDir`) directory,
next the :file:`$HOME/.Molcas` and finally the original location at :file:`$MOLCAS/data`.

The simplest way to manipulate prgm files is to use the :command:`molcas prgm` command.
A command :command:`molcas prgm init global` makes a copy of the prgm files in the :file:`.Molcas`
directory. :command:`molcas prgm init local` creates a :file:`prgm` subdirectory, and copies the prgm files
into it.
The editing of the files can be performed by your favourite editor, or by the :command:`molcas prgm` script.

The structure of PRGM files is simple. The field ``(file)`` is followed by the
FORTRAN name (as this file is known for |molcas|), real file name (as this file is known by the Operating system), and finally the attributes.

The attributes are listed here:

====== =====================================================
``ro`` the file is accessed for reading
``rw`` the file is accessed for reading and writing
``s``  the file will be saved (copied) from the scratch area
``m``  the file will be saved (moved) from the scratch area
``g``  the file can be visualized by program "gv/luscus"
``t``  the file is an ASCII text
``*``  multifile
``.``  multifile (for internal use)
``l``  use lustre filesystem in parallel run
``p``  the file will be deleted
``e``  the file will be placed to memory (see FiM)
``f``  use an alternative file location (FastDir)
====== =====================================================

A command :command:`molcas prgm +x ScfOrb` will add the attribute ``x`` to all ScfOrb files. A regexp can be used for a filename.
An opposite command :command:`molcas prgm -x ScfOrb` will remove the attribute ``x``.
A command :command:`molcas prgm comp [global]` shows the list of modifications in the local (:file:`prgm`), or global (:file:`.Molcas`)
directories.

.. _MT\:sec:fim:

Improving I/O performance
.........................

In order to activate this technology for a |molcas| scratch file, one needs to
do three things. First, please edit an external resource :file:`*.prgm` (for example,
:file:`$MOLCAS/data/seward.prgm`) from the :file:`$MOLCAS/data/` directory. If you don't
have access to the root |molcas| directory, then you can simply copy the
needed resource file into your home :file:`$HOME/.Molcas/` directory and edit it there.
The editing of the file consists in adding the "``e``" character to its
attributes: ::

  original: (file) ORDINT "$WorkDir/$Project."OrdInt rw*
  modified: (file) ORDINT "$WorkDir/$Project."OrdInt rw*e

Second, you need to set up the :variable:`MOLCAS_FIM` environment variable to ``1``
i.e.: ::

  export MOLCAS_FIM=1

The third and the final step is to specify the :variable:`MOLCAS_MAXMEM` (:math:`\geq`\ :variable:`MOLCAS_MEM`) parameter such that the
:variable:`MOLCAS_MAXMEM`\ |-|\ :variable:`MOLCAS_MEM` difference (in MW) is sufficient to host an entire
file in RAM. In other words, the :variable:`MOLCAS_MAXMEM`\ |-|\ :variable:`MOLCAS_MEM` difference should
exceed the original filesize.

In general, not all |molcas| files are suitable for placing in RAM. In
particular, it is a bad idea to activate FiM for :file:`RUNFILE`. In order to
identify which |molcas|'s files are proper candidates for FiM, you can simply
inspect the section ``II. I/O Access Patterns`` from a |molcas|'s output.
All files with high ratio of I/O ``random Write/Read calls`` are good candidates for
FiM. In particular case of the :program:`SEWARD` module, the :file:`ORDINT` file is
a very good candidate for FiM: ::

  II. I/O Access Patterns
  - - - - - - - - - - - - - - - - - - - -
  Unit  Name               % of random
                         Write/Read calls
  - - - - - - - - - - - - - - - - - - - -
   1  RUNFILE             28.6/  11.5
   2  ORDINT             100.0/  24.0
   3  DNSMAT               0.0/   0.0
   4  TWOHAM               0.0/   0.0
   5  GRADIENT            88.9/   0.0
   6  DNSMAX               0.0/   0.0
   7  TWOHAX               0.0/   0.0
   8  SODGRAD             85.7/   0.0
   9  SOXVEC              85.7/   0.0
  10  SODELTA             88.9/   0.0
  11  SOYVEC              88.9/   0.0
  12  ONEINT             100.0/  53.3
  - - - - - - - - - - - - - - - - - - - -

Applying patches
----------------

All program systems do contain bugs and |molcas| is certainly no exception.
We prepare patches for all problems as soon as we identify and fix the
problem.

.. You can get these patches from our web server in an easy and automatic way.

For important updates we provide Service Packs. A service pack is a shell
script, which makes a backup of your current |molcas| installation, and installs
updates.

Local modifications
...................

|molcas| is shipped with source code so you can make modifications
yourself. You are, of course, responsible for the correctness of any
such modification.

If you do make changes/additions to the source code that you feel is of
interest to other users, we encourage you to make these available.
Perhaps the best mechanism is to use the bulletin board on out homepage:
|MolcasWWW|.

Check Molcas Programming Guide for a detailed description of development
and distribution of modified code in |molcas|.
.. _sec\:parallel_installation:

Parallel Installation
=====================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Installation of |molcas| for execution in multi-processor environments can be a
bit more involved than the standard installation, this chapter considers those
particulars not covered previously.

The parallelization of |molcas| is achieved through the use of the Global Arrays
(GA) API and some direct MPI calls. The API can be linked to an external GA library
or to our own DGA library (an internal PGAS framework built upon MPI-2).

.. warning::

   The DGA library is not available in |openmolcas|.

When using DGA (the default), the current list of supported MPI-2.2 implementations is given below:
MPICH2/MPICH3, MVAPICH2, OpenMPI, Intel MPI.

When one wants to use an external GA library, it has to be configured and
compiled separately. In that case, please read the section on using an
external GA installation to properly configure and install GA first!!!

**IMPORTANT**: not all modules support distribution of work and/or
resources through parallel execution, and even if they do it might be that some
functionality is limited to serial performance. This is a list of core modules
which *can* benefit from parallel execution: gateway, seward, scf, rasscf,
caspt2. More detailed information regarding parallel behaviour can be found in
the documentation of the respective module and in the table at the beginning of
the manual about supported parallelism. If no information is available, you
should conclude that there is nothing to be gained from parallel execution.

Supported MPI implementations
-----------------------------

Most probably, you will use a free MPI-2 implementation such as MPICH2/MPICH3,
MVAPICH2, or Open MPI.

* MPICH2: :file:`https://www.mpich.org/`
* MPICH3: :file:`https://www.mpich.org/`
* MVAPICH2: :file:`http://mvapich.cse.ohio-state.edu/`
* Open MPI: :file:`https://www.open-mpi.org/`

**NOTE**: Open MPI versions older than v1.6.5 are not supported. More specifically,
only Open MPI v1.6.5, and v1.8.1 are tested and known to work correctly with |molcas|.

It is a very good idea to verify that the correct compiler environment is
present before configuring |molcas|. You should therefore check that the
backend compiler of the wrappers is correct by running :command:`/path/to/mpif77
-show` (MPICH2/MPICH3 and MVAPICH2) or :command:`/path/to/mpif77 --showme` (Open MPI),
which will list the actual executed command. If the backend compiler seems to
be correct, also try to run it to see if it is properly detected (on some
clusters you will need to load the appropriate module for the compiler). If all
is well, you should be able to configure |molcas| without any problems.

It is highly recommended to use the compiler that was used for the MPI library
to build GA (optional) and |molcas| to avoid compatibility issues. However, if you really
want to use a different compiler than the compiler which was used for building
the MPI library, you can do so by passing the :command:`-fc` and :command:`-cc`
command line arguments (MPICH2/MPICH3 and MVAPICH2) to the wrappers, or setting the
environment variables :variable:`OMPI_F77`/:variable:`OMPI_F90` and :variable:`OMPI_CC` (Open MPI).

Several commercial MPI implementations exist such as HP-MPI, IBM's MPI-F, Intel
MPI, SGI's MPT. Currently we only support Intel MPI. For the others that
are not (yet) supported, it is recommended to either configure |molcas| without parallel
options and change the :file:`Symbols` file after the serial configuration, or rely on
cmake to use the correct options.

Please refer to the documentation of your MPI implementation for details on how
to build programs, i.e. which wrappers to use and if necessary what libraries
you need to link in.

Using an external Global Arrays installation (optional step)
------------------------------------------------------------

If you wish to use an external GA library, it has to be installed before
you build |molcas|. You could e.g. use this if you have trouble with the built-in
DGA solution.
The installation instructions may be found at the Global Arrays home page:
:file:`http://hpc.pnl.gov/globalarrays/`

Note that any problems with installation or other issues specific to GA are
best resolved by contacting the GA authors directly, rather than the
|molcas| group. It is therefore a very good idea to run the GA
testing code as a job on the cluster where you want to use |molcas| to make sure
that it works properly before continuing to install |molcas|.

Global Arrays needs to be installed with 8-byte integer support using
the flag(s) :command:`--enable-i8 --with-blas8[=...] [--with-scalapack8[=...]]`,
and for infiniband clusters you probably need to use the :command:`--with-openib` flag.
When linking to an external library, e.g. the Intel MKL, do not forget to include
the proper :command:`ilp64` library versions.

Please read the documentation of GA for more details about installation.

General overview of the procedure with the configure script (alternative 1)
---------------------------------------------------------------------------

In the simplest case, the parallel version of |molcas| may be installed
simply by specifying the flag :command:`-parallel`
to :file:`configure`. For example: ::

  ./configure -parallel

When using an external GA, pass the location of the installation to |molcas| configure: ::

  ./configure -parallel -ga /opt/ga-5.1

When the locations of the MPI :file:`lib` and :file:`include` directories is set
incorrectly, you can specify them by setting their common root directory with
the :command:`par_root` flag or if they are in different directories you can use the
separate :command:`par_inc` and :command:`par_lib` flags: ::

  ./configure -parallel -par_root /usr/lib/openmpi
  ./configure -parallel -par_inc /usr/lib/openmpi/include -par_lib /usr/lib/openmpi/lib

More likely, some individual tailoring will be required, the following
summarizes the necessary steps:

#. Check that the correct wrapper compilers were detected, as specified in :file:`$MOLCAS/Symbols`.
#. If needed, change the :variable:`F77`/:variable:`F90` and :variable:`CC` variables in the :file:`Symbols` file for any custom modifications you made to the wrappers.
#. Optionally install (and test) the external Global Arrays library.
#. Check the command for executing binaries in parallel, as specified by :variable:`RUNBINARY` in
   :file:`$MOLCAS/molcas.rte`.
#. Install (and test) |molcas|.

Provided that steps 1--4 can be successfully accomplished, the installation
of |molcas| itself is unlikely to present many difficulties.

General overview of the procedure with cmake (alternative 2)
------------------------------------------------------------

CMake accepts two main flags for parallel installation, one to specify the
use of parallelization :command:`-DMPI=ON`, and one to specify a "true" GA
library :command:`-DGA=ON` instead of DGA (the default is :command:`-DGA=OFF`, meaning no
external GA is used, so do not confuse the option ``-DGA`` which means "define GA"
with DGA). When using the latter :command:`-DGA=ON` flag, there are two further
options: using a precompiled GA library or compile GA together with the rest of
|molcas|. To use a precompiled GA, make sure the :command:`GAROOT` environment
variable is exported and contains the path of the GA installation, before running
cmake. To compile GA as part of molcas, use the flag :command:`-DGA_BUILD=ON` (in addition
to :command:`-DGA=ON`)

CMake will determine an appropriate MPI libary based on the compiler it finds, so in order
to use a specific MPI library, just make sure the :variable:`CC` and :variable:`FC`
variables point to the correct MPI wrappers!

The whole procedure is summarized below (square brackets showing optional commands): ::

  [export GAROOT=/path/to/external/GA]
  [CC=/path/to/mpicc] [FC=/path/to/mpifort] cmake -DMPI=ON [-DGA=ON [-DGA_BUILD=ON]] /path/to/molcas
  make [-j4]

Running |molcas| in parallel
----------------------------

A few comments on running on a cluster:

The very old MPICH versions sometimes need a file with a list of the nodes the job at hand is allowed
to use. At default the file is static and located in the MPICH installation
tree. This will not work on a workstation cluster, though, because then all
jobs would use the same nodes.

Instead the queue system sets up a temporary file, which contains a list of the
nodes to be used for the current task. You have to make sure that this filename
is transfered to $mpirun. This is done with the :command:`-machinefile` flag. On a
Beowulf cluster using PBS as queue system the :variable:`RUNBINARY` variable in
:file:`$MOLCAS/molcas.rte` should look something like: ::

  RUNBINARY='/path/to/mpirun -machinefile $PBS_NODEFILE -np $MOLCAS_NPROCS $program'

The newer MPICH2/MPICH3 as well as MVAPICH2, which works through the use of the HYDRA daemons and does not need
this command line argument, as well as Open MPI most likely only need the :command:`-np
$MOLCAS_NPROCS` command line option. They use mpiexec instead of mpirun.

.. compound::

  Parallel execution of |molcas| is achieved by exporting the environment
  variable :command:`MOLCAS_NPROCS`, for example when running on 4 nodes use: ::

    export MOLCAS_NPROCS=4

  and continuing as usual.

In this section, we assume you will be using PBS on a cluster in order to
submit jobs. If you don't use PBS, please ask your system administrator or
consult the cluster documentation for equivalent functionality.

Example of a submit script
..........................

::

  #!/bin/sh
  #PBS -l walltime=10:00:00
  #PBS -l nodes=4
  #PBS -l pmem=3000mb

  ######## Job settings ###########
  export MOLCAS_MEM=800
  export SUBMIT=/home/molcasuser/project/test/
  export Project=test000
  export MOLCAS_NPROCS=4

  ######## modules ###########
  . use_modules
  module load intel/11.1
  module load openmpi/1.4.1/intel/11.1

  ######## molcas settings ###########
  export MOLCAS=/usr/local/molcas80.par/
  export WorkDir=/disk/local/

  ######## run ###########
  cd $SUBMIT
  molcas $Project.input -f

Memory
......

The maximum available memory is set using the PBS option pmem. Typically,
:variable:`MOLCAS_MEM` will then be set to around 75% of the available physical
memory. So for a parallel run, just divide the total physical memory by the
number of processes you will use and take a bit less. For example, for a system
with 2 sockets per node and 64 GB of memory, running 1 process per socket, we
would set pmem to 30000 MB.

I/O
...

The important thing to consider for I/O is to have enough scratch space
available and enough bandwidth to the scratch space. If local disk is large
enough, this is usually preferred over network-attached storage. |molcas|
requires the absolute pathname of the scratch directory to be the same across
nodes.

Pinning
.......

Process pinning is sometimes required to achieve maximum performance. For CASPT2
for example, processes need to be pinned to their socket or NUMA domain.

The pinning configuration can usually be given as an option to the MPI runtime.
With Intel MPI for example, one would set the :variable:`I_MPI_PIN_DOMAIN`
variable to :command:`socket`. Alternatively, you can use a third-party program
to intervene on your behalf, e.g. https://code.google.com/p/likwid/.
Please ask your system administrator how to correctly pin your processes.

GA specific issues
..................

When using GA, several problems can occur when trying to run jobs with a large
amount of memory per process. A few example error messages are given here with
their proposed solution.

::

  (rank:0 hostname:node1011 pid:65317):ARMCI DASSERT fail.
   src/devices/openib/openib.c:armci_pin_contig_hndl():1142
   cond:(memhdl->memhndl!=((void *)0))

The error output in the Molcas errfile (stderr) then says: ::

  Last System Error Message from Task 2:: Cannot allocate memory

Related messages that display a problem with :file:`armci_server_register_region`
instead of :file:`armci_pin_contig_hndl` can also occur, and point to similar problems.

This can have two causes:

* Some parameters of the Mellanox :file:`mlx4_core` kernel module were
  set too low, i.e., :file:`log_num_mtt` and :file:`log_mtts_per_seg`.
  These should be set according to the instructions on
  :file:`https://community.mellanox.com/docs/DOC-1120`. Values of 25 and 0
  respectively, or 24 and 1 should be fine.
* The "max locked memory" process limit was set too low. You can check
  this value by running :command:`ulimit -a` or :command:`ulimit -l`. Make
  sure you check this through an actual job! Easiest is to start an
  interactive job and then execute the command. The value should be set
  to unlimited, or at least to the amount of physical memory available.

::

  0: error ival=4 (rank:0 hostname:node1011 pid:19142):ARMCI DASSERT fail.
   src/devices/openib/openib.c:armci_call_data_server():2193
   cond:(pdscr->status==IBV_WC_SUCCESS)

This error is related to the value of the variable
:variable:`ARMCI_DEFAULT_SHMMAX`, try setting it at least to 2048. If this is
still too low, you should consider patching GA to allow higher values.
.. index::
   single: Error messages
   single: Error

Most frequent error messages found in |molcas|
==============================================

Due to the large number of systems where the |molcas| package is
executed and the large number of options included in each of
the programs it is not possible to compile here all the possible
sources of errors and error messages occurring in the calculations.
The |molcas| codes contain specific error message data basis where
the source of the error and the possible solution is suggested.
Unfortunately it is almost impossible to cover all the possibilities.
Here the user will find a compendium of the more usual errors
showing up in |molcas| and the corresponding error messages.

Many of the error messages the user is going to obtain are specific
for the operative system or architecture being used.
The most serious ones are in most of cases
related with compiler problems, operative system incompatibilities,
etc. Therefore the meaning of this errors must be checked in the proper
manuals or with the computer experts, and if they are characteristic
only of |molcas|, with |molcas| authors. The most common, however,
are simple mistakes related to lack of execution or reading
permission of the shell scripts, |molcas| executable modules, etc.

In the following the most usual errors found in |molcas| are listed.

.. index::
   single: Error; molcas not found

* The shell is unable to find the command :command:`molcas`.
  The message in this case is, for instance: ::

    molcas:  not found

  The solution is to add into the :variable:`PATH` the location of molcas driver script.

  .. index::
     single: Error; MOLCAS undefined

* If the |molcas| environment is not properly installed the
  first message showing up in the default error file is: ::

    ***
    *** Error: Could not find molcas driver shell
    *** Currently MOLCAS=

  Typing a command :command:`molcas`, you can check which molcas
  installation will be used. Check the value of the variable :variable:`MOLCAS`,
  and define it in order to point to the proper location of molcas installation.

  .. index::
     single: Error; ENV undefined

* Environment is not defined

  An attempt to run an executable without molcas driver scripts gives
  an error: ::

   Usage: molcas module_name input

* A call for a program can find problems like the three following ones: ::

    Program NNNN is not defined

  An error means that requested module is missing or the package is not installed.

  .. index::
     single: Error; Input file not found

* When the input file required for a |molcas| program is not
  available, the program will not start at all and no output
  will be printed, except in the default error file where the
  following error message will appear: ::

    Input file specified for run subcommand not found : seward

  .. index::
     single: Error; RUNFILE

* All the codes communicate via file :file:`RUNFILE`, if for a some reason
  the file is missing or corrupted, you will get an error ::

    ***    Record not found in runfile

  The simple solution --- restart seward to generate proper :file:`RUNFILE`.

  .. index::
     single: Error; ONEINT
     single: Error; ORDINT

* All the codes need integral files generated by :program:`SEWARD` in
  files :file:`ONEINT` and :file:`ORDINT`.
  Even the direct codes need the one-electron integrals stored
  in :file:`ONEINT`. The most common problem is then that a program
  fails to read one of this files because :program:`SEWARD` has not
  been executed or because the files are read in the wrong address.
  Some of the error messages found in those cases are listed here.

  In the :program:`SCF` module, the first message will appear when
  the one-electron integral file is missing and the second when
  the two-electron integral file is missing: ::

    Two-electron integral file was not found!
     Try keyword DIRECT in SEWARD.

  .. index::
     single: Error; Insufficient memory

* |molcas| use dynamical allocation of memory for temporary arrays.
  An error message "Insufficient memory" means that requested value
  is too small --- you have to specify :variable:`MOLCAS_MEM` variable and restart your
  calculation.

  .. index::
     single: Error; memory allocation

* if user ask to allocate (via :variable:`MOLCAS_MEM`) an amount of memory,
  which is large than possible on this computer, the following error message
  will be printed. ::

    MA error: MA_init: could not allocate 2097152152 bytes
    The initialization of the memory manager failed ( iRc=  1 ).

  .. index::
     single: Error; input error

* An improper input (e.g. the code expects to read more numbers, than
  user specified in input file) will terminate the code with errorcode 112.

  .. index::
     single: Error; Disk address problems
     single: Error; I/O problems

* Input/Output (I/O) problems are common, normally due to insufficient
  disk space to store the two-electron integral files or some of the
  intermediate files used by the programs. The error message would depend
  on the operative system used. An example for the :program:`SCF` is
  shown below: ::

    *******************************************************************************
    *******************************************************************************
    ***                                                                         ***
    ***                                                                         ***
    ***    Location: AixRd                                                      ***
    ***    File: ORDINT                                                         ***
    ***                                                                         ***
    ***                                                                         ***
    ***    Premature abort while reading buffer from disk:                      ***
    ***    Condition: rc != LenBuf                                              ***
    ***    Actual   :                0!=          262144                        ***
    ***                                                                         ***
    ***                                                                         ***
    *******************************************************************************
    *******************************************************************************

  The error indicates that the file is corrupted, or there is a bug in the
  code.

* Sometimes you might experience the following problem with :program:`GEO`/:program:`HYPER`
  run: ::

    Quaternion tested
    mat. size =     4x    1
     -0.500000000
      0.500000000
     -0.500000000
      0.000000000
    ###############################################################################
    ###############################################################################
    ###                                                                         ###
    ###                                                                         ###
    ###    Location: CheckQuater                                                ###
    ###                                                                         ###
    ###                                                                         ###
    ###                                                                         ###
    ###    Quaternion does not represent a rotation                             ###
    ###                                                                         ###
    ###                                                                         ###
    ###############################################################################
    ###############################################################################

  The error indicates that you need to rearrange the Cartesian coordinates
  (atoms) of one or another fragment.

.. .. _TUT\:sec\:flow_all:

   |molcas| Flowchart
   ------------------

   .. figure:: flow-all.*
      :name: fig:flow_all
      :width: 75%
      :align: center

      Program module dependencies flowchart for |molcas|. Shadow boxes represent optative modules to be installed independently.
.. index::
   single: Program; Seward
   single: Seward
   single: Integrals

.. _TUT\:sec\:seward:

:program:`SEWARD` --- An Integral Generation Program
====================================================

An *ab initio* calculation always requires integrals. In the
|molcas| suite of programs, this function is supplied by the :program:`SEWARD`
module. :program:`SEWARD` computes the one- and two-electron integrals for the
molecule and basis set specified in the input to the program :program:`GATEWAY`,
which should be run before :program:`SEWARD`. :program:`SEWARD` can also be used
to perform some property expectation calculations on the isolated molecule.
The module is also used as an input parser for the reaction field and
numerical quadrature parameters.

We commence our tutorial by calculating the integrals for a water molecule. The
input is given in :numref:`block:seward_input`. Each |molcas| module
identifies input from a file by the name of the module. In the case of
:program:`SEWARD`, the program starts with the label
``&SEWARD``, which is the first statement in the file shown below.

In normal cases no input is required for :program:`SEWARD`, so the following
input is optional. The first keyword used is :kword:`TITLe`. Only the first
line of the title is printed in the output. The first title line is also saved
in the integral file and appears in any subsequent programs that use the
integrals calculated by :program:`SEWARD`.

.. code-block:: none
   :caption: Sample input requesting the :program:`SEWARD` module
              to calculate the integrals for water in :math:`C_{2v}` symmetry.
   :name: block:seward_input

   &SEWARD
   Title
   Water - A Tutorial. The integrals of water are calculated using C2v symmetry

.. Sample input requesting the :program:`SEWARD` module
   to calculate the integrals for water in :math:`C_{2v}` symmetry.

In more complicated cases more input may be needed, to specify certain types of
integrals, that use of Cholesky decomposition techniques (:kword:`CHOLesky` keyword), etc. We refer to the
specific sections of the User's Guide for more information.
The output from a :program:`SEWARD` calculation is small and contains in principle
only a list of the different types of integrals that are computed.

The integrals produced by the :program:`SEWARD` module are stored in
two files in the working directory. They are ascribed the :program:`FORTRAN`
names :file:`ONEINT` and :file:`ORDINT` which are
automatically symbolically linked by the |molcas| script to the file
names :variable:`$Project`:file:`.OneInt` and
:variable:`$Project`:file:`.OrdInt`, respectively
or more specifically, in our case, :file:`water.OneInt` and
:file:`water.OrdInt`, respectively. The default name for each
symbolical name is contained in the corresponding program files of the
directory :file:`$MOLCAS/shell`.
The :file:`ONEINT` file contains the one-electron integrals.
The :file:`ORDINT` contains the ordered and packed two-electron integrals.
Both files are used by later |molcas| program modules.

.. :program:`SEWARD` --- Basic and Most Common Keywords
   ----------------------------------------------------

   .. class:: keywordlist

   :kword:`Cholesky`
     Use Cholesky decomposition

   :kword:`AMFI`
     Atomic mean-field integrals for relativistic calculations.
     Required for spin-coupling. Automatic for ANO-RCC basis sets
.. index::
   single: Program; NEVPT2
   single: NEVPT2

.. _TUT\:sec\:nevpt2:

:program:`NEVPT2` --- :math:`n`-Electron Valence State Second-Order Perturbation Theory
=======================================================================================

NEVPT2 is a second-order perturbation theory with a CAS (or a CAS-like) reference wavefunction originally developed by Angeli et al. :cite:`Angeli_JChemPhys_Introduction_2001,Angeli_ChemPhysLett_Nelectron_2001,Angeli_JChemPhys_nelectron_2002,Angeli_JChemPhys_quasidegenerate_2004` In contrast to CASPT2, it uses a Dyall Hamiltonian :cite:`Dyall_JChemPhys_choice_1995` as the zeroth-order Hamiltonian and is therefore inherently free of intruder states and parameters such as the IPEA shift. NEVPT2 exists in two formulations -- the strongly- (SC-) and the partially-contracted NEVPT2 (PC-NEVPT2), which differ in the basis of the first-order wavefunction expansion.

The implementation in the :program:`NEVPT2` program is based on the original NEVPT2 implementation by Angeli et al. :cite:`Angeli_JChemPhys_nelectron_2002,Angeli_JChemPhys_quasidegenerate_2004`, with the implementation of the QCMaquis DMRG reference wave function and Cholesky decomposition for the two-electron integrals :cite:`Freitag_JChemTheoryComput_Multireference_2017`. For excited states both single-state and multi-state calculations with the QD-NEVPT2 approach :cite:`Angeli_JChemPhys_quasidegenerate_2004` are supported.

.. _TUT\:sec\:nevpt2_run:

Running a NEVPT2 calculation
----------------------------

Prior to running a NEVPT2 calculation, one must obtain a reference wavefunction with the :program:`RASSCF` or :program:`DMRGSCF` program and perform an integral transformation with the :program:`MOTRA` program.

Currently, the implementation supports **only** QCMaquis DMRG reference wavefunctions (support for CASSCF reference wavefunctions will be added in the near future). It is nevertheless possible to run NEVPT2 with a CASSCF reference wavefunction by performing a DMRG-CI calculation with a sufficiently large :math:`m` value using the CASSCF converged orbitals. For example, an :math:`m` value of 2000 recovers the exact CASCI energy up to :math:`5\times{}10^{-8}` a.u. for active spaces of up to 14 orbitals.

Below we show an example workflow of a NEVPT2 calculation. The input below is a calculation of the lowest singlet state of methylene with an active space of 6 electrons in 6 orbitals:

::

  &GATEWAY
    coord
    3
    CH2 Triplet coordinates in Angstrom
    C      0.000000  0.000000  0.000000
    H      0.000000  0.000000  1.077500
    H      0.784304  0.000000 -0.738832
    basis=cc-pVTZ
    Group=Nosym
    RICD
    CDTH=1.0E-7
  &SEWARD
  &DMRGSCF
    ActiveSpaceOptimizer=QCMaquis
    DMRGSettings
      max_bond_dimension=128
      nsweeps=5
    EndDMRGSettings
    OOptimizationSettings
      Spin=3
      Inactive=1
      Ras2=6
      NActEl=6,0,0
      NEVPT2Prep
    EndOOptimizationSettings
  &MOTRA
    Frozen=0
    CTOnly
    Kpq
    HDF5
  &NEVPT2

First, one performs a DMRG-SCF calculation with the keyword :kword:`NEVPT2Prep`, which enables the evaluation of the four-particle reduced density matrices (4-RDMs) (and, in case of multiple states, also transition three-particle density matrices (t-3RDMs)) required by NEVPT2.

Second, one must perform an integral transformation with the :program:`MOTRA` module. If no Cholesky decomposition or RICD is used in the calculation, the only mandatory keyword is :kword:`HDF5`, which enables the write-out of the transformed integrals in the HDF5 format required by the :program:`NEVPT2` module. If Cholesky decomposition is used, one additionally needs to add the keys :kword:`CTOnly` and :kword:`Kpq`. Cholesky decomposition is strongly recommended, as the integral transformation without Cholesky is several times slower and not supported in parallel.

Note that running with the Cholesky decomposed integrals currently does not support symmetry, and the support for frozen orbitals in :program:`MOTRA` with Cholesky is untested, hence also the keyword :kword:`Frozen=0` is recommended.

Finally, one calls the NEVPT2 module with :kword:`\&NEVPT2`. It has no mandatory options, but options described in the Users Guide can be specified.

.. _TUT\:sec\:nevpt2_distrdm:

Distributed RDM evaluation
--------------------------

The computational cost of the RDM evaluation grows as :math:`N^8` with the number of active orbitals, therefore the RDM evaluation for active spaces larger than 11-12 orbitals becomes prohibitively expensive. Therefore :program:`NEVPT2` distribution provides an (experimental) python utility :file:`jobmanager.py` for distributed massively parallel 4-RDM calculations. With distributed 4-RDM calculations, active spaces of up to 22 orbitals can be employed in DMRG-NEVPT2 calculations without any approximation to the 4-RDM.

:file:`jobmanager.py` splits the evaluation of the 4-RDM :math:`G_{ijklmnop}` into four-index subblocks with indices :math:`i,j,k,l`. Due to permutational symmetry and the properties of the creation and annihilation operators, :math:`i \ge j \ge k \ge l` and no more than two indexes are equal (pairwise equality :math:`i=j` and :math:`k=l` is allowed). The script prepares input files and, if requested, submits a separate job for each subblock, and merges the subblocks into the full matrix once the jobs are finished. The script is expected to be run on a head node of a distrubuted computing system with a batch system: `LSF <https://www.ibm.com/support/knowledgecenter/en/SSETD4/product_welcome_platform_lsf.html>`_ has been tested, but any batch system which supports the `DRMAA <http://www.drmaa.org/>`_ library, such as Slurm or PBS, should work. If no support for DRMAA is found, the script still may be used to prepare the input files for each subblock, which then may be submitted manually. Note that the DMRG-SCF/NEVPT2 calculation need not be performed on the same system as the 4-RDM evaluation.

How to run NEVPT2 calculations with distributed 4-RDM evaluation
................................................................

Prerequisites:

- Python :math:`\ge` 2.7.9 (3.x is also supported)

- (optional) DRMAA library compatible with your batch submission system, (e.g. `LSF-DRMAA <https://github.com/IBMSpectrumComputing/lsf-drmaa>`_)

- `Python DRMAA <https://github.com/drmaa-python/drmaa-python>`_

- (optional) GNU Parallel

If your system administrator has not set up DRMAA and Python DRMAA, you might need to download and install these libraries yourself. After the installation, the environment variable :variable:`DRMAA_LIBRARY_PATH` must be set to the path to :file:`libdrmaa.so` and, if Python does not find the DRMAA Python binding, also :variable:`PYTHONPATH` to the path of the Python DRMAA library.

Workflow:

- Run DMRGSCF and MOTRA calculations as shown above, but **omit** calling the :program:`NEVPT2` program. The :kword:`NEVPT2Prep` keyword in the :program:`DMRGSCF` section creates QCMaquis input templates and the MPS checkpoint files required for a later 4-RDM and/or t-3RDM evaluation.

- Copy the :file:`$MOLCAS/Tools/distributed-4rdm/prepare_rdm_template.sh` script to the |openmolcas| scratch directory and run it. The script will create subdirectories named :file:`4rdm-scratch.<state>` for each state. If you wish to perform the 4-RDM evaluation on a different machine (e.g. a cluster), copy the subdirectory for each state to that machine. If you do not wish to evaluate the 4-RDM for all states, pass the list of desired states as parameters to the :file:`prepare_rdm_template.sh` script. For example, :file:`./prepare_rdm_template.sh 0 1 2` will create the scratch directories for states from 0 to 2 (note that QCMaquis starts counting states with 0).

- **If you have installed and working DRMAA setup:** For each state, change to the :file:`4rdm-scratch.<state>` subdirectory and run ::

     nohup jobmanager.py &

  (Login to the machine where you evaluate the 4-RDM before if you wish to run the evaluation on a different machine.) This will create a subdirectory for each batch job (corresponding for each four-index 4-RDM subblock) and submit the jobs. The script will stay in the background until all the jobs have completed.
  The script also accepts the following job-specific options:

  - :command:`-t HH:MM:SS`: set the maximum walltime per job. Default is 24h.
  - :command:`-n NCPU`: run each job in an SMP parallelised fashion and set the number of CPU cores per job. Default is 1 core. For large active spaces, it is recommended to use several cores (e.g. 16 or 24, or as much as is available on a single node on your cluster).

- If you **do not** have DRMAA installed and working, run the :file:`jobmanager.py` script with the :command:`-n` option: ::

    jobmanager.py -n

  This will create subfolders for each 4-RDM block and prepare all the necessary input scripts, but will not submit them to the batch system. Now you may manually submit the scripts from the subfolders :file:`parts/part-*`.

- If you ran the distributed 4-RDM calculation on a different machine, copy the :file:`4rdm-scratch.<state>` back to |openmolcas| :file:`$WorkDir`.

- Create an input file with the input to the :program:`NEVPT2` program and run it. The keyword :kword:`DISTributedRDM` followed by the path to :file:`4rdm-scratch.<state>` folders (in our case, :file:`$WorkDir`) is **mandatory**.

Troubleshooting
...............

The :file:`jobmanager.py` script is experimental, and also batch jobs in queuing systems are prone to crash, therefore we provide a mechanism to identify and restart the crashed batch jobs. The NEVPT2 program will check if the 4-RDM calculation has been finished correctly. If some 4-RDM values are missing, the NEVPT2 program will stop with an error. In this case several options are available:

- **If DRMAA has been used:** if the :file:`jobmanager.py` finishes without errors, it will produce two files, :file:`successlist` and :file:`faillist` with the list of successful and failed batch jobs, respectively. In this case, the failed jobs may be restarted using the restart mode of :file:`jobmanager.py`, which is invoked with ::

    nohup jobmanager.py -r successlist faillist &

  If the :file:`jobmanager.py` finishes with an error, the :file:`successlist` and :file:`faillist` will be either nonexistent or empty. Note that this does NOT necessarily mean that the jobs have failed: in our tests, certain configurations of the queuing system may lead to the crash of the :file:`jobmanager.py` script after the successful completion of the jobs.

- **If DRMAA has not been used and the script was run with the -n switch**: in this case the user is advised to check manually the subfolders for each 4-RDM subblock for the existence of :file:`$Project.results_state.X.h5` files. The files should exist and the command

  .. compound::

     ::

       h5dump $Project.results_$state.X.h5 | grep fourpt

     should not yield an empty result -- otherwise the corresponding calculation should be rerun.

- Finally, if :program:`NEVPT2` is started with the :kword:`DISTributedRDM` keyword, it will check the number of evaluated 4-RDM elements. If the number of evaluated elements is different from its expected value, the program will exit with an error.

Transition 3-RDM distributed calculations
.........................................

:file:`jobmanager.py` also supports distributed calculations of t-3RDMs (required for multi-state QD-NEVPT2). The split evaluation is similar to that of the 4-RDMs, and the workflow above can be followed with the following differences:

- The t-3RDM evaluation requires two states instead of one. Run the :file:`prepare_rdm_template.sh` script with the :command:`-3` parameter.

- Launch the :file:`jobmanager.py` script with the :command:`-3` parameter.
.. index::
   single: Program; MBPT2
   single: MP2

.. _TUT\:sec\:mbpt2:

:program:`MBPT2` --- A Second-Order Many-Body PT RHF Program
============================================================

The :program:`MBPT2` program performs second-order Many Body Perturbation
Theory calculations based on a RHF-type of wave function (MP2 method).
The calculation is to some extent defined by the SCF
calculation which must be performed before running the :program:`MBPT2`
program. Therefore, there is no difficulty related to the input file
unless an analysis of the correlation energies of specific electron
pairs or contribution from external orbitals wants to be performed.
In this case keywords :kword:`SFROzen` and :kword:`SDELeted` have to
be used as described in
:numref:`UG:sec:mbpt2`
of the user's guide.


To run the program the :file:`ORDINT` integral file(s)
generated by the :program:`SEWARD` program and the :file:`RUNFILE` file generated
by the :program:`SCF` program are needed. The program can be otherwise run in a
direct manner. Therefore the :program:`SEWARD` program can be run
with the option :kword:`DIREct` included in its input. Only the :file:`ONEINT`
will then be generated and used by the :program:`SCF` module.
The input file used to run an :program:`MBPT2` calculation on the ground state
of the water molecule is displayed in :numref:`block:mbpt2_input`. For large
molecules it is also possible to use the Cholesky decomposition technique to
speed up the calculations. This will be described in another section of the
tutorials.

.. code-block:: none
   :caption: Sample input requested by the :program:`MBPT2` module to
             calculate the MP2 energy for the ground state of the water in :math:`C_{2v}` symmetry.
   :name: block:mbpt2_input

   &MBPT2
   Title= MP2 of ground state of C2v Water
   Frozen= 1 0 0 0

The output of :program:`MBPT2` is self-explanatory.

.. :program:`MBPT2` --- Basic and Most Common Keywords
   ---------------------------------------------------

   .. class:: keywordlist

   :kword:`FROZEN`
     By symmetry: non-correlated orbitals (default: core)
Short Guide to |molcas|
=======================

.. toctree::
   :maxdepth: 2

   nutshell
   pbtutorials
   tutorials
.. index::
   single: Program; RASSCF
   single: RASSCF
   single: CASSCF
   see: CASSCF; RASSCF

.. _TUT\:sec\:rasscf:

:program:`RASSCF` --- A Multi Configurational Self-Consistent Field Program
===========================================================================

One of the central codes in |molcas| is the :program:`RASSCF` program, which
performs multiconfigurational SCF calculations. Both Complete Active Space
(CASSCF) and Restricted Active Space (RASSCF) SCF calculations can be performed
with the :program:`RASSCF` program module :cite:`Roos:92`.
An open shell Hartree--Fock calculation is not possible with the :program:`SCF`
but it can be performed using the :program:`RASSCF` module. An input listing for
a CASSCF calculation of water appears in :numref:`block:rasscf_input`.
:program:`RASSCF` requires orbital information of the system which can be
obtained in two ways. The :kword:`LUMOrb` indicates that the orbitals should be
taken from a user defined orbital file, which is copied to the internal file
INPORB. If this keyword is not given, the program will look for orbitals on the
runfile in the preference order: :file:`RASORB`, :file:`SCFORB` and
:file:`GUESSORB`

.. code-block:: none
   :caption: Sample input requesting the :program:`RASSCF` module to calculate the
             eight-electrons-in-six-orbitals CASSCF energy of the second excited triplet
             state in the second symmetry group of a water molecule in :math:`C_{2v}` symmetry.
   :name: block:rasscf_input

   &RASSCF
   Title= The CASSCF energy of water is calculated using C2v symmetry. 2 3B2 state.
   nActEl= 8 0 0
   Inactive= 1 0 0 0; Ras2= 3 2 0 1
   Symmetry= 2; Spin= 3
   CIRoot= 1 2; 2
   LumOrb

The :kword:`TITLe` performs the same function as in the previous |molcas|
modules. The keyword :kword:`INACtive` specifies the number of doubly occupied
orbitals in each symmetry that will not be included in the electron excitations
and thus remain doubly occupied throughout the calculation. A diagram of the
complete orbital space available in the :program:`RASSCF` module is given in
:numref:`fig:rasscf_space`.

In our calculation, we have placed the oxygen 1s orbital in the inactive
space using the :kword:`INACtive` keyword. The keyword :kword:`FROZen` can be
used, for example, on heavy atoms to reduce the Basis Set
Superposition Error (BSSE). The corresponding orbitals will then not be
optimized. The :kword:`RAS2` keyword specifies the number of orbitals in each
symmetry to be included in the electron excitations with all possible
occupations allowable. Because the :kword:`RAS1` and :kword:`RAS3` spaces are
zero (not specified in the input in :numref:`block:rasscf_input`) the
:program:`RASSCF` calculation will produce a CASSCF wave function. The
:kword:`RAS2` space is chosen to use all the orbitals available in each
symmetry (except the oxygen 1s orbital). The keyword :kword:`NACTel`
specifies the number of active electrons (8), maximum number of holes in the
Ras1 space (0) and the maximum number of electrons in the Ras3 space (0).
Using the keywords :kword:`RAS1` and/or :kword:`RAS3` to specify orbitals and
specifying none zero numbers of holes/electrons will produce a RASSCF wave
function. We are, therefore, performing an 8in6 CASSCF calculation of
water.

.. table:: Examples of types of wave functions obtainable using the RAS1 and RAS3 spaces in the :program:`RASSCF` module.
   :name: tab:RAS1_3

   ======================== ========================= ========================= =========================
   Description              Number of holes           :kword:`RAS2`             Number of electrons
                            in :kword:`RAS1` orbitals orbitals                  in :kword:`RAS3` orbitals
   ======================== ========================= ========================= =========================
   SD-CI                    2                         0                         2
   SDT-CI                   3                         0                         3
   SDTQ-CI                  4                         0                         4
   Multi Reference SD-CI    2                         :math:`n`                 2
   Multi Reference SD(T)-CI 3                         :math:`n`                 2
   ======================== ========================= ========================= =========================

.. index::
   single: Active space
   single: CI

There are a number of wave function types that can be performed by manipulating
the :kword:`RAS1` and :kword:`RAS3` spaces. :numref:`tab:RAS1_3` lists
a number of types obtainable. The first three are Configuration
Interaction (CI) wave functions of increasing magnitude culminating with a
Single, Double, Triples and Quadruples (SDTQ) CI. These can become
multi reference if the number of :kword:`RAS2` orbitals is non-zero.
The last type provides some inclusion of the triples excitation by
allowing three holes in the :kword:`RAS1` orbitals but save
computation cost by only allowing double excitations in the :kword:`RAS3`
orbitals.

.. float::
   :type: figure
   :caption: :program:`RASSCF` orbital space including keywords and electron occupancy ranges.
   :name: fig:rasscf_space

   .. _tab\:rasscf_space_a:

   ==== =================================
   ---  :kword:`DELETED`
   0    Virtual
   0--2 :kword:`RAS3` orbitals containing
        a max. number of electrons
   0--2 :kword:`RAS2` orbitals of
        arbitrary occupation
   0--2 :kword:`RAS1` orbitals containing
        a max. number of holes
   2    :kword:`INACTIVE`
   2    :kword:`FROZEN`
   ==== =================================

.. index::
   single: RASSCF; Symmetry
   single: RASSCF; Spin
   single: RASSCF; CIroot
   single: RASSCF; Level-shift
   single: RASSCF; Iterations

The symmetry of the wave function is specified using the
:kword:`SYMMetry` keyword. It specifies the number of the symmetry
subgroup in the calculation. We have chosen the second symmetry
species, :math:`b_2`, for this calculation. We have also chosen the triplet
state using the keyword :kword:`SPIN`. The keyword :kword:`CIROot` has been
used to instruct :program:`RASSCF` to find the second excited state in the
given symmetry and spin. This is achieved by specifying the number of roots,
1, the dimension of the small CI matrix which must be as large as the
highest required root and the number of the required second root.
Only for averaged calculations :kword:`CIROot` needs an additional line
containing the weight of the selected roots (unless equal weights are used for
all states).

As an alternative to giving inactive and active orbital input we can use the
type index input on the :file:`INPORB` and indicate there which type the
different orbitals should belong to: frozen (f), inactive (i), RAS1 (1), RAS2
(2), RAS3 (3), secondary (s), or deleted (d). This approach is very useful when the input
orbitals have been run through :program:`LUSCUS`, which is used to select the
different subspaces. :program:`LUSCUS` will relabel to orbitals according to the
users instructions and the corresponding orbital file, :file:`GvOrb` can be
linked as the :file:`INPORB` in the :program:`RASSCF` program without any
further input.

.. index::
   single: Convergence problems; In RASSCF

A level shift was included using the :kword:`LEVShift` keyword
to improve convergence of the calculation. In this case, the calculation
does not converge without the use of the level shift. It is advisable to
perform new calculations with a non-zero :kword:`LEVShift` value (the default
value is 0.5). Another possibility is to increase the maximum number of
iterations for the macro and the super-CI Davidson procedures
from the default values (200,100) using the keyword :kword:`ITERations`.

Sometimes convergence problems might appear when the wave function is
close to fulfill all the convergence criteria. An infrequent but possible
divergence might appear in a calculation starting from orbitals of an already
converged wave function, or in cases where the convergence thresholds
have been decreased below the default values.
Option :kword:`TIGHt` may be useful in those cases. It contains the
thresholds criteria for the Davidson diagonalization procedure. In situations
such as those described above it is recommended to decrease the first
parameter of :kword:`TIGHt` to a value lower than the default, for instance
1.0d-06.

.. index::
   single: RASSCF; Output
   single: RASSCF; CI coefficients
   single: RASSCF; Configurations
   single: RASSCF; Natural occupation

:program:`RASSCF` Output
------------------------

The :program:`RASSCF` section of the |molcas| output contains similar
information to the :program:`SCF`
output. Naturally, the fact that we have requested an excited state is
indicated in the output. In fact, both the lowest triplet state and the first
excited state or second root are documented including energies.
For both of these states the CI
configurations with a coefficient greater than 0.05 are printed along
with the partial electron distribution in the active space.
:numref:`block:RASSCF_CI` shows the relevant output for the second
root calculated. There are three configurations with a CI-coefficient
larger than 0.05 and two with very much larger values. The number of the
configuration is given in the first column and the CI-coefficient and
weight are given in the last two columns. The electron occupation of the
orbitals of the first symmetry for each configuration is given under the
"``111``" using "``2``" for a fully occupied orbital and "``u``"
for a singly occupied orbital containing an electron with an up spin.
The down spin electrons are represented with a "``d``". The occupation
numbers of the active space for each symmetry is given below the contributing
configurations. It is important to remember that the active orbitals are
not ordered by any type of criterion within the active space.

.. code-block:: none
   :caption: :program:`RASSCF` portion of output relating to CI configurations and electron
             occupation of natural orbitals.
   :name: block:RASSCF_CI

   printout of CI-coefficients larger than   .05 for root   2
   energy=    -75.443990
   conf/sym  111 22 4     Coeff  Weight
          3  22u u0 2    .64031  .40999
          4  22u 0u 2    .07674  .00589
         13  2u0 2u 2   -.75133  .56450
         14  2u0 u2 2    .06193  .00384
         19  udu 2u 2    .06489  .00421

   Natural orbitals and occupation numbers for root  2
   sym 1:   1.986957   1.416217    .437262
   sym 2:   1.567238    .594658
   sym 4:   1.997668

The molecular orbitals are displayed in a similar fashion to the
:program:`SCF` section of the output except that the energies of the
active orbitals are not defined and therefore are displayed as zero and
the electron occupancies are those calculated by the :program:`RASSCF`
module. In a state average calculation (more than one root calculated),
the MOs will be the natural orbitals corresponding to the state
averaged density matrix (called pseudo-natural orbitals) and the occupation
numbers will be the corresponding eigenvalues. Natural orbital occupation
numbers for each state are printed as shown in :numref:`block:RASSCF_CI`, but
the MOs specific to a given state are not shown in the output. They are,
however, available in the :file:`JOBIPH` file. A number of molecular
properties are also computed for the requested electronic state in a similar
fashion to the :program:`SCF` module.

.. index::
   single: Program; RASREAD (obsolete)
   single: RASREAD (obsolete)
   single: Files; JOBIPH
   single: Files; RASORB
   single: Convergence problems; In RASSCF

.. _TUT\:sec\:rasread:

Storing and Reading :program:`RASSCF` Orbitals and Wave Functions
-----------------------------------------------------------------

Part of the information stored in the :program:`RASSCF` output file, :file:`JOBIPH`,
for instance the molecular orbitals and occupation numbers can be also found
in an editable file named :file:`RASORB`, which is automatically generated by
:program:`RASSCF`. In case more than one root is used the natural orbitals are
also stored in files :file:`RASORB.1`, :file:`RASORB.2`, etc, up to ten. In such
cases the file :file:`RASORB` contains the averaged orbitals. If more roots
are used the files can be generated using the :kword:`OUTOrbitals` keyword.
The type of orbital produced can be either :kword:`AVERaged`,
:kword:`NATUral`, :kword:`CANOnical` or :kword:`SPIN` (keywords) orbitals.
The :kword:`OUTOrbitals` keyword, combined with the :kword:`ORBOnly` keyword,
can be used to read the :file:`JOBIPH` file and produce
an orbital file, :file:`RASORB`, which can be read by a subsequent
:program:`RASSCF` calculation using the same input section.
The formatted :file:`RASORB` file is useful to operate on the orbitals in order
to obtain appropriate trial orbitals for a subsequent :program:`RASSCF`
calculation. In particular the type index can be changed
directly in the file if the :program:`RASSCF` program has converged to a solution
with wrong orbitals in the active space. The :program:`RASSCF` program
will, however, automatically place the orbital files from the calculation in the
user's home directory under the name :file:`$Project.RasOrb`, etc. In
calculations with spin different from zero the program will also produce the
spin orbital files :file:`$Project.SpdOrb1`, etc for each state. These orbitals
can be used by the program :program:`LUSCUS` to produce spin densities.

:program:`RASSCF` --- Basic and Most Common Keywords
----------------------------------------------------

.. class:: keywordlist

:kword:`SYMMetry`
  Symmetry of the wave function (according to :program:`GATEWAY`)
  (1 to 8)

:kword:`SPIN`
  Spin multiplicity

:kword:`CHARGE`
  Molecular charge

:kword:`NACTel`
  Three numbers: Total number of active electrons, holes in Ras1, particles in Ras3

:kword:`INACtive`
  By symmetry: doubly occupied orbitals

:kword:`RAS1`
  By symmetry: Orbitals in space Ras1 (RASSCF)

:kword:`RAS2`
  By symmetry: Orbitals in space Ras1 (CASSCF and RASSCF)

:kword:`RAS3`
  By symmetry: Orbitals in space Ras1 (RASSCF)

:kword:`CIROot`
  Three numbers: number of CI roots, dimension of the CI matrix, relative weights
  (typically 1)

:kword:`LUMORB`/:kword:`FILEORB`
  use definition of active space from Orbital file
|molcas| Flowchart
==================

.. figure:: flow-all.*
   :name: flow:flow_all
   :width: 75%
   :align: center

   Flowchart for Module Dependencies in |molcas|
.. _TUT\:sec\:tools:

Tools for selection of the active space
=======================================

Selecting an active space is sometimes easy. For a small molecule,
an active space for the ground and the lowest valence excited states
is usually the valence orbitals, i.e. orbitals composed of atomic
orbitals belonging to the usual "valence shells" (there are
some exceptions to this rule). Problems arise for medium or large
molecules, for higher excited states, and for molecules including
transition, lanthanide or actinide elements. A good wish list
of orbitals will give a CASSCF/CASPT2 calculation that demand
unrealistically large computer resources and time.
Compromises must be made. Any smaller selection of active orbitals
can in general affect your results, and the selection should be
based on the specific calculations: see :numref:`TUT:sec:hints` for
advise.

The following three tools may be help in the process:

.. class:: programlist

:program:`localisation`
  is a program that can take a (subrange of) orbitals
  from an orbital file, and produce a new orbital file where these orbitals
  have been transformed to become localized, while spanning the same space
  as the original ones.

:program:`expbas`
  can take an orbital file using a smaller basis set, and
  "expand" it into a new orbital file using a larger basis.

:program:`LUSCUS`
  (is of course also described elsewhere) is the orbital viewer.

It is of course best to have a good perception of the electronic structure
of the molecule, including all states of interest for the calculation.
If it is a larger system, where lots of ligands can be assumed not to
partake in non-dynamic correlation, it is a good idea to run some simple
exploratory calculations with a much smaller model system.
Check the literature for calculations on similar systems or model systems.

First of all, you need to know how many orbitals (in each symmetry) that
should be active. Their precise identity is also good to know, in order
to have a good set of starting orbitals, but we come to that later.
**Necessary** active orbitals are: Any shells that may be open in any of the
states or structures studied. Breaking a bond generally produces a
correlated bond orbital and a correlating antibonding orbital, that must
both be active (Since it is the **number** of orbitals we are dealing
with as yet, you may as well think of the two radical orbitals that are
produced by completely breaking the bond).
You probably want to include one orbital for each aromatic carbon.
**Valuable correlated** active orbitals are: Oxygen lone pair, :math:`\ce{CC}`
:math:`\pi` bonds. **Valuable correlating** active orbitals are: the
antibonding :math:`\pi^*` :math:`\ce{CC}` orbitals, and one additional set of
correlating d orbitals for most transition elements (sometimes
called the "double d-shell effect").

The valuable correlated orbitals can be used as Ras-1 orbitals, and
correlating ones can be used as Ras-3 orbitals, if the active space
becomes too large for a casscf calculation.

Assuming we can decide on the number of active orbitals, the next task
is to prepare starting orbitals that enables CASSCF to converge, by
energy optimization, to the actual starting orbitals for your calculation.
Use a very small basis set to begin with: This will usually be one of the
minimal bases, e.g. ANO-S-MB. This is not just to save time: the small
basis and the large energy spacings make it much easier to get well-defined
correlating orbitals.

Performing the actual casscf (or rasscf) calculation may give you the
active space you want: Viewing the orbitals by :program:`LUSCUS` may confirm this, but
very often the orbitals are too mixed up (compared to one's mental
picture of what constitutes the best orbitals).
Using localisation program solves this problem. In order to localise
without mixing up orbitals from different subspaces may require to
produce the new orbital file through several runs of the program;
however, for the present perpose, it may be best not to have so
very strict restrictions, for example: Allow mixing among a few
high inactive and the most occupied orbitals; and also among the
weakly occupied and some virtual orbitals.

Running the localisation program, and viewing the localised orbitals,
is a great help since directly in :program:`LUSCUS` one can redefine orbitals as
being inactive, or ras3 , or whatever, to produce a new orbital file.
The resulting annotated localised orbitals can be used in a new run.

Once a plausible active space has been found, use the expbas tool to
obtain starting orbitals using, e.g. ANO-VDZP basis, or whatever is
to be used in the bulk of the production run.

It is also a good idea to, at this point, "waste" a few resources on
a single-point calculation for a few more states than you are really
interested in, and maybe look at properties, etc. There may be
experimental spectra to compare with.

And please have a look at :numref:`TUT:sec:hints`.
Quickstart Guide for |molcas|
=============================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Introduction
------------

Running |molcas| requires a small number of operations.
This section of the manual, entitled "Quickstart Guide for |molcas|"
is aimed at those users who want to immediately
run a simple |molcas| calculation in order to become familiar with the program.
Basic hints are included which set the proper environment, build simple input files, run a calculation, and
subsequently extract information from the resulting output.

.. index::
   single: MOLCAS Environment

|molcas| Environment Setup
--------------------------

The environment variable (:variable:`MOLCAS`) and |molcas| driver (:file:`molcas`) must be defined in order to run |molcas|.
The :variable:`MOLCAS` environment variable points to the root directory of the |molcas| installation and
can be defined by the bash shell command ::

  export MOLCAS=/home/molcas/molcas.version

The location of the |molcas| driver is defined at installation time and is
typically located in :file:`/usr/local/bin` or :file:`$HOME/bin`.
Check to ensure that this directory is included in your path. Otherwise, the path can be extended
by the following command: ::

  export PATH=$PATH:$HOME/bin

In addition, the variable :variable:`MOLCAS_NPROCS` is needed to run |molcas| in parallel. This specifies the number of MPI processes that will be used.

It may be also convenient to define environment variables such as :variable:`WorkDir` which points to a directory for intermediate
files and :variable:`Project` to define the name of a project: ::

  export Project=MyMolecule

|molcas| will provide default values if they are not explicitly defined. For a discussion of other |molcas|
environment variables, please see :numref:`TUT:sec:environment`. All environment variables can
either be defined explicitly or entered in a shell script which can be subsequently executed.

.. index::
   single: Customization

Customization of |molcas| Execution
-----------------------------------

|molcas| has flexible control of organizing filenames and directories used during a calculation.
The default values used for customization can be altered either by shell variables or
a resource file :file:`molcasrc` which is more preferable. A command :command:`molcas setuprc`
provides guided help if to create such file.

The terminology used in this chapter:

* ``LOG``: the output and error files produced by |molcas|.

* ``ProjectName``: the Project name used for file naming.

* ``RUNFILE``: a file used in a calculation will be named as ``ProjectName``.Runfile,

* ``WorkDirName``: the WorkDir name used as the directory for temporary/binary files produced by |molcas|.

* ``Scratch``: the scratch disk area which provides a path to a parent directory for ``WorkDirName``\s.

  The :file:`WorkDir` variable used in the |molcas| manual is constructed as ``Scratch``/``WorkDirName``,

* ``CurrDir``: the submit directory where the |molcas| command was issued.

  Note, that in this tutorial, it is assumed that the input file is located in ``CurrDir``,

* ``OutputDir``: the output directory which is used for storage of extra output files, such as Orbital files and molden files.

It is quite important to understand, that if a user performs two consecutive runs of molcas, using the same
scratch area (:variable:`WorkDir`) and project name, |molcas| will try to reuse intermediate data, e.g.
integrals and orbitals, in order to make a restart of a calculation. This can save time, but can also be
can be dangerous if two consecutive calculations are not compatible.

Assuming that :file:`molcasrc` does not exist, and no environment is set, the command :command:`molcas inputfile`
will use the following defaults:

* ``LOG`` is printed to the screen,
* ``OutputDir`` and ``CurrDir`` are defined to be the same directory,
* ``ProjectName`` is s taken as the name of :file:`inputfile` by removing the suffix (before the last . (dot) character),
* ``Scratch`` is defined as :file:`/tmp/`,
* and ``WorkDirName`` is defined from the ``ProjectName`` plus a random suffix.

.. compound::

  For example, when a user issues the following commands: ::

    cd /home/joe/projects/water
    vi H2O.DFT.input
    molcas H2O.DFT.input

  the following files will be generated: ::

    /home/joe/projects/water/H2O.DFT.ScfOrb
    /home/joe/projects/water/H2O.DFT.scf.molden
    ...
    /tmp/H2O.DFT.15014/H2O.DFT.RunFile
    ...

If a flag :command:`-f` is used in a |molcas| command, ``LOG`` files will be stored in the ``CurrDir`` directory with a name
``ProjectName``.log and ``ProjectName``.err.

.. compound::

  ``ProjectName`` can either be set in a shell script running |molcas| or included directly into the |molcas| command: ::

    molcas Project=water H2O.DFT.input

  will change the default value for ``ProjectName`` to water.

If the :variable:`MOLCAS_WORKDIR` environment variable is set either as part of |molcas| command or is included in the :file:`molcasrc` file,
the name of WorkDir will NOT be random, but determined by the ``ProjectName``.

.. compound::

  Example: ::

    cd /home/joe/projects/water
    vi H2O.DFT.input
    molcas MOLCAS_WORKDIR=/tmp Project=water -f H2O.DFT.input

  will generate the following files: ::

    /home/joe/projects/water/water.log
    /home/joe/projects/water/water.ScfOrb
    ...
    /tmp/water/water.RunFile
    ...

For More options to control the behavior of |molcas|, run the command :command:`molcas setuprc` script.
The file :file:`molcasrc` can be used to set global preferences for the |molcas| package and/or to set user preferences.
The :file:`setuprc` script creates a :file:`molcasrc` file (:file:`HOME/.Molcas`) in a users home directory.

The following :file:`molcasrc` file for uses the :file:`/scratch` area as a parent for WorkDirs and
Project name generated for the the name of the input file,
then removes WorkDir before a calculation followed by subsequent
retains of this file when the calculation finished: ::

  # Version 1.0
  MOLCAS_MEM=256
  MOLCAS_WORKDIR=/scratch
  MOLCAS_NEW_WORKDIR=YES
  MOLCAS_KEEP_WORKDIR=YES
  MOLCAS_PROJECT=NAME

Once the :file:`molcasrc` is created, it is usually not necessary to use shell script or environment variables to run |molcas|.

|molcas| Command-Line Help System
---------------------------------

Just by typing :command:`molcas help` you get access to |molcas| Command-Line
Help System. There are different options:

* :command:`molcas help` produces a list of available programs and utilities.
* :command:`molcas help module` yields the list of keywords of the program :program:`module`.
* :command:`molcas help module keyword` offers the detailed description of the keyword.
* :command:`molcas help -t text` displays a list of keywords that contain the text word
  in their description.

.. index::
   single: EMIL commands
   single: MOLCAS input

Input Structure and EMIL Commands
---------------------------------

|molcas| has a modular program structure. The easiest way to run calculations
is to prepare an input file in which the different programs are executed
sequentially when the the module name (&module) is provided. The
keywords of module name then follow, with each entry on a separate line or
several entries on one line, separated by ;.
In addition to specific program module keywords, |molcas|
incorporates certain commands (See section on EMIL Commands.) that allow
operations such as looping over the modules, allowing partial execution,
changing variables, and substituting certain Unix commands.

Basic Examples
--------------

Simple Calculation on Water
...........................

.. compound::

  Start by preparing a file containing the cartesian coordinates of a water molecule. ::

    3
    Angstrom
     O       0.000000  0.000000  0.000000
     H       0.758602  0.000000  0.504284
     H       0.758602  0.000000 -0.504284

  which is given the name :file:`water.xyz`. In the same directory we prepare
  the input for the |molcas| run. We can name it :file:`water.input`.

In addition to using an editor to insert atomic coordinates into a file, a coordinate file can be obtained by using
a graphical interface program, for example, the :program:`LUSCUS` module as shown later in this guide. ::

  &GATEWAY
   coord=water.xyz
   basis=sto-3g
  &SEWARD
  &SCF

The :program:`GATEWAY` program module combines the molecular geometric of water
(In this case, from the external file, :file:`water.xyz`) and the basis set definition.
The :program:`SEWARD` program module then computes the integrals, and :program:`SCF` program modules
completer the calculation by computing the Hartree--Fock wave function.

.. For convenience just define: ::

    export Project=water

To run the calculation, the following command is used: ::

  molcas water.input -f

The file :file:`water.log` now contains output from the calculation, and the :file:`water.err`
includes any error messages. In the same directory, other files, including
:file:`water.scf.molden` or :file:`water.lus` (if the keyword :kword:`grid_it` is added at end of input file)
that help to analyze the results graphically with the external graphical viewer :program:`LUSCUS`
or :program:`Molden` program. Examples of their use are demonstrated below.

In the case of an open-shell calculation (UHF or UDFT), the :program:`SCF` program is again used.
Below, two examples are shown:

#. A UDFT calculation yielding an approximate doublet by setting the charge to +1, even if they are not pure spin functions: ::

     &GATEWAY
      coord=water.xyz
      basis=sto-3g
     &SEWARD
     &SCF
      charge=+1
      uhf; ksdft=b3lyp

#. A triplet state (using keyword :kword:`ZSPIn` to specify that there are two more :math:`\alpha` than :math:`\beta` electrons) states: ::

     &GATEWAY
      coord=water.xyz
      basis=sto-3g
     &SEWARD
     &SCF
      zspin=2
      uhf; ksdft=b3lyp

Geometry Optimization
.....................

In the next example, a DFT/B3LYP geometry optimization is performed on the
ground state of the water molecule. Notice that, after ``&gateway`` has defined
the coordinates and basis set definition, the EMIL commands :command:`>>> Do while`
and :command:`>>> EndDo` are employed to form a loop with the
:program:`seward`, :program:`SLAPAF`, and :program:`SCF` programs until convergence of geometry optimization is reached.
Program :program:`seward` computes the integrals in atomic basis, :program:`SCF` computes the DFT energy, and the program
:program:`SLAPAF` controls the geometry optimization and uses the module :program:`ALASKA` to compute the gradients
of the energy with respect to the degrees of freedom. :program:`SLAPAF` generates
the new geometry to continue the iterative structure optimization process and
checks to determine convergence parameters are satisfied notifying |molcas| and stopping the loop. ::

  &GATEWAY
   coord=water.xyz
   basis=ANO-S-MB
  >>> Do While
    &SEWARD
    &SCF
      ksdft=b3lyp
    &SLAPAF
  >>> EndDo

The above example illustrates the default situation of optimizing to a minimum geometry without
any further constraint. If other options are required such as determining a transition
state, obtaining a states crossing, or imposing a geometry constraint, specific input
should be added to program :program:`SLAPAF`.

.. figure:: acrolein.*
   :name: fig:ac1
   :align: center

   The acrolein molecule.

One of the most powerful aspects of |molcas| is the possibility of computing
excited states with multiconfigurational approaches. The next example demonstrates
a calculation of the five lowest singlet roots in a State-Average (SA) CASSCF calculation
using the :program:`RASSCF` program. It also illustrates the addition of the :program:`CASPT2` program
to determine dynamical correlation which provides accurate electronic energies at the CASPT2 level. The resulting
wave functions are used in the :program:`RASSI` module to calculate state-interaction properties such as oscillator strengths and other properties. ::

  &gateway
  Coord
   8
  Acrolein coordinates in Angstrom
   O     -1.808864   -0.137998    0.000000
   C      1.769114    0.136549    0.000000
   C      0.588145   -0.434423    0.000000
   C     -0.695203    0.361447    0.000000
   H     -0.548852    1.455362    0.000000
   H      0.477859   -1.512556    0.000000
   H      2.688665   -0.434186    0.000000
   H      1.880903    1.213924    0.000000
  Basis=ANO-S-MB
  Group=Nosym
  &SEWARD
  &RASSCF
    nactel  = 6 0 0
    inactive= 12
    ras2    = 5
    ciroot  = 5 5 1
  &CASPT2
    multistate=5 1 2 3 4 5
  &RASSI
    Nr of Job=1 5; 1 2 3 4 5
    EJob

Notice that the :kword:`Group` with the option :kword:`Nosym` has been used
to prevent :program:`GATEWAY` from identifying the symmetry of the molecule
(:math:`C_s` in this case). Otherwise, the input of the :program:`RASSCF` program
will have to change to incorporate the classification of the active space
into the corresponding symmetry species. Working with symmetry will be skipped at
this stage, although its use is very convenient in many cases.
A good strategy is to run only :program:`GATEWAY` and let the program guide you.

The :program:`RASSCF` input describes the active space employed, composed by
six active electrons distributed in five active orbitals. By indicating
twelve inactive orbitals (always doubly occupied), information
about the total number of electrons and the distribution of the orbitals is then complete.
Five roots will be obtained in the SA-CASSCF procedurei, and all them will
be computed at the CASPT2 level to obtain the transition energies at the higher
level of theory. Further, the :program:`RASSI` will compute the transition properties,
in particular, transition dipole moments and oscillator strengths.

GASSCF method
.............

In certain cases it is useful/necessary to enforce restrictions on electronic
excitations within the active space beyond the ones accessible by RASSCF.
These restrictions are meant to remove configurations that contribute only
marginally to the total wave function.
In |molcas| this is obtained by the GASSCF approach :cite:`gas2011`.
In GASSCF an arbitrary number of active spaces may be chosen.
All intra-space excitations are allowed (Full-CI in subspaces).
Constraints are imposed by user choice on inter-space excitations.
This method, like RASSCF, allows restrictions on the active space,
but they are more flexible than in RASSCF.
These restrictions are particularly useful when the cost of using the full CI
expansion of the active space is beyond reach.
These restrictions allow GASSCF to be applied to larger and more complex systems
at affordable cost.
Instead of a maximum number of holes in RAS1 and particles in RAS3, accumulated
minimum and maximum numbers of electrons are specified for GAS1, GAS1+GAS2,
GAS1+GAS2+GAS3, etc. in order to define the desired CI expansion.
The GAS scheme reduces to CAS or RAS when one or three spaces are chosen and
restrictions on electron excitations are adequately imposed.
When and how to use the GAS approach?
We consider three examples: (1) an organometallic material with separated metal
centers and orbitals not delocalized across the metal centers. One can include
the near degenerate orbitals of each center in its own GAS space.
This implies that one may choose as many GAS spaces as the number of
multiconfigurational centers. (2) Lanthanide or actinide metal compounds where
the :math:`f`-electrons require a MC treatment but they do not participate in bonding
neither mix with :math:`d` orbitals. In this case one can put the :math:`f` orbitals and their
electrons into one or more separated GAS spaces and not allow excitations
from and/or to other GAS spaces. (3) Molecules where each bond and its correlating
anti-bonding orbital could form a separate GAS space as in GVB approach.
Finally, if a wave function with a fixed number of holes in one or more
orbitals is desired, without interference of configurations where those
orbitals are fully occupied the GAS approach is the method of choice instead
of the RAS approach. There is no rigorous scheme to choose a GAS partitioning.
The right GAS strategy is system-specific. This makes the method versatile but
at the same time it is not a black box method.
An input example follow: ::

  &RASSCF
  nActEl
   6 0 0
  FROZen
  0 0 0 0 0 0 0 0
  INACTIVE
  2 0 0 0 2 0 0 0
  GASScf
  3
   1 0 0 0 1 0 0 0
  2 2
   0 1 0 0 0 1 0 0
  4 4
   0 0 1 0 0 0 1 0
  6 6
  DELEted
  0 0 0 0 0 0 0 0

In this example the entire active space counts six active electrons
and six active orbitals. These latter are partitioned in three GAS spaces
according to symmetry consideration and in the spirit of the GVB strategy.
Each subspace has a fixed number of electrons, *two*, and no interspace
excitations are allowed. This input shows clearly the difference
with the RAS approach.

Solvation Effects
.................

|molcas| incorporates the effects of the solvent using several models.
The most common is the cavity-based reaction-field Polarizable Continuum Model (PCM)
which is invoked by adding the keyword :kword:`RF-input` to the
:program:`SEWARD` code and is needed to compute the proper integrals. ::

  &GATEWAY
    coord=CH4.xyz
    Basis=ANO-S-MB
  &SEWARD
    RF-Input
     PCM-Model
     Solvent=Water
    End of RF-Input
  &RASSCF
    Nactel=8 0 0
    Inactive=1
    Ras2=8
  &CASPT2
    rfpert

The reaction field is computed in a self-consistent manner by the
:program:`SCF` or :program:`RASSCF` codes and added as a perturbation
to the Hamiltonian in the :program:`CASPT2` method with the keyword :kword:`RFPErt`.

Analyzing Results: Output Files and the :program:`LUSCUS` Program
-----------------------------------------------------------------

|molcas| provides a great deal of printed information in output files, and
the printing level is controlled by the environmental variable :variable:`MOLCAS_PRINT`.
By default this value is set to :kword:`two`, but can be modified by environmental variable :variable:`MOLCAS_PRINT`
Typical |molcas| output contains the program
header and input information, conditions of the calculation, the number of steps to achieve convergence, the energies and wave functions, and
final results, including in many cases the molecular orbital
coefficients as well as an analysis of the properties for the computed states.

.. For geometry optimizations, where many steps are required, there are different options to control
   how much output is generated. Three EMIL commands can be used:

   #. :command:`Set Output Screen` redirects the output to the screen;
   #. :command:`Set Output Over`, the default, skips the output of the intermediate steps and produces only output
      for the last iteration.
   #. :command:`Set Output File` places all output from
      each iteration in the :file:`$WorkDir` directory in files named
      :file:`Structure.iter.output`, where :command:`iter` is the number of
      the iteration.

      This is a convenient option to follow closely the convergence process. In this case, the :variable:`MOLCAS_PRINT` command must be set to :kword:`three`.

.. .. index::
      single: MING

   :program:MING:\: a Graphical Molcas Input Generator
   ...................................................

   |molcas| has incorporated a graphical self-guided tool to help the user to
   prepare the inputs and calculation flow named :program:`MING`. Provided that
   your system has all the graphical libraries and system utilities required
   for the code and this has been properly installed (try :command:`configure -ming`
   and read the installation guide if something fails), the :program:`MING`
   program is activated by the command :command:`molcas ming`.

   A window will then open in which the left panel contains three entrances.
   Clicking on :kword:`Templates` selected types of calculation are displayed
   in the right panel with the proper flow of |molcas| modules. Pressing on each
   of such boxes open new windows that enables to fill the input of the program.
   Most windows have a basic (default) and an advanced form. New modules or
   commands can be added to the flow by using the two other entrance in the
   left panel: :kword:`Commands`, including the EMIL commands that control
   the flow or add specific information, and :kword:`Modules`, including
   all |molcas| programs and utilities (see below).

   In the upper toolbar we find :command:`Settings`, to define the |molcas|
   environment, tools to :command:`Add`, :command:`Duplicate`, :command:`Delete`
   or :command:`Clear` new entrances, :command:`Preview` and :command:`Edit` the
   prepared input files, command :command:`Open` to retrieve previous input
   files, saving commands, and even commands to :command:`Submit` to send
   the calculation and command :command:`Watch` to inspect the output and
   error files.

   :program:`MING` can prepare most of calculations available in |molcas|.
   Even if you have a complex calculation the tool can be used to simplify
   and speed the basic aspects of the input.

.. index::
   single: LUSCUS

.. _TUT\:luscus:

LUSCUS: Grid and Geometry Visualization
.......................................

|molcas| developers have developed a graphical interface that can be used both
to create input for the |molcas| program and to analyze the results in
a graphical manner by visualizing molecular orbitals, density plots, and other output properties.

The first version of the code has the name GV (stands for Grid Viewer, or Geometry Visualization.
By an accident, the name also matches the nicknames of the main developers).
GV program uses a very limited set of graphic libraries, and thus has very primitive
user interface.

The next generation of GV program has the name LUSCUS. Luscus re-uses the code of GV,
and so GV users can use the same key combinations to operate with LUSCUS.
At the same time, LUSCUS provides a user-friendly interface, and contains many new
options, compared to GV.

LUSCUS can be obtained from http://luscus.sourceforge.net/, or
from https://www.molcas.org/LUSCUS.

LUSCUS can read the files only in one format: Luscus internal format (:file:`.lus`).
This format contains two sections: XYZ cartesian coordinates, and XML
formated data. It means that a standard XYZ file is a valid file in LUSCUS format.

Files with different formats, e.g. molden files, can be understood by LUSCUS
since they can be converted to LUSCUS format by a corresponding plug-in.
For instance, opening a file with the extension :file:`.molden`, LUSCUS automatically
runs a plug-in to convert a file from molden format to LUSCUS format. Saving a
LUSCUS file as a Molcas orbital file will automatically run a converter
from LUSCUS format to Orbital format.

* :command:`luscus xyz_file`: reads coordinates from a cartesian coordinate file.

  A molecule can be visualized and modified with the use of the
  left-button of the mouse and the keyboard. Below are some of the most
  useful commands.

  .. _tab\:luscus_geo:

  ======================== ===========================================================
  Left mouse click         Select atoms (if two, a bond is selected, if three
                           bond angle, if four a dihedral angle
  Left mouse + Shift click Mark/unmark atoms to/from the group
  Middle mouse/Space       Remove selection, or marking
  Insert key               Insert atom
  PageUp, PageDown         Alter type of selected atom or bond
  Delete/Supress key       Delete a selected atom
  +/-                      Change a value of selected bond/angle in steps
  Backspace                Undo last action
  Home                     Set selected atom to center of coordinates
  F8 key                   Find or apply symmetry
  ======================== ===========================================================

* :command:`luscus molden_file`: reads (check the comment about plug-in) from MOLDEN files such as
  :file:`wavefunction.molden`, :file:`freq.molden`, and :file:`geo.molden`.

  Note that |molcas| produces molden files with several extensions, so it is
  recommended to visualize these files by using :program:`Luscus`.

* :command:`luscus grid_file`: reads coordinates and densities and molecular orbitals from
  a binary :file:`grid_file`.

  This file is generated by :program:`GRID_IT` and, by default, placed in the :file:`$WorkDir` directory with the name
  :file:`$Project.lus`. The program allows displaying total densities, molecular orbitals, and charge density differences.

  If |molcas| and Luscus are installed locally, :program:`Luscus` can also be called from user input as shown in the following example: ::

    &GATEWAY
       coord = acrolein.xyz
       basis = ANO-L-MB
    &SEWARD
    &SCF
    &GRID_IT
    ALL

    * running external GUI program luscus

    ! luscus $Project.lus

    * User has to select active space and save GvOrb file!

    &RASSCF
    Fileorb=$CurrDir/$Project.GvOrb

  Note, that in the example above, the :program:`GRID_IT` program will generate a
  :file:`$Project.lus` file which :program:`LUSCUS` then uses, eliminating the need for defining
  :file:`$Project.lus` and allowing this file to be overwritten. :program:`rasscf` will
  read starting orbitals from the :file:`$Project.GvOrb` file.
.. index::
   single: Program; Single_aniso
   single: Single_aniso

.. _TUT\:sec\:single_aniso:

:program:`SINGLE_ANISO` --- A Magnetism of Complexes Program
============================================================

The program :program:`SINGLE_ANISO` calculates nonperturbatively the temperature- and field-dependent magnetic
properties (Van Vleck susceptibility tensor and function, molar magnetization vector and function) and the
pseudospin Hamiltonians for Zeeman interaction (the :math:`g` tensor and higher rank tensorial components) and the
zero-field splitting (the :math:`D` tensor and higher rank tensorial components) for arbitrary mononuclear complexes
and fragments on the basis of ab initio spin-orbit calculations.
:program:`SINGLE_ANISO` requires as input file the :file:`RUNFILE` containing all necessary
*ab initio* information: spin--orbit eigenstates, angular momentum matrix elements, the states been mixed
by the spin--orbit coupling in :program:`RASSI`, etc. Usually, the :program:`SINGLE_ANISO`
runs after :program:`RASSI`.

For a proper spin--orbit calculation the relativistic basis sets should be used for the whole calcualtion.
For :program:`SEWARD`, the atomic mean-field (:kword:`AMFI`), Douglas--Kroll (:kword:`DOUG`) must be employed.
To ensure the computation of angular momentum integrals the :kword:`ANGMOM` should be also used, specifying the origin
of angular momentum integrals as the coordinates of the magnetic center of the molecule, i.e. the coordinates of the atom
where the unpaired electrons mainly reside. For program :program:`RASSI` the necessary keywords are: :kword:`SPIN`,
since we need a spin--orbit coupling calculation, and :kword:`MEES`, to ensure the computation of angular momentum
matrix elements in the basis of spin-free states (SFS).

.. index::
   single: Single_aniso; Input

In the cases where spin--orbit coupling has a minor effect on the low-lying energy spectrum (most of the
isotropic cases: :math:`\ce{Cr^{3+}}`, :math:`\ce{Gd^{3+}}`, etc.) the pseudospin is usually the same as the ground spin. For these cases
the :program:`SINGLE_ANISO` may run without specifying any keywords in the input file. ::

&SINGLE_ANISO

In the cases when spin--orbit coupling play an important role in the low-lying energy spectrum, i.e. in the cases of e.g. octahedral :math:`\ce{Co^{2+}}`,
most of the lanthanide complexes, the pseudospin differs strongly from the spin of the ground state. In these cases,
the dimension of the pseudospin can be found by analysing the spin--orbit energy spectrum obtained at :program:`RASSI`.
The pseudospin is best defined as a group of spin--orbit states close in energy. Once specified, these eigenstates are further used
by the :program:`SINGLE_ANISO` to build proper pseudospin eigenfunctions. As an example of an input for :program:`SINGLE_ANISO`
requiring the computation of all magnetic properties (which is the default) and the computation of the :math:`g` tensor for the ground
Kramers doublet (i.e. pseudospin of a Kramers doublet is :math:`\tilde{S}=1/2`). ::

  &SINGLE_ANISO
  MLTP
  1
  2

:program:`SINGLE_ANISO` has implemented pseudospins: :math:`\tilde{S}=1/2`, :math:`\tilde{S}=1`, ..., up to :math:`\tilde{S}=7/2`. The user can also ask for more pseudospins at the same time: ::

  &SINGLE_ANISO
  MLTP
  3
  2 4 2

For the above input example, the :program:`SINGLE_ANISO` will compute the :math:`g` tensor for the ground Kramers doublet
(spin--orbit states 1 and 2), the :math:`g` tensor, ZFS tensor and coefficients of higher rank ITO for the pseudospin
:math:`\tilde{S}=3/2` (spin orbit functions 3--6), and the :math:`g` tensor for the third excited Kramers doublet (spin orbit functions 7 and 8).

.. index::
   single: Single_aniso; Output

:program:`SINGLE_ANISO` Output
------------------------------

The :program:`SINGLE_ANISO` section of the |molcas| output is divided in four parts. In the first part, the :math:`g` tensor and higher rank Zeeman tensors are computed. They are followed by :math:`D` tensor and higher rank ZFS tensors. The program also computes the angular moments in the direction of the main magnetic axes.

In the second part, the paramaters of the crystal field acting on the ground atomic multiplet of lanthanides are calculated.

In the third part, the powder magnetic susceptibility is printed, followed by the magnetic susceptibility tensors with and without intermolecular interaction included.

In the fourth part, magnetization vectors (if required) are printed, and then the powder molar magnetization calculated for the :kword:`TMAG`
temperature.

The keywords :kword:`TINT` and :kword:`HINT` control the temperature and field intervals for computation of
magnetic susceptibility and molar magnetization respectively.
Computation of the magnetic properties at the experimental temperature and field points with the estimation of the standard deviation from experiment
is also possible via :kword:`TEXP`, defining the experimental temperature and measured magnetic susceptibility and
:kword:`HEXP`, defining the experimental field and averaged molar magnetization. ::

  &SINGLE_ANISO
  TITLE
  g tensor and magnetic susceptibility
  TYPE
  4
  MLTP
  2
  3 3
  TINT
  0.0 100 101 0.001

The above input requires computation of the parameters of two pseudospins :math:`\tilde{S}=1`: the ground (spin--orbit functions 1--3)
and first excited (spin--orbit functions 4--6) and the magnetic susceptibility in 101 steps equally distributed in
the temperature domain 0.0--100.0 K.

:program:`SINGLE_ANISO` --- Basic and Most Common Keywords
----------------------------------------------------------

.. class:: keywordlist

:kword:`MLTP`
  Specifies the number and dimension of the pseudospins Hamiltonians

:kword:`TMAG`
  Sets the temperature for the computation of molar magnetization

:kword:`MVEC`
  Number and radial coordinates of directions for which the magnetization vector will be computed
Optimizing Geometries
=====================

.. : minima, transition states, crossings, and minimum energy paths

It is now useful to explore potential energy surfaces (PES) and optimize the molecular geometry for
specific points along the PES. Different cases are discussed including a way to obtain the optimal geometry
in a minimum energy search, to obtain a transition-state structure connecting different regions of
the PES, to find the crossing between two PES where the energy becomes degenerate, or to map
the minimum steepest-descent energy path (MEP) from an initial point to the final
a minimum energy geometry as the PES progresses in a downward manner.

All these types of searches can be performed either by fully optimizing all
degrees of freedom of the system or by introducing certain restrictions. |molcas| can perform
geometry optimizations at the SCF (RHF and UHF), DFT (RHF and UHF based), CASSCF (CASSCF and RASSCF) levels of theory,
where efficient analytical gradients are available and at the CASPT2 and other correlated levels where numerical
gradients are used.

Geometry optimizations require many cycles, in which the electronic energy is estimated at a specific
level of calculation followed by calculation of the gradient of the energy with respect to the geometric
degrees of freedom (DOF). With this information at hand, the program must decide if the molecule is
already at the final required geometry (i.e. gradient :math:`\sim` 0 for all
DOF) indicating a minimum in the PES or if the geometry must be modified
and continue the cycle. The input file should,
therefore, be built in a way that allows a loop over the different programs.

The general input commands :command:`Do while` and :command:`Enddo` control the loop
and program input is inserted within these commands. Instructions for the number of maximum iterations allowed and the type of output required can also be added.
(see :numref:`UG:sec:sysvar`)

.. The commands :command:`Set output file`, which prints output for each iterations and
   in the :file:`$WorkDir` directory with the file name :file:`Structure.$iteration.output`, and
   :command:`Set maxiter 100`, which sets maximum iterations to one hundred.

All examples previously discussed, use :kword:`COORD` keyword, but it also possible
to use *native format*, where symmetry unique atoms are specified (:kword:`SYMMETRY`)
and provide generators to construct all atoms in the molecule.

The selected example describes geometry optimization of the water molecule at the SCF RHF level
of calculation:

.. extractfile:: problem_based_tutorials/Water_distorted.xyz

  3
   coordinates for water molecule NOT in equilibrium
  O 0.000000  0.000000  0.000000
  H 0.758602  0.000000  0.504284
  H 0.758602  0.000000 -0.504284

.. extractfile:: problem_based_tutorials/SCF.minimum_optimization.H2O.input

  *SCF minimum energy optimization for H2O
  *File: SCF.minimum_optimization.H2O
  *
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1

  >>> Do while
   &SEWARD ;&SCF; &SLAPAF
  >>> EndDo

The sequence of programs employed includes :program:`GATEWAY` which is external to the loop, followed by
:program:`SEWARD`, :program:`SCF`, and :program:`SLAPAF`. :program:`SEWARD`
computes the integrals, :program:`SCF` program computes the RHF energy and wave
function, and :program:`SLAPAF` will control the calculation of gradients and
estimate if the calculation has already finished or needs to proceed to a new
nuclear geometry for the next iteration. Automatically, a file named
:file:`$Project.geo.molden` will be generated in :file:`$WorkDir` containing all the
geometric steps contained in the optimization process. :program:`MOLDEN` or :program:`LUSCUS` can
then read this file to display the individual molecular geometries which form the optimization cycle.

Using another reference wave function can be simply performed by changing the sequence of
programs. For instance, we can perform an UHF calculation of the :math:`\ce{H2O^+}`
cation:

.. extractfile:: problem_based_tutorials/UHF.minimum_optimization.H2Oplus.input

  *UHF minimum energy optimization for H2O+
  *File: UHF.minimum_optimization.H2Oplus
  *
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1
  >> Do while

   &SEWARD
   &SCF; Title="H2O minimum optimization"; UHF; Charge=1
   &SLAPAF

  >> EndDo

The same procedure can be followed if we pretend to perform a DFT geometry optimization:

.. extractfile:: problem_based_tutorials/DFT.minimum_optimization.H2O.input

  *DFT minimum energy optimization for H2O
  *File: DFT.minimum_optimization.H2O
  *
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1

  >>> Export MOLCAS_MAXITER=100
  >>> Do while

   &SEWARD
   &SCF ; Title="H2O minimum optimization"; KSDFT=B3LYP
   &SLAPAF &END

  >>> EndDo

Once an energy minimum is found based on the calculation of gradients, it is necessary to
ensure that the geometry really is a minimum energy point. This can be only
accomplished by computing second derivatives of the energy (i.e. the Hessian).
|molcas| can compute analytical Hessians for SCF and single state
CASSCF wave functions. For other methods, numerical procedures can be used
to compute the Hessian. Once the Hessian is computed, vibrational
frequencies are calculated, and Statistical Mechanics is used to obtain thermodynamic
properties. At a true energy minimum, there will be :math:`3N-6` real frequencies
Program :program:`MCKINLEY` computes second derivatives
of a predefined (SCF or CASSCF) wave function, while :program:`MCLR` performs
the vibrational and statistical analyses. |molcas| simply requires input for
the :program:`MCKINLEY` program to perform the entire calculation by using keywords
:kword:`Perturbation` and :kword:`Hessian`, while program :program:`MCLR` will be
called automatically but requires no input.
The full set of calculations is included below first a geometry optimization followed by the
calculation of a Hessian.

.. extractfile:: problem_based_tutorials/SCF.minimization_plus_Hessian.H2O.input

  *SCF minimum energy optimization plus hessian of the water molecule
  *File: SCF.minimization_plus_hessian.H2O
  *
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1

  >>> Export MOLCAS_MAXITER=100
  >>> Do while

   &SEWARD
   &SCF; Title="H2O minimum optimization"
   &SLAPAF

  >>> EndDo

  &MCKINLEY

Note that :program:`MCKINLEY` input above is placed after :command:`EndDo`, and, therefore,
is external to the looping scheme. Once the geometry optimization at the desired level of theory has finished, the
Hessian will be computed at the final geometry.
In general, any calculation performed using a :file:`$WorkDir` directory where a
previous geometry optimization has taken place will use the last geomtry calculated
from that optimization as the input geometry even if :program:`SEWARD` input is
present. To avoid that, the only solution is to remove the communication file
:file:`RUNFILE` where the geometry is stored. Note also, that the frequencies are
computed in a cartesian basis, and that three translational and three rotational
frequencies which should be very close to zero are included in the output file.
This is not the case when numerical gradients and Hessians are used.
In particular, for water at its minimum energy structure three (:math:`3N-6`)
real vibrational frequencies. By default, in :file:`$WorkDir` a file :file:`$Project.freq.molden`
is generated containing the vibrational frequencies and modes, which can be visualized by :program:`MOLDEN`.

A new level of theory, CASSCF, is introduced here which is especially suited for
geometry optimizations of excited states discussed in the next chapter.
A geometry optimization is performed to illustrate a broader range of possibilities including
the imposition of a geometric restrain that the HOH angle in water should be constrained to 120\ |o|
during the optimization.
This means that only the O--H bond distances be optimized in this partial minimization.
The restriction is indicated
in in :program:`GATEWAY`
by invoking the keyword :kword:`Constraints` and ending with the keyword :kword:`End of Constraints`.
The names of variables corresponding to geometrical variables in either internal or Cartesian coordinates
that are to be constrained are placed between these two keywords.
(see nomenclature in
:numref:`UG:sec:definition_of_internal_coordinates`)
In the case of :math:`H_2O`, the H1--O--H2 angle is fixed at 120\ |o|, so a variable,
:math:`a`, is first defined with the keywork :kword:`Angle`, which relates it to the H1--O1--H2 angle, followed by the second keyword, :kword:`Value`,
where the variable :math:`a` is specified as 120\ |o|.
It is not required that the initial geometry is 120\ |o|, only that the final result for the calculation
will become 120\ |o|.

Note that the :program:`RASSCF` program requires initial trial orbitals, and those
which are automatically generated by :program:`SEWARD` are used. The resulting CASSCF
wave function includes all valence orbitals and electrons.

.. extractfile:: problem_based_tutorials/CASSCF.minimum_optimization_restricted.H2O.input

  *CASSCF minimum energy optimization of the water molecule with geometrical restrictions
  *File: CASSCF.minimum_optimization_restricted.H2O
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1
  Constraint
     a = Angle H2 O1 H3
    Value
     a = 90. degree
  End of Constraints

  >>> Do while

   &SEWARD
   &RASSCF; nActEl=8 0 0; Inactive=1; Ras2=6
   &SLAPAF

  >>> EndDo

Other more flexible ways to impose geometric restrictions involve the specification of which internal
coordinates should remain fixed and which should change. In the next example,
the bond lengths are forced to remain fixed at their initial distance (here 0.91 Å), while the
bond angle, having an initial of 81\ |o|, is optimized.

.. extractfile:: problem_based_tutorials/DFT.minimum_optimization_restricted.H2O.input

  *DFT minimum energy optimization of the angle in the water molecule at fixed bond lengths
  *File: DFT.minimum_optimization_restricted.H2O
  *
  &GATEWAY
   Title= H2O minimum optimization
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1

  >>> EXPORT MOLCAS_MAXITER=100
  >>> Do while

   &SEWARD; &SCF; Title="H2O restricted minimum"; KSDFT=B3LYP
   &SLAPAF
    Internal Coordinates
       b1 = Bond O1 H2
       b2 = Bond O1 H3
       a1 = Angle H2 O1 H3
    Vary
       a1
    Fix
       b1
       b2
    End of Internal

  >>> EndDo

In the final output, the two O--H bond lengths remain at the initial values, while the H1--O1--H2 angle is optimized
to a final angle of 112\ |o|.

The next step entails the computation of a transition state, a structure connecting different regions of
the potential energy hypersurface, and is a maximum for only one degree of
freedom. The most common saddle points have order one, that is, they are maxima for one of
one displacement and minima for the others. The simplest way to search for a
transition state in |molcas| is to add the keyword :kword:`TS` to the
:program:`SLAPAF` input. Keyword :kword:`PRFC` is suggested in order to verify
the nature of the transition structure. Searching for transition states is,
however, not an easy task. An illustration of the input required for transition state optimization for water at the DFT level
is given below:

.. extractfile:: problem_based_tutorials/Water_TS.xyz

  3
  water in Transition state in bohr
  O1             0.750000        0.000000        0.000000
  H2             1.350000        0.000000        1.550000
  H3             1.350000        0.000000       -1.550000

.. extractfile:: problem_based_tutorials/DFT.transition_state.H2O.input

  *DFT transition state optimization of the water molecule
  *File: DFT.transition_state.H2O
  *
  &Gateway
   Coord=Water_TS.xyz
   Basis=ANO-S-VDZ
   Group=C1
  >>> Do while

   &SEWARD
   &SCF; Title="H2O TS optimization"; KSDFT=B3LYP
   &SLAPAF ; ITER=20 ; TS

  >>> EndDo

The initial coordinates were chosen in units of Bohr, to illustrare that this is the
default case. The optimal geometry for ground state of water is a structure with :math:`C_{2v}` symmetry.
A transition state has been found with a linear H--O--H angle of 180\ |o|.
In many cases, there may be a clue along the energy pathway for a chemical reaction about the nature of the transition state structure,
which typically represents an intermediate conformation between reactants and products.
If this turns out to be the case, it is possible to help the optimization process
proceed toward an informed guess, by invoking the keyword :kword:`FindTS` in :program:`SLAPAF`.
:kword:`FindTS` must to be accompanied with a definition of constrained geometric definitions.
:program:`SLAPAF` will guide the optimization of the transition state towards a region in
which the restriction is fulfilled. Once there, the restriction will be released
and a free search of the transition state will be performed. This technique is
frequently quite effective and makes it possible to find difficult transition
states or reduce the number of required iterations. Here, an example is provided, in
which the initial geometry of water is clearly bent, and a trial restraint is imposed
such that the angle for the transition state should be near 180\ |o|. The
final transition state will, however, be obtained without any type of geometrical restriction.

.. extractfile:: problem_based_tutorials/DFT.transition_state_restricted.H2O.input

  *DFT transition state optimization of the water molecule with geometrical restrictions
  *File: DFT.transition_state_restricted.H2O
  *
  &Gateway
   Coord=Water_TS.xyz
   Basis=ANO-S-VDZ
   Group=C1
   Constraints
     a = Angle H2 O1 H3
   Value
     a = 180.0 degree
   End of Constraints

  >>> Do while

   &SEWARD
   &SCF; Title="H2O TS optimization"; KSDFT=B3LYP
   &SLAPAF ;FindTS

  >>> EndDo

The :program:`CASPT2` geometry optimizations are somewhat different because :program:`ALASKA`
is not suited to compute :program:`CASPT2` analytical gradients. Therefore the :program:`ALASKA`
program is automatically substituted by program :program:`NUMERICAL_GRADIENT`, which will take care
of performing numerical gradients. From the user point of view the only requirement is to place
the :program:`CASPT2` input after the :program:`RASSCF` input.
The CASSCF wave function has of course to be generated in each step before
performing CASPT2. To compute a numerical gradient can be quite time consuming,
although it is a task that can be nicely parallelized. In a double-sided
gradient algorithm like here a total of :math:`6N-12+1` CASPT2 calculations are performed
each pass of the optimization, where :math:`N` is the number of atoms.

.. extractfile:: problem_based_tutorials/CASPT2.minimum_optimization.H2O.input

  *CASPT2 minimum energy optimization for water
  *File: CASPT2.minimum_optimization.H2O
  *
  &GATEWAY
   coord=Water_distorted.xyz
   basis=ANO-S-MB
   group=C1

  >>> Do while

   &SEWARD
   &RASSCF; Title="H2O restricted minimum"; nActEl=8 0 0; Inactive=1; Ras2=6
   &CASPT2; Frozen=1
   &SLAPAF

  >>> EndDo

The use of spatial symmetry makes the calculations more efficient, although
they may again complicate the preparation of input files. We can repeat the previous :program:`CASPT2`
optimization by restricting the molecule to work in the :math:`C_{2v}` point group, which, by the way,
is the proper symmetry for water in the ground state. The :program:`GATEWAY` program (as no symmetry
has been specified) will identify and work with the highest available point group,
:math:`C_{2v}`. Here the molecule is placed with YZ as the molecular plane. By adding
keyword :kword:`Symmetry` containing as elements of symmetry the YZ (symbol X) and YX (symbol Z),
the point group is totally defined and the molecule properly generated. From that point the
calculations will be restricted to use symmetry restrictions. For instance, the molecular
orbitals will be classified in the four elements of symmetry of the group, :math:`a_1`, :math:`b_1`, :math:`b_2`,
and :math:`a_2`, and most of the programs will require to define the selection of the orbitals in
the proper order. The order of the symmetry labels is determined by :program:`SEWARD` and must
be checked before proceeding, because from that point the elements of symmetry will be known
by their order in :program:`SEWARD`: :math:`a_1`, :math:`b_1`, :math:`b_2`, and :math:`a_2`, for instance, will be
symmetries 1, 2, 3, and 4, respectively. :program:`SCF` does not require to specify the
class of orbitals and it can be used as a learning tool.

.. extractfile:: problem_based_tutorials/CASPT2.minimum_optimization_C2v.H2O.input

  *CASPT2 minimum energy optimization for water in C2v
  *File: CASPT2.minimum_optimization_C2v.H2O
  *
   &GATEWAY
  Title= H2O caspt2 minimum optimization
  Symmetry= X Z
  Basis set
  O.ANO-S...2s1p.
  O        0.000000  0.000000  0.000000 Angstrom
  End of basis
  Basis set
  H.ANO-S...1s.
  H1       0.000000  0.758602  0.504284 Angstrom
  End of basis

  >>> EXPORT MOLCAS_MAXITER=100
  >>> Do while

   &SEWARD
   &RASSCF; nActEl=8 0 0; Inactive=1 0 0 0; Ras2=3 1 2 0
   &CASPT2; Frozen=1 0 0 0
   &SLAPAF &END

  >>> EndDo

Thanks to symmetry restrictions the number of iterations within :program:`NUMERICAL_GRADIENT`
has been reduced to five instead of seven, because many of the deformations
are redundant within the :math:`C_{2v}` symmetry. Also, symmetry considerations are
important when defining geometrical restrictions
(see :numref:`Sections %s <UG:sec:definition_of_internal_coordinates>`
and :numref:`%s <TUT:sec:optim>`).
.. index::
   single: Program; RASSI
   single: RASSI
   single: Properties; With RASSI
   single: Properties; Expectation values
   single: Properties; Matrix elements
   single: Expectation values
   single: Matrix elements

.. _TUT\:sec\:rassi:

:program:`RASSI` --- A RAS State Interaction Program
====================================================

Program :program:`RASSI` (RAS State Interaction) computes matrix elements
of the Hamiltonian and other operators in a wave function basis, which
consists of individually optimized CI expansions from the :program:`RASSCF`
program. Also, it solves the Schrödinger equation within the space of
these wave functions. There are many possible applications for such type
of calculations. The first important consideration to have into account
is that :program:`RASSI` computes the interaction among RASSCF states
expanding the same set of configurations, that is,
having the same active space size and number of electrons.

The :program:`RASSI` program is routinely used to compute electronic
transition moments, as it is shown in the Advanced Examples in the
calculation of transition dipole moments for the
excited states of the thiophene molecule using CASSCF-type wave functions.
By default the program will compute the matrix elements and expectation values
of all the operators for which :program:`SEWARD` has computed the integrals
and has stored them in the :file:`ONEINT` file.

.. index::
   single: Non-orthogonal states

RASSCF (or CASSCF) individually optimized states are interacting and
non-orthogonal. It is imperative when the states involved have different
symmetry to transform the states to a common eigenstate basis in such
a way that the wave function remains unchanged. The State Interaction
calculation gives an unambiguous set of non-interacting and orthonormal
eigenstates to the projected Schrödinger equation and also the
overlaps between the original RASSCF wave functions and the eigenstates.
The analysis of the original states in terms of RASSI eigenstates is
very useful to identify spurious local minima and also to inspect the
wave functions obtained in different single-root RASSCF calculations,
which can be mixed and be of no help to compare the states.

Finally, the :program:`RASSI` program can be applied in situations when
there are two strongly interacting states and there are two very different
MCSCF solutions. This is a typical situation in transition metal chemistry
when there are many close states associated each one to a configuration
of the transition metal atom. It is also the case when there are two
close quasi-equivalent localized and delocalized solutions. :program:`RASSI`
can provide with a single set of orbitals able to represent, for instance,
avoided crossings. :program:`RASSI` will produce a
number of files containing the natural orbitals for
each one of the desired eigenstates to be used in subsequent calculations.

:program:`RASSI` requires as input files the :file:`ONEINT` and :file:`ORDINT`
integral files and the :file:`JOBIPH` files from the :program:`RASSCF` program
containing the states which are going to be computed. The :file:`JOBIPH` files
have to be named consecutively as :file:`JOB001`, :file:`JOB002`, etc.
The input for the :program:`RASSI` module has to contain at least
the definition of the number of states available in each of the input
:file:`JOBIPH` files. :numref:`block:rassi_input` lists the input file
for the :program:`RASSI` program in a calculation including two :file:`JOBIPH`
files (2 in the first line), the first one including three roots (3 in the first
line) and the second five roots (5 in the first line). Each one of the
following lines lists the number of these states within each :file:`JOBIPH` file.
Also in the input, keyword :kword:`NATOrb` indicates that three files
(named sequentially :file:`NAT001`, :file:`NAT002`, and :file:`NAT003`) will
be created for the three lowest eigenstates.

.. index::
   single: RASSI; Input

.. code-block:: none
   :caption: Sample input requesting the :program:`RASSI` module to calculate the matrix
             elements and expectation values for eight interacting RASSCF states
   :name: block:rassi_input

   &RASSI
   NROFjobiph= 2 3 5; 1 2 3; 1 2 3 4 5
   NATOrb= 3

.. index::
   single: RASSI; Output

:program:`RASSI` Output
-----------------------

The :program:`RASSI` section of the |molcas| output is basically divided
in three parts. Initially, the program prints the information about the
:file:`JOBIPH` files and input file, optionally prints the wave functions,
and checks that all the configuration spaces are the same in all the
input states. In second place :program:`RASSI` prints the expectation
values of the one-electron operators, the Hamiltonian matrix, the
overlap matrix, and the matrix elements of the one-electron operators,
all for the basis of input RASSCF states. The third part starts with
the eigenvectors and eigenvalues for the states computed in
the new eigenbasis, as well as the overlap of the computed eigenstates
with the input RASSCF states. After that, the expectation values and
matrix elements of the one-electron operators are repeated on the
basis of the new energy eigenstates. A final section informs about
the occupation numbers of the natural orbitals computed by
:program:`RASSI`, if any.

In the Advanced Examples a detailed example of how to interpret
the matrix elements output section for the thiophene molecule is
displayed. The rest of the output is self-explanatory. It has to be
remembered that to change the default origins for the one electron
operators (the dipole moment operator uses the nuclear charge
centroid and the higher order operators the center of the nuclear
mass) keyword :kword:`CENTer` in :program:`GATEWAY` must be used.
Also, if multipoles higher than order two are required, the
option :kword:`MULTipole` has to be used in :program:`GATEWAY`.

The program :program:`RASSI` can also be used to compute a spin--orbit Hamiltonian
for the input CASSCF wave functions as defined above. The keyword :kword:`AMFI`
has to be used in :program:`SEWARD` to ensure that the corresponding integrals
are available.

.. code-block:: none
   :caption: Sample input requesting the :program:`RASSI` module to calculate and diagonalize
             the spin--orbit Hamiltonian the ground and triplet excited state in water.
   :name: block:rassi_input1

   &RASSI
   NROFjobiph= 2 1 1; 1; 1
   Spinorbit
   Ejob

The first :file:`JOBMIX` file contains the wave function for the ground state and
the second file the :math:`^3B_2` state discussed above. The keyword :kword:`Ejob`
makes the :program:`RASSI` program use the CASPT2 energies which have been
written on the :file:`JOBMIX` files in the diagonal of the spin--orbit
Hamiltonian. The output of this calculation will give four spin--orbit states and
the corresponding transition properties, which can for example be used to
compute the radiative lifetime of the triplet state.

:program:`RASSI` --- Basic and Most Common Keywords
---------------------------------------------------

.. class:: keywordlist

:kword:`NROFjob`
  Number of input files, number of roots, and roots for each file

:kword:`EJOB`/:kword:`HDIAG`
  Read energies from input file / inline

:kword:`SPIN`
  Compute spin--orbit matrix elements for spin properties
.. index::
   single: Program; CPF
   single: CPF
   single: MCPF
   single: ACPF

.. _TUT\:sec\:cpf:

:program:`CPF` --- A Coupled-Pair Functional Program
====================================================

The :program:`CPF` program produces Single and Doubles Configuration
Interaction (SDCI), Coupled-Pair Functional (CPF), Modified Coupled-Pair
Functional (MCPF), and Averaged Coupled-Pair Functional (ACPF) wave
functions (see CPF section of the user's guide) from one
reference configuration. The difference between the :program:`MRCI` and
:program:`CPF` codes is that the former can handle Configuration
Interaction (CI) and Averaged Coupled-Pair Functional (ACPF) calculations
with more than one reference configuration. For a closed-shell reference
the wave function can be generated with the :program:`SCF` program. In
open-shell cases the :program:`RASSCF` has to be used.

The :kword:`TITLe` keyword behaviors in a similar fashion to the
other |molcas| modules. The :kword:`CPF` keyword requests an
Coupled-Pair Functional calculation.
This is the default and is mutually exclusive with keywords
:kword:`MCPF`, :kword:`ACPF`, and :kword:`SDCI` which request different
type of calculations. The input below lists the input files
for the :program:`guga` and :program:`cpf` programs to obtain the MCPF
energy for the lowest triplet state of :math:`B_2` symmetry in the water molecule.
The :program:`GUGA` module computes the coupling coefficients for a triplet
state of the appropriate symmetry and the :program:`CPF` module will
converge to the first excited triplet state. One orbital of the first
symmetry has been frozen in this case (core orbital) in the :program:`MOTRA`
step.

:program:`cpf` Output
---------------------

The :program:`cpf` section of the output lists the number of each type
of orbital in each symmetry including pre-frozen orbitals that were
frozen by the :program:`guga` module. After some information concerning the
total number of internal configurations used and storage data, it appears
the single reference configuration in the :program:`mrci` format: an empty
orbital is listed as "``0``" and a doubly occupied as "``3``". The
spin of a singly occupied orbital by "``1``" (spin up) or "``2``"
(spin down). The molecular orbitals are listed near the end of the output.

Sample input requested by the GUGA and CPF modules to calculate the MCPF energy for
the lowest :math:`B_1` triplet state of the water in :math:`C_{2v}` symmetry: ::

  &GUGA
  Title= H2O molecule. Triplet state.
  Electrons= 8; Spin= 3
  Inactive= 2 0 1 0; Active= 1 1 0 0
  CiAll= 2

  &CPF
  Title= MCPF of triplet state of C2v Water
  MCPF

There are four input files to the :program:`cpf` module; :file:`CIGUGA`
from :program:`GUGA`, :file:`TRAONE` and :file:`TRAINT` from
:program:`MOTRA` and :file:`ONEINT` from :program:`SEWARD`. The orbitals
are saved in :file:`CPFORB`.
.. index::
   single: Program; Alaska
   single: Alaska

:program:`ALASKA` --- A Program for Integral Derivatives
=======================================================

:program:`ALASKA` computes the first derivatives of the one- and two-electron
integrals with respect to the nuclear displacements. The derivatives are contracted
with the one- and two-electron densities to form the molecular gradients, which
will be used by the program :program:`SLAPAF`. At present the :program:`ALASKA`
module computes SCF/DFT and MCSCF gradients analytically, the rest are computed
numerically. The :program:`ALASKA` module is automatically invoked when needed if
the user has not explicitly requested the module to be executed. We postpone the
discussion about :program:`ALASKA` to :numref:`TUT:sec:structure`.
.. index::
   single: Program; MRCI
   single: MRCI
   single: CI
   single: ACPF

.. _TUT\:sec\:mrci:

:program:`MRCI` --- A Configuration Interaction Program
=======================================================

Multi Reference Single and Doubles Configuration Interaction (MR-SDCI)
wave functions are produced by the :program:`MRCI` program module in
the |molcas| codes.
The :kword:`SDCI` keyword requests an
ordinary Multi Reference Single and Doubles Configuration Interaction
calculation. This is the default and is mutually exclusive with the
:kword:`ACPF` keyword which requests an Average Coupled Pair Function
calculation. The final keyword, :kword:`ROOT`, specifies the number
of the CI root the calculation should compute. The second CI root is
the first excited state and since the :program:`GUGA` module has computed the
coupling coefficients for a triplet state, the :program:`MRCI` module will
converge to the first excited triplet state.

:program:`mrci` Output
----------------------

The :program:`mrci` section of the output lists the number of each type
of orbital in each symmetry including pre-frozen orbitals that were
frozen by the :program:`guga` module. There is a list of the
reference configurations with the inactive orbitals included. An empty
orbital is listed as "``0``" and a doubly occupied as "``3``". The
spin of a singly occupied orbital by "``1``" (spin up) or "``2``"
(spin down). The total
number of configuration state functions (CSFs) is listed below the reference
configurations.

Sample input requesting the the MRCI module to calculate the first
excited MRCI energy for neutral triplet water in :math:`C_{2v}` symmetry with six
electrons in the active space: ::

  &MRCI
  Title= MR-SDCI of 2nd CI root of C2v Water
  SDCI; Root= 2

A listing of the possible CI roots is followed by the CI iteration and
convergence information. The Davidson and ACPF corrections are included
along with the important CSFs in the CI wave function. The molecular
orbitals are listed near the end of the output.

There are four input files to the :program:`MRCI` module; :file:`CIGUGA`
from :program:`GUGA`, :file:`TRAONE` and :file:`TRAINT` from
:program:`MOTRA` and :file:`ONEINT` from :program:`SEWARD`. The orbitals
are saved in :file:`CIORBnn` where :file:`nn` is the number of the CI root.
.. index::
   single: Program; GENANO
   single: GENANO
   single: Basis set; Generation
   single: Basis set; Atomic Natural Orbitals

.. _TUT\:sec\:genano:

:program:`GENANO` --- A Program to Generate ANO Basis Sets
==========================================================

:program:`GENANO` is a program for determining the contraction coefficients for
generally contracted basis sets. They are determined by diagonalizing a density
matrix, using the eigenvectors (natural orbitals) as the contraction
coefficients, resulting in basis sets of the ANO (Atomic Natural Orbitals) type.
The program can be used to generate any set of atomic or molecular basis
functions. Only one or more wave functions (represented by formated orbital
files) are needed to generate the average density matrix. These natural orbital
files can be produced by any of the wave function generators, as it is described
in :numref:`UG:sec:genano` of the user's guide. As an illustrative example,
in the Advanced Examples there is an example of how to
generate a set of molecular basis set describing Rydberg orbitals for the
benzene molecule. The reader is referred to this example for more details.

The :program:`GENANO` program requires several input files. First, one
:file:`ONEINT` file generated by the :program:`SEWARD` module for each input wave
function. The files must be linked as :file:`ONE001`, :file:`ONE002`, etc. If the
wave functions correspond to the same system, the same :file:`ONEINT` file must
be linked with the corresponding names as many times as wave functions are
going to be treated. Finally, the program needs one file for wave function
containing the formated set of natural orbitals. The files must be linked as
:file:`NAT001`, :file:`NAT002`, etc.

The input file for module :program:`GENANO` contains basically three important
keywords. :kword:`CENTER` defines the atom label for which the basis set is to
be generated. The label must match the label it has in the :program:`SEWARD`.
:kword:`SETS` keyword indicates that the next line of input contains the
number of sets to be used in the averaging procedure and :kword:`WEIGHTS`
defines the relative weight of each one of the previous sets in the averaging
procedure. :numref:`block:genano_input` lists the input file required by the
:program:`GENANO` program for making a basis set for the oxygen atom. Three
natural orbital files are expected, containing the natural orbitals for the
neutral atom, the cation, and the anion.

.. code-block:: none
   :caption: Sample input requesting the :program:`GENANO` module to
             average three sets of natural orbitals on the oxygen atom.
   :name: block:genano_input

   &GENANO
   Title= Oxygen atom basis set: O/O+/O-
   Center= O
   Sets= 3
   Weights= 0.50 0.25 0.25

As output files :program:`GENANO` provides the file :file:`ANO`,
containing the contraction coefficient matrix organized such that each column
correspond to one contracted basis function, and the file :file:`FIG`, which
contains a PostScript figure file of the obtained eigenvalues. The output of
:program:`GENANO` is self-explanatory.
.. index::
   single: Tutorials
   single: Problem Based Tutorials

Problem Based Tutorials
=======================

.. toctree::

   tut_sp
   tut_op
   tut_ex
.. index::
   single: Program; VibRot
   single: VibRot
   single: Diatomic molecules
   single: Properties; Spectroscopic

.. _TUT\:sec\:vibrot:

:program:`VIBROT` --- A Program for Vibration--Rotation on Diatomic Molecules
=============================================================================

The program :program:`VIBROT` computes vibration-rotation spectra for diatomic
molecules. As input it uses a potential curve computed pointwise by any of
the wave function programs. It does not require other input file from any
of the |molcas| programs, just its standard input file.

In the Advances Examples the reader will find an overview of the input and
output files required by :program:`VIBROT` and the different uses of the
program on the calculation of the electronic states of the :math:`C_2` molecule.
The reader is referred to :numref:`UG:sec:vibrot`
of the user's guide for a detailed description of the program.
Electronic Energy at Fixed Nuclear Geometry
===========================================

The |molcas| suite of Quantum Chemical programs is modular in
design, and a desired calculation is achieved by executing a list of
|molcas| program modules in succession, occasionally manipulating
the program information files. If the information files from a previous
calculation are saved, then a subsequent calculation need not recompute
them. This is dependent on the correct information being preserved in
the information files for the subsequent calculations. Each module has keywords
to specify the functions to be carried out, and many modules rely on the
specification of keywords in previous modules.

In the present examples the calculations will be designed by preparing
a single file in which the input for the different programs is presented
sequentially. The initial problem will be to compute an electronic energy
at a fixed geometry of the nuclei, and this will be performed using different
methods and thus requiring different |molcas| program modules.

First, the proper |molcas| environment has to be set up which requires that
following variables must be properly defined, for instance: ::

  export MOLCAS=/home/molcas/molcas
  export Project=CH4
  export WorkDir=/home/user/tmp

If not defined, |molcas| provides default values for the above environment variables:

* The :variable:`MOLCAS` variable will be set to the latest implemented version of the code.

  This variable is set directly in the |molcas| home directory

* :variable:`Project` and :variable:`WorkDir` have the default values None and $PWD, respectively.

  It is very important that the molcas driver, called by command :command:`molcas`,
  and built during the installation of the code, is included in the $PATH.

The first run involves a calculation of the SCF energy of the methane
(:math:`\ce{CH4}`) molecule. Three programs should be used: :program:`GATEWAY` to specify
information about the system, :program:`SEWARD` to compute
and store the one- and two-electron integrals, and :program:`SCF` to obtain
the Hartree--Fock SCF wave function and energy.

.. compound::

  The three |molcas| programs to
  be used leads to three major entries in the input file: :program:`GATEWAY`, :program:`SEWARD`, and :program:`SCF`.
  The :program:`GATEWAY` program contains the nuclear geometry in cartesian
  coordinates and the label for the one-electron basis set.
  The keyword :kword:`coord` allows automatic insertion of :program:`GATEWAY` input from a standard
  file containing the cartesian coordinates in Angstrom which can be generated by
  programs like :program:`LUSCUS` or :program:`MOLDEN`).
  No symmetry is being considered so the keyword :kword:`group=C1` is used to force the program not
  to look for symmetry in the :math:`\ce{CH4}` molecule, and ,thus, input for :program:`SEWARD` is not required.
  In closed-shell cases, like :math:`\ce{CH4}`, input for :program:`SCF` is not required. All the input
  files discussed here can be found at :file:`$MOLCAS/doc/samples/problem_based_tutorials`, including the file
  :file:`SCF.energy.CH4` described below.

  .. extractfile:: problem_based_tutorials/SCF.energy.CH4.input

    *SCF energy for CH4 at a fixed nuclear geometry.
    *File: SCF.energy.CH4
    *
    &GATEWAY
     Title = CH4 molecule
     coord = CH4.xyz
     basis = STO-3G
     group = C1

    &SEWARD
    &SCF

  where the content of the :file:`CH4.xyz` file is:

  .. extractfile:: problem_based_tutorials/CH4.xyz

    5
    distorted CH4 coordinates in Angstroms
    C    0.000000     0.000000     0.000000
    H    0.000000     0.000000     1.050000
    H    1.037090     0.000000    -0.366667
    H   -0.542115    -0.938971    -0.383333
    H   -0.565685     0.979796    -0.400000

.. compound::

  To run |molcas|, simply execute the command ::

    molcas SCF.energy.CH4.input > SCF.energy.CH4.log 2 > SCF.energy.CH4.err

  where the main output is stored in file :file:`SCF.energy.CH4.log`

  or ::

    molcas -f SCF.energy.CH4.input

  where the main output is stored in :file:`SCF.energy.CH4.log`, and the default error file in :file:`SCF.energy.CH4.err`.

The most relevant information is contained in the output file, where the :program:`GATEWAY` program
information describing the nuclear geometry, molecular symmetry, and the data
regarding the one-electron basis sets and the calculation of one- and
two-electron integrals, as described in :numref:`TUT:sec:seward`. Next,
comes the output of program :program:`SCF` with information of the electronic
energy, wave function, and the Hartree--Fock (HF) molecular orbitals
(see :numref:`TUT:sec:scf`).

Files containing intermediate information, integrals, orbitals, etc, will be
kept in the $WorkDir directory for further use. For instance, files
:file:`$Project.OneInt` and :file:`$Project.OrdInt` contain the one- and
two-electron integrals stored in binary format. File :file:`$Project.ScfOrb`
stores the HF molecular orbitals in ASCII format, and
:file:`$Project.RunFile` is a communication file between programs. All these
files can be used later for more advanced calculations avoiding a
repeat of certain calculations.

There are graphical utilities that can be used for the analysis of the
results. By default, |molcas| generates files which can be read with the
:program:`MOLDEN` program and are found in the :file:`$WorkDir` including the file :file:`CH4.scf.molden`.
This file contains information about molecular geometry and molecular orbitals, and requires the use if *Density Mode* in :program:`MOLDEN`.
However, |molcas| has its own graphical tool, program :program:`LUSCUS`, which is a viewer based on openGL and allows the visualization of
molecular geometries, orbitals, densities, and density differences. For
example, a graphical display of the :math:`\ce{CH4}` molecule can be obtained from a standard coordinate file by the following command: ::

  luscus CH4.xyz

In order to obtain the information for displaying molecular orbitals and densities,
it is necessary to run the |molcas| program called :program:`GRID_IT`:

.. extractfile:: problem_based_tutorials/SCF.energy_grid.CH4.input

  *SCF energy for CH4 at a fixed nuclear geometry plus a grid for visualization.
  *File: SCF.energy_grid.CH4
  *
  &GATEWAY
   Title = CH4 molecule
   coord = CH4.xyz
   basis = STO-3G
   Group = C1

  &SEWARD; &SCF

  &GRID_IT
   All

Now, execute the |molcas| program: ::

  molcas SCF.energy_grid.CH4.input -f

.. compound::

  In the :file:`$WorkDir` and :file:`$PWD` directories a new file is generated, :file:`CH4.lus` which
  contains the information required by the :program:`GRID_IT` input. The file can
  be visualized by :program:`LUSCUS` (Open source program, which can be downloaded and
  installed to your Linux, Windows, or MacOS workstation or laptop). By typing the command: ::

    luscus CH4.lus

  a window will be opened displaying the molecule and its charge density. By proper
  selection of options with the mouse buttons, the shape and size of several molecular orbitals
  can be visualized.

:program:`GRID_IT` can also be run separately, if an orbital file is specified in
the input, and the :file:`$WorkDir` directory is available.

More information can be found in :numref:`UG:sec:gridit`.

As an alternative to running a specific project, the short script provided below can be placed
in the directory :file:`$MOLCAS/doc/samples/problem_based_tutorials` with the name :file:`project.sh`.
Simply execute the shell script, :command:`project.sh $Project`, where :command:`$Project` is the |molcas| input,
and output files, error files, and a :file:`$WorkDir` directory called :file:`$Project.work` will be obtained.

.. extractfile:: problem_based_tutorials/project.sh

  #!/bin/bash

  export MOLCAS=$PWD
  export MOLCAS_DISK=2000
  export MOLCAS_MEM=64
  export MOLCAS_PRINT=3

  export Project=$1
  export HomeDir=$MOLCAS/doc/samples/problem_based_tutorials
  export WorkDir=$HomeDir/$Project.work
  mkdir $WorkDir 2>/dev/null
  molcas $HomeDir/$1 >$HomeDir/$Project.log 2>$HomeDir/$Project.err
  exit

In order to run a Kohn--Sham density functional calculation, |molcas| uses the
same :program:`SCF` module, and, therefore, the only change needed are the specification
of the DFT option and required functional (e.g. B3LYP) in the :program:`SCF` input:

.. extractfile:: problem_based_tutorials/DFT.energy.CH4.input

  *DFT energy for CH4 at a fixed nuclear geometry plus a grid for visualization.
  *File: DFT.energy.CH4
  *
  &GATEWAY
   Title = CH4 molecule
   coord = CH4.xyz
   basis = STO-3G
   group = C1
  &SEWARD
  &SCF
   KSDFT = B3LYP
  &GRID_IT
   All

Similar graphical files can be found in :file:`$WorkDir` and :file:`$PWD`.

The next step is to obtain the second-order Møller--Plesset perturbation (MP2)
energy for methane at the same molecular geometry using the same one-electron
basis set. Program :program:`MBPT2` is now used, and it is possible to take
advantage of having previously computed the proper integrals with :program:`SEWARD`
and the reference closed-shell HF wave function with the :program:`SCF` program.
In such cases, it is possible to keep the same definitions as before and simply prepare a file
containing the :program:`MBPT2` input and run it using the :command:`molcas`
command.

The proper intermediate file will be already in :file:`$WorkDir`.
On the other hand, one has to start from scratch, all required inputs should
be placed sequentially in the :file:`MP2.energy.CH4` file.
If the decision is to start the project from the beginning, it is probably a good idea to remove
the entire :file:`$WorkDir` directory, unless it is known for certain the exact nature of the files contained in this directory.

.. extractfile:: problem_based_tutorials/MP2.energy.CH4.input

  *MP2 energy for CH4 at a fixed nuclear geometry.
  *File: MP2.energy.CH4
  *
  &GATEWAY
   Title = CH4 molecule
   coord = CH4.xyz
   basis = STO-3G
   group = C1
  &SEWARD
  &SCF
  &MBPT2
   Frozen = 1

In addition to the calculation of a HF wave function, an MP2 calculation has been performed with
a frozen deepest orbital, the carbon 1s, of :math:`\ce{CH4}`. Information about the output
of the :program:`MBPT2` program can be found on :numref:`TUT:sec:mbpt2`.

.. compound::

  The :program:`SCF` program works by default with closed-shell systems with an
  even number of electrons at the Restricted Hartee--Fock (RHF) level. If,
  instead there is a need to use the Unrestricted Hartree--Fock (UHF) method, this can be schieved by invoking the
  keyword :kword:`UHF`. This is possible for both even and odd electron systems.
  For instance, in a system with an odd number of electrons such as the :math:`\ce{CH3}` radical, with the
  following Cartesian coordinates

  .. extractfile:: problem_based_tutorials/CH3.xyz

    4
    CH3 coordinates in Angstrom
    C    0.000000     0.000000     0.000000
    H    0.000000     0.000000     1.050000
    H    1.037090     0.000000    -0.366667
    H   -0.542115    -0.938971    -0.383333

  the input to run an open-shell UHF calculation is easily obtained:

.. extractfile:: problem_based_tutorials/SCF.energy_UHF.CH3.input

  *SCF/UHF energy for CH3 at a fixed nuclear geometry
  *File: SCF.energy_UHF.CH3
  *
  &GATEWAY
   Title = CH3 molecule
   coord = CH3.xyz
   basis = STO-3G
   group = C1
  &SEWARD
  &SCF
   UHF

If the system is charged, this must be indicated in the
:program:`SCF` input, for example, by computing the cation of the :math:`\ce{CH4}` molecule
at the UHF level:

.. extractfile:: problem_based_tutorials/SCF.energy_UHF.CH4plus.input

  *SCF/UHF energy for CH4+ at a fixed nuclear geometry
  *File: SCF.energy_UHF.CH4plus
  *
  &GATEWAY
   Title = CH4+ molecule
   coord = CH4.xyz
   basis = STO-3G
   group = c1
  &SEWARD
  &SCF
   UHF
   Charge = +1

The Kohn--Sham DFT calculation can be also run using the UHF algorithm:

.. extractfile:: problem_based_tutorials/DFT.energy.CH4plus.input

  *DFT/UHF energy for CH4+ at a fixed nuclear geometry
  *File: DFT.energy.CH4plus
  *
  &GATEWAY
   Title = CH4+ molecule
   coord = CH4.xyz
   basis = STO-3G
   group = C1
  &SEWARD
  &SCF
   KSDFT = B3LYP
   UHF
   Charge = +1

For the UHF and UHF/DFT methods it is also possible to specify
:math:`\alpha` and :math:`\beta` orbital occupations in two ways.

#. First, the keyword :kword:`ZSPIn` can be invoked in the :program:`SCF` program, which represents the
   difference between the number of :math:`\alpha` and :math:`\beta` electrons.

   For example, setting the keyword to 2 forces the program to converge to a result with two more :math:`\alpha` than :math:`\beta` electrons.

   .. extractfile:: problem_based_tutorials/DFT.energy_zspin.CH4.input

     *DFT/UHF energy for different electronic occupation in CH4 at a fixed nuclear geometry
     *File: DFT.energy_zspin.CH4
     *
     &GATEWAY
      Title = CH4 molecule
      coord = CH4.xyz
      basis = STO-3G
      group = c1
     &SEWARD
     &SCF
      Title = CH4 molecule zspin 2
      UHF; ZSPIN = 2
      KSDFT = B3LYP

   The final occupations in the output will show six :math:`\alpha` and four :math:`\beta` orbitals.

#. Alternatively, instead of :kword:`ZSPIn`, it is possible to specify
   occupation numbers with keyword :kword:`Occupation` at the beginning of the SCF calculation.

   This requires an additional input line containing the occupied :math:`\alpha` orbitals (e.g. 6 in this case), and a second line
   with the :math:`\beta` orbitals (e.g. 4 in this case). Sometimes, SCF convergence may be improved by using this option.

Different sets of methods use other |molcas| modules. For example, to perform a Complete
Active Space (CAS) SCF calculation, the :program:`RASSCF` program has to be used. This
module requires starting trial orbitals, which can be obtained from a previous SCF
calculation or, automatically, from the :program:`SEWARD` program which provides trial orbitals by
using a model Fock operator.

Recommended keywords are

* :kword:`Nactel` defines the total number of active
  electrons, holes in Ras1, and particles in Ras3, respectively. The last two values
  are only for RASSCF-type calculations.
* :kword:`Inactive` indicates the number of inactive orbitals where the occupation is always 2 in the CASSCF reference, and
* :kword:`Ras2` defines the number of active orbitals.

By default, the wave function for the lowest state corresponds to the symmetry with spin multiplicity of 1.
Most of the input may not be necessary, if one has prepared and linked an INPORB file with the different orbital types defined by
a program like :program:`LUSCUS`.

.. extractfile:: problem_based_tutorials/CASSCF.energy.CH4.input

  *CASSCF energy for CH4 at a fixed nuclear geometry
  *File: CASSCF.energy.CH4
  *
  &GATEWAY
   coord = CH4.xyz
   basis = STO-3G
   group = C1
  &SEWARD
  &RASSCF
   Title = CH4 molecule
   Spin = 1; Nactel = 8 0 0; Inactive = 1; Ras2 = 8
  &GRID_IT
   All

In this case, the lowest singlet state (i.e. the ground dstate) is computed, since this is a
closed-shell situation with an active space of eight electrons in eight orbitals and
with an inactive C 1s orbital, the lowest orbital of the :math:`CH4` molecule. This is a CASSCF example in which all the valence
orbitals and electrons (C 2s, C 2p and 4 |x| H 1s) are included
in the active space and allows complete dissociation into
atoms. If this is not the goal, then the three almost degenerate
highest energy occupied orbitals and the corresponding antibonding unoccupied orbitalsmust be active, leading to
a 6 in 6 active space.

Using the CASSCF wave function as a reference, it is possible to perform a second-order
perturbative, CASPT2, correction to the electronic energy by employing the
:program:`CASPT2` program. If all previously calculated files are retained in the
:file:`$WorkDir` directory, in particular, integral files (:file:`CH4.OneInt`, :file:`CH4.OrdInt`),
the CASSCF wave function information file (:file:`CH4.JobIph`), and communication file :file:`CH4.RunFile`), it will not be
necessary to re-run programs :program:`SEWARD`, and :program:`RASSCF`. In this case
case, it is enough to prepare a file containing input only for the :program:`CASPT2` program followed be execution.
Here, however, for the sake of completness, input to all |molcas| modules is provided:

.. extractfile:: problem_based_tutorials/CASPT2.energy.CH4.input

  *CASPT2 energy for CH4 at a fixed nuclear geometry
  *File: CASPT2.energy.CH4
  *
  &GATEWAY
   coord = CH4.xyz; basis = STO-3G; group = C1
  &SEWARD
  &RASSCF
     LumOrb
     Spin = 1; Nactel = 8 0 0; Inactive = 1; Ras2 = 8
  &CASPT2
   Multistate = 1 1

In most of cases, the Hartree--Fock orbitals will be a better choice as starting orbitals.
In that case, the :program:`RASSCF` input has to include keyword :kword:`LumOrb` to read
from any external source of orbitals other than those generated by the :program:`SEWARD` program.
By modifying input to the :program:`SCF` program, it is possible to generate
alternative trial orbitals for the :program:`RASSCF` program. Since a new set of trial orbitals is used,
the input to the :program:`RASSCF` program is also changed. Now, the number of
active orbitals, as well as the number of active electrons, are 6.

The two lowest orbitals (:kword:`Inactive` 2) are excluded from the active space
and one other orbital is placed in the secondary space.
If the previous (8,8) full valence space was used,
the :program:`CASPT2` program would not be able to include more electronic correlation energy,
considering that the calculation involves a minimal basis set.
The input for the :program:`CASPT2` program includes a frozen C 1s orbital, the lowest orbital
in the :math:`\ce{CH4}` molecule.

The charge and multiplicity of our wave function can be changed by computing the
:math:`\ce{CH4^+}` cation with the same methods. The :program:`RASSCF` program defines
the character of the problem by specifying the number of electrons, the spin multiplicity, and the spatial
symmetry. In the example below, there is one less electron giving rise to doublet multiplicity:

.. extractfile:: problem_based_tutorials/CASSCF.energy.CH4plus.input

  *CASSCF energy for CH4+ at a fixed nuclear geometry
  *File: CASSCF.energy.CH4plus
  *
  &GATEWAY
   Title = CH4+ molecule
   coord = CH4.xyz; basis = STO-3G; Group = C1
  &SEWARD
  &RASSCF
   Spin = 2; Nactel = 7 0 0; Inactive = 1; Ras2 = 8

No further modification is needed to the :program:`CASPT2` input:

.. extractfile:: problem_based_tutorials/CASPT2.energy.CH4plus.input

  *CASPT2 energy for CH4+ at a fixed nuclear geometry
  *File: CASPT2.energy.CH4plus
  *
  &GATEWAY
   coord = CH4.xyz; basis = STO-3G; group = C1
  &SEWARD
  &RASSCF
   Title = CH4+ molecule
   Spin = 2; Nactel = 1 0 0; Inactive = 4; Ras2 = 1
  &CASPT2

A somewhat more sophisticated calculation can be performed at the
Restricted Active Space (RAS) SCF level. In such a situation, the level of excitation
in the CI expansion can be controlled by restricting the number of holes
and particles present in certain orbitals.

.. extractfile:: problem_based_tutorials/RASSCF.energy.CH4.input

  *RASSCF energy for CH4 at a fixed nuclear geometry
  *File: RASSCF.energy.CH4
  *
  &GATEWAY
   coord = CH4.xyz; basis = STO-3G; group = C1
  &SEWARD
  &RASSCF
   Title = CH4 molecule
   Spin = 1; Nactel = 8 1 1
   Inactive = 1; Ras1 = 1; Ras2 = 6; Ras3 = 1

In particular, the previous calculation includes one orbital within the Ras1
space and one orbital within the Ras3 space. One hole (single excitation) at
maximum is allowed from Ras1 to Ras2 or Ras3, while a maximum of one particle
is allowed in Ras3, derived from either Ras1 or Ras2. Within Ras2, all types
of orbital occupations are allowed. The RASSCF wave functions can be used
as reference for multiconfigurational perturbation theory (RASPT2), but
this approach has not been as extensively tested as CASPT2, and, so experience is
still somewhat limited.

|molcas| also has the possibility of computing electronic energies at
different CI levels by using the :program:`MRCI` program. The input provided below involves
a Singles and Doubles Configuration Interaction (SDCI) calculation on the :math:`\ce{CH4}` molecule.
To set up the calculations, program :program:`MOTRA` which transforms
the integrals to molecular basis, and program :program:`GUGA` which computes the
coupling coefficients, must be run before the :program:`MRCI` program.
In :program:`MOTRA` the reference orbitals are specifiedi, and those employed
here are from an HF :program:`SCF` calculation including frozen orbitals. In :program:`GUGA`
the reference for the CI calculation is described by the number of correlated electrons,
the spatial and spin symmetry, the inactive orbitals always occupation 2 in
the reference space, and the type of CI expansion.

.. extractfile:: problem_based_tutorials/SDCI.energy.CH4.input

  *SDCI energy for CH4 at a fixed nuclear geometry
  *File: SDCI.energy.CH4
  *
  &GATEWAY
   coord = CH4.xyz; basis = STO-3G; group = c1
  &SEWARD
  &SCF
  &MOTRA
   Lumorb
   Frozen= 1
  &GUGA
   Electrons = 8
   Spin = 1
   Inactive= 4
   Active= 0
   Ciall= 1
  &MRCI
   SDCI

To use reference orbitals from a previous CASSCF calculation, the
:program:`RASSCF` program will have to be run before the :program:`MOTRA`
module. Also, if the spatial or spin symmetry are changed for the CI
calculation, the modifications will be introduced in the input to :program:`GUGA` program.
Many alternatives are possible for performing an MRCI calculation as shown in the next example below,
in which the reference space to perform the CI is multiconfigurational:

.. extractfile:: problem_based_tutorials/MRCI.energy.CH4.input

  *MRCI energy for CH4 at a fixed nuclear geometry
  *File: MRCI.energy.CH4
  *
  &GATEWAY
   Title = CH4 molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
  &SEWARD
  &SCF
  &RASSCF
   LumOrb
   Spin= 1; Nactel= 6 0 0; Inactive= 2; Ras2= 6
  &MOTRA
   Lumorb
   Frozen= 1
  &GUGA
   Electrons= 8
   Spin= 1
   Inactive= 2
   Active= 3
   Ciall= 1
  &MRCI
   SDCI

The :program:`MRCI` program also allows the calculation of electronic energies using the
ACPF method. Another |molcas| program, :program:`CPF`, offers the possibility to
use the CPF, MCPF, and ACPF methods with a single reference function. The
required input is quite similar to that for the :program:`MRCI` program:

.. extractfile:: problem_based_tutorials/CPF.energy.CH4.input

  *CPF energy for CH4 at a fixed nuclear geometry
  *File: CPF.energy.CH4
  *
  &GATEWAY
   Title= CH4 molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
  &SEWARD
  &SCF
  &MOTRA
   Lumorb
   Frozen= 1
  &GUGA
   Electrons= 8
   Spin = 1
   Inactive = 4
   Active = 0
   Ciall= 1
  &CPF
   CPF
  End Of Input

Finally, |molcas| can also perform closed- and open-shell coupled cluster
calculations at the CCSD and CCSD(T) levels. These calculations are controlled by
the :program:`CCSDT` program, whose main requirement is that the reference
function has to be generated with the :program:`RASSCF` program. The following input is
required to obtain a CCSD(T) energy for the :math:`\ce{CH4}` molecule:

.. extractfile:: problem_based_tutorials/CCSDT.energy.CH4.input

  *CCSDT energy for CH4 at a fixed nuclear geometry
  *File: CCSDT.energy.CH4
  *
  &GATEWAY
   Title= CH4 molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
  &SEWARD
  &RASSCF
   Spin= 1; Nactel= 0 0 0; Inactive= 5; Ras2= 0
   OutOrbitals
   Canonical
  &MOTRA
   JobIph
   Frozen= 1
  &CCSDT
   CCT

Since this is a closed-shell calculation, the :program:`RASSCF` input
computes a simple RHF wave function with zero active electrons and orbitals using
keywords :kword:`OutOrbitals` and :kword:`Canonical`. The :program:`MOTRA` must
include the keyword :kword:`JobIph` to extract the wave function information
from file :file:`JOBIPH` which is automatically generated by :program:`RASSCF`. Finally,
the keywork :kword:`CCT` in program :program:`CCSDT` leads to the calculation of the
CCSD(T) energy using the default algorithms.

The :program:`CCSDT` program in |molcas| is especially suited to compute open-shell
cases. The input required to obtain the electronic energy of the :math:`\ce{CH4^+}` cation
with the CCSD(T) method is:

.. extractfile:: problem_based_tutorials/CCSDT.energy.CH4plus.input

  *CCSDT energy for CH4+ at a fixed nuclear geometry
  *File: CCSDT.energy.CH4plus
  *
  &GATEWAY
   Title= CH4+ molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
  &SEWARD
  &RASSCF
   Spin= 2; Nactel= 1 0 0; Inactive= 4; Ras2= 1
   OutOrbitals
   Canonical
  &MOTRA
   JobIph
   Frozen= 1
  &CCSDT
   CCT

where the :program:`RASSCF` program generated the proper Restricted Open-Shell
Hartree--Fock (ROHF) reference. Different levels of spin adaptation are also available.

If solvent effects are desired, |molcas| includes two
models: Kirkwood and PCM. Adding a solvent effect to a ground state at HF, DFT, or CASSCF levels,
simply requires the inclusion of the keyword :kword:`RF-input` within the input for the :program:`SEWARD`
which calculates a self-consistend reaction field.

.. extractfile:: problem_based_tutorials/DFT.energy_solvent.CH4.input

  *DFT energy for CH4 in water at a fixed nuclear geometry
  *File: DFT.energy_solvent.CH4
  *
  &GATEWAY
   Title= CH4 molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
   RF-input
     PCM-model; solvent= water
   End of RF-input
  &SEWARD
  &SCF
  KSDFT= B3LYP

Other programs such as :program:`CASPT2`, :program:`RASSI`, and :program:`MOTRA` require that
the reaction field is included as a perturbation with keyword :kword:`RFPErturbation`.
In the next example the correction is added at both the CASSCF and CASPT2 levels.

.. extractfile:: problem_based_tutorials/CASPT2.energy_solvent.CH4.input

  *CASPT2 energy for CH4 in acetone at a fixed nuclear geometry
  *File: CASPT2.energy_solvent.CH4
  *
  &GATEWAY
   Title= CH4 molecule
   coord = CH4.xyz; basis = STO-3G; group = c1
    RF-input
     PCM-model; solvent= acetone; AAre= 0.2
    End of RF-input
  &SEWARD
  &RASSCF
    Spin= 1; Nactel= 6 0 0; Inactive= 2; Ras2= 6
  &CASPT2
   Frozen= 1
   Multistate= 1 1
   RFPert

Notice that the tesserae of the average area in the PCM model (keyword
has been changed to the value required for acetone by the keyword :kword:`Aare`,
while the default is 0.4 Å:math:`^2` for water
(see :numref:`UG:sec:rfield`).
More detailed examples can be found in :numref:`TUT:sec:cavity`.
Computing Excited States
========================

The calculation of electronic excited states is typically a multiconfigurational problem, and
therefore it should preferably be treated with multiconfigurational methods such as CASSCF and
CASPT2. We can start this section by computing the low-lying electronic states of the
acrolein molecule at the CASSCF level and using a minimal
basis set. The standard file with cartesian coordinates is:

.. extractfile:: problem_based_tutorials/acrolein.xyz

  8
  Angstrom
   O      -1.808864   -0.137998    0.000000
   C       1.769114    0.136549    0.000000
   C       0.588145   -0.434423    0.000000
   C      -0.695203    0.361447    0.000000
   H      -0.548852    1.455362    0.000000
   H       0.477859   -1.512556    0.000000
   H       2.688665   -0.434186    0.000000
   H       1.880903    1.213924    0.000000

We shall carry out State-Averaged (SA) CASSCF calculations, in which one single
set of molecular orbitals is used to compute all the states of a given spatial
and spin symmetry. The obtained density matrix is the average for all states
included, although each state will have its own set of optimized CI
coefficients. Different weights can be considered for each of the states,
but this should not be used except in very special cases by experts. It is
better to let the CASPT2 method to handle that. The use of a SA-CASSCF
procedure has an great advantage. For example, all states in a SA-CASSCF
calculation are orthogonal to each other, which is not necessarily true for
state specific calculations. Here, we shall include five states of singlet
character the calculation. As no symmetry is invoked all the states belong by
default to the first symmetry, including the ground state.

.. extractfile:: problem_based_tutorials/CASSCF.excited.acrolein.input

  *CASSCF SA calculation on five singlet excited states in acrolein
  *File: CASSCF.excited.acrolein
  *
  &GATEWAY
    Title= Acrolein molecule
    coord = acrolein.xyz; basis = STO-3G; group = c1
  &SEWARD; &SCF
  &RASSCF
    LumOrb
    Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
    CiRoot= 5 5 1
  &GRID_IT
    All

We have used as active all the :math:`\pi` and :math:`\pi^*` orbitals, two bonding and
two antibonding :math:`\pi` orbitals with four electrons and in addition the oxygen
lone pair (:math:`n`). Keyword :kword:`CiRoot` informs the program that we want to
compute a total of five states, the ground state and the lowest four excited
states at the CASSCF level and that all of them should have the same weight in
the average procedure. Once analyzed we find that the calculation has provided,
in this order, the ground state, two :math:`n\to\pi^*` states, and two :math:`\pi\to\pi^*` states.
It is convenient to add the :program:`GRID_IT` input in order to be able to use
the :program:`LUSCUS` interface for the analysis of the orbitals and the occupations
in the different electronic states. Such an analysis should always be made in
order to understand the nature of the different excited states.
In order to get a more detailed analysis of the nature of the obtained states it is
also possible to obtain in a graphical way the charge density differences between
to states, typically the difference between the ground and an excited state. The
following example creates five different density files:

.. extractfile:: problem_based_tutorials/CASSCF.excited_grid.acrolein.input

  *CASSCF SA calculation on five singlet excited states in acrolein
  *File: CASSCF.excited_grid.acrolein
  *
  &GATEWAY
    Title= Acrolein molecule
    coord= acrolein.xyz; basis= STO-3G; group= c1
  &SEWARD; &SCF
  &RASSCF
   LumOrb
   Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
   CiRoot= 5 5 1
   OutOrbital
   Natural= 5
  &GRID_IT
   FILEORB = $Project.RasOrb.1
   NAME = 1; All
  &GRID_IT
   FILEORB = $Project.RasOrb.2
   NAME = 2; All
  &GRID_IT
   FILEORB = $Project.RasOrb.3
   NAME = 3; All
  &GRID_IT
   FILEORB = $Project.RasOrb.4
   NAME = 4; All
  &GRID_IT
   FILEORB = $Project.RasOrb.5
   NAME = 5; All

In :program:`GRID_IT` input we have included all orbitals. It is, however,
possible and in general recommended to restrict the calculation to certain
sets of orbitals. How to do this is described in the input manual for
:program:`GRID_IT`.

Simple math operations can be performed with grids of the same size,
for example, :program:`LUSCUS` can be used to display the difference
between two densities.

CASSCF wave functions are typically good enough, but this is not the case for
electronic energies, and the dynamic correlation effects have to be included,
in particular here with the CASPT2 method. The proper input is prepared, again
including :program:`SEWARD` and :program:`RASSCF` (unnecessary if they were
computed previously), adding a :program:`CASPT2` input with the keyword
:kword:`MultiState` set to 5 1 2 3 4 5. The :program:`CASPT2` will perform four
consecutive single-state (SS) CASPT2 calculations using the SA-CASSCF roots computed
by the :program:`RASSCF` module. At the end, a multi-state CASPT2 calculation
will be added in which the five SS-CASPT2 roots will be allowed to interact.
The final MS-CASPT2 solutions, unlike the previous SS-CASPT2 states, will be
orthogonal. The :kword:`FROZen` keyword is put here as a reminder. By
default the program leaves the core orbitals frozen.

.. extractfile:: problem_based_tutorials/CASPT2.excited.acrolein.input

  *CASPT2 calculation on five singlet excited states in acrolein
  *File: CASPT2.excited.acrolein
  *
  &GATEWAY
   Title= Acrolein molecule
   coord = acrolein.xyz; basis = STO-3G; group= c1
  &SEWARD; &SCF
  &RASSCF
   Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
   CiRoot= 5 5 1
  &GRID_IT
   All
  &CASPT2
   Multistate= 5 1 2 3 4 5
   Frozen= 4

Apart from energies and state properties it is quite often necessary to compute
state interaction properties such as transition dipole moments, Einstein coefficients,
and many other. This can be achieved with the :program:`RASSI` module, a powerful
program which can be used for many purposes
(see :numref:`UG:sec:rassi`). We can
start by simply computing the basic interaction properties

.. extractfile:: problem_based_tutorials/CASSI.excited.acrolein.input

  *RASSI calculation on five singlet excited states in acrolein
  *File: RASSI.excited.acrolein
  *
  &GATEWAY
   Title= Acrolein molecule
   coord = acrolein.xyz; basis = STO-3G; group = c1
  &SEWARD; &SCF
  &RASSCF
   LumOrb
   Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
   CiRoot= 5 5 1
  &CASPT2
   Frozen = 4
   MultiState= 5 1 2 3 4 5

  >>COPY $Project.JobMix JOB001

  &RASSI
   Nr of JobIph
   1 5
   1 2 3 4 5
   EJob

Oscillator strengths for the computed transitions and Einstein coefficients are
compiled at the end of the :program:`RASSI` output file. To obtain these values,
however, energy differences have been used which are obtained from the previous
CASSCF calculation. Those energies are not accurate because they do not include
dynamic correlation energy and it is better to substitute them by properly
computed values, such those at the CASPT2 level. This is achieved with the
keyword :kword:`Ejob`.
More information is available
in :numref:`TUT:sec:rassi_thio`.

Now a more complex case. We want to compute vertical singlet-triplet gaps from
the singlet ground state of acrolein to different, up to five, triplet excited
states. Also, interaction properties are requested. Considering that the spin
multiplicity differs from the ground to the excited states, the spin Hamiltonian
has to be added to our calculations and the :program:`RASSI` program takes charge
of that. It is required first, to add in the :program:`SEWARD` input the keyword
:kword:`AMFI`, which introduces the proper integrals required, and to the
:program:`RASSI` input the keyword :kword:`SpinOrbit`. Additionally, as we want
to perform the calculation sequentially and :program:`RASSI` will read from
two different wave function calculations, we need to perform specific links
to save the information. The link to the first :program:`CASPT2` calculation
will saved in file :file:`$Project.JobMix.S` the data from the :program:`CASPT2`
result of the ground state, while the second link before the second :program:`CASPT2`
run will do the same for the triplet states. Later, we link these files as
:file:`JOB001` and :file:`JOB002` to become input files for :program:`RASSI`.
In the :program:`RASSI` input :kword:`NrofJobIph` will be set to two, meaning
two :file:`JobIph` or :file:`JobMix` files, the first containing one root (the ground
state) and the second five roots (the triplet states). Finally, we have added
:kword:`EJob`, which will read the CASPT2 (or MS-CASPT2) energies from the
:file:`JobMix` files to be incorporated to the :program:`RASSI` results.
The magnitude of properties computed with spin-orbit coupling (SOC) depends
strongly on the energy gap, and this has to be computed at the highest possible
level, such as CASPT2.

.. extractfile:: problem_based_tutorials/CASPT2.S-T_gap.acrolein.input

  *CASPT2/RASSI calculation on singlet-triplet gaps in acrolein
  *File: CASPT2.S-T_gap.acrolein
  *
  &GATEWAY
   Title= Acrolein molecule
   coord = acrolein.xyz; basis = STO-3G; group= c1
  &SEWARD
   AMFI
  &SCF
  &RASSCF
   Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
   CiRoot= 1 1 1
  &CASPT2
   Frozen= 4
   MultiState= 1 1
  >>COPY $Project.JobMix JOB001
  &RASSCF
   LumOrb
   Spin= 3; Nactel= 6 0 0; Inactive= 12; Ras2= 5
   CiRoot= 5 5 1
  &CASPT2
   Frozen= 4
   MultiState= 5 1 2 3 4 5
  >>COPY $Project.JobMix JOB002
  &RASSI
   Nr of JobIph= 2 1 5; 1; 1 2 3 4 5
   Spin
   EJob

As here with keyword :kword:`AMFI`,
when using command :kword:`Coord` to build a :program:`SEWARD` input
and we want to introduce other keywords, it is enough if we place them
after the line corresponding to :kword:`Coord`.
Observe that the nature of the triplet states obtained is in sequence one
:math:`n\pi^*`, two :math:`\pi\pi^*`, and two :math:`n\pi^*`. The :program:`RASSI` output is
somewhat complex to analyze, but it makes tables summarizing oscillator
strengths and Einstein coefficients, if those are the magnitudes of interest.
Notice that a table is first done with the spin-free states, while the final
table include the spin-orbit coupled eigenstates (in the CASPT2 energy order
here), in which each former triplet state has three components.

In many cases working with symmetry will help us to perform calculations
in quantum chemistry. As it is a more complex and delicate problem we direct
the reader to the examples section in this manual. However, we include here
two inputs that can help the beginners. They are based on trans-1,3-butadiene,
a molecule with a :math:`C_{2h}` ground state. If we run the next input, the
:program:`SEWARD` and :program:`SCF` outputs will help us to understand how
orbitals are classified by symmetry, whereas reading the :program:`RASSCF` output
the structure of the active space and states will be clarified.

.. extractfile:: problem_based_tutorials/CASSCF.excited.tButadiene.1Ag.input

  *CASSCF SA calculation on 1Ag excited states in tButadiene
  *File: CASSCF.excited.tButadiene.1Ag
  *
  &SEWARD
    Title= t-Butadiene molecule
    Symmetry= Z XYZ
  Basis set
  C.STO-3G...
  C1   -3.2886930 -1.1650250 0.0000000  Bohr
  C2   -0.7508076 -1.1650250 0.0000000  Bohr
  End of basis
  Basis set
  H.STO-3G...
  H1   -4.3067080  0.6343050 0.0000000  Bohr
  H2   -4.3067080 -2.9643550 0.0000000  Bohr
  H3    0.2672040 -2.9643550 0.0000000  Bohr
  End of basis

  &SCF

  &RASSCF
   LumOrb
   Title= tButadiene molecule (1Ag states). Symmetry order (ag bg bu au)
   Spin= 1; Symmetry= 1; Nactel= 4 0 0; Inactive= 7 0 6 0; Ras2= 0 2 0 2
   CiRoot= 4 4 1

  &GRID_IT
   All

Using the next input will give information about states of a different symmetry.
Just run it as a simple exercise.

.. extractfile:: problem_based_tutorials/CASSCF.excited.tButadiene.1Bu.input

  *CASSCF SA calculation on 1Bu excited states in tButadiene
  *File: CASSCF.excited.tButadiene.1Bu
  *
  &SEWARD
   Title= t-Butadiene molecule
   Symmetry= Z XYZ
  Basis set
  C.STO-3G...
  C1   -3.2886930 -1.1650250 0.0000000  Bohr
  C2   -0.7508076 -1.1650250 0.0000000  Bohr
  End of basis
  Basis set
  H.STO-3G...
  H1   -4.3067080  0.6343050 0.0000000  Bohr
  H2   -4.3067080 -2.9643550 0.0000000  Bohr
  H3    0.2672040 -2.9643550 0.0000000  Bohr
  End of basis

  &SCF

  &RASSCF
   FileOrb= $Project.ScfOrb
   Title= tButadiene molecule (1Bu states). Symmetry order (ag bg bu au)
   Spin= 1; Symmetry= 1; Nactel= 4 0 0; Inactive= 7 0 6 0
   Ras2= 0 2 0 2
   CiRoot= 4 4 1
  >COPY $Project.RasOrb $Project.1Ag.RasOrb
  >COPY $Project.JobIph JOB001

  &GRID_IT
   Name= $Project.1Ag.lus
   All

  &RASSCF
   FileOrb= $Project.ScfOrb
   Title= tButadiene molecule (1Bu states). Symmetry order (ag bg bu au)
   Spin= 1; Symmetry= 3; Nactel= 4 0 0; Inactive= 7 0 6 0; Ras2= 0 2 0 2
   CiRoot= 2 2 1
  >COPY $Project.RasOrb $Project.1Bu.RasOrb
  >COPY $Project.JobIph JOB002

  &GRID_IT
   Name= $Project.1Bu.lus
   All

  &RASSI
   NrofJobIph= 2 4 2; 1 2 3 4; 1 2

Structure optimizations can be also performed at the CASSCF, RASSCF or CASPT2
levels. Here we shall optimize the second singlet state in the first (here the
only) symmetry for acrolein at the SA-CASSCF level. It is strongly recommended
to use the State-Average option and avoid single state CASSCF calculations for
excited states. Those states are non-orthogonal with the ground state and
are typically heavily contaminated. The usual set of input commands will be
prepared, with few changes. In the :program:`RASSCF` input two states will
be simultaneously computed with equal weight (:kword:`CiRoot` 2 2 1), but,
in order to get accurate gradients for a specific root (not an averaged one),
we have to add :kword:`Rlxroot` and set it to two, which is, among the
computed roots, that we want to optimize. The proper density matrix will be
stored. The :program:`MCLR` program optimizes, using a perturbative approach,
the orbitals for the specific root (instead of using averaged orbitals), but
the program is called automatically and no input is needed.

.. extractfile:: problem_based_tutorials/CASSCF.excited_state_optimization.acrolein.input

  *CASSCF excited state optimization in acrolein
  *File: CASSCF.excited_state_optimization.acrolein
  *
   &GATEWAY
  Title= acrolein minimum optimization in excited state 2
  Basis set
  O.STO-3G...2s1p.
  O1       1.608542      -0.142162       3.240198 Angstrom
  End of basis
  Basis set
  C.STO-3G...2s1p.
  C1      -0.207776       0.181327      -0.039908 Angstrom
  C2       0.089162       0.020199       1.386933 Angstrom
  C3       1.314188       0.048017       1.889302 Angstrom
  End of basis
  Basis set
  H.STO-3G...1s.
  H1       2.208371       0.215888       1.291927 Angstrom
  H2      -0.746966      -0.173522       2.046958 Angstrom
  H3      -1.234947       0.213968      -0.371097 Angstrom
  H4       0.557285       0.525450      -0.720314 Angstrom
  End of basis
  >>> Do while

   &SEWARD

  >>> If ( Iter = 1 ) <<<

   &SCF
  Title= acrolein minimum optimization

  >>> EndIf <<<

   &RASSCF
  LumOrb
  Title= acrolein
  Spin= 1; nActEl= 4 0 0; Inactive= 13; Ras2= 4
  CiRoot= 2 2 1
  Rlxroot= 2

   &SLAPAF

  >>> EndDo

In case of performing a :program:`CASPT2` optimization for an excited
state, still the SA-CASSCF approach can be used to generate the reference
wave function, but keyword :kword:`Rlxroot` and the use of the :program:`MCLR` program
are not necessary, because :program:`CASPT2` takes care of selecting
the proper root (the last one).

A very useful tool recently included in |molcas| is the possibility to
compute minimum energy paths (MEP), representing steepest descendant minimum
energy reaction paths which are built through a series of geometry optimizations,
each requiring the minimization of the potential energy on a hyperspherical
cross section of the PES centered on a given reference geometry and characterized
by a predefined radius. One usually starts the calculation from a high energy reference
geometry, which may correspond to the Franck--Condon (FC) structure on an excited-state PES
or to a transition structure (TS). Once the first lower energy optimized structure is
converged, this is taken as the new hypersphere center, and the procedure is iterated
until the bottom of the energy surface is reached. Notice that in the TS case a pair of
steepest descent paths, connecting the TS to the reactant and product structures
(following the forward and reverse orientation of the direction defined by the transition
vector) provides the minimum energy path (MEP) for the reaction. As mass-weighted
coordinates are used by default, the MEP coordinate corresponds to the so-called Intrinsic
Reaction Coordinates (IRC). We shall compute here the MEP from the FC structure of acrolein
along the PES of the second root in energy at the CASSCF level. It is important to remember
that the CASSCF order may not be accurate and the states may reverse orders at higher
levels such as CASPT2.

.. extractfile:: problem_based_tutorials/CASSCF.mep_excited_state.acrolein.input

  *CASSCF excited state mep points in acrolein
  *File: CASSCF.mep_excited_state.acrolein
  *
   &GATEWAY
  Title = acrolein mep calculation root 2
  Basis set
  O.STO-3G...2s1p.
   O1    1.367073     0.000000     3.083333 Angstrom
  End of basis
  Basis set
  C.STO-3G...2s1p.
   C1    0.000000     0.000000     0.000000 Angstrom
   C2    0.000000     0.000000     1.350000 Angstrom
   C3    1.367073     0.000000     1.833333 Angstrom
  End of basis
  Basis set
  H.STO-3G...1s.
   H1    2.051552     0.000000     0.986333 Angstrom
   H2   -0.684479     0.000000     2.197000 Angstrom
   H3   -1.026719     0.000000    -0.363000 Angstrom
   H4    0.513360     0.889165    -0.363000 Angstrom
  End of basis

  >>> EXPORT MOLCAS_MAXITER=300
  >>> Do while

   &SEWARD
  >>> If ( Iter = 1 ) <<<
   &SCF
  >>> EndIf <<<

   &RASSCF
     Title="acrolein mep calculation root 2"; Spin=1
     nActEl=4 0 0; Inactive=13; Ras2=4; CiRoot=2 2 1; Rlxroot=2
   &SLAPAF
     MEP-search
     MEPStep=0.1

  >>> EndDo

As observed, to prepare the input for the MEP is simple, just add the keyword :kword:`MEP-search`
and specify a step size with :kword:`MEPStep`, and the remaining structure equals that of a geometry optimization.
The calculations are time consuming, because each point of the
MEP (four plus the initial one obtained here) is computed through a specific optimization.
A file named :file:`$Project.mep.molden` (read by :program:`MOLDEN` )
will be generated in $WorkDir containing only those points belonging to the MEP.

We shall now show how to perform geometry optimizations under nongeometrical
restrictions, in particular, how to compute hypersurface crossings, which are key structures
in the photophysics of molecules. We shall get those points as minimum energy crossing points in
which the energy of the highest of the two states considered is minimized under the restriction
that the energy difference with the lowest state should equal certain value (typically zero).
Such point can be named a minimum energy crossing point (MECP). If a further restriction is
imposed, like the distance to a specific geometry, and several MECP as computed at varying distances,
it is possible to obtain a crossing seam of points where the energy between the two states is
degenerated. Those degeneracy points are funnels with the highest probability for the energy
to hop between the surfaces in internal conversion or intersystem crossing photophysical processes.
There are different possibilities. A crossing between states of the same spin
multiplicity and spatial symmetry is named a conical intersection. Elements like the nonadiabatic
coupling terms are required to obtain them strictly, and they are not computed presently
by |molcas|. If the crossing occurs between states of the same
spin multiplicity and different spatial symmetry or between states of different spin multiplicity,
the crossing is an hyperplane and its only requirement is the energetic degeneracy and the
proper energy minimization.

Here we include an example with the crossing between the lowest singlet (ground) and triplet
states of acrolein. Notice that two different states are computed, first by using
:program:`RASSCF` to get the wave function and then :program:`ALASKA` to get the gradients
of the energy. Nothing new on that, just the information needed in any geometry optimizations.
The :program:`GATEWAY` input requires to add as constraint an energy
difference between both states equal to zero. A specific instruction is required after
calculating the first state. We have to copy the communication file :file:`RUNFILE`
(at that point contains the information about the first state) to :file:`RUNFILE2`
to provide later :program:`SLAPAF` with proper information about both states:

.. extractfile:: problem_based_tutorials/CASSCF.S-T_crossing.acrolein.input

  *CASSCF singlet-triplet crossing in acrolein
  *File: CASSCF.S-T_crossing.acrolein
  *
   &GATEWAY
  Title= Acrolein molecule
  Basis set
  O.sto-3g....
   O1             1.5686705444       -0.1354553340        3.1977912036  Angstrom
  End of basis
  Basis set
  C.sto-3g....
   C1            -0.1641585340        0.2420235062       -0.0459895824  Angstrom
   C2             0.1137722023       -0.1389623714        1.3481527296  Angstrom
   C3             1.3218729238        0.1965728073        1.9959513294  Angstrom
  End of basis
  Basis set
  H.sto-3g....
   H1             2.0526602523        0.7568282320        1.4351034056  Angstrom
   H2            -0.6138178851       -0.6941171027        1.9113821810  Angstrom
   H3            -0.8171509745        1.0643342316       -0.2648232855  Angstrom
   H4             0.1260134708       -0.4020589690       -0.8535699812  Angstrom
  End of basis
  Constraints
     a = Ediff
    Value
     a = 0.000
  End of Constraints

  >>> Do while

   &SEWARD

  >>> IF ( ITER = 1 ) <<<
   &SCF
  >>> ENDIF <<<

   &RASSCF
     LumOrb
     Spin= 1; Nactel= 4 0 0; Inactive= 13; Ras2= 4
     CiRoot= 1 1; 1
   &ALASKA
  >>COPY $WorkDir/$Project.RunFile $WorkDir/RUNFILE2

   &RASSCF
     LumOrb
     Spin= 3; Nactel= 4 0 0; Inactive= 13; Ras2= 4
     CiRoot= 1 1; 1
   &ALASKA
   &SLAPAF

  >>> EndDo

Solvent effects can be also applied to excited states, but first the reaction
field in the ground (initial) state has to be computed. This is because solvation in
electronic excited states is a non equilibrium situation in with the electronic
polarization effects (fast part of the reaction field) have to treated apart
(they supposedly change during the excitation process) from the orientational
(slow part) effects. The slow fraction of the reaction field is maintained from
the initial state and therefore a previous calculation is required.
From the practical point of view the input is simple as illustrated in the next
example. First, the proper reaction-field
input is included in :program:`SEWARD`, then a :program:`RASSCF` and :program:`CASPT2`
run of the ground state, with keyword :kword:`RFPErt` in :program:`CASPT2`,
and after that another SA-CASSCF calculation of five roots to get the wave function
of the excited states. Keyword :kword:`NONEequilibrium` tells the program to extract
the slow part of the reaction field from the previous calculation of the ground
state (specifically from the :file:`JOBOLD` file, which may be stored for other
calculations) while the fast part is freshly computed. Also, as it is a SA-CASSCF
calculation (if not, this is not required) keyword :kword:`RFRoot` is introduced
to specify for which of the computed roots the reaction field is generated. We have
selected here the fifth root because it has a very large dipole moment, which is
also very different from the ground state dipole moment. If you compare the excitation
energy obtained for the isolated and the solvated system, a the large red shift is
obtained in the later.

.. extractfile:: problem_based_tutorials/CASPT2.excited_solvent.acrolein.input

  *CASPT2 excited state in water for acrolein
  *File: CASPT2.excited_solvent.acrolein
  *
  &GATEWAY
    Title= Acrolein molecule
    coord = acrolein.xyz; basis = STO-3G; group= c1
    RF-input
     PCM-model; solvent= water
    End of RF-input
  &SEWARD
  &RASSCF
    Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
    CiRoot= 1 1 1
  &CASPT2
    Multistate= 1 1
    RFPert
  &RASSCF
    Spin= 1; Nactel= 6 0 0; Inactive= 12; Ras2= 5
    CiRoot= 5 5 1
    RFRoot= 5
    NONEquilibrium
  &CASPT2
    Multistate= 1 5
    RFPert

A number of simple examples as how to proceed with the most frequent
quantum chemical problems computed with |molcas| have been given above. Certainly there are many more
possibilities in |molcas|, such as calculation of 3D band
systems in solids at a semiempirical level, obtaining valence-bond structures,
the use of QM/MM methods in combination with a external MM code, the introduction
of external homogeneous or non homogeneous perturbations, generation of atomic
basis sets, application of different localization schemes, analysis of first
order polarizabilities, calculation of vibrational intensities, analysis, generation,
and fitting of potentials, computation of vibro-rotational spectra for diatomic
molecules, introduction of relativistic effects, etc. All those aspects are
explained in the manual and are much more specific. :ref:`Next section <TUT:sec:pg-based-tut>`
details the basic structure of the inputs, program by program, while easy examples
can also be found. Later, another chapter includes a number of extremely detailed
examples with more elaborated quantum chemical examples, in which also scientific
comments are included. Examples include calculations on high symmetry molecules,
geometry optimizations and Hessians, computing reaction paths, high quality wave
functions, excited states, solvent models, and computation of relativistic effects.
.. index::
   single: Program; CASPT2
   single: CASPT2

.. _TUT\:sec\:caspt2:

:program:`CASPT2` --- A Many Body Perturbation Program
======================================================

Dynamic correlation energy of a molecular system can be calculated using
the :program:`CASPT2` program module in |molcas|. A :program:`CASPT2`
calculation gives a second order perturbation estimate of the full CI energy
using the CASSCF wave function of the system.
The program can also perform Multi-State CASPT2 calculations (MS-CASPT2) in
which different CASPT2 states are coupled using an effective Hamiltonian
computed to second order in perturbation theory. This is necessary in cases
where different CASSCF wave functions are strongly dependent on dynamical
correlation effects. The wave function have to be obtained in a previous
State-Average CASSCF calculation.

.. index::
   single: CASPT2; Input

A sample input is given in :numref:`block:caspt2_input`. The
:kword:`FROZen` keyword specifies the number of orbitals of each
symmetry which will not be included in the correlation. We have
chosen the :program:`RASSCF` :kword:`INACtive` orbitals to be frozen
for this calculation (the default is to freeze all core orbitals, so the input
is strictly not needed). The remaining two keywords, :kword:`CONVergence` and
:kword:`MAXIter`, are included with there default values. The
:kword:`MULTistate` keyword is included for clarity even if not needed in this single
state calculation. A single line follows indicating the number of
simultaneously treated CASPT2 roots and the number of the roots in the previous
SA-CASSCF calculation.

.. index::
   single: CASPT2; Output

:program:`CASPT2` Output
------------------------

In :numref:`TUT:sec:pt2out` the meaning and significance of most of the
features used and printed by the :program:`CASPT2` program are explained in the
context of an actual example. We suggest a careful reading of that section
because understanding the results of a CASPT2 calculation is important for
the analysis of problems like intruder states, large coefficients, convergence,
etc.

.. code-block:: none
   :caption: Sample input requesting the :program:`CASPT2` module to calculate the CASPT2
             energy of a water molecule in :math:`C_{2v}` symmetry with one frozen orbital.
   :name: block:caspt2_input

   &CASPT2
   Frozen= 1 0 0 0
   Multistate= 1 1
   MaxIter= 40

The output of the :program:`CASPT2` program begins with the title
from the input as well as the title from the :program:`SEWARD` input.
It also contains the cartesian coordinates of the molecule and the
CASSCF wave function and orbital specifications. This is followed by
details about the type of Fock and :math:`H_0` operator used and, eventually,
the value of the level-shift parameter employed. It is possible then
to obtain, by input specifications, the quasi-canonical orbitals in
which the wave function will be represented. The following CI vector
and occupation number analysis will be performed using the
quasi-canonical orbitals.

Two important sections follow. First a detailed report on small energy
denominators, large components, and large energy contributions which will
inform about the reliability of the calculation
(see :numref:`TUT:sec:pt2out`)
and finally the :program:`CASPT2` property section
including the natural orbitals obtained
as defined in the output and a number of approximated molecular properties.

If the :kword:`MULTistate` option is used, the program will perform one CASPT2
calculation for each one of the selected roots, and finally the complete
effective Hamiltonian containing the selected states will be solved to obtain
the final MS-CASPT2 energies and PM-CASSCF wave functions :cite:`Finley:98b`.

The :program:`CASPT2` module needs the integral files in :file:`$WorkDir` and the
:file:`RUNFILE` file from the and the :file:`JOBIPH` file from the
:program:`RASSCF` module. The orbitals are saved in the :file:`PT2ORB` file.
The new PM-CASSCF wave functions generated in a MS-CASPT2 calculation
is saved in the :file:`JOBMIX` file.

:program:`CASPT2` --- Basic and Most Common Keywords
----------------------------------------------------

.. class:: keywordlist

:kword:`MULTistate`
  Multi-State CASPT2 calculation: number of roots and roots (Ex. 3 1 2 3)

:kword:`IMAG`
  Value for the imaginary shift for the zero order Hamiltonian
.. index::
   single: Program; GUGA
   single: GUGA

.. _TUT\:sec\:guga:

:program:`GUGA` --- A Configuration Interaction Coupling Coefficients Program
=============================================================================

Several of the Configuration Interaction (CI) modules in |molcas| use
the :program:`guga` module to compute the CI coupling coefficients.
We continue our water calculations using the input file shown in
the input below. The :kword:`TITLe` keyword behaves
in a similar fashion as described in previous modules.
There are several compulsory keywords of the :program:`guga` module. The
number of electrons to be correlated is specified using the
:kword:`ELECtrons` keyword. We are correlating the valence electrons.
The spin state is specified using the :kword:`SPIN` keyword.

.. index::
   single: GUGA; Input

Sample input requesting the the GUGA module to calculate the coupling
coefficients for neutral triplet water in :math:`C_{2v}` symmetry with six electrons
in the active space: ::

  &GUGA
  Title= GUGA for C2v Water
  Electrons= 8; Spin= 3
  Inactive= 1 0 0 0; Active= 2 2 0 1
  CIAll= 1

The keywords :kword:`CIALl` and :kword:`REFErence` are mutually
exclusive. We specify :kword:`CIALl` which will calculate the
energy using all possible references functions that can be constructed
using the input set of occupation numbers of the active orbitals regardless of
the spin coupling (all configurations used to build the corresponding CASSCF
wave function). Specific selected references can be chosen using the
:kword:`REFErence` keyword. Either the :kword:`ACTIve` or :kword:`INACtive`
keyword should be used for a meaningful calculation. The default for both
keywords is zero for all symmetries. These keywords function in a similar
fashion to these in the :program:`RASSCF` program module. The :kword:`INACtive`
keyword specifies the orbitals that are fully occupied in each symmetry
in all the reference functions and the :kword:`ACTIve` keyword
specifies the orbitals that may have varying occupations in all references.
The selection of :kword:`INACtive` orbitals in the input above
is forcing the bonding sp hybrid orbital to remain fully occupied in all
reference states.

:program:`GUGA` Output
----------------------

The :program:`GUGA` section of the output lists the possible configurations
in the active space. There are nine possible triplet configurations of
six electrons in five orbitals. Apart from the various types of orbital in each
symmetry the :program:`GUGA` section of the output also gives the number of
states that will coupled with various states. There are no input files for the
:program:`GUGA` module but the calculated coupling coefficients are stored in
:file:`CIGUGA`.
.. index::
   single: Program; FFPT
   single: FFPT
   single: Properties; Finite-field PT
   single: Properties; FFPT

.. _TUT\:sec\:ffpt:

:program:`FFPT` --- A Finite Field Perturbation Program
========================================================

Many molecular properties of wave functions can be computed using the
:program:`FFPT` program module in |molcas|. It adds the requested operator to
the integrals computed by the :program:`seward` module. This must be done
before the |molcas| module calculating the required wave function is requested
so the :program:`FFPT` module is best run directly after the :program:`seward`
module.

The :kword:`TITLe` keyword behaviors in a similar fashion to other
|molcas| modules.
The sample input below contains the :program:`FFPT` input
requesting that the dipole moment operator be added to the integrals
using the :kword:`DIPOle` keyword.
The size and direction is specified using the :kword:`COMP` keyword
which accepts free format input. We can compute the dipole of the
molecule by numerical determination of the gradient of the energy
curve determined for several values of the dipole operator. From the second
derivative we can obtain the polarizability component.

Sample input requesting the FFPT module to
include a dipole moment operator in the integral file: ::

  &FFPT
  Title= Finite Perturbation with a dipole in the x negative of strength 0.1 au
  FFPT
  Dipole
   Comp
   X -0.1

:program:`ffpt` Output
----------------------

The :program:`ffpt` section of the output is short and self
explanatory. The :file:`ONEINT` file is updated with the requested
operator.
.. index::
   single: Program; MCLR
   single: MCLR

.. _TUT\:sec\:mclr:

:program:`MCLR` --- A Program for Linear Response Calculations
==============================================================

:program:`MCLR` computes response calculations on single and multiconfigurational
SCF wave functions. One of the basic uses of :program:`MCKINLEY` and :program:`MCLR`
is to compute analytical Hessians (vibrational frequencies, IR intensities, etc).
:program:`MCLR` can also calculate the Lagrangian multipliers for
a MCSCF state included in a state average optimization and construct the effective
densities required for analytical gradients of such a state.
The use of keyword :kword:`RLXRoot` in the :program:`RASSCF` program is required.
In both cases the explicit request of executing the :program:`MCLR` module is not
required and will be automatic.
We postpone further
discussion about :program:`MCLR` to :numref:`TUT:sec:structure`.

It follows an example of how to optimize an excited state from a previous
State-Average (SA) CASSCF calculation.

.. extractfile:: tutorials/MCLR.acrolein.input

  &GATEWAY
  Title= acrolein minimum optimization in excited state 2
  Coord=$MOLCAS/Coord/Acrolein.xyz
  Basis= sto-3g
  Group=NoSym
  >>> Do while
  &SEWARD
  &RASSCF
  Title= acrolein
  Spin= 1; nActEl= 6 0 0; Inactive= 12; Ras2= 5
  CiRoot= 3 3 1
  Rlxroot= 2
  &SLAPAF
  >>> EndDo

The root selected for optimization has been selected here with the keyword
:kword:`Rlxroot` in :program:`RASSCF`, but it is also possible to select it
with keyword :kword:`SALA` in :program:`MCLR`.

Now if follows an example as how to compute the analytical hessian for the lowest
state of each symmetry in a CASSCF calculation (SCF, DFT, and RASSCF analytical
Hessians are also available).

.. extractfile:: tutorials/MCLR.benzoquinone.input

  &GATEWAY
  Title=p-benzoquinone anion. Casscf optimized geometry.
  Coord = $MOLCAS/Coord/benzoquinone.xyz
  Basis= sto-3g
  Group= X Y Z
  &SEWARD
  &RASSCF
  TITLE=p-benzoquinone anion. 2B3u state.
  SYMMETRY=2; SPIN=2; NACTEL=9 0 0
  INACTIVE=8  0  5  0  7  0  4  0
  RAS2    =0  3  0  1  0  3  0  1

  &MCKINLEY; Perturbation=Hessian

The :program:`MCLR` is automatically called after :program:`MCKINLEY`
and it is not needed in the input.

:program:`MCLR` program --- Basic and Most Common Keywords
----------------------------------------------------------

.. class:: keywordlist

:kword:`SALA`
  Root to relax in geometry optimizations

:kword:`ITER`
  Number of iterations
.. index::
   single: Program; Poly_aniso
   single: Poly_aniso

.. _TUT\:sec\:poly_aniso:

:program:`POLY_ANISO` --- Semi-*ab initio* Electronic Structure and Magnetism of Polynuclear Complexes Program
===============================================================================================================

The program :program:`POLY_ANISO` calculates nonperturbatively the temperature- and field- dependent magnetic
properties (Van Vleck susceptibility tensor and function, molar magnetization vector and function) and the
pseudospin Hamiltonians for Zeeman interaction (the :math:`g` tensor and higher rank tensorial components) and the
zero-field splitting (the :math:`D` tensor and higher rank tensorial components) for arbitrary mononuclear complexes
and fragments on the basis of ab initio spin-orbit calculations.
:program:`POLY_ANISO` requires as input file the :file:`RUNFILE` containing all necessary
*ab initio* information: spin orbit eigenstates, angular momentum matrix elements, the states been mixed
by the spin-orbit coupling in :program:`RASSI`, etc. Usually, the :program:`POLY_ANISO`
runs after :program:`RASSI`.

For a proper spin-orbit calculation the relativistic basis sets should be used for the whole calcualtion.
For :program:`SEWARD`, the atomic mean-field (:kword:`AMFI`), Douglas--Kroll (:kword:`DOUG`) must be employed.
To ensure the computation of angular momentum integrals the :kword:`ANGMOM` should be also used, specifying the origin
of angular momentum integrals as the coordinates of the magnetic center of the molecule, i.e. the coordinates of the atom
where the unpaired electrons mainly reside. For program :program:`RASSI` the necessary keywords are: :kword:`SPIN`,
since we need a spin-orbit coupling calculation, and :kword:`MEES`, to ensure the computation of angular momentum
matrix elements in the basis of spin-free states (SFS).

.. index::
   single: Poly_aniso; Input

In the cases where spin-orbit coupling has a minor effect on the low-lying energy spectrum (most of the
isotropic cases: :math:`\ce{Cr^{3+}}`, :math:`\ce{Gd^{3+}}`, etc.) the pseudospin is usually the same as the ground spin. For these cases
the :program:`POLY_ANISO` may run without specifying any keywords in the input file.

::

  &POLY_ANISO

In the cases when spin-orbit coupling play an important role in the low-lying energy spectrum, i.e. in the cases of e.g. octahedral :math:`\ce{Co^{2+}}`,
most of the lanthanide complexes, the pseudospin differs strongly from the spin of the ground state. In these cases,
the dimension of the pseudospin can be found by analysing the spin-orbit energy spectrum obtained at :program:`RASSI`.
The pseudospin is best defined as a group of spin-orbit states close in energy. Once specified, these eigenstates are further used
by the :program:`POLY_ANISO` to build proper pseudospin eigenfunctions. As an example of an input for :program:`POLY_ANISO`
requiring the computation of all magnetic properties (which is the default) and the computation of the :math:`g` tensor for the ground
Kramers doublet (i.e. pseudospin of a Kramers doublet is :math:`\tilde{S}=1/2`).

::

  &POLY_ANISO
   MLTP
   1
   2

.. compound::

  :program:`POLY_ANISO` has implemented pseudospins: :math:`\tilde{S}=1/2`, :math:`\tilde{S}=1`, ..., up to :math:`\tilde{S}=7/2`. The user can also ask for more pseudospins at the same time: ::

    &POLY_ANISO
     MLTP
     3
     2 4 2

  For the above input example, the :program:`POLY_ANISO` will compute the :math:`g` tensor for the ground Kramers doublet
  (spin-orbit states 1 and 2), the :math:`g` tensor, ZFS tensor and coefficients of higher rank ITO for the pseudospin
  :math:`\tilde{S}=3/2` (spin orbit functions 3--6), and the :math:`g` tensor for the third excited Kramers doublet (spin orbit functions 7 and 8).

.. index::
   single: Poly_aniso; Output

:program:`POLY_ANISO` Output
----------------------------

The :program:`POLY_ANISO` section of the |molcas| output is divided in four parts. In the first part, the :math:`g` tensor and higher rank Zeeman tensors are computed. They are followed by :math:`D` tensor and higher rank ZFS tensors. The program also computes the angular moments in the direction of the main magnetic axes.

In the second part, the paramaters of the crystal field acting on the ground atomic multiplet of lanthanides are calculated.

In the third part, the powder magnetic susceptibility is printed, followed by the magnetic susceptibility tensors with and without intermolecular interaction included.

In the fourth part, magnetization vectors (if required) are printed, and then the powder molar magnetization calculated for the :kword:`TMAG`
temperature.

The keywords :kword:`TINT` and :kword:`HINT` control the temperature and field intervals for computation of
magnetic susceptibility and molar magnetization respectively.
Computation of the magnetic properties at the experimental temperature and field points with the estimation of the standard deviation from experiment
is also possible via :kword:`TEXP`, defining the experimental temperature and measured magnetic susceptibility and
:kword:`HEXP`, defining the experimental field and averaged molar magnetization.

::

  &POLY_ANISO
  TITLE
  g tensor and magnetic susceptibility
  TYPE
  4
  MLTP
  2
  3 3
  TINT
  0.0 100 101 0.001

The above input requires computation of the parameters of two pseudospins :math:`\tilde{S}=1`: the ground (spin-orbit functions 1--3)
and first excited (spin-orbit functions 4--6) and the magnetic susceptibility in 101 steps equally distributed in
the temperature domain 0.0--100.0 K.

:program:`POLY_ANISO` --- Basic and Most Common Keywords
--------------------------------------------------------

.. class:: keywordlist

:kword:`MLTP`
  Specifies the number and dimension of the pseudospins Hamiltonians

:kword:`TMAG`
  Sets the temperature for the computation of molar magnetization

:kword:`MVEC`
  Number and radial coordinates of directions for which the magnetization vector will be computed
.. index::
   single: Program; McKinley
   single: McKinley

.. _TUT\:sec\:mckinley:

:program:`MCKINLEY` --- A Program for Integral Second Derivatives
=================================================================

:program:`MCKINLEY` computes the analytic second derivatives of the one- and two-electron
integrals with respect to the nuclear positions at the SCF and CASSCF level of theory.
The differentiated integrals
can be used by program :program:`MCLR` to performs response calculations on
single and multiconfigurational SCF wave functions. One of the basic uses
of :program:`MCKINLEY` and :program:`MCLR` is to compute analytical Hessians
(vibrational frequencies, IR intensities, etc).
Note that :program:`MCKINLEY` for a normal frequency calculations will automatically
start the :program:`MCLR` module!
For all other methods a numerical procedure is automatically
invoked by :program:`MCKINLEY` to compute the vibrational frequencies.

:program:`MCKINLEY` --- Basic and Most Common Keywords
------------------------------------------------------

.. class:: keywordlist

:kword:`PERTurbation`
  Suboptions Geometry (for geometry optimizations) or Hessian (full Hessian)
.. index::
   single: Optimization
   single: Geometry

.. _TUT\:sec\:structure:

:program:`ALASKA` and :program:`SLAPAF` --- A Molecular Structure Optimization
==============================================================================

One of the most powerful functions of *ab initio* calculations is geometry
predictions. The minimum energy structure of a molecule for a given method and
basis set is instructive especially when experiment is unable to determine the
actual geometry. |molcas| performs a geometry optimization with analytical
gradients at the SCF or RASSCF level of calculation, and with numerical
gradients at the CASPT2 level.

In order to perform geometry optimization an input file must contain
a loop, which includes several calls: calculation of integrals (:program:`SEWARD`),
calculation of energy (:program:`SCF`, :program:`RASSCF`, :program:`CASPT2`), calculation of gradients
(:program:`ALASKA`), and calculation of the new geometry (:program:`SLAPAF`).

This is an example of such input ::


  &GATEWAY
   coord= file.xyz
   basis= ANO-S-MB
  >> EXPORT MOLCAS_MAXITER=25
  >> Do While <<
  &SEWARD
  &SCF
  &SLAPAF
  >> EndDo <<

The initial coordinates will be taken from xyz file :file:`file.xyz`, and the geometry
will be optimized at the SCF level in this case. After the wave function calculation,
calculation of gradients is required, although code :program:`ALASKA` is automatically
called by |molcas|. :program:`SLAPAF` in this case required the calculation of an
energy minimum (no input). Other options are transition states (:kword:`TS`), minimum energy
paths (:kword:`MEP-search`), etc
The loop will be terminated if the geometry
converges, or maximum number of iterations (:variable:`MOLCAS_MAXITER`) will be reached (the
default value is 50).

There are several EMIL commands
(see :numref:`UG:sec:emil_commands`) which can be
used to control geometry optimization. For example, it is possible to execute
some |molcas| modules only once: ::

  >> IF ( ITER = 1 )
  * this part of the input will be executed only during the first iteration
  >> ENDIF

Program :program:`SLAPAF` is tailored to use analytical or numerical gradients produced
by :program:`ALASKA` to relax the geometry of a molecule towards an energy
minimum (default, no input required then) or a transition state. The program is also used for
finding inter state crossings (ISC), conical intersections (CI),
to compute reaction paths, intrinsic reaction coordinate (IRC) paths, etc.

.. Examples as how to use the :program:`SLAPAF` code is displayed in following :numref:`TUT:sec:structure`.

:program:`SLAPAF` --- Basic and Most Common Keywords
----------------------------------------------------

.. class:: keywordlist

:kword:`TS`
  Computing a transition state

:kword:`FindTS`
  Computing a transition state with a constraint

:kword:`MEP-search`
  Computing a steepest-descent minimum reaction path

:kword:`ITER`
  Number of iterations

:kword:`INTErnal`
  Definition of the internal coordinates

  .. :kword:`IRC`
     Intrinsic reaction coordinate analysis of a TS
.. index::
   single: Program; GRID_IT
   single: GRID_IT

.. _TUT\:sec\:gridit:

:program:`GRID_IT` --- A Program for Orbital Visualization
======================================================================

.. warning::

   This program requires a submodule

:program:`GRID_IT` is an interface program for calculations of molecular
orbitals and density in a set of cartesian grid points. Calculated grid
can be visualized by separate program :program:`LUSCUS` in
the form of isosurfaces.

:program:`GRID_IT` generates the regular grid and calculates amplitudes of
molecular orbitals in this net. Keywords :kword:`Sparse`,:kword:`Dense`,
:kword:`Npoints` specify the density of the grid. And keywords :kword:`ORange` (occupation range),
:kword:`ERange` (energy range), :kword:`Select` allow to select some specific orbitals to draw.

As default :program:`GRID_IT` will use grid net with intermediate quality,
and choose orbitals near HOMO--LUMO region. Note, that using keyword
:kword:`All` --- to calculate grids for all orbitals or :kword:`Dense` --
to calculate grid with very high quality you can produce a very huge
output file.

.. _TUT\:sec\:gridit_dependencies:

:program:`GRID_IT` requires the communication file :file:`RUNFILE`,
processed by :program:`GATEWAY` and any formated :file:`INPORB` file: :file:`SCFORB`,
:file:`RASORB`, :file:`PT2ORB`, generated by program :program:`SCF`, :program:`RASSCF`,
or :program:`CASPT2`, respectively. The output file :file:`M2MSI`
contains the graphical information.

Normally you do not need to specify any keywords for :program:`GRID_IT`:
the selection of grid size, as well as the selection of orbitals done automatically.

An input example for :program:`GRID_IT` is: ::

  &GRID_IT
  Dense
  * compute orbitals from 20 to 23 form symmetry 1 and orbital 4 from symmetry 2
  SELECT
  1:20-23,2:4

.. compound::

  :program:`GRID_IT` can be run in a sequence of other computational codes
  (if you need to run :program:`GRID_IT` several times, you have to rename
  grid file by using EMIL command, or by using keyword :kword:`NAME`) ::

    &GATEWAY
     ...
    &SEWARD
    &SCF
    &GRID_IT
    NAME=scf
    &RASSCF
    &GRID_IT
    NAME=ras

  or, you can run :program:`GRID_IT` separately, when the calculation has finished. ::

    &GATEWAY
    &GRID_IT
    FILEORB=/home/joe/project/water/water.ScfOrb

This is quite important to understand that the timing for :program:`GRID_IT`, and
the size of generated grid file depends dramatically on the targeting problem.
To get a printer quality pictures you have to use Dense grid, but in order to see the
shape of orbitals --- low quality grids are much more preferable.

The following table illustrates this dependence:

.. _tab\:grid_it_size:

============================== ======== ======== ===============
:math:`\ce{C_{24}}` molecule, 14 orbitals.
----------------------------------------------------------------
Keywords                       Time (s) filesize picture quality
============================== ======== ======== ===============
:kword:`Dense`; :kword:`ASCII` 188      473 MB   best
:kword:`Dense`                 117      328 MB   best
:kword:`Dense`; :kword:`Pack`  117      41 MB    below average
Default (no keywords)          3        9 MB     average
:kword:`Pack`                  3        1.4 MB   average
:kword:`Sparse`                1.3      3 MB     poor
:kword:`Sparse`; :kword:`Pack` 1.3      620 KB   poor
============================== ======== ======== ===============

:program:`GRID_IT` --- Basic and Most Common Keywords
-----------------------------------------------------

.. class:: keywordlist

:kword:`ASCII`
  Generate the :file:`grid` file in ASCII (e.g. to transfer to another computer),
  can only be used in combination with :kword:`NoLUSCUS`

:kword:`ALL`
  Generate all orbitals

:kword:`SELECT`
  Select orbitals to compute
.. _TUT\:sec\:environment:

Environment and EMIL Commands
=============================

The following are basic and most common commands for the |molcas| environment variables and input language (EMIL):

.. class:: variablelist

:variable:`MOLCAS`
  |molcas| home directory.

:variable:`MOLCAS_MEM`
  Memory definition in Mb. Default 1024.

:variable:`MOLCAS_PRINT`
  Printing level: 2 Normal, 3 Verbose

:variable:`MOLCAS_PROJECT`
  Name used for the project/files.

:variable:`MOLCAS_WORKDIR`
  Scratch directory for intermediate files.

.. class:: commandlist

:command:`>> Do While`
  Start of a loop in an input file for geometry optimization with conditional termination.

:command:`>> Foreach`
  Start of a loop in an input file over a number of items.

:command:`>> EndDo`
  End of a loop in an input file.

:command:`>> If ( condition )`
  Start of If block.

:command:`>> EndIf`
  End of If block.

:command:`>> Label Mark`
  Setting the label "Mark" in the input.

:command:`>> Goto Mark`
  Forward jump to the label "Mark" skipping that part of the input.
.. _TUT\:sec\:hints:

Some practical hints
====================

This section contains a collection of practical hints
and advices how to
use |molcas| in solving quantum chemistry problems.


:program:`GATEWAY`/:program:`SEWARD` program
--------------------------------------------

* Try the Cholesky approximation (or RI)!
  It saves disk space and possibly time.
* Think about basis set. ANO-like basis sets have many advantages,
  but they are "marginal".
* Try to avoid inline basis sets, use the library.
* Remember that the quality of basis set should match quality of
  computational method.
* Use ANO-RCC even for atoms in the 2nd row.
* Be extremely careful when computing anions.
  Remember that special situations requires special basis sets.
* Use minimal or small basis set for understanding chemical problem.
  You always can use expbas later.


:program:`SCF` program
----------------------

* HF orbitals are in many cases good starting orbitals,
  but quite often GuessOrb can be used instead.
* Very large basis set together with HF can lead to linear dependences.
* Remember! Hartree--Fock method allows multiple solutions (even for trivial
  systems).
* Be reasonable selecting convergence thresholds.
* UHF convergence is much poor comparing to RHF.
* Sometime you have to use Scramble keyword to break the symmetry.
* DFT convergence can't be better that HF convergence. Think about starting
  orbitals for DFT.
* Remember that DFT is a powerful method but
  it is still single configurational method. Don't use it beyond
  its limits.
* Choose your favorite functional, and stay with your decision.
* Note that MOLCAS is not the best DFT code available.

:program:`RASSCF` program
-------------------------

* MCSCF are multi-solution methods that heavily depend on
  the starting orbitals and
  level of calculation (roots).
* On convergence ALWAYS (ALWAYS, ALWAYS, etc) check the orbitals
  (LUSCUS, molden, CMOcorr, etc). MCSCF methods will lead to different solutions
  for active spaces of
  different nature. Use your chemical intuition and
  let the calculation guide you.
* Analyze carefully the CI coefficients and natural occupation
  numbers together with
  the orbitals (average orbitals are fine in general for that)
  in order to understand the
  nature of the states.
* You get average orbitals, and orbitals for individual roots, which
  you can visualized by LUSCUS or molden
  etc, contain the natural orbitals of the different roots.
* Try increasing the number of SA-CASSCF roots to locate more excited states. They can
  be low-lying solutions at the CASPT2 level. In high symmetry cases you may also need
  to consider roots that have high energy at the initial steps and can become lower roots in
  the converged calculation.
* It is NOT advisable to play games with weights for the different roots. Roots with equal
  weights make your calculation more clear and reproducible.
* MOLCAS can handle only :math:`D_{2h}` subgroups. Molecules with other
  symmetry (:math:`C_{3v}`, :math:`D_{4d}`, :math:`T_d`, :math:`O_h`) have a problem.
  Especially if you use approximations, like CD.
* Work in a symmetry point group that allows degenerate states to belong to the
  same irreducible representation (e.g. :math:`C_2` for linear molecules). Try :math:`C_1` too.
* Working in a too high symmetry might prevent you from obtaining less
  symmetric lowest-lying localized solutions (e.g. :math:`\ce{Ni^{2+}}`).
* Start with clean symmetric orbitals (GUESSORB). Sometime (for example
  for a radical), an orbital
  for positively charged system can be more symmetric.
* use if needed, CLEANUP and SUPSYM, or for linear molecules: the
  LINEAR keyword.
* Use it! RASSCF is a simple way to increase an active space.
* Balance RAS1/3 and RAS2 subspaces. Try to change orbitals between
  these subspaces.
* Removing RAS2 space completely is not a good idea.
* Note that RAS calculations have a slower convergence, and demand more
  resources.
* Increase LEVShift parameter in cases of slow or difficult convergence.
* Sometimes RASSCF is very sensitive when is close to convergence.
  Try restarting the calculation from the previous JOBIPH file
* Try to restart from orbitals (or JOBIPH) instead of starting from scratch.

Selection of active spaces
--------------------------

* Always compare calculations with the same active space size (and nature if possible).
* Ask yourself first which is your goal. The selection of the active space depends on that.
* If you made a selection once, try to reuse orbitals! Especially for a set of
  calculations with different geometries.
* In ground state calculations many orbitals can have an occupation close to 2 and 0 and
  might rotate with others in the inactive (secondary) space. It might be wise to skip them.
* For low-lying excited states and few roots you might leave inactive quite a number of
  orbitals. Check with RASSCF for instance.
* SCF orbital energies sometimes help to choose the orbitals by using the energy order
  criterion, but you must learn to see the problems (like lone pair orbitals having too low
  energies at the SCF level).
* You typically will need correlating orbitals, that is, if you have a :math:`\pi` orbital you need a :math:`\pi^*`,
  the same for :math:`\sigma`, :math:`\sigma^*`, but not for lone pairs.
* CASSCF/RASSCF geometry optimizations are the worst case. If you miss orbitals you
  might end up in a totally wrong geometry (e.g. breaking a bond usually requires the
  bonding and antibonding orbitals in the space).
* Organic (1st row atoms) molecules usually require open shell orbitals,
  :math:`\pi`, :math:`\pi^*`, and lone
  pairs. If 2nd row atoms are added (:math:`\ce{S}`, :math:`\ce{P}`, :math:`\ce{Si}`, etc) s orbitals enter in action (s bonds are
  longer). :math:`\ce{CH}` bonds can often be left be inactive.
* Rydberg states require additional diffuse basis sets and specific orbitals in the active
  space. Use basis sets centered in the charge center of the positive ion
  (consult the manual).
* Transition metal chemistry (1st row) sometimes requires a double d shell description
  in the active space.
* Lanthanides have a quite inert 4f shell that must be active together with 5d, 6s (6p).
  Actinides 5f, 6d, 7s.
* **use expbas!** start from minimal basis set, decide the active
  space, and expand the basis to "normal". With small basis set you can
  clearly identify orbitals.
* **use localization!** Especially for virtual orbitals.
* **expand active space by adding RAS1/3** --- give the system a freedom, and see how it
  reacts.

:program:`CASPT2` program
-------------------------

* The new IPEA = 0.25 zeroth Hamiltonian is the default.
  It particularly improves open shell cases. But there are some cases where
  IPEA=0 gives better correlation with experiment.
* Energy differences between different states or situations are only reliable between
  calculations with the same active space size and similar reference weights in CASPT2.
* An intruder state (low reference weight in the CASPT2 state) might be informing you
  that your active space lacks an important orbital. Check the list of large perturbative
  contributions (small denominators combined with large RHS values; check the output)
  and also the occupation number of the CASPT2 orbitals.
* For weakly interacting intruder states cases try the IMAGINARY level shift parameter.
  Don't use the level shift to reach agreement with experiment!

  .. 0.05 or 0.1 au is typically enough. It is wise to compute a series: 0.0, 0.05, 0.10, 0.15
     and check that the result is converged. Then, take the lowest value that solves your
     problem. Beware of using too large level shifts (not larger than IMAGINARY 0.20).

* For heavy valence--Rydberg mixing cases or for closely degenerated CASPT2 states,
  use MS-CASPT2.
* If the MS-CASPT2 description differs a lot from the CASPT2 one,
  try to check the
  calculation by increasing the active space (introducing angular correlation if possible)
  until the result is converged. The "true" solution is typically between both cases
  (CASPT2 and MS-CASPT2). If you are suspicious about the MS-CASPT2 result,
  better keep the CASPT2 one. It has worked out generally well so far.

RASSI program
-------------

* Remember that the program shows first the interaction among the input states and later this description might change.
  ALWAYS check the changing order of states.

  .. %(because the states order and nature change) in a
     %second part of the output. In general,

* For spin-orbit coupling calculations don't forget to include the CASPT2 energies as input
  (:kword:`EJOB` or :kword:`HDIAG` keywords) because the results depend on the energy gap. In other cases
  having the CASPT2 energies as input will help you to get the right oscillator strength and
  Einstein coefficient in the final table.
* If you have degenerate states be sure that the CASPT2 energies are degenerate. If they
  are not (which is common) average the energies for the degenerate set (the two
  components of E symmetry for example).
* Remember that the spin-orbit coupled results (e.g. TDM) depend on the number of interacting singlet and triplet states included in RASSI.


Geometry optimization
---------------------

* Not all methods have analytical derivatives.
* Default thresholds in slapaf are typically too tight. Do not waste computer time!
* Use constrained optimization.
* For minima on flat hypersurfaces, such in loosely bound fragments, or in slow convergence
  cases you might have to decrease the CUTOFF threshold in ALASKA.
* Be careful with the bond angle definition if you are close to a linear bond.
  You may have to switch to the LAngle definition.
* Don't forget that CASSCF does not include dynamical correlation. In some cases you better
  change to DFT or numerical CASPT2 optimizations or, if this is not feasible, may be
  preferable to run RASSCF optimizations.
* Poor active spaces may lead you to symmetry broken wrong solutions (e.g. a :math:`C_s` minimum
  for water below the true :math:`C_{2v}` one)
* Poor geometry convergence might be reduced or at least controlled by reducing the initial
  trust radius with the MAXSTEP keyword or/and by doing the optimization in Cartesian
  coordinates (CARTESIAN)
* In order to obtain localized solutions it might be a good idea to feed the program with a
  slightly distorted geometry that helps the method to reach the non symmetric solutions.
  Other possibilities are to use an electric field, to add a charge far from the system or use a solvent cavity. In all cases you break symmetry and allow less symmetric situations.
* Linearly interpolated internal coordinates geometries may be a good starting point to locate
  a transition state. Use also the useful FindTS command. Sometimes can be wise to compute
  a MEP from the TS to prove that it is relevant for the studied reaction path. Try also the new
  Saddle approach!
* When locating a CASSCF surface crossing (MECP) ALWAYS compute CASPT2 energies
  at that point. The gap between the states can be large at that level. In severe cases you might have to make a scan with CASPT2 to find a better region for the crossing.
* Remember that (so far) MOLCAS does not search for true conical intersections (CIs) but
  minimum energy crossing points (MECP) because it lacks NACMEs. Note however that
  typically computed minimum energy CIs (MECIs) may not be photochemically relevant
  if they are not easily accessible. Barriers have to be computed. Use MEPs!!
* Numerical Hessians and optimizations may lead you to bad solutions when different
  electronic states are too close. As you move your calculation from the equilibrium geometry
  some of the points may belong to other state and corrupt your result. This might be the case
  for numerical CASPT2 crossing search. Use then MS-CASPT2 search.
* Remember that SA-RASSCF analytical gradients and SA-CASSCF analytical Hessians are
  not implemented.
* Be careful with the change of roots and nature along a geometry optimization or MEP.
  For example, you start with the state in root 3 (at the CASSCF level) and reach a region
  of crossing root 3 and root 2. You may need to change to root 2 for your state.
  Not an easy solution (so far).

Solvent effects
---------------

* Some effects of the solvent are very specific, such as hydrogen bonds, and require to
  include explicit solvent molecules. Try adding a first solvent shell (optimized with
  molecular mechanics for instance) and then a cavity, for instance with PCM.
* Too small cavity sizes can lead you to unphysical solutions,
  even if they seem to match experiment.
* Remember using NonEquilibrium (final state) and RFRoot (SA-CASSCF)
  when required.
* QM/MM is a much powerful strategy, but it requires experience and knowledge
  of the field.
.. index::
   single: Program; MOTRA
   single: MOTRA
   single: Integrals; Integral transformation

.. _TUT\:sec\:motra:

:program:`MOTRA` --- An Integral Transformation Program
=======================================================

Integrals saved by the :program:`SEWARD` module
are stored in the Atomic Orbital (AO) basis. Some programs have their own
procedures to transform the integrals into the Molecular Orbital (MO) basis.
The |molcas| :program:`MOTRA` module performs this task for
Configuration Interaction (CI), Coupled- and Modified Coupled-Pair (CPF and
MCPF, respectively) and Coupled-Cluster (CC) calculations.

The sample input below contains the :program:`motra` input
information for our continuing water calculation. We firstly specify that the
:program:`RASSCF` module interface file will be the source of the
orbitals using the keyword :kword:`JOBIph`. The keyword
:kword:`FROZen` is used to specify the number of orbitals in each
symmetry which will not be correlated in
subsequent calculations. This can also be performed in the corresponding
:program:`MRCI`, :program:`CPF` or CC programs
but is more efficient to freeze them here.
Virtual orbitals can be deleted using the :kword:`DELEte` keyword. ::

  &MOTRA
  JobIph
  Frozen= 1 0 0 0

:program:`motra` Output
-----------------------

The :program:`motra` section of the output is short and self
explanatory. The integral files produced by :program:`SEWARD`, :file:`ONEINT`
and :file:`ORDINT`, are used as input by the
:program:`MOTRA` module which produces the transformed symbolic files
:file:`TRAONE` and :file:`TRAINT`, respectively. In our case, the files
are called :file:`water.TraOne` and :file:`water.TraInt`, respectively.


The :program:`motra` module also requires input orbitals.
If the :kword:`LUMOrb` keyword is specified the orbitals are taken
from the :file:`INPORB` file which can be any formated orbital
file such as :file:`water.ScfOrb` or :file:`water.RasOrb`. The
:kword:`JOBIph` keyword causes the :program:`MOTRA` module to
read the required orbitals from the :file:`JOBIPH` file.

:program:`MOTRA` --- Basic and Most Common Keywords
---------------------------------------------------

.. class:: keywordlist

:kword:`FROZEN`
  By symmetry: non-correlated orbitals (default: core)

:kword:`RFPErt`
  Previous reaction field introduced as a perturbation

:kword:`LUMORB`
  Input orbital file as ASCII (INPORB)

:kword:`JOBIPH`
  Input orbital file as binary (JOBOLD)
.. index::
   single: Tool; MOLDEN
   single: MOLDEN

.. _TUT\:sec\:Molden:

Writing MOLDEN input
====================

By default the :program:`GUESSORB`, :program:`SCF`, :program:`MBPT2`, :program:`RASSCF`,
:program:`SLAPAF`, :program:`LOCALISATION`, and :program:`MCLR` modules
generate input in Molden format. The :program:`SCF`, :program:`MBPT2`, :program:`RASSCF`,
and :program:`LOCALISATION` modules generate input for molecular orbital
analysis, :program:`SLAPAF` for geometry optimization analysis, minimum energy paths,
Saddle optimization paths and IRC TS analysis,
and the :program:`MCLR` module generates input for
analysis of harmonic frequencies. Molden files can be visualized by :program:`GV`
or by :program:`Molden` (http://www.cmbi.ru.nl/molden/).

The generic name of the input file and the actual
name are different for the nodes as a reflection on the data generated
by each module. Hence, the actual names (generic name) for the Molden files in each module are

* :program:`GUESSORB` module:
  :file:`$Project.guessorb.molden` (:file:`MD_GSS`)
* :program:`SCF` module:
  :file:`$Project.scf.molden` (:file:`MD_SCF`)
* :program:`MBPT2` module:
  :file:`$Project.mp2.molden` (:file:`MD_MP2`)
* :program:`RASSCF` module:
  :file:`$Project.rasscf.molden` (:file:`MD_CAS`) for the state-averaged natural orbitals, and
  :file:`$Project.rasscf.x.molden` (:file:`MD_CAS.x`) for the state-specific natural spin orbitals,
  where :file:`x` is the index of a CI root.
* :program:`SLAPAF` module:
  :file:`$Project.geo.molden` (:file:`MD_GEO`) for geometry optimizations,
  :file:`$Project.mep.molden` (:file:`MD_MEP`) for minimum energy paths,
  :file:`$Project.irc.molden` (:file:`MD_IRC`) for IRC analysis of a TS, and
  :file:`$Project.saddle.molden` (:file:`MD_SADDLE`) for Saddle method TS optimizations.
* :program:`LOCALISATION` module:
  :file:`$Project.local.molden` (:file:`MD_LOC`)
* :program:`MCLR` module:
  :file:`$Project.freq.molden` (:file:`MD_FREQ`)
.. _TUT\:sec\:pg-based-tut:

Program Based Tutorials
=======================

The |molcas| suite of Quantum Chemical programs is modular in
design. The desired calculation is achieved by executing a list of
|molcas| program modules in succession, while potentially manipulating
the program information files. If the information files from a previous
calculation are saved, then a subsequent calculation need not recompute
them. This is dependent on the correct information being preserved in
the information files for subsequent calculations.
Each module has keywords to specify the
functions to be carried out, and many modules rely on the
specification of keywords in previous modules.

The following sections describe the use of the |molcas| modules and
their inter-relationships. Each module is introduced in the
approximate order for performing a typical calculation.
A complete flowchart for the |molcas| suite of programs follows.

.. toctree::

   flowchart
   tut_emil

   tut_gateway
   tut_seward
   tut_scf
   tut_mbpt2
   tut_rasscf
   tut_caspt2
   tut_nevpt2
   tut_rassi
   tut_casvb
   tut_motra
   tut_guga
   tut_mrci
   tut_cpf
   tut_ccsdt
   tut_optimiza
   tut_mckinley
   tut_mclr
   tut_genano
   tut_ffpt
   tut_vibrot
   tut_single_aniso
   tut_poly_aniso
   tut_grid_it
   tut_molden
   tut_expbas

   tut_errors
   tut_hints

.. tut_alaska
.. index::
   single: Program; CCSDT
   single: Program; CCSD
   single: Program; CCT3
   single: Program; CCSORT
   single: CCSD(T)
   single: CCSD

.. _TUT\:sec\:ccsdt:

:program:`CCSDT` --- A Set of Coupled-Cluster Programs
======================================================

The |molcas| program :program:`CCSDT`
computes Coupled-Cluster Singles Doubles, CCSD, and Coupled-Cluster Singles
Doubles and Non-iterative Triples Correction CCSD(T) wave functions
for restricted single reference
both closed- and open-shell systems.

In addition to the :file:`ONEINT` and :file:`ORDINT` integral files
(in non-Cholesky calculations),
the :program:`CCSDT` code requires the :file:`JOBIPH` file containing the
reference wave function (remember that it is not possible to
compute open-shell systems with the :program:`SCF` program) and
the transformed two-electron integrals produced by the :program:`MOTRA`
module and stored in the :file:`TRAINT` file.


Previously to execute the :program:`CCSDT` module, wave functions
and integrals have to be prepared. First, a RASSCF calculation has
to be run in such a way that the resulting wave function has one
single reference. In closed-shell situations this means to include
all the orbitals as inactive and set the number of active electrons to zero.
Keyword :kword:`OUTOrbitals` followed by the specification :kword:`CANOnical`
must be used in
the :program:`RASSCF` input to activate the construction of canonical
orbitals and the calculation of the CI-vectors on the basis of
the canonical orbitals.
After that the :program:`MOTRA` module has to
be run to transform the two-electron integrals using the molecular
orbitals provided by the :program:`RASSCF` module.
The files :file:`JOBIPH` or :file:`RASORB` from the
:program:`RASSCF` calculation can be used directly by :program:`MOTRA`
using the keywords :kword:`JOBIph` or :kword:`LUMOrb` in the :program:`MOTRA` input.
Frozen or
deleted orbitals can be introduced in the transformation step
by the proper options in the :program:`MOTRA` input.

:program:`CCSDT` Outputs
------------------------

The section of the |molcas| output corresponding to the CC program
is self explanatory. The default output simply contains
the wave function specifications from the previous RASSCF calculation,
the orbital specifications, the diagonal Fock matrix elements and orbital
energies, the technical description of the calculation, the iterations leading to the CCSD energy,
and the five largest amplitudes of each type, which will help to evaluate
the calculation. If triples excitations have been required the description
of the employed method (from the three available) to compute perturbatively
the triple excited contributions to the CC energy, the value of the
correction, and the energy decomposition into spin parts will be available.

Example of a CCSD(T) calculation
--------------------------------

:numref:`block:ccsdt_input` contains the input files required by the
:program:`seward`, :program:`scf`,
:program:`rasscf`, :program:`motra` and :program:`ccsdt`
programs to compute the ground state of the :math:`\ce{HF^+}` cation.
molecule, which is a doublet of :math:`\Sigma^+` symmetry. A more detailed
description of the different options included in the input of the
programs can be found in the CCSDT section of the user's guide.
This example describes how to calculate CCSD(T) energy for :math:`\ce{HF^+}` cation.
This cation can be safely represented by the single determinant as a reference
function, so one can assume that CCSD(T) method will be suitable for its
description.

The calculation can be divided into few steps:

#. Run :program:`SEWARD` to generate AO integrals.

#. Calculate the HF molecule at the one electron level using :program:`SCF` to
   prepare an estimate of MO for the :program:`RASSCF` run.

#. Calculate :math:`\ce{HF^+}` cation by subtracting one electron from the orbital with
   the first symmetry. There is only one electron in one active orbital
   so only one configuration is created. Hence, we obtain a simple single
   determinant ROHF reference.

#. Perform MO transformation exploiting :program:`MOTRA` using MO coefficients
   from the :program:`RASSCF` run.

#. Perform the Coupled Cluster calculation using :program:`CCSDT` program. First,
   the data produced by the programs :program:`RASSCF` and :program:`MOTRA` need
   to be reorganized, then the CCSD calculation follows, with the chosen spin
   adaptation being T2 DDVV. Finally, the noniterative triple excitation contribution
   calculation is following, where the CCSD amplitudes are used.

This is an open shell case, so it is suitable to choose CCSD(T) method
as it is defined by Watts *et al.* :cite:`t3_watts`.
Since CCSD amplitudes produced by previous :program:`CCSD` run are partly
spin adapted and denominators are produced from the corresponding diagonal
Fock matrix elements,
final energy is sometimes referred as SA1 CCSD(T)\ :math:`_d` (see
:cite:`t3_neo`).

.. A suitable shell script to run these calculations can be found at the end of
   :numref:`UG:sec:cct3` of the user's guide.

.. extractcode-block:: none
   :filename: tutorials/CCSDT.HF.input
   :caption: Sample input containing the files required by the :program:`SEWARD`, :program:`SCF`,
             :program:`RASSCF`, :program:`MOTRA`, :program:`CCSORT`, :program:`CCSD`, and
             :program:`CCT3` programs to compute the ground state of the :math:`\ce{HF^+}` cation.
   :name: block:ccsdt_input

   &SEWARD &END
   Title= HF molecule
   Symmetry
   X Y
   Basis set
   F.ANO-S-VDZ
   F      0.00000   0.00000   1.73300
   End of basis
   Basis set
   H.ANO-S-VDZ
   H      0.00000   0.00000   0.00000
   End of basis
   End of input
   &SCF
   &RASSCF
   Title= HF(+) cation
   OUTOrbitals= Canonical
   Symmetry= 1; Spin= 2
   nActEl= 1 0 0; Inactive= 2 1 1 0; Ras2= 1 0 0 0
   LumOrb; OUTOrbitals= Canonical
   &MOTRA; JobIph; Frozen= 1 0 0 0
   &CCSDT
   Iterations= 50; Shift= 0.2,0.2; Accuracy= 1.0d-7
   Denominators= 2; Extrapolation= 5,4
   Adaptation= 1; Triples= 3; T3Denominators= 0

:program:`RASSCF` calculates the HF ionized state by removing one electron
from the orbital in the first symmetry.
Do not forget to use keyword
:kword:`CANONICAL`.
In the :program:`CCSDT` run, the number of iterations is limited to 50.
Denominators will be formed using orbital energies. (This corresponds to the
chosen spin adaptation.) Orbitals will be shifted by 0.2 au,
what will accelerate the convergence. However, final energy will not be
affected by the chosen type of denominators and orbital shifts. Required
accuracy is 10\ :math:`^{-7}` au. for the energy. T2 DDVV class of CCSD amplitudes will
be spin adapted.
To accelerate the convergence,
DIIS procedure is exploited. It will start after 5th iteration and
the last four iterations will be taken into account in each extrapolation step.

In the triples step the CCSD(T) procedure as defined
by Watts *et al.* :cite:`t3_watts` will be performed.
Corresponding denominators will be produced using diagonal Fock matrix elements.

:program:`CCSDT` --- Basic and Most Common Keywords
---------------------------------------------------

.. class:: keywordlist

:kword:`CCSD`
  Coupled-cluster singles and doubles method

:kword:`CCT`
  CCSD plus a non iterative triples (T) calculation
.. index::
   single: Program; CASVB
   single: CASVB

.. _TUT\:sec\:casvb:

:program:`CASVB` --- A non-orthogonal MCSCF program
===================================================

:program:`CASVB` is a program for carrying out quite general types of
non-orthogonal MCSCF calculations, offering, for example, all the advantages
associated with working within a valence bond formalism.

**Warning:** as for any general MCSCF program, one may experience convergence
problems, (e.g., due to redundant parameters), and the non-orthogonal
optimization of orbitals can furthermore give linear dependency problems.
Several options in :program:`CASVB` can help overcoming these difficulties.

This program can be used in two basic modes:

#. fully variational optimization
#. representation of CASSCF wavefunctions using
   overlap- (*relatively inexpensive*) or energy-based criteria.

:program:`CASVB` executes the following logical steps:
Setup of wavefunction information, starting guess generation, one, or several,
optimization steps, various types of analysis of the converged solution.

.. index::
   single: CASVB; Input

:program:`CASVB` Input
----------------------

:program:`CASVB` attempts to define defaults for as many input quantities as
possible, so that in the simplest case no input to the :program:`CASVB` module
is required.
Sample input for a CASVB calculation on the lowest singlet state of :math:`\ce{CH_2}`:

.. extractfile:: tutorials/CASVB.CH2.input

  &GATEWAY
  coord
  3
  ch2 molecule
  C 0.000000  0.000000 0.000000
  H 0.000000  0.892226 0.708554
  H 0.000000 -0.892226 0.708554

  group= x y; basis= sto-3g
  &SEWARD
  &SCF
  &RASSCF
  nactel= 6 0 0; inactive= 1 0 0 0; ras2= 3 1 2 0
  lumorb
  &CASVB

.. index::
   single: CASVB; Output

:program:`CASVB` Output
-----------------------

The amount of output in :program:`CASVB` depends heavily on the setting of the
:kword:`PRINT` levels. In case of problems with convergence behaviour it is
recommended to increase these from their rather terse default values.

In the following the main features of the output are outlined, exemplified by
the job in the input above. Initially, all relevant information
from the previous :program:`RASSCF` calculation is recovered from the
:file:`JOBIPH` interface file, after which the valence bond wavefunction
information is summarized, as shown below. Since
spatial configurations have not been specified explicitly in this example, a
single covalent configuration is chosen as default. This gives 5 spin-adapted
VB structures.

::

  Number of active electrons :   6
            active orbitals  :   6
            Total spin       : 0.0
            State symmetry   :   1

  Spatial VB configurations
  -------------------------
      Conf. =>   Orbitals
        1   =>    1  2  3  4  5  6

  Number of VB configurations :     1
            VB structures     :     5
            VB determinants   :    20


The output from the following optimization steps summarizes only the most
relevant quantities and convergence information at the default print level. For
the last optimization step, for example, The output below thus
states that the VB wavefunction was found by maximizing the overlap with a
previously optimized CASSCF wavefunction (output by the :program:`RASSCF`
program), and that the spin adaptation was done using the Yamanuchi--Kotani
scheme. Convergence was reached in 7 iterations.

::

  -- Starting optimization - step  3 --------

  Overlap-based optimization (Svb).

  Optimization algorithm:            dFletch
  Maximum number of iterations:           50
  Spin basis:                         Kotani

  -------------------------------------------
  Optimization entering local region.
  Converged ... maximum update to coefficient:  0.59051924E-06
  Final Svb :    0.9978782695
  Number of iterations used:   7

Finally in the output below the converged
solution is printed; orbital coefficients (in terms of the active CASSCF MOs)
and structure coefficients. The overlap between orbitals are generally of
interest, and, as also the structures are non-orthogonal, the structure weights
in the total wavefunction. The total VB wavefunction is not symmetry-adapted
explicitly (although one may ensure the correct symmetry by imposing constraints
on orbitals and structure coefficients), so its components in the various
irreducible representations can serve to check that it is physically plausible
(a well behaved solution generally has just one non-vanishing component).

Next follows the one-electron density with natural-orbital analysis, again with
quantities printed in the basis of the active CASSCF MOs.

::

  Orbital coefficients :
  ----------------------
            1           2           3           4           5           6
    1  0.43397359 -0.43397359 -0.79451779 -0.68987187 -0.79451780 -0.68987186
    2 -0.80889967  0.80889967 -0.05986171 -0.05516284 -0.05986171 -0.05516284
    3  0.00005587 -0.00005587  0.20401015 -0.20582094  0.20401016 -0.20582095
    4  0.39667145  0.39667145  0.00000000  0.00000000  0.00000000  0.00000000
    5 -0.00000001 -0.00000001 -0.53361427 -0.65931951  0.53361425  0.65931952
    6  0.00000000  0.00000000  0.19696124 -0.20968879 -0.19696124  0.20968879

  Overlap between orbitals :
  --------------------------
            1           2           3           4           5           6
    1  1.00000000 -0.68530352 -0.29636622 -0.25477647 -0.29636623 -0.25477647
    2 -0.68530352  1.00000000  0.29636622  0.25477647  0.29636623  0.25477646
    3 -0.29636622  0.29636622  1.00000000  0.81994979  0.35292419  0.19890631
    4 -0.25477647  0.25477647  0.81994979  1.00000000  0.19890634  0.04265679
    5 -0.29636623  0.29636623  0.35292419  0.19890634  1.00000000  0.81994978
    6 -0.25477647  0.25477646  0.19890631  0.04265679  0.81994978  1.00000000

  Structure coefficients :
  ------------------------
       0.00000000  0.00000001  0.09455957  0.00000000 -0.99551921

  Saving VB wavefunction to file VBWFN.

  Saving VB CI vector to file JOBIPH.

  Svb :          0.9978782695
  Evb :        -38.4265149062

  Chirgwin-Coulson weights of structures :
  ----------------------------------------
  VB spin+space (norm   1.00000000) :
       0.00000000  0.00000000 -0.00211737  0.00000000  1.00211737
  VB spin only  (norm   0.38213666) :
       0.00000000  0.00000000  0.00894151  0.00000000  0.99105849

  Symmetry contributions to total VB wavefunction :
  -------------------------------------------------
  Irreps 1 to 4 :  0.10000000E+01  0.15118834E-17  0.17653074E-17  0.49309519E-17

  Energies for components > 1d-10 :
  ---------------------------------
  Irreps 1 to 4 : -0.38426515E+02  0.00000000E+00  0.00000000E+00  0.00000000E+00

  One-electron density :
  ----------------------
            1           2           3           4           5           6
    1  1.98488829 -0.00021330  0.00011757  0.00000000  0.00000000  0.00000000
    2 -0.00021330  1.90209222 -0.00006927  0.00000000  0.00000000  0.00000000
    3  0.00011757 -0.00006927  0.02068155  0.00000000  0.00000000  0.00000000
    4  0.00000000  0.00000000  0.00000000  0.09447774  0.00000000  0.00000000
    5  0.00000000  0.00000000  0.00000000  0.00000000  1.97572540 -0.00030574
    6  0.00000000  0.00000000  0.00000000  0.00000000 -0.00030574  0.02213479

  Natural orbitals :
  ------------------
            1           2           3           4           5           6
    1 -0.99999668  0.00000000  0.00257629  0.00000000  0.00000000  0.00005985
    2  0.00257628  0.00000000  0.99999668  0.00000000  0.00000000 -0.00003681
    3 -0.00005995  0.00000000 -0.00003666  0.00000000 -0.00000001 -1.00000000
    4  0.00000000  0.00000000  0.00000000  1.00000000  0.00000001  0.00000000
    5  0.00000000  0.99999999  0.00000000  0.00000000  0.00015650  0.00000000
    6  0.00000000 -0.00015650  0.00000000 -0.00000001  0.99999999 -0.00000001

  Occupation numbers :
  --------------------
            1           2           3           4           5           6
    1  1.98488885  1.97572545  1.90209167  0.09447774  0.02213475  0.02068154

.. index::
   single: CASVB; Plotting

Viewing and plotting VB orbitals
--------------------------------

In many cases it can be helpful to view the shape of the converged valence bond
orbitals. |molcas| therefore provides two facilities for doing this. For the
Molden program, an interface file is generated at the end of each
:program:`CASVB` run (see also :numref:`UG:sec:Molden`). Alternatively a
:program:`CASVB` run may be followed by :program:`RASSCF`
(:numref:`UG:sec:rasscf`) and :program:`GRID_IT`
(:numref:`UG:sec:gridit`) with the :kword:`VB` specification, in order to
generate necessary files for viewing with :program:`LUSCUS`.
.. index::
   single: Program; SCF
   single: SCF

.. _TUT\:sec\:scf:

:program:`SCF` --- A Self-Consistent Field program and Kohn--Sham DFT
=====================================================================

The simplest *ab initio* calculations possible use the Hartree--Fock
(HF) Self-Consistent Field (SCF) method with the program name :program:`SCF` in
the |molcas| suite. It is possible to calculate the HF energy once we have
calculated the integrals using the :program:`SEWARD` module, although |molcas|
can perform a direct SCF calculation in which the two-electron integrals are
not stored on disk. The |molcas| implementation performs a closed-shell (all
electrons are paired in orbitals) and open-shell (Unrestricted Hartree--Fock)
calculation. It is not possible to perform an Restricted Open-shell Hartree--Fock (ROHF)
calculation with the :program:`SCF`. This is instead done using the program
:program:`RASSCF`. The :program:`SCF` program can also be used to perform
calculations using Kohn Sham Density Functional Theory (DFT).

The :program:`SCF` input for a Hartree--Fock calculation of a water
molecule is given in :numref:`block:scf_input`
which continues our calculations on the water molecule.

There are no compulsory keywords following the program name, ``&SCF``. If no input
is given the program will compute the SCF energy for a neutral molecule with the
orbital occupations giving the lowest energy. Here, we have used the following
input: the first is :kword:`TITLe`. As
with the :program:`SEWARD` program, the first line following the keyword is
printed in the output.

.. index::
   single: SCF; Input
   single: SCF; Occupied

No other keyword is required for a closed-shell calculation. The program
will find the lowest-energy electron configuration compatible with the
symmetry of the system and will distribute the orbitals accordingly.
In complex cases the procedure may fail and produce a higher-lying configuration.
It is possible to use the keyword :kword:`OCCUpied`
which specifies the number of occupied orbitals in each symmetry grouping
listed in the :program:`GATEWAY` output and given in
:numref:`block:Irreducible`, forcing the method to converge to the specified
configuration. The basis label and type give an
impression of the possible molecular orbitals that will be obtained in
the SCF calculation. For example, the first basis function in the :math:`a_1`
irreducible representation is an s type on the oxygen indicating the
oxygen 1s orbital. Note, also, that the fourth basis function is centered on
the hydrogens, has an s type and is symmetric on both hydrogens as
indicated by both hydrogens having a phase of 1, unlike the sixth basis function
which has a phase of 1 on center 2 (input H1) and |-|\ 1 on center 3
(generated H1).
As an alternative you can use the keyword :kword:`Charge` with parameters 0 and
1 to indicate a neutral molecule and optimization procedure 1 that searches for
the optimal occupation.

.. code-block:: none
   :caption: Sample input requesting the :program:`SCF` module to calculate the ground Hartree--Fock energy for a neutral water molecule in :math:`C_{2v}` symmetry.
   :name: block:scf_input

   &SCF
   Title= Water - A Tutorial. The SCF energy of water is calculated using C2v symmetry
   End of Input

.. index::
   single: Symmetry; Adapted basis functions

.. code-block:: none
   :caption: Symmetry adapted Basis Functions from a :program:`GATEWAY` output.
   :name: block:Irreducible

             Irreducible representation : a1
             Basis function(s) of irrep: z

   Basis Label        Type   Center Phase
     1   O1           1s        1     1
     2   O1           2s        1     1
     3   O1           2p0       1     1
     4   H1           1s        2     1      3     1

             Irreducible representation : b1
             Basis function(s) of irrep: x, xz, Ry

   Basis Label        Type   Center Phase
     5   O1           2p1+      1     1
     6   H1           1s        2     1      3    -1

             Irreducible representation : b2
             Basis function(s) of irrep: y, yz, Rx

   Basis Label        Type   Center Phase
     7   O1           2p1-      1     1

.. Note: This includes a nbsp character

We have ten electrons to ascribe to five orbitals to describe a
neutral water molecule in the ground state. Several
techniques exist for correct allocation of electrons. As a test of
the electron allocation, the energy obtained should be the same with
and without symmetry.
Water is a simple case, more so when
using the minimal basis set. In this case, the fourth irreducible
representation is not listed in the :program:`GATEWAY` output as there
are no basis functions in that representation.

.. index::
   single: SCF; Open-shell cases – Unrestricted Kohn–Sham DFT

To do a UHF calculation, the keyword :kword:`UHF` must be specified.
To force a specific occupation for alpha and beta orbitals
In this keyword :kword:`OCCNumbers` has to be used with two entries, one
for alpha and beta occupied orbital. It is possible to use UHF
together with keyword :kword:`Charge` or :kword:`Aufbau`, in this case
you have to specify a keyword :kword:`ZSPIN` set to the
difference between alpha and beta electrons.

If you want to do an UHF calculation for a closed shell system, for example,
diatomic molecule with large interatomic distance, you have to specify keyword
:kword:`SCRAMBLE`.

To do the Density Functional Theory calculations, keyword :kword:`KSDFT` followed
in the next line by the name of the available functional as listed in the input
section is compulsory. Presently following Functional Keywords are available:
BLYP, B3LYP, B3LYP5, HFB, HFS, LDA, LDA5, LSDA, LSDA5, SVWN, SVWN5, TLYP, PBE, PBE0,
M06, M06HF, M062X, M06L.
The description of functional keywords and the functionals is defined in the
section :ref:`UG:sec:dft`.

The input for KSDFT is given as, ::

  KSDFT= B3LYP5

In the above example B3LYP5 functional will be used in KSDFT calculations.

Running :program:`SCF`
----------------------

Performing the Hartree--Fock calculation introduces some important
aspects of the transfer of data between the |molcas| program modules.
The :program:`SCF` module uses the integral files computed by
:program:`SEWARD`. It produces a orbital file with the symbolic name
:file:`SCFORB` which contains all the MO information. This is then
available for use in subsequent |molcas| modules. The
:program:`SCF` module also adds information to the :file:`RUNFILE`.
Recall that the :program:`SEWARD` module produces two integral files
symbolically linked to :file:`ONEINT` and :file:`ORDINT` and actually
called, in our case, :file:`water.OneInt` and :file:`water.OrdInt`,
respectively (this is for non-Cholesky-type calculations only).
Because the two integral files are present in
the working directory when the :program:`SCF` module is performed, |molcas|
automatically links them to the symbolic names.

If the integral files were not deleted in a previous calculation
the :program:`SEWARD` calculation need not be repeated. Furthermore,
integral files need not be in the working directory if they are linked
by the user to their respective symbolic names. Integral files,
however, are often very large making it desirable to remove them after the
calculation is complete. The linking of files to their symbolic names
is useful in other case, such as input orbitals.

.. index::
   single: SCF; LumOrb
   single: SCF; Input orbitals
   single: SCF; Convergence problems

If nothing else is stated, the :program:`SCF` program will use the guess orbitals
produced by :program:`SEWARD` as input orbitals with the internal name
:file:`GUESSORB`. If one wants to use any other input orbitals for the
:program:`SCF` program the option :kword:`LUMOrb` must be used. The
corresponding file should be copied to the internal file :file:`INPORB`. This
could for example be an orbital file generated by an earlier SCF calculation,
:file:`$Project.ScfOrb`. Just copy or link the file as :file:`INPORB`.

.. index::
   single: SCF; Output

:program:`SCF` Output
---------------------

The :program:`SCF` output includes the title from the input as well as
the title from the :program:`GATEWAY` input because we used the integrals
generated by :program:`SEWARD`. The output also contains the cartesian
coordinates of the molecule and orbital specifications including the
number of frozen, occupied and virtual (secondary) orbitals in each
symmetry. This is followed by details regarding the :program:`SCF`
algorithm including convergence criteria and iteration limits. The
energy convergence information includes the one-electron, two-electron,
and total energies for each iteration. This is followed by the final
results including the final energy and molecular orbitals for each
symmetry.

The Density Functional Theory Program gives in addition to the above,
details of grids used, convergence criteria, and name of the functional used.
This is followed by integrated DFT energy which is the functional contribution
to the total energy and the total energy including the correlation.
This is followed results including the Kohn Sham orbitals for each symmetry.

.. index::
   single: SCF; Orbitals
   single: SCF; Orbital energies
   single: Orbital energies

The molecular orbital (MO) information lists the orbital energy, the
electron occupation and the coefficients of the basis functions
contributing to that MO. For a minimal basis set, the basis functions
correspond directly to the atomic orbitals. Using larger basis sets
means that a combination of the basis functions will be used for each
atomic orbital and more so for the MOs.
The MOs from the first symmetry species are
given in :numref:`block:water_MOs`. The first MO has an energy of
-20.5611 hartree and an occupation of 2.0. The major
contribution is from the first basis function label "``O1  1s``"
meaning an s type function centered on the oxygen atom. The
orbital
energy and the coefficient indicates that it is the MO based largely
on the oxygen 1s atomic orbital.

.. code-block:: none
   :caption: Molecular orbitals from the first symmetry species of a calculation of water using :math:`C_{2v}` symmetry and a minimal basis set.
   :name: block:water_MOs

   Molecular orbitals for symmetry species 1: a1

      Orbital        1         2         3         4
      Energy    -20.5611   -1.3467    -.5957     .0000
      Occ. No.    2.0000    2.0000    2.0000     .0000

    1 O1  1s      1.0000    -.0131    -.0264    -.0797
    2 O1  2s       .0011     .8608    -.4646    -.7760
    3 O1  2p0      .0017     .1392     .7809    -.7749
    4 H1  1s      -.0009     .2330     .4849    1.5386

The second MO has a major contribution from the second oxygen ``1s``
basis function indicating a mostly oxygen ``2s`` construction.
Note that it is the
absolute value of the coefficient that determines it importance. The
sign is important for determining the orthogonality of its orbitals and
whether the atomic orbitals contributions with overlap constructively
(bonding) or destructively (anti-bonding).
The former occurs in this MO as indicated by the positive sign on the
oxygen ``2s`` and the hydrogen ``1s`` orbitals, showing a bonding
interaction between them.
The latter occurs in the third MO, where the relative sign is reversed.

The third MO has an energy of
-0.5957 hartree and major contributions from the second oxygen
``1s`` basis function, the oxygen ``2p0`` basis function and the
hydrogen ``1s`` basis functions which are symmetrically situated on
each hydrogen (see :numref:`block:Irreducible`). The mixing of the
oxygen ``2s`` and ``2p0`` basis functions leads to a hybrid
orbital that points away from the two hydrogens, to which it is
weakly antibonding.

A similar analysis of the fourth orbital reveals that it is the
strongly anti-bonding orbital partner to the third MO. The oxygen ``2p0``
basis function is negative which reverses the overlap characteristics.

The molecular orbital information is followed by a Mulliken charge
analysis by input center and basis function. This provides a measure
of the electronic charge of each atomic center.

Towards the end of the :program:`SCF` section of the |molcas| output
various properties of the molecule are displayed. By default the
first (dipole) and second cartesian moments and the quadrupoles are displayed.

.. The
   inclusion of the :kword:`FLDG` keyword (with zero (0))
   with cause the electric field gradients at each atomic center to be calculated
   and displayed.
   There are several other properties that can be calculated
   in this fashion using the variational |molcas| programs --- :program:`SCF`
   and :program:`RASSCF` when producing a CASSCF wave function.

:program:`SCF` --- Basic and Most Common Keywords
-------------------------------------------------

.. class:: keywordlist

:kword:`UHF`
  Unrestricted Hartee Fock or unrestricted DFT calculation

:kword:`KSDFt`
  DFT calculations, with options: BLYP, B3LYP, B3LYP5, HFB, HFS,
  LDA, LDA5, LSDA, LSDA5, SVWN, SVWN5, TLYP, PBE, PBE0, M06, M06HF, M062X, M06L

:kword:`CHARge`
  Net charge of the system (default zero)

:kword:`ZSPIn`
  Difference between :math:`\alpha` and :math:`\beta` electrons

:kword:`Occupied`
  Specify the orbital occupations per irreps
.. index::
   single: Program; Gateway
   single: Gateway
   single: Integrals

.. _TUT\:sec\:gateway:

:program:`GATEWAY` --- Definition of geometry, basis sets, and symmetry
=======================================================================

The program :program:`GATEWAY` handles the basic molecular parameters in the
calculation. It generates data that are used in all subsequent calculations.
These data are stored in the :file:`RUNFILE`. :program:`GATEWAY` is the first
program to be executed, if the :file:`WorkDir` directory and the :file:`RUNFILE` file
has not already been generated by a previous calculation.

This tutorial is describes how to set up the basic |molcas| input for the water molecule.
For a more general description of the input options for :program:`GATEWAY`, please refer to the Users Guide.
The first line of the input is the program identifier ``&GATEWAY``.
Then follows the keyword used is :kword:`TITLe` which will also get
printed in the :program:`GATEWAY` section of the calculation output.
The title line is also saved in the integral file and will appear in subsequent programs.

.. The input for water is given in
   :numref:`block:gateway_input`.

.. index::
   single: Gateway; Symmetry
   single: Option; Symmetry
   single: Symmetry; Generators
   single: Symmetry; Point groups
   single: Gateway; Input

The :kword:`GROUp` keyword is followed by the generators for the :math:`C_{2v}`
point group, since the example deals with the water molecule.
The specification of the :math:`C_{2v}` point group given in
:numref:`tab:symmetry_list` is not unique, but, in this tutorial, the
generators have been input in an order that reproduces the ordering in the
character tables. A complete list of symmetry generator input syntax is given
in :numref:`tab:symmetry_list`. The symmetry groups available are listed
with the symmetry generators defining the group. The |molcas| keywords required
to specify the symmetry groups are also listed. The last column contains the
symmetry elements generated by the symmetry generators. ::

  &GATEWAY
  Title= Water in C2v symmetry - A Tutorial
  Coord = water.xyz
  Group = XY Y
  Basis Set = O.ANO-S-MB,H.ANO-S-MB

.. table:: Symmetries available in |molcas| including generators, |molcas| keywords and symmetry elements.
   :name: tab:symmetry_list

   ============== ============== ================ =========== ============ ============ ============ ========= ============== ================ ================= =========== =================== =================== ===================
   Group          Generators                                  |molcas|                               Elements
   -------------- ------------------------------------------- -------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------
   |zws|          :math:`g_1`    :math:`g_2`      :math:`g_3` :math:`g_1`  :math:`g_2`  :math:`g_3`  :math:`E` :math:`g_1`    :math:`g_2`      :math:`g_1g_2`    :math:`g_3` :math:`g_1g_3`      :math:`g_2g_3`      :math:`g_1g_2g_3`
   ============== ============== ================ =========== ============ ============ ============ ========= ============== ================ ================= =========== =================== =================== ===================
   :math:`C_1`                                                                                       :math:`E`
   :math:`C_2`    :math:`C_2`                                 :kword:`xy`                            :math:`E` :math:`C_2`
   :math:`C_s`    :math:`\sigma`                              :kword:`x`                             :math:`E` :math:`\sigma`
   :math:`C_i`    :math:`i`                                   :kword:`xyz`                           :math:`E` :math:`i`
   :math:`C_{2v}` :math:`C_2`    :math:`\sigma_v`             :kword:`xy`  :kword:`y`                :math:`E` :math:`C_2`    :math:`\sigma_v` :math:`\sigma_v'`
   :math:`C_{2h}` :math:`C_2`    :math:`i`                    :kword:`xy`  :kword:`xyz`              :math:`E` :math:`C_2`    :math:`i`        :math:`\sigma_h`
   :math:`D_2`    :math:`C_2^z`  :math:`C_2^y`                :kword:`xy`  :kword:`xz`               :math:`E` :math:`C_2^z`  :math:`C_2^y`    :math:`C_2^x`
   :math:`D_{2h}` :math:`C_2^z`  :math:`C_2^y`    :math:`i`   :kword:`xy`  :kword:`xz`  :kword:`xyz` :math:`E` :math:`C_2^z`  :math:`C_2^y`    :math:`C_2^x`     :math:`i`   :math:`\sigma^{xy}` :math:`\sigma^{xz}` :math:`\sigma^{yz}`
   ============== ============== ================ =========== ============ ============ ============ ========= ============== ================ ================= =========== =================== =================== ===================

.. Note: contains a nbsp

To reduce the input, the unity operator :math:`E` is always assumed. The twofold
rotation about the z-axis, :math:`C_2(z)`, and the reflection in the xz-plane,
:math:`\sigma_v(xz)`, are input as XY and Y respectively. The |molcas|
input can be viewed as symmetry operators that operate on the
Cartesian elements specified. For example, the reflection in the
xz-plane is specified by the input keyword :kword:`Y` which is the
Cartesian element operated upon by the reflection.

The input produces the character table in the
:program:`GATEWAY` section of the output shown in
:numref:`block:TUT_C2v_output`. Note that :math:`\sigma_v(yz)` was produced from
the other two generators. The last column contains the basis functions of
each irreducible symmetry representation. The totally symmetric :math:`a_1`
irreducible representation has the :math:`z` basis function listed which is unchanged
by any of the symmetry operations.

.. index::
   single: Character table

.. code-block:: none
   :caption: Character Table for :math:`C_{2v}`
   :name: block:TUT_C2v_output

            E   C2(z) s(xz) s(yz)
   a1       1     1     1     1  z
   b1       1    -1     1    -1  x, xz, Ry
   a2       1     1    -1    -1  xy, Rz, I
   b2       1    -1    -1     1  y, yz, Rx

.. Note: contains a nbsp

.. index::
   single: Gateway; Test
   single: Input; Comment lines
   single: Units
   single: Gateway; Geometry
   single: Gateway; Units
   single: Coordinates; Gateway input

The geometry of the molecule is defined using the keyword :kword:`coord`. On
the next line, the name of the xyz file that defines the geometrical
parameters of the molecule (:file:`water.xyz`) is given.

#. The first line of the :file:`water.xyz` file contains the number of atoms.
#. The second line is used to indicate the units: ångström or atomic units.
   The default is to use ångström.
#. Then follows one line for each atom containing the name of each atom and its coordinates.

Basis sets are defined after the keyword :kword:`BASIs sets`. The oxygen
and hydrogen basis set chosen, for this example, are the small Atomic Natural Orbitals
(ANO) sets. There are three contractions of the basis included in the input,
which can be toggled in or excluded with an asterisk, according to the desired calculation:
minimal basis, double zeta basis with polarization, or triple zeta basis with polarization.

.. code-block:: none
   :caption: The geometry of the water molecule
   :name: block:coord

   3

   O           .000000        .000000        .000000
   H          0.700000        .000000       0.700000
   H         -0.700000        .000000       0.700000

.. index::
   single: Gateway; Output
   single: Gateway; Geometry

:program:`GATEWAY` Output
-------------------------

The :program:`GATEWAY` output contains the symmetry character table, basis set
information and input atomic centers. The basis set information lists the
exponents and contraction coefficients as well as the type of Gaussian functions
(Cartesian, spherical or contaminated) used.

The internuclear distances and valence bond angles (including dihedral angles)
are displayed after the basis set information.
Inertia and rigid-rotor analysis is also included in the output along with
the timing information.

.. There is a keyword,
   :kword:`RTRN`, which is used to increase the threshold for printing of bond
   lengths, bond angles and dihedral angles from the default of 3.5 au.

A section of the output that is useful for determining the input to
the |molcas| module :program:`SCF` is the symmetry adapted basis
functions which appears near the end of the :program:`GATEWAY` portion
of the output. This is covered in more detail in the :program:`SCF`
tutorial.

The most important file produced by the :program:`GATEWAY` module is the
:file:`RUNFILE` which in our case is linked to :file:`water.RunFile`. This is
the general |molcas| communications file for transferring data between the
various |molcas| program modules. Many of the program modules add
data to the :file:`RUNFILE` which can be used in still other modules. A new
:file:`RUNFILE` is produced every time :program:`GATEWAY` is run. It should finally
be mentioned that for backwards compatibility one can run :program:`MOLCAS`
without invoking :program:`GATEWAY`. The corresponding input and output will
then be handled by the program :program:`SEWARD`.

.. index::
   single: Gateway; BSSE

Basis Set Superposition Error (BSSE)
------------------------------------

:program:`GATEWAY` can operates with several coordinate files, which is convenient
for computing BSSE corrections. :kword:`BSSE` followed by a number marks a XYZ
file which should be treated as dummy atoms. The following example demonstrates
this feature: ::

  &GATEWAY
  coord = ethanol.xyz
  coord = water.xyz
  bsse  = 1
  basis = ANO-S-MB
  NOMOVE
  &SEWARD; &SCF
  &GRID_IT
  NAME = water
  ***************
  &GATEWAY
  coord = ethanol.xyz
  coord = water.xyz
  bsse  = 2
  basis = ANO-S-MB
  NOMOVE
  &SEWARD; &SCF
  &GRID_IT
  NAME = ethanol
  **************
  &GATEWAY
  coord = ethanol.xyz
  coord = water.xyz
  basis = ANO-S-MB
  NOMOVE
  &SEWARD; &SCF
  &GRID_IT
  NAME = akvavit

Note, that :kword:`NOMOVE` keyword prevents centering of the molecule, so the computed
grids are identical. An alternative way to compute density difference is to
modify coordinates, and change an element label to X.

:program:`GATEWAY` Basic and Most Common Keywords
-------------------------------------------------

.. class:: keywordlist

:kword:`Coord`
  File name or inline number of atoms and XYZ coordinates

:kword:`BASIs Set`
  Atom_label.Basis_label (for example ANO-L-VTZP)

:kword:`Group`
  Full (find maximum), NoSym, or symmetry generators

:kword:`SYMMetry`
  Symmetry generators: X, Y, Z, XY, XZ, YZ, XYZ (in native format)

:kword:`RICD`
  On-the-fly auxiliary basis sets.
.. index::
   single: ECP
   single: Pseudopotentials
   single: Embedding potentials
   single: SEWARD; ECP
   single: SEWARD; Pseudopotentials
   single: SEWARD; Embedding potentials
   single: SEWARD; Core potentials
   single: Core; Core potentials
   single: Integrals; Core potentials

.. _TUT\:sec\:ecp:

Core and Embedding Potentials within the :program:`SEWARD` Program
==================================================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

|molcas| is able to perform *effective core potential* (ECP)
and *embedded cluster* (EC) calculations.
In ECP calculations :cite:`Wahlgren:92,Seijo:99`
the *core* electrons of a molecule are kept frozen and represented by a set of atomic
effective potentials, while only the valence electrons are explicitly handled
in the quantum mechanical calculation. In EC calculations only the electrons
assigned to a piece of the whole system, the *cluster*, are explicitly
treated in a quantum mechanical calculation, while the rest of the whole
system, the *environment*, is kept frozen and represented by embedding
potentials which act onto the *cluster*. For an explanation of the
type of potentials and approaches used in |molcas| the reader is referred
to :numref:`UG:sec:the_ecp_libraries` of the user's guide.

To use such type of effective potentials implies to compute a set
of atomic integrals and therefore involves only the :program:`SEWARD` program.
The remaining |molcas| programs will simply use the integrals in the
standard way and no indication of the use of ECP will appear in the
outputs further on; the difference is of course that the absolute energies
obtained for the different methods are not comparable to those obtained
in an all-electron calculation. Therefore, the only input required to
use ECP or EC is the :program:`SEWARD` input, according to the examples
given below. In the input files of the subsequent |molcas| programs the
orbitals corresponding to the excluded core orbitals should of course not be
included, and not the excluded electrons.

:program:`seward` input for Effective Core Potential calculations
-----------------------------------------------------------------

Astatine (:math:`\ce{At}`) is the atomic element number 85 which has the main configuration
in its electronic ground state: [*core*] 6s\ :math:`^2` 5d\ :math:`^{10}` 6p\ :math:`^5`. In the
*core* 68 electrons are included, corresponding to the xenon configuration
plus the 4f\ :math:`^{14}` lantanide shell. To perform an ECP calculation in a
molecular system containing :math:`\ce{At}` it is necessary to specify which type of
effective potential will substitute the *core* electrons and which valence
basis set will complement it. Although the core ECP's (strictly AIMP's, see
:numref:`UG:sec:the_ecp_libraries` of the user's guide) can be safely
mixed together with all-electron basis set, the valence basis sets included
in the |molcas| AIMP library have been explicitly optimized to complement the
AIMP potentials.

.. index::
   single: Relativistic effect; Core potentials

The file :file:`ECP` in the |molcas| directory :file:`$MOLCAS/basis_library` contains the
list of available core potentials and valence basis sets. Both the relativistic
(CG-AIMP's) and the nonrelativistic (NR-AIMP's) potentials are included. As an
example, this is the head of the entry corresponding to the relativistic ECP
for :math:`\ce{At}`: ::

  /At.ECP.Barandiaran.13s12p8d5f.1s1p2d1f.17e-CG-AIMP.
  Z.Barandiaran, L.Seijo, J.Chem.Phys. 101(1994)4049; L.S. JCP 102(1995)8078.
  core[Xe,4f] val[5d,6s,6p]  SO-corr  (11,1,1/9111/611*/4o1)=3s4p3d2f recommended
  *
  * - spin-orbit basis set correction from
  *   L.Seijo, JCP 102(1995)8078.
  *
  * - (5o) f orthogonality function is the 4f core orbital
  *
  *ATQR-DSP(A3/A2/71/5)-SO       (A111/9111/611/41)

The first line is the label line written in the usual :program:`SEWARD` format:
element symbol, basis label, first author, size of the primitive set, size
of the contracted set (in both cases referred to the valence basis set), and
type of ECP used. In this case there are 17 valence electrons and the
effective potential is a Cowan--Griffin-relativistic core AIMP. The number of
primitive functions for the valence basis set (13s12p8d5f here) will split
into different subsets (within a segmented contraction scheme) according to
the number of contracted functions. In the library, the contracted
basis functions have been set to the minimal basis size: 1s1p2d1f for the
valence electrons in :math:`\ce{At}`. This means the following partition: 1s contracted
function including 13 primitive functions; 1p contracted function including
12 primitive functions; 2d contracted functions, the first one containing
seven primitive functions and the second one primitive function
(see the library), and finally 1f contracted function containing five
primitive functions.

In the :program:`SEWARD` input the user can modify the contraction scheme
simply varying the number of contracted functions. There is a recommended size
for the valence basis set which is printed in the third line for each atom entry
on the library: 3s4p3d2f for :math:`\ce{At}`. For example, the simplest way to include the
atom core potential and valence basis set in the :program:`SEWARD` input would
be: ::

  At.ECP...3s4p3d2f.17e-CG-AIMP.

This means a partition for the valence basis set as showed in
:numref:`block:valbas_ecp`.

.. code-block:: none
   :caption: Partition of a valence basis set using the ECP's library
   :name: block:valbas_ecp

   Basis set:AT.ECP...3S4P3D2F.17E-CG-AIMP.

                    Type
                     s
             No.      Exponent    Contraction Coefficients
              1   .133037396D+07  -.000154   .000000   .000000
              2   .993126141D+05  -.001030   .000000   .000000
              3   .128814005D+05  -.005278   .000000   .000000
              4   .247485916D+04  -.014124   .000000   .000000
              5   .214733934D+03   .069168   .000000   .000000
              6   .111579706D+03   .020375   .000000   .000000
              7   .370830653D+02  -.259246   .000000   .000000
              8   .113961072D+02   .055751   .000000   .000000
              9   .709430236D+01   .649870   .000000   .000000
             10   .448517638D+01  -.204733   .000000   .000000
             11   .157439587D+01  -.924035   .000000   .000000
             12   .276339384D+00   .000000  1.000000   .000000
             13   .108928284D+00   .000000   .000000  1.000000

                    Type
                     p
             No.      Exponent    Contraction Coefficients
             14   .608157825D+04   .000747   .000000   .000000   .000000
             15   .128559298D+04   .009304   .000000   .000000   .000000
             16   .377428675D+03   .026201   .000000   .000000   .000000
             17   .552551834D+02  -.087130   .000000   .000000   .000000
             18   .233740022D+02  -.044778   .000000   .000000   .000000
             19   .152762905D+02   .108761   .000000   .000000   .000000
             20   .838467359D+01   .167650   .000000   .000000   .000000
             21   .234820847D+01  -.290968   .000000   .000000   .000000
             22   .119926577D+01  -.237719   .000000   .000000   .000000
             23   .389521915D+00   .000000  1.000000   .000000   .000000
             24   .170352883D+00   .000000   .000000  1.000000   .000000
             25   .680660800D-01   .000000   .000000   .000000  1.000000

                    Type
                     d
             No.      Exponent    Contraction Coefficients
             26   .782389711D+03   .007926   .000000   .000000
             27   .225872717D+03   .048785   .000000   .000000
             28   .821302011D+02   .109617   .000000   .000000
             29   .173902999D+02  -.139021   .000000   .000000
             30   .104111329D+02  -.241043   .000000   .000000
             31   .195037661D+01   .646388   .000000   .000000
             32   .689437556D+00   .000000  1.000000   .000000
             33   .225000000D+00   .000000   .000000  1.000000

                    Type
                     f
             No.      Exponent    Contraction Coefficients
             34   .115100000D+03   .065463   .000000
             35   .383200000D+02   .270118   .000000
             36   .151600000D+02   .468472   .000000
             37   .622900000D+01   .387073   .000000
             38   .242100000D+01   .000000  1.000000

Therefore, the primitive set will always be split following the scheme:
the first contracted function will contain the total number of primitives
minus the number of remaining contracted functions and each of the
remaining contracted functions will contain one single uncontracted
primitive function. In the present example possible contraction patterns
are: contracted 1s1p2d1f (13/12/8,1/5 primitives per contracted function, respectively),
2s2p3d2f (12,1/11,1/7,1,1/4,1), 3s3p4d2f (11,1,1/10,1,1/6,1,1,1/4,1), etc.
Any other scheme which cannot be generated in this way must be included in
the input using the Inline format for basis sets or an additional user's library.
When the Inline option is
used both the valence basis set and the AIMP potential must be included in
the input, as it will be shown in the next section.

For an explanation of the remaining items in the library the reader is referred
to :numref:`UG:sec:the_ecp_libraries` of the user's guide.

:numref:`block:hat_scf` contains the sample input required to compute the
SCF wave function for the astatine hydride molecule at an internuclear
distance of 3.2 au.
The Cowan--Griffin-relativistic core-AIMP has been
used for the :math:`\ce{At}` atom with a size for the valence basis set recommended in the
:file:`ECP` library: 3s4p3d2f.

.. extractcode-block:: none
   :filename: advanced/ECP.HAt.input
   :caption: Sample input required by SEWARD and SCF programs to compute the SCF
             wave function of :math:`\ce{HAt}` using a relativistic ECP
   :name: block:hat_scf

   &GATEWAY
   Title
   HAt molecule using 17e-Cowan-Griffin-relativistic core-AIMP
   coord
   2
   coordinates in bohr
   At 0 0 0
   H  0 0 3.2
   group
   X Y
   Basis set
   H.ano-l-vtzp
   Basis set
   At.ECP...3s4p3d2f.17e-CG-AIMP.
   &SEWARD
   &SCF
   Title
    HAt g.s. (At-val=5d,6s,6p)
   Occupied
    4 2 2 1

.. index::
   single: Embedded clusters
   single: Lattice

:program:`seward` input for Embedded Cluster calculations
---------------------------------------------------------

To perform embedded cluster (EC) calculations requires certain degree
of experience and therefore the reader is referred to the literature
quoted in :numref:`UG:sec:the_ecp_libraries` of the user's guide.
On the following a detailed example is however presented.
It corresponds to EC calculations useful for local properties
associated to a :math:`\ce{Tl^+}` impurity in :math:`\ce{KMgF3}`. First, a cluster must be
specified. This is the piece of the system which is explicitly treated by the
quantum mechanical calculation. In the present example the cluster will be
formed by the unit :math:`\ce{(TlF_{12})^{11-}}`. A flexible basis for the cluster must be
determined. :numref:`block:tlf_input` contains the basis set selection
for the thallium and fluorine atoms. In this case ECP-type basis sets
have been selected. For :math:`\ce{Tl}` a valence basis set of size 3s4p4d2f has
been used combined with the relativistic core-AIMP potentials as they
appear in the :file:`ECP` library. For the :math:`\ce{F}` atom the valence
basis set has been modified from that appearing in the :file:`ECP`
library. In this case the exponent of the p-diffuse function and the p
contraction coefficients
of the :math:`\ce{F}` basis set have been optimized in calculations on the fluorine
anion included in the specific lattice in order to obtain a more
flexible description of the anion. This
basis set must be introduced Inline, and then also the ECP potential
must be added to the input. The user can compare the basis set
and ECP for :math:`\ce{F}` in :numref:`block:tlf_input` with the entry of :file:`ECP`
under /F.ECP.Huzinaga.5s6p1d.1s2p1d.7e-NR-AIMP. The entry for the
Inline format must finish with the line End of Spectral Representation Operator.

Once the cluster has been defined it is necessary to represent the embedding
lattice. Presently, |molcas| includes embedding potentials for ions of
several elpasolites, fluoro-perovskites, rocksalt structure oxides and halides,
and fluorites. The embedding potentials for any other structure can be included
in the input using the Inline format
or included in a private user library.
In the selected example a fluoro-perovskite lattice has
been selected: :math:`\ce{KMgF3}`.
Here, the :math:`\ce{Tl^+}` impurity substitutes a :math:`\ce{K^+}` ion in an :math:`O_h` site with
12 coordination.
The first coordination shell of fluorine ions has been included into the cluster
structure and the interactions to the :math:`\ce{Tl}` atom will be computed by quantum
mechanical methods. The rest of the lattice will be represented by the
structure :math:`\ce{KMgF3}` with five shells of ions at experimental sites.
The shells have been divided in two types. Those shells closer to the
cluster are included as embedding potentials from the library :file:`ECP`.
For example the potassium centers will use the entry on :numref:`block:tlf_k`.

.. code-block:: none
   :caption: Sample input for an embedded core potential for a shell of potassium cations
   :name: block:tlf_k

   Basis set
   K.ECP..0s.0s.0e-AIMP-KMgF3.
   PSEUdocharge
   K2-1    0.0000000000   0.0000000000   7.5078420000
   K2-2    0.0000000000   7.5078420000   0.0000000000
   K2-3    0.0000000000   7.5078420000   7.5078420000
   K2-4    7.5078420000   0.0000000000   0.0000000000
   K2-5    7.5078420000   0.0000000000   7.5078420000
   K2-6    7.5078420000   7.5078420000   0.0000000000
   K2-7    7.5078420000   7.5078420000   7.5078420000
   End Of Basis

No basis set is employed to represent the potassium centers on :numref:`block:tlf_k`,
which just act as potentials embedding the cluster. The keyword
:kword:`PSEUdocharge` ensures that the interaction energy between the embedding
potentials is not included in the "Nuclear repulsion energy"
and that their location is not varied in a geometry optimization (:program:`SLAPAF`).
The first shells of :math:`\ce{Mg^{+2}}` and :math:`\ce{F^-}` will be introduced in the same way.

The remaining ions of the lattice will be treated as point charges.
To add a point charge on the :program:`SEWARD` input it is possible to proceed
in two ways. One possibility is to employ the usual label to introduce an atom
with its basis functions set to zero and the keyword :kword:`CHARge` set to the
value desired for the charge of the center. This way of introducing point charges must not be
used when geometry optimizations with the :program:`SLAPAF` program is going to
be performed because :program:`SLAPAF` will recognize the point charges as atoms
whose positions should be optimized. Instead the keyword :kword:`XFIEld` can be
used as it is illustrated in :numref:`block:tlf_input`. :kword:`XFIEld` must
be followed by a line containing the number of point charges, and by subsequent
lines containing the cartesian coordinates and the introduced charge or the
three components of the dipole moment at the specified geometry. In any case
the seven positions in each line must be fulfilled. To ensure the neutral
character of the whole system the point charges placed on the terminal edges,
corners or faces of the lattice must have the proper fractional values.

:numref:`block:tlf_input` contains the complete sample input to perform a
SCF energy calculation on the system :math:`\ce{(TlF_{12})^{11-}{:}KMgF3}`.

.. extractcode-block:: none
   :filename: advanced/ECP.TlF12.input
   :caption: Sample input for a SCF geometry optimization of the :math:`\ce{(TlF_{12})^{11-}{:}KMgF3}` system
   :name: block:tlf_input

   &GATEWAY
   Title
   |                          Test run TlF12:KMgF3.1                              |
   |** Molecule **   (TlF12)11- cluster embedded in a lattice of KMgF3            |
   |** Basis set and ECP **                                                       |
   |  * Tl * (11,1,1/9,1,1,1/5,1,1,1/4,1)                             from ECP    |
   |         13e-Cowan-Griffin-relativistic core-AIMP                 from ECP    |
   |  * F *  (4,1/4,1,1) diffuse-p optimized in KMgF3:F(-)                  inline|
   |          7e-nonrelativistic core-AIMP                                  inline|
   |  KMgF3 embedding-AIMPs                                           from ECP    |
   |** cluster geometry **   r(Tl-F)/b= 5.444 = 3.84948932 * sqrt(2)              |
   |** lattice **  (perovskite structure) 5 shells of ions at experimental sites  |
   Symmetry
   X Y Z

   Basis set
   Tl.ECP.Barandiaran.13s12p8d5f.3s4p4d2f.13e-CG-AIMP.
   Tl     0.00000   0.00000   0.00000
   End Of Basis

   Basis set
   F.ECP.... / Inline
   *    basis set and core-AIMP as in: F.ECP.Huzinaga.5s6p1d.2s4p1d.7e-NR-AIMP.
   *    except that the p-diffuse and the p contraction coeffs. have been
   *    optimized in KMgF3-embedded F(-) scf calculations.
     7.000000         1
       5    2
      405.4771610
      61.23686380
      13.47117730
      1.095173720
      .3400847530
     -.013805187800   .000000000000
     -.089245064800   .000000000000
     -.247937861000   .000000000000
      .632895340000   .000000000000
      .000000000000   .465026336000
       6    3
      44.13600920
      9.982597110
      2.947082680
      .9185111850
      .2685213550
      .142
      .015323038700   .000000000000   .000000000000
      .095384703000   .000000000000   .000000000000
      .291214218000   .000000000000   .000000000000
      .441351868000   .000000000000   .000000000000
      .000000000000   .427012588000   .000000000000
      .000000000000   .000000000000  1.000000000000
   *
   * Core AIMP: F-1S
   *
   * Local Potential Paramenters : (ECP convention)
   *                               A(AIMP)=-Zeff*A(ECP)
   M1
       7
      279347.4000
      31889.74900
      5649.977600
      1169.273000
      269.0513200
      71.29884600
      22.12150700

      .004654725000
      .007196816857
      .015371258571
      .032771900000
      .070383742857
      .108683807143
      .046652035714
   M2
       0
   COREREP
      1.0
   PROJOP
       0
      14    1
     52.7654040
      210965.4100
      31872.59200
      7315.837400
      2077.215300
      669.9991000
      232.1363900
      84.99573000
      32.90124100
      13.36331800
      5.588141500
      2.319058700
      .9500928100
      .3825419200
      .1478404000
      .000025861368
      .000198149380
      .001031418900
      .004341016600
      .016073698000
      .053856655000
      .151324390000
      .318558040000
      .404070310000
      .190635320000
      .011728993000
      .002954046500
     -.000536098280
      .000278474090
   *
   Spectral Representation Operator
   Valence primitive basis
   Exchange
   End of Spectral Representation Operator
   F_1        3.849489320       3.849489320        .000000000
   F_2         .000000000       3.849489320       3.849489320
   F_3        3.849489320        .000000000       3.849489320
   * 3*4 = 12
   End Of Basis

   * end of cluster data: TlF12

   * beginning of lattice embedding data: KMgF3

   Basis set
   K.ECP.Lopez-Moraza.0s.0s.0e-AIMP-KMgF3.
   pseudocharge
   * K(+) ions as embedding AIMPs
   K2-1    0.0000000000   0.0000000000   7.5078420000
   K2-2    0.0000000000   7.5078420000   0.0000000000
   K2-3    0.0000000000   7.5078420000   7.5078420000
   K2-4    7.5078420000   0.0000000000   0.0000000000
   K2-5    7.5078420000   0.0000000000   7.5078420000
   K2-6    7.5078420000   7.5078420000   0.0000000000
   K2-7    7.5078420000   7.5078420000   7.5078420000
   * 3*2 + 3*4 + 1*8 = 26
   End Of Basis

   Basis set
   Mg.ECP.Lopez-Moraza.0s.0s.0e-AIMP-KMgF3.
   pseudocharge
   * Mg(2+) ions as embedding AIMPs
   MG1-1   3.7539210000   3.7539210000   3.7539210000
   MG3-1   3.7539210000   3.7539210000  11.2617630000
   MG3-2   3.7539210000  11.2617630000   3.7539210000
   MG3-3   3.7539210000  11.2617630000  11.2617630000
   MG3-4  11.2617630000   3.7539210000   3.7539210000
   MG3-5  11.2617630000   3.7539210000  11.2617630000
   MG3-6  11.2617630000  11.2617630000   3.7539210000
   MG3-7  11.2617630000  11.2617630000  11.2617630000
   * 8*8 = 64
   End Of Basis

   Basis set
   F.ECP.Lopez-Moraza.0s.0s.0e-AIMP-KMgF3.
   pseudocharge
   * F(-) ions as embedding AIMPs
   F2-1    3.7539210000   3.7539210000   7.5078420000
   F2-2    3.7539210000   7.5078420000   3.7539210000
   F2-3    7.5078420000   3.7539210000   3.7539210000
   F3-1    0.0000000000   3.7539210000  11.2617630000
   F3-2    3.7539210000   0.0000000000  11.2617630000
   F3-3    3.7539210000  11.2617630000   0.0000000000
   F3-4    0.0000000000  11.2617630000   3.7539210000
   F3-5    3.7539210000  11.2617630000   7.5078420000
   F3-6    0.0000000000  11.2617630000  11.2617630000
   F3-7    3.7539210000   7.5078420000  11.2617630000
   F3-8   11.2617630000   3.7539210000   0.0000000000
   F3-9   11.2617630000   0.0000000000   3.7539210000
   F3-10   11.2617630000   3.7539210000   7.5078420000
   F3-11    7.5078420000   3.7539210000  11.2617630000
   F3-12   11.2617630000   0.0000000000  11.2617630000
   F3-13   11.2617630000  11.2617630000   0.0000000000
   F3-14    7.5078420000  11.2617630000   3.7539210000
   F3-15   11.2617630000   7.5078420000   3.7539210000
   F3-16   11.2617630000  11.2617630000   7.5078420000
   F3-17    7.5078420000  11.2617630000  11.2617630000
   F3-18   11.2617630000   7.5078420000  11.2617630000
   * 9*4 +  12*8 = 132
   End Of Basis

   * The rest of the embedding lattice will be represented by point charges,
   * which enter into the calculation in the form of a XField.
   *
   XField
    95
   *
   * K(+) ions as point charges
       0.0000000000   0.0000000000  15.0156840000       +1.0  0.  0.  0.
       0.0000000000   7.5078420000  15.0156840000       +1.0  0.  0.  0.
       0.0000000000  15.0156840000   0.0000000000       +1.0  0.  0.  0.
       0.0000000000  15.0156840000   7.5078420000       +1.0  0.  0.  0.
       0.0000000000  15.0156840000  15.0156840000       +1.0  0.  0.  0.
       7.5078420000   0.0000000000  15.0156840000       +1.0  0.  0.  0.
       7.5078420000   7.5078420000  15.0156840000       +1.0  0.  0.  0.
       7.5078420000  15.0156840000   0.0000000000       +1.0  0.  0.  0.
       7.5078420000  15.0156840000   7.5078420000       +1.0  0.  0.  0.
       7.5078420000  15.0156840000  15.0156840000       +1.0  0.  0.  0.
      15.0156840000   0.0000000000   0.0000000000       +1.0  0.  0.  0.
      15.0156840000   0.0000000000   7.5078420000       +1.0  0.  0.  0.
      15.0156840000   0.0000000000  15.0156840000       +1.0  0.  0.  0.
      15.0156840000   7.5078420000   0.0000000000       +1.0  0.  0.  0.
      15.0156840000   7.5078420000   7.5078420000       +1.0  0.  0.  0.
      15.0156840000   7.5078420000  15.0156840000       +1.0  0.  0.  0.
      15.0156840000  15.0156840000   0.0000000000       +1.0  0.  0.  0.
      15.0156840000  15.0156840000   7.5078420000       +1.0  0.  0.  0.
      15.0156840000  15.0156840000  15.0156840000       +1.0  0.  0.  0.
   *
   * F(-) ions as point charges
       3.7539210000   3.7539210000  15.0156840000       -1.0  0.  0.  0.
       3.7539210000  11.2617630000  15.0156840000       -1.0  0.  0.  0.
       3.7539210000  15.0156840000   3.7539210000       -1.0  0.  0.  0.
       3.7539210000  15.0156840000  11.2617630000       -1.0  0.  0.  0.
      11.2617630000   3.7539210000  15.0156840000       -1.0  0.  0.  0.
      11.2617630000  11.2617630000  15.0156840000       -1.0  0.  0.  0.
      11.2617630000  15.0156840000   3.7539210000       -1.0  0.  0.  0.
      11.2617630000  15.0156840000  11.2617630000       -1.0  0.  0.  0.
      15.0156840000   3.7539210000   3.7539210000       -1.0  0.  0.  0.
      15.0156840000   3.7539210000  11.2617630000       -1.0  0.  0.  0.
      15.0156840000  11.2617630000   3.7539210000       -1.0  0.  0.  0.
      15.0156840000  11.2617630000  11.2617630000       -1.0  0.  0.  0.
   *
   * Mg(2+) ions in face, as fractional point charges
      3.7539210000   3.7539210000  18.7696050000        +1.0  0.  0.  0.
      3.7539210000  11.2617630000  18.7696050000        +1.0  0.  0.  0.
      3.7539210000  18.7696050000   3.7539210000        +1.0  0.  0.  0.
      3.7539210000  18.7696050000  11.2617630000        +1.0  0.  0.  0.
     11.2617630000   3.7539210000  18.7696050000        +1.0  0.  0.  0.
     11.2617630000  11.2617630000  18.7696050000        +1.0  0.  0.  0.
     11.2617630000  18.7696050000   3.7539210000        +1.0  0.  0.  0.
     11.2617630000  18.7696050000  11.2617630000        +1.0  0.  0.  0.
     18.7696050000   3.7539210000   3.7539210000        +1.0  0.  0.  0.
     18.7696050000   3.7539210000  11.2617630000        +1.0  0.  0.  0.
     18.7696050000  11.2617630000   3.7539210000        +1.0  0.  0.  0.
     18.7696050000  11.2617630000  11.2617630000        +1.0  0.  0.  0.
   *
   * Mg(2+) ions in edge, as fractional point charges
      3.7539210000  18.7696050000  18.7696050000     +0.5  0.  0.  0.
     11.2617630000  18.7696050000  18.7696050000     +0.5  0.  0.  0.
     18.7696050000   3.7539210000  18.7696050000     +0.5  0.  0.  0.
     18.7696050000  11.2617630000  18.7696050000     +0.5  0.  0.  0.
     18.7696050000  18.7696050000   3.7539210000     +0.5  0.  0.  0.
     18.7696050000  18.7696050000  11.2617630000     +0.5  0.  0.  0.
   *
   * Mg(2+) ions in corner, as fractional point charges
     18.7696050000  18.7696050000  18.7696050000      +0.25  0. 0. 0.
   *
   * F(-) ions in face, as fractional point charges
      0.0000000000   3.7539210000  18.7696050000       -0.5  0. 0. 0.
      3.7539210000   0.0000000000  18.7696050000       -0.5  0. 0. 0.
      0.0000000000  11.2617630000  18.7696050000       -0.5  0. 0. 0.
      3.7539210000   7.5078420000  18.7696050000       -0.5  0. 0. 0.
      3.7539210000  18.7696050000   0.0000000000       -0.5  0. 0. 0.
      0.0000000000  18.7696050000   3.7539210000       -0.5  0. 0. 0.
      3.7539210000  18.7696050000   7.5078420000       -0.5  0. 0. 0.
      0.0000000000  18.7696050000  11.2617630000       -0.5  0. 0. 0.
      3.7539210000  18.7696050000  15.0156840000       -0.5  0. 0. 0.
      3.7539210000  15.0156840000  18.7696050000       -0.5  0. 0. 0.
      7.5078420000   3.7539210000  18.7696050000       -0.5  0. 0. 0.
     11.2617630000   0.0000000000  18.7696050000       -0.5  0. 0. 0.
      7.5078420000  11.2617630000  18.7696050000       -0.5  0. 0. 0.
     11.2617630000   7.5078420000  18.7696050000       -0.5  0. 0. 0.
     11.2617630000  18.7696050000   0.0000000000       -0.5  0. 0. 0.
      7.5078420000  18.7696050000   3.7539210000       -0.5  0. 0. 0.
     11.2617630000  18.7696050000   7.5078420000       -0.5  0. 0. 0.
      7.5078420000  18.7696050000  11.2617630000       -0.5  0. 0. 0.
     11.2617630000  18.7696050000  15.0156840000       -0.5  0. 0. 0.
     11.2617630000  15.0156840000  18.7696050000       -0.5  0. 0. 0.
     18.7696050000   3.7539210000   0.0000000000       -0.5  0. 0. 0.
     18.7696050000   0.0000000000   3.7539210000       -0.5  0. 0. 0.
     18.7696050000   3.7539210000   7.5078420000       -0.5  0. 0. 0.
     18.7696050000   0.0000000000  11.2617630000       -0.5  0. 0. 0.
     18.7696050000   3.7539210000  15.0156840000       -0.5  0. 0. 0.
     15.0156840000   3.7539210000  18.7696050000       -0.5  0. 0. 0.
     18.7696050000  11.2617630000   0.0000000000       -0.5  0. 0. 0.
     18.7696050000   7.5078420000   3.7539210000       -0.5  0. 0. 0.
     18.7696050000  11.2617630000   7.5078420000       -0.5  0. 0. 0.
     18.7696050000   7.5078420000  11.2617630000       -0.5  0. 0. 0.
     18.7696050000  11.2617630000  15.0156840000       -0.5  0. 0. 0.
     15.0156840000  11.2617630000  18.7696050000       -0.5  0. 0. 0.
     15.0156840000  18.7696050000   3.7539210000       -0.5  0. 0. 0.
     18.7696050000  15.0156840000   3.7539210000       -0.5  0. 0. 0.
     15.0156840000  18.7696050000  11.2617630000       -0.5  0. 0. 0.
     18.7696050000  15.0156840000  11.2617630000       -0.5  0. 0. 0.
   *
   * F(-) ions in edge, as fractional point charges
      0.0000000000  18.7696050000  18.7696050000       -0.25  0. 0. 0.
      7.5078420000  18.7696050000  18.7696050000       -0.25  0. 0. 0.
     18.7696050000   0.0000000000  18.7696050000       -0.25  0. 0. 0.
     18.7696050000   7.5078420000  18.7696050000       -0.25  0. 0. 0.
     18.7696050000  18.7696050000   0.0000000000       -0.25  0. 0. 0.
     18.7696050000  18.7696050000   7.5078420000       -0.25  0. 0. 0.
     18.7696050000  18.7696050000  15.0156840000       -0.25  0. 0. 0.
     15.0156840000  18.7696050000  18.7696050000       -0.25  0. 0. 0.
     18.7696050000  15.0156840000  18.7696050000       -0.25  0. 0. 0.

   *  end of lattice embedding data: KMgF3

   * 13 cluster components  and 881 lattice components

   &SEWARD
   &SCF
   Title
    (TlF12)11- run as D2h
   Occupied
    12    7    7    6    7    6    6    3
.. index::
   single: Excited states
   single: Vertical spectra
   single: Rydberg states
   single: CASPT2

.. _TUT\:sec\:excited:

Excited states
==============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

The accurate calculation of excited electronic states has been
a challenge for quantum chemistry. The possibility for
accurate calculations of such states in molecules has only
recently been made possible through the development of new
quantum chemical techniques. CASPT2 is currently one of the more
successful methods to compute excited states due to its balance
between accuracy and cost. In addition to the intrinsic
limitations of the method, photochemistry and photophysics
involves a large number of situations and mechanisms which
complicate the problems enormously. In the present section we
are going to show a systematic way to deal with a large
number of states in a molecule. We have selected the thiophene
molecule and our goal will be to compute the lowest valence and
Rydberg singlet states at the ground state geometry. This can
be considered to be the gas-phase absorption spectrum of the molecule.
The calculations comprise an extensive use of the RASSCF,
CASPT2, and RASSI programs. Selection of proper active spaces,
building of appropriate diffuse basis functions, calculation
of transition dipole moments, and use of the level-shift technique
in CASPT2 will be some of the topics covered.

.. index::
   single: Thiophene

.. _TUT\:sec\:thiophene:

The vertical spectrum of thiophene
----------------------------------

Besides the usual limitation typical of any *ab initio* procedure
due to the size of the system and the calculation of the integrals,
the CASPT2 method has the basic limitation of the size and selection of the
active space in the preliminary CASSCF step, not only because the
space cannot be too large but because the active space defines the
type and number of configurations (read excitations) to be included
in the multiconfigurational wave functions.
The near-degenerate configurations describing all states must
be present in the reference wave function.
Therefore, certain knowledge of the system is necessary
to design the calculation and, for excited states, this will
limit the number of states we are able to study.

Planning the calculations
.........................

Thiophene is a planar five membered ring molecule containing one sulfur
and four carbon atoms. The :math:`\pi` structure of the system contains
two conjugated double bonds between carbon atoms. Therefore, the orbital
:math:`\pi` valence structure is composed by two :math:`\pi` bonding, two
:math:`\pi^*` antibonding orbitals, and one :math:`\pi` nonbonding orbital placed
on the sulfur atom.
The :math:`\pi` orbitals are the highest occupied ones in this type of
systems and excitations from them form the UV
spectrum in gas phase and solution. Also, typical orbitals involved
in low-lying excited states are the lone-pair orbitals such as the
sulfur :math:`n` orbital co-planar with the :math:`\sigma` skeleton of the
molecule. On the other hand, :math:`\sigma` orbitals forming :math:`\ce{C-H}` and :math:`\ce{C-C}`
bonds do not participate in the low-lying excited
electronic states. One has, however to be careful here. In thiophene there are
low-lying virtual :math:`\sigma` that give rise to excited states in the region around
6 eV :cite:`Tozer:99a`.

.. figure:: thiophene.*
   :name: fig:thiophene
   :width: 50%
   :align: center

   Thiophene

.. index::
   single: Active space

With this in mind we have to include at least the three :math:`\pi`
and two :math:`\pi^*` valence orbitals and the valence :math:`\sigma` lone-pair
on the sulfur in the active space. The molecule belongs
to the |Ctv| point group, therefore we have three |bo| and
two |at| :math:`\pi`,\ :math:`\pi^*` orbitals and one |ao| :math:`n` orbital.
That is, our minimal valence active space can be labeled
(1302), where each number corresponds to the number of |ao|, |bo|,
|bt|, and |at| orbitals, respectively.

.. index::
   single: Orbitals; Rydberg functions
   single: Orbitals; Rydberg
   single: Rydberg states

But the valence states are not the only states present at low energies.
In a gas-phase spectrum of a neutral molecule the Rydberg states start to
appear at energies above 5 eV. Therefore, they must be simultaneously
included in the calculations. The Rydberg orbitals are large compared
to the molecular dimension and therefore have quasi atomic shapes. Rydberg
states are commonly labeled as excited states of atoms with a principal
quantum number :math:`n` and the usual angular quantum numbers :math:`l` and :math:`m`.
For molecules containing only first row atoms :math:`n` conventionally starts
with 3. This convention is actually used also in a molecule like thiophene,
although in sulfur the valence electrons are in the third shell.
Increasing the value of :math:`n` will lead to more and more diffuse orbitals,
eventually converging to an ionized state of the molecule. The lowest
Rydberg state corresponds to the excitation HOMO\ |->|\3\ |s|.
The next components will be 3\ |px|, 3\ |py|, and 3\ |pz|, followed by the
five components of 3\ |d.|.

The Rydberg orbitals classify into the point group like their corresponding
atomic orbitals. Therefore, a look at the character table
(see :numref:`tab:c2v`) indicates that in |Ctv| the |s|, |pz|, |dzt|,
and |dxtyt| Rydberg orbitals belong to symmetry |ao|, |px| and |dxz| to symmetry
|bo|, |py| and |dyz| to symmetry |bt| and, finally, |dxy| to
symmetry |at|. According to the labeling defined above the nine lowest Rydberg
orbitals classify to (4221). It is obvious that we cannot normally
afford to have simultaneously the whole valence plus Rydberg space
(15 active orbitals in the present example). Therefore we are going to
exploit the symmetry properties to select different active spaces.

.. index::
   single: Orbital energies

By inspection of the SCF orbital energies or the ionization
potentials of the molecule we observe that the highest occupied
orbitals HOMO (1\ |at|) and HOMO\ |-|\1 (2\ |bo|) are reasonably close in
energy (around 0.6 eV). Therefore, two Rydberg series close in energy
can be expected at low energies, the first one arising from the
HOMO orbital and the second from the HOMO\ |-|\1 orbital. By exciting
one electron from each of those orbitals to each one of the
Rydberg orbitals we know the symmetry of the resulting state.
For instance, the excitation HOMO (|at|) |->| 3\ |s| (|ao|) leads
to a :math:`A_2` by direct product of the symmetry representations.
:numref:`tab:thio` contains the analysis for the Rydberg states
arising both from HOMO and HOMO\ |-|\1 orbitals to the :math:`n=3` Rydberg
orbitals. They form the two lowest Rydberg series. We want also
to locate the state from the lone-pair HOMO\ |-|\2 (11\ |ao|) to 3\ |s|.

.. float::
   :type: table
   :name: tab:thio
   :caption-top:
   :caption: Selection of active spaces in thiophene.

   .. _tab\:thio_a:

   =================== ==== ==== ==== ====
   |zws|               Symmetries
   =================== ===================
   \                   |ao| |bo| |bt| |at|
   Frozen orb.         5    1    3    0
   Inactive orb.       6    0    4    0
   Valence active orb. 1    3    0    2
   =================== ==== ==== ==== ====

   .. |pa2| replace:: (:math:`\pi`) |at|\ |->|
   .. |pb1| replace:: (:math:`\pi`) |bo|\ |->|
   .. |na1| replace:: (:math:`n`) |ao|\ |->|
   .. |HOMO0| replace:: HOMO\ |->|\ :math:`n=3`
   .. |HOMO1| replace:: HOMO\ |-|\1\ |->|\ :math:`n=3`
   .. |HOMO2| replace:: HOMO\ |-|\2\ |->|\ :math:`n=3`
   .. |A1| replace:: :math:`A_1`
   .. |A2| replace:: :math:`A_2`
   .. |B1| replace:: :math:`B_1`
   .. |B2| replace:: :math:`B_2`

   .. _tab\:thio_b:

   ============ ============ ====== ============ ============ ====== ============ ============ ======
   Rydberg states
   --------------------------------------------------------------------------------------------------
   |HOMO0|                   State  |HOMO1|                   State  |HOMO2|                   State\
                                                                                               [#a]_
   ========================= ====== ========================= ====== ========================= ======
   |pa2|        3\ |s| |ao|  |A2|   |pb1|        3\ |s| |ao|  |B1|   |na1|        3\ |s| |ao|  |A1|
   \            3\ |p.| |ao| |A2|                3\ |p.| |ao| |B1|
   \            3\ |p.| |bo| |B2|                3\ |p.| |bo| |A1|
   \            3\ |p.| |bt| |B1|                3\ |p.| |bt| |A2|
   \            3\ |d.| |ao| |A2|                3\ |d.| |ao| |B1|
   \            3\ |d.| |ao| |A2|                3\ |d.| |ao| |B1|
   \            3\ |d.| |bo| |B2|                3\ |d.| |bo| |A1|
   \            3\ |d.| |bt| |B1|                3\ |d.| |bt| |A2|
   \            3\ |d.| |at| |A1|                3\ |d.| |at| |B2|
   ============ ============ ====== ============ ============ ====== ============ ============ ======

   .. _tab\:thio_c:

   +---------------------------------------------------------------------------------------------------+
   | Total active space                                                                                |
   +========================================================+==========================================+
   | | |A1|, |B2| states (:math:`\pi\to\pi^*`)              |                                          |
   | | |A1|, |B2| states (:math:`\pi\to\mathrm{R}(\pi^*)`)  | Valence (1302) + Rydberg (0201) = (1503) |
   | | |A2|, |B1| states (:math:`n\to\pi^*`)                |                                          |
   +--------------------------------------------------------+------------------------------------------+
   | | |A2|, |B1| states (:math:`\pi\to\mathrm{R}(\sigma)`) | Valence (1302) + Rydberg (4020) = (5322) |
   | | |A1| states (:math:`n\to\mathrm{R}(\sigma)`)         |                                          |
   +--------------------------------------------------------+------------------------------------------+

   .. [#a] Only considered up to the :math:`A_1` (3\ |s|) state because the remaining are expected at higher energy.

.. index::
   single: Active space

The computed states will use different partitionings of the active space. The
basic valence space (1302) must be included in all the cases. The valence
:math:`\pi\to\pi^*` states only involve excitations into the :math:`\pi` and :math:`\pi^*`
orbitals. Therefore they belong to the :math:`A_1` and :math:`B_2` symmetries. In addition
we can have single excitations (Rydberg states) from the occupied :math:`\pi`
orbitals to the Rydberg orbitals of :math:`b_1` and :math:`a_2` symmetries. The number of
Rydberg orbitals belonging to those symmetries is (0201). Thus, the final space
to compute simultaneously valence and Rydberg :math:`\pi\to\pi^*` states is
(1302) + (0201): (1503). The same space can be used to compute
:math:`n\to\pi^*` states because the :math:`n` orbital and the :math:`\pi^*` orbitals
are included into the active space. The symmetries of these states, however,
will be :math:`A_2` and :math:`B_1`. In the table we also have another
division for the :math:`A_2` and :math:`B_1`, :math:`\pi\to\mathrm{R}(\sigma)`, and :math:`A_1`, :math:`n\to\mathrm{R}(\sigma)`,
(only the :math:`n`\ |->|\3\ |s|) Rydberg states, using an active space (5322).
We have, therefore, divided the excited states to be computed by symmetries
and active space. State-average CASSCF calculations for each one of
the cases have to be performed. The only question which remains is how many roots
we have to include in each of the cases. This is also determined by the symmetry
and active space available. For instance, for the :math:`\pi\to\pi^*` :math:`A_1` states,
we want to compute the ground state plus three Rydberg states (see :numref:`tab:thio` in both
HOMO and HOMO\ |-|\1 |->| :math:`n=3` series) plus a certain number of valence states.
If we do not have any previous experience we may think of three or four possible
valence states but we know that the usual number of low-lying valence
states is close to the number of valence singly excited states, in this case
two of :math:`A_1` symmetry. This does not mean that the states are
going to be described by one single configuration; it is simply an estimation
of the number of relevant states based on experience. In summary, we expect
to compute six :math:`A_1` states and therefore we include six roots in the
CASSCF state-average input.

It is not uncommon that one or more valence states do not appear in the
initial CASSCF calculation including the desired roots and other higher Rydberg
states. This is
due to the fact that valence states usually require larger dynamical
correlation corrections than the Rydberg states. Therefore in a CASSCF
calculation the Rydberg states are, in general, lower in energy than the valence states.
The dynamical correlation included by the CASPT2 method will place the
states correctly. However this is only possible if the states are present
in the CASSCF calculation. It is then necessary to be sure that the states
are located at the CASSCF level. Maybe it is necessary to increase
the number of roots and in special cases like those with low symmetry
even to delete Rydberg orbitals from the active space
:cite:`Roos:95a,Roos:96b,Serrano:96a,Serrano:96b`.

In the following we will describe briefly the calculations :cite:`Serrano:94th`.
A detailed report of the vertical excited spectrum of thiophene can be found
in references :cite:`Serrano:94th,Serrano:93d`. The selection of the active spaces in that
work included additional orbitals to minimize the effect of intruder
states. The availability of the level-shift technique in later versions of
|molcas| allow us to use a smaller active space.

.. index::
   single: Rydberg orbitals
   single: Orbitals; Rydberg
   single: Basis set; Diffuse functions
   single: Basis set; Rydberg functions

.. _TUT\:sec\:make_rydberg_basis_sets:

Generating Rydberg basis functions
..................................

First we describe a method for generating Rydberg basis functions
for molecules.
Such Rydberg orbitals are diffuse and thus require
diffuse basis functions. Due to this diffuseness they are not
"localized" to atoms in the sense that valence orbitals are, but
should be considered to be spread out over the entire molecule.

The basis of the method lies in the fact
that if we add an electron into a virtual orbital, the energy
for the system is increased by the orbital energy, according to
Koopmans' theorem.
The reorganizational effects are very minor for the diffuse
virtual orbitals. Thus adding an electron into a virtual orbital
for a cation is an reasonable approximation to the proper
Rydberg state.
A more extensive discussion of the method
outlined below can be found in :cite:`Roos:96b`.

The method can be broken down into a few steps (see Ref. :cite:`Roos:96b` for details):

#. Perform a RHF or valence CASSCF calculation of the system with one electron
   removed, using the :program:`RASSCF` program.
   This will determine the center of charge which is
   a suitable choice to center the Rydberg basis function
   expansion. The result is rather insensitive to this choice.

#. Add a suitable diffuse primitive basis set at the center of charge.
   We use as universal exponents those optimized by Kaufmann *et al.* :cite:`Kaufmann:89`
   for Rydberg wave functions.

#. Repeat the RHF or CASSCF calculation in the new basis.

#. Construct the basis set using the program :program:`GENANO` and use the lowest virtual
   function to define the basis set.

It is better not to use an extremely large valence basis set to
perform these calculations. The best choice is a double-zeta or
double-zeta plus polarization basis set.
In this example we will use benzene which have a natural
origin in the center of the ring.
Thus we have eliminated the step of determining the
center of charge.
Also we have made the simplification of only considering s-functions.

The procedure we will follow is

#. Create inputs for :program:`SEWARD`, :program:`SCF`, :program:`RASSCF`,
   and :program:`GENANO`.

#. Create a shell script to run
   :program:`SEWARD`, :program:`SCF`, and :program:`RASSCF`,
   and run the job.

#. Hand edit the resulting formated orbital file, :file:`C6H6.RasOrb`.
   Set the occupation numbers for the occupied space to zero, while
   the first three virtual orbitals in the first irreducible representation
   get the occupation numbers :math:`10^{-1}`, :math:`10^{-2}` and :math:`10^{-3}`
   respectively. These occupation numbers are quite arbitrary as long
   as they form a decreasing sequence.

#. Create a shell script to run :program:`GENANO` and run the job.

#. The resulting file :file:`C6H6.Ano` now contains the contraction coefficients.
   Merge this file with the exponents in the :program:`SEWARD` input to obtain the final
   contracted basis set. We normally use only one function of each type.

The radial extent of the resulting basis functions is shown in
:numref:`fig:rydberg_orbitals`.

.. figure:: ex-99.*
   :name: fig:rydberg_orbitals
   :width: 75%
   :align: center

   Radial extent of the Rydberg orbitals.

Here are the inputs used for this example. First the SEWARD input
using the uncontracted Rydberg functions (note that only the s-type Rydberg
basis is shown).

.. extractfile:: advanced/SEWARD.Rydberg.input

  &SEWARD &END
  Title
   Benzene molecule.
  Symmetry
  X Y Z
  *OneOnly
  Basis set
  C.ano-s...3s2p1d.
  C1    2.636169     .000000     .000000
  C2    1.318084    2.282990     .000000
  End of basis
  Basis set
  H.ano-s...2s1p.
  H1    4.684633     .000000     .000000
  H2    2.342316    4.057011     .000000
  End of basis
  Basis set
  X....8s8p8d. / Inline
    0.0 0
  8 8
  .02462393 .01125334 .00585838 .00334597 .00204842 .00132364 .00089310 .00062431
  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
  0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0
  0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0
  0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0
  0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0
  0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0
  0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0
  0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0
  X     0.000000    0.000000     .000000
  End of basis
  End of input

Once computed, the contracted functions will replace the uncontracted ones.
In the usual calculations we are going to use one function of each type,
1s1p1d, but we can keep three of them if we want to increase the Rydberg
basis for some particular use. Here is the input listing for the generation of
the ANO. Note that in newer versions of |molcas| the sequence of calculations is
driven by the input list. You can skip parts of the calculation by commenting
out (with a ``*``) the corresponding namelist input (for example ``* &SEWARD &END``
skips the integral calculation).

.. extractfile:: advanced/GENANO.C6H6.sample

  &SEWARD &END
  Title
   Benzene molecule.
  Symmetry
  X Y Z
  *OneOnly
  Basis set
  C.ano-s...3s2p1d.
  C1    2.636169     .000000     .000000
  C2    1.318084    2.282990     .000000
  End of basis
  Basis set
  H.ano-s...2s1p.
  H1    4.684633     .000000     .000000
  H2    2.342316    4.057011     .000000
  End of basis
  Basis set
  X....1s1p1d. / Inline
    0.0 0
  8 1
  .02462393 .01125334 .00585838 .00334597 .00204842 .00132364 .00089310 .00062431
     .15531366  -.26126804   .38654527
   -1.53362747 -1.27182240   .94560891
    1.10186802   .95250581 -1.24269525
   -1.70918216   .49632170 -2.22724281
    2.03031830   .68292933  1.94719179
   -1.73187442  -.56245782   .68883478
     .92694465   .30675927   .15138171
    -.22934028  -.07852136  -.02092438
  X     0.000000    0.000000     .000000
  End of basis

  &SCF &END
  Title
   Benzene molecule.
  Occupied
   6 5 4 3 1 1 1 0
  End of input

  &RASSCF &END
  Title
   Benzene molecule
  Symmetry
   7
  Spin
   2
  nActEl
    1 0 0
  Inactive
   6 5 4 3 1 1 0 0
  Ras2
   0 0 0 0 0 0 1 0
  LumOrb
  Thrshld
  0.5d-8 0.5d-4 1.0d-4
  Iterations
   50 25
  End of input
  >>COPY $Project.RasOrb  NAT001
  >>COPY $Project.OneInt  ONE001
  >>COPY $Project.RunFile RUN001

  &GENANO &END
  Title
   Rydberg basis set for benzene.
  sets
   1
  Center
  X
  Weights
   1.0
  end of input

.. index::
   single: Program; GENANO
   single: GENANO

Here is the shell script used for this example. It is written in Korn shell,
but no exotic features of Korn shell are used, so rewriting them into
C shell, or whatever your favorite shell is, is a straightforward matter.

.. index::
   single: Shell script

::

  #!/bin/ksh
  Project='C6H6'
  Home=$PWD
  WorkDir=/temp1/$LOGNAME/$Project
  export Project WorkDir
  print 'Start of job:' $Project
  print 'Current directory:' $Home
  print 'Scratch directory:' $WorkDir
  #
  trap 'exit' ERR
  rm -fr $WorkDir
  #
  molcas  $Home/$Project.input >$Project.output
  #
  rm -r $WorkDir

For thiophene one can proceed in the same way. The only
difference (apart from the fact that we generate s,p,d
functions) is that two states of the cation are going to
be computed and therefore the final step using the
GENANO program will involve two files and have the following input: ::

  !ln -s $Home/Thiophene.Ano      ANO
  !ln -s $Home/Thiophene.RasOrb1  NAT001
  !ln -s $Home/Thiophene.RasOrb2  NAT002
  !ln -s Thiophene.OneInt         ONE001
  !ln -s Thiophene.OneInt         ONE002

  &GENANO &END
  Title
   Rydberg basis set for thiophene.
  sets
   2
  Center
  X
  Weights
   0.5 0.5
  End of input

The charge centroid is chosen as an average of the charge centroids
of the two cations.

.. index::
   single: Program; Seward
   single: Seward
   single: Program; SCF
   single: SCF
   single: Program; RASSCF
   single: RASSCF
   single: Basis set; For excited states

SEWARD and CASSCF calculations
..............................

Once we have built the diffuse basis set we can proceed with the
SEWARD and CASSCF calculations of the different states. Remember that
no quantitative result can be expected for calculations which use
less than a DZP basis set. Additionally, as we are using methods
which include large amounts of correlation, it is also recommended
to use basis sets designed to include the correlation, such as the
Dunning correlation-consistent basis sets or the Atomic Natural
Orbital-type basis sets. Several tests of the accuracy of the
ANO-type basis sets for calculations on excited states can
be found elsewhere :cite:`Fuelscher:94a`. It was found that the
minimum basis set suitable for calculations on excited states
is the ANO 3s2p1d basis set for the first row atoms, with
2s functions for the hydrogen. The recommended basis however is
an ANO 4s3p1d basis set.

We proceed with the calculations on thiophene. The inputs for
the programs :program:`SEWARD`, :program:`SCF`, and :program:`RASSCF`
(:math:`^1A_1` states) are: ::

  &SEWARD &END
  Title
  Thiophene molecule. Experimental gas-phase geometry.
  Symmetry
   X Y
  Basis set
  S.ANO-L...5s4p2d.
  S1    0.000000  0.000000  0.000000  Bohr
  End of basis
  Basis set
  C.ANO-L...4s3p1d.
  C1    0.000000  2.333062  2.246725  Bohr
  C2    0.000000  1.344416  4.639431  Bohr
  End of basis
  Basis set
  H.ANO-L...2s1p.
  H1    0.000000  4.288992  1.677364  Bohr
  H2    0.000000  2.494694  6.327573  Bohr
  End of basis
  Basis set
  X....1s1p1d / Inline
   0.0000000 2
  *  s-type diffuse functions
      8    1
   .024624 .011253 .005858 .003346 .002048 .001324 .000893 .000624
    .38826283
  -1.91720062
   1.70115553
  -2.69265935
   3.15654806
  -2.69329518
   1.44320084
   -.35712479
  *  p-type diffuse functions
      8    1
   .042335 .019254 .009988 .005689 .003476 .002242 .001511 .001055
    .14713386
   -.64370136
   -.17112583
   -.62433766
    .58193247
   -.53426167
    .30777301
   -.08250038
  *  d-type diffuse functions
      8    1
   .060540 .027446 .014204 .008077 .004927 .003175 .002137 .001491
    .24501363
    .04635428
    .66592833
   -.08963981
    .52211247
   -.32807746
    .18219220
   -.04616325
  X               .0000000000         .0000000000         .1609268500
  End of Basis
  End of Input

  &SCF &END
  Title
   Thiophene molecule
  Occupied
  11 1 7 3
  Iterations
  40
  End of Input

  &RASSCF &END
  Title
   Thiophene. pipi  1A1 states
  Symmetry
      1
  Spin
      1
  Nactel
      8    0    0
  Frozen
      4    1    3    0
  Inactive
      6    0    4    0
  Ras2
      1    5    0    3
  CiRoot
  6 6
  1 2 3 4 5 6
  1 1 1 1 1 1
  Iter
  50,25
  LumOrb
  End of Input
  >> COPY $Project.JobIph $CurrDir/$Project.1A1.JobIph

The last line will copy the current JOBIPH file to a file in the directory where
the job was submitted.

The wave function and natural occupation numbers obtained for the
:math:`^1A_1` states are:

.. index::
   single: RASSCF; CI coefficients
   single: RASSCF; Configurations
   single: RASSCF; Natural occupation
   single: Orbitals; Natural

::

                                    Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

        printout of CI-coefficients larger than  0.38 for root  1
        energy=   -551.412548
        conf/sym  1 22222 444     Coeff  Weight
              11  2 22000 200   0.95720 0.91624

        printout of CI-coefficients larger than  0.38 for root  2
        energy= -551.192455
        conf/sym  1 22222 444     Coeff  Weight
              14  2 22000 u0d   0.38522 0.14839
              20  2 2ud00 200   0.68777 0.47302

        printout of CI-coefficients larger than  0.38 for root  3
        energy= -551.178212
        conf/sym  1 22222 444     Coeff  Weight
              85  2 2u0d0 200   0.74016 0.54783
              86  2 2u00d 200   0.46282 0.21421

        printout of CI-coefficients larger than  0.38 for root  4
        energy= -551.155996
        conf/sym  1 22222 444     Coeff  Weight
              12  2 22000 ud0   0.49009 0.24019
              14  2 22000 u0d   0.72977 0.53257

        printout of CI-coefficients larger than  0.38 for root  5
        energy= -551.151801
        conf/sym  1 22222 444     Coeff  Weight
              85  2 2u0d0 200  -0.48463 0.23486
              86  2 2u00d 200   0.78218 0.61180

        printout of CI-coefficients larger than  0.38 for root  6
        energy= -551.106218
        conf/sym  1 22222 444     Coeff  Weight
               1  2 22200 000  -0.50027 0.25027
              20  2 2ud00 200  -0.49511 0.24514
              29  2 u2d00 200   0.46904 0.22000

        Natural orbitals and occupation numbers for root 1
        sym 1:   1.999604
        sym 2:   1.991918  1.943992  0.097398  0.000219  0.000640
        sym 4:   1.904095  0.061524  0.000611
        Natural orbitals and occupation numbers for root 2
        sym 1:   1.999436
        sym 2:   1.947529  1.248261  0.788864  0.028171  0.000731
        sym 4:   1.617765  0.032985  0.336259
        Natural orbitals and occupation numbers for root 3
        sym 1:   1.999273
        sym 2:   1.926567  1.085938  0.128802  0.904415  0.000774
        sym 4:   1.805386  0.141116  0.007730
        Natural orbitals and occupation numbers for root 4
        sym 1:   1.999591
        sym 2:   1.938931  1.828828  0.185815  0.001667  0.027931
        sym 4:   1.100050  0.074750  0.842438
        Natural orbitals and occupation numbers for root 5
        sym 1:   1.999251
        sym 2:   1.935074  1.086440  0.103317  0.001139  0.911640
        sym 4:   1.854839  0.074961  0.033340
        Natural orbitals and occupation numbers for root 6
        sym 1:   1.999766
        sym 2:   1.874358  1.484874  1.099307  0.004906  0.008790
        sym 4:   1.285113  0.235809  0.007076

.. Note: contains a nbsp

We have only included the configurations with weights larger than 10%.
Root one corresponds to the closed-shell ground state. To understand
the character of the states one must also analyze the orbitals,
remembering that the active orbitals are not ordered within the
active space.

The following output shows the coefficients of the diffuse functions
(center X) which appear in the |molcas| output.
Active orbitals two, three, and six in symmetry 2 are valence orbitals
(they have main contributions from the other functions not printed
here) and orbitals four and five are Rydberg orbitals. It is usual
that they appear as mixed orbitals (3p--3d here) but this mixing has no
consequences on the excitation energies. This is also the reason why
the Rydberg states appear not as clearly singly configurational
states but mixed as in root 5 (see above).

.. index::
   single: Orbitals; Rydberg
   single: Rydberg functions

::

     Molecular orbitals for symmetry species 2

     ORBITAL       2        3        4        5        6
     ENERGY      .0000    .0000    .0000    .0000    .0000
     OCC. NO.   1.8923   1.4570    .4122    .1674    .1689

  19 X  2px     -.0203    .0055   -.0082    .8091    .4535
  20 X  3d1+     .0064   -.0037    .0369    .4430  -1.0132

     Molecular orbitals for symmetry species 4

     ORBITAL       1        2        3
     ENERGY      .0000    .0000    .0000
     OCC. NO.   1.5865    .1722    .1439

  15 X  3d2-     .0032    .5171    .9600

.. Note: contains a nbsp

Both by looking at the configurations and the occupation numbers
we can identify the states. Root two has a main configuration described
by an excitation 3\ |bo| |->| 4\ |bo|. As 4\ |bo| is a valence orbital,
the resulting state will also be a valence state. Root three, on the
contrary, has a main configuration 3\ |bo| |->| 5\ |bo|, and 5\ |bo| is a
Rydberg orbital. 3\ |bo| is the HOMO\ |-|\1 orbital, therefore we can expect the
state represented by root three to be the HOMO\ |-|\1 |->| 3\ |px| Rydberg
state. So, why does configuration 3\ |bo| |->| 5\ |bo| contribute 21% to this
wave function
if a Rydberg state is just a singly excited state?. The answer is in the
composition of the orbitals. Orbitals four and five are a mixture
of |px| and |dxz|, and the configurational description must reflect that.

In summary we can make a initial classification of the states:

.. index::
   single: Excited states; Thiophene

| Root 1: Ground state
| Root 2: Valence :math:`\pi\to\pi^*` state
| Root 3: Rydberg 3\ |bo|\ |->|\3\ |px| state
| Root 4: Rydberg 3\ |at|\ |->|\3\ |dxy| state
| Root 5: Rydberg 3\ |bo|\ |->|\3\ |dxz| state
| Root 6: Valence :math:`\pi\to\pi^*` state

.. index::
   single: Orbitals; Valence–Rydberg mixing

Orbital two of symmetry 4 also deserves attention. It has large
contributions from the diffuse functions, although the remaining non-printed
coefficients are even larger. It is an orbital of mixed
valence--Rydberg character. This can affect the description of the valence
states. In the present system the problem is minor because the orbital
does not strongly participate in the description of the valence states
as it is shown by the configurations and the occupation numbers, but
in other systems the effect is going to be larger as we shall show later.

One important difference between valence and Rydberg states is the diffuse
character of the latter. We can analyze the orbital extension of the states.
Valence states have an orbital extension (second Cartesian moment)
similar to the ground state extension. Rydberg states, on the contrary,
should have a diffuse character. Additionally we can also study the
Mulliken population analysis. Both appear in the RASSCF output.

.. index::
   single: Properties; Mulliken analysis
   single: Mulliken analysis

::

       Mulliken population Analysis for root number: 1

       Gross atomic populations per centre and basis function type

                S1      C1      C2      H1      H2      X
       Total 15.8153 12.3470 12.2660  1.6887  1.8021   .0809

       Expectation values of various properties for root number: 1

   2-nd Cartesian moments: origin at (   .00000000,   .00000000,  2.15947162)
  ----------------------------------------------------------------------------
  Component                            XX              YY              ZZ
  Total                      -30.24626427    -21.54920631    -24.73702724

       Mulliken population Analysis for root number: 2

       Gross atomic populations per centre and basis function type

                S1      C1      C2      H1      H2      X
       Total 15.6548 12.3730 12.1962  1.6914  1.8015   .2831

       Expectation values of various properties for root number: 2

   2-nd cartesian moments: origin at (   .00000000,   .00000000,  2.15947162)
  ----------------------------------------------------------------------------
  Component                            XX              YY              ZZ
  Total                      -42.75835009    -28.13902538    -28.72863222

       Mulliken population Analysis for root number: 4

       Gross atomic populations per centre and basis function type

                S1      C1      C2      H1      H2      X
       3d2-    .0334   .0306   .0413   .0000   .0000   .9662
       Total 15.5924 11.8522 12.0083  1.6814  1.7986  1.0671

       Expectation values of various properties for root number: 4

   2-nd cartesian moments: origin at (   .00000000,   .00000000,  2.15947162)
  ----------------------------------------------------------------------------
  Component                            XX              YY              ZZ
  Total                      -89.85913318    -76.33249740    -44.45493589

       Mulliken population Analysis for root number: 6

       Gross atomic populations per centre and basis function type

                S1      C1      C2      H1      H2      X
       Total 15.6154 12.4779 12.3182  1.6946  1.8028   .0911

       Expectation values of various properties for root number: 6

   2-nd cartesian moments: origin at (   .00000000,   .00000000,  2.15947162)
  ----------------------------------------------------------------------------
  Component                            XX              YY              ZZ
  Total                      -31.85163136    -24.13169375    -26.69322385

.. Note: contains a nbsp

The Mulliken analysis provides us with the charge distribution per atom
and basis function. If we have used for the Rydberg states singly centered
Rydberg functions we can observe a population close to one on the X center.
This is what happened in root four (see above). In addition we can see that
the electron is placed in the 3d2\ |-| (3\ |dxy|) Rydberg orbital, confirming the
character of the state. The orbital extension is undoubtedly much larger
in the fourth root than in the ground state. The second and sixth roots however have
a much more compact description, especially the sixth, and they have low populations
on center X. The second root is somewhat more diffuse but it can be still considered
a clear valence state with minor Rydberg mixing.

.. index::
   single: RASSCF; Roots
   single: RASSCF; Average states

It is very important to ensure that
the relevant states of the symmetry are included in the CASSCF calculation. This
may mean performing different experiments by increasing the number of roots
and analyzing the results. Valence states are specially sensitive to this
because they are high roots at the CASSCF level. Take for instance
the sixth root. At the CASSCF level, it is 1.35 eV higher in energy than its
preceding root. It could happen that other close Rydberg states or even
valence states (such as mainly doubly excited states) were lower at this
level of calculation. It can be also helpful to analyze the transition moment
to be sure that the intense valence states are present in the set of computed
states.

.. compound::

  The RASSCF inputs for the remaining states replace the following keywords: ::

    &RASSCF
    Title
     Thiophene. pipi  1B2 states
    Symmetry
        3
    CiRoot
    5 5
    1 2 3 4 5
    1 1 1 1 1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1B2.JobIph

  ::

    &RASSCF
    Title
     Thiophene. npi  1B1 states
    Symmetry
        2
    CiRoot
    1 1
    1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1B1n.JobIph

  ::

    &RASSCF &END
    Title
     Thiophene. npi  1A2 states
    Symmetry
        4
    CiRoot
    2 2
    1 2
    1 1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1A2n.JobIph

  ::

    &RASSCF &END
    Title
     Thiophene. pisigma  1B1 states
    Symmetry
        2
    Ras2
        5    3    2    2
    CiRoot
    6 6
    1 2 3 4 5 6
    1 1 1 1 1 1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1B1.JobIph

  ::

    &RASSCF &END
    Title
     Thiophene. pisigma  1A2 states
    Symmetry
        4
    Ras2
        5    3    2    2
    CiRoot
    6 6
    1 2 3 4 5 6
    1 1 1 1 1 1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1A2.JobIph

  ::

    &RASSCF &END
    Title
     Thiophene. nsigma  1A1 states
    Symmetry
        1
    Ras2
        5    3    2    2
    CiRoot
    4 4
    1 2 3 4
    1 1 1 1
    ...
    End of Input
    >> COPY $Project.JobIph $CurrDir/$Project.1A1n.JobIph

  and use the saved :file:`JOBIPH` files subsequently.

.. index::
   single: RASSCF; Active space
   single: Orbitals; Reordering

We must ensure that the right orbitals are included into
the active space. For instance, computing the :math:`^1A_2` and
:math:`^1B_1` Rydberg states with the active space (5322) we
observe that one Rydberg orbital is absent from the active space
in both cases. For the :math:`^1A_2` state it was orbital 3\ |dyz|.
Instead, an extra-valence :math:`\sigma^*` orbital took its place and
therefore the sixth root of symmetry :math:`^1A_2` was not the expected
2\ |bo| |->| 3\ |dyz| Rydberg state. In this case we can reorder
the orbitals including the Rydberg state in the active space
and excluding the other orbital and make the calculation again.
Hopefully the new calculation will include the Rydberg state
into the selected roots. If not we can always increase the
number of roots or increase the active space to have both
orbitals included.

It is very important to remember that to compute energy differences
one must always use states computed using the same active
space. Therefore, if we are computing vertical excitation energies
we must have the ground state energy computed in all the different
active spaces employed. One can make the comparison using a ground
state computed in the average procedure or as a single root. They
do not differ significantly. For consistency, we will use a ground state
computed as a single root. Therefore we have to perform two CASSCF
calculations using the inputs where we replace: ::

  >> COPY $CurrDir/$Project.11A1.JobIph JOBIPH
  &RASSCF &END
  Title
   Thiophene. Ground state (1503)
  Symmetry
      1
  Ras2
      1    5    0    3
  CiRoot
  1 1
  1

::

  >> COPY $CurrDir/$Project.11Ar.JobIph JOBIPH
  &RASSCF &END
  Title
   Thiophene. Ground state (5322)
  Symmetry
      1
  Ras2
      5    3    2    2
  CiRoot
  1 1
  1

.. index::
   single: Program; CASPT2
   single: CASPT2
   single: CASPT2; Lroot
   single: RASSCF; JOBIPH file
   single: CASPT2; JOBIPH file

.. _TUT\:sec\:pt2out:

CASPT2 calculations
...................

Once the reference wave functions have been computed at the CASSCF level
we can perform the CASPT2 calculations. The :file:`JOBIPH` file from
each CASSCF calculation contains data that describes the state(s).
If several CASSCF states are present on a :file:`JOBIPH` file, then any
of this may act as root function for the CASPT2. The input to the CASPT2
must then tell which one of the states we want. In previous |molcas|
version the keyword :kword:`LROOt` was used. Although it will still
work, it has been substituted by the more convenient keyword :kword:`MULTistate`,
which allows now to perform Multi-State CASPT2 calculations. We will start
by discussing single state CASPT2 calculations: ::

  &CASPT2 &END
  Title
   caspt2 input
  MultiState
  1 1
  End of input

The CASPT2 calculation will be performed on the ground state
with the active space (1305), stored on the :file:`JOBIPH` file that
we named :file:`$Project.11A1.JobIph`.
The final full CASPT2 result is: ::

        Reference energy:        -551.4423376617
        E2 (Non-variational):       -.6341237973
        E2 (Variational):           -.6341237319
        Total energy:            -552.0764613935
        Residual norm:               .0000008080
        Reference weight:            .80657

.. Note: contains a nbsp

For a perfectly converged result, the two formulae used to compute E2 are
equivalent, but if there are (as is usually the case) a small residual
error in the CASPT2 equation system, then the variational result is much
more accurate. In particular, for numerical differentiation the variational
energy should always be used. If a level shift has been used, in order to
avoid singularities (see below), then the non-variational energy and the
variational one will differ. The former is the conventional E2 as obtained
with the modified (shifted) :math:`\hat{H}_0` operator, while the latter is a
corrected value very close to what would have been obtained with the unshifted
operator if the near-singular term had been removed. The latter energy is
the one that should normally be used.

.. index::
   single: CASPT2; Weight

.. compound::

  For the ground state with a reasonable active space, all coefficients in the
  first order wave function and all contributions to the second-order energy
  will be small. For excited states, large contributions may occur, and then the
  second-order perturbation treatment may be invalid. One criterion for a good
  calculation is that the reference weight should be close to that of the ground
  state. When this is not true, special remedies may be considered.
  For example, we compute the CASPT2 correction for the sixth root of symmetry
  one, using the :file:`JOBIPH` file called :file:`$Project.1A1.JobIph`. The input is: ::

    &CASPT2 &END
    Title
     caspt2 input
    MultiState
    1 6
    End of input

  and the result (always full CASPT2 results): ::

          Reference energy:        -551.1062184006
          E2 (Non-variational):       -.7460718503
          E2 (Variational):           -.7460719607
          Total energy:            -551.8520232128
          Residual norm:               .0000009146
          Reference weight:            .29470

We observe a low weight of 0.295 for the CASSCF reference,
compared to the value 0.807 in the ground state. The low weight for
the excited state is a warning sign: the second order treatment may
be invalid. However, if so, the problem is due to one or a few
specific terms in the first-order wave function.

.. index::
   single: CASPT2; Intruder states
   single: Intruder states

In the output, there is a section with warnings for
large contributions to the energy, low denominator values, or large
coefficients.::

  CASE  SYM   ACT IND   NON-ACT INDICES  DENOMINATOR  RHS value  COEFFICIENT CONTRIBUTION

  ATVX   2   Mu2.0001   Se2.007           .01778941  -.00706261   .72136097  -.00509469
  ATVX   2   Mu2.0001   Se2.009           .20859986   .03118841  -.14372642  -.00448260
  ATVX   4   Mu4.0001   Se4.004           .02156184  -.01357269  1.20409651  -.01634282
  AIVX   1   Mu1.0001   In1.010 Se1.014   .08105563   .00023689  -.00197645  -.00000047
  AIVX   1   Mu1.0001   In3.007 Se3.012   .28275882  -.02231776   .08282960  -.00184857

In CASPT2, the wave operator is a sum of two-electron excitations,
:math:`\sum C_{pqrs}\hat{E}_{pqrs}`, where the singlet excitation operator
:math:`\hat{E}_{pqrs}` is normal-ordered and summed over spin. The electrons
are transferred from :math:`s` to :math:`r` and from :math:`q` to :math:`p`.

.. index::
   single: CASPT2; Excitations

No one-electron excitations are used. This is not due to any approximation;
it is simply because, for a RASSCF root function with active electrons, the
single excitations are exact linear combinations of the double excitations.

The non-orthogonality, as well as the non-diagonal terms of the :math:`\hat{H}_0`, makes it
difficult (and to some extent irrelevant) to obtain a label that partitions the
wave function and correlation energy in terms of orbital indices of elementary
excitations. However, the CASPT2 program uses internally an orbital system that
diagonalizes part of the Fock matrix: the block diagonal part which does not
include coupling between inactive, active and virtual orbitals. The first-order
wave function, or equivalently the first-order wave operator, can be
subdivided into terms that are grouped into eight different cases. These are named
by four-letter combinations as follows. The letters A, B, C or D are used for
secondary (virtual) orbitals; T, U, V, or X for active ones, and I, J, K or L
for inactive orbitals. A case such as ATVX contains wave operator terms that
can be written as :math:`\hat{E}_{atvx}`, where :math:`a` is a virtual orbital and :math:`t`, :math:`v`,
and :math:`x` are active.

The first-order wave function can be subdivided into individual terms labeled
by the case (e.g. ATVX), the individual non-active orbital indices, and an
active superindex that labels a linear combination of terms with different
active orbital indices. The linear combination will "mix" all active indices or
index combinations within the case (with symmetry restrictions, if any) in such
a way that *the individual terms that are used internally in the CASPT2
programs are orthogonal, and they diagonalize the block-diagonal part of* :math:`\hat{H}_0`.

.. index::
   single: CASPT2; Denominators

Of course, the complete :math:`\hat{H}_0` is used to solve the CASPT2 equations, which
is why an iterative procedure is needed. However, in the diagnostic output above,
the "DENOMINATOR" value is that of the resolvent of the block-diagonal part of
:math:`\hat{H}_0`. However, for diagnostics, this is a good approximation. (That it is
not exact only shows by the fact that singularities in the energy do not
occur exactly when the "DENOMINATOR" reported is equal to 0.)

The orbitals are labeled by the symmetry type, a period, and then the ordering number
within that symmetry type. However, for clarity, it also is prefixed by the letters
"Fr", "In", "Ac", "Se" or "De" for frozen (uncorrelated), inactive, active,
secondary, and deleted orbitals. In the wave operator, the only possible orbital
labels are "In" and "Se".
The active superindex is given in formulae as :math:`\mu`, :math:`\nu`, etc so it is
given a prefix "Mu".

Most of the cases are further subdivided into a plus and a minus linear combination
making altogether 13 cases. Thus, the BVAT case is subdivided into BVATP and BVATM,
containing terms of the type :math:`\hat{E}_{bvat} \pm \hat{E}_{avbt}`, respectively.
This has nothing to do with spin. It offers some technical advantages in the
equation solution.

.. table:: Labeling for the configurations in :program:`CASPT2`.
   :name: tab:pt2ex

   ======= === ============ ==== ============= ============ ==== =============
   Config.     Excitation 1                    Excitation 2
   ======= === =============================== ===============================
   VJTU        Inactive (J) |->| Active (V)      Active (U) |->| Active (T)
   VJTIP       Inactive (J) |->| Active (V)    Inactive (I) |->| Active (T)
   VJTIM       Inactive (J) |->| Active (V)    Inactive (I) |->| Active (T)
   ATVX          Active (T) |->| Secondary (A)   Active (X) |->| Active (V)
   AIVX        Inactive (I) |->| Secondary (A)   Active (X) |->| Active (V)
   |zws|   or:   Active (X) |->| Secondary (A) Inactive (I) |->| Active (V)
   VJAIP       Inactive (J) |->| Active (V)    Inactive (I) |->| Secondary (A)
   VJAIM       Inactive (J) |->| Active (V)    Inactive (I) |->| Secondary (A)
   BVATP         Active (V) |->| Secondary (B)   Active (T) |->| Secondary (A)
   BVATM         Active (V) |->| Secondary (B)   Active (T) |->| Secondary (A)
   BJATP       Inactive (J) |->| Secondary (B)   Active (T) |->| Secondary (A)
   BJATM       Inactive (J) |->| Secondary (B)   Active (T) |->| Secondary (A)
   BJAIP       Inactive (J) |->| Secondary (B) Inactive (I) |->| Secondary (A)
   BJAIM       Inactive (J) |->| Secondary (B) Inactive (I) |->| Secondary (A)
   ======= === ============ ==== ============= ============ ==== =============

For more details see Refs. :cite:`Andersson:90,Andersson:92a,Andersson:92e`

The first configuration shown in the thiophene output involves the excitation
from the active space to the secondary orbital, which is orbital nr
seven of symmetry two (Se2.007). The denominator value for this
configuration is close to zero (0.01778941). This is an energy difference,
in the :math:`\hat{H}_0` approximation. Thus the root state, and some
eigenstate of :math:`\hat{H}_0` in the interacting space, have almost the same
energy value.

Such states, that were not included in the CASSCF configuration interaction
but have energies within the range of the lowest CAS states, cause frequent
problems in excited state calculations, since they often give
small denominators and even, at particular geometries, singularities. We
call these states intruders, by analogy to a similar phenomenon in multi-state
perturbation theory.
A calculation of excited states by means of a perturbation theory
based on an active space has to deal with the problem of intruder states.
This is especially common when large and diffuse basis
sets, such as the Rydberg functions, are included in the calculations.

In this example, the coefficient to the
first order wave function is large (0.72136094). So is
the contribution to the second order energy (\ |-|\0.00509469 |Eh|),
|-|\0.14 eV. Even worse is the situation for the third term printed
involving the fourth orbital (secondary) of symmetry four
with an energy contribution of 0.44 eV. The analysis of the secondary
orbitals 7\ |bo| and 4\ |at| (they are the first virtual orbital of their
symmetry) indicates that they are extremely diffuse orbitals with
large Rydberg character. Remember that the subspaces we are
using are: frozen (4130), inactive (6040), and active (1503).

This is not the case in the other configurations shown. First we
have other ATVX terms including the excitation to the secondary
orbital Se2.009. Also we have an AIVX term, involving
the excitation from inactive In3.007 to secondary Se3.012. Their
contributions to the second order energy, |-|\0.00448260 and |-|\0.00184857,
respectively, are not caused by accidental near degeneracies in the value of
the denominator. The orbitals involved are not of Rydberg character either.
We have finally included as an example the excitation AIVX involving
the excitation from In1.010 to Se1.014. Although it has a small value
for the denominator, its contribution to the second order energy is
very small and therefore it does not represent an important problem.

Intruders can be eliminated by including sufficiently many orbitals in
the active space. When this is a reasonable alternative, it is the preferred
solution. Limitations in the number of active orbitals
can make this approach impractical. However, especially when intruders
have clear Rydberg character, their effect on the second-order energy is
often small, except perhaps in a small range of geometries around a singularity
due to accidental degeneracy. In this common situation, two other remedies
are available: shifting the :math:`\hat{H}_0` Hamiltonian, or deleting virtual
orbitals. These remedies will be described in some detail in the following.

.. index::
   single: Intruder states
   single: CASPT2; Intruder states
   single: CASPT2; Level-shift
   single: CASPT2; Shift
   single: LS-CASPT2

In order to obtain continuous potential energy functions, one cannot use a
case-by-case approach, such as deleting an orbital. However, the :math:`\hat{H}_0`
can be modified in such a way as to eliminate weak singularities.
A well-tested method is a level-shift technique called
LS-CASPT2 :cite:`Roos:96b,Roos:95b`.
A constant parameter is added to the external part of the zeroth-order
Hamiltonian. Any denominator close to zero is thus shifted away from zero, and
does not produce any singular term. Of course, in a worst-case scenario, it
might happen that some other denominator, previously non-zero, is shifted to
come close to zero. In general,
it is the higher excited states, in combination with large diffuse basis sets
and exploration of a large range of geometries, that is the greatest risk for
troublesome intruders.

There is also a new, less tried technique, called the imaginary shift
method :cite:`Forsberg:96`. Here, the use of an imaginary shift value (but
taking the real part of the computed correlation energy) offers some
advantage, since an imaginary shift cannot introduce new singularities.

.. compound::

  With either of the level shift methods, the (2nd order) correlation energy :math:`E_2`
  and the (1st order) wave function will depend on
  the level shift used. A correction of therefore applied, whereby in practice
  this dependence is made small, except of course for the spurious term that has
  disappeared. The corrected energy is in fact computed by using Hylleraas' 2nd-order
  variational formula to evaluate :math:`E_2`, with the *unshifted* :math:`\hat{H}_0`,

  .. math:: E_2 = 2 \braopket{\Psi_1}{\hat{H}}{\Psi_0} + \braopket{\Psi_1}{\hat{H}_0}{\Psi_1}

  which we call the *variational* :math:`E_2` in the output listing.

To minimize the effect on relative energies, we recommend that the same level shift is
used for all states and geometries, if possible. This may require some
experimenting. A criterion on absence of disturbing intruders is that
the weight of the reference wave function should be roughly the same in
all calculations. Without shift, a difference of up to 10% between the weights
of the ground and an excited state can be acceptable (that is, the excitation energy
is accurate enough) in a :program:`CASPT2` calculation without level shift.
Using level shift, this should be adjusted to find a better match of reference weights.
A detailed explanation of how to use the level-shift technique has been
published :cite:`Roos:96a`. Here we will simply summarize the main aspects.

Using the same :file:`JOBIPH` file as before we perform a new CASPT2 calculation
using the input: ::

  &CASPT2 &END
  Title
   caspt2 input
  MultiState
  1 6
  Shift
  0.1
  End of input

A level-shift of 0.1 |Eh| has been introduced as a separation of the
eigenvalues of the zeroth-order Hamiltonian. The final energy is then
corrected, and the result is: ::

        Reference energy:        -551.1062184006
        E2 (Non-variational):       -.6921992859
        Shift correction:           -.0334372801
        E2 (Variational):           -.7256365659
        Total energy:            -551.8315878181
        Residual norm:               .0000003986
        Reference weight:            .74942

  CASE  SYM   ACT IND   NON-ACT INDICES  DENOMINATOR  RHS value  COEFFICIENT CONTRIBUTION

  ATVX   2   Mu2.0001   Se2.007           .01778941  -.00706261   .06072347  -.00042887
  ATVX   2   Mu2.0001   Se2.009           .20859986   .03118841  -.09700134  -.00302532
  ATVX   4   Mu4.0001   Se4.004           .02156184  -.01357269   .11838970  -.00160687
  AIVX   1   Mu1.0001   In3.007 Se3.012   .28275882  -.02231776   .05918658  -.00132091

.. Note: contains a nbsp

Several details come to our attention. Firstly, the final CASPT2 energy is
higher than the result with level-shift 0.0. This is because the introduction
of the parameter decreases the amount of dynamical correlation included.
Secondly, the weight of the reference function has increased greatly, from
0.29 to 0.74, meaning that the most important intruder states have been
removed from the treatment. Finally, we can observe the new contributions
of the printed configurations to the second order energy. Configurations
involving excitations to the 7\ |bo| and 4\ |at| orbitals have drastically decreased
their contributions, proving that the previous contributions
were due to degeneracies in the denominators. However, the other two
configurations remain almost as they were before, only slightly
decreasing their contributions.

Now we use a value for the level-shift parameter of 0.2 |Eh|: ::

        Reference energy:        -551.1062184006
        E2 (Non-variational):       -.6619040669
        Shift correction:           -.0557159229
        E2 (Variational):           -.7176199898
        Total energy:            -551.8235712419
        Residual norm:               .0000009298
        Reference weight:            .78212

  CASE  SYM   ACT IND   NON-ACT INDICES  DENOMINATOR  RHS value  COEFFICIENT CONTRIBUTION

  ATVX   2   Mu2.0001   Se2.007           .01778941  -.00706261   .03193515  -.00022555
  ATVX   2   Mu2.0001   Se2.009           .20859986   .03118841  -.07304944  -.00227830
  ATVX   4   Mu4.0001   Se4.004           .02156184  -.01357269   .06238180  -.00084669
  AIVX   1   Mu1.0001   In3.007 Se3.012   .28275882  -.02231776   .04673419  -.00104300

The observed tendencies are maintained. Finally, a value of 0.3 |Eh|: ::

        Reference energy:           -551.1062184006
        E2 (Non-variational):          -.6347955450
        Shift correction:              -.0735679820
        E2 (Variational):              -.7083635270
        Total energy:               -551.8145819276
        Residual norm:                  .0000006328
        Reference weight:               .80307

  CASE  SYM   ACT IND   NON-ACT INDICES  DENOMINATOR  RHS value  COEFFICIENT CONTRIBUTION

  ATVX   2   Mu2.0001   Se2.007           .01778941  -.00706261   .02173413  -.00015350
  ATVX   2   Mu2.0001   Se2.009           .20859986   .03118841  -.05865340  -.00182931
  ATVX   4   Mu4.0001   Se4.004           .02156184  -.01357269   .04240583  -.00057556
  AIVX   1   Mu1.0001   In3.007 Se3.012   .28275882  -.02231776   .03862959  -.00086213

The contributions to the energy are much lower for each increase of the
parameter, but we must never forget that we are losing dynamical correlation
with the increase of the level-shift factor. In a calculation of excitation
energies that means that the resulting excitation energies become larger each time
(dynamical correlation is larger in the excited state).
Therefore, the level-shift parameter must be
set to the lowest possible value which solves the intruder state problems.
In practice it is then convenient to scan all the valence states for several
values of the parameter and look for two factors:

#. Reference weight as close as possible to the ground state reference weight
   with the same level shift parameter (LS).
#. Excitation energies (ES) as stable as possible with the increment of the
   level-shift parameter (LS).

We now compute the ground state (GS) also for the level-shift values of 0.1, 0.2,
and 0.3, and compare the excitation energies :math:`\Delta E` (always between states
computed with the same parameter):

.. table:: Excitation energies and reference weights of thiophene
           for different level shift values.
   :name: tab:thiols

   ===================== ===================== ===================== =====================
   LS (|Eh|)             :math:`\Delta E` (eV) weight GS             weight ES
   ===================== ===================== ===================== =====================
   0.0                   6.11                  0.81                  0.29
   0.1                   6.64                  0.82                  0.75
   0.2                   6.79                  0.83                  0.78
   0.3                   6.89                  0.84                  0.80
   ===================== ===================== ===================== =====================

After checking the remaining states we conclude that a level shift
of 0.1 |Eh| is enough for our purposes. However the results
seem to be too unstable with respect to the increase of the level-shift
parameter. As our active space only comprises nine orbitals, we can consider the
possibility of increasing it by including two more active orbitals in
symmetries |bo| and |at|. In this way we minimize the intruder states
problems in the best way, by introducing extra (not diffuse hopefully)
orbitals. This will increase the accuracy.

.. index::
   single: CASPT2; Intruder states

The introduction of a (real) level-shift parameter does not automatically
remove intruder state problems. It happens that a shift leads to more
severe problems that those observed without level-shift. Examples
and further explanations are given in e.g. ref. :cite:`Roos:96a`.
In such a case is may be possible to find a range of level-shift values
where none of the computed states present intruder state problems.
In a few cases we have found it necessary to use a shift larger than
0.3 |Eh|. Another solution is to try an imaginary shift. This option has
not been extensively investigated yet.

Consider a situation like the following: ::

  CASE  SYM   ACT IND   NON-ACT INDICES  DENOMINATOR  RHS value  COEFFICIENT CONTRIBUTION

  ATVX   2   Mu2.0001   Se2.004          -.30281661  -.00194108  -.37224517   .00072256

This is a calculation performed using level shift of 0.3 |Eh|. (The approximate
denominator printed in the listing is that *without* the added shift).
We have added
the level shift to solve intruder states problem in other states, but we
should use the same technique for all the computed states for consistency
reasons (of course always using a ground state computed with the same
level shift value). We find, however, that
the weight of the CASSCF reference function is lower in the case with
level shift 0.3 |Eh| (0.61) than in the case without level shift (0.69).
In this state we have a denominator with
a value close to |-|\0.3 |Eh|. As the level shift we apply is a positive
quantity (0.3 |Eh|) added to this denominator, we have created a problem
by decreasing the denominator to a value close to zero. The coefficient
of the configuration increases, which is reflected in the
contributions to the second-order energy. Therefore, before applying
any level shift, it is wise to check the values of the most important
denominators to see if any of them is going to be close to the value
of the applied level shift. In those situations we should set the level
shift to another value. Sometimes the consequences for the final energy
are small (here for instance) but this is not always the case
(see ref. :cite:`Roos:96a`).

.. index::
   single: Orbitals; Deleted

It is also possible to delete virtual orbitals. This is occasionally
used, e.g. when using other types of basis sets than ANO's, in order
to delete virtual orbitals that are core-correlating.
The procedure to do that is to take an orbital file, such as that
produced by SCF or RASSCF, and edit it by hand and then using it as
:file:`INPORB` file in the RASSCF step. The orbitals one wants
to delete are placed at the end of their symmetry group, and the
keyword :kword:`DELEted` in used the RASSCF input, indicating
how many orbitals are going to be deleted by symmetry. The program will
ignore the deleted orbitals, both in RASSCF and the subsequent CASPT2 steps.
To obtain accurate energy differences
it is necessary to use the same set of initial orbitals and recompute the
ground state (or the state one is comparing with) with the same number
of deleted orbitals.

When the above scheme is used in order to try to eliminate intruders in
CASPT2, the best way is if the :file:`INPORB` can be prepared from the
CASPT2 calculation where the intruder problem occurred.

For that calculation, the natural orbital analysis that
follows the CASPT2 calculation shows up a virtual orbital with abnormally
large occupation number and diffuse character. Use an editor to move this orbital
to the end of the orbital file, and use it as :file:`INPORB`.
When the calculation is repeated, intruders with this orbital heavily
populated have been eliminated.
Occasionally, several orbitals need to be removed.

The deletion of virtual orbitals works best at single-geometry
calculations, such as obtaining the vertical electronic spectrum.

.. index::
   single: MSCASPT2

Let us focus on the Multi-State CASPT2 type of calculations. The original
reference :cite:`Finley:98b` should be carefully read before using the method.
This multidimensional perturbative approach considers the coupling of a number
of CASPT2 states, a condition which is crucial to solve certain problems such
as adiabatic crossing among states, strong valence--Rydberg situations, etc.
The treatment is performed for a number of roots of the same symmetry provided
they originate from a previous State-Average CASSCF calculation, that is, the
:program:`CASPT2` program will use the binary :file:`JOBIPH` file from a
previous SA-CASSCF calculation, for instance, the six roots :math:`^1A_1` CASSCF
calculation in thiophene. The corresponding :program:`CASPT2` input to treat
simultaneously the six states will be: ::

  &CASPT2 &END
  Title
   mscaspt2 input
  MultiState
  6 1 2 3 4 5 6
  Shift
  0.3
  End of input

A level shift parameter of 0.3 |Eh| has been selected for comparison with the
previous calculations. The program creates a new
binary file, :file:`JOBMIX`, which contains the newly generated Perturbatively
Modified (PM) CASSCF wave function.

Using the previous input, the :program:`CASPT2` module will perform in a single
run six consecutive single-root CASPT2 calculations for each one of the CASSCF
states. At the end of each of the calculations the contributions to the Hamiltonian
coupling elements between the computed and the remaining states will be printed.
After computing the six CASPT2 roots, the MS-CASPT2 treatment will be performed.
First, the effective Hamiltonian matrix, asymmetric and symmetric, is printed. ::

    Effective Hamiltonian matrix (Symmetric):


                  1                2              3               4               5
    1        -.07013926
    2        -.01263691       .12976380
    3         .00071175       .01001560       .18051855
    4         .00509735       .00990244      -.00321669       .19922802
    5         .00607124       .00070650      -.00129815      -.00225583       .21601193
    6         .01998132       .02350235      -.00771000      -.01037132      -.00264941

                  6
    1         .18541807

.. Note: contains a nbsp

Notice that the diagonal elements of the matrix correspond to the single root
CASPT2 state energies, where some quantity, 551.0 |Eh| here, has been added to get a
better print of the output. Following, the eigenvalues and eigenvectors of the
diagonalized matrix are obtained: ::

    Energies and eigenvectors:

      -552.07305076  -551.88140802  -551.81866833  -551.80756578  -551.79500203

          .99308520     -.10131857      .01038991      .05207094     -.02055799
          .07343489      .90295279      .31190606      .28061095     -.05245262
         -.00869768     -.19493901      .90626880     -.37241673      .03796203
         -.02478279     -.15572120      .13596794      .50373403      .83205915
         -.02204833     -.01553573      .05330075      .08679334      .05789830
         -.08492920     -.33454317      .24485766      .72011863     -.54745806

      -551.78350398

          .01655899
         -.02245882
         -.02155609
         -.10285444
          .99274682
         -.05129770

.. Note: contains a nbsp

The eigenvalues correspond to the final MS-CASPT2 energies, while the eigenvectors
describe the combination of the coupled CASPT2 state which give rise to the final
MS-CASPT2 states. **Important:** Notice that the states are written in an increasing
energy order, and therefore they do not, in general, correspond to the order
obtained in the previous SA-CASSCF calculation. For instance, the MS-CASPT2
state number six, energy |-|\551.78350398 au, mainly correspond to the fifth state
of the previous calculation. It is very important to remember that the final
states are linear combinations of the preceding ones, and therefore a one to
one correspondence is hardly possible. In the present example most of the MS-CASPT2
states have a strong weight in just one of the preceding states, but this is not
the case in many situations. Following in the output, a printing of the new
wave function is obtained. It corresponds to linear combinations of the SA-CASSCF
CI wave functions, obtained in the basis of the previous CASSCF averaged orbitals. ::

    The CI coefficients for the MIXED state nr.   1
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
       11  2 22000 200    .960835       .923204

    The CI coefficients for the MIXED state nr.   2
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
       20  2 2ud00 200    .856751        .734023

    The CI coefficients for the MIXED state nr.   3
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
       85  2 2u0d0 200    .764848        .584993
       86  2 2u00d 200    .507350        .257404

    The CI coefficients for the MIXED state nr.   4
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
        1  2 22200 000   -.368003        .135427
       14  2 22000 u0d    .732276        .536229

    The CI coefficients for the MIXED state nr.   5
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
        1  2 22200 000    .416925        .173826
       12  2 22000 ud0    .549793        .302272
       14  2 22000 u0d    .455052        .207072

    The CI coefficients for the MIXED state nr.   6
   ----------------------------------------------------------------------------
   CI COEFFICIENTS LARGER THAN 0.36
    Occupation of active orbitals, and spin coupling
    of open shells. (u,d: Spin up or down).
     Conf Occupation        Coef          Weight
       85  2 2u0d0 200    -.517972       .268295
       86  2 2u00d 200     .776117       .602358

.. Note: contains a nbsp

.. index::
   single: PMCASSCF wave functions

The comparison of the present wave functions, that will be hereafter
called Perturbatively Modified (PM) CASSCF wave functions, and the
previous CASSCF wave functions leads to several conclusions. Remember
that the orbital basis has not changed, therefore those mixing related
to the orbitals are not going to disappear. For instance, state number
three will still be formed by two configurations, because the Rydberg
3px character is still delocalized between orbitals 5 and 6 or symmetry
\bo. However the character of the second root has changed dramatically.
Now one single configuration describes the state, which has acquired a
very clear valence character. The previous mixing with a Rydberg-like
configuration has disappeared. It is illustrative to carry out
an additional analysis of the obtained states using the generated
file :file:`JOBMIX` as input file to perform
a :program:`RASSI` calculation, in which new PM-CASSCF properties
for the states will be obtained. Even when the changes in energies
are small, changes in the properties can be considerable.
:program:`RASSI` provides different types of matrix elements
(see next section), and dipole moments, transition dipole moments
and their directions, and orbital extensions (all of them available
from the :program:`RASSI` output) will be crucial for our purposes
in the study of excited states.

Finally, it is necessary to remember that the extent of the MS interaction
relies on the mixing of the previous states. This depends on different
factors. The basis sets is one of them. The use of one or other atomic
basis set to describe the diffuse functions may lead to different answers.
It is not uncommon that CASPT2 results with different diffuse basis sets
give different answers due to different extents of the valence--Rydberg
mixing. It will be necessary to perform final MS-CASPT2 calculations.
Those will change the CASPT2 result in some cases, but it will be
unaffected in other cases. Another effect comes from the use
of the level shift. The use of MS-CASPT2 does not prevent or
affect the extent of the intruder effects. Remember that this effect
is already included both in the diagonal terms of the effective
Hamiltonian as in the non-diagonal coupling terms. Still a careful checking
of different LS values and how they affect the CASPT2 values must be
performed, and the final MS-CASPT2 results should be those in which
the effect of the intruder states is small, always trying to use as low level
shift values as possible. An alternative is to use an imaginary level shift.
Finally, the extent of the off-diagonal coupling elements and its asymmetric
character introduce further inaccuracies in the treatment. In most cases the
proper enlargement of the active space diminishes most of the spurious
effects and increases the accuracy.

.. index::
   single: Properties; Transition dipole moments
   single: Transition dipole moments
   single: Program; RASSI
   single: RASSI

.. _TUT\:sec\:rassi_thio:

Transition dipole moment calculations
.....................................

One powerful tool included in the |molcas| package is the :program:`RASSI` program.
RASSI (RAS State Interaction) forms matrix elements of the Hamiltonian
and other operators in a wave function basis which consists of
individually optimized CI expansions from the RASSCF program.
It also solves the Schrödinger equation within the space of these
wave functions. In spectroscopy we need to compute the matrix elements
of a one-electron operator such as the dipole transition moment
to obtain the intensity of the transitions. In an absorption process
this means computing the interaction of the ground state with the
excited states. RASSI will compute all matrix elements among the
states provided they have been computed with the number of inactive
and active orbitals, and using the same basis set.
The transition dipole moments are computed using the length
representation.

.. compound::

  In our example we have used two different active spaces.
  We therefore need to perform at least two RASSI calculations.
  First we will compute the interaction of the ground
  state :math:`1^1A_1` (computed as single root), with the :math:`\pi\to\pi^*`
  :math:`^1A_1` and :math:`^1B_2` excited states. We should link the corresponding
  :file:`JOBIPH` files:

  .. index::
     single: RASSI; JOBIPH file

  ::

    ln -fs $Project.11A1.JobIph JOB001
    ln -fs $Project.1A1.JobIph JOB002
    ln -fs $Project.1B2.JobIph JOB003

  and use the RASSI input file: ::

    &RASSI &END
    Nrofjobiphs
     3 1 5 5
      1
      2 3 4 5 6
      1 2 3 4 5
    End of input

As we are using states that are not orthogonal (this is the case
among the :math:`1^1A_1` ground state computed as a single root and
the other :math:`^1A_1` states) we must take the matrix elements
of the transition dipole moment computed after the transformation
to the eigenbasis; the second time they appear in the
output: ::

   PROPERTY: MLTPL  1   COMPONENT:   2
   ORIGIN    :  .00000000D+00  .00000000D+00  .00000000D+00
   STATE     :       1              2              3              4

       1        .00000000D+00  .00000000D+00 -.43587844D+00  .00000000D+00
       2        .00000000D+00  .00000000D+00 -.10019699D+01  .00000000D+00
       3       -.43587844D+00 -.10019699D+01  .00000000D+00 -.46859879D+00
       4        .00000000D+00  .00000000D+00 -.46859879D+00  .00000000D+00
       5        .90773544D-01  .75718497D-01  .00000000D+00  .27645327D+00
       6        .00000000D+00  .00000000D+00  .41227462D+01  .00000000D+00
       7        .00000000D+00  .00000000D+00  .89741299D+00  .00000000D+00
       8       -.16935368D+00  .15487793D+01  .00000000D+00 -.41013917D+01
       9        .81381108D+00  .79559359D+00  .00000000D+00 -.88184724D-01
      10        .00000000D+00  .00000000D+00 -.43659784D+00  .00000000D+00
      11        .13520301D+01  .50454715D+00  .00000000D+00  .56986607D-01

  ...

   PROPERTY: MLTPL  1   COMPONENT:   3
   ORIGIN    :  .00000000D+00  .00000000D+00  .22419033D+01
   STATE     :       1              2              3              4

       1        .28126942D+00 -.92709234D+00  .00000000D+00  .11876829D+00
       2       -.92709234D+00  .26218513D+00  .00000000D+00  .14100968D+00
       3        .00000000D+00  .00000000D+00  .52558493D-01  .00000000D+00
       4        .11876829D+00  .14100968D+00  .00000000D+00  .36996295D+00
       5        .00000000D+00  .00000000D+00 -.43197968D+01  .00000000D+00
       6       -.15470487D+00 -.42660550D+00  .00000000D+00  .94593876D+00
       7       -.18676753D-01  .18738780D+01  .00000000D+00 -.37737952D+01
       8        .00000000D+00  .00000000D+00 -.28182178D+00  .00000000D+00
       9        .00000000D+00  .00000000D+00  .38253559D+00  .00000000D+00
      10        .12859613D+01  .48476356D+00  .00000000D+00  .35525361D+00
      11        .00000000D+00  .00000000D+00 -.39325294D-01  .00000000D+00

.. Note: contains a nbsp

.. index::
   single: RASSI; Symmetry

We have a symmetric matrix containing the results. The matrix elements
corresponding to the interaction of the first state in the input
(ground state) and the remaining states appear both in the first
column and in the first row (only partially printed here). Remember
that the transition dipole moment (TDM) matrix elements are determined by the symmetry.
The matrix element :math:`\braopket{^1A_1}{\text{TDM}}{^1A_1}` will be zero for the
:math:`x` and :math:`y` components of TDM, and non-zero otherwise.
The matrix element :math:`\braopket{^1A_1}{\text{TDM}}{^1B_2}` will be non-zero only
for the :math:`y` component of TDM. This is because the product
(wave function 1 |x| dipole moment component |x| wave function 2), if decomposed into
irreducible representations, must contain the
totally symmetric representation to have an allowed transition. In this simple case,
we can use a multiplication table for the irreps.
Thus, for instance, (:math:`^1A_1(z) \times \text{TDM}_y \times {}^1A_1(z)`) gives :math:`y`, which
does not belong to the totally symmetric representation. A look at the
character table and the behavior of the :math:`x`, :math:`y`, :math:`z` functions will give us the
information we need.

Therefore, in the component two (:math:`y`) of the transition dipole moment
matrix elements we have zero values for the interaction among :math:`^1A_1`
states and non-zero values for the interaction among :math:`^1A_1` and :math:`^1B_2`
states.

The :program:`RASSI` program in 6.0 and later versions of |molcas| will print the
oscillator strengths and the Einstein :math:`A` coefficients for all transitions. Also
the angles of the transition moment vectors to the coordinate axes will be
printed. In the calculation :program:`RASSI` will use the energies given as input, so be
careful to use the keywords :kword:`HDIAG` or :kword:`EJOB` to use energies which include dynamic
correlation.

We illustrate how the oscillator strengths are computed. The 11 states are
ordered by CASSCF energies. We focus on the valence states; firstly the fourth
and fifth :math:`^1B_2` states. Their transition dipole moment values in
atomic units are 0.81381108 and 1.3520301, respectively. The oscillator
strength is defined as:

.. index::
   single: Oscillator strength
   single: Properties; Oscillator strength

.. _eqn\:oscillator:

.. math:: f = \frac{2}{3} (\text{TDM})^2 \Delta E

The energy difference :math:`\Delta E` is the excitation energy expressed in atomic
units. The transition moments were computed by CASSCF. It is usually not practically
possible to compute them with dynamic correlation included, except if a common set
of orbitals are used. However, the CASSCF values are usually good enough.
(Exceptions occur, e.g. close to narrowly avoided crossings or conical intersections).
The excitation energies, on the other hand, are quite sensitive to dynamic
correlation.
Thus, it is a good approach to
use CASSCF TDMs and CASPT2 excitation energies. The values for the oscillator
strengths of the two :math:`^1B_2` valence states are 0.086 and 0.324, respectively.
The excitation energies are 5.31 and 7.23 eV, respectively. All data corresponds
to results obtained using the 0.1 |Eh| value for the level-shift parameter.

Remember that in other symmetries like :math:`C_{2h}` the :math:`^1B_2` states have
two components of TDM, :math:`x` and :math:`y`, for which the matrix elements with
respect to the ground state are non-zero. In this case the :math:`\text{TDM}^2` value
is computed as :math:`\text{TDM}_x^2 + \text{TDM}_y^2`. In those cases is is also possible to
compute the direction of the total TDM vector by taking their components and
compute the angle respect to any of the axis.

You will find the complete calculation of the absorption spectrum of thiophene
in reference :cite:`Serrano:93a`. You can observe that, despite there being
no level-shift technique used, the final results on the excitation energies
agree to within 0.1 eV to those shown here.

.. index::
   single: Valence states
   single: Rydberg states
   single: Basis set; Rydberg functions

Influence of the Rydberg orbitals and states. One example: guanine
------------------------------------------------------------------

Thiophene has a valence :math:`\pi`,\ :math:`\pi^*` orbital space small
enough to allow the simultaneous inclusion of all the corresponding Rydberg orbitals
into the active space (remember valence space (1302) + Rydberg spaces
(0201) or (4020)), but this is not always the case. In addition, the
valence--Rydberg mixing is not severe. This mixing is reflected
in the orbital extension or the population analysis. In difficult cases
valence and Rydberg orbitals mix, and then the configurations also mix.
Valence states become more diffuse and Rydberg states more compact.
Energetically this has minor consequences for the Rydberg states, which
can be computed using these CASSCF mixed wave functions. This is not
the case for the valence states. They are extremely sensitive to the
mixing. Therefore, if we do not observe clear and compact valence states
some mixing has occurred.

.. index::
   single: Guanine
   single: Excited states; Rydberg
   single: Active space

We consider
the example of the guanine molecule, the nucleic acid base monomer.
It is a system with 11 valence :math:`\pi`,\ :math:`\pi^*` orbitals which should be included
into the active space. It is a planar system
in the :math:`C_s` point group. Focusing only in the :math:`\pi\to\pi^*` states
we can label the active orbital space (0,11) where 0 is the number of
:math:`a'` orbitals and 11 the number of :math:`a''` orbitals. In :math:`C_s` symmetry the
Rydberg orbitals are distributed as (6,3), using the same labeling.
Therefore the calculation of the corresponding :math:`A'` states should
use the space (0,14) with 14 active electrons and a large number of
roots. This is a large calculation that one might want to avoid.
One can perform several
test calculations (maybe even RASSCF calculations) and find if
any orbitals can be excluded. The lowest occupied
:math:`\pi` orbital is a deep orbital which does not participate in the
lowest valence excited states and can be excluded from the active
space. Despite this exclusion, a (0,13) orbitals calculation is
still expensive. We can proceed in another way.
Consider the new valence space (0,10), and add only one more
orbital designed to include the first Rydberg orbital.
With this space of (0,11) orbitals and 12 active electrons we perform
a CASSCF including 6 roots.

.. figure:: guanine.*
   :name: fig:guanine
   :width: 50%
   :align: center

   Guanine

Our basis set is of the ANO-L type
contracted to C,N,O 4s3p1d / H 2s, plus 1s1p1d optimized
diffuse functions placed in the cation charge centroid.
The results are collected in :numref:`tab:gua1`.

.. table:: CASSCF and CASPT2 excitation energies (eV), oscillator strengths (f),
           dipole moments (:math:`\mu` (D)), and transition moment directions (:math:`\Theta`) of singlet valence excited states of guanine\ [#b]_. The Rydberg orbitals have not been included in the active space.
   :name: tab:gua1

   ============= ================ ================ ================ ================ ================ ================ ================ ===========================
   State         Theoretical                                                                          Experiment
   ------------- ------------------------------------------------------------------------------------ -------------------------------------------------------------
   |zws|         CAS              PT2              :math:`f`        :math:`\Theta`   :math:`\mu`      :math:`\Delta E` :math:`f`        :math:`\Theta`
   ============= ================ ================ ================ ================ ================ ================ ================ ===========================
   :math:`\pi`--:math:`\pi^*` transitions
   ----------------------------------------------------------------------------------------------------------------------------------------------------------------
   :math:`2^1A'` 5.72             4.47             0.20             |-|\64\ |o|      1.07             4.4--4.5         0.16             (|-|\4\ |o|,35\ |o|)
   :math:`3^1A'` 6.74             5.30             0.09             +52\ |o|         2.72             4.9--5.0         0.25             (|-|\75\ |o|)
   :math:`4^1A'` 7.18             5.63             0.05             |-|\90\ |o|      3.10             5.7--5.8         < 0.05
   :math:`5^1A'` 8.45             6.83             0.26             0\ |o|           3.20             6.1--6.3         0.41             (|-|\71\ |o|,\ |-|\79\ |o|)
   ============= ================ ================ ================ ================ ================ ================ ================ ===========================

.. [#b] See ref. :cite:`Fuelscher:97a` for details.

There are important discrepancies between theoretical and
experimental results, more important in the properties such as the
intensities and the transition dipole moments than in the excitation
energies. If we analyze the CASSCF output everything
is apparently correct: six converged roots, all of them clear valence
states, and no Rydberg orbital into the active space. This is the problem.
At least one of the Rydberg orbitals should have been introduced into the
active space. Rydberg and valence orbitals must be treated simultaneously
and this is not possible if there is no Rydberg orbital in the active space.

.. index::
   single: Orbitals; Deleted
   single: RASSCF; Delete
   single: Orbitals; Rydberg

The correct way to proceed is to take the first Rydberg orbital (3\ |pz|)
and place it as the 11th active orbital of :math:`a''` symmetry. Then
the CASSCF calculation will retain it in the space. Once the calculation
has converged we observe than at least one of the computed states is of
Rydberg character. It can also happen that some mixing appears in the
valence states due to the presence of the diffuse orbital in the active space.
The Rydberg orbital is then removed (placed in the last
position of its symmetry and the :kword:`DELEte` option used)
from the active space and the calculation
repeated. This time the next Rydberg orbital (3\ |dxz| or 3\ |dyz|) will take
its place. The process is repeated once again until the three Rydberg
orbitals have been first included in the active space and then
deleted (option :kword:`DELEted` of the RASSCF program). Now
we can reduce the active space to (0,10), only including valence orbitals
and valence excited states.

We can repeat the calculation including even more roots. The results
are in :numref:`tab:gua2`.

.. |bb| replace:: :math:`\Bigg\}`

.. table:: CASSCF and CASPT2 excitation energies (eV), oscillator strengths (f), dipole moments (:math:`\mu` (D)),
           and transition moment directions (:math:`\Theta`) of singlet valence excited states of guanine\ [#c]_ [#d]_. The Rydberg orbitals have been first included in the active space and then deleted.
   :name: tab:gua2

   +---------------+----------------------------------------------------------------------------------------------+------+-------------------------------------------------------------------+
   | State         | Theoretical                                                                                  |      | Experiment                                                        |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   |               | CAS              | PT2              | :math:`f`        | :math:`\Theta`   | :math:`\mu`      |      | :math:`\Delta E` | :math:`f`        | :math:`\Theta`              |
   +===============+==================+==================+==================+==================+==================+======+==================+==================+=============================+
   | :math:`\pi`--:math:`\pi^*` transitions                                                                                                                                                  |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   | :math:`2^1A'` | 6.08             | 4.76             | 0.133            | |-|\15\ |o|      | 7.72             |      | 4.4--4.5         | 0.16             | (|-|\4\ |o|,35\ |o|)        |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   | :math:`3^1A'` | 6.99             | 5.09             | 0.231            | +73\ |o|         | 6.03             |      | 4.9--5.0         | 0.25             | (|-|\75\ |o|)               |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   | :math:`4^1A'` | 7.89             | 5.96             | 0.023            | +7\ |o|          | 5.54             |      | 5.7--5.8         | < 0.05           |                             |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   | :math:`5^1A'` | 8.60             | 6.65             | 0.161            | |-|\80\ |o|      | 10.17            |      | 6.1--6.3         | 0.41             | (|-|\71\ |o|,\ |-|\79\ |o|) |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+
   | :math:`6^1A'` | 9.76             | 6.55             | 0.225            | |-|\41\ |o|      | 6.11             |      |                  |                  |                             |
   +---------------+------------------+------------------+------------------+------------------+------------------+      |                  |                  |                             |
   | :math:`7^1A'` | 8.69             | 6.66             | 0.479            | +43\ |o|         | 6.57             | |bb| | 6.6--6.7         | 0.48             | (|-|\9\ |o|,41\ |o|)        |
   +---------------+------------------+------------------+------------------+------------------+------------------+      |                  |                  |                             |
   | :math:`8^1A'` | 9.43             | 6.77             | 0.098            | +52\ |o|         | 7.17             |      |                  |                  |                             |
   +---------------+------------------+------------------+------------------+------------------+------------------+------+------------------+------------------+-----------------------------+

.. [#c] See ref. :cite:`Fuelscher:97a` for details.
.. [#d] A better match with the experimental values is obtained by considering solvent effects.

The results are quite different from those obtained previously, especially
regarding the
oscillator strengths and transition dipole moment directions. What we
have before was a set of states with valence--Rydberg character,
although it was not reflected in the orbital extension or population
analysis because the orbitals in the active space were too compact
to be able to reflect it. The states we have now are also of clear valence character
but the difference is that we have first included the Rydberg orbitals
in the active space, allowed the flexibility to describe the
Rydberg state, and then removed them from the space to finish with a
set of compact valence orbitals which cannot represent the Rydberg states.
Then, the latter are removed from the computed spectrum of states.

The experience of this type of treatment in different molecules
:cite:`Roos:96b,Roos:95b,Fuelscher:97a` points out that if the valence states
of a molecule are computed without considering the Rydberg states and
functions (whether by excluding them from the basis set or from the
active space) can result in an additional CASPT2 error as large as 0.3--0.4 eV.
The errors are
more severe for other transitions properties. One example of this can be
found for two different CASPT2 treatments of the formamide molecule,
one including diffuse functions and other excluding
them (see ref. :cite:`Serrano:96c` for details). Notice, however, that this
approach cannot describe a true valence--Rydberg mixing.
An alternative to such an approach is to use the Multi-State
CASPT2 treatment that, although computationally expensive, might properly
treats the valence--Rydberg mixing. It must be remembered, however, that
the performance of the MS-CASPT2 method relies on the previous mixing of
the wave functions, and therefore it will not be unusual, depending on the
employed basis set, to obtain CASPT2 results that already give the same
answer as MS-CASPT2 results when the initial basis sets are changed.

Other cases
-----------

The calculations become increasingly difficult with increased
size of the system or in low symmetry cases. Common
problems one has to solve are the selection of the active space when it
is not possible to include all orbitals expected to be important and
the presence of artificial valence-Rydberg mixing in the description
of the states. Specific problems appear in systems containing transition
metals, where there are a large amount of states close in energy.

.. index::
   single: Active space
   single: Program; RASSCF
   single: RASSCF

To include all the required orbitals into the active space is sometimes
impossible. This is one of the important limitations of the methodology.
But some solutions are
available if one is aware of the limitations. References
:cite:`Merchan:94b` and :cite:`Serrano:97a` report
studies on the porphin and indigo molecules, respectively.
Porphin and indigo have 24 and 20 :math:`\pi`,\ :math:`\pi^*` orbitals, respectively.
It is obviously impossible to include all of them in the active
spaces. The analysis of the configurations and occupation numbers
of the orbitals in a restricted number of excited states by means of
the RASSCF method has been found to be a useful procedure to
find a proper active space to study different states of the systems.
The RASSCF method is able to deal with a larger number of configurations
making possible to include all the :math:`\pi` orbitals in the active space
and analyze the role of the different orbitals. Our goal in this case
is to be able to discard some of the deepest or highest orbitals if they
become less important in the description of the desired states.

One possibility is to perform a SDTQ calculation involving all the
presumably important active space (occupied orbitals in :kword:`RAS1`,
empty orbitals in :kword:`RAS3`, no orbitals in :kword:`RAS2`, and four
holes/electrons allowed in RAS1/RAS3). The occupation numbers for the
active orbitals obtained for such calculation are usually similar to
those of a full CASSCF treatment. Another possibility is to place in
the CAS space (:kword:`RAS2`) the most important orbitals and
the corresponding electrons and only allow singles and doubles
excitations from :kword:`RAS1` (occupied orbitals) to
:kword:`RAS3` (empty orbitals). In all these cases we will study
the configurations and occupation numbers of the orbitals to find if
some of them are or minor importance for the description of the states
we are considering and then reduce the active space for the CASSCF/CASPT2
calculation :cite:`Merchan:94b,Serrano:97a`.

.. index::
   single: Transition metals; Active space
   single: CASPT2; g1 option

Calculation on the excited states of transition metal compounds have to
deal with another set of problems. For instance, the known 3d double-shell
effect: two sets of d orbitals (3d and 4d) must be included in the
reference space in order to obtain accurate results :cite:`Roos:96b` in
molecules containing metal atoms of the first transition row with many
d-electrons (:math:`\ce{Fe}`\--\ :math:`\ce{Zn}`). This
is a severe limitation when more ligands are included together with the
metal atom. Illustrations of such problems are the calculation of the
cyanide and carbonyl transition metal compounds :cite:`Roos:96b,Pierloot:93a`
and metal--protein models :cite:`Pierloot:96a`. Core--valence :cite:`Pierloot:93b`
and relativistic effects :cite:`Roos:96a` have been shown to be
important for obtaining accurate results. Finally, the problem of the high
multiplicity states in the standard CASPT2 formulation has to be considered.
The zeroth-order Hamiltonian is defined as a Fock-type one-electron operator.
Apart from the originally proposed Fock matrix :cite:`Andersson:90,Andersson:92a`,
a correction, denoted :math:`g_1` :cite:`Andersson:95a`, has been designed so that
CASSCF wave functions dominated by a closed-shell configuration, on the
one hand, and an open-shell configuration, on the other hand, are treated
in similar and balanced ways in the perturbation calculation. This
correction was shown to be essential in order to obtain reliable results
for the :math:`\ce{Cr_2}` molecule with the CASSCF/CASPT2 method :cite:`Roos:95b`.

.. index::
   single: Symmetry; Breaking

Each type of system and situation has its own specific problems. Size and
convergence problems in systems without any symmetry :cite:`Merchan:97,Serrano:95a`,
symmetry breaking and localization problems in high symmetry cases
:cite:`Merchan:96c`, excited states in radical cations :cite:`Fuelscher:95b` and
anions :cite:`Rubio:95c`, etc. In addition, there are situations such as
the crossing regions which require the simultaneous treatment of more than
one state at the CASPT2 level, which can only be solved using the multi-state
option in CASPT2.
Annexes
=======

.. toctree::

   ex-bs
   ex-ecp
.. _TUT\:sec\:SOC:

Computing relativistic effects in molecules
===========================================

|molcas| is intended for calculations on systems including all atoms of the
periodic table. This is only possible if relativistic effects can be added in a
way that is accurate and at the same time applies to all the methods used in
|molcas|, in particular the CASSCF and CASPT2 approaches. |molcas|
includes relativistic effects within the same wave function framework as used in
non-relativistic calculations. This has been possible by partitioning the
relativistic effects into two parts: the scalar relativistic effects and
spin--orbit coupling. This partitioning is based on the Douglas--Kroll (DK)
transformation of the relativistic Hamiltonian :cite:`Douglas:74,Hess:86`.

Scalar relativistic effects
---------------------------

The scalar relativistic effects are included by adding the corresponding terms
of the DK Hamiltonian to the one-electron integrals in Seward (use
the keyword :kword:`Douglas-Kroll`). This has no effect on the form of the wave
function and can be used with all |molcas| modules. Note however that it is
necessary to use a basis set with a corresponding relativistic contraction.
|molcas| provides the ANO-RCC basis set, which has been constructed using
the DK Hamiltonian. Use this basis set in your relativistic calculations. It has
the same accuracy as the non-relativistic ANO-L basis set. Scalar relativistic
effects become important already for atoms of the second row. With ANO type
basis sets it is actually preferred to use the DK Hamiltonian and ANO-RCC in all
your calculations.

Spin--orbit coupling (SOC)
--------------------------

In order to keep the structure of |molcas| as intact as possible, it was decided
to incorporate SOC as an *a posteriori* procedure which can be added after
a series of CASSCF calculations. The program :program:`RASSI` has been modified
to include the spin--orbit part of the DK Hamiltonian :cite:`Malmqvist:02a`. The
method is thus based on the concept of electronic states interacting via SOC.
In practice this means that one first performs a series of CASSCF calculations
in the electronic states one expects to interact via SOC. They are then used as
the basis states in the RASSI calculations. Dynamic electron correlation effects
can be added by a shift of the diagonal of the SOC Hamiltonian to energies
obtained in a CASPT2 or MRCI calculation. If MS-CASPT2 is used, a special
output file (:file:`JOBMIX`) is provided that is to be used as the input file
for RASSI. The procedure will below be illustrated in a calculation on the lower
excited states of the PbO molecule.

The SO Hamiltonian has been approximated by a one-electron effective
Hamiltonian :cite:`Hess:96`, which also avoids the calculation of multi-center
integrals (the Atomic Mean Field Approximation -- AMFI )
:cite:`Hess:96,Schimmelpfennig:96`.

The :math:`\ce{PbO}` molecule
-----------------------------

Results from a calculation of the potentials for the ground and lower excited
states of :math:`\ce{PbO}`, following the procedure outlined above, has recently been
published :cite:`Roos:03h`. The ground state of :math:`\ce{PbO}` dissociates to :math:`\ce{O}(^3P)` and
:math:`\ce{Pb}(^3P)`. However in the :math:`\ce{Pb}` atom there is strong SOC between the :math:`^3P`, :math:`^1D`,
and :math:`^1S` term of the (6s)\ |2|\(6p)\ |2| electronic configuration. All levels with
the :math:`\Omega` value :math:`O^+` arising from these terms will therefore contribute to
the ground state potential. The first task is therefore to construct the
electronic states that are obtained by coupling :math:`\ce{O}(^3P)` to any of the :math:`^3P`,
:math:`^1D`, and :math:`^1S` terms of :math:`\ce{Pb}`. In the table below we give the states. They have
been labeled both in linear symmetry and in :math:`C_2` symmetry, which is the
symmetry used in the calculation because it makes it possible to average over
degenerate components.

.. _tab\:so:

==== =============== ================================================================================ =============
Spin :math:`C_2` sym Labels in linear symmetry                                                        No. of states
==== =============== ================================================================================ =============
2    1               :math:`^5\Delta`, 2\ |x|\ :math:`^5\Sigma^+`, :math:`^5\Sigma^-`                 5
2    2               2\ |x|\ :math:`^5\Pi`                                                            4
1    1               3\ |x|\ :math:`^3\Delta`, 3\ |x|\ :math:`^3\Sigma^+`, 4\ |x|\ :math:`^3\Sigma^-` 13
1    2               6\ |x|\ :math:`^3\Pi`, :math:`^3\Phi`                                            14
0    1               :math:`^1\Delta`, 2\ |x|\ :math:`^1\Sigma^+`, :math:`^1\Sigma^-`                 5
0    2               2\ |x|\ :math:`^1\Pi`                                                            4
==== =============== ================================================================================ =============

The total number of states is 45. One thus has to perform 6 CASSCF (and
MS-CASPT2) calculations according to the spin and symmetries given in the table.
The RASSI-SO calculation will yield 134 levels with :math:`\Omega` ranging from 0 to
4. Only the lower of these levels will be accurate because of the limitations in
the selection of electronic states.

The active space used in these calculations is 6s,6p for :math:`\ce{Pb}` and 2p for :math:`\ce{O}`. This
is the natural choice and works well for all main group elements in most
molecules. The s-orbital should be active in groups IIa--Va, but may be left
inactive for the heavier atoms (groups VIa--VIIa). The ANO-RCC basis sets have
been constructed to include correlation of the semi-core electrons. For :math:`\ce{Pb}` they
are the 5d, which should then not be frozen in the :program:`CASPT2`
calculations. All other core electrons should be frozen, because there are no
basis functions to describe their correlation. Including them in the correlation
treatment may lead to large BSSE errors.

The input file for these calculations is quite lengthy, so we show here only one
set of :program:`CASSCF/CASPT2` calculations but the whole :program:`RASSI` input
for all six cases.

.. extractfile:: advanced/RASSI.PbO.input

  &GATEWAY
    Title= PbO
    Coord= $CurrDir/PbO.xyz
    Basis set
    ANO-RCC-VQZP
    Group= XY
    AngMom
   0.00  0.00  0.00
  End of Input

  &SEWARD
  End of Input

  &SCF
    Title
    PbO
    Occupied
      24 21
    Iterations
      20
    Prorbitals
      2 1.d+10
  End of Input

  &RASSCF
    Title
    PbO
    Symmetry
      1
    Spin
      5
    CIROOT
      5 5 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      5 1 2 3 4 5
    Imaginary Shift
      0.1
  End of Input

  >> COPY $Project.JobMix $CurrDir/JobMix.12
  &RASSCF
    Title
    PbO
    Symmetry
      2
    Spin
      5
    CIROOT
      4 4 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      4 1 2 3 4
    Imaginary Shift
      0.1
  >> COPY $Project.JobMix $CurrDir/JobMix.22
  &RASSCF
    Title
    PbO
    Symmetry
      1
    Spin
      3
    CIROOT
      13 13 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      13 1 2 3 4 5 6 7 8 9 10 11 12 13
    Imaginary Shift
      0.1
  End of Input

  >> COPY $Project.JobMix $CurrDir/JobMix.11
  &RASSCF
    Title
    PbO
    Symmetry
      2
    Spin
      3
    CIROOT
      14 14 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      14 1 2 3 4 5 6 7 8 9 10 11 12 13 14
    Imaginary Shift
      0.1
  >> COPY $Project.JobMix $CurrDir/JobMix.21
  &RASSCF
    Title
    PbO
    Symmetry
      1
    Spin
      1
    CIROOT
      5 5 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      5 1 2 3 4 5
    Imaginary Shift
      0.1
  End of Input

  >> COPY $Project.JobMix $CurrDir/JobMix.10
  &RASSCF
    Title
    PbO
    Symmetry
      2
    Spin
      1
    CIROOT
      4 4 1
    nActEl
      8 0 0
    Inactive
      23 18
    Ras2
      3 4
    Lumorb
    THRS
      1.0e-8 1.0e-04 1.0e-04
    Levshft
      1.50
    ITERation
      200 50
    CIMX
      200
    SDAV
      500
  End of Input

  &CASPT2
    Title
    PbO
    MAXITER
      25
    FROZEN
      19 16
    Focktype
    G1
    Multistate
      4 1 2 3 4
    Imaginary Shift
      0.1
  End of Input

  >> COPY $Project.JobMix $CurrDir/JobMix.20
  >> COPY $CurrDir/JobMix.12 JOB001
  >> COPY $CurrDir/JobMix.11 JOB002
  >> COPY $CurrDir/JobMix.21 JOB003
  >> COPY $CurrDir/JobMix.10 JOB004
  >> COPY $CurrDir/JobMix.22 JOB005
  >> COPY $CurrDir/JobMix.20 JOB006
  &RASSI
    Nrof JobIphs
      6 5 13 14 5 4 4
      1 2 3 4 5
      1 2 3 4 5 6 7 8 9 10 11 12 13
      1 2 3 4 5 6 7 8 9 10 11 12 13 14
      1 2 3 4 5
      1 2 3 4
      1 2 3 4
    Spin Orbit
    Ejob
  End of Input

In the above definitions of the JobMix files the labels correspond to
symmetry and spin. Thus :file:`JobMix.12` is for quintets (:math:`S=2`) in symmetry 1,
etc. The keyword :kword:`Ejob` ensures that the :program:`MS-CASPT2` energies
from the :file:`JobMix` files are used as the diagonal elements in the SO
Hamiltonian matrix. The output file of one such calculation is quite lengthy (6
:program:`CASSCF/MS-CASPT2` calculations and one :program:`RASSI`). Important
sections of the :program:`RASSI` output are the spin-free energies (look for the
word ``SPIN-FREE`` in the listing) and the SOC energies (found by looking for
``COMPLEX``). The complex SO wave functions are also given and can be used to
analyze the wave function. For linear molecules one wants to know the :math:`\Omega`
values of the different solutions. Here the computed transition moments can be
quite helpful (using the selection rules). It is important in a calculation of
many excited states, as the one above, to check for intruder state problems in
the :program:`CASPT2` results.

This example includes a large number of states, because the aim was to compute
full potential curves. If one is only interested in the properties near
equilibrium, one can safely reduce the number of states. For lighter atoms it is
often enough to include the spin-free states that are close in energy in the
calculation of the SOC. An intersystem crossing can usually be treated by
including only the two crossing states. The choice of basis states for the
:program:`RASSI` calculation depends on the strength of the SO interaction and
the energy separation between the states.

The above input is for one distance. The shell script loops over distances
according to: ::

  Dist='50.0 10.0 8.00 7.00 6.00 5.50 5.00 4.40 4.20 4.00 3.90 3.80 3.75 3.70 3.65 3.60 3.55 3.50 3.40 3.30 3.10'
   for R in $Dist
   do
   cat $CurrDir/template | sed -e "s/Dist/$R/" >$CurrDir/input
  rm -rf $WorkDir
  mkdir  $WorkDir
  cd     $WorkDir
  echo "R=$R" >>$CurrDir/energies
  molcas $CurrDir/input >$CurrDir/out_$R
  grep "Reference energy" $CurrDir/out_$R >>$CurrDir/energies
  grep "Total energy" $CurrDir/out_$R >>$CurrDir/energies
  grep "Reference weight" $CurrDir/out_$R >>$CurrDir/energies
  done

Thus, the whole potential curves can be run as one job (provided that there are
no problems with intruder states, convergence, etc). Notice that the
:file:`JOBIPH` files for one distance are used as input (:file:`JOBOLD`) for the
next distance. The shell script collects all :program:`CASSCF` and
:program:`CASPT2` energies and reference weights in the file :file:`energies`.

We shall not give any detailed account of the results obtained in the
calculation of the properties of the :math:`\ce{PbO}` molecule. The reader is referred to the
original article for details :cite:`Roos:03h`. However it might be of interest to
know that the computed dissociation energy (:math:`D_0`) was 5.0 eV without SOC and
4.0 eV with (experiment is 3.83 eV). The properties at equilibrium are much less
affected by SOC: the bond distance is increased with 0.003 Å, the frequency is
decreased with 11 cm\ :math:`^{-1}`. The results have also been used to assign the 10
lowest excited levels.
.. index::
   single: Geometry
   single: Optimization; Minima
   single: Hessian

.. _TUT\:sec\:optim:

Geometry optimizations and Hessians
===================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

To optimize a molecular geometry is probably one of the most frequent
interests of a quantum chemist :cite:`Helgaker:92`. In the present section we examine
some examples of obtaining stationary points on the energy surfaces.
We will focus in this section in searching of minimal energy points,
postponing the discussion on transition states to :numref:`TUT:sec:path`.
This type of calculations require the computation of molecular gradients,
whether using analytical or numerical derivatives. We will also examine
how to obtain the full geometrical Hessian for a molecular state, what
will provide us with vibrational frequencies within the harmonic
approximation and thermodynamic properties by the use of the proper
partition functions.

The program :program:`ALASKA` computes analytical gradients for optimized wave
functions. In |molcas| the SCF, DFT, and CASSCF/RASSCF levels of calculation are
available. The program :program:`ALASKA` also computes numerical gradients
from CASPT2 and MS-CASPT2 energies. Provided with the first order derivative matrix with respect to the
nuclei and an approximate guess of the Hessian matrix, the program
SLAPAF is then used to optimize molecular structures. From |molcasv| it is
not necessary to explicitly define the set of internal coordinates
of the molecule in the SLAPAF input. Instead a redundant coordinates
approach is used. If the definition is absent
the program builds its own set of parameters based on
curvature-weighted non-redundant internal coordinates and displacements
:cite:`Lindh:97`. As they depend
on the symmetry of the system it might be somewhat difficult in some
systems to define them. It is, therefore, strongly recommended to let
the program define its own set of non-redundant internal coordinates.
In certain situations such as bond dissociations the previous coordinates
may not be appropriate and the code directs the user to use instead
Cartesian coordinates, for instance.

.. index::
   single: Ground state
   single: Optimization; Ground state

Ground state optimizations and vibrational analysis
---------------------------------------------------

As an example we are going to work with the 1,3-cyclopentadiene
molecule. This is a five-carbon system forming a ring which has
two conjugated double bonds. Each carbon has one attached
hydrogen atom except one which has two. We will use the
CASSCF method and
take advantage of the symmetry properties of the molecule to
compute ground and excited states. To ensure
the convergence of the results we will also perform
Hessian calculations to compute the force fields at the
optimized geometries.

In this section we will combine two types of procedures to perform
calculations in |molcas|. The user may then choose the most convenient
for her/his taste. We can use an general script and perform an input-oriented
calculation, when all the information relative to the calculation, including
links for the files and control of iterations, are inserted in the input
file. The other procedure is the classical script-oriented system used in
previous examples and typically previous versions of |molcas|. Let's start
by making an input-oriented optimization. A script is still needed to
perform the basic definitions, although they can be mostly done within the
input file. A suggested form for this general script could be: ::

  #!/bin/sh
  export MOLCAS=/home/molcas/molcashome
  export MOLCAS_MEM=64
  export Project=Cyclopentadiene1
  export HomeDir=/home/somebody/somewhere
  export WorkDir=$HomeDir/$Project
  [ ! -d $WorkDir ] && mkdir $WorkDir
  molcas $HomeDir/$Project.input >$HomeDir/$Project.out 2>$HomeDir/$Project.err
  exit

We begin by defining the input for the initial calculation.
In simple cases the optimization procedure is very efficient.
We are going, however, to design a more complete procedure that
may help in more complex situations.
It is sometimes useful to start the optimization in a small
size basis set and use the obtained approximate Hessian to
continue the calculation with larger basis sets. Therefore,
we will begin by using the minimal STO-3G basis set to optimize
the ground state of 1,3-cyclopentadiene within |Ctv| symmetry.

.. index::
   single: Cyclopentadiene

.. figure:: cyclope.*
   :name: fig:cyclope
   :width: 50%
   :align: center

   1,3-cyclopentadiene

.. We will use the following input in an input-oriented calculation.
   Notice that we have directed the output files sequentially (one
   per iteration) to the $WorkDir directory by using the
   :command:`Set Output File` command, the maximum number of
   iterations of the subsequent loops, and the starting and end
   of the loops on each step of the optimization procedure by
   using the commands :command:`Do while` and :command:`EndDo`.
   It is important than the
   parameter MaxIter never goes beyond the number of iterations
   in the :program:`SLAPAF` input.

.. index::
   single: Program; ALASKA
   single: Program; SLAPAF
   single: SLAPAF; Initial Hessian

.. extractfile:: advanced/OPT.hessian.input

  >>> EXPORT MOLCAS_MAXITER=50
   &GATEWAY; Title=1,3,-cyclopentadiene. STO-3G basis set.
     Symmetry= X XY
     Basis set
     C.STO-3G....
     C1    0.000000  0.000000  0.000000  Bohr
     C2    0.000000  2.222644  1.774314  Bohr
     C3    0.000000  1.384460  4.167793  Bohr
     End of basis
     Basis set
     H.STO-3G....
     H1    1.662033  0.000000 -1.245623  Bohr
     H2    0.000000  4.167844  1.149778  Bohr
     H3    0.000000  2.548637  5.849078  Bohr
     End of basis

  >>> Do while <<<

   &SEWARD

  >>> IF ( ITER = 1 )
   &SCF
      TITLE= cyclopentadiene molecule
      OCCUPIED=9 1 6 2
      ITERATIONS=40
  >>> END IF
   &RASSCF
     TITLE=cyclopentadiene molecule 1A1
     SYMMETRY=1; SPIN=1
     NACTEL= 6    0    0
     INACTIVE= 9    0    6    0
     RAS2= 0    2    0    3            <--- All pi valence orbitals active
     ITER= 50,25; CIMX= 25

   &ALASKA
   &SLAPAF; Iterations=80; Thrs=0.5D-06 1.0D-03
  >>> EndDo <<<
  >>> COPY $Project.RunFile $CurrDir/$Project.ForceConstant.STO-3G

.. index::
   single: Force Constant; From a file

A copy of the :file:`RUNFILE` has been made at the end of the input stream.
This saves the file for use as (a) starting geometry and (b)
a guess of the Hessian matrix in the following calculation.
The link can be also done in the shell
script.

.. index::
   single: SEWARD
   single: SEWARD; Symmetry
   single: SEWARD; Test

The generators used to define the
|Ctv| symmetry are X and XY, plane :math:`yz` and axis :math:`z`. They
differ from those used in other examples as in :numref:`TUT:sec:nih`.
The only consequence is that the order of the symmetries in :program:`SEWARD`
differs. In the present case the order is: |ao|, |at|, |bo|, and |bt|,
and consequently the classification by symmetries of the orbitals
in the SCF and RASSCF inputs will differ. It is therefore
recommended to initially use the option :kword:`TEST` in the :program:`GATEWAY` input
to check the symmetry option. This option, however, will stop the calculation
after the :program:`GATEWAY` input head is printed.

The calculation converges in four steps. We change now the input. We can
choose between replacing by hand the geometry of the :program:`SEWARD` input
or use the same $WorkDir directory and let the program to take the last
geometry stored into the :file:`RUNFILE` file. In any case the
new input can be:

.. index::
   single: Program; ALASKA
   single: Program; SLAPAF
   single: SLAPAF; Internal coordinates
   single: SLAPAF; Initial Hessian

.. extractfile:: advanced/OPT.internal_coord.input

  >>COPY $CurrDir/OPT.hessian.ForceConstant.STO-3G $Project.RunOld

   &GATEWAY; Title=1,3,-cyclopentadiene molecule
     Symmetry=X XY
     Basis set
     C.ANO-L...4s3p1d.
     C1              .0000000000         .0000000000       -2.3726116671
     C2              .0000000000        2.2447443782        -.5623842095
     C3              .0000000000        1.4008186026        1.8537195887
     End of basis
     Basis set
     H.ANO-L...2s.
     H1             1.6523486260         .0000000000       -3.6022531906
     H2              .0000000000        4.1872267035       -1.1903003793
     H3              .0000000000        2.5490335048        3.5419847446
     End of basis

  >>> Do while <<<

   &SEWARD

  >>> IF ( ITER = 1 ) <<<<
   &SCF
     TITLE=cyclopentadiene molecule
     OCCUPIED= 9 1 6 2
     ITERATIONS= 40

  >>> ENDIF <<<

   &RASSCF; TITLE cyclopentadiene molecule 1A1
     SYMMETRY=1; SPIN=1; NACTEL=6    0    0
     INACTIVE= 9    0    6    0
     RAS2    = 0    2    0    3
     ITER=50,25; CIMX= 25

   &SLAPAF; Iterations=80; Thrs=0.5D-06 1.0D-03
     OldForce Constant Matrix
  >>> EndDo <<<

.. index::
   single: SLAPAF; Initial Hessian

The :file:`RUNOLD` file will be used by :program:`SEWARD` to pick up
the molecular structure on the initial iteration and
by :program:`SLAPAF` as initial Hessian
to carry out the relaxation. This use of the :file:`RUNFILE` can be
done between any different calculations provided they work in the
same symmetry.

In the new basis set, the resulting
optimized geometry at the CASSCF level in |Ctv| symmetry is: ::

  ********************************************
  * Values of internal coordinates           *
  ********************************************
  C2C1   2.851490 Bohr
  C3C2   2.545737 Bohr
  C3C3   2.790329 Bohr
  H1C1   2.064352 Bohr
  H2C2   2.031679 Bohr
  H3C3   2.032530 Bohr
  C1C2C3     109.71 Degrees
  C1C2H2     123.72 Degrees
  C2C3H3     126.36 Degrees
  H1C1H1     107.05 Degrees

Once we have the optimized geometry we can obtain the
force field, to compute the force constant matrix and
obtain an analysis of the harmonic frequency. This is done by
computing the analytical Hessian at the optimized geometry.
Notice that this is a single-shot calculation using the
:program:`MCKINLEY`, which will automatically start the :program:`MCLR` module
in case of a frequency calculation.

.. index::
   single: Program; McKinley
   single: Program; MCLR
   single: Hessian

.. extractfile:: advanced/MCLR.cyclopentadiene.input

  &GATEWAY; Title=1,3,-cyclopentadiene molecule
    Symmetry= X XY
    Basis set
    C.ANO-L...4s3p1d.
      C1             0.0000000000        0.0000000000       -2.3483061484
      C2             0.0000000000        2.2245383122       -0.5643712787
      C3             0.0000000000        1.3951643642        1.8424767578
    End of basis
    Basis set
    H.ANO-L...2s.
      H1             1.6599988023        0.0000000000       -3.5754797471
      H2             0.0000000000        4.1615845660       -1.1772096132
      H3             0.0000000000        2.5501642966        3.5149458446
    End of basis

  &SEWARD
  &SCF; TITLE=cyclopentadiene molecule
    OCCUPIED= 9 1 6 2
    ITERATIONS= 40
  &RASSCF; TITLE=cyclopentadiene molecule 1A1
    SYMMETRY=1; SPIN=1; NACTEL= 6    0    0
    INACTIVE= 9    0    6    0
    RAS2    = 0    2    0    3
    ITER= 50,25; CIMX=25

  &MCKINLEY

.. index::
   single: Harmonic frequencies

Cyclopentadiene has 11 atoms, that mean :math:`3N = 33` Cartesian degrees of freedom.
Therefore the :program:`MCLR` output will contain 33 frequencies. From those,
we are just interested in the :math:`3N-6 = 27` final degrees of freedom that
correspond to the normal modes of the system. We will discard from the
output the three translational (:math:`T_i`) and three rotational (:math:`R_i`) coordinates.
The table of characters gives us the classification of these six coordinates:
:math:`a_1` (:math:`T_z`), :math:`a_2` (:math:`R_z`), :math:`b_2` (:math:`T_x`, :math:`R_y`), :math:`b_1` (:math:`T_y`, :math:`R_x`).
This information is found in the Seward output: ::

                      Character Table for C2v

                               E   s(yz) C2(z) s(xz)
                      a1       1     1     1     1  z
                      a2       1    -1     1    -1  xy, Rz, I
                      b2       1     1    -1    -1  y, yz, Rx
                      b1       1    -1    -1     1  x, xz, Ry

.. NOTE: contains a nbsp

It is simply to distinguish these frequencies because they must be zero,
although and because of numerical inaccuracies they will be simply close
to zero. Note that the associated intensities are nonsense.
In the present calculation the harmonic frequencies, the infrared
intensities, and the corresponding normal modes printed below in Cartesian
coordinates are the following: ::

     Symmetry a1
    ==============

                  1         2         3         4         5         6

       Freq.       0.04    847.85    966.08   1044.69   1187.61   1492.42

       Intensity:   0.646E-08 0.125E-02 0.532E+01 0.416E+00 0.639E-01 0.393E+01

       C1         z    0.30151   0.35189  -0.21166  -0.11594   0.06874   0.03291
       C2         y    0.00000   0.31310   0.14169   0.12527  -0.01998  -0.08028
       C2         z    0.30151  -0.02858   0.06838  -0.00260   0.02502  -0.06133
       C3         y   -0.00000   0.04392  -0.07031   0.23891  -0.02473   0.16107
       C3         z    0.30151  -0.15907   0.00312   0.08851  -0.07733  -0.03146
       H1         x    0.00000  -0.02843  -0.00113  -0.01161   0.00294   0.04942
       H1         z    0.30151   0.31164  -0.21378  -0.13696   0.08233   0.11717
       H2         y    0.00000   0.24416   0.27642   0.12400   0.11727   0.07948
       H2         z    0.30151  -0.25054   0.46616  -0.05986   0.47744   0.46022
       H3         y   -0.00000  -0.29253  -0.28984   0.59698   0.34878  -0.34364
       H3         z    0.30151   0.07820   0.15644  -0.13576  -0.34625   0.33157


                  7         8         9        10        11

       Freq.    1579.76   1633.36   3140.69   3315.46   3341.28

       Intensity:   0.474E+01 0.432E+00 0.255E+02 0.143E+02 0.572E+01

  ...

      Symmetry a2
     ==============

                         1         2         3         4         5

            Freq.      i9.26    492.62    663.74    872.47   1235.06

  ...

      Symmetry b2
     ==============

                      1         2         3         4         5         6

          Freq.     i10.61    0.04      858.72   1020.51   1173.33   1386.20

       Intensity:   0.249E-01 0.215E-07 0.259E+01 0.743E+01 0.629E-01 0.162E+00

  ...
                           7         8         9        10

               Freq.    1424.11   1699.07   3305.26   3334.09

         Intensity:   0.966E+00 0.426E+00 0.150E+00 0.302E+02

  ...

      Symmetry b1
     ==============

                           1         2         3         4         5         6

              Freq.     i11.31      0.11    349.15    662.98    881.19    980.54

         Intensity:   0.459E-01 0.202E-06 0.505E+01 0.896E+02 0.302E+00 0.169E+02

  ...
                           7

              Freq.    3159.81

        Intensity:   0.149E+02
  ...

Apart from the six mentioned translational and rotational coordinates
There are no imaginary frequencies and therefore the geometry corresponds
to a stationary point within the :math:`C_{2v}` symmetry.
The frequencies are expressed in reciprocal centimeters.

After the vibrational analysis the zero-point energy correction and the thermal
corrections to the total energy, internal, entropy, and Gibbs free energy.
The analysis uses the standard expressions for an ideal gas in the canonical
ensemble which can be found in any standard statistical mechanics book.
The analysis is performed at different temperatures, for instance: ::

  *****************************************************
  Temperature =   273.00 kelvin, Pressure =   1.00 atm
  -----------------------------------------------------
  Molecular Partition Function and Molar Entropy:
                        q/V (M**-3)    S(kcal/mol*K)
  Electronic            0.100000D+01        0.000
  Translational         0.143889D+29       38.044
  Rotational            0.441593D+05       24.235
  Vibrational           0.111128D-47        3.002
  TOTAL                 0.706112D-15       65.281

  Thermal contributions to INTERNAL ENERGY:
  Electronic           0.000 kcal/mol      0.000000 au.
  Translational        0.814 kcal/mol      0.001297 au.
  Rotational           0.814 kcal/mol      0.001297 au.
  Vibrational         60.723 kcal/mol      0.096768 au.
  TOTAL               62.350 kcal/mol      0.099361 au.

  Thermal contributions to
  ENTHALPY            62.893 kcal/mol      0.100226 au.
  GIBBS FREE ENERGY   45.071 kcal/mol      0.071825 au.

  Sum of energy and thermal contributions
  INTERNAL ENERGY                       -192.786695 au.
  ENTHALPY                              -192.785831 au.
  GIBBS FREE ENERGY                     -192.814232 au.

Next, polarizabilities (see below) and isotope shifted frequencies are also displayed
in the output. ::

  ************************************
  *                                  *
  *       Polarizabilities           *
  *                                  *
  ************************************



    34.76247619
    -0.00000000 51.86439359
    -0.00000000 -0.00000000 57.75391824

For a graphical representation of the harmonic frequencies one can also use the
:file:`$Project.freq.molden` file as an input to the MOLDEN program.

.. index::
   single: Excited states
   single: Optimization; Excited states

Excited state optimizations
---------------------------

The calculation of excited states using the :program:`ALASKA` and :program:`SLAPAF` codes
has no special characteristic. The wave function is defined by the
:program:`SCF` or :program:`RASSCF` programs. Therefore if we want to optimize an excited
state the :program:`RASSCF` input has to be defined accordingly. It is not,
however, an easy task, normally because the excited states have lower
symmetry than the ground state and one has to work in low order
symmetries if the full optimization is pursued.

(:numref:`fig:thiophene`)

.. index::
   single: Thiophene

Take the example of the thiophene molecule (see :numref:`fig:thiophene`).
The ground state has
|Ctv| symmetry: :math:`1^1A_1`. The two lowest valence excited states
are :math:`2^1A_1` and :math:`1^1B_2`. If we optimize the geometries within
the |Ctv| symmetry the calculations converge easily for the three
states. They are the first, second, and first roots of their
symmetry, respectively. But if we want to make a full optimization
in :math:`C_1`, or even a restricted one in :math:`C_s`, all three states belong
to the same symmetry representation. The higher the root more
difficult is to converge it. A geometry optimization requires
single-root optimized CASSCF wave-functions, but, unlike in previous |molcas|
versions, we can now carry out State-Average (SA) CASSCF calculations
between different roots. The wave functions we have with this procedure
are based on an averaged density matrix, and a further orbital relaxation
is required. The :program:`MCLR` program can perform such a task by means
of a perturbational approach. Therefore, if we choose to carry out a
SA-CASSCF calculations in the optimization procedure, the :program:`Alaska`
module will automatically start up the :program:`MCLR` module.

.. compound::

  We are going to optimize the three states of thiophene in |Ctv|
  symmetry. The inputs are:

  .. index::
     single: Program; ALASKA
     single: Program; SLAPAF
     single: Program; MCLR
     single: SLAPAF; Excited states

  .. extractfile:: advanced/OPT.excited.input

    &GATEWAY; Title=Thiophene molecule
      Symmetry= X XY
      Basis set
      S.ANO-S...4s3p2d.
      S1              .0000000000         .0000000000       -2.1793919255
      End of basis
      Basis set
      C.ANO-S...3s2p1d.
      C1              .0000000000        2.3420838459         .1014908659
      C2              .0000000000        1.3629012233        2.4874875281
      End of basis
      Basis set
      H.ANO-S...2s.
      H1              .0000000000        4.3076765963        -.4350463731
      H2              .0000000000        2.5065969281        4.1778544652
      End of basis

    >>> Do while <<<
    &SEWARD
    >>> IF ( ITER = 1 ) <<<
    &SCF; TITLE=Thiophene molecule
      OCCUPIED= 11 1 7 3
      ITERATIONS= 40
    >>> ENDIF <<<

    &RASSCF; TITLE=Thiophene molecule 1 1A1
      SYMMETRY=1; SPIN=1; NACTEL= 6    0    0
      INACTIVE= 11    0    7    1
      RAS2    =  0    2    0    3
      ITER= 50,25

    &ALASKA
    &SLAPAF
    End of Input
    >>> ENDDO <<<

  for the ground state. For the two excited states we will replace
  the :program:`RASSCF` inputs with

  .. index::
     single: RASSCF
     single: Program; RASSCF

  ::

    &RASSCF; TITLE=Thiophene molecule 2 1A1
      SYMMETRY=1; SPIN=1; NACTEL= 6    0    0
      INACTIVE= 11    0    7    1
      RAS2    =  0    2    0    3
      ITER= 50,25
      CIROOT= 2 2; 1 2; 1 1
      LEVSHFT=1.0
      RLXRoot= 2

  for the :math:`2^1A_1` state.
  Notice that we are doing a SA-CASSCF calculation
  including two roots, therefore we must use
  the keyword :kword:`RLXROOT` within the :program:`RASSCF` input
  to specify for which state we want the root.
  We have also

  ::

    &RASSCF; TITLE=Thiophene molecule 1 1B2
      SYMMETRY=2; SPIN=1; NACTEL= 6    0    0
      INACTIVE= 11    0    7    1
      RAS2    =  0    2    0    3
      ITER= 50,25
      LEVSHFT=1.0

  for the :math:`1^1B_2` state.

To help the program to converge we can include one or more initial :program:`RASSCF`
inputs in the input file.
The following is an example for the calculation
of the of the :math:`3^1A'` state of thiophene (:math:`C_s` symmetry) with a previous
calculation of the ground state to have better starting orbitals.

.. index::
   single: Convergence problems; Do always option
   single: Hessian
   single: SLAPAF; Numerical Hessian
   single: Program; SLAPAF
   single: Program; ALASKA

.. extractfile:: advanced/OPT.numerical.input

  &GATEWAY; Title= Thiophene molecule
    Symmetry=X
    Basis set
    S.ANO-S...4s3p2d.
    S1              .0000000000         .0000000000       -2.1174458547
    End of basis
    Basis set
    C.ANO-S...3s2p1d.
    C1              .0000000000        2.4102089951         .1119410701
    C1b             .0000000000       -2.4102089951         .1119410701
    C2              .0000000000        1.3751924147        2.7088559532
    C2b             .0000000000       -1.3751924147        2.7088559532
    End of basis
    Basis set
    H.ANO-S...2s.
    H1              .0000000000        4.3643321746        -.4429940876
    H1b             .0000000000       -4.3643321746        -.4429940876
    H2              .0000000000        2.5331491787        4.3818833166
    H2b             .0000000000       -2.5331491787        4.3818833166
    End of basis

  >>> Do while <<<
  &SEWARD

  >>> IF ( ITER = 1 ) <<<
  &SCF; TITLE= Thiophene molecule
    OCCUPIED= 18 4
    ITERATIONS = 40

  &RASSCF; TITLE= Thiophene molecule 1A'
    SYMMETRY=1; SPIN=1; NACTEL= 6    0    0
    INACTIVE= 18    1
    RAS2    =  0    5
    ITER= 50,25
  >>> ENDIF <<<

  &RASSCF; TITLE= Thiophene molecule 3 1A'
    SYMMETRY=1; SPIN=1; NACTEL= 6    0    0
    INACTIVE= 18    1
    RAS2    =  0    5
    ITER= 50,25
    CIROOT=3 3 1
    RLXRoot= 3

  &ALASKA
  &SLAPAF &END
  >>> ENDDO <<<

.. index::
   single: Convergence problems
   single: Optimization; Convergence problems
   single: Optimization; Do always

It should be remembered that geometry optimizations for excited states
are difficult. Not only can it be difficult to converge the corresponding
:program:`RASSCF` calculation, but we must also be sure that the order of the
states does not change during the optimization of the geometry. This is
not uncommon and the optimization must be followed by the user.

.. Sometimes may be interesting to follow the path of the optimization
   by looking at each one of the output files generated by |molcas|.
   All the iterative information is stored in the input file if the
   "Set Output File" command as not used. If it was used
   the output files of each complete iteration are stored in the $WorkDir
   directory under the names :file:`1.save.$iter`, for instance:
   :file:`1.save.1`, :file:`1.save.2`, etc. You should not remove the
   $WorkDir directory if you want to keep them.

.. index::
   single: Optimization; Geometry restrictions

Restrictions in symmetry or geometry
------------------------------------

.. index::
   single: Biphenyl
   single: SLAPAF
   single: SLAPAF; Constraints
   single: Program; SLAPAF
   single: Program; Gateway

Optimizing with geometrical constraints
.......................................

A common situation in geometry optimizations is to have one or
several coordinates fixed or constrained and vary the remaining coordinates.
As an example we will take the biphenyl molecule, two benzene moieties
bridged by a single bond. The ground state of the molecule is not
planar. One benzene group is twisted by 44 degrees with
respect to the other :cite:`Rubio:94`. We can use this example to perform
two types of restricted optimizations. The simplest way to introduce
constraints is to give a coordinate a fixed value and let the other
coordinates to be optimized. For instance, let's fix the dihedral
angle between both benzenes to be fixed to 44 degrees. Within
this restriction, the remaining coordinates will be fully optimized.
The :kword:`Constraints` keyword in the program :program:`GATEWAY` will
take care of the restriction (note this keyword could also
be placed in the program :program:`SLAPAF`). The input could be:

.. extractfile:: advanced/OPT.biphenyl.input

  &GATEWAY; Title= Biphenyl twisted D2
    Symmetry= XY XZ
    Basis set
    C.ANO-S...3s2p1d.
    C1             1.4097582886         .0000000000         .0000000000
    C2             2.7703009377        2.1131321616         .8552434921
    C3             5.4130377085        2.1172148045         .8532344474
    C4             6.7468359904         .0000000000         .0000000000
    End of basis
    Basis set
    H.ANO-S...2s.
    H2             1.7692261798        3.7578798540        1.5134152112
    H3             6.4188773347        3.7589592975        1.5142479153
    H4             8.7821560635         .0000000000         .0000000000
    End of basis
    Constraints
       d1 = Dihedral C2 C1 C1(XY) C2(XY)
    Values
       d1 = -44.4 degrees
    End of Constraints

  >>> Do while <<<
  &SEWARD
  >>> IF ( ITER = 1 ) <<<
  &SCF; TITLE= Biphenyl twisted D2
    OCCUPIED= 12 9 9 11
    ITERATIONS= 50
  >>> ENDIF <<<

  &RASSCF; TITLE= Biphenyl twisted D2
    SYMMETRY=1; SPIN=1; NACTEL= 12    0    0
    INACTIVE= 11    7    7   10
    RAS2    =  2    4    4    2

  &ALASKA
  &SLAPAF; Iterations=30; MaxStep=1.0
  >>> ENDDO <<<

One important consideration about the constraint. You do not need
to start at a geometry having the exact value for the coordinate
you have selected (44.4 degrees for the dihedral angle here).
The optimization will lead you to the right solution. On the other
hand, if you start exactly with the dihedral being 44.4 deg the
code does not necessarily will freeze this value in the first
iterations, but will converge to it at the end. Therefore, it may
happen that the value for the dihedral differs from the selected
value in the initial iterations. You can follow the optimization
steps in the $WorkDir directory using the MOLDEN files generated
automatically by |molcas|.

Now we will perform the opposite optimization: we want to optimize the
dihedral angle relating both benzene units but keep all the other
coordinates fixed. We could well use the same procedure as before
adding constraints for all the remaining coordinates different from
the interesting dihedral angle, but to build the input would be
tedious. Therefore, instead of keyword :kword:`Constraints` we
will make use of the keywords :kword:`Vary` and :kword:`Fix`.

The input file should be:

.. extractfile:: advanced/OPT.constrains.biphenyl.input

  &GATEWAY; Title= Biphenyl twisted D2
    Symmetry=XY XZ
    Basis set
    C.ANO-S...3s2p1d.
    C1             1.4097582886         .0000000000         .0000000000
    C2             2.7703009377        2.1131321616         .8552434921
    C3             5.4130377085        2.1172148045         .8532344474
    C4             6.7468359904         .0000000000         .0000000000
    End of basis
    Basis set
    H.ANO-S...2s.
    H2             1.7692261798        3.7578798540        1.5134152112
    H3             6.4188773347        3.7589592975        1.5142479153
    H4             8.7821560635         .0000000000         .0000000000
    End of basis

  >>> Do while <<<
  &SEWARD
  >>> IF ( ITER = 1 ) <<<
  &SCF; TITLE= Biphenyl twisted D2
    OCCUPIED= 12 9 9 11
    ITERATIONS= 50
  >>> ENDIF <<<

  &RASSCF; TITLE= Biphenyl twisted D2
    SYMMETRY=1; SPIN=1; NACTEL=12    0    0
    INACTIVE= 11    7    7   10
    RAS2    =  2    4    4    2

  &ALASKA
  &SLAPAF
  Internal coordinates
  b1 = Bond C1 C1(XY)
  b2 = Bond C1 C2
  b3 = Bond C2 C3
  b4 = Bond C3 C4
  h1 = Bond C2 H2
  h2 = Bond C3 H3
  h3 = Bond C4 H4
  a1 = Angle C2 C1 C1(XY)
  a2 = Angle C1 C2 C3
  a3 = Angle C1 C2 H2
  a4 = Angle C2 C3 H3
  phi = Dihedral C2 C1 C1(XY) C2(XY)
  d1 = Dihedral H2 C2 C1 C1(XY)
  d2 = OutOfP C3 C1(XY) C1 C2
  d3 = Dihedral H3 C3 C2 H2
  Vary; phi
  Fix; b1; b2; b3; b4; h1; h2; h3; a1; a2; a3; a4; d1; d2; d3
  End of Internal
  Iterations= 30
  >>> ENDDO <<<

To be able to optimize the molecule in that way a :math:`D_2` symmetry
has to be used. In the definition of the internal coordinates
we can use an out-of-plane coordinate: C2 C2(xy) C1(xy) C1 or
a dihedral angle
C2 C1 C1(xy) C2(xy). In this case there is no major problem but
in general one has to avoid as much as possible to define
dihedral angles close to 180\ |o| (trans conformation).
The :program:`SLAPAF` program will warn about this problem if necessary.
In the present example, angle "phi" is the angle to vary
while the remaining coordinates are frozen. All this is only
a problem in the user-defined internal approach, not in the
non-redundant internal approach used by default in the program.
In case we do not have the coordinates from a previous calculation
we can always run a simple calculation with one iteration
in the :program:`SLAPAF` program.

It is not unusual to have problems in the relaxation step when
one defines internal coordinates. Once the program has found that
the definition is consistent with the molecule and the symmetry,
it can happen that the selected coordinates are not the best choice
to carry out the optimization, that the variation of some of the
coordinates is too large or maybe some of the angles are close
to their limiting values (|+-|\180\ |o| for Dihedral angles and
|+-|\90\ |o| for Out of Plane angles). The SLAPAF program will
inform about these problems. Most of the situations are solved by
re-defining the coordinates, changing the basis set or the geometry
if possible, or even freezing some of the coordinates.
One easy solution is to froze this particular coordinate and optimize,
at least partially, the other as an initial step to a full
optimization. It can be recommended to change the definition of the
coordinates from internal to Cartesian.

.. figure:: biphenyl.*
   :name: fig:biphenyl
   :width: 50%
   :align: center

   Twisted biphenyl molecule

.. index::
   single: Optimization; Symmetry restrictions

Optimizing with symmetry restrictions
.....................................

Presently, |molcas| is prepared to work in the point groups
:math:`C_1`, :math:`C_i`, :math:`C_s`, :math:`C_2`, :math:`D_2`, :math:`C_{2h}`, :math:`C_{2v}`, and :math:`D_{2h}`.
To have the wave functions or geometries in other symmetries we
have to restrict orbital rotations or geometry relaxations specifically.
We have shown how to in the :program:`RASSCF` program by using the
:kword:`SUPSym` option. In a geometry optimization we may also want to
restrict the geometry of the molecule to other symmetries. For
instance, to optimize the benzene molecule which belongs to the
:math:`D_{6h}` point group we have to generate the integrals and
wave function in :math:`D_{2h}` symmetry, the highest group available,
and then make the appropriate combinations of the coordinates
chosen for the relaxation in the :program:`SLAPAF` program, as is shown
in the manual.

.. index::
   single: Ammonia
   single: SLAPAF
   single: SLAPAF; Vary
   single: SLAPAF; Fix
   single: Program; SLAPAF

As an example we will take the ammonia molecule, :math:`\ce{NH3}`. There is
a planar transition state along the isomerization barrier between
two pyramidal structures. We want to optimize the planar structure
restricted to the :math:`D_{3h}` point group. However, the electronic wave function will
be computed in :math:`C_s` symmetry (:math:`C_{2v}` is also possible)
and will not be restricted, although it is possible to do that
in the :program:`RASSCF` program.

The input for such a geometry optimization is:

.. extractfile:: advanced/OPT.NH3.input

  &GATEWAY; Title= NH3, planar
    Symmetry= Z
    Basis Set
    N.ANO-L...4s3p2d.
    N               .0000000000         .0000000000         .0000000000
    End of Basis
    Basis set
    H.ANO-L...3s2p.
    H1             1.9520879910         .0000000000         .0000000000
    H2             -.9760439955        1.6905577906         .0000000000
    H3             -.9760439955       -1.6905577906         .0000000000
    End of Basis

  >>> Do while <<<
  &SEWARD
  >>> IF ( ITER = 1 ) <<<
  &SCF; Title= NH3, planar
    Occupied= 4 1
    Iterations= 40
  >>> ENDIF <<<

  &RASSCF; Title= NH3, planar
    Symmetry=1; Spin=1; Nactel=8  0  0
    INACTIVE=1 0
    RAS2    =6 2

  &ALASKA

  &SLAPAF
  Internal coordinates
  b1 = Bond N H1
  b2 = Bond N H2
  b3 = Bond N H3
  a1 = Angle H1 N H2
  a2 = Angle H1 N H3
  Vary
    r1 = 1.0 b1 + 1.0 b2 + 1.0 b3
  Fix
    r2 = 1.0 b1 - 1.0 b2
    r3 = 1.0 b1 - 1.0 b3
    a1 = 1.0 a1
    a2 = 1.0 a2
  End of internal
  >>> ENDDO <<<

All four atoms are in the same plane.
Working in :math:`C_s`, planar ammonia has five degrees of freedom.
Therefore we must define five independent internal coordinates, in this
case the three :math:`\ce{N-H}` bonds and two of the three angles :math:`\ce{H-N-H}`. The
other is already defined knowing the two other angles.
Now we must define the varying coordinates. The bond lengths will
be optimized, but all three :math:`\ce{N-H}` distances must be equal.
First we define (see definition in the previous input)
coordinate :math:`r1` equal to the sum of all three
bonds; then, we define coordinates :math:`r2` and :math:`r3` and keep them fixed.
:math:`r2` will ensure that ``bond1`` is equal to ``bond2`` and :math:`r3` will assure that
``bond3`` is equal to ``bond1``. :math:`r2` and :math:`r3` will have a zero value.
In this way all three bonds will have the same length.
As we want the system constrained into the :math:`D_{3h}` point group,
the three angles must be equal with a value of 120 degrees. This is
their initial value, therefore we simply keep coordinates ``ang1`` and ``ang2``
fixed. The result is a :math:`D_{3h}` structure: ::

                      *******************************************
                      *    InterNuclear Distances / Angstrom    *
                      *******************************************

                 1 N             2 H1            3 H2            4 H3
      1 N        0.000000
      2 H1       1.003163        0.000000
      3 H2       1.003163        1.737529        0.000000
      4 H3       1.003163        1.737529        1.737529        0.000000

                      **************************************
                      *    Valence Bond Angles / Degree    *
                      **************************************
                            Atom centers                 Phi
                        2 H1       1 N        3 H2       120.00
                        2 H1       1 N        4 H3       120.00
                        3 H2       1 N        4 H3       120.00

.. Note: contains a nbsp

In a simple case like this an optimization without
restrictions would also end up in the same symmetry as the initial
input.

.. index::
   single: Optimization; Z-matrix

Optimizing with Z-Matrix
------------------------

An alternative way to optimize a structure with geometrical and/or symmetrical
constraints is to combine the Z-Matrix definition of the molecular structure
used for the program :program:`SEWARD` with a coherent definition for the
:kword:`Internal Coordinated` used in the optimization by program :program:`SLAPAF`.

Here is an examples of optimization of the methyl carbanion. Note that the
wavefunction is calculated within the :math:`C_s` symmetry but the geometry is optimized
within the :math:`C_{3v}` symmetry through the :kword:`ZMAT` and the :kword:`Internal
Coordinates` definitions. Note that :kword:`XBAS` precedes :kword:`ZMAT`.

.. extractfile:: advanced/OPT.Zmat.input

  &Gateway
    Symmetry=Y
    XBAS=Aug-cc-pVDZ
    ZMAT
    C1
    X2   1  1.00
    H3   1  1.09   2 105.
    H4   1  1.09   2 105.    3  120.

  >>>  export MOLCAS_MAXITER=500
  >>>  Do  While  <<<

  &SEWARD
  &SCF; Charge= -1

  &ALASKA

  &SLAPAF
    Internal Coordinates
      CX2  = Bond C1 X2
      CH3  = Bond C1 H3
      CH4  = Bond C1 H4
      XCH3 = Angle X2 C1 H3
      XCH4 = Angle X2 C1 H4
      DH4  = Dihedral H3 X2 C1 H4
    Vary
      SumCH34  = 1. CH3  +2. CH4
      SumXCH34 = 1. XCH3 +2. XCH4
    Fix
      rCX2  = 1.0 CX2
      DifCH34  = 2. CH3  -1. CH4
      DifXCH34 = 2. XCH3 -1. XCH4
      dDH4  = 1.0 DH4
    End of Internal
    PRFC
    Iterations= 10
  >>>  EndDo  <<<

Note that the *dummy* atom X2 is used to define the Z axis and the planar angles
for the hydrogen atoms. The linear combinations of bond distances and planar
angles in the expression in the :kword:`Vary` and :kword:`Fix` sections are used
to impose the :math:`C_{3v}` symmetry.

Another example where the wavefunction and the geometry can be calculated
within different symmetry groups is benzene. In this case, the former uses
:math:`D_{2h}` symmetry and the latter :math:`D_{6h}` symmetry. Two special atoms are
used: the *dummy* X1 atom defines the center of the molecule while the *ghost*
Z2 atom is used to define the :math:`C_6` rotational axis (and the Z axis).

.. extractfile:: advanced/OPT.Zmat.symmetry.input

  &GATEWAY
    Symmetry=X Y Z
    XBAS
    H.ANO-S...2s.
    C.ANO-S...3s2p.
    End of basis
    ZMAT
    X1
    Z2   1  1.00
    C3   1  1.3915   2  90.
    C4   1  1.3915   2  90.    3  60.
    H5   1  2.4715   2  90.    3   0.
    H6   1  2.4715   2  90.    3  60.

  >>>  export MOLCAS_MAXITER=500
  >>>  Do  While  <<<

  &SEWARD ; &SCF ; &ALASKA

  &SLAPAF
    Internal Coordinates
      XC3 = Bond X1 C3
      XC4 = Bond X1 C4
      XH5 = Bond X1 H5
      XH6 = Bond X1 H6
      CXC = Angle C3 X1 C4
      HXH = Angle H5 X1 H6
    Vary
      SumC = 1.0 XC3 + 2.0 XC4
      SumH = 1.0 XH5 + 2.0 XH6
    Fix
      DifC = 2.0 XC3 - 1.0 XC4
      DifH = 2.0 XH5 - 1.0 XH6
      aCXC = 1.0 CXC
      aHXH = 1.0 HXH
    End of Internal
    PRFC

  >>> EndDo <<<

Note that the *ghost* atom Z2 is used to define the geometry within the Z-Matrix
but it does not appear in the :kword:`Internal Coordinates` section. On the
other hand, the *dummy* atom X1 represents the center of the molecule and it
is used in the :kword:`Internal Coordinates` section.

.. index::
   single: Program; CASPT2
   single: Program; SLAPAF
   single: Optimization; CASPT2
   single: Acrolein

CASPT2 optimizations
--------------------

For systems showing a clear multiconfigurational nature, the CASSCF
treatment on top of the HF results is of crucial importance in order to
recover the large non dynamical correlation effects.
On the other hand, ground-state geometry optimizations of closed
shell systems are not exempt from non dynamical correlation effects.
In general, molecules containing :math:`\pi` electrons suffer from significant
effects of non dynamical correlation, even more in presence of
conjugated groups. Several studies on systems with delocalized bonds
have shown the effectiveness of the CASSCF approach in reproducing
the main geometrical parameters with
high accuracy :cite:`Serrano:93a,Serrano:96a,Page:99`.

However, pronounced effects of dynamical correlation often occur
in systems with :math:`\pi` electrons, especially in combination with polarized
bonds. An example is given by the :math:`\ce{C=O}` bond length, which is known
to be very sensitive to an accurate
description of the dynamical correlation effects :cite:`Pou:99`. We will show now
that the inherent limitations of the CASSCF method can be successfully overcome by employing
a CASPT2 geometry optimization, which uses a numerical gradient procedure
of recent implementation. A suitable molecule for this investigation
is acrolein.
As many other conjugated aldehydes and ketones, offers an example
of *s-cis*/*s-trans* isomerism (:numref:`fig:cis-trans`). Due to the resonance
between various structures
involving :math:`\pi` electrons,
the bond order for the :math:`\ce{C-C}` bond is higher than the one for a non-conjugated
:math:`\ce{C-C}` single bond. This partial double-bond character restricts the rotation
about such a bond, giving rise to the possibility of geometrical isomerism,
analogue to the *cis*--\ *trans* one observed for conventional double bonds.

A :program:`CASPT2` geometry optimization can be performed in |molcas|.
A possible input for the CASPT2 geometry optimization of the *s-trans*
isomer is displayed below. The procedure is invoking the resolution-of-identity
approximation using the keyword :kword:`RICD`. This option will speed up the
calculation, something which makes sense since we will compute the gradients numerically.

.. extractfile:: advanced/OPT.CASPT2.input

  >>> Export MOLCAS_MAXITER=500

  &GATEWAY
    Title= Acrolein Cs symmetry - transoid
    Coord
      8

      O      0.0000000     -1.4511781     -1.3744831
      C      0.0000000     -0.8224882     -0.1546649
      C      0.0000000      0.7589531     -0.0387200
      C      0.0000000      1.3465057      1.2841925
      H      0.0000000     -1.4247539      0.8878671
      H      0.0000000      1.3958142     -1.0393956
      H      0.0000000      0.6274048      2.2298215
      H      0.0000000      2.5287634      1.4123985
      Group=X
      Basis=ANO-RCC-VDZP
      RICD

  >>>>>>>>>>>>> Do while <<<<<<<<<<<<

  &SEWARD

  >>>>>>>> IF ( ITER = 1 ) <<<<<<<<<<<
  &SCF; Title= Acrolein Cs symmetry
  *The symmetry species are a'  a''
  Occupied= 13 2
  >>>>>>> ENDIF <<<<<<<<<<<<<<<<<<<<<

  &RASSCF; Title=Acrolein ground state
     nActEl= 4 0 0
     Inactive= 13 0
  *  The symmetry species are a'  a''
     Ras2= 0 4

  &CASPT2

  &SLAPAF
  >>>>>>>>>>>>> ENDDO  <<<<<<<<<<<<<<

Experimental investigations assign a planar structure for both the
isomers. We can take advantage of this result and use a :math:`C_s` symmetry
throughout the optimization procedure. Moreover, the choice of the
active space is suggested by previous calculations on analogous
systems. The active space contains 4 :math:`\pi` MOs / 4 :math:`\pi` electrons, thus
what we will call shortly a :math:`\pi`\-CASPT2 optimization.

The structure of the input follows the trends already explained in
other geometry optimizations, that is, loops over the set of programs
ending with :program:`SLAPAF`. Notice that CASPT2 optimizations require
obviously the :program:`CASPT2` input, but also the input for the
:program:`ALASKA` program, which computes the gradient numerically.
Apart from that, a CASPT2 optimization input is identical to the corresponding
CASSCF input.
One should note that the numerical gradients are not as accurate as the
analytic gradient. This can manifest itself in that there is no strict energy
lowering the last few iterations, as displayed below: ::

  *****************************************************************************************************************
  *                                  Energy Statistics for Geometry Optimization                                  *
  *****************************************************************************************************************
                         Energy     Grad     Grad              Step                 Estimated   Geom     Hessian
  Iter      Energy       Change     Norm     Max    Element    Max     Element     Final Energy Update Update Index
    1   -191.38831696  0.00000000 0.208203-0.185586 nrc007  -0.285508* nrc007     -191.41950985 RS-RFO  None    0
    2   -191.43810737 -0.04979041 0.117430-0.100908 nrc007  -0.190028* nrc007     -191.45424733 RS-RFO  BFGS    0
    3   -191.45332692 -0.01521954 0.022751-0.021369 nrc007  -0.051028  nrc007     -191.45399070 RS-RFO  BFGS    0
    4   -191.45414598 -0.00081906 0.012647 0.005657 nrc002  -0.013114  nrc007     -191.45421525 RS-RFO  BFGS    0
    5   -191.45422730 -0.00008132 0.003630 0.001588 nrc002   0.004050  nrc002     -191.45423299 RS-RFO  BFGS    0
    6   -191.45423140 -0.00000410 0.000744 0.000331 nrc006   0.000960  nrc013     -191.45423186 RS-RFO  BFGS    0
    7   -191.45423123  0.00000017 0.000208-0.000098 nrc003  -0.001107  nrc013     -191.45423159 RS-RFO  BFGS    0
    8   -191.45423116  0.00000007 0.000572 0.000184 nrc006   0.000422  nrc013     -191.45423131 RS-RFO  BFGS    0

         +----------------------------------+----------------------------------+
         +    Cartesian Displacements       +    Gradient in internals         +
         +  Value      Threshold Converged? +  Value      Threshold Converged? +
   +-----+----------------------------------+----------------------------------+
   + RMS + 0.5275E-03  0.1200E-02     Yes   + 0.1652E-03  0.3000E-03     Yes   +
   +-----+----------------------------------+----------------------------------+
   + Max + 0.7738E-03  0.1800E-02     Yes   + 0.1842E-03  0.4500E-03     Yes   +
   +-----+----------------------------------+----------------------------------+

   Geometry is converged in   8 iterations to a Minimum Structure

  *****************************************************************************************************************
  *****************************************************************************************************************

The calculation converges in 8 iterations. At this point it is worth noticing
how the convergence of CASPT2 energy is not chosen among the criteria for the
convergence of the structure. The final structure is in fact decided by checking the
Cartesian displacements and the gradient in non-redundant internal coordinates.

CASPT2 optimizations are expensive, however, the use for the resolution-of-identity
options gives some relief. Notice that they are based on numerical
gradients and many point-wise calculations are needed. In particular,
the Cartesian gradients are computed using a two-point formula.
Therefore, each macro-iteration
in the optimization requires :math:`2N + 1` Seward/RASSCF/CASPT2 calculations, with :math:`N` being
the Cartesian degrees of freedom. In the present example, acrolein has eight atoms.
From each atom, only two Cartesian coordinates are free to move (we are working
within the :math:`C_s` symmetry and the third coordinate is frozen), therefore the
total number of Seward/RASSCF/CASPT2 iterations within each macro-iteration
is :math:`2(8\cdot 2) + 1`, that is, 33. In the current example a second trick has been
used to speed up the numerical calculation. The explicit reference to :program:`ALASKA`
is excluded. This means that :program:`SLAPAF` is called first without any gradients
beeing computed explicitly. It does then abort automatically requesting an implicit
calulation of the gradients, however, before doing so it compiles the internal coordinates
and sets up a list of displaced geometries to be used in a numerical gradient procedure.
In the present case this amounts to that the actual number of micro iterations is
reduced from 33 to 29.

The :numref:`tab:geo-acrol` displays the equilibrium geometrical
parameters computed at the :math:`\pi`\-CASSCF and :math:`\pi`\-CASPT2
level of theory
for the ground state of both isomers of acrolein. For sake of comparison,
:numref:`tab:geo-acrol` includes
experimental data obtained from microwave spectroscopy
studies :cite:`Blom:82`. The computed parameters at :math:`\pi`\-CASPT2 level are in
remarkable agreement with the experimental
data. The predicted value of the :math:`\ce{C=C}` bond length is very close to the double bond length
observed in ethylene. The other :math:`\ce{C-C}` bond has a length within the range expected
for a :math:`\ce{C-C}` single bond: it appears shorter in the *s-trans* isomer as a consequence
of the reduction of steric hindrance between the ethylenic and aldehydic
moieties. CASSCF estimates a carbon-oxygen bond length shorter
than the experimental value. For
:math:`\pi`\-CASSCF optimization in conjugated systems this can be assumed as a general
behavior :cite:`Molina:01b,Pou:99`. To explain such
a discrepancy, one may invoke the fact that the :math:`\ce{C=O}` bond distance is
particularly sensitive to electron correlation effects. The :math:`\pi` electron
correlation effects included at the :math:`\pi`\-CASSCF level tend to overestimate bond
lengths. However, the lack of :math:`\sigma` electron correlation, goes
in the opposite direction, allowing shorter bond distances for double bonds.
For the :math:`\ce{C=C}` double bonds, these contrasting behaviors compensate each other
:cite:`Page:99` resulting in quite an accurate value for the bond length at the
:math:`\pi`\-CASSCF level. On the contrary, the extreme sensitivity of the :math:`\ce{C=O}`
bond length to the electron correlation effects, leads to a general
underestimation of the :math:`\ce{C=O}` double bond lengths, especially when such
a bond is part of a conjugated system. It is indeed the effectiveness of the CASPT2
method in recovering dynamical correlation which leads to a substantial improvement
in predicting the :math:`\ce{C=O}` double bond length.

.. figure:: acrolein.*
   :name: fig:cis-trans
   :width: 75%
   :align: center

   Acrolein geometrical isomers

.. table:: Geometrical parameters for the ground state of acrolein.
   :name: tab:geo-acrol

   =============================== ============= ============= ============= ============= =============
   Parameters\ [#a]_               :math:`\pi`\-CASSCF [04/4]  :math:`\pi`\-CASPT2         Expt.\ [#b]_
   ------------------------------- --------------------------- --------------------------- -------------
   |zws|                           *s-cis*       *s-trans*     *s-cis*       *s-trans*
   =============================== ============= ============= ============= ============= =============
   :math:`\ce{C{1}=O}`             1.204         1.204         1.222         1.222         1.219
   :math:`\ce{C{1}-C{2}}`          1.483         1.474         1.478         1.467         1.470
   :math:`\ce{C{2}=C{3}}`          1.340         1.340         1.344         1.344         1.345
   :math:`\angle\ce{C{1}C{2}C{3}}` 123.0         121.7         121.9         120.5         119.8
   :math:`\angle\ce{C{2}C{1}O}`    124.4         123.5         124.5         124.2         ---
   =============================== ============= ============= ============= ============= =============

.. [#a] Bond distances in Å and angles in degrees.
.. [#b] Microwave spectroscopy data from ref. :cite:`Blom:82`.
        No difference between *s-cis* and *s-trans* isomers is reported.

The use of numerical CASPT2 gradients can be extended to all the optimizations
available in :program:`SLAPAF`, for instance transition state searches.
Use the following input for the water molecule to locate the linear
transition state:

.. index::
   single: Optimization; TS

.. extractfile:: advanced/OPT.TS.input

  &GATEWAY; Title= Water, STO-3G Basis set
    Coord
    3

    H1   -0.761622       0.000000      -0.594478
    H2    0.761622       0.000000      -0.594478
    O     0.000000       0.000000       0.074915
    Basis set= STO-3G
    Group= NoSym

  >>> EXPORT MOLCAS_MAXITER=500
  >> DO WHILE

  &SEWARD

  >>> IF ( ITER = 1 ) <<<
  &SCF; Title= water, STO-3g Basis set
  Occupied= 5
  >>> ENDIF <<<

  &RASSCF
  Nactel= 2 0 0
  Inactive= 4
  Ras2    = 2

  &CASPT2

  &SLAPAF; TS
  >>> ENDDO <<<

After seventeen macro-iterations the linear water is reached: ::

  *****************************************************************************************************************
  *                                  Energy Statistics for Geometry Optimization                                  *
  *****************************************************************************************************************
                         Energy     Grad     Grad              Step                 Estimated   Geom     Hessian
  Iter      Energy       Change     Norm     Max    Element    Max     Element     Final Energy Update Update Index
    1    -75.00567587  0.00000000 0.001456-0.001088 nrc003  -0.003312  nrc001      -75.00567822 RSIRFO  None    1
    2    -75.00567441  0.00000145 0.001471-0.001540 nrc003  -0.004162  nrc001      -75.00567851 RSIRFO  MSP     1
    3    -75.00566473  0.00000968 0.003484-0.002239 nrc003   0.008242  nrc003      -75.00567937 RSIRFO  MSP     1
    4    -75.00562159  0.00004314 0.006951-0.004476 nrc003   0.016392  nrc003      -75.00568012 RSIRFO  MSP     1
    5    -75.00544799  0.00017360 0.013935-0.008809 nrc003   0.033088  nrc003      -75.00568171 RSIRFO  MSP     1
    6    -75.00475385  0.00069414 0.027709-0.017269 nrc003   0.066565  nrc003      -75.00568219 RSIRFO  MSP     1
    7    -75.00201367  0.00274018 0.054556-0.032950 nrc003   0.084348* nrc003      -75.00430943 RSIRFO  MSP     1
    8    -74.99610698  0.00590669 0.086280-0.050499 nrc003   0.082995* nrc003      -74.99970484 RSIRFO  MSP     1
    9    -74.98774224  0.00836474 0.114866-0.065050 nrc003   0.080504* nrc003      -74.99249408 RSIRFO  MSP     1
   10    -74.97723219  0.01051005 0.139772 0.076893 nrc002   0.107680* nrc003      -74.98534124 RSIRFO  MSP     1
   11    -74.95944303  0.01778916 0.167230 0.096382 nrc002  -0.163238* nrc002      -74.97296260 RSIRFO  MSP     1
   12    -74.93101977  0.02842325 0.182451-0.114057 nrc002   0.185389* nrc002      -74.94544042 RSIRFO  MSP     1
   13    -74.90386636  0.02715341 0.157427-0.107779 nrc002   0.201775* nrc002      -74.91601550 RSIRFO  MSP     1
   14    -74.88449763  0.01936873 0.089073-0.064203 nrc002   0.240231  nrc002      -74.89232405 RSIRFO  MSP     1
   15    -74.87884197  0.00565566 0.032598-0.019326 nrc002   0.050486  nrc002      -74.87962885 RSIRFO  MSP     1
   16    -74.87855520  0.00028677 0.004934-0.004879 nrc003  -0.006591  nrc003      -74.87857157 RSIRFO  MSP     1
   17    -74.87857628 -0.00002108 0.000172-0.000120 nrc003   0.000262  nrc002      -74.87857630 RSIRFO  MSP     1

         +----------------------------------+----------------------------------+
         +    Cartesian Displacements       +    Gradient in internals         +
         +  Value      Threshold Converged? +  Value      Threshold Converged? +
   +-----+----------------------------------+----------------------------------+
   + RMS + 0.1458E-03  0.1200E-02     Yes   + 0.9925E-04  0.3000E-03     Yes   +
   +-----+----------------------------------+----------------------------------+
   + Max + 0.1552E-03  0.1800E-02     Yes   + 0.1196E-03  0.4500E-03     Yes   +
   +-----+----------------------------------+----------------------------------+

   Geometry is converged in  17 iterations to a Transition State Structure

  *****************************************************************************************************************
  *****************************************************************************************************************

We note that the optimization goes through three stages. The first one is while the structure still is
very much ground-state-like. This is followed by the second stage in which the :math:`\ce{H-O-H}` angle is drastically
changed at each iteration (iterations 7--13). The ``*`` at ``Step Max`` entry indicate that these steps were
reduced because the steps were larger than allowed.
Changing the default max step length from 0.3 to 0.6 (using keyword :kword:`MaxStep`)
reduces the number of macro iterations by 2 iterations.
Extra information about basis sets and integrals
================================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Basis set format
----------------

.. compound::

  The **Inline** option for a basis set will read the basis set
  as defined by the following pseudo code. ::

    Read Charge, lAng
    Do iAng = 0, lAng
       Read nPrim, nContr
       Read (Exp(iPrim),iPrim=1,nPrim)
       Do iPrim=1,nPrim
          Read (Coeff(iPrim,iContr),iContr=1,nContr)
       End Do
    End Do

  where ``Charge`` is the nuclear charge, ``lAng`` is the highest angular
  momentum quantum number, ``nPrim`` is the number of primitive functions
  (exponents) for a given shell, and ``nContr`` is the number of contracted
  functions for a given shell.

The following is an example of a DPZ basis set for carbon.
Normally, however, the basis set will be read from a library file following
the specified label (like, e.g., C.DZP...4s2p1d.),
and not be inserted inline at the input file. ::

  Basis set                                -- Start defining a basis set
  C.DZP.Someone.9s5p1d.4s2p1d. / inline    -- Definition in input stream
         6.0              2                -- charge, max l-quantum no.
      9    4                               -- no. of prim. and contr. s-functions
  4232.61                                  -- s-exponents
  634.882
  146.097
  42.4974
  14.1892
  1.9666
  5.1477
  0.4962
  0.1533
    .002029   .0       .0       .0         -- s-contraction matrix
    .015535   .0       .0       .0
    .075411   .0       .0       .0
    .257121   .0       .0       .0
    .596555   .0       .0       .0
    .242517   .0       .0       .0
    .0       1.0       .0       .0
    .0        .0      1.0       .0
    .0        .0       .0      1.0
      5    2                               -- no. of prim. and contr. p-functions
  18.1557                                  -- p-exponents
  3.98640
  1.14290
  0.3594
  0.1146
   .018534   .0                            -- p-contraction matrix
   .115442   .0
   .386206   .0
   .640089   .0
   .0       1.0
      1    1                               -- no. of prim. and contr. d-functions
     .75                                   -- d-exponents
    1.0                                    -- d-contraction matrix
  C1 0.00000 0.00000 0.00000               -- atom-label, Cartesian coordinates
  C2 1.00000 0.00000 0.00000               -- atom-label, Cartesian coordinates
  End Of Basis                             -- end of basis set definition

The basis set label and the ECP libraries
-----------------------------------------

The label within the :file:`ECP` library
is given as input in the line following the keyword :kword:`BASIS SET`.
The label defines either the valence basis set and core potential
which is assigned to a
frozen-core atom
or the embedding potential
which is assigned to an environmental froze-ion.
Here, all the comments made about this label in the section
**The basis set label and the basis set library**
for all-electron basis sets
stand, except for the following changes:

#. The identifier ``type`` must be ``ECP`` or ``PP``.

#. The identifier ``aux`` specifies the kind of the potential.
   It is used, for instance, to choose between non-relativistic, Cowan--Griffin, or no-pair
   Douglas--Kroll relativistic core potentials
   (i.e. ``Pt.ECP.Casarrubios.13s10p9d5f.1s2p2d1f.16e-NR-AIMP.``
   or ``Pt.ECP.Casarrubios.13s10p9d5f.1s2p2d1f.16e-CG-AIMP.``
   or ``Pt.ECP.Rakowitz.13s10p9d6f.5s4p4d2f.18e-NP-AIMP.``)
   and to pick up one among all the embedding potentials available
   for a given ion
   (i.e. ``F.ECP.Lopez-Moraza.0s.0s.0e-AIMP-KMgF3.``
   or ``F.ECP.Lopez-Moraza.0s.0s.0e-AIMP-CsCaF3.``).

#. The identifier ``contracted`` is used here
   in order to produce the actual basis set
   out of the basis set included in the :file:`ECP` library,
   which is a minimal basis set (in general contraction form) augmented
   with some polarization, diffuse, ... function.
   It indicates the number of s, p, ... contracted functions
   in the actual basis set,
   the result being always a many-primitive contracted function
   followed by a number of primitives.
   As an example,
   ``At.ECP.Barandiaran.13s12p8d5f.3s4p3d2f.17e-CG-AIMP.``
   will generate a (13,1,1/12,1,1,1/8,1,1/5,1) formal contraction pattern
   which is in this case a (13,1,1/12,1,1,1/7,1,1/5,1) real pattern.
   Other contraction patters should be input "Inline".

#. The user is suggested to read carefully :numref:`TUT:sec:ecp`
   of the tutorials and examples manual before using the ECP utilities.

.. _UG\:sec\:one-electron_integral_labels:

One-Electron Integral Labels
----------------------------

.. compound::

  The storage of one-electron integrals on disk is facilitated by the
  one-electron integral I/O facility. The internal structure of the
  one-electron file and the management is something which the user normally
  do not need to worry about. However, for the general input section of the
  :program:`FFPT`, the user need to know the name and structure of the internal
  labels which the one-electron integral I/O facility associates with each type
  of one-electron integral. The labels are listed and explained here below for reference.
  The component index is also utilized by the one-electron integral I/O facility to
  discriminate the various components of the one-electron integrals of a certain type,
  for example, the dipole moment integrals have three components (1=x-component,
  2=y-component, 3=z-component). The component index is enumerated as a canonical
  index over the powers of the Cartesian components of the operator (e.g. multipole
  moment, velocity, electric field, etc.). The order is defined by following pseudo
  code, ::

    Do ix = nOrder, 0, -1
       Do iy = nOrder-ix, 0, -1
          iz = nOrder-ix-iy
       End Do
    End Do,

  where ``nOrder`` is the total order of the operator, for example, ``nOrder=2`` for
  the electric field gradient and the quadrupole moment operator.

.. _tab\:bs:

============ =========================================================================
Label        Explanation
============ =========================================================================
``Mltpl nn`` the ``nn``\ th order Cartesian multipole moments.
``MltplS``   the overlap matrix used in the semi-empirical NDDO method.
``Kinetic``  the kinetic energy integrals.
``Attract``  the electron attraction integrals.
``AttractS`` the electron attraction integrals used in the semi-empirical NDDO method.
``PrjInt``   the projection integrals used in ECP calculations.
``M1Int``    the M1 integrals used in ECP calculations.
``M2Int``    the M2 integrals used in ECP calculations.
``SROInt``   the spectrally resolved operator integrals used in ECP calculations.
``XFdInt``   the external electric field integrals.
``MassVel``  the mass-velocity integrals.
``Darwin``   the Darwin one-electron contact integrals.
``Velocity`` the velocity integrals.
``EF0nnnnn`` the electric potential at center ``nnnnn``.
``EF1nnnnn`` the electric field at center ``nnnnn``.
``EF2nnnnn`` the electric field gradient at center ``nnnnn``.
``AngMom``   the angular momentum integrals.
``DMS``      the diamagnetic shielding integrals.
``Wellnnnn`` the ``nnnn``\ th set of spherical well integrals.
``OneHam``   the one-electron Hamiltonian.
``AMProd``   the hermitized product of angular momentum integrals.
``AMFI``     the atomic mean field integrals.
============ =========================================================================
.. index::
   single: Reaction field
   single: Cavity
   single: Solvent

.. _TUT\:sec\:cavity:

Solvent models
==============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

For isolated molecules of modest size the *ab initio* methods
have reached great accuracy at present both for ground and
excited states. Theoretical studies on isolated molecules, however,
may have limited value to bench chemists since most of the
actual chemistry takes place in a solvent. If solute--solvent interactions are
strong they may have a large impact on the electronic structure of a
system and then on its excitation spectrum, reactivity, and properties.
For these reasons, numerous models
have been developed to deal with solute--solvent interactions in *ab
initio* quantum chemical calculations. A microscopic
description of solvation effects can be obtained by a supermolecule
approach or by combining statistical mechanical simulation techniques
with quantum chemical methods.
Such methods, however, demand expensive computations. By contrast, at the
phenomenological level, the solvent can be regarded as a dielectric continuum,
and there are a number of approaches :cite:`Cossi:98,Cossi:01,Karlstroem:88,Serrano:97b,Tomasi:94`
based on the classical reaction field concept.

|molcas| can model the solvent
within the framework of SCF, RASSCF and CASPT2 programs, for the calculation of energies
and properties and also for geometry optimizations. The reaction field formalism
is based on a sharp partition of the system: the solute molecule (possibly
supplemented by some explicit solvent molecules) is placed in a cavity
surrounded by a polarizable dielectric.
The surrounding is characterized mainly by its dielectric constant and density:
an important parameter of the method is the size of the cavity;
the dielectric medium is polarized by the solute, and this polarization creates
a reaction field which perturbs the solute itself.

Two versions of the model are presently available: one is based on the Kirkwood model
:cite:`Karlstroem:88,Serrano:97b` and uses only spherical cavities; the other is
called PCM (polarizable continuum model) :cite:`Cossi:98,Cossi:01` and can
use cavities of general shape, modeled on the actual solute molecule. In the former
case, the reaction field is computed as a truncated multipolar expansion and added
as a perturbation to the one-electron Hamiltonian; in the latter case the reaction
field is expressed in terms of a collection of apparent charges (solvation charges)
spread on the cavity surface: the PCM reaction field perturbs both one- and
two-electron Hamiltonian operators. In both cases, the solvent effects can be
added to the Hamiltonian at any level of theory, including MRCI and CASPT2.

.. index::
   single: Kirkwood model

Kirkwood model
--------------

This version of the model only uses spherical cavities. In addition,
it includes Pauli repulsion due to the medium by introducing a repulsive
potential representing the exchange repulsion between the solute and the solvent.
This is done by defining a penalty function of Gaussian type, generating
the corresponding spherical well integrals, and adding them to the one-electron
Hamiltonian. When the repulsion potential is used, the size of the cavity should
be optimized for the ground state of the molecule (see below). If the repulsive
potential is not used and the cavity size is chosen to be smaller (molecular
size plus van der Waals radius as is the usual choice in the literature)
one must be aware of the consequences: larger solvent effects but also
an unknown presence of molecular charge outside the boundaries of the
cavity. This is not a consequence of the present model but it is a general
feature of cavity models :cite:`Serrano:97b`.

.. Comment: As long as this does not work correctly in the code we should not mention it here!

   Dielectric cavity models, in general, assume equilibrium between the
   electronic state of the solute and the reaction field. This condition is
   not fulfilled for an electronic excitation. Therefore, to compute excited
   states |molcas| introduces the time dependence into the :program:`RASSCF` program
   by partitioning the reaction field factor
   into two parts, a slow and a fast component. The slow
   field follows geometrical changes of the solute and is, in practice,
   determined by the properties of the ground state.
   The fast component can be considered as
   the instantaneous electronic polarization that follows the absorption of
   a photon and the strength of this fast component is proportional to the
   square of the refractive index, that is, the optical value of the
   dielectric constant :cite:`Serrano:97b`.

.. index::
   single: PCM

PCM
---

The cavities are defined as the envelope of spheres centered on solute
atoms or atomic groups (usually hydrogens are included in the same sphere
of the atoms they are bonded to). Two selection of radii are presently available,
i.e. Pauling radii, and the so-called UATM (united atom topological model) radii:
the latter is the default for PCM calculations; sphere radii can also be provided
by the user in the input file.
The solvation charges are placed
in the middle of small tiles (*tesserae*) drawn on the surface; the number of
solvation charges can be gauged by changing the average area of tesserae (keyword
AAre in :program:`SEWARD`).

The program prints some information related to the cavity, where one should
always check carefully the magnitude of sphere radii: the program adjusts them
automatically to the solute topology (each radius depends on
hybridization, bonds, etc.), and sometimes this causes some
problems (for instance, discontinuities could appear during the scan
of a potential energy surface): if this happens, it is preferable to provide
the desired radii in the input file, so that they will be kept at all
geometries.

When doing state-average RASSCF calculations, one has to specify which root is
to be used to generate the solvation charges: this means that the PCM reaction
field will be in equilibrium with a specific electronic state, while it
perturbs all the states included in the calculation.

In electronic transitions (e.g. photon absorption or emission) one has to include
non-equilibrium effects, due to the finite relaxation time of solvent molecules
following a sudden change in electronic distribution. This is done by partitioning the
reaction field in two components (fast and slow, the former always equilibrated,
the latter delayed), whose magnitude is determined by the static dielectric constant
and by a "fast" dielectric constant :cite:`Cossi:00` (for very fast processes, like
photon absorption, the fast constant is equal to the square of the refraction index).
To perform a non-equilibrium calculation, for example to study a ground-to-excited state
transition, one has to perform a regular calculation at equilibrium for the ground state,
followed by a calculation for the excited state specifying the keyword NONEQ in the
:program:`RASSCF` program. Failing to include the keyword NONEQ will cause the program
to compute equilibrium solvation also for the excited state, what would be appropriate
for an adiabatic, instead of a vertical, transition.

CASPT2 calculations can be performed as usual for isolated molecules, specifying
the keyword RFPERT. Geometry optimizations can be performed as usual: note that
the arrangement of solvation charges around the solute molecule is likely
to break the molecular symmetry. If the symmetry was explicitly requested in
:program:`SEWARD`, the system will keep it through the optimization even in the
presence of the solvent, otherwise the convergence could be more difficult, and
the final geometry could result of a lower symmetry.

.. index::
   single: Solvent
   single: Solvent; Ground state
   single: Kirkwood model

Calculation of solvent effects: Kirkwood model
----------------------------------------------

We begin by performing a CASSCF/CASPT2 reaction field calculation
on the ground state of a molecule.

.. compound::

  To use the Kirkwood model, the keyword ::

    REACtion field

  is needed; if no repulsive potential is going to be used the input
  simply consists in adding the
  appropriate data (dielectric constant of the medium, cavity size, and
  angular quantum number of the highest multipole moment of the charge
  distribution) into the :program:`SEWARD` input: ::

    &SEWARD &END
    ...
    ...
    RF-Input
    Reaction field
    80 8.0 4
    End of RF-Input
    ...
    ...
    End of Input

This will compute the reaction field at those levels. The dielectric
constant 80.0 correspond to water as solvent. The radius of the cavity
is 8.0 in atomic units. Finally 4 is the maximum angular moment
number used in the multipole expansion. The cavity origin is the
coordinate origin, thus the molecule must be placed accordingly.

If we want to include the reaction field (either PCM or Kirkwood
model)
at other levels of theory the keyword :kword:`RFPErt` must be
added to the :program:`MOTRA` or :program:`CASPT2` inputs.

We are, however, going to explain the more complicated situation where
a repulsive well potential has to be added to the model. In this case
it is convenient to optimize the size of the cavity, although
in so doing we obtain large cavity sizes and therefore
smaller solvent effects. More realistic results can be obtained if
additional and specific solvent molecules are added inside the cavity.

.. index::
   single: Repulsive well
   single: SEWARD; Well integrals

To define the well potential we have to add the keyword
:kword:`WELL Integrals` to the :program:`SEWARD` input to compute and add the
Pauli repulsion integrals to the bare Hamiltonian.

The requirements considered to build this potential
are that it shall reproduce solvation energies for spherical particles,
ions, and that it must be wide enough so that the electrons in the
excited state of the molecules are also confined to the cavity. Negative ions
have the property that their electrons are loosely bound and they are thus suited
for parametrizing the repulsive potential.
The final result of different calibration calculations
:cite:`Bernhardsson:96a,Serrano:97b` is a penalty function which includes four
Gaussians. If :math:`a` is
the radius of the cavity the Gaussians are placed at distances :math:`a+2.0`,
:math:`a+3.0`, :math:`a+5.0` and :math:`a+7.0` |a0| from the cavity's center with
exponents 5.0, 3.5, 2.0 and 1.4, respectively.

.. index::
   single: DMABN

As an example we will use the N,N-dimethylaminobenzonitrile (DMABN) molecule
(see :numref:`fig:dmabn`).
This is a well known system with large dipole moments both in ground and
excited states which suffer important effects due to the polar environment.

.. figure:: dmabn.*
   :name: fig:dmabn
   :width: 50%
   :align: center

   N,N-dimethylaminobenzonitrile (DMABN)

.. extractfile:: advanced/RF.input

  &SEWARD &END
  Title
  para-DMABN molecule. Cavity size: 10 au.
  Symmetry
   X XY
  Basis set
  N.ANO-S...3s2p1d.
  N1             0.0000000000        0.0000000000        4.7847613288
  N2             0.0000000000        0.0000000000       -8.1106617786
  End of basis
  Basis set
  C.ANO-S...3s2p1d.
  C1             0.0000000000        0.0000000000        2.1618352923
  C2             0.0000000000        2.2430930886        0.7747833630
  C3             0.0000000000        2.2317547910       -1.8500321252
  C4             0.0000000000        0.0000000000       -3.1917306021
  C5             0.0000000000        0.0000000000       -5.9242601761
  C6             0.0000000000        2.4377336900        6.0640991723
  End of basis
  Basis set
  H.ANO-S...2s.
  H1             0.0000000000        4.0043085530       -2.8534714086
  H2             0.0000000000        4.0326542950        1.7215314260
  H3             0.0000000000        2.1467175630        8.0879851846
  H4             1.5779129980        3.6622699270        5.5104123361
  End of basis

  RF-Input
  reaction field
  38.8 10.0 4
  End of RF-Input

  Well Int
  4
  1.0 5.0 12.0
  1.0 3.5 13.0
  1.0 2.0 15.0
  1.0 1.4 17.0
  End of Input

  &SCF &END
  TITLE
   DMABN molecule
  OCCUPIED
  20 2 12 5
  ITERATIONS
  50
  END OF INPUT

  &RASSCF &END
  TITLE
   p-DMABN
  SYMMETRY
      1
  SPIN
      1
  NACTEL
     10    0    0
  FROZEN
      8    0    3    0
  INACTIVE
     12    1    9    1
  RAS2
      0    2    0    7
  THRS
  1.0E-06,1.0E-03,1.0E-03
  ITER
  50,25
  LUMORB
  END OF INPUT

.. index::
   single: Cavity

In the :program:`SEWARD` input the :kword:`WELL Integrals` must include
first the number of Gaussians used (four), followed by the
coefficient and exponent of the Gaussian and the radius of
the cavity in the sequence explained above: first the most
compact Gaussian with the radius plus 2.0 |a0|, and so on
to the least compact Gaussian.
Here, we have defined a cavity size of 10 |a0|
(cavity centered at coordinate origin). The RASSCF program will read
the RCTFLD input, prepared this time for acetonitrile
(:math:`\epsilon = 38.8`), a cavity size of 10.0 |a0| (the same
as in the SEWARD input) and a multipole expansion up to the fourth order
which is considered sufficient :cite:`Serrano:97b`.
The active space includes the :math:`\pi` space over
the molecular plane, excluding the :math:`\pi` orbital of the :math:`\ce{CN}`
group which lies in the molecular plane.

We repeat the calculation for different cavity sizes in order
to find the radius which gives the lowest absolute energy at the CASSCF
level. The presence of the repulsive terms allows the cavity
radius to be computed by energy minimization. For the calculations
using different cavity sizes it is not necessary to repeat the
calculation of all the integrals, just those related to the
well potential. Therefore, the keyword :kword:`ONEOnly` can be
included in the SEWARD input. The :file:`ONEINT` file will be modified
and the :file:`ORDINT` file is kept the same for each molecular
geometry. The energies obtained are in :numref:`tab:cav1`.

.. table:: Ground state CASSCF energies for DMABN with different cavity sizes.
   :name: tab:cav1

   ============= ======================
   Radius (|a0|) CASSCF energies (|Eh|)
   ============= ======================
   no cav.       |-|\455.653242
   10.0          |-|\455.645550
   11.0          |-|\455.653486
   12.0          |-|\455.654483
   14.0          |-|\455.654369
   16.0          |-|\455.654063
   ============= ======================

Taking the gas-phase value (no cav.) as the reference, the CASSCF
energy obtained with a 10.0 |a0| cavity radius is higher. This is an
effect of the repulsive potential, meaning that the molecule is too close to
the boundaries. Therefore we discard this value and use the values
from 11.0 to 16.0 to make a simple second order fit and obtain a
minimum for the cavity radius at 13.8 |a0|.

.. index::
   single: Cavity

Once we have this value we also need to optimize the position of the
molecule in the cavity. Some parts of the molecule, especially those
with more negative charge, tend to move close to the
boundary. Remember than the sphere representing the cavity has
its origin in the cartesian coordinates origin. We use the radius of
13.8 |a0| and compute the CASSCF energy at different displacements
along the coordinate axis. Fortunately enough, this molecule has
:math:`C_{2v}` symmetry. That means that displacements along two of the
axis (:math:`x` and :math:`y`) are restricted by symmetry. Therefore it is
necessary to analyze only the displacements along the :math:`z` coordinate.
In a less symmetric molecule all
the displacements should be studied even including combination of the displacements.
The result may even be a three dimensional net, although no
great accuracy is really required. The results for DMABN in |Ctv| symmetry are compiled
in :numref:`tab:cav2`.

.. table:: Ground state CASSCF energies for different translations with respect to the initial position of of the DMABN molecule in a 13.8 |a0| cavity.
   :name: tab:cav2

   ========================= ======================
   Disp. in :math:`z` (|a0|) CASSCF energies (|Eh|)
   ========================= ======================
   +0.5                      -455.654325
   0.0                       -455.654400
   |-|\0.5                   -455.654456
   |-|\1.0                   -455.654486
   |-|\1.5                   -455.654465
   ========================= ======================

Fitting these values to a curve we obtain an optimal displacement of |-|\1.0 |a0|. We move the
molecule and reoptimize the cavity radius at the new position of the
molecule. The results are listed in :numref:`tab:cav3`.

.. table:: Ground state CASSCF energies for DMABN with different cavity sizes. The molecule position in the cavity has been optimized.
   :name: tab:cav3

   ============= ======================
   Radius (|a0|) CASSCF energies (|Eh|)
   ============= ======================
   11.8          |-|\455.653367
   12.8          |-|\455.654478
   13.8          |-|\455.654486
   ============= ======================

There is no significant change. The cavity radius is then selected as 13.8 |a0| and the
position of the molecule with respect to the cavity is kept as in
the last calculation. The calculation is carried out with the new values.
The SCF or RASSCF outputs will contain the information about the
contributions to the solvation energy. The CASSCF energy obtained will
include the reaction field effects and an analysis of the
contribution to the solvation energy for each value of the multipole
expansion: ::

        Reaction field specifications:
        ------------------------------

         Dielectric Constant :                  .388E+02
         Radius of Cavity(au):                  .138E+02
         Truncation after    :                 4

        Multipole analysis of the contributions to the dielectric solvation energy

        --------------------------------------
           l             dE
        --------------------------------------
           0            .0000000
           1           -.0013597
           2           -.0001255
           3           -.0000265
           4           -.0000013
        --------------------------------------

.. Note: contains a nbsp

.. Comment: As long as this does not work correctly in the code we should not mention it here!

  .. index::
     single: Excited states
     single: Solvent; Excited states

  Solvent effects on excited states
  ---------------------------------

  As was explained above, the calculation of the solvent effects
  on excited states must be done in a different way.
  The inclusion of the solvent effects on the ground state of one molecule leads to
  a relaxation both for nuclei and electrons. It is considered to be in equilibrium
  with the environment. However, when an absorption or emission occurs, a dynamic process
  starts. It is usually considered that the new electronic distribution of the final
  state polarizes the solvent, which affects again in a different way the electronic part
  of the molecule than in the ground state case. This is considered to be a fast motion,
  where the equilibrium is achieved by solvent and solute electrons. The situation is not
  the same for nuclei. Slow motions are included in this case, and the nuclei do not
  achieve the equilibrium with solvent. These slow motions and the related
  interactions remain as in the ground state. Therefore, the calculations must be
  carried out using this sequence of steps:

  * A normal reaction field calculation is done for the ground state. However, we
    have included in the RASSCF input the keyword

    .. index::
       single: RASSCF
       single: RASSCF; HFRctFld
       single: Reaction field

    ::

      HFrctfld
      1 1 1.796

    The first number, one, indicates that this is a ground (or initial) state calculation
    and the slow part or the reaction field is stored in the file :file:`COMFILE`.
    The second number is the number of the computed root, one as we are interested in the
    ground state at this stage. The third number is the square of the refractive index of
    the solvent, also called the dielectric constant at high frequencies or optical value
    (from an approximate expression of the Clausius--Mossoti formulae). The RF-Input section in the
    integral input
    must be included also, as in the previous case: ::

      &SEWARD &END
      ...
      ...
      RF-Input
      reaction field
      38.8 13.8 4
      end of RF-Input
      ...
      ...
      End of Input

  * .. compound::

      The RASSCF program will store in the communications file, :file:`COMFILE`,
      not only the full reaction field of the computed state (ground state in this case),
      but also the slow component of the reaction field.
      The partitioning of the reaction field is performed for each individual :math:`2^l`\-pole
      component. The slow part is calculated for the ground state wave function
      as the (:math:`c_l-c_l^\infty/c_l`) fraction of the reaction field,
      where :math:`c_l` is the reaction field factor

      .. math:: c_l = -\frac{l!(l+1)(\epsilon-1)}{(l+1)\epsilon+l}\frac{1}{a^{2l+1}},

      :math:`c_l^\infty` is the reaction field
      factor using :math:`\epsilon^\infty\approx n^2`, :math:`n` is the refraction
      index for some suitable frequency in the infrared or visible range,
      and :math:`M_l^m` is the component :math:`m` of a :math:`2^l`\-pole moment of order :math:`l`.
      This value, :math:`F_{l,\text{slow}}^m`, is stored in the communications
      file together with the corresponding
      self-energy used to create the cavity. These fields in the :file:`COMFILE` file
      will not be replaced until we perform another RASSCF calculation using the
      same :file:`COMFILE` and the first value in the keyword :kword:`HFRCtfld`
      set to one.

  * .. compound::

      The RASSCF input for the excited state must contain ::

        HFrctfld
        0 2 1.796

      where the zero indicates this is an excited state calculation, the two is the
      number of the computed root, and 1.796 the square of the refractive index of the solvent.
      The same RCTFLD namelist is used as before.

    The total reaction field of the excited state will be added to the :file:`COMFILE` file,
    which can be then used as a perturbation on other program for that particular excited state.
    The slow part of the reaction field of the initial state remains in the :file:`COMFILE`.

    .. index::
       single: Option; RFPert

  * Once the RASSCF calculation is finished one can use other programs such as MRCI
    or CASPT2 where the CASSCF reaction field is introduced as a perturbation by
    including the :kword:`RFPErt` in their inputs (in the MOTRA input for MRCI).

  Remember, however, that each time an SCF or RASSCF calculation is done the
  resulting total reaction field is stored in the communications file (:file:`COMFILE`).
  Therefore, one must control which file is being used. The following is an easy sequence
  for the calculations: ::

    &SEWARD &END
    Title
    para-DMABN molecule. Cavity size: 13.8 au.
    Symmetry
     X XY
    Basis set
    N.ANO-S...3s2p1d.
    N1             0.0000000000        0.0000000000        3.7847613288
    N2             0.0000000000        0.0000000000       -9.1106617786
    End of basis
    Basis set
    C.ANO-S...3s2p1d.
    C1             0.0000000000        0.0000000000        1.1618352923
    C2             0.0000000000        2.2430930886       -0.2252166370
    C3             0.0000000000        2.2317547910       -2.8500321252
    C4             0.0000000000        0.0000000000       -4.1917306021
    C5             0.0000000000        0.0000000000       -6.9242601761
    C6             0.0000000000        2.4377336900        5.0640991723
    End of basis
    Basis set
    H.ANO-S...2s.
    H1             0.0000000000        4.0043085530       -3.8534714086
    H2             0.0000000000        4.0326542950        0.7215314260
    H3             0.0000000000        2.1467175630        7.0879851846
    H4             1.5779129980        3.6622699270        4.5104123361
    End of basis

    RF-Input
    reaction field
    38.8 13.8 4
    End of RF-Input

    Well Int
    4
    1.0 5.0 15.8
    1.0 3.5 16.8
    1.0 2.0 18.8
    1.0 1.4 20.8
    End of Input

    &SCF &END
    TITLE
     DMABN molecule
    OCCUPIED
    20 2 12 5
    ITERATIONS
    50
    END OF INPUT

    &RASSCF &END
    TITLE
     p-DMABN
    SYMMETRY
        1
    SPIN
        1
    NACTEL
       10    0    0
    FROZEN
        8    0    3    0
    INACTIVE
       12    1    9    1
    RAS2
        0    2    0    7
    THRS
    1.0E-06,1.0E-03,1.0E-03
    ITER
    50,25
    LUMORB
    HFRCtfld
    1 1 1.796
    END OF INPUT

    &CASPT2 &END
    Title
     Solvent
    Maxit
    20
    Lroot
    1
    RFPert
    End of Input

    &RASSCF &END
    TITLE
     p-DMABN
    SYMMETRY
        1
    SPIN
        1
    NACTEL
       10    0    0
    FROZEN
        8    0    3    0
    INACTIVE
       12    1    9    1
    RAS2
        0    2    0    7
    THRS
    1.0E-06,1.0E-03,1.0E-03
    CIROot
    1 2
    2
    Iterations
    50,25
    LumOrb
    Hfrctfld
    0 2 1.796
    End of Input

    &CASPT2 &END
    Title
     Solvent
    Maxit
    20
    Lroot
    2
    RFPert
    End of Input

  This sequence of calculations is correct because we perform
  the CASPT2 calculations immediately after the RASSCF calculations
  for each root. They will not be correct if we first compute the
  two RASSCF states and then the two CASPT2 corrections, because
  in the :file:`COMFILE` file the reaction field stored would be
  that from the last RASSCF calculation. The safer way is to save
  explicitly the :file:`COMFILE` file each time.

  One additional problem that can occur in excited state calculations
  is that the :program:`RASSCF` program does not converge easily for single root
  calculations. One may have to do a state-average CASSCF calculation.
  The program can compute the reaction field in average calculations
  because at each iteration it takes the density matrix of the root
  we specify under the keyword :kword:`Hfrctfld` to compute the reaction
  field, although the optimized density matrix is the averaged one.
  As this is only an approximation, the recommended procedure is to
  increase as much as possible the weight of the computed state
  in the average procedure. For instance, for the :math:`2^1A_1` state
  in DMABN the RASSCF input could be: ::

    &RASSCF &END
    TITLE
     p-DMABN molecule. 21A1 averaged state.
    SYMMETRY
        1
    SPIN
        1
    NACTEL
       10    0    0
    FROZEN
        8    0    3    0
    INACTIVE
       12    1    9    1
    RAS2
        0    2    0    7
    CIROOT
    2 2
    1 2
    1 9
    LEVSHFT
    0.5
    ITER
    50,25
    CIMX
    25
    LUMORB
    HFRctFld
    0 2 1.801
    END OF INPUT

  The experimental and theoretical excitation energies, and computed
  dipole moments for the ground state (GS) and :math:`\pi\to\pi^*` :math:`2^1A_1`
  state of DMABN in different media are shown in :numref:`tab:dmabn`
  (see ref. :cite:`Serrano:97b`):

  .. index::
     single: Excited states; DMABN
     single: Excited states; Solvent effects

  .. table:: Excitation energies and dipole moments for the
             :math:`2^1A_1` state of DMABN in different media.
     :name: tab:dmabn

     ===================================== =========================== =========================== =========================== ===========================
     Solvent                               PT2 (eV)                    Exp (eV)                    :math:`\mu_{\text{GS}}` (D) :math:`\mu_{\text{ES}}` (D)
     ===================================== =========================== =========================== =========================== ===========================
     Gas phase                             4.41                        ---                         6.6                         14.2
     Cyclohexane   (:math:`\epsilon=4.30`) 4.38                        4.4                         6.7                         14.6
     Butylchloride (:math:`\epsilon=9.65`) 4.32                        4.3                         6.9                         15.1
     Acetonitrile  (:math:`\epsilon=38.8`) 4.31                        4.2                         7.0                         15.2
     ===================================== =========================== =========================== =========================== ===========================

  The large radius of the cavity and the empty space within the cavity
  lead to a clear underestimation of the solvent effects. In this case
  however the model accounts for the most important aspects of the
  interaction.

  We now consider a difficult case. We want to compute both :math:`\pi\pi^*` and
  :math:`n\pi^*` excited states in DMABN and we want to use different active
  spaces in each case. For the :math:`\pi\pi^*` states (:math:`2^1A_1` and :math:`1^1B_2`)
  we use a (0207) space (|ao|\ |at|\ |bt|\ |bo|) with 10 active electrons and for the :math:`n\pi^*`
  states (:math:`1^1A_2` and :math:`1^1B_1`)
  a (1207) active space with 12 active electrons. This means we need
  two different ground state calculations. In principle we could re-optimize
  the cavity size for the new ground state but this is going to be a very
  minor effect. The following is a Korn shell script designed to do the
  explained calculations.

  .. index::
     single: Shell script

  ::

    #!/bin/ksh
    ################################################################################
    export Project=DMABN
    export Solvent=ACN
    export HomeDir=/u/$LOGNAME/$Project
    export TempDir=/temp/$LOGNAME
    export WorkDir=$TempDir/$RANDOM
    mkdir $WorkDir
    cd $WorkDir
    ln -fs  $TempDir/$Project.OrdInt ORDINT
    ln -fs  $TempDir/$Project.OneInt.$Solvent ONEINT
    #------------------------------------------------------------------------------#
    # Compute integrals                                                            #
    #------------------------------------------------------------------------------#
    molcas run seward $HomeDir/seward.$Project.$Solvent.input
    #------------------------------------------------------------------------------#
    # Compute RHF-SCF wavefunction                                                 #
    #------------------------------------------------------------------------------#
    ln -fs  $TempDir/$Project.$Solvent.ScfOrb SCFORB
    molcas run scf $HomeDir/scf.$Project.input
    rm SCFORB
    #------------------------------------------------------------------------------#
    # Compute CASSCF state functions and CASPT2 energy corrections for the state   #
    #------------------------------------------------------------------------------#
    #
    #------------------------------------------------------------------------------#
    # Ground State CASSCF and CASPT2 calculations                                  #
    #------------------------------------------------------------------------------#
    Name_list='11A1_pipi 11A1_npi'
    for Name in $Name_list;
    do
      ln -fs  $TempDir/$Project.$Solvent.ScfOrb                INPORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.RasOrb          RASORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile         COMFILE
      molcas run rasscf $HomeDir/rasscf.$Name.$Solvent.input
      molcas run caspt2 $HomeDir/caspt2.rfpert.1.input
      rm RASORB
      rm INPORB
      rm JOBIPH
      rm COMFILE
    done
    #------------------------------------------------------------------------------#
    # Excited States CASSCF calculations                                           #
    #------------------------------------------------------------------------------#
    Name_list='21A1 11B2'
    for Name in $Name_list;
    do
      #----------------------------------------------------------------#
      #  Changing the name of the COMFILE                              #
      #----------------------------------------------------------------#
      cp $Project.11A1_pipi.$Solvent.ComFile $Project.$Name.$Solvent.ComFile
      #----------------------------------------------------------------#
      ln -fs  $TempDir/$Project.11A1.$Solvent.RasOrb           INPORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.RasOrb          RASORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile         COMFILE
      molcas run rasscf $HomeDir/rasscfs.$Name.$Solvent.input
      rm RASORB
      rm INPORB
      rm JOBIPH
      rm COMFILE
    done
    Name_list='11A2 11B1'
    for Name in $Name_list;
    do
      #----------------------------------------------------------------#
      #  Changing the name of the COMFILE                              #
      #----------------------------------------------------------------#
      cp $Project.11A1_npi.$Solvent.ComFile $Project.$Name.$Solvent.ComFile
      #----------------------------------------------------------------#
      ln -fs  $TempDir/$Project.11A1.$Solvent.RasOrb           INPORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.RasOrb          RASORB
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile         COMFILE
      molcas run rasscf $HomeDir/rasscfs.$Name.$Solvent.input
      rm RASORB
      rm INPORB
      rm JOBIPH
      rm COMFILE
    done
    #------------------------------------------------------------------------------#
    # Excited States CASPT2 calculations                                           #
    #------------------------------------------------------------------------------#
    Name_list='21A1'
    for Name in $Name_list;
    do
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile        COMFILE
      molcas run caspt2 $HomeDir/caspt2.rfpert.2.input
      rm JOBIPH
      rm COMFILE
    done
    Name_list='11B2'
    for Name in $Name_list;
    do
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile        COMFILE
      molcas run caspt2 $HomeDir/caspt2.rfpert.1.input
      rm JOBIPH
      rm COMFILE
    done
    Name_list='11A2 11B1'
    for Name in $Name_list;
    do
      ln -fs  $TempDir/$Project.$Name.$Solvent.JobIph          JOBIPH
      ln -fs  $TempDir/$Project.$Name.$Solvent.ComFile        COMFILE
      molcas run caspt2 $HomeDir/caspt2.rfpert.1.input
      rm JOBIPH
      rm COMFILE
    done
    #------------------------------------------------------------------------------#
    cd $TempDir
    rm -r $WorkDir
    exit

.. index::
   single: SEWARD; OneOnly

Notice that the two-electron integral file is the same
independent of the cavity size, well integrals
used or translational movement of the molecule.
Therefore, if the well parameters are
changed only the one-electron integral file :file:`ONEINT` need to be
recomputed using the option :kword:`ONEOnly` in the SEWARD
input. In the previous script we have named the :file:`ONEINT`
as :file:`$Project.OneInt.$Solvent`, but not because it depends on
the solvent but on the cavity radius which should be different
for each solvent when the well potential is used.

.. index::
   single: Solvent
   single: PCM

Solvation effects in ground states. PCM model in formaldehyde
-------------------------------------------------------------

The reaction field parameters are added to the
:program:`SEWARD` program input through the keyword ::

  RF-Input

.. compound::

  To invoke the PCM model the keyword ::

    PCM-model

  is required. A possible input is ::

    RF-input
    PCM-model
    solvent
    acetone
    AAre
    0.2
    End of rf-input

  which requests a PCM calculation with acetone as solvent, with tesserae
  of average area 0.2 Å\ |2|. Note that the default parameters are
  solvent = water, average area 0.4 Å\ |2|; see the :program:`SEWARD`
  manual section for further PCM keywords. By default the PCM adds
  non-electrostatic terms (i.e. cavity formation energy, and dispersion
  and repulsion solute-solvent interactions) to the computed free-energy
  in solution.

A complete input for a ground state CASPT2 calculation on formaldehyde
(:math:`\ce{H2CO}`) in water is

.. extractfile:: advanced/CASPT2.RF.input

  &GATEWAY
  Title
  formaldehyde
  Coord
  4

  H      0.000000    0.924258   -1.100293    Angstrom
  H      0.000000   -0.924258   -1.100293    Angstrom
  C      0.000000    0.000000   -0.519589    Angstrom
  O      0.000000    0.000000    0.664765    Angstrom
  Basis set
   6-31G*
  Group
   X Y
  RF-input
  PCM-model
  solvent
  water
  end of rf-input
  End of input

  &SEWARD
  End of input

  &SCF
  Title
  formaldehyde
  Occupied
  5 1 2 0
  End of input

  &RASSCF
  Title
  formaldehyde
  nActEl
  4 0 0
  Inactive
  4 0 2 0
  Ras2
  1 2 0 0
  LumOrb
  End of input

  &CASPT2
  Frozen
  4  0  0  0
  RFPErt
  End of input

.. Originally written by Francesco Aquilante

Solvation effects in excited states. PCM model and acrolein
-----------------------------------------------------------

.. compound::

  In the PCM picture, the solvent reaction field is
  expressed in terms of a polarization charge density :math:`\sigma(\vec{s})` spread
  on the cavity surface, which, in the most recent version of the method,
  depends on the electrostatic potential
  :math:`V(\vec{s})` generated by the solute on the cavity according to

  .. _PCM:

  .. math:: \left[ \frac{\epsilon+1}{\epsilon-1} \hat{S}
            -\frac{1}{2\pi}\hat{S}\hat{D}^* \right]
            \sigma(\vec{s}) =
            \left[ - 1 + \frac{1}{2\pi} \hat{D}\right] V(\vec{s})

  where :math:`\epsilon` is the solvent dielectric constant and
  :math:`V(\vec{s})` is the (electronic+nuclear) solute potential at point
  :math:`\vec{s}` on the cavity surface.
  The :math:`\hat{S}` and :math:`\hat{D}^*` operators are related respectively to
  the electrostatic potential :math:`V^\sigma({\vec{s}})`
  and to the normal component of the
  electric field :math:`E_\perp^\sigma(\vec{s})`
  generated by the surface charge density :math:`\sigma(\vec{s})`.
  It is noteworthy that in this PCM formulation the polarization charge
  density :math:`\sigma(\vec{s})` is designed to take into account implicitly
  the effects of the fraction of solute electronic density lying outside the
  cavity.

In the computational practice, the surface charge distribution
:math:`\sigma(\vec{s})` is expressed in terms of a set of point charges `\vec{q}` placed
at the center of each surface tessera, so that operators are replaced by the
corresponding square matrices.
Once the solvation charges (:math:`\vec{q}`) have been determined,
they can be used to compute energies and properties in solution.

.. compound::

  The interaction energy between the solute and the solvation charges
  can be written

  .. math:: E_{\text{int}} = \mat{V}^{\text{T}} \vec{q} = \sum_i^{N_{\text{TS}}} V_i q_i

  where :math:`V_i` is the solute potential calculated at the representative point
  of tessera :math:`i`. The charges act as
  perturbations on the solute electron density :math:`\rho`: since the charges
  depend in turn on :math:`\rho` through the electrostatic potential, the solute
  density and the charges must be adjusted until self consistency.
  It can be shown :cite:`Tomasi:94` that for any SCF procedure including a
  perturbation linearly depending on the electron density,
  the quantity that is variationally minimized corresponds to a free energy
  (i.e. :math:`E_{\text{int}}` minus the work spent to polarize the dielectric and to create
  the charges).
  If :math:`E^0=E[\rho^0] + V_{\text{NN}}` is the solute energy in vacuo, the free energy
  minimized in solution is

  .. math:: G = E[\rho] + V_{\text{NN}} + \frac{1}{2} E_{\text{int}}

  where :math:`V_{\text{NN}}` is the solute nuclear repulsion energy, :math:`\rho^0` is the
  solute electronic density for the isolated molecule, and :math:`\rho` is the
  density perturbed by the solvent.

The inclusion of non-equilibrium solvation effects, like those
occurring during electronic excitations, is introduced in the model by
splitting the solvation charge on each surface element into
two components: :math:`q_{i,\text{f}}` is the charge due to electronic (fast) component
of solvent polarization, in equilibrium with the solute electronic density
upon excitations, and :math:`q_{i,\text{s}}`, the charge arising from the orientational
(slow) part, which is delayed when the solute undergoes a sudden transformation.

The photophysics and photochemistry of
acrolein are mainly controlled by the relative position of the
:math:`^1(n\to\pi^*)`, :math:`^3(n\to\pi^*)` and :math:`^3(\pi\to\pi^*)` states, which is,
in turn, very sensitive to the presence and the nature of the solvent.
We choose this molecule in order to show an example of how to
use the PCM model in a CASPT2 calculation of vertical excitation
energies.

The three states we want to compute are low-lying singlet
and triplet excited states of the *s-trans* isomer.
The :math:`\pi` space (4 :math:`\pi` MOs, 4 :math:`\pi`\-electrons)
with the inclusion of the lone-pair MO (:math:`n_y`) is a suitable choice
for the active space in this calculation.
For the calculation in aqueous solution, we need first to compute the CASPT2
energy of the ground state in presence of the solvent water.
This is done by including in the :program:`SEWARD` input for the corresponding gas-phase
calculation the section ::

  RF-input

  PCM-model
  solvent
   water
  DIELectric constant
   78.39
  CONDuctor version
  AARE
   0.4

  End of rf-input

If not specified, the default solvent is chosen to be water.
Some options are available. The value of the dielectric constant
can be changed for calculations at temperatures other than 298 K.
For calculations in polar solvents like water, the use of the conductor
model (C-PCM) is recommended.
This is an approximation that employs conductor rather than dielectric
boundary conditions. It works very well for polar solvents
(i.e. dielectric constant greater than about 5), and is based
on a simpler and more robust implementation. It can be useful also in cases when
the dielectric model shows some convergence problems.
Another parameter that can be varied in presence of convergency problem
is the average area of the tesserae of which the surface of the cavity is composed.
However, a lower value for this parameter may give poorer results.

Specific keywords are in general needed for the other modules to work with PCM, except for
the SCF. The keyword :kword:`NONEquilibrium` is
necessary when computing excited states energies in :program:`RASSCF`.
For a state specific calculation of the ground state CASSCF energy, the solvent effects
must be computed with an equilibrium solvation approach, so this keyword must be omitted.
None the less, the keyword :kword:`RFpert` must be included in the CASPT2 input
in order to add
the reaction field effects to the one-electron Hamiltonian as a constant perturbation. ::

  &RASSCF &END
  Title
  Acrolein GS + PCM
  Spin
   1
  Symmetry
   1
  nActEl
   6 0 0
  Frozen
   4 0
  Inactive
   8 0
  Ras2
   1 4
  LUMORB
  THRS
  1.0e-06 1.0e-04 1.0e-04
  ITERation
   100 100
  End of input

  &CASPT2 &END
  Title
   ground state + PCM
  RFpert
  End of Input

Information about the reaction field calculation employing
a PCM-model appear first in the SCF output ::

  Polarizable Continuum Model (PCM) activated
  Solvent:water
  Version: Conductor
  Average area for surface element on the cavity boundary: 0.4000 Angstrom2
  Minimum radius for added spheres: 0.2000 Angstrom



  Polarized Continuum Model Cavity
  ================================

   Nord Group  Hybr  Charge Alpha Radius          Bonded to
     1   O     sp2   0.00   1.20  1.590   C   [d]
     2   CH    sp2   0.00   1.20  1.815   O   [d]  C   [s]
     3   CH    sp2   0.00   1.20  1.815   C   [s]  C   [d]
     4   CH2   sp2   0.00   1.20  2.040   C   [d]
   ------------------------------------------------------------------------------

The following input is used for the CASPT2 calculation of the :math:`^3A''(n\to\pi^*)` state.
Provided that the same $WorkDir has been using, which contains all the files of of the
calculation done for the ground state, the excited state calculation is done
by using inputs for the :program:`RASSCF`
and the :program:`CASPT2` calculations: ::

  &RASSCF &END
  Title
  Acrolein n->pi* triplet state + PCM
  Spin
   3
  Symmetry
   2
  nActEl
   6 0 0
  Frozen
   4 0
  Inactive
   8 0
  Ras2
   1 4
  NONEquilibrium
  LUMORB
  ITERation
   100 100
  End of input

  &CASPT2 &END
  Title
   triplet state
  RFpert
  End of Input

Note the :program:`RASSCF` keyword NONEQ, requiring that the slow part of the reaction
field be frozen as in the ground state, while the fast part is
equilibrated to the new electronic distribution. In this case the fast
dielectric constant is the square of the refraction index, whose value
is tabulated for all the allowed solvents (anyway, it can be modified by
the user through the keyword :kword:`DIELectric` in :program:`SEWARD`).

The :program:`RASSCF` output include the line: ::

  Calculation type: non-equilibrium (slow component from JobOld)

   Reaction field from state:            1

This piece of information means that the program computes the solvent
effects on the energy of the :math:`^3A''(n\to\pi^*)`
by using a non-equilibrium approach.
The slow component of the solvent response is kept frozen in terms of the charges
that have been computed for the previous equilibrium calculation of
the ground state. The remaining part of the solvent response,
due to the fast charges, is instead computed self-consistently for the
state of interest (which is state 1 of the specified spatial and spin symmetry in this case).

The vertical excitations to the lowest valence states
in aqueous solution for *s-trans* acrolein are
listed in the :numref:`tab:acrol-water` and compared
with experimental data.
As expected by qualitative reasoning, the vertical excitation energy to the
:math:`^1A''(n\to\pi^*)` state exhibits a blue shift in water.
The value of the vertical transition energy computed with the inclusion of the
PCM reaction field is computed to be 3.96 eV at the CASPT2 level of theory.
The solvatochromic shift is thus of +0.33 eV.
Experimental data are available for the
excitation energy to the :math:`^1A''(n\to\pi^*)` state. The band shift in
going from isooctane to water is reported to be +0.24 eV which is in fair
agreement with the PCM result.

No experimental data are available for the excitation energies to the triplet
states of acrolein in aqueous solution. However it is of interest to see how
the ordering of these two states depends on solvent effects.
The opposing solvatochromic shifts produced by the solvent on these two electronic transitions
place the two triplet states closer in energy.
This result might suggest that a dynamical interconversion between
the :math:`n\pi^*` and :math:`\pi\pi^*` may occur more favorable in solution.

.. table:: Vertical excitation energies/eV (solvatochromic shifts)
           of *s-trans* acrolein in gas-phase and in aqueous solution.
   :name: tab:acrol-water

   ====================================== =================== =================== ===================
   State                                  Gas-phase           Water               Expt.\ [#a]_
   ====================================== =================== =================== ===================
   :math:`^1A''(n_y\to\pi^*)`             3.63                3.96 (+0.33)        3.94 (+0.24)\ [#b]_
   :math:`T_1` :math:`^3A''(n_y\to\pi^*)` 3.39                3.45 (+0.06)
   :math:`T_2` :math:`^3A'(\pi\to\pi^*)`  3.81                3.71 (\ |-|\0.10)
   ====================================== =================== =================== ===================

.. [#a] Ref. :cite:`Forbes:59`
.. [#b] Solvatochromic shifts derived by comparison of the
        absorption wave lengths in water and isooctane
Advanced Examples and Annexes
=============================

.. toctree::
   :maxdepth: 2

   examples
   annexes
.. index::
   single: Reaction path
   single: PES
   single: Transition state
   single: IRC
   single: Intrinsic reaction coordinate
   single: Optimization; Transition state

.. _TUT\:sec\:path:

Computing a reaction path
=========================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Chemists are familiarized with the description of a chemical
reaction as a continuous motion on certain path of the
potential energy hypersurfaces connecting reactants with
products. Those are considered minima in the hypersurface
while an intermediate state known as the transition state
would be a saddle point of higher energy. The height of the
energy barrier separating reactants from products relates
to the overall rate of reaction, the positions of the
minima along the reaction coordinate give the equilibrium
geometries of the species, and the relative energies relate
to the thermodynamics of the process. All this is known
as transition state theory.

The process to study a chemical reaction starts by obtaining
proper geometries for reactants and products, follows by finding the
position of the transition state, and finishes by computing
as accurately as possible the relative energies relating the
position of the species. To perform geometry optimizations
searching for true minima in the potential energy surfaces (PES)
is by now a well-established procedure (see :numref:`TUT:sec:optim`).
An stationary point in the PES is characterized by having all the
first derivatives of the energy with respect to each one of the
independent coordinates equal to zero and the second derivatives
larger than zero. First-order saddle points, on the contrary, have their
second derivatives lower than zero for one coordinate,
that is, they are maxima along this coordinate. A
transition state is defined as a saddle point having only
one negative second derivative along the specific coordinate
known as the reaction coordinate. To simplify the treatment a special
set of coordinates known as normal coordinates is defined
in a way that the matrix of second derivatives is diagonal.
A transition state will have one negative value in the
diagonal of such a matrix.

Finally once the reactant, product and transition state geometries have been established one
could perform a Intrinsic Reaction Coordinate (IRC) analysis. This to find the energy profile
of the reaction and also to establish that the found transition state is connected to the
reactant and the product.

.. index::
   single: Transition state

Studying a reaction
-------------------

The localization of the transition state of a reaction is of importance
in both a qualitative and quantitative description of the reaction mechanism and
the thermodynamics of a reaction.
In the following example we will locate the
transition state of the proton transfer reaction between the two species
in :numref:`Figures %s <fig:job0>` and :numref:`%s <fig:job5>`.
The example selected here is chosen
to demonstrate the steps needed to find a transition state. For that sake we have
limited our model to the SCF level of theory.

.. figure:: job0.*
   :name: fig:job0
   :width: 50%
   :align: center

   Reactant

.. figure:: job5.*
   :name: fig:job5
   :width: 50%
   :align: center

   Product

Reactant and product
....................

.. compound::

  The first step is to establish the two species in equilibrium. These calculations
  would constitute standard geometry optimizations with the input for the reactant

  .. extractfile:: advanced/OPT.reactant.input

    >>> Do while <<<

    &Seward

    Basis set
    C.cc-pVDZ....
    C1            -1.9385577715        0.0976565175        0.4007212526
    C2            -2.4151209200       -0.0592579424        2.8519334864
    C3             0.7343463765        0.0088689871       -0.7477660837
    End of Basis
    Basis set
    H.cc-pVDZ....
    H1            -4.3244501026        0.0091320829        3.6086029352
    H2            -0.8591520071       -0.2642180524        4.1663142585
    H3            -3.4743702487        0.3026128386       -0.9501874771
    End of Basis
    Basis set
    O.cc-pVDZ....
    O1             0.7692102769        0.1847569555       -3.0700425345
    O2             2.4916838932       -0.2232135341        0.7607580753
    End of Basis
    End of input

    >>> IF ( ITER = 1 ) <<<
    &SCF
    Core
    Charge = -1
    >>> ENDIF <<<
    &SCF &End
    LUMORB
    Charge = -1

    &Slapaf
    Iterations = 20
    >>> EndDo <<<

  resulting in the following convergence pattern ::

                          Energy     Grad     Grad          Step           Estimated  Hessian Geom Hessian
    Iter     Energy       Change     Norm      Max  Element  Max  Element  Final Energy Index Update Update

     1   -265.09033194 0.00000000 0.091418 0.044965 nrc003 0.069275  nrc003 -265.09529138  0  RF(S)   None
     2   -265.09646330-0.00613136 0.020358 0.008890 nrc003 0.040393  nrc008 -265.09684474  0  RF(S)   BFGS
     3   -265.09693242-0.00046912 0.011611-0.005191 nrc001 0.079285  nrc016 -265.09709856  0  RF(S)   BFGS
     4   -265.09655626 0.00037616 0.020775-0.010792 nrc016-0.070551  nrc016 -265.09706324  0  RF(S)   BFGS
     5   -265.09706308-0.00050682 0.003309-0.001628 nrc003-0.010263  nrc017 -265.09707265  0  RF(S)   BFGS
     6   -265.09707056-0.00000747 0.000958-0.000450 nrc011 0.017307  nrc017 -265.09707924  0  RF(S)   BFGS
     7   -265.09706612 0.00000444 0.002451 0.001148 nrc003-0.011228  nrc018 -265.09706837  0  RF(S)   BFGS
     8   -265.09707550-0.00000938 0.000516 0.000220 nrc001-0.004017  nrc014 -265.09707591  0  RF(S)   BFGS
     9   -265.09707586-0.00000036 0.000286 0.000104 nrc001 0.002132  nrc017 -265.09707604  0  RF(S)   BFGS

  .. Note: contains a nbsp

  and for the product the input

  .. extractfile:: advanced/OPT.product.input

    >>> Do while <<<

    &Seward

    Basis set
    C.cc-pVDZ....
    C1            -2.0983667072        0.1000525724        0.5196668948
    C2            -2.1177298783       -0.0920244467        3.0450747772
    C3             0.5639781563        0.0024463770       -0.5245225314
    End of Basis
    Basis set
    H.cc-pVDZ....
    H1            -3.8870548756       -0.0558560582        4.1138131865
    H2            -0.4133953535       -0.2946498869        4.2050068095
    H3            -1.3495534119        0.3499572533       -3.3741881412
    End of Basis
    Basis set
    O.cc-pVDZ....
    O1             0.5100106099        0.2023808294       -3.0720173949
    O2             2.5859515474       -0.2102046338        0.4795705925
    End of Basis
    End of input

    >>> IF ( ITER = 1 ) <<<
    &SCF
    Core
    Charge = -1
    >>> ENDIF <<<
    &SCF
    LUMORB
    Charge = -1

    &Slapaf
    Iterations = 20
    >>> EndDo <<<

  resulting in the following convergence pattern ::

                          Energy     Grad     Grad          Step           Estimated  Hessian Geom Hessian
    Iter     Energy       Change     Norm      Max  Element  Max  Element  Final Energy Index Update Update

     1   -265.02789209 0.00000000 0.062885-0.035740 nrc006-0.060778  nrc006 -265.02939600  0  RF(S)   None
     2   -265.02988181-0.00198972 0.018235-0.011496 nrc006-0.023664  nrc006 -265.03004886  0  RF(S)   BFGS
     3   -265.03005329-0.00017148 0.001631-0.000978 nrc009-0.015100  nrc017 -265.03006082  0  RF(S)   BFGS
     4   -265.03004953 0.00000376 0.002464-0.000896 nrc014 0.013752  nrc017 -265.03006022  0  RF(S)   BFGS
     5   -265.03006818-0.00001865 0.001059 0.000453 nrc013-0.007550  nrc014 -265.03007064  0  RF(S)   BFGS
     6   -265.03006524 0.00000294 0.001800 0.000778 nrc014 0.006710  nrc014 -265.03007032  0  RF(S)   BFGS
     7   -265.03006989-0.00000465 0.000381 0.000190 nrc005 0.003078  nrc016 -265.03007014  0  RF(S)   BFGS
     8   -265.03006997-0.00000008 0.000129-0.000094 nrc016-0.001305  nrc017 -265.03007003  0  RF(S)   BFGS

.. Note: contains a nsbp

The computed reaction energy is estimated to about 42 kcal/mol at this level of theory.

Transition state optimization
.............................

To locate the transition state it is important to identify the reaction coordinate.
In our case here we note that the significant reaction coordinates are the bond distances between C1
and H3, and O1 and H3. In the location of the transition state we
will start from the geometry of the reactant for which the :math:`\ce{O{1}-H{3}}` bond distance is
2.51 Å. We will conduct the search in a number of constrained geometry
optimizations in which we step by step reduce the :math:`\ce{O{1}-H{3}}` distance towards the distance
in the product of 0.95 Å. The selected series is 2.0, 1.5, 1.3, and
1.0 Å.
To constraint the :math:`\ce{O{1}-H{3}}` bond distance we modify the input to the
:program:`GATEWAY` moduel by adding the following: ::

  Constraint
  R1 = Bond H3 O1
  Value
  R1 = 2.0 Angstrom
  End of Constraint

The :program:`SLAPAF` module's associated input looks like: ::

  &Slapaf &End
  Iterations
  20
  FindTS
  PRFC
  End of Input

This will correspond to the input for the first of the series of constraint
geometry optimization. However, note the keyword FindTS. This
keyword will make the SLAPAF module switch from a constrained geometry optimization
to a transition state geometry optimization if the updated geometrical
Hessian contains one negative eigenvalue. It is of course our hope that during the
series of constrained geometry optimizations that we will run into
this situation and find the transition state. The convergence pattern for the first
constrained optimization is ::

                        Energy     Grad     Grad          Step           Estimated  Hessian Geom Hessian
  Iter     Energy       Change     Norm      Max  Element  Max  Element  Final Energy Index Update Update

   1   -265.09707600 0.00000000 0.965614 0.965614 Cns001 0.230366* nrc009 -265.07671229  0  MFRFS   None
   2   -265.08759913 0.00947687 0.216939 0.214768 Cns001 0.081441  nrc012 -265.08946379  0  MFRFS   MSP
   3   -265.08218288 0.00541624 0.014770 0.007032 nrc010 0.019690  nrc010 -265.08242668  0  MFRFS   MSP
   4   -265.08251826-0.00033537 0.003644-0.001560 nrc003 0.005075  nrc002 -265.08254163  0  MFRFS   MSP
   5   -265.08254834-0.00003008 0.001274-0.000907 nrc012 0.026237! nrc016 -265.08257455  0  MFRFS   MSP
   6   -265.08251413 0.00003421 0.003036-0.002420 nrc016-0.024325  nrc016 -265.08254699  0  MFRFS   MSP
   7   -265.08254682-0.00003269 0.000837-0.000426 nrc012 0.012351  nrc017 -265.08255083  0  MFRFS   MSP
   8   -265.08255298-0.00000616 0.000470 0.000238 nrc016-0.005376  nrc017 -265.08255421  0  MFRFS   MSP
   9   -265.08255337-0.00000038 0.000329-0.000154 nrc012-0.004581  nrc014 -265.08255409  0  MFRFS   MSP
  10   -265.08255418-0.00000081 0.000206-0.000148 nrc012-0.000886  nrc014 -265.08255425  0  MFRFS   MSP
  11   -265.08255430-0.00000013 0.000123-0.000097 nrc012-0.001131  nrc014 -265.08255436  0  MFRFS   MSP

.. Note: contains a nbsp

Here we note that the Hessian index is zero, i.e. the optimization is a constrained
geometry optimization. The final structure is used as the starting geometry for
the 2nd constrained optimization at 1.5 Å. This optimization did not find a negative
eigenvalue either. However, starting the 3rd constrained optimization from the final
structure of the 2nd constrained optimization resulted in the convergence pattern ::

                        Energy     Grad     Grad          Step           Estimated  Hessian Geom Hessian
  Iter     Energy       Change     Norm      Max  Element  Max  Element  Final Energy Index Update Update

   1   -265.03250948 0.00000000 0.384120 0.377945 Cns001-0.209028* nrc007 -264.99837542 0  MFRFS   None
   2   -265.01103140 0.02147809 0.120709 0.116546 Cns001-0.135181  nrc007 -265.01209656 0  MFRFS   MSP
   3   -265.00341440 0.00761699 0.121043-0.055983 nrc005-0.212301* nrc007 -264.98788416 1  MFRFS   MSP
   4   -264.99451339 0.00890101 0.089986 0.045423 nrc007 0.123178* nrc002 -264.99582814 1  MFRFS   MSP
   5   -264.99707885-0.00256546 0.044095-0.015003 nrc009 0.159069* nrc015 -265.00090995 1  MFRFS   MSP
   6   -264.99892919-0.00185034 0.033489-0.013653 nrc015-0.124146  nrc015 -265.00050567 1  MFRFS   MSP
   7   -265.00031159-0.00138240 0.009416-0.004916 nrc018-0.156924  nrc018 -265.00070286 1  MFRFS   MSP
   8   -265.00019076 0.00012083 0.009057 0.005870 nrc018 0.081240  nrc018 -265.00049408 1  MFRFS   MSP
   9   -265.00049567-0.00030490 0.003380 0.001481 nrc011-0.070124  nrc015 -265.00056966 1  MFRFS   MSP
  10   -265.00030276 0.00019291 0.159266-0.159144 Cns001 0.114927! nrc015 -264.99874954 0  MFRFS   MSP
  11   -265.00098377-0.00068101 0.031621-0.008700 nrc005-0.101187  nrc007 -265.00046906 1  MFRFS   MSP
  12   -265.00050857 0.00047520 0.003360 0.001719 nrc015 0.012580  nrc015 -265.00052069 1  MFRFS   MSP
  13   -265.00052089-0.00001233 0.001243-0.000590 nrc017-0.006069  nrc017 -265.00052323 1  MFRFS   MSP
  14   -265.00052429-0.00000340 0.000753 0.000259 nrc011-0.002449  nrc018 -265.00052458 1  MFRFS   MSP
  15   -265.00052441-0.00000011 0.000442-0.000136 nrc007 0.003334  nrc018 -265.00052464 1  MFRFS   MSP
  16   -265.00052435 0.00000006 0.000397 0.000145 nrc017 0.001628  nrc010 -265.00052459 1  MFRFS   MSP

.. Note: contains a nbsp

Here a negative Hessian eigenvalue was found at iteration 3. At this point the optimization turn to a normal
quasi-Newton--Raphson optimization without any constraints. We note that the procedure flips back to a constrained
optimization at iteration 10 but is finished as an optimization for a transition state.
The predicted activation energy is estimated to 60.6 kcal/mol (excluding vibrational corrections).
The computed transition state
is depicted in :numref:`fig:job3`.

.. figure:: job3.*
   :name: fig:job3
   :width: 50%
   :align: center

   Transition state

The remaining issue is if this is a true transition state. This issue can only be
resolved by doing a calculation of the analytical Hessian using the
MCKINLEY module (execution of the MCLR module is automatic). The corresponding input is

.. extractfile:: advanced/MCKINLEY.input

  &Seward

  Basis set
  C.cc-pVDZ....
  C1            -1.8937541206        0.0797525492        0.5330826031
  C2            -2.3239194706       -0.0748842444        3.0012862573
  C3             0.7556108398       -0.0065134659       -0.5801137465
  End of Basis
  Basis set
  H.cc-pVDZ....
  H1            -4.2196708766       -0.0106202053        3.8051971560
  H2            -0.7745261239       -0.2775291936        4.3506967746
  H3            -1.9256618348        0.2927045555       -2.1370156139
  End of Basis
  Basis set
  O.cc-pVDZ....
  O1             0.2162486684        0.2196587542       -2.9675781183
  O2             2.8171388123       -0.2187115071        0.3719375423
  End of Basis
  End of input

  &SCF
  Charge = -1

  &McKinley
  Perturbation
  Hessian

.. compound::

  From the output of the MCLR code ::

          ***********************************
          *                                 *
          * Harmonic frequencies in cm-1    *
          * Intensities in km/mole          *
          *                                 *
          * No correction due to curvlinear *
          * representations has been done   *
          *                                 *
          ***********************************

        Symmetry a
       ==============

                             1         2         3         4         5         6

                Freq.   i2027.40     i2.00     i0.07      0.05      0.07      2.02

    ...
                             7         8         9        10        11        12

                Freq.       3.57    145.36    278.41    574.44    675.27    759.94

    ...
                            13        14        15        16        17        18

                Freq.     927.78    943.60   1000.07   1225.34   1265.63   1442.57

    ...
                           19        20        21        22        23        24

                Freq.    1517.91   1800.86   1878.11   2294.83   3198.94   3262.66

  we can conclude that we have one imaginary eigenvalue (modes 2--7 corresponds to the translational
  and rotational zero frequency modes) and that the structure found with this procedure indeed is a
  transition state. A post calculation analysis of the vibrational modes using the MOLDEN package
  confirm that the vibrational mode with the imaginary frequency is a mode which moves the proton from
  the oxygen to the carbon.

Finding the reaction path -- an IRC study
-----------------------------------------

A minimum energy path (MEP) is defined as the path defined by a sequence of geometries obtained by a
series of optimizations on a hypersphere. The series of constrained optimization starts from some
starting structure and the optimized structure at each step is taken as the start for the next step.
The constraint in these optimizations is the radius (in mass weighted coordinates) of the hyper sphere
with the origin defined by the starting geometry. If the starting structure is a transition state the
path is called an Intrinsic Reaction Coordinate (IRC) path. Since the transition structure (TS) has a negative
index of the Hessian we have two paths away from the TS. One leading us to the product(s) and one going to
the reactant(s). The IRC analysis is used to verify whether the TS is really connecting the expected
reactant(s) and product(s) and it is performed in forward and backward directions starting from the TS.
This analysis is obtained using the keyword :kword:`IRC` with the :program:`SLAPAF`
specifying the number of points and, if different from the default value (0.10 au), the radius
of the hypersphere with the keywords :kword:`nIRC` and :kword:`IRCStep`, respectively.
The reaction vector can be found on RUNOLD or it can be specified explicitly (see keyword :kword:`REACtion vector`).
In the latter case, the vector can be find at the end of the optimization job in the
``The Cartesian Reaction vector`` section of the :program:`SLAPAF` output.
A file named :file:`$Project.irc.molden` (read by :program:`MOLDEN`) will be generated
in $WorkDir containing only those points belonging to the IRC.
Here an example for an IRC analysis with 20 points back and forth and with 0.05 au as step.
The reaction vector will be read on RUNOLD. ::

  >>> EXPORT MOLCAS_MAXITER=500
  >>> Do while <<<

  ...

  &Slapaf &End
  IRC
  nIRC
   20
  IRCStep
   0.05
  Iterations
  200
  End of Input
  >>> EndDo <<<

If the file :file:`RUNFILE` is not available, the reaction vector must be specified in the
input. ::

  >>> EXPORT MOLCAS_MAXITER=500
  >>> Do while <<<

  ...

  &Slapaf &End
  IRC
  nIRC
   20
  IRCStep
   0.05
   REACtion vector
     0.140262        0.000000        0.179838
     0.321829        0.000000       -0.375102
    -0.006582        0.000000       -0.048402
    -0.032042       -0.018981       -0.003859
    -0.423466        0.000000        0.247525
  Iterations
  200
  End of Input
  >>> EndDo <<<
.. index::
   single: High Quality

.. _TUT\:sec\:rp_wf:

High quality wave functions at optimized structures
===================================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Here we will give an example of how geometrical structures obtained at
one level of theory can be used in an analysis at high quality wave functions.
:numref:`tab:tsgeo` compiles the obtained CASSCF geometries for
the dimethylcarbene to propene reaction (see :numref:`fig:reaction`).
They can be compared to the MP2 geometries :cite:`Ford:97`.
The overall agreement is good.

.. figure:: reaction.*
   :name: fig:reaction
   :width: 75%
   :align: center

   Dimethylcarbene to propene reaction path

The wave function at each of the geometries was
proved to be almost a single configuration. The second configuration in
all the cases contributed by less than 5% to the weight of the wave
function. It is a double excited replacement. Therefore, although
MP2 is not generally expected to describe properly a bond formation
in this case its behavior seems to be validated. The larger discrepancies
appear in the carbon-carbon distances in the dimethylcarbene and in
the transition state. On one hand the basis set used in the present
example were small; on the other hand there are indications that
the MP2 method overestimates the hyper conjugation effects present
in the dimethylcarbene :cite:`Ford:97`. :numref:`fig:carbene` displays
the dimethylcarbene with indication of the employed labeling.

.. figure:: carbene.*
   :name: fig:carbene
   :width: 50%
   :align: center

   Dimethylcarbene atom labeling

.. table:: Bond distances (Å) and bond angles (deg) of
           dimethylcarbene, propene, and their transition state\ [#a]_
   :name: tab:tsgeo

   ========== ============================= ============================= ============================= ============================= ============================= ============================= ============================= ============================= =============================
   |zws|      :math:`\ce{C{1}C{3}}`         :math:`\ce{C{1}C{2}}`         :math:`\ce{C{2}C{1}C{3}}`     :math:`\ce{C{1}C{3}H{6}}`     :math:`\ce{C{2}C{1}C{3}H{6}}` :math:`\ce{C{2}H{5}}`         :math:`\ce{C{1}H{5}}`         :math:`\ce{C{1}C{2}H{5}}`     :math:`\ce{C{3}C{1}C{2}H{5}}`
   ========== ============================= ============================= ============================= ============================= ============================= ============================= ============================= ============================= =============================
   *Dimethylcarbene*
   ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   CAS\ [#b]_ 1.497                         1.497                         110.9                         102.9                         88.9                          1.099                                                       102.9                         88.9
   MP2\ [#c]_ 1.480                         1.480                         110.3                          98.0                         85.5                          1.106                                                        98.0                         85.5
   *Transition structure*
   ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   CAS\ [#b]_ 1.512                         1.394                         114.6                         106.1                         68.6                          1.287                         1.315                          58.6                         76.6
   MP2\ [#c]_ 1.509                         1.402                         112.3                         105.1                         69.2                          1.251                         1.326                          59.6                         77.7
   *Propene*
   ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   CAS\ [#b]_ 1.505                         1.344                         124.9                         110.7                         59.4
   MP2\ [#c]_ 1.501                         1.338                         124.4                         111.1                         59.4
   ========== ============================= ============================= ============================= ============================= ============================= ============================= ============================= ============================= =============================

.. [#a] :math:`\ce{C{1}}`, carbenoid center; :math:`\ce{C{2}}`, carbon which loses the hydrogen :math:`\ce{H{5}}`. See :numref:`fig:carbene`.
.. [#b] Present results. CASSCF, ANO-S C[3s2p1d], H[2d1p]. Two electrons in two orbitals.
.. [#c] MP2 6-31G(2p,d), Ref. :cite:`Ford:97`.

.. index::
   single: Geometry

The main structural effects occurring during the reaction can be observed
displayed in :numref:`tab:tsgeo`. As the rearrangement starts out one
hydrogen atom (:math:`\ce{H{5}}`) moves in a plane almost perpendicular to the plane
formed by the three carbon atoms while the remaining two hydrogen atoms
on the same methyl group swing very rapidly into a nearly planar
position (see :numref:`fig:reaction`).
As the :math:`\pi` bond is formed we observe
a contraction of the :math:`\ce{C{1}-C{2}}` distance. In contrast, the spectator
methyl group behaves as a rigid body. Their parameters were
not compiled here but it rotates and bends slightly :cite:`Ford:97`. Focusing
on the second half reaction, the moving hydrogen atom rotates into the
plane of the carbon atoms to form the new :math:`\ce{C{1}-H{5}}` bond. This movement
is followed by a further shortening of the preformed :math:`\ce{C{1}-C{2}}` bond,
which acquires the bond distance of a typical double carbon bond, and
smaller adjustments in the positions of the other atoms. The structures
of the reactant, transition state, and product are shown in
:numref:`fig:reaction`.

As was already mentioned we will apply now higher-correlated methods
for the reactant, product, and transition state system at the CASSCF
optimized geometries to account for more accurate relative energies.
In any case a small basis set has been used and therefore the goal is
not to be extremely accurate. For more complete results see Ref.
:cite:`Ford:97`. We are going to perform calculations with the
MP2, MRCI, ACPF, CASPT2, CCSD, and CCSD(T) methods.

Starting with dimethylcarbene, we will use the following input file:

.. extractfile:: advanced/CCSDT.dimethylcarbene.input

  &SEWARD &END
  Title
   Dimethylcarbene singlet C2-sym
   CASSCF(ANO-VDZP) opt geometry
  Symmetry
   XY
  Basis set
  C.ANO-S...3s2p1d.
  C1              .0000000000         .0000000000        1.2019871414
  C2              .0369055124        2.3301037548        -.4006974719
  End of basis
  Basis set
  H.ANO-S...2s1p.
  H1             -.8322309260        2.1305589948       -2.2666729831
  H2             -.7079699536        3.9796589218         .5772009623
  H3             2.0671154914        2.6585385786        -.6954193494
  End of basis
  PkThrs
   1.0E-10
  End of input

  &SCF &END
  Title
  Dmc
  Occupied
  7 5
  End of input

  &RASSCF &END
  Title
  Dmc
  Symmetry
   1
  Spin
   1
  Nactel
   2  0  0
  Inactive
   6  5
  Ras2
   1  1
  Thrs
  1.0E-05,1.0E-03,1.0E-03
  Iteration
  50,25
  LumOrb
  End of input

  &CASPT2 &END
  Title
  Dmc
  LRoot
  1
  Frozen
   2  1
  End of input

  &MOTRA &END
  Title
  Dmc
  Frozen
   2  1
  JobIph
  End of input

  &GUGA &END
  Title
  Dmc
  Electrons
  18
  Spin
   1
  Inactive
   4  4
  Active
   1  1
  Ciall
   1
  Print
   5
  End of input

  &MRCI &END
  Title
  Dimethylcarbene
  SDCI
  End of input

  &MRCI &END
  Title
  Dimethylcarbene
  ACPF
  End of input

  * Now we generate the single ref. function
  * for coupled-cluster calculations

  &RASSCF &END
  Title
  Dmc
  Symmetry
   1
  Spin
   1
  Nactel
   0  0  0
  Inactive
   7  5
  Ras2
   0  0
  Thrs
  1.0E-05,1.0E-03,1.0E-03
  Iteration
  50,25
  LumOrb
  OutOrbitals
   Canonical
  End of input

  &MOTRA &END
  Title
  Dmc
  Frozen
   2  1
  JobIph
  End of input

  &CCSDT &END
  Title
   Dmc
  CCT
  Iterations
   40
  Triples
   2
  End of input

.. index::
   single: MP2
   single: Program; MBPT2
   single: CCSD
   single: CCSD(T)
   single: Program; CCSORT
   single: Program; CCSD
   single: Program; CCT3
   single: Program; CCSDT
   single: ACPF
   single: Program; CPF
   single: MRCI
   single: Program; MRCI
   single: Option; Canonical
   single: RASSCF; Canonical

Observe in the previous input that we have generated a multiconfigurational
wave function for CASPT2, MRCI, and ACPF wave functions but a single configuration
reference wave function (using :program:`RASSCF` program with the options
:kword:`OUTOrbitals` and :kword:`CANOnical`)
for the CCSD and CCSD(T) wave functions. Notice also
that to compute a multiconfigurational ACPF wave function we have to use
the :program:`MRCI` program, not the :program:`CPF` module which does not accept
more than one single reference. In all the highly correlated
methods we have frozen the three carbon core orbitals because of the reasons
already explained in :numref:`TUT:sec:x2`. For MRCI, ACPF, CCSD, and CCSD(T)
the freezing is performed in the :program:`MOTRA` step.

.. index::
   single: Reference space
   single: Active space

One question that can be addressed is which is the proper reference space
for the multiconfigurational calculations. As was explained when we selected
the active space for the geometry optimizations, we performed several tests
at different stages in the reaction path and observed that the smallest
meaningful active space, two electrons in two orbitals, was sufficient
in all the cases. We can come back to this problem here to select the
reference for CASPT2, MRCI, and ACPF methods. The simple analysis of the
SCF orbital energies shows that in dimethylcarbene, for instance, the
orbital energies of the :math:`\ce{C-H}` bonds are close to those of the :math:`\ce{C-C}` :math:`\sigma`
bonds and additionally those orbitals are strongly mixed along
the reaction path. A balanced active space including all orbitals necessary
to describe the shifting H-atom properly would require a full valence
space of 18 electrons in 18 orbitals. This is not a feasible space, therefore
we proceed with the minimal active space and analyze later the quality
of the results. The CASSCF wave function will then include for dimethylcarbene
and the transition state structure the :math:`(\sigma)^2(\pi)^0` and
:math:`(\sigma)^0(\pi)^2` configurations correlating the non-bonded electrons
localized at the carbenoid center where as for propene the active space
include the equivalent valence :math:`\pi` space.

.. index::
   single: GUGA
   single: Program; GUGA
   single: GUGA; Electrons
   single: GUGA; Active
   single: GUGA; Inactive
   single: GUGA; Ciall
   single: Option; Ciall
   single: Option; Electrons
   single: Option; Symmetry in GUGA

The :program:`GUGA` input must be built carefully. There are several
ways to specify the reference configurations for the following methods.
First, the keyword :kword:`ELECtrons` refers to the total number of
electrons that are going to be correlated, that is, all except those
frozen in the previous :program:`MOTRA` step.
Keywords :kword:`INACtive` and
:kword:`ACTIve` are optional and describe the number of inactive
(occupation two in all the reference configurations) and active
(varying occupation number in the reference configurations) orbitals
of the space. Here :kword:`ACTIve` indicates one orbital of each
of the symmetries. The following keyword :kword:`CIALl` indicates
that the reference space will be the full CI within the subspace
of active orbitals. It must be always followed by symmetry index
(number of the irrep) for the resulting wave function, one here.

For the transition state structure we do not impose any symmetry
restriction, therefore the calculations are performed in the :math:`C_1` group
with the input file:

.. extractfile:: advanced/CCSDT.C1.input

  &SEWARD &END
  Title
   Dimethylcarbene to propene
   Transition State C1 symmetry
   CASSCF (ANO-VDZP) opt geometry
  Basis set
  C.ANO-S...3s2p1d.
  End of basis
  Basis set
  H.ANO-S...2s1p.
  End of basis
  PkThrs
   1.0E-10
  End of input

  &SCF &END
  Title
   Ts
  Occupied
   12
  End of input

  &MBPT2 &END
  Title
   Ts
  Frozen
   3
  End of input

  &RASSCF &END
  Title
   Ts
  Symmetry
   1
  Spin
   1
  Nactel
   2  0  0
  Inactive
   11
  Ras2
   2
  Iteration
  50,25
  LumOrb
  End of input

  &CASPT2 &END
  Title
   Ts
  LRoot
   1
  Frozen
   3
  End of input

  &MOTRA &END
  Title
   Ts
  Frozen
   3
  JobIph
  End of input

  &GUGA &END
  Title
   Ts
  Electrons
   18
  Spin
   1
  Inactive
   8
  Active
   2
  Ciall
   1
  Print
   5
  End of input

  &MRCI &END
  Title
   Ts
  SDCI
  End of input

  &MRCI &END
  Title
   Ts
  ACPF
  End of input

  &RASSCF &END
  Title
   Ts
  Symmetry
   1
  Spin
   1
  Nactel
   0  0  0
  Inactive
   12
  Ras2
   0
  Iteration
  50,25
  LumOrb
  OutOrbitals
   Canonical
  End of input

  &MOTRA &END
  Title
   Ts
  Frozen
   3
  JobIph
  End of input

  &CCSDT &END
  Title
   Ts
  CCT
  Iterations
   40
  Triples
   2
  End of input

Finally we compute the wave functions for the product, propene, in the
:math:`C_s` symmetry group with the input:

.. extractfile:: advanced/CCSDT.Cs.input

  &SEWARD &END
  Title
   Propene singlet Cs-sym
   CASSCF(ANO-VDZP) opt geometry
  Symmetry
   Z
  Basis set
  C.ANO-S...3s2p1d.
  C1            -2.4150580342         .2276105054         .0000000000
  C2              .0418519070         .8733601069         .0000000000
  C3             2.2070668305        -.9719171861         .0000000000
  End of basis
  Basis set
  H.ANO-S...2s1p.
  H1            -3.0022907382       -1.7332097498         .0000000000
  H2            -3.8884900111        1.6454331428         .0000000000
  H3              .5407865292        2.8637419734         .0000000000
  H4             1.5296107561       -2.9154199848         .0000000000
  H5             3.3992878183        -.6985812202        1.6621549148
  End of basis
  PkThrs
   1.0E-10
  End of input

  &SCF &END
  Title
  Propene
  Occupied
  10 2
  End of input

  &MBPT2 &END
  Title
   Propene
  Frozen
   3 0
  End of input

  &RASSCF &END
  Title
  Propene
  Symmetry
  1
  Spin
  1
  Nactel
   2  0  0
  Inactive
  10  1
  Ras2
   0  2
  Thrs
  1.0E-05,1.0E-03,1.0E-03
  Iteration
  50,25
  LumOrb
  End of input

  &CASPT2 &END
  Title
  Propene
  LRoot
  1
  Frozen
   3  0
  End of input

  &MOTRA &END
  Title
  Propene
  Frozen
   3  0
  JobIph
  End of input

  &GUGA &END
  Title
  Propene
  Electrons
  18
  Spin
   1
  Inactive
   7  1
  Active
   0  2
  Ciall
   1
  Print
   5
  End of input

  &MRCI &END
  Title
  Propene
  SDCI
  End of input

  &MRCI &END
  Title
  Propene
  ACPF
  End of input

  &RASSCF &END
  Title
  Propene
  Symmetry
  1
  Spin
  1
  Nactel
   0  0  0
  Inactive
  10  2
  Ras2
   0  0
  Thrs
  1.0E-05,1.0E-03,1.0E-03
  Iteration
  50,25
  LumOrb
  OutOrbitals
   Canonical
  End of input

  &MOTRA &END
  Title
  Propene
  Frozen
   3  0
  JobIph
  End of input

  &CCSDT &END
  Title
   Propene
  CCT
  Iterations
   40
  Triples
   2
  End of input

:numref:`tab:rpener` compiles the total and relative energies
obtained for the studied reaction at the different levels of
theory employed.

.. index::
   single: Barrier height
   single: Exothermicity
   single: Reaction path

.. float::
   :type: table
   :name: tab:rpener
   :caption-top:
   :caption: Absolute (au) and relative (kcal/mol, in parentheses) energies obtained at the different
             theory levels for the reaction path from dimethylcarbene to propene.

   .. _tab_rpener_a:

   ========= ============== ============== ============== ==============
   Single configurational methods
   ---------------------------------------------------------------------
   |zws|     RHF            MP2            CCSD           CCSD(T)
   ========= ============== ============== ============== ==============
   *Dimethylcarbene*
   ---------------------------------------------------------------------
   \         |-|\117.001170 |-|\117.392130 |-|\117.442422 |-|\117.455788
   *Transition state structure*
   ---------------------------------------------------------------------
   \         |-|\116.972670 |-|\117.381342 |-|\117.424088 |-|\117.439239
   BH\ [#d]_ (17.88)        (6.77)         (11.50)        (10.38)
   *Propene*
   ---------------------------------------------------------------------
   \         |-|\117.094700 |-|\117.504053 |-|\117.545133 |-|\117.559729
   EX\ [#e]_ (|-|\58.69)    (|-|\70.23)    (|-|\64.45)    (|-|\65.22)
   ========= ============== ============== ============== ==============

   .. _tab_rpener_b:

   ========= ============== ============== ============== ==============
   Multiconfigurational methods
   ---------------------------------------------------------------------
   |zws|     CASSCF         CASPT2         SD-MRCI+Q      ACPF
   ========= ============== ============== ============== ==============
   *Dimethylcarbene*
   ---------------------------------------------------------------------
   \         |-|\117.020462 |-|\117.398025 |-|\117.447395 |-|\117.448813
   *Transition state structure*
   ---------------------------------------------------------------------
   \         |-|\116.988419 |-|\117.383017 |-|\117.430951 |-|\117.432554
   BH\ [#d]_ (20.11)        (9.42)         (10.32)        (10.20)
   *Propene*
   ---------------------------------------------------------------------
   \         |-|\117.122264 |-|\117.506315 |-|\117.554048 |-|\117.554874
   EX\ [#e]_ (|-|\63.88)    (|-|\67.95)    (|-|\66.93)    (|-|\66.55)
   ========= ============== ============== ============== ==============

   .. [#d] Barrier height. Needs to be corrected with the zero point vibrational correction.
   .. [#e] Exothermicity. Needs to be corrected with the zero point vibrational correction.

We can discuss now the quality of the results obtained and their
reliability (for a more careful discussion of the accuracy of
quantum chemical calculations see Ref. :cite:`Taylor:92b`).
In first place we have to consider that a valence
double-zeta plus polarization basis set is somewhat small to obtain
accurate results. At least a triple-zeta quality would be required.
The present results have, however, the goal to serve as an example.
We already pointed out that the CASSCF geometries were very similar
to the MP2 reported geometries :cite:`Ford:97`. This fact validates
both methods. MP2 provides remarkably accurate geometries using
basis sets of triple-zeta quality, as in Ref. :cite:`Ford:97`, in
situations were the systems can be described as singly configurational,
as the CASSCF calculations show. The Hartree--Fock configuration has
a contribution of more than 95% in all three structures, while the
largest weight for another configuration appears in propene for
:math:`(\pi)^0(\pi^*)^2` (4.2%).

.. index::
   single: MRCI
   single: Program; MRCI

The MRCI calculations provide also one test of the validity of the
reference wave function. For instance, the MRCI output for propene is: ::

                 FINAL RESULTS FOR STATE NR   1
   CORRESPONDING ROOT OF REFERENCE CI IS NR:  1
              REFERENCE CI ENERGY: -117.12226386
           EXTRA-REFERENCE WEIGHT:     .11847074
              CI CORRELATION ENERGY:    -.38063043
                        CI ENERGY: -117.50289429
              DAVIDSON CORRECTION:    -.05115380
               CORRECTED ENERGY: -117.55404809
                    ACPF CORRECTION:    -.04480105
                 CORRECTED ENERGY: -117.54769535

        CI-COEFFICIENTS LARGER THAN  .050
    NOTE: THE FOLLOWING ORBITALS WERE FROZEN
    ALREADY AT THE INTEGRAL TRANSFORMATION STEP
    AND DO NOT EXPLICITLY APPEAR:
          SYMMETRY:   1   2
        PRE-FROZEN:   3   0
    ORDER OF SPIN-COUPLING: (PRE-FROZEN, NOT SHOWN)
                            (FROZEN, NOT SHOWN)
                             VIRTUAL
                             ADDED VALENCE
                             INACTIVE
                             ACTIVE

    ORBITALS ARE NUMBERED WITHIN EACH SEPARATE SYMMETRY.


        CONFIGURATION     32   COEFFICIENT  -.165909   REFERENCE
   SYMMETRY             1  1  1  1  1  1  1  2  2  2
   ORBITALS             4  5  6  7  8  9 10  1  2  3
   OCCUPATION           2  2  2  2  2  2  2  2  0  2
   SPIN-COUPLING        3  3  3  3  3  3  3  3  0  3


        CONFIGURATION     33   COEFFICIENT  -.000370   REFERENCE
   SYMMETRY             1  1  1  1  1  1  1  2  2  2
   ORBITALS             4  5  6  7  8  9 10  1  2  3
   OCCUPATION           2  2  2  2  2  2  2  2  1  1
   SPIN-COUPLING        3  3  3  3  3  3  3  3  1  2

        CONFIGURATION     34   COEFFICIENT   .924123   REFERENCE
   SYMMETRY             1  1  1  1  1  1  1  2  2  2
   ORBITALS             4  5  6  7  8  9 10  1  2  3
   OCCUPATION           2  2  2  2  2  2  2  2  2  0
   SPIN-COUPLING        3  3  3  3  3  3  3  3  3  0
  **************************************************************

.. Note: contains a nbsp

The Hartree--Fock configuration contributes to the
MRCI configuration with a weight of 85.4%, while the next configuration
contributes by 2.8%. Similar conclusions can be obtained analyzing the
ACPF results and for the other structures. We will keep the MRCI results
including the Davidson correction (MRCI+Q) which corrects for the
size-inconsistency of the truncated CI expansion :cite:`Taylor:92b`.

For CASPT2 the evaluation criteria are commented in
:numref:`TUT:sec:excited`. The portion of the :program:`CASPT2` output for
propene is: ::

        Reference energy:        -117.1222638304
        E2 (Non-variational):       -.3851719971
        E2 (Variational):           -.3840516039
        Total energy:            -117.5063154343
        Residual norm:               .0000000000
        Reference weight:            .87905

        Contributions to the CASPT2 correlation energy
        Active & Virtual Only:          -.0057016698
        One Inactive Excited:           -.0828133881
        Two Inactive Excited:           -.2966569393


  ----------------------------------------------------------------------------
  Report on small energy denominators, large components, and large energy contributions.
  The ACTIVE-MIX index denotes linear combinations which gives ON expansion functions
    and makes H0 diagonal within type.
  DENOMINATOR: The (H0_ii - E0) value from the above-mentioned diagonal approximation.
  RHS value: Right-Hand Side of CASPT2 Eqs.
  COEFFICIENT: Multiplies each of the above ON terms in the first-order wave function.
  Thresholds used:
          Denominators:  .3000
            Components:  .0250
  Energy contributions:  .0050

  CASE SYMM ACTIVE  NON-ACT IND    DENOMINATOR  RHS VALUE  COEFFICIENT CONTRIBUTION
  AIVX  1  Mu1.0003 In1.004 Se1.022  2.28926570 .05988708  -.02615995  -.00156664

.. Note: contains a nbsp

.. index::
   single: CASPT2
   single: Program; CASPT2

The weight of the CASSCF reference to the first-order wave function is
here 87.9%, very close to the weights obtained for the dimethylcarbene and
the transition state structure,
and there is only a small contribution to the wave function and energy
which is larger than the selected thresholds. This should not be considered as a
intruder state, but as a contribution from the fourth inactive orbital which
could be, eventually, included in the active space. The contribution to the
second-order energy in this case is smaller than 1 kcal/mol. It can be observed
that the same contribution shows up for the transition state structure but not
for the dimethylcarbene. In principle this could be an indication that a larger
active space, that is, four electrons in four orbitals, would give a slightly
more accurate CASPT2 energy. The present results will probably overestimate
the second-order energies for the transition state structure and the propene,
leading to a slightly smaller activation barrier and a slightly larger
exothermicity, as can be observed in :numref:`tab:rpener`. The orbitals
pointed out as responsible for the large contributions in propene are the
fourth inactive and 22nd secondary orbitals of the first symmetry. They are
too deep and too high, respectively, to expect that an increase in the active
space could in fact represent a great improvement in the CASPT2 result.
In any case we tested for four orbitals-four electrons CASSCF/CASPT2 calculations
and the results were very similar to those presented here.

.. index::
   single: CCSD
   single: CCSD(T)
   single: Program; CCSORT
   single: Program; CCSD
   single: Program; CCT3
   single: Program; CCSDT

Finally we can analyze the so-called :math:`\tau_1`\-diagnostic :cite:`Lee:89`
for the coupled-cluster wave functions. :math:`\tau_1` is defined for closed-shell
coupled-cluster methods as the Euclidean norm of the vector of :math:`T_1`
amplitudes normalized by the number of electrons correlated:
:math:`\tau_1 = \lVert T_1\Vert/N_{\text{el}}^{1/2}`.
In the output of the :program:`CCSD` program we have: ::

        Convergence after  17  Iterations


        Total energy (diff) :    -117.54513288       -.00000061
        Correlation energy  :       -.45043295
        E1aa   contribution :        .00000000
        E1bb   contribution :        .00000000
        E2aaaa contribution :       -.04300448
        E2bbbb contribution :       -.04300448
        E2abab contribution :       -.36442400


   Five largest amplitudes of :T1aa
    SYMA   SYMB   SYMI   SYMJ     A      B      I      J     VALUE
      2      0      2      0      4      0      2      0     -.0149364994
      2      0      2      0      2      0      2      0      .0132231037
      2      0      2      0      8      0      2      0     -.0104167047
      2      0      2      0      7      0      2      0     -.0103366543
      2      0      2      0      1      0      2      0      .0077537734
   Euclidean norm is :      .0403635306

   Five largest amplitudes of :T1bb
    SYMA   SYMB   SYMI   SYMJ     A      B      I      J     VALUE
      2      0      2      0      4      0      2      0     -.0149364994
      2      0      2      0      2      0      2      0      .0132231037
      2      0      2      0      8      0      2      0     -.0104167047
      2      0      2      0      7      0      2      0     -.0103366543
      2      0      2      0      1      0      2      0      .0077537734
   Euclidean norm is :      .0403635306

.. Note: contains a nbsp

In this case T1aa and T1bb are identical because we are computing a
closed-shell singlet state. The five largest :math:`T_1` amplitudes are
printed, as well as the Euclidean norm. Here the number of correlated
electrons is 18, therefore the value for the :math:`\tau_1` diagnostic is 0.01.
This value can be considered acceptable as evaluation of the
quality of the calculation. The use of :math:`\tau_1` as a diagnostic is
based on an observed empirical correlation: larger values give poor
CCSD results for molecular structures, binding energies, and
vibrational frequencies :cite:`Lee:92`. It was considered that values
larger than 0.02 indicated that results from single-reference electron
correlation methods limited to single and double excitations should be
viewed with caution.

There are several considerations concerning the :math:`\tau_1` diagnostic
:cite:`Lee:89`. First, it is only valid within the frozen core
approximation and it was defined for coupled-cluster procedures
using SCF molecular orbitals in the reference function. Second, it is
a measure of the importance of non-dynamical electron correlation effects
and not of the degree of the multireference effects. Sometimes the two
effects are related, but not always (see discussion in Ref. :cite:`Lee:92`).
Finally, the performance of the CCSD(T) method is reasonably good even
in situations where :math:`\tau_1` has a value as large as 0.08.
In conclusion, the use of :math:`\tau_1` together with other wave function
analysis, such as explicitly examining the largest :math:`T_1` and :math:`T_2`
amplitudes, is the best approach to evaluate the quality of the
calculations but this must be done with extreme caution.

As the present systems are reasonably well described by a single
determinant reference function there is no doubt that the CCSD(T)
method provides the most accurate results. Here CASPT2, MRCI+Q,
ACPF, and CCSD(T) predict the barrier height from the reactant
to the transition state with an accuracy better than 1 kcal/mol.
The correspondence is somewhat worse, about 3 kcal/mol, for the
exothermicity. As the difference is largest for the CCSD(T) method
we may conclude than triple and higher order excitations are of
importance to achieve a balanced correlation treatment, in particular
with respect to the partially occupied :math:`\pi^*` orbital at the
carbenoid center. It is also noticeable that the relative MP2
energies appear to be shifted about 3--4 kcal/mol towards lower
values. This effect may be due to the overestimation of the
hyper-conjugation effect which appears to be strongest in dimethylcarbene
:cite:`Matzinger:95,Ford:97`.

.. index::
   single: Zero Point correction

Additional factors affecting the accuracy of the results obtained
are the zero point vibrational energy correction and, of course,
the saturation of the one particle basis sets. The zero point
vibrational correction could be computed by performing a numerical
harmonic vibrational analysis at the CASSCF level using |molcas|
At the MP2 level :cite:`Ford:97` the
obtained values were |-|\1.1 kcal/mol and 2.4 kcal/mol for the
activation barrier height and exothermicity, respectively.
Therefore, if we take as our best values the CCSD(T) results
of 10.4 and |-|\65.2 kcal/mol, respectively, our prediction would
be an activation barrier height of 9.3 kcal/mol and an
exothermicity of |-|\62.8 kcal/mol. Calculations with larger
basis sets and MP2 geometries gave 7.4 and |-|\66.2 kcal/mol,
respectively :cite:`Ford:97`. The experimental estimation
gives a lower limit to the activation barrier of 3.3 kcal/mol
:cite:`Ford:97`.

.. index::
   single: Mulliken analysis
   single: Properties; Mulliken analysis

|molcas| provides also a number of one-electron properties
which can be useful to analyze the chemical behavior of the systems.
For instance, the Mulliken population analysis is available for the
RHF, CASSCF, CASPT2, MRCI, and ACPF wave functions. Mulliken charges
are known to be strongly biased by the choice of the basis sets,
nevertheless one can restrict the analysis to the relative charge
differences during the course of the reaction to obtain a qualitative
picture. We can use, for instance, the charge distribution obtained
for the MRCI wave function, which is listed in :numref:`tab:Mq`.
Take into account that the absolute values of the charges can
vary with the change of basis set.

.. table:: Mulliken's population analysis (partial charges) for the reaction path from dimethylcarbene to propene. MRCI wave functions.
   :name: tab:Mq

   ================================== ================================== ================================== ================================== ================================== ==================================
   :math:`\ce{C{2}}`\ [#f]_           :math:`\ce{C{1}}`\ [#g]_           :math:`\ce{H{5}}`\ [#h]_           :math:`\Sigma`\ [#i]_              :math:`\ce{H{1}}+\ce{H{3}}`\ [#j]_ :math:`\ce{Me}`\ [#k]_
   ================================== ================================== ================================== ================================== ================================== ==================================
   *Dimethylcarbene*
   -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   |-|\0.12                           |-|\0.13                           0.05                               |-|\0.20                           0.14                               0.07
   *Transition state structure*
   -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   |-|\0.02                           |-|\0.23                           0.05                               |-|\0.20                           0.17                               0.02
   *Propene*
   -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   |-|\0.18                           |-|\0.02                           0.05                               |-|\0.15                           0.18                               |-|\0.02
   ================================== ================================== ================================== ================================== ================================== ==================================

.. [#f] Carbon from which the hydrogen is withdrawn.
.. [#g] Central carbenoid carbon.
.. [#h] Migrating hydrogen.
.. [#i] Sum of charges for centers :math:`\ce{C{2}}`, :math:`\ce{C{1}}`, and :math:`\ce{H{5}}`.
.. [#j] Sum of charges for the remaining hydrogens attached to :math:`\ce{C{2}}`.
.. [#k] Sum of charges for the spectator methyl group.

In dimethylcarbene both the medium and terminal carbons appear equally charged.
During the migration of hydrogen :math:`\ce{H{5}}` charge flows from the hydrogen donating
carbon, :math:`\ce{C{2}}`, to the carbenoid center. For the second half of the reaction
the charge flows back to the terminal carbon from the centered carbon, probably
due to the effect of the :math:`\pi` delocalization.
.. index::
   single: Linear molecules; Supersymmetry
   single: Symmetry

.. _TUT\:sec\:x2:

Computing high symmetry molecules
=================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

|molcas| makes intensive use of the symmetry properties of the
molecular systems in all parts of the calculation. The highest
symmetry point group available,
however, is the |Dth| point group, which makes things somewhat
more complicated when the molecule has higher symmetry.
One of such cases is the calculation of linear molecules.
In this section we describe calculations on
different electronic states of three diatomic molecules:
:math:`\ce{NiH}`, a heteronuclear molecule which belongs to the |Cinfv|
symmetry group and :math:`\ce{C2}` and :math:`\ce{Ni2}`, two homonuclear molecules which belong
to the |Dinfh| symmetry group. They must be computed in
|molcas| using the lower order symmetry groups |Ctv| and
|Dth|, respectively, and therefore some codes such RASSCF use specific tools
to constrain the resulting wave functions
to have the higher symmetry of the actual point group.
It must be pointed out clearly that linear symmetry cannot always be fully
obtained in |molcas| because the tools to average over degenerate representations
are not totally implemented presently in the
RASSCF program. This is the case, for instance, for the :math:`\delta`
orbitals in a |Ctv|\--\ |Cinfv| situation, as will be shown below.
(For problems related to accurate calculations of diatomic
molecules and symmetry see Ref. :cite:`Partridge:95` and
:cite:`Taylor:92a`, respectively.).
In a final section we will briefly comment the situation of
high symmetry systems other than linear.

.. index::
   single: Linear molecules; NiH
   single: NiH

.. _TUT\:sec\:nih:

A diatomic heteronuclear molecule: :math:`\ce{NiH}`
---------------------------------------------------

Chemical bonds involving transition-metal atoms are often
complex in nature due to the common presence of several unpaired
electrons resulting in many close-lying spectroscopic states
and a number of different factors such spin--orbit coupling or the
importance of relativistic effects. :math:`\ce{NiH}` was the first
system containing a transition-metal atom to be studied with
the CASSCF method :cite:`Roos:82`. The large dynamic correlation
effects inherent in a 3d semi-occupied shell with many electrons is
a most severe problem, which few methods have been able to compute. The
calculated dipole moment of the system has become one measurement
of the quality of many *ab initio* methods :cite:`Roos:87`.
We are not going to analyze the effects in detail. Let us only
say that an accurate treatment of the correlation effects
requires high quality methods such as MRCI, ACPF or CASPT2,
large basis sets, and an appropriate treatment of
relativistic effects, basis set superposition errors,
and core-valence correlation. A detailed CASPT2 calculation
of the ground state of :math:`\ce{NiH}` can be found elsewhere :cite:`Pou:94`.

The :math:`^3F` (3d\ :math:`^8`\4s\ :math:`^2`) and :math:`^3D` (3d\ :math:`^9`\4s\ :math:`^1`) states of the nickel
atom are almost degenerate with a splitting of only 0.03 eV :cite:`Andersson:92c` and
are characterized by quite different chemical behavior. In systems such as the
:math:`^2\Delta` ground state of :math:`\ce{NiH}` molecule, where both states take part in the
bonding, an accurate description of the low-lying :math:`\ce{Ni}` atomic states is required.
The selection of the active space for :math:`\ce{NiH}` is not trivial.
The smallest set of active orbitals for the :math:`^2\Delta` ground state which allows
a proper dissociation and also takes into account the important 3d\ :math:`\sigma`
correlation comprises the singly occupied 3\ |dxy| orbital and three :math:`\sigma`
orbitals (3\ |dzt|, :math:`\sigma`, and :math:`\sigma^*`). One cannot however expect to obtain
accurate enough molecular properties just by including non-dynamical correlation
effects. MRCI+Q calculations with the most important CASSCF configurations
in the reference space proved that at least one additional 3d\ :math:`\delta` (3\ |dxtyt|)
and its correlating orbital were necessary to obtain spectroscopic constants in close
agreement with the experimental values. It is, however, a larger active space comprising
all the eleven valence electrons distributed in twelve active orbitals
(:math:`\sigma`, :math:`\sigma^*`, d, d') that is the most consistent choice of active orbitals as
evidenced in the calculation of other metal hydrides such as :math:`\ce{CuH}` :cite:`Pou:94`
and in the electronic spectrum of the :math:`\ce{Ni}` atom :cite:`Andersson:92c`. This is the
active space we are going to use in the following example. We will use the
ANO-type basis set contracted to :math:`\ce{Ni}` [5s4p3d1f] / :math:`\ce{H}` [3s2p] for simplicity. In
actual calculations g functions on the transition metal and d functions on
the hydrogen atom are required to
obtain accurate results.

.. index::
   single: Spherical Harmonics; C∞v

First we need to know the behavior of each one of the basis functions
within each one of the symmetries. Considering the molecule placed in
the :math:`z` axis the classification of the spherical harmonics into the |Cinfv|
point group is:

.. table:: Classification of the spherical harmonics in the |Cinfv| group.
   :name: tab:cinfv

   ============== ======= ======= ======= ======= ======= =======
   Symmetry       Spherical harmonics
   ============== ===============================================
   :math:`\sigma` |s|     |pz|    |dzt|   |fztt|
   :math:`\pi`    |px|    |py|    |dxz|   |dyz|   |fx|    |fy|
   :math:`\delta` |dxtyt| |dxy|   |fxyz|  |fz|
   :math:`\phi`   |fxtt|  |fytt|
   ============== ======= ======= ======= ======= ======= =======

.. index::
   single: Diatomic molecules; Symmetry problems
   single: Spherical Harmonics; C2v

In |Ctv|, however, the functions are distributed into the four representations
of the group and therefore different symmetry representations can be mixed.
The next table lists the distribution of the
functions in |Ctv| and the symmetry of the corresponding orbitals in |Cinfv|.

.. table:: Classification of the spherical harmonics and |Cinfv| orbitals in the |Ctv| group.
   :name: tab:c2v

   ============ ======================== ======================== ======================== ======================== ======================== ========================
   Symm.\ [#a]_ Spherical harmonics (orbitals in |Cinfv|)
   ============ =====================================================================================================================================================
   |ao| (1)     |s| (:math:`\sigma`)     |pz| (:math:`\sigma`)    |dzt| (:math:`\sigma`)   |dxtyt| (:math:`\delta`) |fztt| (:math:`\sigma`)  |fz| (:math:`\delta`)
   |bo| (2)     |px| (:math:`\pi`)       |dxz| (:math:`\pi`)      |fx| (:math:`\pi`)       |fxtt| (:math:`\phi`)
   |bt| (3)     |py| (:math:`\pi`)       |dyz| (:math:`\pi`)      |fy| (:math:`\pi`)       |fytt| (:math:`\phi`)
   |at| (4)     |dxy| (:math:`\delta`)   |fxyz| (:math:`\delta`)
   ============ ======================== ======================== ======================== ======================== ======================== ========================

.. [#a] In parenthesis the number of the symmetry in |molcas|. It depends on the generators used in :program:`SEWARD`.

In symmetry |ao| we find both :math:`\sigma` and :math:`\delta` orbitals. When the
calculation is performed in |Ctv| symmetry all the orbitals of |ao| symmetry
can mix because they belong to the same representation, but this is not
correct for |Cinfv|. The total symmetry must be kept |Cinfv| and therefore the
:math:`\delta` orbitals should not be allowed to rotate and mix with the :math:`\sigma`
orbitals. The same is true in the |bo| and |bt| symmetries with the :math:`\pi` and
:math:`\phi` orbitals, while in |at| symmetry this problem does not exist because
it has only :math:`\delta` orbitals (with a basis set up to f functions).

The tool to restrict possible orbital rotations is the option :kword:`SUPSym` in the
RASSCF program. It is important to start with clean orbitals belonging to the
actual symmetry, that is, without unwanted mixing.

But the problems with the symmetry are not solved with the :kword:`SUPSym` option only.
Orbitals belonging to different components of a degenerate representation should also be
equivalent. For example: the :math:`\pi` orbitals in |bo| and |bt| symmetries should have the
same shape, and the same is true for the :math:`\delta` orbitals in |ao| and |at| symmetries.
This can only be partly achieved in the RASSCF code. The input option :kword:`AVERage`
will average the density matrices for representations |bo| and |bt| (:math:`\pi` and :math:`\phi`
orbitals), thus producing equivalent orbitals. The present version does not, however,
average the :math:`\delta` orbital densities in representations |ao| and |at| (note that
this problem does not occur for electronic states with an equal occupation of the
two components of a degenerate set, for example :math:`\Sigma` states).
A safe way to obtain totally symmetric orbitals is to reduce the symmetry to :math:`C_1`
(or :math:`C_s` in the homonuclear case) and perform a state-average calculation for the
degenerate components.

.. index::
   single: Spherical Harmonics; MOLCAS format

We need an equivalence table to know the correspondence of
the symbols for the functions in |molcas| to the spherical harmonics (SH):

.. table:: |molcas| labeling of the spherical harmonics.
   :name: tab:labels

   ======== ======= ======== ======= ======== =======
   |molcas| SH      |molcas| SH      |molcas| SH
   ======== ======= ======== ======= ======== =======
   1s       |s|     3d2+     |dxtyt| 4f3+     |fxtt|
   2px      |px|    3d1+     |dxz|   4f2+     |fz|
   2pz      |pz|    3d0      |dzt|   4f1+     |fx|
   2py      |py|    3d1\ |-| |dyz|   4f0      |fztt|
   |zws|            3d2\ |-| |dxy|   4f1\ |-| |fy|
   |zws|                             4f2\ |-| |fxyz|
   |zws|                             4f3\ |-| |fytt|
   ======== ======= ======== ======= ======== =======

We begin by performing a SCF calculation and analyzing the resulting
orbitals. The employed bond distance is close
to the experimental equilibrium bond length for the ground state :cite:`Pou:94`.
Observe in the following SEWARD input that the symmetry generators,
planes :math:`yz` and :math:`xz`, lead to a |Ctv| representation. In the SCF
input we have used the option :kword:`OCCNumbers` which allows specification of
occupation numbers other than 0 or 2. It is still the closed shell SCF
energy functional which is optimized, so the obtained SCF energy has no
physical meaning. However, the computed orbitals are somewhat
better for open shell cases as :math:`\ce{NiH}`. The energy of the virtual orbitals
is set to zero due to the use of the :kword:`IVO` option.
The order of the orbitals may change in different computers
and versions of the code.

.. index::
   single: Program; Seward
   single: Program; SCF
   single: SCF; OccNumbers
   single: IVO

.. extractfile:: advanced/SCF.NiH.input

  &SEWARD
  Title
   NiH G.S
  Symmetry
  X Y
  Basis set
  Ni.ANO-L...5s4p3d1f.
  Ni    0.00000   0.00000   0.000000   Bohr
  End of basis
  Basis set
  H.ANO-L...3s2p.
  H     0.000000  0.000000  2.747000   Bohr
  End of basis
  End of Input

  &SCF
  TITLE
   NiH G.S.
  OCCUPIED
   8 3 3 1
  OCCNumber
  2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0
  2.0 2.0 2.0
  2.0 2.0 2.0
  1.0

::

     SCF orbitals + arbitrary occupations

     Molecular orbitals for symmetry species 1

     ORBITAL        4         5         6         7         8         9        10
     ENERGY     -4.7208   -3.1159    -.5513    -.4963    -.3305     .0000     .0000
     OCC. NO.    2.0000    2.0000    2.0000    2.0000    2.0000     .0000     .0000

   1 NI  1s0      .0000     .0001     .0000    -.0009     .0019     .0112     .0000
   2 NI  1s0      .0002     .0006     .0000    -.0062     .0142     .0787     .0000
   3 NI  1s0     1.0005    -.0062     .0000    -.0326     .0758     .3565     .0000
   4 NI  1s0      .0053     .0098     .0000     .0531    -.4826     .7796     .0000
   5 NI  1s0     -.0043    -.0032     .0000     .0063    -.0102    -.0774     .0000
   6 NI  2pz      .0001     .0003     .0000    -.0015     .0029     .0113     .0000
   7 NI  2pz     -.0091    -.9974     .0000    -.0304     .0622     .1772     .0000
   8 NI  2pz      .0006     .0013     .0000     .0658    -.1219     .6544     .0000
   9 NI  2pz      .0016     .0060     .0000     .0077    -.0127    -.0646     .0000
  10 NI  3d0     -.0034     .0089     .0000     .8730     .4270     .0838     .0000
  11 NI  3d0      .0020     .0015     .0000     .0068     .0029     .8763     .0000
  12 NI  3d0      .0002     .0003     .0000    -.0118    -.0029    -.7112     .0000
  13 NI  3d2+     .0000     .0000    -.9986     .0000     .0000     .0000     .0175
  14 NI  3d2+     .0000     .0000     .0482     .0000     .0000     .0000     .6872
  15 NI  3d2+     .0000     .0000     .0215     .0000     .0000     .0000    -.7262
  16 NI  4f0      .0002     .0050     .0000    -.0009    -.0061     .0988     .0000
  17 NI  4f2+     .0000     .0000     .0047     .0000     .0000     .0000    -.0033
  18 H   1s0     -.0012    -.0166     .0000     .3084    -.5437    -.9659     .0000
  19 H   1s0     -.0008    -.0010     .0000    -.0284    -.0452    -.4191     .0000
  20 H   1s0      .0014     .0007     .0000     .0057     .0208     .1416     .0000
  21 H   2pz      .0001     .0050     .0000    -.0140     .0007     .5432     .0000
  22 H   2pz      .0008    -.0006     .0000     .0060    -.0093     .2232     .0000

     ORBITAL       11        12        13        14        15        16        18
     ENERGY       .0000     .0000     .0000     .0000     .0000     .0000     .0000
     OCC. NO.     .0000     .0000     .0000     .0000     .0000     .0000     .0000

   1 NI  1s0     -.0117    -.0118     .0000     .0025     .0218    -.0294     .0000
   2 NI  1s0     -.0826    -.0839     .0000     .0178     .1557    -.2087     .0000
   3 NI  1s0     -.3696    -.3949     .0000     .0852     .7386    -.9544     .0000
   4 NI  1s0    -1.3543   -1.1537     .0000     .3672    2.3913   -2.8883     .0000
   5 NI  1s0     -.3125     .0849     .0000   -1.0844     .3670    -.0378     .0000
   6 NI  2pz     -.0097    -.0149     .0000     .0064     .0261    -.0296     .0000
   7 NI  2pz     -.1561    -.2525     .0000     .1176     .4515    -.4807     .0000
   8 NI  2pz     -.3655   -1.0681     .0000     .0096    1.7262   -2.9773     .0000
   9 NI  2pz    -1.1434    -.0140     .0000    -.1206     .2437    -.9573     .0000
  10 NI  3d0     -.1209    -.2591     .0000     .2015     .5359    -.4113     .0000
  11 NI  3d0     -.3992    -.3952     .0000     .1001     .3984    -.9939     .0000
  12 NI  3d0     -.1546    -.1587     .0000    -.1676    -.2422    -.4852     .0000
  13 NI  3d2+     .0000     .0000    -.0048     .0000     .0000     .0000    -.0498
  14 NI  3d2+     .0000     .0000    -.0017     .0000     .0000     .0000    -.7248
  15 NI  3d2+     .0000     .0000     .0028     .0000     .0000     .0000    -.6871
  16 NI  4f0     -.1778   -1.0717     .0000    -.0233     .0928    -.0488     .0000
  17 NI  4f2+     .0000     .0000   -1.0000     .0000     .0000     .0000    -.0005
  18 H   1s0     1.2967    1.5873     .0000    -.3780   -2.7359    3.8753     .0000
  19 H   1s0     1.0032     .4861     .0000     .3969    -.9097    1.8227     .0000
  20 H   1s0     -.2224    -.2621     .0000     .1872     .0884    -.7173     .0000
  21 H   2pz     -.1164    -.4850     .0000     .3388    1.1689    -.4519     .0000
  22 H   2pz     -.1668    -.0359     .0000     .0047     .0925    -.3628     .0000

     Molecular orbitals for symmetry species 2

     ORBITAL        2         3         4         5         6         7
     ENERGY     -3.1244    -.5032     .0000     .0000     .0000     .0000
     OCC. NO.    2.0000    2.0000     .0000     .0000     .0000     .0000

   1 NI  2px     -.0001     .0001     .0015     .0018     .0012    -.0004
   2 NI  2px     -.9999     .0056     .0213     .0349     .0235    -.0054
   3 NI  2px     -.0062    -.0140     .1244    -.3887     .2021    -.0182
   4 NI  2px      .0042     .0037     .0893     .8855    -.0520     .0356
   5 NI  3d1+     .0053     .9993     .0268     .0329     .0586     .0005
   6 NI  3d1+    -.0002    -.0211    -.5975     .1616     .1313     .0044
   7 NI  3d1+    -.0012    -.0159     .7930     .0733     .0616     .0023
   8 NI  4f1+     .0013    -.0049     .0117     .1257    1.0211    -.0085
   9 NI  4f3+    -.0064     .0000    -.0003    -.0394     .0132     .9991
  10 H   2px     -.0008     .0024    -.0974    -.1614    -.2576    -.0029
  11 H   2px      .0003    -.0057    -.2060    -.2268    -.0768    -.0079

     Molecular orbitals for symmetry species 3

     ORBITAL        2         3         4         5         6         7
     ENERGY     -3.1244    -.5032     .0000     .0000     .0000     .0000
     OCC. NO.    2.0000    2.0000     .0000     .0000     .0000     .0000

   1 NI  2py     -.0001     .0001    -.0015     .0018     .0012     .0004
   2 NI  2py     -.9999     .0056    -.0213     .0349     .0235     .0054
   3 NI  2py     -.0062    -.0140    -.1244    -.3887     .2021     .0182
   4 NI  2py      .0042     .0037    -.0893     .8855    -.0520    -.0356
   5 NI  3d1-     .0053     .9993    -.0268     .0329     .0586    -.0005
   6 NI  3d1-    -.0002    -.0211     .5975     .1616     .1313    -.0044
   7 NI  3d1-    -.0012    -.0159    -.7930     .0733     .0616    -.0023
   8 NI  4f3-     .0064     .0000    -.0003     .0394    -.0132     .9991
   9 NI  4f1-     .0013    -.0049    -.0117     .1257    1.0211     .0085
  10 H   2py     -.0008     .0024     .0974    -.1614    -.2576     .0029
  11 H   2py      .0003    -.0057     .2060    -.2268    -.0768     .0079

     Molecular orbitals for symmetry species 4

     ORBITAL        1         2         3         4
     ENERGY      -.0799     .0000     .0000     .0000
     OCC. NO.    1.0000     .0000     .0000     .0000

   1 NI  3d2-    -.9877    -.0969     .0050    -.1226
   2 NI  3d2-    -.1527     .7651     .0019     .6255
   3 NI  3d2-    -.0332    -.6365    -.0043     .7705
   4 NI  4f2-     .0051    -.0037    1.0000     .0028

.. NOTE: contains a nbsp

In difficult situations it can be useful to employ the :kword:`AUFBau` option
of the :program:`SCF` program. Including this option, the subsequent
classification of the orbitals in the different symmetry representations
can be avoided. The program will look for the lowest-energy solution and will
provide with a final occupation. This option must be used with caution. It
is only expected to work in clear closed-shell situations.

We have only printed the orbitals most relevant to the following discussion.
Starting with symmetry 1 (|ao|) we observe that the orbitals
are not mixed at all. Using a basis set contracted to :math:`\ce{Ni}` 5s4p3d1f / :math:`\ce{H}` 3s2p
in symmetry |ao| we obtain 18 :math:`\sigma` molecular orbitals (combinations
from eight atomic |s| functions,
six |pz| functions, three |dzt| functions, and one |fztt| function)
and four :math:`\delta` orbitals (from three |dxtyt| functions and one |fz|
function). Orbitals 6, 10, 13, and 18 are formed by contributions from
the three |dxtyt| and one |fz| :math:`\delta` functions, while the
contributions of the remaining harmonics are zero. These orbitals are :math:`\delta` orbitals
and should not mix with the remaining |ao| orbitals.
The same situation occurs in symmetries |bo| and |bt| (2 and 3) but in this case
we observe an important mixing among the orbitals. Orbitals 7\ |bo| and 7\ |bt|
have main contributions from the harmonics 4f3+ (|fxtt|) and 4f3\ |-| (|fytt|),
respectively. They should be pure
:math:`\phi` orbitals and not mix at all with the remaining :math:`\pi` orbitals.

The first step is to evaluate the importance of the mixings
for future calculations. Strictly, any kind of mixing should be avoided.
If g functions are used, for instance, new contaminations show up. But,
undoubtedly, not all mixings are going to be equally important. If the
rotations occur among occupied or active orbitals the influence
on the results is going to be larger than if they are high secondary
orbitals. :math:`\ce{NiH}` is one of these cases. The ground state of the molecule
is :math:`^2\Delta`. It has two components and we can therefore compute it
by placing the single electron in the |dxy| orbital (leading to a
state of |at| symmetry in |Ctv|) or in the |dxtyt| orbital of the
|ao| symmetry. Both are :math:`\delta` orbitals and the resulting states
will have the same energy provided that no mixing happens. In the
|at| symmetry no mixing is possible because it is only composed
of :math:`\delta` orbitals but in |ao| symmetry the :math:`\sigma` and :math:`\delta` orbitals
can rotate. It is clear that this type of mixing will be more
important for the calculation than the mixing of :math:`\pi` and :math:`\phi`
orbitals. However it might be necessary to prevent it. Because in the
SCF calculation no high symmetry restriction was imposed on the orbitals,
orbitals 2 and 4
of the |bo| and |bt| symmetries have erroneous contributions of
the 4f3+ and 4f3\ |-| harmonics, and they are occupied or active
orbitals in the following CASSCF calculation.

.. index::
   single: Option; Supersymmetry
   single: Symmetry; Supersymmetry
   single: Program; RASSCF
   single: RASSCF; Supersymmetry

To use the supersymmetry (:kword:`SUPSym`) option we must
start with proper orbitals. In this case the |ao| orbitals are
symmetry adapted (within the printed accuracy) but not the
|bo| and |bt| orbitals. Orbitals 7\ |bo| and 7\ |bt|
must have zero coefficients for all the harmonics except for
4f3+ and 4f3\ |-|, respectively. The remaining orbitals of these
symmetries (even those not shown) must have zero in the
coefficients corresponding to 4f3+ or 4f3\ |-|. To clean the orbitals
the option :kword:`CLEAnup` of the :program:`RASSCF` program can be used.

Once the orbitals are properly symmetrized we can perform CASSCF
calculations on different electronic states. Deriving the types of the
molecular electronic states resulting from the electron configurations
is not simple in many cases. In general, for a given electronic
configuration several electronic states of the molecule will result.
Wigner and Witmer derived rules for determining what types of molecular
states result from given states of the separated atoms.
In chapter VI of reference :cite:`Herzberg:66` it is possible to
find the tables of the resulting electronic states once the
different couplings and the Pauli principle have been applied.

.. index::
   single: Active space
   single: Ground state

In the present CASSCF calculation we have chosen the active
space (3d, 4d, :math:`\sigma`, :math:`\sigma^*`) with all the 11 valence
electrons active. If we consider 4d and :math:`\sigma^*` as weakly occupied
correlating orbitals, we are left with 3d and :math:`\sigma` (six orbitals),
which are to be occupied with 11 electrons. Since the bonding
orbital :math:`\sigma` (composed mainly of :math:`\ce{Ni}` 4s and :math:`\ce{H}` 1s) will be doubly
occupied in all low lying electronic states, we are left with nine
electrons to occupy the 3d orbitals. There is thus one hole, and
the possible electronic states are: :math:`^2\Sigma^+`, :math:`^2\Pi`, and :math:`^2\Delta`,
depending on the orbital where the hole is located. Taking :numref:`tab:cc`
into account we observe that we have two low-lying electronic states
in symmetry 1 (:math:`A_1`): :math:`^2\Sigma^+` and :math:`^2\Delta`, and one in each of
the other three symmetries: :math:`^2\Pi` in symmetries 2 (:math:`B_1`) and 3 (:math:`B_2`),
and :math:`^2\Delta` in symmetry 4 (:math:`A_2`). It is not immediately obvious which
of these states is the ground state as they are close in energy. It may
therefore be necessary to study all of them. It has been found at different
levels of theory that the :math:`\ce{NiH}` has a :math:`^2\Delta` ground state :cite:`Pou:94`.

.. index::
   single: Excited states; NiH

We continue by computing the :math:`^2\Delta` ground state. The previous SCF
orbitals will be the initial orbitals for the CASSCF calculation. First
we need to know in which |Ctv| symmetry or symmetries we can compute
a :math:`\Delta` state. In the symmetry tables it is determined how the species
of the linear molecules are resolved into those of lower symmetry
(depends also on the orientation of the molecule). In :numref:`tab:cc`
is listed the assignment of the different symmetries for the molecule
placed on the :math:`z` axis.

.. index::
   single: Degenerate states

The :math:`\Delta` state has two degenerate components in symmetries |ao| and |at|.
Two CASSCF calculations can be performed, one computing
the first root of |at| symmetry and the second for the first root of |ao| symmetry.
The :program:`RASSCF` input for the state of |at| symmetry would be: ::

  &RASSCF &END
  Title
   NiH 2Delta CAS s, s*, 3d, 3d'.
  Symmetry
      4
  Spin
      2
  Nactel
     11    0    0
  Inactive
      5    2    2    0
  Ras2
      6    2    2    2
  Thrs
  1.0E-07,1.0E-05,1.0E-05
  Cleanup
  1
    4 6 10 13 18
   18 1 2 3 4 5 6 7 8 9 10 11 12 16 18 19 20 21 22
    4 13 14 15 17
  1
    1 7
    10 1 2 3 4 5 6 7 8 10 11
    1 9
  1
    1 7
    10 1 2 3 4 5 6 7 9 10 11
    1 8
  0
  Supsym
  1
     4 6 10 13 18
  1
     1 7
  1
     1 7
  0
  *Average
  *1 2 3
  Iter
  50,25
  LumOrb
  End of Input

The corresponding input for symmetry |ao| will be identical except
for the :kword:`SYMMetry` keyword ::

  Symmetry
      1

.. index::
   single: Symmetry Species; C∞v in C2v

.. table:: Resolution of the |Cinfv| species in the |Ctv| species.
   :name: tab:cc

   ====================== ======================
   State symmetry |Cinfv| State symmetry |Ctv|
   ====================== ======================
   :math:`\Sigma^+`       :math:`A_1`
   :math:`\Sigma^-`       :math:`A_2`
   :math:`\Pi`            :math:`B_1 + B_2`
   :math:`\Delta`         :math:`A_1 + A_2`
   :math:`\Phi`           :math:`B_1 + B_2`
   :math:`\Gamma`         :math:`A_1 + A_2`
   ====================== ======================

.. index::
   single: Option; Cleanup
   single: Symmetry; Cleanup
   single: RASSCF; Cleanup

In the :program:`RASSCF` inputs the :kword:`CLEAnup` option will take the initial orbitals
(SCF here)
and will place zeroes in all the coefficients of orbitals 6, 10, 13, and 18 in symmetry 1,
except in coefficients 13, 14, 15, and 17. Likewise all coefficients 13, 14, 15, and 17
of the remaining |ao| orbitals will be set to zero. The same procedure is used
in symmetries |bo| and |bt|. Once cleaned, and because of the :kword:`SUPSymmetry` option,
the :math:`\delta` orbitals 6, 10, 13, and 18 of |ao| symmetry
will only rotate among themselves and they will not mix with the remaining
|ao| :math:`\sigma` orbitals. The same holds true for :math:`\phi` orbitals 7\ |bo| and 7\ |bt|
in their respective symmetries.

Orbitals can change order during the calculation. |molcas| incorporates a
procedure to check the nature of the orbitals in each iteration. Therefore
the right behavior of the :kword:`SUPSym` option is guaranteed during the
calculation. The procedure can have problems if the initial orbitals are
not symmetrized properly. Therefore, the output with the final results
should be checked to compare the final order of the orbitals and the
final labeling of the :kword:`SUPSym` matrix.

.. index::
   single: Option; Average
   single: RASSCF; Average option
   single: Symmetry; Average
   single: Convergence problems; In RASSCF

The :kword:`AVERage` option would average the density matrices of symmetries 2 and 3,
corresponding to the :math:`\Pi` and :math:`\Phi` symmetries in |Cinfv|. In this case
it is not necessary to use the option because the two components of the
degenerate sets in symmetries |bo| and |bt| have the same occupation and
therefore they will have the same shape. The use of the option in a situation
like this (:math:`^2\Delta` and :math:`^2\Sigma^+` states) leads to convergence problems.
The symmetry of the orbitals in symmetries 2 and 3 is retained even if the
:kword:`AVERage` option is not used.

The output for the calculation on symmetry 4 (|at|) contains the following lines: ::

        Convergence after  29 iterations
         30   2    2    1 -1507.59605678    -.23E-11   3   9 1  -.68E-06  -.47E-05

                                    Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

        printout of CI-coefficients larger than   .05 for root   1
        energy=  -1507.596057
        conf/sym  111111 22 33 44     Coeff  Weight
           15834  222000 20 20 u0    .97979  .95998
           15838  222000 ud ud u0    .05142  .00264
           15943  2u2d00 ud 20 u0   -.06511  .00424
           15945  2u2d00 20 ud u0    .06511  .00424
           16212  202200 20 20 u0   -.05279  .00279
           16483  u220d0 ud 20 u0   -.05047  .00255
           16485  u220d0 20 ud u0    .05047  .00255

        Natural orbitals and occupation numbers for root  1
        sym 1:   1.984969   1.977613   1.995456    .022289    .014882    .005049
        sym 2:   1.983081    .016510
        sym 3:   1.983081    .016510
        sym 4:    .993674    .006884

.. NOTE: contains a nbsp

.. index::
   single: RASSCF; CI coefficients
   single: RASSCF; Natural occupation

The state is mainly (weight 96%) described by a single configuration
(configuration number 15834) which placed one electron on the first active
orbital of symmetry 4 (|at|) and the remaining electrons are paired.
A close look to this orbital indicates that is
has a coefficient |-|\.9989 in the first 3d2\ |-| (3\ |dxy|) function and small
coefficients in the other functions. This results clearly indicate that
we have computed the :math:`^2\Delta` state as the lowest root of that symmetry.
The remaining configurations have negligible contributions. If the orbitals
are properly symmetrized, all configurations will be compatible with a
:math:`^2\Delta` electronic state.

The calculation of the first root of symmetry 1 (|ao|) results: ::

        Convergence after  15 iterations
         16   2    3    1 -1507.59605678    -.19E-10   8  15 1   .35E-06  -.74E-05

                                    Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

        printout of CI-coefficients larger than   .05 for root   1
        energy=  -1507.596057
        conf/sym  111111 22 33 44     Coeff  Weight
           40800  u22000 20 20 20   -.97979  .95998
           42400  u02200 20 20 20    .05280  .00279

        Natural orbitals and occupation numbers for root  1
        sym 1:    .993674   1.977613   1.995456    .022289    .006884    .005049
        sym 2:   1.983081    .016510
        sym 3:   1.983081    .016510
        sym 4:   1.984969    .014882

.. NOTE: contains a nbsp

We obtain the same energy as in the previous calculation. Here the dominant
configuration places one electron on the first active orbital of symmetry 1 (|ao|).
It is important to remember that the orbitals are not ordered by energies or
occupations into the active space. This orbital has also the coefficient |-|\.9989
in the first 3d2\ |-| (3\ |dxtyt|) function. We have then computed the other
component of the :math:`^2\Delta` state. As the :math:`\delta` orbitals in different |Ctv|
symmetries are not averaged
by the program it could happen (not in the present case) that the two energies
differ slightly from each other.

The consequences of not using the :kword:`SUPSym` option are not extremely
severe in the present example. If you perform a calculation without the
option, the obtained energy is: ::

  Convergence after  29 iterations
   30   2    2    1 -1507.59683719    -.20E-11   3   9 1  -.69E-06  -.48E-05

As it is a broken symmetry solution the energy is lower than in the other
case. This is a typical behavior. If we were using an exact wave function
it would have the right symmetry properties, but approximated wave
functions do not necessarily fulfill this condition. So, more flexibility leads to
lower energy solutions which have broken the orbital symmetry.

If in addition to the :math:`^2\Delta` state we want to compute the lowest :math:`^2\Sigma^+`
state we can use the adapted orbitals from any of the :math:`^2\Delta` state
calculations and use the previous :program:`RASSCF` input without the
:kword:`CLEAnup` option. The orbitals have not changed place in this example.
If they do, one has to change the labels in the :kword:`SUPSym` option.
The simplest way to compute the lowest excited :math:`^2\Sigma^+` state
is having the unpaired electron in one of the :math:`\sigma` orbitals because none of
the other configurations, :math:`\delta^3` or :math:`\pi^3`, leads to the :math:`^2\Sigma^+` term.
However, there are more possibilities such as the configuration
:math:`\sigma^1\sigma^1\sigma^1`; three nonequivalent electrons in three
:math:`\sigma` orbitals. In actuality
the lowest :math:`^2\Sigma^+` state must be computed as a doublet state in symmetry
:math:`A_1`. Therefore, we set the symmetry in the RASSCF to 1 and compute the second
root of the symmetry (the first was the :math:`^2\Delta` state):

.. index::
   single: RASSCF; CIroot
   single: Excited states

::

  CIRoot
  1 2
  2

Of course the :kword:`SUPSym` option must be maintained.
The use of :kword:`CIROot` indicates that we are computing the second root
of that symmetry. The obtained result: ::

        Convergence after  33 iterations
          9   2    3    2 -1507.58420263    -.44E-10   2  11 2  -.12E-05   .88E-05

                                    Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

        printout of CI-coefficients larger than   .05 for root   1
        energy=  -1507.584813
        conf/sym  111111 22 33 44     Coeff  Weight
           40800  u22000 20 20 20   -.97917  .95877

        printout of CI-coefficients larger than   .05 for root   2
        energy=  -1507.584203
        conf/sym  111111 22 33 44     Coeff  Weight
           40700  2u2000 20 20 20    .98066  .96169

        Natural orbitals and occupation numbers for root  2
        sym 1:   1.983492    .992557   1.995106    .008720    .016204    .004920
        sym 2:   1.983461    .016192
        sym 3:   1.983451    .016192
        sym 4:   1.983492    .016204

.. NOTE: contains a nbsp

As we have used two as the dimension of the CI matrix employed in the CI Davidson
procedure we obtain the wave function of two roots, although the optimized
root is the second. Root 1 places one electron in the first active orbital
of symmetry one, which is a 3d2+ (3\ |dxtyt|) :math:`\delta` orbital. Root 2 places
the electron in the second active orbital, which is a :math:`\sigma` orbital with a
large coefficient (.9639) in the first 3d0 (3\ |dzt|) function of the nickel
atom. We have therefore computed the lowest :math:`^2\Sigma^+` state. The two :math:`^2\Sigma^+` states
resulting from the configuration with the three unpaired :math:`\sigma` electrons
is higher in energy at the CASSCF level. If the second root of symmetry |ao|
had not been a :math:`^2\Sigma^+` state we would have to study higher roots of the
same symmetry.

.. index::
   single: Orbitals; Active

It is important to remember that the active orbitals are not ordered at all
within the active space. Therefore, their order might vary from calculation
to calculation and, in addition, no conclusions about the orbital energy,
occupation or any other information can be obtained from the
order of the active orbitals.

We can compute also the lowest :math:`^2\Pi` excited state.
The simplest possibility is having the configuration :math:`\pi^3`,
which only leads to one :math:`^2\Pi` state. The unpaired electron
will be placed in either one |bo| or one |bt| orbital. That means
that the state has two degenerate components and we can compute it
equally in both symmetries. There are more possibilities, such as the
configuration :math:`\pi^3\sigma^1\sigma^1` or the configuration :math:`\pi^3\sigma^1\delta^1`.
The resulting :math:`^2\Pi` state will always have two degenerate
components in symmetries
|bo| and |bt|, and therefore it is the wave function analysis which
gives us the information of which configuration leads to
the lowest :math:`^2\Pi` state.

.. index::
   single: Convergence problems; In RASSCF

For :math:`\ce{NiH}` it turns out to be non trivial to compute the :math:`^2\Pi` state.
Taking as initial orbitals
the previous SCF orbitals and using any type of restriction such as
the :kword:`CLEAnup`, :kword:`SUPSym` or :kword:`AVERage` options lead to
severe convergence problems like these: ::

   45   9   17    1 -1507.42427683    -.65E-02   6  18 1  -.23E-01  -.15E+00
   46   5   19    1 -1507.41780710     .65E-02   8  15 1   .61E-01  -.15E+00
   47   9   17    1 -1507.42427683    -.65E-02   6  18 1  -.23E-01  -.15E+00
   48   5   19    1 -1507.41780710     .65E-02   8  15 1   .61E-01  -.15E+00
   49   9   17    1 -1507.42427683    -.65E-02   6  18 1  -.23E-01  -.15E+00
   50   5   19    1 -1507.41780710     .65E-02   8  15 1   .61E-01  -.15E+00

  No convergence after  50 iterations
   51   9   19    1 -1507.42427683    -.65E-02   6  18 1  -.23E-01  -.15E+00

.. NOTE: contains nbsp

The calculation, however, converges in an straightforward way if none of those tools are used: ::

        Convergence after  33 iterations
         34   2    2    1 -1507.58698677    -.23E-12   3   8 2  -.72E-06  -.65E-05

                                    Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

        printout of CI-coefficients larger than   .05 for root   1
        energy=  -1507.586987
        conf/sym  111111 22 33 44     Coeff  Weight
           15845  222000 u0 20 20    .98026  .96091
           15957  2u2d00 u0 ud 20    .05712  .00326
           16513  u220d0 u0 20 ud   -.05131  .00263

        Natural orbitals and occupation numbers for root  1
        sym 1:   1.984111   1.980077   1.995482    .019865    .015666    .004660
        sym 2:    .993507    .007380
        sym 3:   1.982975    .016623
        sym 4:   1.983761    .015892

.. NOTE: contains a nbsp

The :math:`\pi` (and :math:`\phi`) orbitals, both in symmetries |bo| and |bt|, are, however,
differently occupied and therefore are not equal as they should be: ::

     Molecular orbitals for sym species 2     Molecular orbitals for symmetry species 3

     ORBITAL        3         4               ORBITAL        3         4
     ENERGY       .0000     .0000             ENERGY       .0000     .0000
     OCC. NO.     .9935     .0074             OCC. NO.    1.9830     .0166

   1 NI  2px      .0001     .0002           1 NI  2py      .0018    -.0001
   2 NI  2px      .0073     .0013           2 NI  2py      .0178    -.0002
   3 NI  2px     -.0155     .0229           3 NI  2py     -.0197    -.0329
   4 NI  2px      .0041     .0227           4 NI  2py      .0029    -.0254
   5 NI  3d1+     .9990    -.0199           5 NI  3d1-     .9998    -.0131
   6 NI  3d1+    -.0310    -.8964           6 NI  3d1-     .0128     .9235
   7 NI  3d1+    -.0105     .4304           7 NI  3d1-     .0009    -.3739
   8 NI  4f1+    -.0050     .0266           8 NI  4f3-     .0001    -.0003
   9 NI  4f3+     .0001     .0000           9 NI  4f1-    -.0050    -.0177
  10 H   2px      .0029    -.0149          10 H   2py      .0009     .0096
  11 H   2px     -.0056    -.0003          11 H   2py     -.0094    -.0052

.. NOTE: contains a nbsp

Therefore what we have is a symmetry broken solution. To obtain a solution which
is not of broken nature the :math:`\pi` and :math:`\phi` orbitals must be equivalent.
The tool to obtain equivalent orbitals is the :kword:`AVERage` option, which averages
the density matrices of symmetries |bo| and |bt|. But starting with any of the preceding
orbitals and using the :kword:`AVERage` option lead again to convergence problems.
It is necessary to use better initial orbitals; orbitals which have
already equal orbitals in symmetries |bo| and |bt|. One possibility is to perform a
SCF calculation on the :math:`\ce{NiH^+}` cation explicitly indicating occupation one in the two
higher occupied :math:`\pi` orbitals (symmetries 2 and 3):

.. index::
   single: SCF; OccNumbers

::

  &SCF &END
  TITLE
   NiH cation
  OCCUPIED
   8 3 3 1
  OCCNO
  2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0
  2.0 2.0 1.0                      <-- Note the extra occupation
  2.0 2.0 1.0                      <-- Note the extra occupation
  2.0
  IVO
  END OF INPUT

It can take some successive steps to obtain a converged calculation using the
:kword:`CLEAnup`, :kword:`SUPSym`, and :kword:`AVERage` options. The calculation
with a single root did not converge clearly. We obtained, however, a converged
result for the lowest :math:`^2\Pi` state of :math:`\ce{NiH}`
by computing two averaged CASSCF roots and setting a weight of
90% for the first root using the keyword:

.. index::
   single: RASSCF; CIroot
   single: Option; CIroot
   single: RASSCF; Average states
   single: Average states

::

  CIROot
   2 2
   1 2
   9 1

::

                              Wave function printout:
  occupation of active orbitals, and spin coupling of open shells (u,d: Spin up or down)

       printout of CI-coefficients larger than   .05 for root   1
       energy=  -1507.566492
       conf/sym  111111 22 33 44     Coeff  Weight
           4913  222u00 20 d0 u0   -.05802  .00337
          15845  222000 u0 20 20    .97316  .94703
          15953  2u2d00 u0 20 20    .05763  .00332
          16459  2u20d0 u0 20 ud   -.05283  .00279

       Natural orbitals and occupation numbers for root  1
       sym 1:   1.972108   1.982895   1.998480    .028246    .016277    .007159
       sym 2:    .997773    .007847
       sym 3:   1.978019    .016453
       sym 4:   1.978377    .016366

.. NOTE: contains a nbsp

The energy of the different states (only the first one shown above) is
printed on the top of their configuration list. The converged energy is
simply an average energy.
The occupation numbers obtained in the section of the :program:`RASSCF` output printed
above are the occupation numbers of the natural orbitals of the corresponding
root. They differ from the occupation numbers printed in the
molecular orbital section where we have pseudonatural molecular orbitals and
average occupation numbers. On top of each of the valence :math:`\pi` orbitals
an average occupation close to 1.5 will be printed; this is a consequence
of the the averaging procedure.

.. index::
   single: Natural occupation
   single: Orbitals; Natural

The results obtained are only at the CASSCF level. Additional effects have to
be considered and included. The most important of them is the dynamical correlation
effect which can be added by computing, for instance, the CASPT2 energies. The reader can find
a detailed explanation of the different approaches in ref. :cite:`Pou:94`, and a
careful discussion of their consequences and solutions in ref. :cite:`Taylor:92b`.

.. index::
   single: Relativistic effects
   single: Option; Relint
   single: SEWARD; Relint

We are going, however, to point out some details. In the first place the basis set
must include up to g functions for the transition metal atom and up to d
functions for the hydrogen. Relativistic effects must be taken into account,
at least in a simple way as a first order correction. The keyword :kword:`RELInt`
must be then included in the :program:`SEWARD` input to compute the mass-velocity and
one-electron Darwin contact term integrals and obtain a first-order correction
to the energy with respect to relativistic effects at the CASSCF level in the :program:`RASSCF` output.
Scalar relativistic effects can be also included according the Douglas--Kroll
or the Barysz--Sadlej--Snijders transformations, as it will be explained in
:numref:`TUT:sec:SOC`.

The CASPT2 input needed to compute the second-order correction to the energy
will include the number of the CASSCF root to compute. For instance,
for the first root of each symmetry:

.. index::
   single: CASPT2

::

  &CASPT2 &END
  Title
   NiH
  Frozen
  5 2 2 0
  Maxit
  30
  Lroot
  1
  End of input

.. index::
   single: Orbitals; Frozen
   single: Option; Frozen
   single: CASPT2; Frozen
   single: Core; Core correlation

The number of frozen orbitals taken by :program:`CASPT2` will be that specified in the :program:`RASSCF` input
except if this is changed in the :program:`CASPT2` input. In the perturbative step
we have frozen all the occupied orbitals except the active ones. This is motivated by
the desire to include exclusively the dynamical correlation related to the valence
electrons. In this way we neglect correlation between core electrons, named core-core
correlation, and between core and valence electrons, named core-valence correlation.
This is not because the calculation is smaller but because of the inclusion of those
type of correlation in a calculation designed to treat valence correlation is an
inadequate approach. Core-core and core-valence correlation requires additional basis
functions of the same spatial extent as the occupied orbitals being correlated, but
with additional radial and angular nodes. Since the spatial extent of the core
molecular orbitals is small, the exponents of these correlating functions must be
much larger than those of the valence optimized basis sets. The consequence is that
we must avoid the inclusion of the core electrons in the treatment in the first step.
Afterwards, the amount of correlation introduced by the core electrons can be estimated
in separated calculations for the different states and those effects added to the
results with the valence electrons.

.. index::
   single: Core; core–valence correlation

Core-valence correlation effects of the 3s and 3p nickel shells can be studied by
increasing the basis set flexibility by uncontracting the
basis set in the appropriate region. There are different possibilities. Here we show
the increase of the basis set by four s, four p, and four d functions. f
functions contribute less to the description of the 3s and 3p shells and can be
excluded. The uncontracted exponents should correspond to the region where the 3s
and 3p shells present their density maximum. Therefore, first we compute the absolute
maxima of the radial distribution of the involved orbitals, then we determine the primitive
gaussian functions which have their maxima in the same region as the orbitals and therefore
which exponents should be uncontracted. The final basis set will be the valence basis set
used before plus the new added functions. In the present example the SEWARD
input can be:

.. index::
   single: SEWARD; Inline
   single: Basis set; Inline
   single: Basis set; Extension

.. extractfile:: advanced/SEWARD.NiH.input

  &SEWARD &END
  Title
   NiH G.S.
  Symmetry
  X Y
  *RelInt
  Basis set
  Ni.ANO-L...5s4p3d1f.
  Ni    0.00000   0.00000   0.000000   Bohr
  End of basis
  Basis set
  Ni....4s4p4d. / Inline
   0.  2
  * Additional s functions
   4 4
  3.918870 1.839853 0.804663 0.169846
   1. 0. 0. 0.
   0. 1. 0. 0.
   0. 0. 1. 0.
   0. 0. 0. 1.
  * Additional p functions
   4 4
  2.533837 1.135309 0.467891 0.187156
   1. 0. 0. 0.
   0. 1. 0. 0.
   0. 0. 1. 0.
   0. 0. 0. 1.
  * Additional d functions
   4 4
  2.551303 1.128060 0.475373 0.182128
   1. 0. 0. 0.
   0. 1. 0. 0.
   0. 0. 1. 0.
   0. 0. 0. 1.
  Nix   0.00000   0.00000   0.000000   Bohr
  End of basis
  Basis set
  H.ANO-L...3s2p.
  H     0.000000  0.000000  2.747000   Bohr
  End of basis
  End of Input

.. index::
   single: Option; Charge
   single: SEWARD; Charge

.. compound::

  We have used a special format to include the additional functions.
  We include the additional 4s4p4d functions for the nickel atom.
  The additional basis set input must use a dummy label (``Nix`` here), the
  same coordinates of the original atom, and
  specify a :kword:`CHARge` equal to zero, whether in an Inline basis set
  input as here or by specifically using keyword :kword:`CHARge`. It is not
  necessary to include the basis set with the Inline format. A library can
  be created for this purpose. In this case the label for the additional
  functions could be:

  .. index::
     single: Basis set; Extension

  ::

    Ni.Uncontracted...4s4p4d. / AUXLIB
    Charge
    0

  .. index::
     single: Basis set; Auxiliary libraries

  and a proper link to AUXLIB should be included in the script (or in the
  input if one uses AUTO).

Now the CASPT2 is going to be different to include also
the correlation related to the 3s,3p shell of the nickel atom. Therefore,
we only freeze the 1s,2s,2p shells: ::

  &CASPT2 &END
  Title
   NiH. Core-valence.
  Frozen
  3 1 1 0
  Maxit
  30
  Lroot
  1
  End of input

.. index::
   single: BSSE Effect

A final effect one should study is the basis set superposition error (BSSE).
In many cases it is a minor effect but it is an everpresent phenomenon
which should be investigated when high accuracy is required, especially in
determining bond energies, and not only in cases with weakly interacting
systems, as is frequently believed. The most common approach to estimate
this effect is the counterpoise correction: the separated fragment energies
are computed in the total basis set of the system. For a discussion of this
issue see Refs. :cite:`Taylor:92b,Gonzalez:94`. In the present example
we would compute the energy of the isolated nickel atom using a SEWARD input
including the full nickel basis set plus the hydrogen basis set in the
hydrogen position but with the charge set to zero. And then the opposite
should be done to compute the energy of isolated hydrogen. The BSSE depends
on the separation of the fragments and must be
estimated at any computed geometry. For instance, the SEWARD input necessary
to compute the isolated hydrogen atom at a given distance from the ghost
nickel basis set including core uncontracted functions is:

.. index::
   single: Basis set; Ghost

.. extractfile:: advanced/BSSE.NiH.sample

  >>UNIX mkdir AUXLIB
  >>COPY $CurrDir/NiH.NewLib AUXLIB/UNCONTRACTED
  &SEWARD &END
  Title
   NiH. 3s3p + H (BSSE)
  Symmetry
  X Y
  RelInt
  Basis set
  Ni.ANO-L...5s4p3d1f.
  Ni    0.00000   0.00000   0.000000   Bohr
  Charge
  0.0
  End of basis
  Basis set
  Ni.Uncontracted...4s4p4d. / AUXLIB
  Nix   0.00000   0.00000   0.000000   Bohr
  Charge
  0.0
  End of basis
  Basis set
  H.ANO-L...3s2p.
  H     0.000000  0.000000  2.747000   Bohr
  End of basis
  End of Input

Once the energy of each of the fragments with the corresponding ghost
basis set of the other fragment is determined, the energies of the
completely isolated fragments can be computed and subtracted from those
which have the ghost basis sets. Other approaches used to estimate
the BSSE effect are discussed in Ref. :cite:`Taylor:92b`.

The results obtained at the CASPT2 level are close to those obtained by
MRCI+Q and ACPF treatments but more accurate. They match well with experiment.
The difference is that all the configuration functions (CSFs) of the active
space can be included in CASPT2 in the zeroth-order references for the second-order
perturbation calculation :cite:`Pou:94`, while the other methods have to restrict
the number of configurations.

Calculations of linear molecules become more and more complicated when the
number of unpaired electrons increases. In the following sections we will discuss
the more complicated situation occurring in the :math:`\ce{Ni2}` molecule.

.. _TUT\:sec\:c2:

A diatomic homonuclear molecule: :math:`\ce{C2}`
------------------------------------------------

.. index::
   single: Linear molecules; C2
   single: C2

:math:`\ce{C2}` is a classical example of a system where near-degeneracy effects have large
amplitudes even near the equilibrium internuclear separation. The biradical
character of the ground state of the molecule suggest that a single
configurational treatment will not be appropriate for accurate descriptions
of the spectroscopic constants :cite:`Roos:87`.
There are two nearly degenerate states: :math:`^1\Sigma_g^+` and :math:`^3\Pi_u`. The latter
was earlier believed to be the ground state, an historical assignment which can
be observed in the traditional labeling of the states.

As :math:`\ce{C2}` is a |Dinfh| molecule, we have to compute it in |Dth| symmetry. We
make a similar analysis as for the |Ctv| case. We begin by
classifying the functions in |Dinfh| in :numref:`tab:dinfh`.
The molecule is placed on the :math:`z` axis.

.. index::
   single: Spherical Harmonics; D∞h

.. table:: Classification of the spherical harmonics in the |Dinfh| group\ [#b]_.
   :name: tab:dinfh

   ================ ======= ======= ======= =======
   Symmetry         Spherical harmonics
   ================ ===============================
   :math:`\sigma_g` |s|     |dzt|
   :math:`\sigma_u` |pz|    |dzt|
   :math:`\pi_g`    |dxz|   |dyz|
   :math:`\pi_u`    |px|    |py|    |fx|    |fy|
   :math:`\delta_g` |dxtyt| |dxy|
   :math:`\delta_u` |fxyz|  |fz|
   :math:`\phi_u`   |fxtt|  |fytt|
   ================ ======= ======= ======= =======

.. [#b] Functions placed on the symmetry center.

:numref:`tab:d2h` classifies
the functions and orbitals into the symmetry representations of the |Dth|
symmetry. Note that in :numref:`tab:d2h` subindex :math:`b` stands for bonding combination and
:math:`a` for antibonding combination.

.. index::
   single: Spherical Harmonics; D2h

.. table:: Classification of the spherical harmonics and |Dinfh| orbitals in the |Dth| group\ [#c]_.
   :name: tab:d2h

   ============ ====================================== ====================================== ====================================== ====================================== ====================================== ======================================
   Symm.\ [#d]_ Spherical harmonics (orbitals in |Dinfh|)
   ============ =========================================================================================================================================================================================================================================
   |ag|\(1)     |s|\ :math:`_b` (:math:`\sigma_g`)     |pz|\ :math:`_b` (:math:`\sigma_g`)    |dzt|\ :math:`_b` (:math:`\sigma_g`)   |dxtyt|\ :math:`_b` (:math:`\delta_g`) |fztt|\ :math:`_b` (:math:`\sigma_g`)  |fz|\ :math:`_b` (:math:`\delta_g`)
   |bttu|\(2)   |px|\ :math:`_b` (:math:`\pi_u`)       |dxz|\ :math:`_b` (:math:`\pi_u`)      |fx|\ :math:`_b` (:math:`\pi_u`)       |fxtt|\ :math:`_b` (:math:`\phi_u`)
   |btu|\(3)    |py|\ :math:`_b` (:math:`\pi_u`)       |dyz|\ :math:`_b` (:math:`\pi_u`)      |fy|\ :math:`_b` (:math:`\pi_u`)       |fytt|\ :math:`_b` (:math:`\phi_u`)
   |bog|\(4)    |dxy|\ :math:`_b` (:math:`\delta_g`)   |fxyz|\ :math:`_b` (:math:`\delta_g`)
   |bou|\(5)    |s|\ :math:`_a` (:math:`\sigma_u`)     |pz|\ :math:`_a` (:math:`\sigma_u`)    |dzt|\ :math:`_a` (:math:`\sigma_u`)   |dxtyt|\ :math:`_a` (:math:`\delta_u`) |fztt|\ :math:`_a` (:math:`\sigma_u`)  |fz|\ :math:`_a` (:math:`\delta_u`)
   |btg|\(6)    |py|\ :math:`_a` (:math:`\pi_g`)       |dyz|\ :math:`_a` (:math:`\pi_g`)      |fy|\ :math:`_a` (:math:`\pi_g`)       |fytt|\ :math:`_a` (:math:`\phi_g`)
   |bttg|\(7)   |px|\ :math:`_a` (:math:`\pi_g`)       |dxz|\ :math:`_a` (:math:`\pi_g`)      |fx|\ :math:`_a` (:math:`\pi_g`)       |fxtt|\ :math:`_a` (:math:`\phi_g`)
   |au|\(8)     |dxy|\ :math:`_a` (:math:`\delta_u`)   |fxyz|\ :math:`_a` (:math:`\delta_u`)
   ============ ====================================== ====================================== ====================================== ====================================== ====================================== ======================================

.. [#c] Subscripts :math:`b` and :math:`a` refer to the bonding and antibonding combination of the AO's, respectively.
.. [#d] In parenthesis the number of the symmetry in |molcas|. Note that the number and order of the
        symmetries depend on the generators and the orientation of the molecule.

The order of the symmetries, and therefore the number they have in |molcas|, depends
on the generators used in the :program:`SEWARD` input. This must be carefully checked
at the beginning of any calculation. In addition, the orientation of the molecule on the
cartesian axis can change the labels of the symmetries. In :numref:`tab:d2h` for
instance we have used the order and numbering of a calculation performed with the
three symmetry planes of the |Dth| point group (X Y Z in the :program:`SEWARD` input)
and the :math:`z` axis as the intermolecular axis (that is, :math:`x` and :math:`y` are equivalent in |Dth|).
Any change in the orientation of the molecule will affect the labels of the orbitals
and states. In this case the :math:`\pi` orbitals will belong to the |bttu|, |btu|,
|btg|, and |bttg| symmetries. For instance, with :math:`x` as the intermolecular axis |bttu| and |bttg| will
be replaced by |bou| and |bog|, respectively, and finally with :math:`y` as the intermolecular axis
|bou|, |bttu|, |bttg|, and |bog| would be the :math:`\pi` orbitals.

It is important to remember that |molcas| works with symmetry adapted basis functions.
Only the symmetry independent atoms are required in the :program:`SEWARD` input. The remaining
ones will be generated by the symmetry operators. This is also the case for the
molecular orbitals. |molcas| will only print the coefficients of the symmetry adapted
basis functions.

.. index::
   single: Symmetry; Adapted basis functions

The necessary information to obtain the complete set of orbitals
is contained in the SEWARD output. Consider the case of the |ag| symmetry: ::

                      **************************************************
                      ******** Symmetry adapted Basis Functions ********
                      **************************************************

             Irreducible representation : ag
             Basis function(s) of irrep:

   Basis Label        Type   Center Phase Center Phase
     1   C            1s0       1     1      2     1
     2   C            1s0       1     1      2     1
     3   C            1s0       1     1      2     1
     4   C            1s0       1     1      2     1
     5   C            2pz       1     1      2    -1
     6   C            2pz       1     1      2    -1
     7   C            2pz       1     1      2    -1
     8   C            3d0       1     1      2     1
     9   C            3d0       1     1      2     1
    10   C            3d2+      1     1      2     1
    11   C            3d2+      1     1      2     1
    12   C            4f0       1     1      2    -1
    13   C            4f2+      1     1      2    -1

.. NOTE: contains a nbsp

The previous output indicates that symmetry adapted basis function 1,
belonging to the |ag| representation, is formed by
the symmetric combination of a s type function centered on atom C and
another s type function centered on the redundant center 2, the second
carbon atom. Combination s+s constitutes a bonding :math:`\sigma_g`\-type
orbital. For the |pz| function however the combination must be
antisymmetric. It is the only way to make the |pz| orbitals overlap
and form a bonding orbital of |ag| symmetry. Similar combinations are obtained for the
remaining basis sets of the |ag| and other symmetries.

The molecular orbitals will be combinations of these symmetry adapted
functions. Consider the |ag| orbitals: ::

     SCF orbitals

     Molecular orbitals for symmetry species 1

     ORBITAL        1         2         3         4         5         6
     ENERGY    -11.3932   -1.0151    -.1138     .1546     .2278     .2869
     OCC. NO.    2.0000    2.0000     .0098     .0000     .0000     .0000

   1 C   1s0     1.4139    -.0666    -.0696     .2599     .0626     .0000
   2 C   1s0      .0003    1.1076    -.6517    1.0224     .4459     .0000
   3 C   1s0      .0002    -.0880    -.2817     .9514     .0664     .0000
   4 C   1s0      .0000    -.0135    -.0655     .3448    -.0388     .0000
   5 C   2pz     -.0006    -.2581   -1.2543    1.1836     .8186     .0000
   6 C   2pz      .0000     .1345    -.0257    2.5126    1.8556     .0000
   7 C   2pz      .0005    -.0192    -.0240     .7025     .6639     .0000
   8 C   3d0      .0003     .0220    -.0005    -.9719     .2430     .0000
   9 C   3d0     -.0001    -.0382    -.0323    -.8577     .2345     .0000
  10 C   3d2+     .0000     .0000     .0000     .0000     .0000    -.7849
  11 C   3d2+     .0000     .0000     .0000     .0000     .0000    -.7428
  12 C   4f0     -.0002    -.0103    -.0165     .0743     .0081     .0000
  13 C   4f2+     .0000     .0000     .0000     .0000     .0000    -.0181

.. NOTE: contains a nbsp

In |molcas| outputs only 13 coefficients for orbital are going to be printed
because they are the coefficients of the symmetry adapted basis
functions. If the orbitals were not composed by symmetry adapted basis
functions they would have, in this case, 26 coefficients, two for type of
function (following the scheme observed above in the :program:`SEWARD` output),
symmetrically combined the s and d functions and antisymmetrically
combined the p and f functions.

To compute |Dinfh| electronic states using the |Dth| symmetry we need
to go to the symmetry tables and determine how the species
of the linear molecules are resolved into those of lower symmetry
(this depends also on the orientation of the molecule :cite:`Herzberg:66`).
:numref:`tab:dd` lists the case of a |Dinfh| linear molecule with :math:`z` as
the intermolecular axis.

.. index::
   single: Symmetry; D∞h in D2h

.. table:: Resolution of the |Dinfh| species in the |Dth| species.
   :name: tab:dd

   ======================== ========================
   State symmetry |Dinfh|   State symmetry |Dth|
   ======================== ========================
   :math:`\Sigma^+_g`       :math:`A_g`
   :math:`\Sigma^+_u`       :math:`B_{1u}`
   :math:`\Sigma^-_g`       :math:`B_{1g}`
   :math:`\Sigma^-_u`       :math:`A_u`
   :math:`\Pi_g`            :math:`B_{2g} + B_{3g}`
   :math:`\Pi_u`            :math:`B_{2u} + B_{3u}`
   :math:`\Delta_g`         :math:`A_{g} + B_{1g}`
   :math:`\Delta_u`         :math:`A_{u} + B_{1u}`
   :math:`\Phi_g`           :math:`B_{2g} + B_{3g}`
   :math:`\Phi_u`           :math:`B_{2u} + B_{3u}`
   :math:`\Gamma_g`         :math:`A_{g} + B_{1g}`
   :math:`\Gamma_u`         :math:`A_{u} + B_{1u}`
   ======================== ========================

.. index::
   single: Ground state
   single: RASSCF; Supersymmetry
   single: Option; Supersymmetry
   single: Symmetry; Supersymmetry

To compute the ground state of :math:`\ce{C2}`, a :math:`^1\Sigma_g^+` state, we will
compute a singlet state of symmetry :math:`A_g` (1 in this context).
The input files for a CASSCF calculation on the :math:`\ce{C2}` ground state
will be:

.. extractfile:: advanced/RASSCF.supersymmetry.input

  &SEWARD &END
  Title
   C2
  Symmetry
    X  Y  Z
  Basis set
  C.ANO-L...4s3p2d1f.
  C        .00000000    .00000000     1.4
  End of basis
  End of input

  &SCF &END
  Title
   C2
  ITERATIONS
   40
  Occupied
    2  1  1  0  2  0  0  0
  End of input

  &RASSCF &END
  Title
   C2
  Nactel
    4  0  0
  Spin
    1
  Symmetry
    1
  Inactive
    2  0  0  0  2  0  0  0
  Ras2
    1  1  1  0  1  1  1  0
  *Average
  *2 2 3 6 7
  Supsymmetry
  1
   3 6 9 11
  1
   1 6
  1
   1 6
  0
  1
   3 5 8 12
  1
   1 6
  1
   1 6
  0
  Iter
  50,25
  Lumorb
  End of input

In this case the SCF orbitals are already clean symmetry adapted orbitals
(within the printed accuracy).
We can then directly use the :kword:`SUPSym` option. In symmetries
|ag| and |bou| we restrict the rotations among the :math:`\sigma` and
the :math:`\delta` orbitals, and in symmetries |bttu|, |btu|, |btg|, and
|bttg| the rotations among :math:`\pi` and :math:`\phi` orbitals. Additionally,
symmetries |bttu| and |btu| and symmetries |btg| and
|bttg| are averaged, respectively, by using
the :kword:`AVERage` option. They belong to the :math:`\Pi_u` and
:math:`\Pi_g` representations in |Dinfh|, respectively.

A detailed explanation on different CASSCF calculations on the :math:`\ce{C2}`
molecule and their states can be found elsewhere :cite:`Roos:87`.
Instead we include here an example of how to combine the use of
UNIX shell script commands with |molcas| as a powerful tool.

The following example computes the transition dipole moment for the transition
from the :math:`^1\Sigma_g^+` state to the :math:`^1\Pi_u` state in the :math:`\ce{C2}`
molecule. This transition is known as the Phillips bands :cite:`Herzberg:66`.
This is not a serious attempt to compute this property accurately, but serves
as an example of how to set up an automatic calculation.
The potential curves are computed using CASSCF wavefunctions
along with the transition dipole moment.

.. index::
   single: Excited states; C2

Starting orbitals are generated by computing a CI wavefunction once and
using the natural orbitals. We loop over a set of distances, compute the
CASSCF wave functions for both states and use :program:`RASSI` to compute the TDMs.
Several UNIX commands are used to manipulate input and output files,
such as grep, sed, and the *awk* language. For instance, an explicit "sed"
is used to insert the geometry into the seward input; the final CASSCF
energy is extracted with an explicit "grep", and the TDM is extracted from the
RASSI output using an *awk* script. We are not going to include the *awk* scripts
here. Other tools can be used to obtain and collect the data.

In the first script, when the loop over geometries is done, four files are available:
geom.list (contains the distances), tdm.list (contains the TDMs),
e1.list (contains the energy for the :math:`^1\Sigma_g^+` state), and
e2.list (contains the energy for the :math:`^1\Pi_u` state). In the second script the vibrational
wave functions for the two states and the vibrationally averaged TDMs
are now computed using the :program:`VIBROT` program. We will retain the RASSCF outputs
in the scratch directory to check the wave function. It is always dangerous
to assume that the wave functions will be correct in a CASSCF calculation.
Different problems such as root flippings or incorrect orbitals rotating into the
active space are not uncommon. Also, it is always necessary to control that the
CASSCF calculation has converged. The first script (Korn shell) is:

.. index::
   single: Shell script

::

  #!/bin/ksh
  #
  # perform some initializations
  #
  export Project='C2'
  export WorkDir=/temp/$LOGNAME/$Project
  export Home=/u/$LOGNAME/$Project
  echo "No log" > current.log
  trap 'cat current.log ; exit 1' ERR
  mkdir $WorkDir
  cd $WorkDir
  #
  # Loop over the geometries and generate input for vibrot
  #
  list="1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 5.0 10.0"
  scf='yes'
  print "Sigma" > e1.list
  print "Pi" > e2.list
  for geom in $list
  do
     #--- run seward
     print "Dist $geom" >> geom.list
     sed -e "s/#/$geom/" $Home/$Project.seward.input > seward.input
     molcas seward.input > current.log
     #--- optionally run scf, motra, guga and mrci to obtain good starting orbitals
     if [ "$scf" = 'yes' ]
     then
        scf='no'
        molcas    $Home/$Project.scf.input > current.log
        molcas    $Home/$Project.motra.input > current.log
        molcas    $Home/$Project.guga.input > current.log
        molcas    $Home/$Project.mrci.input > current.log
        cp $Project.CiOrb $Project.RasOrb1
        cp $Project.CiOrb $Project.RasOrb2
     fi
     #--- rasscf wavefunction for 1Sg+
     ln -fs $Project.Job001 JOBIPH
     ln -fs $Project.RasOrb1 INPORB
     molcas   $Home/$Project.rasscf1.input > current.log
     cat current.log >> rasscf1.log
     cat current.log | grep -i 'average ci' >> e1.list
     cp $Project.RasOrb $Project.RasOrb1
     rm -f JOBIPH INPORB
     #--- rasscf wavefunction for 1Pu
     ln -fs $Project.Job002 JOBIPH
     ln -fs $Project.RasOrb2 INPORB
     molcas   $Home/$Project.rasscf2.input > current.log
     cat current.log >> rasscf2.log
     cat current.log | grep -i 'average ci' >> e2.list
     cp $Project.RasOrb $Project.RasOrb2
     rm -f JOBIPH INPORB
     #--- rassi to obtain transition
     ln -fs $Project.Job001 JOB001
     ln -fs $Project.Job002 JOB002
     molcas   $Home/$Project.rassi.input > current.log
     awk -f $Home/tdm.awk current.log >> tdm.list
     rm -f JOB001 JOB002
     #---
  done
  #
  # Finished so clean up the files.
  #
  print "Calculation finished" >&2
  cd -
  rm $WorkDir/molcas.temp*
  #rm -r $WorkDir
  exit 0

In a second script we will compute the vibrational wave functions ::

  #!/bin/ksh
  #
  # perform some initializations
  #
  export Project='C2'
  export WorkDir=/temp/$LOGNAME/$Project
  export Home=/u/$LOGNAME/$Project
  echo "No log" > current.log
  trap 'cat current.log ; exit 1' ERR
  mkdir $WorkDir
  cd $WorkDir
  #
  # Build vibrot input
  #
  cp e1.list $Home
  cp e2.list $Home
  cp geom.list $Home
  cp tdm.list $Home
  #---
  cat e1.list geom.list | awk -f $Home/wfn.awk > vibrot1.input
  cat e2.list geom.list | awk -f $Home/wfn.awk > vibrot2.input
  cat tdm.list geom.list | awk -f $Home/tmc.awk > vibrot3.input
  #---
  ln -fs $Project.VibWvs1 VIBWVS
  molcas vibrot1.input > current.log
  cat current.log
  rm -f VIBWVS
  #---
  ln -fs $Project.VibWvs2 VIBWVS
  molcas vibrot2.input > current.log
  cat current.log
  rm -f VIBWVS
  #---
  ln -fs $Project.VibWvs1 VIBWVS1
  ln -fs $Project.VibWvs2 VIBWVS2
  molcas vibrot3.input > current.log
  cat current.log
  rm -f VIBWVS1 VIBWVS2
  #
  # Finished so clean up the files.
  #
  print "Calculation finished" >&2
  cd -
  rm $WorkDir/molcas.temp*
  #rm -r $WorkDir
  exit 0

The input for the first part of the calculations include the
SEWARD, SCF, MOTRA, GUGA, and MRCI inputs:

.. index::
   single: SEWARD
   single: SCF
   single: MOTRA
   single: GUGA
   single: MRCI

.. extractfile:: advanced/MRCI.C2.input

  &SEWARD &END
  Title
   C2
  Pkthre
  1.0D-11
  Symmetry
    X  Y  Z
  Basis set
  C.ANO-S...3s2p.
  C        .00000000    .00000000   #
  End of basis
  End of input

  &SCF &END
  Title
   C2
  ITERATIONS
   40
  Occupied
    2  1  1  0  2  0  0  0
  End of input

  &MOTRA &END
  Title
   C2 molecule
  Frozen
   1 0 0 0 1 0 0 0
  LumOrb
  End of input

  &GUGA &END
  Title
   C2 molecule
  Electrons
      8
  Spin
      1
  Inactive
      1    1    1    0    1    0    0    0
  Active
      0    0    0    0    0    0    0    0
  CiAll
      1
  End of Input

  &MRCI &END
  Title
   C2 molecule
  SDCI
  End of input

We are going to use a small ANO [3s2p] basis set because our purpose
it is not to obtain an extreme accuracy.
In the SEWARD input the sign "#" will be replaced by the right distance
using the "sed" command. In the MOTRA input we have frozen the two
core orbitals in the molecule, which will be recognized by the MRCI
program. The GUGA input defines the reference space of configurations
for the subsequent MRCI or ACPF calculation. In this case the
valence orbitals are doubly occupied and there is only one reference configuration
(they are included as inactive). We thus use one single
configuration to perform the SDCI calculation and obtain the initial
set of orbitals for the CASSCF calculation.

The lowest :math:`^1\Sigma_g^+` state in :math:`\ce{C2}` is the result of the
electronic configuration [core]\ :math:`(2\sigma_g)^2(2\sigma_u)^2(1\pi_u)^4`.
Only one electronic state is obtained from this
configuration. The configuration :math:`(1\pi_u)^3(3\sigma_g)^1`
is close in energy and generates two possibilities,
one :math:`^3\Pi_u` and one :math:`^1\Pi_u` state. The former is the lowest
state of the Swan bands, and was thought to be the ground state of
the molecule. Transitions to the :math:`^1\Pi_u` state are known as the
Phillips band and this is the state we are going to compute.
We have the possibility to compute the state in symmetry |bttu| or
|btu| (|molcas| symmetry groups 2 and 3, respectively) in the |Dth|
group, because both represent the degenerate :math:`\Pi_u` symmetry in |Dinfh|.

.. index::
   single: RASSCF
   single: RASSCF; Average option
   single: Option; Average
   single: Excited states

The RASSCF input file to compute the two states are: ::

  &RASSCF &END
  Title
   C2 1Sigmag+ state.
  Nactel
    4  0  0
  Spin
    1
  Symmetry
    1
  Inactive
    2  0  0  0  2  0  0  0
  Ras2
    1  1  1  0  1  1  1  0
  *Average
  *2 2 3 6 7
  OutOrbitals
   Natural
   1
  Iter
  50,25
  Lumorb
  End of input

  &RASSCF &END
  Title
   C2 1Piu state.
  Nactel
    4  0  0
  Spin
    1
  Symmetry
    2
  Inactive
    2  0  0  0  2  0  0  0
  Ras2
    1  1  1  0  1  1  1  0
  Average
  2 2 3 6 7
  OutOrbitals
   Natural
   1
  Iter
  50,25
  Lumorb
  End of input

We can skip the :kword:`SUPSym` option because our basis set
contains only s,p functions and no undesired rotations can
happen. Symmetries |bttu| and |btu| on one hand and |btg| and |bttg| on
the other are averaged. Notice that to obtain natural orbitals we have
used keyword :kword:`OUTOrbitals` instead of the old :program:`RASREAD`
program. In addition, we need the :program:`RASSI` input:

.. index::
   single: RASSCF
   single: OUTORBITALS; Natural orbitals
   single: Orbitals; Natural
   single: RASSI
   single: Properties; Transition dipole moments
   single: Transition dipole moments

::

  &RASSI &END
  NrOfJobiphs
   2 1 1
   1
   1
  End of input

.. index::
   single: Program; VibRot
   single: VibRot; Potential
   single: VibRot; Orbital
   single: VibRot; Vibwvs

The :program:`VIBROT` inputs to compute the vibrational--rotational
analysis and spectroscopic constants of the state should be: ::

  &VIBROT &END
  RoVibrational spectrum
  Title
   Vib-Rot spectrum for C2. 1Sigmag+
  Atoms
  0 C 0 C
  Grid
  400
  Range
  2.0 10.0
  Vibrations
  3
  Rotations
  0 4
  Orbital
  0
  Potential
  2.2 -75.42310136
  ...
  End of input

Under the keyword :kword:`POTEntial` the bond distance and
potential energy (both in au) of the corresponding state
must be included. In this case we are going to compute three
vibrational quanta and four rotational quantum numbers.
For the :math:`^1\Pi_u` state, the keyword :kword:`ORBItal` must be
set to one, corresponding to the orbital angular momentum
of the computed state. :program:`VIBROT` fits the potential curve to
an analytical curve using splines. The ro-vibrational
Schrödinger equation is then solved numerically (using
Numerov's method) for one vibrational state at a time and
for the specified number of rotational quantum numbers.
File :file:`VIBWVS` will contain the corresponding wave
function for further use.

.. index::
   single: Diatomic molecules
   single: Spectroscopy
   single: Properties; Spectroscopic

.. compound::

  Just to give some of the results obtained, the spectroscopic
  constants for the :math:`^1\Sigma_g^+` state were: ::

    Re(a)                 1.4461
    De(ev)                3.1088
    D0(ev)                3.0305
    we(cm-1)         .126981E+04
    wexe(cm-1)      -.130944E+02
    weye(cm-1)      -.105159E+01
    Be(cm-1)         .134383E+01
    Alphae(cm-1)     .172923E-01
    Gammae(cm-1)     .102756E-02
    Dele(cm-1)       .583528E-05
    Betae(cm-1)      .474317E-06

  and for the :math:`^1\Pi_u` state: ::

    Re(a)                 1.3683
    De(ev)                2.6829
    D0(ev)                2.5980
    we(cm-1)         .137586E+04
    wexe(cm-1)      -.144287E+02
    weye(cm-1)       .292996E+01
    Be(cm-1)         .149777E+01
    Alphae(cm-1)     .328764E-01
    Gammae(cm-1)     .186996E-02
    Dele(cm-1)       .687090E-05
    Betae(cm-1)     -.259311E-06

.. index::
   single: Properties; Vibrationally averaged TDMs
   single: Properties; Lifetimes
   single: Diatomic molecules; Vibrationally averaged TDMs
   single: Diatomic molecules; Lifetimes
   single: VibRot; Observable

To compute vibrationally averaged TDMs the :program:`VIBROT` input must be: ::

  &VIBROT &END
  Transition moments
  Observable
  Transition dipole moment
  2.2 0.412805
  ...
  End of input

.. compound::

  Keyword :kword:`OBSErvable` indicates the start of input
  for radial functions of observables other than the energy.
  In the present case the vibrational--rotational matrix elements
  of the transition dipole moment function will be generated.
  The values of the bond distance and the TDM at each distance
  must be then included in the input. VIBROT also requires
  the :file:`VIBWVS1` and :file:`VIBWVS2` files
  containing the vibrational wave functions of the involved electronic states.
  The results obtained contain matrix elements, transition
  moments over vibrational wave functions, and the lifetimes of the
  transition among all the computed vibrational--rotational states.
  The radiative lifetime of a vibrational level depends on the
  sum of the transition probabilities to all lower vibrational
  levels in all lower electronic states. If rotational effects are
  neglected, the lifetime (:math:`\tau_v'`) can be written as

  .. math:: \tau_v' = \left( \sum_{v''} A_{v'v''} \right)^{-1}

  where :math:`v'` and :math:`v''` are the vibrational
  levels of the lower and upper electronic state and :math:`A_{v'v''}` is the
  Einstein :math:`A` coefficient (ns\ :math:`^{-1}`) computed as

  .. math:: A_{v'v''} = 21.419474\, (\Delta E_{v'v''})^3 (\text{TDM}_{v'v''})^2

  :math:`\Delta E_{v'v''}` is the energy difference (au) and :math:`\text{TDM}_{v'v''}`
  the transition dipole moment (au) of the transition.

For instance, for rotational states zero of the :math:`^1\Sigma^+_g` state
and one of the :math:`^1\Pi_u` state: ::

   Rotational quantum number for state 1:  0, for state 2:  1
   --------------------------------------------------------------------------------

   Overlap matrix for vibrational wave functions for state number  1
   1  1  .307535  2  1  .000000  2  2  .425936  3  1  .000000  3  2  .000000  3  3  .485199

   Overlap matrix for vibrational wave functions for state number  2
   1  1  .279631  2  1  .000000  2  2  .377566  3  1  .000000  3  2  .000000  3  3  .429572

   Overlap matrix for state 1 and state 2 functions
     -.731192  -.617781  -.280533
      .547717  -.304345  -.650599
     -.342048   .502089  -.048727

   Transition moments over vibrational wave functions (atomic units)
     -.286286  -.236123  -.085294
      .218633  -.096088  -.240856
     -.125949   .183429   .005284

   Energy differences for vibrational wave functions(atomic units)
   1  1  .015897  2  1  .010246  2  2  .016427  3  1  .004758  3  2  .010939  3  3  .017108

   Contributions to inverse lifetimes (ns-1)
  No degeneracy factor is included in these values.
   1  1  .000007  2  1  .000001  2  2  .000001  3  1  .000000  3  2 .000001   3  3  .000000

   Lifetimes (in nano seconds)
     v       tau
     1 122090.44
     2  68160.26
     3  56017.08

.. NOTE: contains a nbsp

Probably the most important caution when using the VIBROT program
in diatomic molecules is that the number of vibrational
states to compute and the accuracy obtained depends
strongly on the computed surface. In the present case we
compute all the curves to the dissociation limit. In other cases, the program
will complain if we try to compute states which lie at energies
above those obtained in the calculation of the curve.

.. index::
   single: Ni2
   single: Linear molecules; Ni2

.. _TUT\:sec\:ni2:

A transition metal dimer: :math:`\ce{Ni2}`
------------------------------------------

This section is a brief comment on a complex situation in a diatomic
molecule such as :math:`\ce{Ni2}`. Our purpose is to compute the ground state
of this molecule. An explanation of how to calculate it accurately can
be found in ref. :cite:`Pou:94`. However we will concentrate on computing
the electronic states at the CASSCF level.

The nickel atom has two close low-lying configurations 3\ :math:`d^8`\4s\ :math:`^2` and
3\ :math:`d^9`\4\ :math:`s^1`. The combination of two neutral :math:`\ce{Ni}` atoms leads to a
:math:`\ce{Ni2}` dimer whose ground state has been somewhat controversial.
For our purposes we commence with the assumption that it is
one of the states derived
from 3d\ :math:`^9`\4\ :math:`s^1` :math:`\ce{Ni}` atoms, with a single bond between the 4s orbitals,
little 3d involvement, and the holes localized in the 3d\ :math:`\delta` orbitals.
Therefore, we compute the states resulting from two
holes on :math:`\delta` orbitals: :math:`\delta\delta` states.

.. index::
   single: Transition metals
   single: Excited states; Ni2

We shall not go through the procedure leading to the different electronic
states that can arise from these electronic configurations, but refer to
the Herzberg book on diatomic molecules :cite:`Herzberg:66` for details. In
|Dinfh| we have three possible configurations with two holes, since the
:math:`\delta` orbitals can be either *gerade* (:math:`g`) or *ungerade* (:math:`u`):
:math:`(\delta_g)^{-2}`, :math:`(\delta_g)^{-1}(\delta_u)^{-1}`, or :math:`(\delta_u)^{-2}`.
The latter situation corresponds to nonequivalent electrons while the other
two to equivalent electrons.
Carrying through the analysis we obtain the following electronic states:

  | :math:`(\delta_g)^{-2}`: :math:`^1\Gamma_g`, :math:`^3\Sigma_g^-`, :math:`^1\Sigma_g^+`
  | :math:`(\delta_u)^{-2}`: :math:`^1\Gamma_g`, :math:`^3\Sigma_g^-`, :math:`^1\Sigma_g^+`
  | :math:`(\delta_g)^{-1}(\delta_u)^{-1}`: :math:`^3\Gamma_u`, :math:`^1\Gamma_u`, :math:`^3\Sigma_u^+`,
    :math:`^3\Sigma_u^-`, :math:`^1\Sigma_u^+`, :math:`^1\Sigma_u^-`

In all there are thus 12 different electronic states.

.. compound::

  Next, we need to classify these electronic states in the lower symmetry
  |Dth|, in which |molcas| works. This is done in :numref:`tab:dd`, which
  relates the symmetry in |Dinfh| to that of |Dth|. Since we have only
  :math:`\Sigma^+`, :math:`\Sigma^-`, and :math:`\Gamma` states here, the |Dth| symmetries
  will be only :math:`A_g`, :math:`A_u`, :math:`B_{1g}`, and :math:`B_{1u}`. The table above can
  now be rewritten in |Dth|:

    | :math:`(\delta_g)^{-2}`: (|SAG| + |SBOG|), |TBOG|, |SAG|
    | :math:`(\delta_u)^{-2}`: (|SAG| + |SBOG|), |TBOG|, |SAG|
    | :math:`(\delta_g)^{-1}(\delta_u)^{-1}`: (|TAU| + |TBOU|), (|SAU| + |SBOU|),
      |TBOU|, |TAU|, |SBOU|, |SAU|

  or, if we rearrange the table after the |Dth| symmetries:

    | |SAG|:  :math:`^1\Gamma_g(\delta_g)^{-2}`, :math:`^1\Gamma_g(\delta_u)^{-2}`,
              :math:`^1\Sigma_g^+(\delta_g)^{-2}`, :math:`^1\Sigma_g^+(\delta_u)^{-2}`
    | |SBOU|: :math:`^1\Gamma_u(\delta_g)^{-1}(\delta_u)^{-1}`,
              :math:`^1\Sigma_u^+(\delta_g)^{-1}(\delta_u)^{-1}`
    | |SBOG|: :math:`^1\Gamma_g(\delta_g)^{-2}`, :math:`^1\Gamma_g(\delta_u)^{-2}`
    | |SAU|:  :math:`^1\Gamma_u(\delta_g)^{-1}(\delta_u)^{-1}`,
              :math:`^1\Sigma_u^-(\delta_g)^{-1}(\delta_u)^{-1}`

    | |TBOU|: :math:`^3\Gamma_u(\delta_g)^{-1}(\delta_u)^{-1}`,
              :math:`^3\Sigma_u^+(\delta_g)^{-1}(\delta_u)^{-1}`
    | |TBOG|: :math:`^3\Sigma_g^-(\delta_g)^{-2}`, :math:`^3\Sigma_g^-(\delta_u)^{-2}`
    | |TAU|:  :math:`^3\Gamma_u(\delta_g)^{-1}(\delta_u)^{-1}`,
              :math:`^3\Sigma_u^-(\delta_g)^{-1}(\delta_u)^{-1}`

It is not necessary to compute all the states because some of
them (the :math:`\Gamma` states) have degenerate components. It is both
possible to make single state calculations looking for the lowest
energy state of each symmetry or state-average calculations in each of
the symmetries. The identification of the |Dinfh| states can be
somewhat difficult. For instance, once we have computed one
|SAG| state it can be a :math:`^1\Gamma_g` or a :math:`^1\Sigma_g^+` state.
In this case the simplest solution is to compare the obtained
energy to that of the :math:`^1\Gamma_g` degenerate component in
:math:`B_{1g}` symmetry, which must be equal to the energy of the
:math:`^1\Gamma_g` state computed in :math:`A_g` symmetry. Other situations
can be more complicated and require a detailed analysis of the
wave function.

It is important to have clean d orbitals and the :kword:`SUPSym`
keyword may be needed to separate :math:`\delta` and :math:`\sigma`
(and :math:`\gamma` if g-type functions are used in the basis set)
orbitals in symmetry 1 (:math:`A_g`). The :kword:`AVERage` keyword
is not needed here because the :math:`\pi` and :math:`\phi` orbitals have
the same occupation for :math:`\Sigma` and :math:`\Gamma` states.

.. index::
   single: Spin–orbit coupling

Finally, when states of different multiplicities are close in
energy, the spin--orbit coupling which mix the different states
should be included. The CASPT2 study of the :math:`\ce{Ni2}` molecule
in reference :cite:`Pou:94`, after considering all the mentioned
effects determined that the ground
state of the molecule is a :math:`0_g^+` state, a mixture of the
:math:`^1\Sigma_g^+` and :math:`^3\Sigma_g^-` electronic states.
For a review of the spin--orbit coupling and other important
coupling effects see reference :cite:`Peric:95`.

.. index::
   single: High symmetry
   single: Symmetry; High symmetry molecules
   single: RASSCF; Supersymmetry
   single: Option; Supersymmetry
   single: RASSCF; Cleanup
   single: Option; Cleanup
   single: RASSCF; Average option

.. _TUT\:sec\:hsym:

High symmetry systems in |molcas|
---------------------------------

There are a large number of symmetry point groups in which |molcas|
cannot directly work. Although unusual in organic chemistry, some
of them can be easily found in inorganic compounds. Systems belonging
for instance to three-fold groups such as :math:`C_{3v}`, :math:`D_{3h}`, or :math:`D_{6h}`,
or to groups such :math:`O_h` or :math:`D_{4h}` must be computed using lower symmetry
point groups. The consequence is, as in linear molecules, that
orbitals and states belonging to different representations in the
actual groups, belong to the same representation in the lower symmetry
case, and *vice versa*. In the :program:`RASSCF` program it is
possible to prevent the orbital and configurational mixing caused by
the first situation. The :kword:`CLEAnup` and :kword:`SUPSymmetry`
keywords can be used in a careful, and somewhat tedious, way. The right
symmetry behaviour of the RASSCF wave function is then assured. It is
sometimes not a trivial task to identify the symmetry of the orbitals
in the higher symmetry representation and which coefficients must vanish.
In many situations the ground state wave function keeps the right
symmetry (at least within the printing accuracy) and helps to identify
the orbitals and coefficients. It is more frequent that the mixing
happens for excited states.

The reverse situation, that is, that orbitals (normally degenerated) which
belong to the same symmetry representation in the higher symmetry groups
belong to different representations in the lower symmetry groups cannot
be solved by the present implementation of the :program:`RASSCF` program.
The :kword:`AVERage` keyword, which performs this task in the linear molecules,
is not prepared to do the same in non-linear systems. Provided that the
symmetry problems mentioned in the previous paragraph are treated in
the proper way and the trial orbitals have the right symmetry, the :program:`RASSCF`
code behaves properly.

.. index::
   single: Symmetry; Three-fold groups
   single: Geometry

There is a important final precaution concerning the high symmetry systems:
the geometry of the molecule must be of the right symmetry. Any deviation
will cause severe mixings. :numref:`block:porph` contains the
:program:`SEWARD` input for the magnesium porphirin molecule. This is
a :math:`D_{4h}` system which must be computed :math:`D_{2h}` in |molcas|.

For instance, the :math:`x` and :math:`y` coordinates of atoms C1 and C5
are interchanged with equal values in :math:`D_{4h}` symmetry. Both
atoms must appear in the :program:`SEWARD` input because they
are not independent by symmetry in the :math:`D_{2h}` symmetry in which
|molcas| is going to work. Any deviation of the values,
for instance to put the :math:`y` coordinate to 0.681879 Å in C1
and the :math:`y` to 0.681816 Å in C5 and similar deviations for the other
coordinates, will lead to severe symmetry mixtures. This must be
taken into account when geometry data are obtained from other
program outputs or data bases.

.. index::
   single: Porphyrine–Mg

.. extractcode-block:: none
   :filename: advanced/SEWARD.Mg-Porphyrine.input
   :caption: Sample input of the SEWARD program for the magnesium
             porphirin molecule in the :math:`D_{2h}` symmetry}
   :name: block:porph

   &SEWARD &END
   Title
    Mg-Porphyrine D4h computed D2h
   Symmetry
    X Y Z
   Basis set
   C.ANO-S...3s2p1d.
   C1    4.254984     .681879     .000000  Angstrom
   C2    2.873412    1.101185    0.000000  Angstrom
   C3    2.426979    2.426979    0.000000  Angstrom
   C4    1.101185    2.873412    0.000000  Angstrom
   C5     .681879    4.254984    0.000000  Angstrom
   End of basis
   Basis set
   N.ANO-S...3s2p1d.
   N1    2.061400     .000000    0.000000  Angstrom
   N2     .000000    2.061400    0.000000  Angstrom
   End of basis
   Basis set
   H.ANO-S...2s0p.
   H1    5.109145    1.348335    0.000000  Angstrom
   H3    3.195605    3.195605    0.000000  Angstrom
   H5    1.348335    5.109145    0.000000  Angstrom
   End of basis
   Basis set
   Mg.ANO-S...4s3p1d.
   Mg     .000000     .000000    0.000000  Angstrom
   End of basis
   End of Input

.. index::
   single: Symmetry; Three-fold groups
   single: Geometry

The situation can be more complex for some three-fold point groups
such as :math:`D_{3h}` or :math:`C_{3v}`. In these cases it is not possible
to input in the exact cartesian geometry, which depends on
trigonometric relations and relies on the numerical precision
of the coordinates entry. It is necessary then to use in the
:program:`SEWARD` input as much
precision as possible and check on the distance matrix of the
:program:`SEWARD` output if the symmetry of the system has been
kept at least within the output printing criteria.
.. index::
   single: examples

Examples
========

.. toctree::

   ex-x2
   ex-op
   ex-rp
   ex-hi
   ex-ex
   ex-rc
   ex-so
Commands and environment variables
==================================

This section will describe the usage of |molcas| in an
UNIX environment.

Production jobs using |molcas| in an UNIX environment can be
performed as batch jobs.
This requires the creation of a shell script that
contains a few simple commands. Further you need to create input for
each program module that you intend to use. This section describes the
necessary steps you have to take in order to make a successful job using
|molcas|.
Input examples for a typical |molcas|
run can be found in :file:`doc/samples/problem_based_tutorials/` directory.
Also you can use some input examples
in :file:`Test/input` subdirectory.

Commands
--------

There is a command supplied with the |molcas| package, named
:command:`molcas`, that the user issue to perform a given task.
A sequence of such commands will perform the calculation requested by
the user.

.. class:: commandlist

:command:`molcas`
  This command tells which |molcas| installation will be used, and gives
  some help about usage of |molcas| command

:command:`molcas` :file:`input-file`
  This command executes a command in the |molcas| system.

:command:`molcas help` :program:`prgm`
  This command gives the list of available keywords for program :program:`prgm`.

:command:`molcas help` :program:`prgm keyword`
  This command gives description of a :program:`keyword`.

:command:`molcas help` :program:`environment`
  This command gives a list of |molcas| specific environment variables.

:command:`molcas help` :program:`basis element`
  This command gives a list of basis sets available for an :program:`element`.

The following is an example of running |molcas| by using a single input file: ::

  molcas $Project.input

An alternative way of running |molcas| as a sequence of separate calls: ::

  molcas $Project.seward.input    # Execute seward
  molcas $Project.scf.input       # Execute scf

By default, the output will go directly to the screen. It can be redirected
by using flag :command:`-f`, e.g. :command:`molcas -f water.inp` will store the output
in :file:`water.log` and :file:`water.err` files.

The default behavior of |molcas| execution can be altered by setting environment variables.

Project name and working directory
----------------------------------

When running a project, |molcas| uses the variable
:variable:`Project` giving a project name, and a scratch directory defined by
the variable :variable:`WorkDir`.
This serves the purpose of maintaining structure of the files and
facilitating automatic file mapping.

There are several ways to set up these variables.
By default, the name of the Project constructed from the name of the input file,
by removing the last suffix, e.g. for example for an input name :file:`Water.SCF.input`
the :variable:`Project` name will be :variable:`Water.SCF`.
Alternatively,
user can set environment variable :variable:`Project`, or :variable:`MOLCAS_PROJECT`.

Scratch directory can be set by environment variable :variable:`MOLCAS_WORKDIR`.
If it is set to value ``PWD``, current directory will be used. Otherwise,
it can be set to a directory name. In this case scratch area will be located
in a subdirectory :file:`$MOLCAS_WORKDIR/$Project`. It is also possible to
overwrite the value of scratch area, by setting environment variable
:variable:`WorkDir`.

* :command:`Project=...; export Project`
* :command:`WorkDir=...; export WorkDir`

|molcas| modules communicates between each other via files, located in the :variable:`WorkDir`.
The description of internal filenames and file mapping can be found at Appendix.

Input
-----

.. compound::

  When you have decided which program modules you need to use to perform your
  calculation, you need to construct input for each of these. There is no
  particular structure enforced on the input files, but it is recommended that
  you follow:

  * :file:`$Project.<prgm-name>.input`

  which is the name of the input files assumed in the sample shell script.

Preparing a job
---------------

When you prepare a job for batch processing, you have to create a shell script.
It is recommended that you use the sample shell script supplied with
|molcas| as a starting point when building your own shell script.
The following steps are taken in the shell script:

#. Define and export the |molcas| variables

   * Project (or use :variable:`MOLCAS_PROJECT`)
   * WorkDir (or :variable:`MOLCAS_WORKDIR`)

#. Issue a sequence of |molcas| commands.
#. Remove the scratch directory and all files in it.

The following is an example of a shell script. ::

  Project=HF; export Project                               # Define the project id
  WorkDir=/temp/$LOGNAME/$Project.$RANDOM; export WorkDir  # Define scratch directory
  molcas $Project.input                                    # Run molcas with input file, which
                                                           # contains inputs for several modules
  rm -r $WorkDir                                           # Clean up

The file :file:`$ThisDir/$Project.input` contains the ordered sequence
of |molcas| inputs and the EMIL interpreter will call the appropriate
programs. See :numref:`UG:sec:EMIL` for an explanation of the
additional tools available in the EMIL interpreter.

The following is an example of a shell script to be submitted for batch
execution. ::

  Project=HF; export Project                               # Define the project id
  WorkDir=/temp/$LOGNAME/$Project.$RANDOM; export WorkDir  # Define scratch directory
  molcas $Project.seward.input                             # Execute seward
  molcas $Project.scf.input                                # Execute scf
  rm -r $WorkDir                                           # Clean up

An alternative way to control the usage of the WorkDir is to use flags in molcas command:

.. class:: commandlist

:command:`-new`
  clean WorkDir before the usage

:command:`-clean`
  clean WorkDir after the usage

Note, that if you configured your working environment by using :command:`setuprc` script,
the only command you have to place into the shell script is: ::

  molcas $Project.input

.. _UG\:sec\:sysvar:

System variables
----------------

|molcas| contains a set of system variables that the user can
set to modify the default behaviour of |molcas|. Two of them
(Project and WorkDir) must be set in order to make |molcas| work at all.
There are defaults for these but you are advised not to use the defaults.

There are several ways of using |molcas| environment variables:

* These variables can be exported in your shell script ::

    export MOLCAS_MEM=512
    molcas input

* These variables can be included into |molcas| input: ::

    * begin of the input file
    >>> export MOLCAS_MEM=512

      . . .

* variables can be included directly into :command:`molcas` command in the form: ::

    molcas MOLCAS_MEM=512 input

The simplest way to set up default environment for |molcas| is
to use script :file:`setuprc`, which can be run as command
:command:`molcas setuprc`. This interactive script creates
a resource file :file:`molcasrc`, located either in :file:`$MOLCAS` or :file:`$HOME/.Molcas`
directory. The priority of these settings is: user defined settings
(e.g. in :command:`molcas` command), user resource file, |molcas| resource file.

Two flags in |molcas| command are related to resource files:

.. class:: variablelist

:variable:`-env`
  Display current |molcas| environment
  e.g. :command:`molcas -env input` will print information about environment
  variables, used during execution of the input file.

:variable:`-ign`
  Ignore resource files
  e.g. :command:`molcas -ign input` will process input file without settings,
  which are stored in :file:`$MOLCAS/molcasrc` and in :file:`$HOME/molcasrc` files.

The most important environment variables, used in |molcas|:

.. xmldoc:: <MODULE NAME="ENVIRONMENT" LEVEL="HIDDEN">
            %%Description:
            List of environment variables

.. class:: variablelist

:variable:`Project`
  This variable can be set in order to overwrite the default name of the
  project you are running. The default (and recommended) value of the project name is the
  name of the input file (without the file extension).

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="Project" APPEAR="Project" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: Project <advanced>
              <HELP>
              This variable can be set in order to overwrite the default name of the
              project you are running. The default (and recommended) value of the project name
              is the name of the input file (without the file extension).
              </HELP>
              </KEYWORD>

:variable:`WorkDir`
  This variable can be used to specify directly the directory where all files
  that |molcas| creates are placed. See :kword:`MOLCAS_WORKDIR` for more options.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="WorkDir" APPEAR="WorkDir" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: WorkDir <advanced>
              <HELP>
              This variable can be used to specify directly the directory where all files
              that molcas creates are placed. See MOLCAS_WORKDIR for more options.
              </HELP>
              </KEYWORD>

:variable:`CurrDir`
  This variable corresponds to the location of the input, and it is used as
  a default location for all output files, generated by |molcas| modules.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="CurrDir" APPEAR="CurrDir" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: CurrDir <advanced>
              <HELP>
              This variable corresponds to the location of the input, and it is used as
              a default location for all output files, generated by molcas modules.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS`
  This variable indicates the location of |molcas|. The default version of Molcas
  to be used is specified at file :file:`.Molcas/molcas`, located at user HOME directory.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS" APPEAR="MOLCAS" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: MOLCAS <advanced>
              <HELP>
              This variable indicates the location of molcas. The default version of Molcas
              to be used is specified at file .Molcas/molcas, located at user HOME directory.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_NPROCS`
  This variable should be used to run |molcas| code in parallel. It defines the
  number of computational units (cores or nodes) which will be used.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_NPROCS" APPEAR="MPI Processes" KIND="STRING" LEVEL="BASIC">
              %%Keyword: MOLCAS_NPROCS <basic>
              <HELP>
              This variable should be used to run molcas code in parallel. It defines the
              number of computational units (cores or nodes) which will be used.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_MEM`
  .. compound::

    This environment variable controls the size (soft limit) of the
    work array utilized in the programs that offer dynamic memory.
    It is specified in Megabytes, i.e.

    :command:`MOLCAS_MEM=256; export MOLCAS_MEM`

    will assign 256MB for the working arrays.
    It is also possible to use Gb (Tb) to specify memory in Gb or Tb.

  * MOLCAS_MEM is undefined --- The default amount of memory (1024MB),
    will be allocated for the work arrays.
  * MOLCAS_MEM is defined but nonzero --- This amount of memory
    will be allocated.

  See also :kword:`MOLCAS_MAXMEM`.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_MEM" APPEAR="MOLCAS_MEM (Mb)" KIND="INT" LEVEL="BASIC">
              %%Keyword: MOLCAS_MEM <basic>
              <HELP>
              This environment variable controls the size (soft limit) of the
              work array (in Mb) utilized in the programs that offer dynamic memory.
              It is also possible to set up memory in Gb, e.g. 2Gb
              </HELP>
              </KEYWORD>

The complete list of |molcas|-related environment variables:

.. class:: variablelist

:variable:`MOLCAS_COLOR`
  By default molcas uses markup characters in the output. To overwrite, set the key to NO.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_COLOR" APPEAR="Use markup in the output" KIND="CHOICE" LIST="----,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_COLOR <advanced>
              <HELP>
              By default molcas uses markup characters in the output.
              To overwrite, set the key to NO
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_NPROCS`
  See above

:variable:`MOLCAS_DEBUGGER`
  This variable can be set to the name of debugger (or another code) which will be used on top of
  molcas executables. The option is useful for tracing an error in the code

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_DEBUGGER" APPEAR="Debugger" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_DEBUGGER <advanced>
              <HELP>
              This variable can be set to the name of debugger (or another code) which will be used on top of
              molcas executables. The option is useful for tracing an error in the code
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_DISK`
  The value of this variable is used to split large files into a set of
  smaller datasets, as many as are needed (max. 20 subsets). It is specified
  in Megabytes, for instance, :command:`MOLCAS_DISK=1000; export MOLCAS_DISK`,
  and the following rules apply:

  * MOLCAS_DISK is undefined --- The program modules will ignore this
    option and the file size limit will be defined by your hardware
    (2 GBytes for 32-bit machines).
  * MOLCAS_DISK=0 (zero) --- The programs will assume a file size limit
    of 2 GBytes (200GBytes on 64-bit machines).
  * MOLCAS_DISK is defined but nonzero --- The files will be limited to
    this value (approximately) in size.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_DISK" APPEAR="MOLCAS_DISK" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_DISK <advanced>
              <HELP>
              The value of this variable is used to split large files into a set of
              smaller datasets, as many as are needed (max. 20 subsets).
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_ECHO_INPUT`
  An environment variable to control echoing of the input.
  To suppress print level, set MOLCAS_ECHO_INPUT to ``NO``.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_ECHO_INPUT" APPEAR="Echo input" KIND="CHOICE" LIST="----,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_ECHO_INPUT <advanced>
              <HELP>
              An environment variable to control echoing of the input.
              To suppress print level, set MOLCAS_ECHO_INPUT to 'NO'.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_FIM`
  Activates the Files In Memory I/O layer. See :numref:`MT:sec:fim` for more details.
  *Note that this setting is available only in MOLCAS compiled without Global
  Arrays.*

  .. warning::

     This feature is not available in |openmolcas|.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_FIM" APPEAR="FiM" KIND="CHOICE" LIST="----,YES" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_FIM <advanced>
              <HELP>
              Activate the Files in Memory I/O layer
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_INPORB_VERSION`
  Selects the version used for writing orbital files (`$Project.ScfOrb`, `$Project.RasOrb`, etc.).
  The value should be a version number such as ``1.0`` or ``2.2``.
  If the version is not known, the default (usually latest) version will be used.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_INPORB_VERSION" APPEAR="INPORB version" KIND="REAL" LEVEL="BASIC">
              %%Keyword: MOLCAS_INPORB_VERSION <basic>
              <HELP>
              Selects the version used for writing orbital files.
              The value should be a version number such as 1.0 or 2.2.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_KEEP_WORKDIR`
  If set to NO |molcas| will remove scratch area after a calculation.
  This setting can be overwritten by running :command:`molcas` with flag :command:`-clean`.
  Note that this does not work in a parallel environment.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_KEEP_WORKDIR" APPEAR="Keep WorkDir" KIND="CHOICE" LIST="NO" LEVEL="BASIC">
              %%Keyword: MOLCAS_KEEP_WORKDIR <basic>
              <HELP>
              If set to NO molcas will remove scratch area after a calculation.
              This setting can be overwritten by running molcas with flag -clean:

                molcas -clean input
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_LICENSE`
  An environment which specifies the directory with |molcas| license file :file:`license.dat`.
  The default value of this variable is directory :file:`.Molcas/` in user home directory.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_LICENSE" APPEAR="License Directory" KIND="DIR" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_LICENSE <advanced>
              <HELP>
              An environment which specifies the directory with molcas license file license.dat.
              The default value of this variable is directory .Molcas/ in user home directory.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_LINK`
  An environment variable to control information about linking of files.
  By default (MOLCAS_LINK is not set) only essential
  information about linking will be printed. To increase/decrease the
  print level, set MOLCAS_LINK to ``Yes``/``No``.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_LINK" APPEAR="Link information" KIND="CHOICE" LIST="YES,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_LINK <advanced>
              <HELP>
              An environment variable to control information about linking of files.
              By default (MOLCAS_LINK is not set) only essential
              information about linking will be printed. To increase/decrease the
              print level, set MOLCAS_LINK to 'Yes'/'No'.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_MAXITER`
  An environment variable to control maximum number of iterations in DO WHILE loop.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_MAXITER" APPEAR="Max Iter" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_MAXITER <advanced>
              <HELP>
              An environment variable to control maximum number of iterations in DO WHILE loop
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_MAXMEM`
  An environment variable to set up a hard limit for allocated memory (in Mb).
  If is not specified, then it takes value of MOLCAS_MEM. Otherwise, the (MOLCAS_MAXMEM-MOLCAS_MEM)
  amount of RAM will be primarily used for keeping files in memory (FiM), or allocating Distributed Global Arrays.
  *Note that this setting is available only in MOLCAS compiled without Global Arrays.*

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_MAXMEM" APPEAR="Max Memory" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_MAXMEM <advanced>
              <HELP>
              An environment variable to set up a hard limit for allocated memory (in Mb).
              If is not specified, then it takes value of MOLCAS_MEM. Otherwise, the
              (MOLCAS_MAXMEM-MOLCAS_MEM) amount of RAM will be primarily used for keeping
              files in memory (FiM), or allocating Distributed Global Arrays. Note that
              this setting is available only in MOLCAS compiled without GA.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_MEM`
  See above.

:variable:`MOLCAS_MOLDEN`
  If MOLCAS_MOLDEN set to ``ON`` a Molden style input file will be generated regardless of the number of orbitals.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_MOLDEN" APPEAR="MOLDEN output" KIND="CHOICE" LIST="ON,OFF" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_MOLDEN <advanced>
              <HELP>
              If MOLCAS_MOLDEN set to 'ON' a Molden style input file will be generated regardless of the number of orbitals.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_NEW_DEFAULTS`
  If set to ``YES`` (case insensitive), some new default values will be activated:

  * :kword:`RICD` will be enabled by default in :program:`GATEWAY`, it can be disabled with :kword:`NOCD`.
  * The default IPEA shift in :program:`CASPT2` is set to 0.0, other values can be specified normally with the :kword:`IPEA` keyword.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_NEW_DEFAULTS" APPEAR="New defaults" KIND="CHOICE" LIST="YES,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_NEW_DEFAULTS <advanced>
              <HELP>
              If set to 'YES', activates new defaults (e.g. RICD, IPEA=0.0)
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_NEW_WORKDIR`
  If set to YES |molcas| will never reuse files in scratch area.
  This setting can be overwritten by running :command:`molcas` with flag :command:`-old`:
  :command:`molcas -old input`.
  Note that this does not work in a parallel environment.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_NEW_WORKDIR" APPEAR="Use new WorkDir" KIND="CHOICE" LIST="YES" LEVEL="BASIC">
              %%Keyword: MOLCAS_NEW_WORKDIR <basic>
              <HELP>
              If set to YES molcas will never reuse files in scratch area.
              This setting can be overwritten by running molcas with flag -old:

                molcas -old input
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_OUTPUT`
  This variable can alter the default directory for extra output files,
  such as orbitals files, molden files, etc.
  If set, |molcas| will save output files to the specified directory.
  The directory name can be set in the form of absolute PATH, or
  relative PATH (related to the submit directory).
  A special value ``WORKDIR`` will keep all output files in WorkDir.
  A special value ``NAME`` will create a subdirectory with a name of Project.
  If the variable is not set, all output files will be copied or moved
  to the current directory. Default value can be forced by MOLCAS_OUTPUT=PWD.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_OUTPUT" APPEAR="Output Directory" KIND="CHOICE" LIST="????,PWD,?DIR,NAME,WORKDIR" LEVEL="BASIC">
              %%Keyword: MOLCAS_OUTPUT <basic>
              <HELP>
              This variable can alter the default directory for extra output files,
              such as orbitals files, molden files, etc.
              If set, molcas will save output files to the specified directory.
              The directory name can be set in the form of absolute PATH, or
              relative PATH (related to submit directory)
              A special value 'WORKDIR' will keep all output files in WorkDir.
              A special value 'NAME' will create a subdirectory with a name of Project.
              If the variable is not set, all output files will be copied or moved
              to the current directory.
              Default value can be forced by MOLCAS_OUTPUT=PWD
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_PRINT`
  MOLCAS_PRINT variable controls the level of output. The value could be numerical or mnemonic:
  SILENT (0), TERSE (1), NORMAL (2), VERBOSE (3), DEBUG (4) and INSANE (5).

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_PRINT" APPEAR="Print level" KIND="CHOICE" LIST="----,0:SILENT,1:TERSE,2:NORMAL,3:VERBOSE,4:DEBUG,5:INSANE" LEVEL="BASIC">
              %%Keyword: MOLCAS_PRINT <basic>
              <HELP>
              MOLCAS_PRINT variable controls the level of output. The value could be numerical or mnemonic:
              SILENT (0), TERSE (1), NORMAL (2), VERBOSE (3), DEBUG (4) and INSANE (5).
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_PROJECT`
  If set to value NAME, |molcas| will use the prefix of the input file
  as a project name. Otherwise, it set a project name for the calculation.
  If set to the value NAMEPID, the Project name still will be constructed
  from the name of input file, however, the name of scratch area will
  be random.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_PROJECT" APPEAR="Project Policy" KIND="CHOICE" LIST="????,NAME,NAMEPID" LEVEL="BASIC">
              %%Keyword: MOLCAS_PROJECT <basic>
              <HELP>
              If set to the value NAME, molcas will use the prefix of the input file
              as a project name,
              If set to the value NAMEPID, the Project name still will be constructed
              from the name of input file, however, the name of scratch area will
              be random
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_PROPERTIES`
  If MOLCAS_PROPERTIES is set to ``LONG`` properties with the individual MO contributions will be listed.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_PROPERTIES" APPEAR="Property output" KIND="CHOICE" LIST="SHORT,LONG" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_PROPERTIES <advanced>
              <HELP>
              If MOLCAS_PROPERTIES is set to 'LONG' properties with the individual MO contributions will be listed.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_RANDOM_SEED`
  Set to an integer to provide a fixed seed for operations that use a random number.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_RANDOM_SEED" APPEAR="Random number seed" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_RANDOM_SEED <advanced>
              <HELP>
              Set to an integer to provide a fixed seed for operations that use a random number.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_REDUCE_PRT`
  If set to NO, print level in DO WHILE loop is not reduced.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_REDUCE_PRT" APPEAR="Verbose input in do loops" KIND="CHOICE" LIST="----,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_REDUCE_PRT <advanced>
              <HELP>
              If set to NO, print level in DO WHILE loop is not reduced
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_REDUCE_NG_PRT`
  If set to NO, print level in :program:`numerical_gradient` loop is not reduced.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_REDUCE_NG_PRT" APPEAR="Verbose input in numerical_gradient" KIND="CHOICE" LIST="----,NO" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_REDUCE_NG_PRT <advanced>
              <HELP>
              If set to NO, print level in numerical_gradient is not reduced.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_SAVE`
  This variable can alter the default filenames for output files.
  If not set (default), all files will overwrite old files.
  If set to ``INCR`` all output files will get an incremental
  filenames.
  If set to ``ORIG`` --- an existent file will be copied with
  an extension ``.orig``

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_SAVE" APPEAR="Save files as" KIND="CHOICE" LIST="----,INCR,ORIG" LEVEL="BASIC">
              %%Keyword: MOLCAS_SAVE <basic>
              <HELP>
              This variable can alter the default filenames for output files.
              If not set (default), all files will overwrite old files.
              If set to 'INCR' all output files will get an incremental
              filenames.
              If set to 'ORIG' - an existent file will be copied with
              an extension '.orig'
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_TIME`
  If set, switch on timing information for each module

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_TIME" APPEAR="Timing" KIND="CHOICE" LIST="----,YES" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_TIME <advanced>
              <HELP>
              If set, switch on timing information for each module
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_TIMELIM`
  Set up a timelimit for each module (in seconds). By default, the maximum
  execution time is set to unlimited. *Note that this setting is available only
  in MOLCAS compiled without Global Arrays.*

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_TIMELIM" APPEAR="Time Limit" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_TIMELIM <advanced>
              <HELP>
              Set up a timelimit for each module (in seconds). By default, the maximum
              execution time is set to unlimited. Note that this setting is available only
              in MOLCAS compiled without Global Arrays.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_TRAP`
  If set to OFF |molcas| modules will continue to be executed,
  even if a non-zero return code was produced.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_TRAP" APPEAR="Trap on Error" KIND="CHOICE" LIST="----,OFF" LEVEL="ADVANCED">
              %%Keyword: MOLCAS_TRAP <advanced>
              <HELP>
              If set to OFF molcas modules will continue to be executed,
              even if a non-zero return code was produced.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_VALIDATE`
  If set to YES, the input for each module will be validated against the documented syntax,
  and the calculation will stop if it does not pass. If set to CHECK, the input will be
  validated, but the calculation will continue, although the program itself may stop.
  If set to FIRST, the whole input file will be validated prior to the calculation.

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_VALIDATE" APPEAR="Validate input" KIND="CHOICE" LIST="----,YES,CHECK,FIRST" LEVEL="BASIC">
              %%Keyword: MOLCAS_VALIDATE <basic>
              <HELP>
              If set to YES, the input for each module will be validated against the documented syntax,
              and the calculation will stop if it does not pass. If set to CHECK, the input will be
              validated, but the calculation will continue, although the program itself may stop.
              If set to FIRST, the whole input file will be validated prior to the calculation.
              </HELP>
              </KEYWORD>

:variable:`MOLCAS_WORKDIR`
  A parent directory for all scratch areas. It can be set to an
  absolute PATH (recommended), to a relative PATH, or to a special value PWD
  (to use current directory for scratch files)

  .. xmldoc:: <KEYWORD MODULE="ENVIRONMENT" NAME="MOLCAS_WORKDIR" APPEAR="Top WORKDIR" KIND="CHOICE" LIST="?DIR" LEVEL="BASIC">
              %%Keyword: MOLCAS_WORKDIR <basic>
              <HELP>
              A parent directory for all scratch areas. It can be set to an
              absolute PATH (recommended), to a relative PATH, or to a special value PWD
              (to use current directory for scratch files)
              </HELP>
              </KEYWORD>

User can customize his installation by adding MOLCAS environment variable into :file:`molcasrc` file.

Another way of customizing |molcas| is to use prologue and epilogue scripts. If user created a file
:file:`prologue` in :file:`$HOME/.Molcas` directory it will be executed (as :command:`./prologue`) before |molcas| calculation
starts. :file:`epilogue` in :file:`$HOME/.Molcas` directory will be executed at the end of calculation.
Files :file:`module.prologue` and :file:`module.epilogue` contains commands executing before and after
each executable molcas module. These files may use internal |molcas| variables, such as
:variable:`$Project`, :variable:`$WorkDir`, :variable:`$MOLCAS_MEM`, etc. Note that prologue/epilogue scripts should be executable.
For debug purposes, the location of prologue and epilogue files can be set by :variable:`$MOLCAS_LOGUE_DIR` variable.

Example:

:file:`prologue`: ::

  echo Calculation of $Project input will start at `date`

:file:`module.prologue`: ::

  echo Running module $MOLCAS_CURRENT_PROGRAM at $WorkDir

.. xmldoc:: </MODULE>
User's Guide
============

.. toctree::
   :maxdepth: 2

   env-main
   programs
   tools
.. _UG\:sec\:the_basis_set_libraries:

The Basis Set Libraries
=======================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

The basis sets library contains both all-electron and effective core
potentials. They will be briefly described below and we
refer to the publications for more details. The user can also add new
basis sets to the basis directory and the structure of the file will therefore
be described below.

Dummy atoms
-----------

Note that to use dummy atoms the user should employ the basis set label "``X....``". This
will signify centers associated with no charge and no basis functions.

The All Electron Basis Set Library
----------------------------------

The basis set library of |molcas| contains an extensive set of basis sets both
segmented and generally contracted. The files in the basis directory are named
in upper case after the basis type
label (see below). Three sets of generally contracted basis sets have been
especially designed for |molcas|. They are based on the Atomic Natural Orbital
(ANO) concept and are labeled ANO-X (X=S, L, or RCC). They
have been designed to give a balanced description of the atoms in ground,
excited, and ionized states. A more detailed description of these basis sets is
given below. A fourth basis set, which is especially designed for the
calculation of electric properties of molecules (POL) will also be described.

In addition to this, an
subset of segmented standard basis sets are included, for example, STO-3G,
3-21G 4-31G, 6-31G, 6-31G*, 6-31G**, cc-pVXZ (X=D,T,Q), and aug-cc-pVXZ
(X=D,T). In addition, the library also contains different variants of the
Turbomole RI basis sets. For additional all electron basis set we recommend a
visit to the EMSL Basis Set Exchange
(https://bse.pnl.gov/bse/portal).
All basis sets are stored in the
directory :file:`basis_library`. The different types of available basis sets can be
found in the file :file:`basistype.tbl` in this directory. Aliases for the names are
listed in the file :file:`basis.tbl`. However, the best way to find out which basis sets
are available is to issue the command :command:`molcas help basis X` where :command:`X` is the atom.
Note that a short hand notation can be used for most basis sets: for example
ANO-L-VTZP will give a basis set of valence triple zeta accuracy with
polarization functions.

.. include:: basis_library/ANO-S.inc

.. include:: basis_library/ANO-L.inc

.. include:: basis_library/ANO-RCC.inc

.. 6.1 .. include:: basis_library/ANO-DK3.inc

.. include:: basis_library/POL.inc

.. include:: basis_library/AE_library_structure.inc

.. _UG\:sec\:the_ecp_libraries:

The ECP Library
---------------

|molcas| is able to perform *effective core potential* (ECP) calculations
and *embedded cluster* calculations.
In ECP calculations, only the *valence* electrons of a molecule are
explicitly handled in a quantum mechanical calculation,
at a time that the *core* electrons are kept frozen and are represented by
ECP's.
(An example of this is a calculation on :math:`\ce{HAt}` in which only the 5d, 6s and 6p
electrons of Astatine and the one of Hydrogen are explicitly considered.)
Similarly, in *embedded cluster* calculations,
only the electrons assigned to a piece of the whole system (the *cluster*)
are explicitly handled in the quantum mechanical calculation,
under the assumption that they are the only ones relevant for
some local properties under study;
the rest of the whole system (the *environment*)
is kept frozen and represented by embedding potentials
which act onto the *cluster*.
(As an example, calculations on a :math:`\ce{TlF12^{11-}}` cluster embedded in
a frozen lattice of :math:`\ce{KMgF3}` can be sufficient to calculate spectroscopical
properties of :math:`\ce{Tl^+}`\-doped :math:`\ce{KMgF3}` which are due to the :math:`\ce{Tl+}`
impurity.)

In order to be able to perform ECP calculations in molecules, as well as
*embedded cluster* calculations in ionic solids, with the
Ab Initio Model Potential method
(AIMP) :cite:`Huzinaga:87,Barandiaran:88,Barandiaran:90,Wittborn:95,Rakowitz:99a,Rakowitz:99b`
|molcas| is provided with the library
:file:`ECP` which includes nonrelativistic and relativistic
*core* ab initio model potentials and
*embedding* ab initio model potentials
representing both complete-cations and complete-anions in ionic
lattices :cite:`Barandiaran:88,Barandiaran:92`.

Before we continue we should comment a little bit on the terminology used here.
Strictly speaking, ECP methods are all that use the frozen-core approximation.
Among them, we can distinguish two families: the "pseudopotential" methods
and the "model potential" methods.
The pseudopotential methods are ultimately based on the
Phillips--Kleinman equation :cite:`Phillips:59`
and handle valence nodeless pseudo orbitals.
The model potential methods are based on the Huzinaga
equation :cite:`Huzinaga:71,Huzinaga:73`
and handle node-showing valence orbitals;
the AIMP method belongs to this family.
Here, when we use the general term ECP we will be referring to the more
particular of AIMP.
According to its characteristics,
the AIMP method can be also applied to represent
frozen-ions in ionic lattices in embedded cluster calculations;
in this case,
we will not be very strict in the nomenclature and we will also call ECP's
to the frozen-ion (embedding) *ab initio* model potentials.

The effective potentials in the libraries include the effects of the atomic
core wave functions (embedding ion wave functions) through the
following operators:

* a local representation of the core (ion) Coulomb operator,
* a non-local spectral representation of the core (ion) exchange operator,
* a core (ion) projection operator,
* a spectral representation of the relativistic mass-velocity and
  Darwin operators corresponding to the valence orbitals,
  if the Cowan--Griffin-based scalar relativistic
  CG-AIMP method :cite:`Barandiaran:90` is used.
* a spectral representation of the relativistic no-pair Douglas--Kroll
  operators, if the scalar relativistic no-pair Douglas--Kroll NP-AIMP method
  :cite:`Wittborn:95,Rakowitz:99a,Rakowitz:99b` is used.

Given the quality and non-parametric nature of the operators
listed above, the flexibility of the basis sets to be used
with the AIMP's is crucial, as in any *ab initio* method.

The valence basis sets included in the libraries
have been obtained by energy minimization in atomic valence-electron
calculations,
following standard optimization procedures.
All the experience gathered in the design of
molecular basis sets starting from all-electron atomic basis sets,
and in particular from segmented minimal ones,
is directly applicable to the AIMP valence basis sets included in
the libraries.
They are, for non-relativistic and relativistic Cowan--Griffin AIMPs, minimal
basis sets with added functions,
such as polarization and diffuse functions;
in consequence,
the minimal sets should be split in molecular calculations
in order to get reasonable sets (a splitting pattern
is recommended in the library for every set);
the splitting can be done by means of "the basis set label".
For the relativistic no-pair Douglas--Kroll AIMPs contracted valence basis sets
are given directly in a form which is recommended in molecular calculations,
i.e. they are of triple zeta quality in the outer shells and contain
polarization functions.
In both cases these *valence* basis sets contain very
*inner* primitive GTF's: They are necessary since,
typical to a model potential method,
the valence orbitals will show correct nodal structure.
Finally, it must be noted that
the core AIMP's can be safely mixed together with all-electron basis sets.

In AIMP *embedded cluster calculations*,
the cluster basis set,
which must be decided upon by the user,
should be designed following high quality standard procedures.
Very rigid cluster basis sets should not be used.
In particular,
the presence of the necessary embedding projection operators,
which prevent the cluster densities from collapsing onto the crystal lattice,
demands flexible cluster bases, including, eventually,
components outside the cluster volume :cite:`Pascual:93`.
The use of flexible cluster basis sets is then a
necessary requirement to avoid artificial frontier effects,
not ascribable to the AIMP embedding potentials.
This requirement is unavoidable, anyway, if good correlated wave
functions are to be calculated for the cluster.
Finally, one must remember that
the AIMP method does exclude any correlation between the
cluster electronic group
and the embedding crystal components; in other words, only
intra-cluster correlation effects can be accounted for in
AIMP embedded cluster calculations.
Therefore the cluster-environment partition
and the choice of the cluster wave function
must be done accordingly. In particular, the use of
one-atom clusters is not recommended.

Core- and embedding-AIMP's can be combined in a natural way
in valence-electron, embedded cluster calculations.
They can be used with any of the different types of wave
functions that can be calculated with |molcas|.

.. include:: basis_library/ECP.inc

.. include:: basis_library/ECP.nodeless.inc

.. include:: basis_library/ECP_library_structure.inc
Programs
========

.. note::

   Programs marked with |extramark| are *not* available in |openmolcas|.

.. toctree::
   :maxdepth: 1

   programs/alaska
   programs/averd
   programs/caspt2
   programs/casvb
   programs/ccsdt
   programs/chcc
   programs/cht3
   programs/cmocorr
   programs/cpf
   programs/dimerpert
   programs/dmrgscf
   programs/dynamix
   programs/embq
   programs/espf
   programs/expbas
   programs/extf
   programs/falcon
   programs/false
   programs/ffpt
   programs/gateway
   programs/genano
   programs/geo
   programs/grid_it
   programs/guessorb
   programs/guga
   programs/gugaci
   programs/gugadrt
   programs/localisation
   programs/loprop
   programs/mbpt2
   programs/mckinley
   programs/mclr
   programs/mcpdft
   programs/mknemo
   programs/motra
   programs/mpprop
   programs/mpssi
   programs/mrci
   programs/mula
   programs/nemo
   programs/nevpt2
   programs/numerical_gradient
   programs/poly_aniso
   programs/qmstat
   programs/quater
   programs/rasscf
   programs/rassi
   programs/rhodyn
   programs/rpa
   programs/scf
   programs/seward
   programs/single_aniso
   programs/slapaf
   programs/surfacehop
   programs/symmetrize
   programs/vibrot
   programs/wfa

   basis_library
.. _UG\:sec\:EMIL:

General input structure. EMIL commands
======================================

.. xmldoc:: %%Description:
            EMIL commands

This is a general guide to the input structure of the programs in the
|molcas| program system. All programs conform to the same conventions
except where explicitly stated otherwise.

.. TODO: Note nested markup is currently not supported
   (|molcas| is not substituted if included in the italic text)

The programs are driven by keywords, which are either used without
further information, or followed by additional specifications on the
line(s) following the keyword, and is normally numeric in nature.
*All numerical inputs are read in free format, note that in general*
|molcas| *will not be able to process lines longer than 120 characters.*
The keywords can be given in mixed case (both upper and lower case are
allowed). In the input stream you can
insert comment lines anywhere, except between a keyword and the
following additional specifications, with a comment line identified by
an asterisk (*) in the first position on the line.

Most codes look at the first 4 characters of the keyword and ignores the
rest.
The entries in the lists of keywords below follow the
standard that the significant characters are in upper case and larger
than the nonsignificant characters.
This do not imply that the keywords have to be typed in upper case;
they can be typed freely in mixed case.

.. compound::

  All inputs begin with a name of the program followed by the keywords: ::

    &PROGRAM
    * here follows the keywords

  where PROGRAM is the name of the |molcas| module. The input listing is finished
  when a new program name, precede by the symbol &, is found (or the end of
  file or an EMIL command).

The following is an example of a list of keywords common to most of the
programs:

.. class:: keywordlist

:kword:`TITLe`
  This keyword starts the reading of title line.
  The following line is treated as title line.

The programs only decode the first four characters of a keyword
(except otherwise specifically indicated). For clarity it is however
recommended to write the full keyword name. The keywords can be typed freely
in upper, lower or mixed case.

An example for an input file used to run the :program:`SCF` program follows: ::

  &SCF
  Title
   Water molecule. Experimental equilibrium geometry
  * The symmetries are: a1, b2, b1 and a2.
  Occupied
  3 1 1 0
  * The ivo keyword prepares virtual orbitals for MCSCF.
  Ivo

Interpretation of |molcas| input is performed by :file:`molcas.exe`.
The internal language used by :file:`molcas.exe` is EMIL (Extended Molcas Input
Language).
It includes two different types of input commands:

* Sections with |molcas| input.
* EMIL commands (a line started with > character)

|molcas| input
--------------

EMIL allows to write |molcas| input in a more compact way:
user can omit :variable:`&END`, as well as a compulsory (in previous versions of |molcas|) keyword :kword:`End of input`.
As soon as a new module (or EMIL command) is requested in
a user input, the input for the module is terminated.

Also, it is possible to separate lines by ``;`` sign, or by ``=`` sign (to create
a pair ``keyword=value``). In some rare occasions signs ``;`` and ``=`` are used in
the input for a |molcas| module. In order to keep these symbols unchanged, user can
mark a part of an input, containing these symbols, by EMIL commands ``>> verbatim`` and
``>> end verbatim``.

.. compound::

  It means that the input: ::

    &SCF &END
    CHARGE
     1
    End of input
    &ALASKA &END
    End of input
    &SLAPAF &END
    End of input

  could be written as: ::

    &SCF; CHARGE=1
    &ALASKA; &SLAPAF

User can comment parts of input, by using ``*`` at the beginning of line,
or use C-style comments (``/* ... */``) to comment several lines.

In a rare occasion user might want to execute a UNIX command from
the input. It is important to understand that not all UNIX commands
can be understood and interpreted by EMIL. Also, EMIL should know
where to execute a command -- only at the master node, or for all
parallel tasks. In the past, EMIL supports the usage of commands
started from an exclamation mark, or with command :command:`UNIX`.
To avoid confusions, the serial execution of a command is now related to :command:`SHELL`,
and the parallel execution to :command:`EXEC`.

.. _UG\:sec\:emil_commands:

EMIL commands
-------------

.. compound::

  EMIL commands can be written in a short form: ::

    > KEY [VALUE]

  or in a nice form: ::

    >>>>>>>>>>  KEY  [VALUE]  <<<<<<<<<

EMIL commands are not case sensitive, but the variables used in commands must be written in upper case.
Also, it is important to place spaces in between elements (words) in the commands.

Here is a list of EMIL commands:

.. xmldoc:: <EMIL>

.. class:: commandlist

:command:`>> EXPORT A=B`
  a command to set environment variable A to value B

  .. xmldoc:: <COMMAND NAME="EXPORT" APPEAR="Export" FORMAT="EXPORT %s = %s" SHOWVALUE="TRUE">
              %%Keyword: EXPORT <basic>
              <HELP>
              A command to export environment variable in a form A=B
              </HELP>
              </COMMAND>

:command:`>> EXIT`
  a command to terminate execution.
  An optional value for this command is the return code (default value is 0)

  .. xmldoc:: <COMMAND NAME="EXIT" APPEAR="Exit" FORMAT="EXIT">
              %%Keyword: EXIT <basic>
              <HELP>
              A command to terminate execution.
              An optional value for this command is the return code (default value is 0)
              </HELP>
              </COMMAND>

:command:`>> INCLUDE file`
  a command to include a file into the input
  A compulsory value for this command is the filename.

  .. xmldoc:: <COMMAND NAME="INCLUDE" APPEAR="Include file" FORMAT="INCLUDE %s" LEVEL="HIDDEN">
              %%Keyword: INCLUDE <basic>
              <HELP>
              A command to include file

                >> INCLUDE filename
              </HELP>
              </COMMAND>

:command:`>> FILE file`
  A compulsory value for this command is the filename. A command to inline a
  file in the input file. The file will be extracted into WorkDir before the
  start of the calculation. The end of file should be marked as :command:`EOF` command.
  Not that the file is only created in the master process WorkDir, if the slaves
  need access to it, you'll need to use the :command:`COPY` command (see below).
  All files specified with :command:`FILE` are created at the beginning of the calculation,
  regardless of their placement in the input.

  .. xmldoc:: <COMMAND NAME="FILE" APPEAR="Inline file" FORMAT="FILE %s" LINK_ANCHOR="EOF" CONTENT="ANY">
              %%Keyword: FILE <basic>
              <HELP>
              A command to inline a file in the input file. The file will be extracted into
              WorkDir before the start of the calculation

                >> FILE filename
                ...
                >> EOF
              </HELP>
              </COMMAND>

:command:`>> EOF`
  A command to close inlined file.

  .. xmldoc:: <COMMAND NAME="EOF" APPEAR="EOF" FORMAT="EOF">
              %%Keyword: EOF <basic>
              <HELP>
              A command to close inlined file.
              </HELP>
              </COMMAND>

:command:`>> SHELL`
  a command to execute a unix command in serial.

  .. xmldoc:: <COMMAND NAME="SHELL" APPEAR="Serial shell" FORMAT="SHELL %s" SHOWVALUE="TRUE">
              %%Keyword: SHELL <basic>
              <HELP>
              A command to define a unix command to be executed in serial.
              </HELP>
              </COMMAND>

:command:`>> EXEC`
  a command to execute a unix command in parallel.

  .. xmldoc:: <COMMAND NAME="EXEC" APPEAR="Parallel shell" FORMAT="EXEC %s" SHOWVALUE="TRUE">
              %%Keyword: EXEC <basic>
              <HELP>
              A command to define a unix command to be executed in parallel.
              Note that any special characters are ignored.
              </HELP>
              </COMMAND>

:command:`>> LINK`
  a command to make a link between two files, located in WorkDir. The command is similar to
  ``!ln -s FILE1 FILE2`` but in parallel environment it is executed in all WorkDirs. The command assumes that
  FILE1 does exist, and FILE2 does not at the moment. >>LINK -FORCE allows
  to link a file which does not exist. User should avoid the usage of LINK commands in the input.

  .. xmldoc:: <COMMAND NAME="LINK" APPEAR="Link" FORMAT="LINK %s %s" FILE_INDEX="0" VALUES="????|????.OR.ITER" SHOWVALUE="TRUE">
              %%Keyword: LINK <basic>
              <HELP>
              A command to link two files located in WorkDir.
              The command is similar to '!ln -s FILE1 FILE2' but in parallel environment it is
              executed in all WorkDirs. The command assumes that FILE1 does exist, and FILE2 does not.
              >>LINK -FORCE allows to link a file FILE1 which does not exist at the moment. User should
              avoid the usage of LINK commands in the input.
              </HELP>
              </COMMAND>

:command:`>> COPY`
  a command to make a copy. The command is similar to ``!cp -f
  /path/to/FILE1 FILE2`` but can be used also in a parallel environment, in which case it
  will take the source file and distribute to the work directories of all
  processes. The destination must be located in the work directory. Note that
  EMIL command does not allow to use masks in the command. If FILE1 does not
  exist, the command returns an error code.

  .. xmldoc:: <COMMAND NAME="COPY" APPEAR="Copy to all" FORMAT="COPY %s %s" FILE_INDEX="0" SHOWVALUE="TRUE">
              %%Keyword: COPY <basic>
              <HELP>
              A command to copy one file to another. The command is similar to '!cp -f
              /path/to/FILE1 FILE2' but can be used also in a parallel environment, in which case it
              will take the source file and distribute to the work directories of all
              processes. The destination must be located in the work directory. Note that
              EMIL command does not allow to use masks in the command. If FILE1 does not
              exist, the command returns an error code.
              </HELP>
              </COMMAND>

:command:`>> CLONE`
  a command to make a clone copy of a file, doing a local copy on
  all slaves if parallel. It is mostly used internally, e.g. to distribute an input
  file to all WorkDirs.

  .. xmldoc:: <COMMAND NAME="CLONE" APPEAR="Copy on all" FORMAT="CLONE %s %s" FILE_INDEX="0" SHOWVALUE="TRUE">
              %%Keyword: CLONE <basic>
              <HELP>
              A command to make a clone copy of a file, doing a local copy on
              all slaves if parallel. It is mostly used internally, e.g. to distribute an input
              file to all WorkDirs.
              </HELP>
              </COMMAND>

:command:`>> COLLECT`
  A command to copy one file to another, collecting files on
  slaves and put them on the master if parallel. It is mostly used internally, e.g.
  to collect output files.

  .. xmldoc:: <COMMAND NAME="COLLECT" APPEAR="Collect from slaves" FORMAT="COLLECT %s %s" FILE_INDEX="0" SHOWVALUE="TRUE">
              %%Keyword: COLLECT <basic>
              <HELP>
              A command to copy one file to another, collecting files on slaves and put them on the master if parallel
              </HELP>
              </COMMAND>

:command:`>> SAVE`
  A command to copy one file to another, only on the master if parallel

  .. xmldoc:: <COMMAND NAME="SAVE" APPEAR="Copy on master" FORMAT="SAVE %s %s" FILE_INDEX="0" SHOWVALUE="TRUE">
              %%Keyword: SAVE <basic>
              <HELP>
              A command to copy one file to another, only on the master if parallel
              </HELP>
              </COMMAND>

:command:`>> RM`
  a command to delete a file. The command is similar to ``!rm
  FILE`` but can be used also in parallel environment. Note that EMIL command
  does not allow to use masks in the command. An attempt to remove non existent
  file leads to an error. It is possible to use -FORCE flag to allow deleting
  of non-existent file.

  .. xmldoc:: <COMMAND NAME="RM" APPEAR="Delete" FORMAT="RM %s" FILE_INDEX="0" SHOWVALUE="TRUE">
              %%Keyword: RM <basic>
              <HELP>
              A command to delete a file. The command is similar to '!rm
              FILE' but can be used also in parallel environment. Note that EMIL command
              does not allow to use masks in the command. An attempt to remove non existent
              file leads to an error. It is possible to use -FORCE flag to allow deleting
              of non-existent file.
              </HELP>
              </COMMAND>

:command:`>> EVAL A=B`
  evaluate a numerical value

  .. xmldoc:: <COMMAND NAME="EVAL" APPEAR="Evaluate" FORMAT="EVAL %s = %s">
              %%Keyword: EVAL <basic>
              <HELP>
              A command to evaluate numerical expression, e.g. eval A=$A+1
              </HELP>
              </COMMAND>

Keywords to organize loops in input, and execute modules conditionally:

.. class:: commandlist

:command:`>> DO WHILE`
  a command to start a loop. The loop should be terminated by SLAPAF or LOOP module,
  followed by ENDDO command

  .. xmldoc:: <COMMAND NAME="DO" APPEAR="Do loop" FORMAT="DO WHILE" LINK_ANCHOR="ENDDO">
              %%Keyword: DO WHILE <basic>
              <HELP>
              A command to start a loop. The loop should be terminated by SLAPAF or LOOP module,
              followed by ENDDO command
              </HELP>
              </COMMAND>

:command:`>> DO GEO`
  a command to start a special loop for geometry optimization
  with constrained internal coordinates. The loop should be terminated by
  ENDDO command. (See documentation for :program:`GEO` for more details.)

  .. xmldoc:: <COMMAND NAME="DOGEO" APPEAR="Geo loop" FORMAT="DO GEO" LINK_ANCHOR="ENDDO">
              %%Keyword: DO GEO <basic>
              <HELP>
              A command to start a constrained geometry optimization loop. The loop should be
              terminated by an ENDDO command
              </HELP>
              </COMMAND>

:command:`>> FOREACH A in (B, C, D)`
  a command to loop when the value of A is in the comma or space separated list.
  The list also can be written in the format ``From .. To``. Note that variable in the loop must be uppercased.

  .. xmldoc:: <COMMAND NAME="FOREACH" APPEAR="Foreach loop" FORMAT="FOREACH %s IN ( %s )" LINK_ANCHOR="ENDFOREACH" SHOWVALUE="TRUE">
              %%Keyword: FOREACH <basic>
              <HELP>
              A command to loop when the value of A is in the comma or space separated list.

                >> foreach A in (B,C,D)

              The list also can be written in the format "From .. To".
              Note that variable in the loop must be uppercased.
              </HELP>
              </COMMAND>

  .. xmldoc:: <COMMAND NAME="ENDFOREACH" FORMAT="END FOREACH" />

:command:`>> ENDDO`
  a command to finish the loop. If last module (before ENDDO command) returns
  1 --- the loop will be executed again (if number of iterations is less than MAXITER).
  If the return code is equal to 0 the loop will be terminated.

  .. xmldoc:: <COMMAND NAME="ENDDO" FORMAT="END DO">
              %%Keyword: ENDDO <basic>
              <HELP>
              A command to finish the loop.
              </HELP>
              </COMMAND>

:command:`>> IF ( ITER = N )`
  a command to make conditional execution of modules/commands on iteration N (N possibly could be a space separated list)

:command:`>> IF ( ITER NE N )`
  a command to skip execution of modules/commands on iteration N

:command:`>> IF ( ITER != N )`
  same as above

  .. xmldoc:: <COMMAND NAME="IF" APPEAR="Condition" FORMAT="IF ( %s %s %d )" VALUES="ITER.OR.????|=.OR.!=" LINK_ANCHOR="ENDIF" SHOWVALUE="TRUE">
              %%Keyword: IF ITER <basic>
              <HELP>
              A command to make conditional execution of modules/commands on iteration N
              </HELP>
              </COMMAND>

:command:`>> IF ( $VAR = N )`
  a command to make conditional execution if $VAR value equals to N (if statement terminated by ENDIF command)

:command:`>> IF ( $VAR = N ) GOTO JUMP`
  a command to make conditional goto to a label JUMP

:command:`>> IF ( -FILE file )`
  test for existence of a file

  .. xmldoc:: <COMMAND NAME="IFGOTO" APPEAR="Conditional jump" FORMAT="IF ( %s %s %d ) GOTO %s" VALUES="ITER.OR.????|=.OR.!=" LINK_ANCHOR="LABEL" LINK_VALUE_INDEX="3" SHOWVALUE="TRUE">
              %%Keyword: IF  <advanced>
              <HELP>
              A command to make conditional execution.
              Allowed syntax:

              * IF ( $VAR = 7 )           (IF statement terminated by ENDIF)
              * IF ( $VAR = 7 ) GOTO JUMP (jump to label JUMP)
              * IF ( -FILE file )         (test for existence of a file, terminated by ENDIF)
              </HELP>
              </COMMAND>

:command:`>> LABEL JUMP`
  a command to define a label. Note! Only forward jumps are allowed.

  .. xmldoc:: <COMMAND NAME="LABEL" APPEAR="Label" FORMAT="LABEL %s" LINK_TARGET="0" SHOWVALUE="TRUE">
              %%Keyword: LABEL <advanced>
              <HELP>
              A command to define a label. Note! Only forward jumps are allowed.
              </HELP>
              </COMMAND>

:command:`>> ENDIF`
  terminate :command:`IF` block. Note nested if's are not allowed.

  .. xmldoc:: <COMMAND NAME="ENDIF" FORMAT="END IF">
              %%Keyword: ENDIF  <basic>
              <HELP>
              Terminate IF block. Note nested if's are not allowed.
              </HELP>
              </COMMAND>

EMIL interpreter automatically stops calculation if a module returns a returncode
higher than 0 or 1. To force the interpretor to continue calculation even if a
returncode equal to 16 (which is a return code for non-convergent calculation) one
should set environment variable MOLCAS_TRAP=\ ``OFF``.

:program:`SLAPAF` returns a special return code in the case of converged (non converged) geometry.
So, to organize a structure calculation one should place the call to
:program:`SLAPAF` as a last statement of loop block. The summary of geometry optimization
convergence located in a file :file:`$Project.structure`.
The programs following a geometry optimization will automatically
assume the optimized geometry and wave function. Any new :program:`SEWARD`
calculation after an optimization (minimum or transition state) will
disregard the input coordinates and will take the geometry optimized at previous step.

It is also possible to use a special dummy program :program:`LOOP` to organize
infinite loops, or loops terminated by the counter (set by MOLCAS_MAXITER)

Keyword :kword:`SET` is obsolete and should be changed to :kword:`EXPORT`.

Verbatim input.

If an input for a module must contain special symbols, such as ``;`` or ``=``, user can
mark a corresponding part of the input by EMIL command :command:`VERBATIM`

.. class:: commandlist

:command:`>> VERBATIM <<`
  start verbatim input

  .. xmldoc:: <COMMAND NAME="VERBATIM" APPEAR="Verbatim" FORMAT="VERBATIM" LEVEL="HIDDEN" LINK_ANCHOR="ENDVERBATIM" CONTENT="ANY" />
              %%Keyword: VERBATIM <advanced>
              Start verbatim input

:command:`>> END VERBATIM <<`
  finish verbatim input

  .. xmldoc:: <COMMAND NAME="ENDVERBATIM" FORMAT="END VERBATIM" LEVEL="HIDDEN" />
              %%Keyword: END VERBATIM <advanced>
              Finish verbatim input

.. xmldoc:: </EMIL>

.. .. xmldoc:: <MODULE NAME="COMMENT" LEVEL="HIDDEN">
                 <KEYWORD MODULE="COMMENT" NAME="UNDEFINED" APPEAR="Unrecognized Content" KIND="STRINGS" LEVEL="BASIC" />
               </MODULE>

   .. xmldoc:: <MODULE NAME="DEMO">
                 <KEYWORD MODULE="DEMO" NAME="CHECKBOX" APPEAR="Check Appear" KIND="SINGLE" />
                 <KEYWORD MODULE="DEMO" NAME="INTTEXT" KIND="INT" REQUIRE="CHECKBOX" DEFAULT_VALUE="1" />
                 <KEYWORD MODULE="DEMO" NAME="REALTEXT" KIND="REAL" MIN_VALUE="0" MAX_VALUE="100.0" />
                 <KEYWORD MODULE="DEMO" NAME="STRINGTEXT" KIND="STRING" />
                 <KEYWORD MODULE="DEMO" NAME="INTTABLE" KIND="INTS" SIZE="3" />
                 <KEYWORD MODULE="DEMO" NAME="REALTABLE" KIND="REALS" SIZE="3" />
                 <KEYWORD MODULE="DEMO" NAME="MULTILINESTRING" KIND="STRINGS" SIZE="3" />
                 <KEYWORD MODULE="DEMO" NAME="MANYLINESTRING" KIND="STRINGS" />
                 <KEYWORD MODULE="DEMO" NAME="COMBOBOX" KIND="CHOICE" LIST="CHO1,CHO2,CHO3" />
                 <KEYWORD MODULE="DEMO" NAME="INTTABLE_COMPUTED" KIND="INTS_COMPUTED" SIZE="2" />
                 <KEYWORD MODULE="DEMO" NAME="COMPUTED_REALTABLE" KIND="REALS_COMPUTED" SIZE="3" />
                 <KEYWORD MODULE="DEMO" NAME="LOOKUP_INTTABLE" KIND="INTS_LOOKUP" SIZE="NSYM" />
                 <KEYWORD MODULE="DEMO" NAME="FILELOAD" KIND="FILE" />
                 <SELECT MODULE="DEMO" NAME="SELECTION" CONTAINS="SEL1,SEL2,SEL3">
                   <KEYWORD MODULE="DEMO" NAME="SEL1" KIND="REALS" SIZE="2" EXCLUSIVE="SEL2,SEL3" />
                   <KEYWORD MODULE="DEMO" NAME="SEL2" KIND="INTS" SIZE="3" EXCLUSIVE="SEL1,SEL3" />
                   <KEYWORD MODULE="DEMO" NAME="SEL3" KIND="SINGLE" EXCLUSIVE="SEL1,SEL2" />
                 </SELECT>
                 <GROUP MODULE="DEMO" NAME="BOXGROUP" KIND="BOX" WINDOW="INPLACE">
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX1" KIND="SINGLE" EXCLUSIVE="CHECKBOX2,CHECKBOX3" />
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX2" KIND="SINGLE" EXCLUSIVE="CHECKBOX1,CHECKBOX3" />
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX3" KIND="SINGLE" EXCLUSIVE="CHECKBOX1,CHECKBOX2" />
                   <KEYWORD MODULE="DEMO" NAME="REALTEXT1" KIND="REAL" MIN_VALUE="0" MAX_VALUE="100.0" />
                 </GROUP>
                 <GROUP MODULE="DEMO" NAME="BLOCKGROUP" KIND="BLOCK" WINDOW="POPUP">
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX4" KIND="SINGLE" EXCLUSIVE="CHECKBOX5,CHECKBOX6" />
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX5" KIND="SINGLE" EXCLUSIVE="CHECKBOX4,CHECKBOX6" />
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX6" KIND="SINGLE" EXCLUSIVE="CHECKBOX4,CHECKBOX5" />
                   <KEYWORD MODULE="DEMO" NAME="REALTEXT2" KIND="REAL" MIN_VALUE="0" MAX_VALUE="100.0" />
                 </GROUP>
                 <GROUP MODULE="DEMO" NAME="RADIOGROUP" KIND="RADIO" WINDOW="TAB">
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX7" KIND="SINGLE" />
                   <KEYWORD MODULE="DEMO" NAME="CHECKBOX8" KIND="SINGLE" />
                   <KEYWORD MODULE="DEMO" NAME="REALTEXT3" KIND="REAL" MIN_VALUE="0" MAX_VALUE="100.0" />
                 </GROUP>
               </MODULE>

Below are different input examples.

The first example shows the procedure to perform first a :program:`CASSCF`
geometry optimization of the water molecule, then a numerical hessian
calculation on the optimized geometry, and later to make a :program:`CASPT2`
calculation on the optimized geometry and wave function. Observe that
the position of the :program:`SLAPAF` inputs controls the data required
for the optimizations.

.. extractfile:: ug/EMIL.loop.input

  *
  *    Start Structure calculation
  *
  >>EXPORT MOLCAS_MAXITER=50
   &GATEWAY
  coord
  $MOLCAS/Coord/Water.xyz
  BASIS = ANO-S

  >>>>>>>>>>>>> Do while <<<<<<<<<<<<
   &SEWARD
  >>>>>>>> IF ( ITER = 1 ) <<<<<<<<<<
   &SCF
  >>>>>>> ENDIF <<<<<<<<<<<<<<<<<<<<

   &RASSCF
  Title
   H2O ANO(321/21).
  Nactel   = 6  0  0
  Spin     = 1
  Inactive = 1  0  0  0
  Ras2     = 3  1  0  2

   &ALASKA; &SLAPAF

  >>>>>>>>>>>>> ENDDO <<<<<<<<<<<<<<

   &CASPT2
  Maxit = 20
  Lroot = 1
   &GRID_IT

Another example demonstrate a possibility to use loops. SCF module
will be called twice --- first time with BLYP functional,
second time with B3LYP functional.

.. extractfile:: ug/EMIL.foreach.input

  *------------------------------------------------------
   &GATEWAY
  coord
  $MOLCAS/Coord/C2H6.xyz
  basis
  ANO-S-VDZ
  group
  y xz
  *------------------------------------------------------
   &SEWARD
  Title
  Ethane DFT test job
  *------------------------------------------------------
  >>foreach DFT in (BLYP, B3LYP )
   &SCF ; KSDFT = $DFT
  >>enddo
  *------------------------------------------------------

The next examples calculates HF energy for the several structures:

.. extractfile:: ug/EMIL.foreach.coord.sample

  * modify coordinates in place
  >>foreach DIST in (1.0, 2.0, 20.0)
   &GATEWAY
  Coord
  2
  hydrogen molecule
  H 0 0 0
  H $DIST 0 0
  BASIS= ANO-S-MB
  GROUP= C1
   &SEWARD
   &SCF
  UHF
  SCRAMBLE=0.3
  >>enddo

  * incremental change of coordinates
  >>export DIST=1.0
  >>foreach L in ( 1 .. 3 )
  >>eval DIST=$DIST+0.1
   &GATEWAY
  Coord
  2
  hydrogen molecule
  H 0 0 0
  H $DIST 0 0
  BASIS= ANO-S-MB
  GROUP= C1
   &SEWARD
   &SCF
  >>enddo

  * different coordinate files
  >> FILE H2001.xyz
  2

  H  0.300000000  0.000000000  0.000000000
  H -0.300000000  0.000000000  0.000000000

  >> FILE H2002.xyz
  2

  H  0.350000000  0.000000000  0.000000000
  H -0.350000000  0.000000000  0.000000000

  >> FILE H2003.xyz
  2

  H  0.400000000  0.000000000  0.000000000
  H -0.400000000  0.000000000  0.000000000

  >>foreach COO in ( 000, 001, 002)
   &GATEWAY
  Coord = H2$COO.xyz
  BASIS= ANO-S-MB
  GROUP= C1
   &SEWARD
   &SCF
  >>enddo

Use of shell parameters in input
--------------------------------

The |molcas| package allows the user to specify parts or variables in the the
input file with shell variables, which subsequently are dynamically defined
during execution time. **Note:** the shell variable names must be in upper
case. Find below a simple example where a part of the :math:`\ce{H2}` potential curve
is computed. First, the script used to run the calculation: ::

  #! /bin/sh
  #
  Home=`pwd` ;                     export Home
  Project=H2 ;                     export Project
  WorkDir=/tmp/$Project ;          export WorkDir
  #
  # Create workdir and cd to it
  #
  rm -fr $WorkDir
  mkdir $WorkDir
  #
  # Loop over distances
  #
  for R in 0.5 0.6 0.7 0.8 0.9 1.0
  do
     export R
     molcas $Home/$Project.input > $Home/$Project-$R-log 2> $Home/$Project-$R-err
  done
  #
  # Cleanup WorkDir
  #
  rm -fr $WorkDir

In this sh shell script we have arranged the call to the |molcas| package inside a loop over
the various values of the distances. This value is held by the variable $R which is
exported every iterations. Below is the input file used, note that the third cartesian
coordinate is the variable $R. ::

  &SEWARD
  Symmetry
   x y z
  Basis set
  H.sto-3g....
  H   0.000   0.000   $R
  End of basis
  End of input

  &SCF

Customization of molcas input
-----------------------------

EMIL interpretor supports templates (aliases) for a group of program calls
or/and keywords. The definition of these templates can be located in file :file:`alias`
located at |molcas| root directory, or at :file:`.Molcas/` directory.
The definition should be written in the following format: ``@name { sequence of EMIL commands }``.
In order to use the alias, the input should contain ``@name``.

.. compound::

  For example, user can define ::

    @DFTgeometry {
    >> DO WHILE
     &SEWARD
     &SCF; KSDFT=B3LYP;
     &SLAPAF
    >>ENDDO
    }

  and so, an input for geometry optimization can be written in the following form: ::

    &GATEWAY; Coord=Water.xyz; Basis = ANO-L-MB;
    @DFTgeometry

It is also possible to use parameters. In the alias file, possible parameters
have names: ``$1``, ``$2``, etc. up to 5 parameters.
In the user input an alias should be followed by parenthesis with comma separated list
of values.

Modifying the previous example: ::

  @DFTgeometry {
  >> DO WHILE
   &SEWARD
   &SCF; CHARGE=$1; KSDFT=$2;
   &SLAPAF
  >>ENDDO
  }

Input file now looks like: ::

  @DFTgeometry(0,B3LYP)
.. _UG\:environment:

The |molcas| environment
========================

This section describes how to use the |molcas| program system. The
reader is assumed to be familiar with the workings of the operating
system, and only issues that are |molcas| specific will be covered.

.. toctree::
   :maxdepth: 2

   env-overview
   environment
   emil
Overview
========

|molcas| contains a set of ab initio quantum chemical programs. These
programs are essentially separate entities, but they are tied
together by a shell. The exchange of information between the programs
is through files. The shell is designed to allow ease of use with a
minimum amount of specifications in a "run of the mill" case. The
shell is flexible and allows the user to perform any calculation
possible within the limitations of the various codes supplied with
|molcas|.

To make a calculation using |molcas| you have to decide on which
programs you need to use, prepare input for these, and construct a
command procedure file to run the various programs. This command
procedure file is submitted for batch execution. The following two
subsections describe the programs available and the files used in
|molcas|.

.. _UG\:sec\:progs_list:

Programs in the system
----------------------

Below is a list of the available programs given. The programs are tied
together with a shell and the inter-program information is passed
through files. These files are also specified in this list to indicate
the program module interdependencies.

.. class:: programlist

:program:`ALASKA`
  This program computes the first derivatives of the one- and
  two-electron integrals with respect to the nuclear positions.
  The derivatives are not stored on files, but contracted
  immediately with the one- and two-electron densities to form the
  molecular gradients.

  .. :program:`AUTO`
       This is a shell-script but is implemented into the
       |molcas| framework as if it is a program.
       In oder to avoid writing shell scripts for each job, this script
       contains all logics required to perform any type of calculation
       using a single input file and will invoke all programs.

:program:`CASPT2`
  This program computes the second order Many Body Perturbation Theory
  correction to CASSCF or RASSCF wave function.

:program:`CASVB`
  This program performs various types of valence bond calculations.
  It may be called directly (for VB interpretation of CASSCF wave functions),
  or within the RASSCF program (for fully variational VB calculations).
  In the former case it requires the information in the
  :file:`JOBIPH` file generated by the :program:`RASSCF` program, possibly also the
  integral files :file:`ONEINT` and :file:`ORDINT`.

:program:`CCSDT`
  This program performs the iterative ROHF CCSD procedure,
  optionally followed by the (T) calculation contribution.
  It requires the :file:`JOBIPH` file produced by
  :program:`RASSCF`, and :file:`TRAONE` and :file:`TRAINT` files produced by :program:`MOTRA`.

:program:`CHCC`
  This program performs Closed-Shell Coupled-Clusters Singles and
  Doubles calculations based exclusively on the Cholesky (or RI)
  decomposed 2-electron integrals.

:program:`CMOCORR`
  This program compares the orbital spaces of two orbitals files.

:program:`CPF`
  This program produces a CPF, MCPF or ACPF wave function from a
  single reference configuration.

:program:`DYNAMIX`
  This program allows to do molecular dynamics
  simulations using the velocity Verlet algorithm. It has
  also the capability to detect non-adiabatic transition
  using a surface hopping algorithm.

:program:`ESPF`
  The ElectroStatic Potential Fitted (ESPF) method adds some
  one-electron operators to the one-electron hamiltonian in
  order to compute the interaction between the charge
  distribution and any kind of external electrostatic
  potential, field, and field derivatives.

:program:`EXPBAS`
  This program takes one orbital file generated with a smaller basis set (ANO) and
  expands it to a larger basis set.

:program:`GATEWAY`
  This program collects all information about computed system, including
  geometry, basis sets and symmetry, and stores the data for a future use.

:program:`GENANO`
  This program is used to construct ANO type basis sets.

:program:`GRID_IT`
  This program calculates densities and molecular orbitals
  in a set of cartesian grid points, and produce a file for
  visualisation of MO's and densities.

  .. :program:`GV`
       GUI code for visualization and manipulation of molecular structures, and
       for visualization of molecular orbitals, densities, density differences, etc.

:program:`FFPT`
  This program applies perturbations to the one-electron Hamiltonian
  for finite field perturbation calculations.

:program:`GUGA`
  This program generates the coupling coefficients required by the
  :program:`MRCI` and
  :program:`CPF` programs.

:program:`LOCALISATION`
  This program generates localised occupied orbitals according to one of
  the following procedures: Pipek--Mezey, Boys,
  Edmiston--Ruedenberg, or Cholesky. Orthonormal, linearly
  independent, local virtual orbitals may also be generated
  from projected atomic orbitals (Cholesky PAOs).

:program:`LOPROP`
  This program computes molecular properties based on the
  one-electron density or transition-density and
  one-electron integrals like charges, dipole moments and
  polarizabilities

:program:`MBPT2`
  This program computes the second order Many Body Perturbation Theory
  correction to an SCF wave function.

:program:`MCKINLEY`
  This program calculates the second and first order derivatives of
  integrals that are used
  for calculating second order derivatives of the energies with perturbation
  dependent basis sets.

:program:`MCLR`
  This program calculates the response of the wave function
  and related second order properties.

:program:`MOTRA`
  This program transforms one- and two-electron integrals from AO
  basis to MO basis. The integrals that are transformed are the
  one-electron Hamiltonian and the two-electron repulsion integrals.

:program:`MRCI`
  This program produces a Multi Reference CI wave function from an
  arbitrary set of reference configurations. Alternatively the program
  can produce an Averaged CPF wave function.

:program:`MULA`
  This program calculates intensities of vibrational
  transitions between electronic states.

:program:`NEMO`
  A set of computational modules for calculation of
  interaction energies between molecules.

:program:`RASSCF`
  This program generates CASSCF, RASSCF and GASSCF type wave functions.

:program:`RASSI`
  This program computes the interaction between several RASSCF
  wave functions. A spin-orbit Hamiltonian can be used.

:program:`SCF`
  This program generates Closed Shell SCF or Unrestricted SCF,
  and Kohn--Sham DFT wave functions.

:program:`SEWARD`
  This program generates one- and two-electron integrals needed
  by other programs. If requested the two-electron integrals are
  computed in the form of Cholesky decomposed vectors.

:program:`SINGLE_ANISO`
  This program allows the non-perturbative
  calculation of effective spin (pseudospin) Hamiltonians
  and static magnetic properties of mononuclear complexes
  and fragments completely ab initio, including the
  spin-orbit interaction.

:program:`SLAPAF`
  This program is a general purpose facility for geometry
  optimization, transition state search, MEP, conical intersections, intersystem
  crossings, etc. using analytical or numerical gradients produced by
  :program:`ALASKA`.

:program:`VIBROT`
  This program computes the vibrational-rotational spectrum of a
  diatomic molecule. Spectroscopic constants are computed. The program can also
  compute transition moments, life times, etc. for excited state potentials.

.. _UG\:sec\:files_list:

Files in the system
-------------------

The following is a list of the most common files in |molcas| that are used
to exchange information between program modules. The names given in
this list are the FORTRAN file names, defined in the source code.
Actual file names are constructed from so called prgm tables, specific
for each individual module. (More information about PRGM files can be found
in the Molcas Programming Guide).

.. class:: filelist

:file:`RUNFILE`
  This file contains general information of the calculation. All programs
  read from it and write to it. :program:`GATEWAY` creates a new :file:`RUNFILE`
  corresponding to a new calculation.

:file:`ONEINT`
  This file contains the one-electron integrals generated by the program
  :program:`SEWARD`.

:file:`ORDINT`
  This file contains the ordered two-electron integrals generated by the program
  :program:`SEWARD`.

:file:`RYSRW`
  Data base for the fast direct evaluation of roots and weights of
  the Rys polynomials. This file is a part of the program system and
  should not be manipulated by the user.

:file:`ABDATA`
  Data base for the evaluation of roots and weights of high order Rys
  polynomial. This file is a part of the program system and should
  not be manipulated by the user.

:file:`CHVEC`
  This file contains the Cholesky vectors representing the two-electron integrals
  as generated by the program
  :program:`SEWARD`.

:file:`CHORST`
  This file contains information about each of the Cholesky
  vectors generated by the program
  :program:`SEWARD`.

:file:`CHRED`
  This file contains information about the storage mode of the Cholesky
  vectors generated by the program
  :program:`SEWARD`.

:file:`CHOR2F`
  File containing the mapping between Cholesky vector storage and the canonical orbital ordering.

:file:`TRAINT`
  This file contains the transformed two-electron integrals generated
  by the program
  :program:`MOTRA`.

:file:`TRAONE`
  This file contains the transformed one-electron integrals generated by
  the program
  :program:`MOTRA`.

:file:`INPORB`
  A generic name for an orbital file. Different programs
  uses and/or generates :file:`INPORB` files with a specific name:

  * :file:`GSSORB` generated by the program :program:`GUESSORB`.
  * :file:`SCFORB` generated by the program :program:`SCF`.
  * :file:`RASORB` generated by the program :program:`RASSCF`.
  * :file:`CIORB` generated by the program :program:`MRCI`
  * :file:`CPFORB` generated by the program :program:`CPF`.
  * :file:`SIORB` generated by the program :program:`RASSI`.
  * :file:`PT2ORB` generated by the program :program:`CASPT2`.

:file:`JOBIPH`
  This file contains the RASSCF wave function information generated by the
  :program:`RASSCF` program.

:file:`JOBOLD`
  This file contains the RASSCF wave function information generated by the
  :program:`RASSCF` program in the file :file:`JOBIPH`, and is used as input for a
  subsequent :program:`RASSCF` calculation.

:file:`JOBMIX`
  This file contains the multi-state CASPT2 wave function information
  generated by the
  :program:`CASPT2` program, and is used as input for a
  subsequent :program:`RASSI` calculation.

:file:`GRID`
  This file contains binary or ASCII data generated by
  :program:`GRID_IT` program for visualization of density or
  molecular orbitals.
GUI
===

The manual for graphical viewer :program:`GV`, and :program:`LUSCUS` can be found
online: https://www.molcas.org/GV/, http://luscus.sourceforge.net/.

.. .. include:: gv.inc

.. .. include:: yattagawa.inc

.. include:: molden.inc

.. .. include:: c2molcas.inc
.. index::
   single: Program; CPF
   single: CPF

.. _UG\:sec\:cpf:

:program:`cpf`
==============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Description
-----------

.. xmldoc:: <MODULE NAME="CPF">
            %%Description:
            <HELP>
            This program performs standard SDCI calculations, or
            CPF calculations as described by Ahlrichs; MCPF calculations(Chong) or
            ACPF calculations(Gdanitz). In each case, the reference is normally
            a single determinant, possibly with a few high-spin coupled open shells,
            but low-spin cases are also possible. It was originally written by Siegbahn and
            Blomberg, and has only been slightly modified to fit MOLCAS.
            It requires a file generated by the GUGA program. See manual.
            </HELP>

The
:program:`CPF` program generates :index:`SDCI <single: SDCI; using CPF>`,
:index:`CPF` :cite:`Ahlrichs:85`,
:index:`MCPF` :cite:`Chong:86` or
:index:`ACPF <single: ACPF; using CPF>` :cite:`Gdanitz:88`,
wavefunctions from **one** reference configuration.

The
:program:`CPF` program is a modification to a CPF
program written by P. E. M. Siegbahn and M. Blomberg
(Institute of Physics, Stockholm University, Sweden).

The program is based on the Direct CI method :cite:`Roos:72`,
with the coupling coefficients generated
by the Graphical Unitary Group Approach :cite:`Shavitt:77,Shavitt:78,Siegbahn:80`
(See program description for
:program:`GUGA`).
:program:`CPF` generates natural orbitals that can be fed into
the property program to evaluate certain one electron properties.
Also, the natural orbitals can be used for Iterative Natural Orbital
calculations.

Orbital subspaces
-----------------

The orbital space is divided into the following subspaces:
:index:`Frozen <single: CPF; Frozen>`,
:index:`Inactive <single: CPF; Inactive>`,
:index:`Active <single: CPF; Active>`,
:index:`Secondary <single: CPF; Secondary>`,
and :index:`Deleted <single: CPF; Deleted>` orbitals. Within each
symmetry type, they follow this order.
Their meaning is the same as explained in the :program:`GUGA` and
:program:`MOTRA` sections, except that, in this case, there is only
a single reference configuration. Therefore, the active orbitals in
this case are usually only open shells, if any.
Since explicit handling of orbitals is taken care of at the integral
transformation step, program :program:`MOTRA`, orbital spaces are not
specified in the input, except when orbitals are frozen or deleted by the
:program:`CPF` program, rather than by :program:`MOTRA`
(which should normally be avoided).

.. index::
   pair: Dependencies; CPF

.. _UG\:sec\:cpf_dependencies:

Dependencies
------------

The :program:`CPF` program needs the coupling
coefficients generated by the program
:program:`GUGA` and the transformed one and two electron
integrals from the program
:program:`MOTRA`.

.. index::
   pair: Files; CPF

.. _UG\:sec\:cpf_files:

Files
-----

Input files
...........

The
:program:`CPF` program need the coupling coefficients generated by
:program:`GUGA` and the transformed integrals from
:program:`MOTRA`.

:program:`CPF` will use the following input
files: :file:`ONEINT`, :file:`RUNFILE`, :file:`CIGUGA`,
:file:`TRAINT`, :file:`TRAONE`
(for more information see :numref:`UG:sec:files_list`).
and :file:`CPFVECT` (for restarted calculations).

Output files
............

:program:`CPF` generates an two output files:

.. class:: filelist

:file:`CPFORB`
  The natural orbitals from the CPF functional.

:file:`CPFVECT`
  The CI expansion coefficients. These may be used for restarting an
  unconverged calculation.

.. index::
   pair: Input; CPF

.. _UG\:sec\:cpf_input:

Input
-----

This section describes the input to the :program:`CPF` program in the |molcas| program system.
The input for each module is preceded by its name like: ::

  &CPF

.. index::
   pair: Keywords; CPF

Optional keywords
.................

.. class:: keywordlist

:kword:`TITLe`
  Followed by a title line

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              Followed by a title line
              </HELP>
              </KEYWORD>

:kword:`SDCI`
  Specifies that a SDCI calculation is to be performed.
  No additional input is required.
  Only one of the choices SDCI, CPF, MCPF or ACPF should be chosen.

  .. xmldoc:: <SELECT MODULE="CPF" NAME="COMP_MODEL" APPEAR="Computation model" CONTAINS="SDCI,CPF,MCPF,ACPF" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="SDCI" KIND="SINGLE" EXCLUSIVE="CPF,MCPF,ACPF" LEVEL="BASIC">
              %%Keyword: SDCI <basic>
              Out of the choices SDCI, CPF, MCPF or ACPF, precisely one must be used.
              <HELP>
              Single-reference SDCI calculation.
              </HELP>
              </KEYWORD>

:kword:`CPF`
  Specifies that a CPF calculation is to be performed.
  Only one of the choices SDCI, CPF, MCPF or ACPF should be chosen.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="CPF" KIND="SINGLE" EXCLUSIVE="SDCI,MCPF,ACPF" LEVEL="BASIC">
              %%Keyword: CPF <basic>
              Out of the choices SDCI, CPF, MCPF or ACPF, precisely one must be used.
              <HELP>
              Single-reference CPF calculation (Ahlrichs, see manual).
              </HELP>
              </KEYWORD>

:kword:`MCPF`
  Specifies that a Modified CPF calculation is to be performed.
  This option is in fact the default choice.
  Only one of the choices SDCI, CPF, MCPF or ACPF should be chosen.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="MCPF" KIND="SINGLE" EXCLUSIVE="SDCI,CPF,ACPF" LEVEL="BASIC">
              %%Keyword: MCPF <basic>
              Out of the choices SDCI, CPF, MCPF or ACPF, precisely one must be used.
              <HELP>
              Single-reference MCPF calculation (Chong, see manual).
              </HELP>
              </KEYWORD>

:kword:`ACPF`
  Specifies that an Average CPF calculation is to be performed.
  Only one of the choices SDCI, CPF, MCPF or ACPF should be chosen.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="ACPF" KIND="SINGLE" EXCLUSIVE="SDCI,CPF,MCPF" LEVEL="BASIC">
              %%Keyword: ACPF <basic>
              Out of the choices SDCI, CPF, MCPF or ACPF, precisely one must be used.
              <HELP>
              Single-reference ACPF calculation (Gdanitz, see manual).
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`RESTart`
  Restart the calculation from a previous calculation.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="RESTART" APPEAR="Restart" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Restart <advanced>
              <HELP>
              Restart the calculation from a previous calculation.
              </HELP>
              </KEYWORD>

:kword:`THRPr`
  Threshold for printout of the wavefunction. All configurations with
  a coefficient greater than this threshold are printed in the final
  printout. The default is 0.05.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="THRP" APPEAR="CI Print Threshold" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.05" MIN_VALUE="0.0">
              %%Keyword: ThrPrint <advanced>
              <HELP>
              Set threshold on CI coefficients to be printed. Default 0.05.
              </HELP>
              </KEYWORD>

:kword:`ECONvergence`
  Energy convergence threshold. The update procedure is repeated
  until the energy difference between the last two iterations is less
  than this threshold. The default is 1.0e-8.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="ECON" APPEAR="Energy Convergence" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="1.0D-8" MIN_VALUE="0.0">
              %%Keyword: EConvergence <advanced>
              <HELP>
              Set energy threshold for convergence. Default 1.0D-8.
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  Print level of the program. Default is 5.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="PRINT" APPEAR="Print level" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="5">
              %%Keyword: PrintLevel <advanced>
              <HELP>
              Set print level. Default is 5.
              </HELP>
              </KEYWORD>

:kword:`MAXIterations`
  Maximum number of iterations in the update procedure. Default 20.
  The maximum value of this parameter is 75.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="MAXITER" APPEAR="Maximum iterations" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="20" MIN_VALUE="0" MAX_VALUE="75">
              %%Keyword: MaxIterations <advanced>
              <HELP>
              Set maximum iterations. Default 20, max possible 75.
              </HELP>
              </KEYWORD>

:kword:`FROZen`
  Specify the number of orbitals to be frozen in
  **addition** to the orbitals frozen in the integral transformation. Default is 0
  in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="FROZEN" APPEAR="Frozen" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: Frozen <advanced>
              <HELP>
              Specify, for each symmetry, how many orbitals to keep uncorrelated
              in addition to any that were frozen already by MOTRA.
              </HELP>
              </KEYWORD>

:kword:`DELEted`
  Specify the number of orbitals to be deleted in
  **addition** to the orbitals deleted in the integral transformation. Default is 0
  in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="DELETED" APPEAR="Deleted" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: Deleted <advanced>
              <HELP>
              Specify, for each symmetry, how many orbitals to delete
              in addition to any that were deleted already by MOTRA.
              </HELP>
              </KEYWORD>

:kword:`LOW`
  Specifies that this is a low spin case, i.e. the spin is less than
  the maximum possible with the number of open shells in the
  calculation. See Refs. :cite:`Ahlrichs:85,Chong:86`.
  This requires special considerations.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="LOWSPIN" APPEAR="Low Spin" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Low <advanced>
              <HELP>
              Specifies a low spin case, see manual.
              </HELP>
              </KEYWORD>

:kword:`MAXPulay`
  Maximum number of iterations in the initial stage. After that, DIIS extrapolation
  will be used. Default is 6.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="MAXPULAY" APPEAR="Pre-DIIS Iterations" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="6">
              %%Keyword: MaxPulay <advanced>
              <HELP>
              Number of iterations until DIIS extrapolation is switched on.
              </HELP>
              </KEYWORD>

:kword:`LEVShift`
  Levelshift in the update procedure. Default is 0.3.

  .. xmldoc:: <KEYWORD MODULE="CPF" NAME="LEVSHIFT" APPEAR="Level shift" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.3">
              %%Keyword: LevShift <advanced>
              <HELP>
              Enter level shift to use in the equation solver. Default is 0.3.
              </HELP>
              </KEYWORD>

Input example
.............

::

  &CPF
  Title
   Water molecule. 1S frozen in transformation.
  MCPF

.. xmldoc:: </MODULE>
.. index::
   single: Program; NEMO
   single: NEMO

.. _UG\:sec\:nemo:

:program:`nemo` |extramark|
===========================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:nemo_description:

Description
-----------

.. xmldoc:: %%Description:
            The Nemo program of the molcas program system generates:
            fitting of potential surfaces, energy optimizations, potential curves and simulation parameters.

The :program:`NEMO` is a potential analyzis package that calculates interaction energies between molecules. The package uses input files from :program:`MPPROP` and :program:`MKNEMOPOT`.
The package was originally a set of programs that has been totaly rewritten and put together into one program. The package
are capable of doing fitting of potential surfaces, energy optimization between molecules, calculate some specific potential curves and generate simulation parameters for rigid molecules.

The theoretical background stands in perturbation theory. The interaction
energy between two molecules can be described by three quantum chemical
calculations. One quantum chemical calculation for each of the monomers
and one calculation for the two molecules together i.e. the dimer. The
energy for the two monomers are then subtracted from the dimer
calculation. That is done for each configuration, i.e. coordinate set
for a dimer calculation, given by the input to :program:`MKNEMOPOT`.
The calculations are set up by the :program:`MKNEMOPOT` package and to
performe those calculations it is recommended to read the manual for
the :program:`MKNEMOPOT` package. The interaction energy can also be
described in the classical energy terms electrostatic, induction dispersion,
repulsion and chargetransfer. Where, a good description the first three
energy terms can be given by distributed multipole expansions and distributed
polarizabilities. The last two energy terms are harder to predict and
are of quantum chemical origin. The reason for calculating the interaction
energy quantum chemically is that this reference energy will be used for
the description of the repulsion(/chargetransfer) parameters. The repulsive
reference energy term is achieved by subtracting the energy for the electrostatic,
induction and dispersion from the reference energy. Note here that the
dispersion energy is only added if the reference energy is performed
with a method that includes true dynamic correlation, i.e. when the energy
includes the London dispersion term. The reference energy will also include
a charge transfer term if it is defined by the user. An estimation of the
repulsive energy term can now be fitted to the reference repulsive energy
term by using the FITPar subprogram in the :program:`NEMO` program. The
fitted parameters are classified in elements and type. Where a hydrogen
atom is element 1 and can be classified in different types depending on
their chemical environment. This information is supplied with the MpProp
file together with coordinates, multipole and polarizabilities of a
molecule. The MpProp file is an output from the :program:`MPPROP` or
:program:`LOPROP` program. A MpProp file does not always contain all the
information needed to run the :program:`NEMO` program. Thus, it is important
have look directly in the file and do your prefered changes before using
it. It can for example be to change the type of a hydrogen atom. If we
take the ethanol molecule as an example. It is composed of two carbons,
five hydrogens and one oxygen atoms. Here we can define three different
type of hydrogens that are bonded to C1, C2 and O1 respectively. The two
carbons in the molecule can of course also be defined to be of different
type. For each defined type there excists two corresponding parameters for
the repulsion energy. These are the ones that are varied to in the fitting
procedure.

The input file comming from the :program:`MKNEMOPOT` program can contain
a cluster definition. A cluster is defined as a supermolecule containing
one/several different/equal molecules. The interaction energy is thus
defined as the interaction between different clusters.

The POTSurf subprogram produces potential energy curves between two
clusters. This is normally used to compare the fitted potential with the
result from a quantum chemical calculation. Whats happening is that one
of clusters are translated and rotated to a certain position. The moved
cluster is then translated along a displacement vector.

In the DIMEr subprogram an optimizition/minimizition of the energy between
two/several molecules is performed. The routine is not good and practical
for many molecules. Because, it was originally written to do the job for
two molecules which works pretty good.

The SIMPar program can produce input files for the :program:`MOLSIM` package.

.. _UG\:sec\:nemo_dependencies:

Dependencies
------------

The :program:`NEMO` program requires a nemo library.
The library is just a concatenation of several different :file:`nemo` files.
In order to run the FitPar subprogram in :program:`NEMO` a :file:`NEMO` file is required.
The :file:`NEMO` file is either autogenerated through the :program:`MKNEMOPOT` or it might be
generated by hand from some other potential.

.. index::
   pair: Files; NEMO

.. _UG\:sec\:nemo_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`NEMO`.

Input files
...........

.. class:: filelist

:file:`NEMO`
  This file will be opened in the $WorkDir/ directory and is composed of several :file:`Nemo` files
  generated by :program:`MKNEMOPOT`.

:file:`ATOMPAR`
  This file will be opened in the $WorkDir/ directory and it holds the atomic parameters for repulsion, scaling constants for the
  dispersion, valence of the atoms. It will originaly be stored in the $MOLCAS/nemo_libary directory. It's definition is:
  two dummy lines, nElements=103 of lines and all this taken nType=4 times. The signifacant nElements of lines will hold 12 columns.
  Where the first column is the element number, the second column is the element label, the third column

  Columns in the ATOMPAR file:

  * **Column=1**
    element number

  * **Column=2**
    element label

  * **Column=3**
    Alpha

  * **Column=4**
    Kappa

  * **Column=5**
    Charge Transfer Alpha

  * **Column=6**
    Charge Transfer Kappa

  * **Column=7**
    Valence of the atom

  * **Column=8**
    RepExp an integer for the :math:`r^{-n}` type potential.

  * **Column=9**
    RepFac

  * **Column=10**
    DispFac

  * **Column=11**
    K1/Sigma

  * **Column=12**
    K2/Epsilon

Output files
............

.. class:: filelist

:file:`POTSURF`
  This file holds the potential curve. The columns of the PotSurf file will be:

  * **Column=1**
    Coordinate 1

  * **Column=2**
    Electrostatic+Induction+Repulsion

  * **Column=3**
    Electrostatic+Induction+Repulsion+Dispersion

  * **Column=4**
    Electrostatic

  * **Column=5**
    Induction

  * **Column=6**
    Dispersion

  * **Column=7**
    Repulsion

  * **Column=8**
    Charge Transfer

:file:`MOLSIM`
  The input file in molsim format for the particle part.

:file:`MOLSIMLIB`
  The library file in molsim format for the repulsive and dispersive part.

:file:`ATOMFIT`
  This is the same file as ATOMPAR, but it is written to the $WorkDir directory

.. index::
   pair: Input; NEMO

.. _UG\:sec\:nemo_input:

Input
-----

.. compound::

  Below follows a description of the input to :program:`NEMO`. The keywords
  are always significant to four characters, but in order to make the
  input more transparent, it is recommended to use the full keywords.
  The :program:`NEMO` program section of the |molcas| input is bracketed by
  a preceding dummy namelist reference ::

    &NEMO &END

  and an "end of input" statement ::

    End of Input

Argument(s) to a keyword are always supplied on the next line of the
input file, except explicitly stated otherwise.

Optional general keywords
.........................

.. class:: keywordlist

:kword:`ALPHa`
  Use this Keyword to define the alpha parameter for a specific atom and atomtype.
  The keyword should be followed by a line/lines composed of the element number,
  the atomtype and the value for alpha.This Keyword should be ended by a END statement
  in the last line. The example below means that uran type 1 will have the value 0.1 .
  The alpha parameter will be used in the exponent for the repulsion. ::

    ALPHa
    92 1 0.1
    END

  .. xmldoc:: %%Keyword: ALPHa <basic>
              Use this Keyword to define the alpha parameter for a specific atom and atomtype.
              The should be followed by a line/lines composed of the element number,
              the atomtype and the value for alpha.This Keyword should be ended by a END statement
              in the last line. The example below means that uran type 1 will have the value 0.1 .

:kword:`KAPPa`
  Use this Keyword to define the kappa parameter for a specific atom and atomtype.
  The keyword should be followed by a line/lines composed of the element number,
  the atomtype and the value for kappa.This Keyword should be ended by a END statement
  in the last line. The example below means that uran type 1 will have the value 10.0 .
  The kappa parameter will be used as a prefactor to the exponent expression for the repulsion. ::

    KAPPa
    92 1 10.0
    END

  .. xmldoc:: %%Keyword: KAPPa <basic>
              Use this Keyword to define the kappa parameter for a specific atom and atomtype.
              The keyword should be followed by a line/lines composed of the element number,
              the atomtype and the value for kappa.This Keyword should be ended by a END statement
              in the last line. The example below means that uran type 1 will have the value 10.0 .
              The kappa parameter will be used as a prefactor to the exponent expression for the repulsion.

:kword:`ALCT`
  This keyword is for the charge transfer term that can be used if one specifies that in the NEMO keyword.
  The energy term is exactly the same expression as the repulsion, but with a minus sign instead.
  Use this Keyword to define the charge transfer alpha parameter for a specific atom and atomtype.
  The keyword should be followed by a line/lines composed of the element number,
  the atomtype and the value for charge transfer alpha.This Keyword should be ended by a END statement
  in the last line. The example below means that uran type 1 will have the value 0.1 .
  The charge transfer alpha parameter will be used in the exponent for the repulsion. ::

    ALCT
    92 1 0.1
    END

  .. xmldoc:: %%Keyword: ALCT <basic>
              This keyword is for the charge transfer term that can be used if one specifies that in the NEMO keyword.
              The energy term is exactly the same expression as the repulsion, but with a minus instead.
              Use this Keyword to define the charge transfer alpha parameter for a specific atom and atomtype.
              The keyword should be followed by a line/lines composed of the element number,
              the atomtype and the value for charge transfer alpha.This Keyword should be ended by a END statement
              in the last line. The example below means that uran type 1 will have the value 0.1 .
              The charge transfer alpha parameter will be used in the exponent for the repulsion.

:kword:`KACT`
  This keyword is for the charge transfer term that can be used if one specifies that in the NEMO keyword.
  The energy term is exactly the same expression as the repulsion, but with a minus sign instead.
  Use this Keyword to define the charge transfer kappa parameter for a specific atom and atomtype.
  The keyword should be followed by a line/lines composed of the element number,
  the atomtype and the value for charge transfer kappa. This Keyword should be ended by a END statement
  in the last line. The example below means that uran type 1 will have the value 10.0 .
  The charge transfer kappa parameter will be used as a prefactor to the exponent expression for the repulsion. ::

    KACT
    92 1 10.0
    END

  .. xmldoc:: %%Keyword: KACT <basic>
              This keyword is for the charge transfer term that can be used if one specifies that in the NEMO keyword.
              The energy term is exactly the same expression as the repulsion, but with a minus sign instead.
              Use this Keyword to define the charge transfer kappa parameter for a specific atom and atomtype.
              The keyword should be followed by a line/lines composed of the element number,
              the atomtype and the value for charge transfer kappa. This Keyword should be ended by a END statement
              in the last line. The example below means that uran type 1 will have the value 10.0 .
              The charge transfer kappa parameter will be used as a prefactor to the exponent expression for the repulsion.

:kword:`REPFactor`
  If a repulsion of type :math:`\sqrt{F_1 F_2}r^{-n}` is to be used.
  Check the NEMO keyword for information. This keyword is specified in the same way as kappa.

:kword:`DISPfactor`
  Two factors are multiplied with the dispersion energy. They work in the same way as the REPFactor does and
  are specified in the same way.

:kword:`VALEnce`
  Set the number of valence electrons. The keyword should be followed by a line/lines composed of the element number,
  the atomtype and the value for kappa.This Keyword should be ended by a END statement
  in the last line. The example below means that oxygen type 2 will have 6 valence electrons. ::

    VALEnce
    8 2 6.0
    END

  .. xmldoc:: %%Keyword: VALEnce <basic>
              Set the number of valence electrons. The keyword should be followed by a line/lines composed of the element number,
              the atomtype and the value for kappa.This Keyword should be ended by a END statement
              in the last line. The example below means that oxygen type 2 will have 6 valence electrons.

:kword:`NOISotropicPolarizabilities`
  The default is to use isotropic polarizabilities for the induction energy.
  This is due to the fact that we use Thole damping as default, which require isotropic
  polarizabilities.

  .. xmldoc:: %%Keyword: NOISotropicPolarizabilities <basic>
              The default is to use isotropic polarizabilities for the induction energy.
              This is due to the fact that we use Thole damping as default, which require isotropic
              polarizabilities.

:kword:`NOMOve`
  The default interactions sites are not placed in the atoms. If this keyword is used
  the interactions sites are not moved to a new location.

  .. xmldoc:: %%Keyword: NOMove <basic>
              Do not move the interactions sites which is the default.

:kword:`NOQUadrupoleDelete`
  The default is to replace the quadrupoles with local dipoles to get the correct total quadrupole.
  If this keyword is used, the quadrupoles will be truncated at the dipole level.

  .. xmldoc:: %%Keyword: NOQUadrupoleDelete <basic>
              The default is to replace the quadrupoles with local dipoles to get the correct total quadrupole.
              If this keyword is used, the quadrupoles will be truncated at the dipole level.

:kword:`NODAmping`
  As default the Thole damping is used, but using this heyword that is overruled.

  .. xmldoc:: %%Keyword: NODAmping <basic>
              As default the Thole damping is used, but using this heyword that is overruled.

:kword:`REPLace`
  Use this keyword to specify that some atomic quadrupoles should be replaced by charges.

:kword:`MOLD`
  The new local atomic dipole will be used when calculating the new interaction center.
  The default is to use the original local atomic dipole.

:kword:`NOLM`
  The new local atomic quadrupole will be used when estamating the size of the atom.
  This is used when calculating the repulsion and dispersive energy.
  The default is to use the original local atomic quadrupole which is the correct way.

:kword:`RETY`
  REpTYpe: The keyword should be followed by a line, specifying the expression to use for the repulsion type.

  Optional RETY parameters:

  * **m=0**
    (Default) Here the exponent is described by :math:`-r_{12}/(\sqrt{\Tr(Q_1)/3/qv_1+\Tr(Q_2)/3/qv_2}(\alpha_1\alpha_2))`.

  * **m=1**
    Here the exponent is described by :math:`-r_{12}/(\alpha_1\sqrt{\Tr(Q_1)/3/qv_1}+\alpha_2\sqrt{\Tr(Q_2)/3/qv_2})`.

:kword:`NEMO`
  The keyword should be followed by a line, what kind of energy expression to use.
  The parameters for the energies are read from the :file:`nemo` and :file:`ATOMPAR`

  Optional NEMO parameters:

  * **m=0**
    (Default) Electrostatic, inductive, dispersive and a exponetial repulsion energy term is used.

  * **m=1**
    Here a :math:`\sqrt{F_1 F_2}r^{-n}` type repulsion is added to the default energy.

  * **m=2**
    Here dispersion factors are used to scale the energy.

  * **m=3**
    This number means that default energy is used, plus the repulsive term of type 1 and the dispersive scaling of type 2.

  * **m=4**
    A charge transfer term is added to the default energy, which has the same expression
    as the repulsion term only differing in the sign.

  .. :kword:`AMBEr`
       Not implemented. For future use.

  ..   .. xmldoc:: %%Keyword: AMBEr <basic>
                   Not implemented. For future use.

  .. :kword:`SIGMa`
       Not implemented. For future use.

  ..   .. xmldoc:: %%Keyword: SIGMa <basic>
                   Not implemented. For future use.

  .. :kword:`EPSIlon`
       Not implemented. For future use.

  ..   .. xmldoc:: %%Keyword: EPSIlon <basic>
                   Not implemented. For future use.

:kword:`SEED`
  The seed to the random generator.

  .. xmldoc:: %%Keyword: SEED <basic>
              The seed to the random generator.

:kword:`FITPar`
  This is the start keyword for the subprogram :program:`FITPAR`. It should consist of the Keyword plus a END statement.
  Inbetween there should be :program:`FITPAR` specific keywords.
  The subprogram to do the fitting of parameters.

:kword:`DIMEr`
  This is the start keyword for the subprogram :program:`DIMER`. It should consist of the Keyword plus a END statement.
  Inbetween there should be :program:`DIMEr` specific keywords.
  The subprogram do an energy minimisation for two monomers.

:kword:`POTSurf`
  This is the start keyword for the subprogram :program:`POTSURF`. It should consist of the Keyword plus a END statement.
  Inbetween there should be :program:`POTSURF` specific keywords.
  The subprogram generates potential curves.

:kword:`SIMPar`
  This is the start keyword for the subprogram :program:`SIMPAR`. It should consist of the Keyword plus a END statement.
  Inbetween there should be :program:`SIMPAR` specific keywords.

Optional FITPar specific keywords
.................................

These keywords should begin by a FITPar keyword and end with a END statement.

.. class:: keywordlist

:kword:`NUAL`
  NO UPDATE ALPHA. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated. ::

    NUAL
    8 2
    END

:kword:`NUKA`
  NO UPDATE KAPPA. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated. ::

    NUKA
    8 2
    END

:kword:`NUAC`
  NO UPDATE CHARGE TRANSFER ALPHA. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated.This only works for NEMO type 4. Check the NEMO keyword. ::

    NUAC
    8 2
    END

:kword:`NUKC`
  NO UPDATE CHARGE TRANSFER KAPPA. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated.This only works for NEMO type 4. Check the NEMO keyword. ::

    NUKC
    8 2
    END

:kword:`NUSI`
  Not implemented. For future use.

:kword:`NUEP`
  Not implemented. For future use.

:kword:`NURE`
  NO UPDATE REPULSION FACTOR. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated. This only works for NEMO type 1 and 3. Check the NEMO keyword. ::

    NUKC
    8 2
    END

:kword:`NUDI`
  NO UPDATE DISPERSION FACTOR. This keyword should be followed by a line/lines specifying the element and type
  of the atomic parameter that should not be updated during the fitting. The example says that the
  oxygen type 2 atomic parameter should not be updated. This only works for NEMO type 2 and 3. Check the NEMO keyword. ::

    NUKC
    8 2
    END

:kword:`GLOBal`
  The keyword should be followed by a line specifying the number of globalsteps.

:kword:`MACRo`
  The keyword should be followed by a line specifying the number of macrosteps.

:kword:`MICRo`
  The keyword should be followed by a line specifying the number of microsteps.

:kword:`TEMP`
  The keyword should be followed by a line specifying the temperature for the weighting procedure. See the keyword WEIG.

:kword:`SCFFit`
  By default the program tries to fit the second energy term in the NEMO file. Using this keyword the program uses the
  first energy term witch is a SCF type energy.

:kword:`CONVergence`
  The keyword should be followed by a line specifying the number for the convergence radii.

:kword:`RFACtor`
  The keyword should be followed by a line specifying the number for the scaling constant in the least square fit.

:kword:`WEIGht`
  The keyword should be followed by a line specifying the number of the weight type

  Optional WEIGht parameters:

  * **m=0**
    (Default) Weight=Min(2,Exp( -0.2*(E(dimer)-E(Monomer1)-E(Monomer2)) )

  * **m=1**
    Weight=exp(-(E(dimer)-E(Monomer1)-E(Monomer2))/kT)

:kword:`ERROr`
  The keyword should be followed by a line specifying the number of the error type

  Optional ERROr parameters:

  * **m=0**
    (Default) Error=Weight*( Exp( 0.15D0*(E(estimated)-E(reference)) )-1 )**2

  * **m=1**
    Error=Weight*(E(reference)-E(estimated))**2

:kword:`DISFactor`
  The keyword should be followed by a line specifying a scaling constant for the dispersion energy. (Default 1.0)

:kword:`LINEarsearch`
  The keyword can contain any of the keywords FORCe, SIMPlex, ITERation and CONVergence. It should also finnish by an END statement.

  .. Optional LINEar specific keywords:

:kword:`SIMPlex`
  Keyword for the simplex method.

:kword:`FORCe`
  Keyword for a steepest descent type method.

:kword:`ITERation`
  The keyword should be followed by a line specifying the number of interations.

:kword:`CONVergence`
  The keyword should be followed by a line specifying the number for the convergence.

Optional DIMEr specific keywords
................................

These keywords should begin by a DIMEr keyword and end with a END statement.

.. class:: keywordlist

:kword:`MOLEcules`
  The keyword should be followed by a line specifying a molecule by name exactly as they are named in the nemo file. All other molecular based keywords will be given to this molecule. That until a new molecule name is given with this keyword.

:kword:`METHod`
  Specifies the method to be used for the file to be opened. The program will find another method if the specified method cannot be found in the MPPROP file.

:kword:`MACRosteps`
  The keyword should be followed by a line specifying the number of macrosteps.

:kword:`MICRosteps`
  The keyword should be followed by a line specifying the number of microsteps.

:kword:`STARt`
  The keyword should be followed by a line specifying two numbers. The first number is search radii for coordinates and
  the second number is the search radii for the angles. In the first macrostep.

:kword:`RFACtor`
  The keyword should be followed by a line specifying the number of the scaling factor for the search radii each macrostep.

:kword:`CONVergence`
  The keyword should be followed by a line specifying the number for the convergence radii.

:kword:`DISFac`
  The keyword should be followed by a line specifying a scaling constant for the dispersion energy. (Default 1.0)

Optional POTSurf specific keywords
..................................

These keywords should begin by a POTSur keyword and end with a END statement.

.. class:: keywordlist

:kword:`MOLEcule`
  Specifies the start and the title of a new molecule. This means every keyword after this MOLEcule keyword will belong to the last specified MOLEcule.

:kword:`METHod`
  Specifies the method to be used for the file to be opened. The program will find another method if the specified method cannot be found in the MPPROP file.

:kword:`CLUSter`
  This keyword should be followed by a line that gives an integer number of witch cluster the lates molecule belongs to. Only the integer numbers 1 and 2 are valid for the PotSurf module.

:kword:`TROR`
  This keyword should be followed by a line that gives six numbers. The six numbers describes the translation in polar coordinates and the rotation in the three euler angles for the molecule given by the latest MOLEcule keyword. The sequence of the numbers are the following: R Theta Phi Alpha Beta Gamma (See Arfken for definitions)

:kword:`POTEntial`
  The keyword should be followed by one line specifying three numbers. The numbers gives the displacement vector in spherical poolar coordinates for the second cluster when calculating the potential energy. The numbers are given in the following order: R Theta Phi

:kword:`NPOInts`
  The keyword should be followed by one line specifying the number of points in the potential.

:kword:`TRANslation`
  The keyword should be followed by a line specifying up to five numbers. The first number specifies the type of potential coordinates.
  In order to visulize the potential curve one has to define a translation coordinate.
  The first column of the PotSurf file will consist of a coordinete specified by the iTrType parameter. The other parameters jTrType, kTrType ... are specified below.

  Optional TRANslation parameters:

  * **iTrType=0**
    The coordinate will be the length of the translation vector. (Default)

  * **iTrType=1**
    jTrType=coordinte (1=X,2=Y and 3=Z) index of kTrType=molecule given by the order of the apperence in the input section.

  * **iTrType=2**
    jTrType=Atom1 and kTrType=Atom2 on molecule=lTrType and mTrType respectively. The molecules are given by the order of the apperence in the input section. The potential coordinate will be the distance between Atom1 and Atom2. Note that if the potential coordinate is constant if the molcules belong to the same cluster.

:kword:`DISFactor`
  The keyword should be followed by a line specifying a scaling constant for the dispersion energy. (Default 1.0)

Optional SIMPar specific keywords
.................................

These keywords should begin by a DIMEr keyword and end with a END statement.

.. class:: keywordlist

:kword:`MOLEcules`
  Specifies the start and the title of a new molecule. This means that every keyword after this
  MOLEcule keyword will belong to the last specified MOLEcule.

:kword:`METHod`
  Specifies the method to be used for the file to be opened.
  The program will find another method if the specified method
  cannot be found in the MPPROP file.

:kword:`MOLSim`
  Tells the program to generate Molsim parameters and input files.

:kword:`EQUAlatoms`
  This keyword should be followed by a line specifying two atom numbers that should treated as equal.
  The atomic numbers are the numbers in sequence as they are found in the MPPROP file.
  For example, a water molecule in gasphase has the two hydrogen atoms equal by symmetry.
  They should thus be treated equally for the analysis in a simulation program. If the
  MPPROP file has the atoms in the sequence O H H the example below makes the two hydrogen equal ::

    EQUA
    2 3

:kword:`NUMBer`
  The keyword should by a line giving the number of latest molecule that will
  be used in the latter simulation. This information will be written in the MOLSIM file.

:kword:`DISFactor`
  The keyword should be followed by a line specifying a scaling constant for the dispersion energy. (Default 1.0)

Limitations
...........

The program package has no internal degrees of freedom.
The program cannot handle interactions including quadrupoles and higher.
The program cannot handle hyperpolarizabilities. For the time being we cannot handle more than two clusters.

.. Contacts
   ........

   It is hard to see what should be included in this manual, but if you have any questions or problems just send an email to daniel.hagberg@teokem.lu.se .
.. index::
   single: Program; Averd
   single: Averd

.. _UG\:sec\:averd:

:program:`averd`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:averd_description:

Description
-----------

.. xmldoc:: <MODULE NAME="AVERD">
            %%Description:
            <HELP>
            Computes average densities and corresponding natural molecular orbitals
            </HELP>

:program:`Averd` computes average densities and corresponding
natural molecular orbitals. Given a set of density
matrices in the same basis set, an average density matrix is
constructed and diagonalized to give average natural orbitals.
These orbitals have non-integer occupation numbers, although they
usually are fairly well clustered in one strongly occupied
part and one weakly occupied part. From basic mathematical
properties of natural orbitals, a truncated set of the orbitals
constructed this way constitutes the most compact basis of
one-electron functions of that given size. In other words, the smallest
set of functions to span the average space within a certain
accuracy has been obtained. :program:`Averd`
is in essence very similar to :program:`Genano`.

.. _UG\:sec\:averd_dependencies:

Dependencies
------------

:program:`Averd` needs a set of input densities. Any of the
programs, which generate a density must precede.

.. _UG\:sec\:averd_files:

Files
-----

Below is a list of the files that are used/created by
:program:`Averd`.

Input files
...........

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information generated by the program
  :program:`SEWARD`.

:file:`ONEINT`
  File with one-electron integrals generated by :program:`SEWARD`.

:file:`RUN***`
  A set of RunFiles on which a density matrix is stored. This density
  matrix is read and added to the average. If :kword:`ORBItals` is
  given, these files are not needed.

:file:`NAT***`
  A set of orbitals in the format generated by :program:`SCF` or
  :program:`RASSCF`. The orbitals are used to generate a density matrix,
  which is added to the average. Only required if :kword:`ORBItals` is
  given.

Output files
............

.. class:: filelist

:file:`AVEORB`
  The average orbitals generated by :program:`Averd`. They are stored in
  the same way as SCF-orbitals and can be used as INPORB.

.. _UG\:sec\:averd_input:

Input
-----

.. class:: keywordlist

:kword:`TITLe`
  Title of the calculation.

  .. xmldoc:: <KEYWORD MODULE="AVERD" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              Title of the calculation
              </HELP>
              </KEYWORD>

:kword:`WSET`
  Followed by two rows. On the first the number of input orbitals are
  given, :math:`N`. Second row contains :math:`N` numbers each giving a weight
  for the :math:`k`\th input density matrix to the average density. The
  weights are normalized by :program:`Averd`, hence only the
  ratio of the numbers have any significance. **This keyword
  is mandatory.**

  .. xmldoc:: <KEYWORD MODULE="AVERD" NAME="WSET" APPEAR="Relative weights" KIND="REALS_COMPUTED" SIZE="1" LEVEL="BASIC">
              %%Keyword: WSet <compulsory>
              <HELP>
              Number of input sets of orbitals and relative weight for each of them.
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  Print level. 1 is default. Higher than 3 is not recommended for the
  average user.

  .. xmldoc:: <KEYWORD MODULE="AVERD" NAME="PRINT" APPEAR="Print level" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: Print <basic>
              <HELP>
              Print level. Default is 1.
              </HELP>
              </KEYWORD>

:kword:`ORBItals`
  This keyword signifies that the densities should be created from
  average orbitals in the files :file:`NAT***`, not directly from the density
  matrices on the files :file:`RUN***`. The default is to use the density
  matrices on :file:`RUN***`.

  .. xmldoc:: <KEYWORD MODULE="AVERD" NAME="ORBITALS" APPEAR="Densities from orbital files" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Orbitals <basic>
              <HELP>
              This keyword signifies that the densities should be created from
              average orbitals in the NAT*** files, not directly from the density
              matrices in the RUN*** files.
              </HELP>
              </KEYWORD>

:kword:`OCCUpation`
  Followed by one number. The number of average orbitals with an
  occupation higher than this number is reported for each symmetry.
  Since the occupation is the guide for how to truncate the orbitals
  in subsequent applications, this is an easy way to get hold of
  that number. The default is :math:`10^{-5}`.

  .. xmldoc:: <KEYWORD MODULE="AVERD" NAME="OCCUPATION" APPEAR="Occupation threshold" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1.0D-5">
              %%Keyword: Occupation <basic>
              <HELP>
              The number of average orbitals with an
              occupation higher than this number is reported for each symmetry.
              The default is 1.0d-5.
              </HELP>
              </KEYWORD>

Input example
.............

In this example, two density matrices are averaged and their
average orbitals are computed. ::

  &Seward
  Basis set
  O.ano-s.Pierloot.10s6p3d.7s4p2d.
  O  0.0000  0.0000  0.3000
  End of Basis set
  Basis set
  H.ano-s.Pierloot.7s3p.4s1p.
  H1 0.0000 -1.4300 -0.8070
  H2 0.0000  1.4300 -0.8070
  End of Basis Set

  &FfPt
  Dipo
  z 0.005
  End of Input

  &Scf
  Occupation
  5
  >>COPY $Project.RunFile RUN001

  &FfPt
  Dipo
  z -0.005

  &Scf
  Occupation
  5
  End of Input
  >>COPY $Project.RunFile RUN002

  &Averd &End
  Wset
  2
  1.0 1.0
  Occupation
  1d-6

.. xmldoc:: </MODULE>
.. index::
   single: Program; Dynamix
   single: Dynamix

.. _UG\:sec\:dynamix:

:program:`dynamix`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="DYNAMIX">
            %%Description:
            <HELP>
            The DYNAMIX program allows to do molecular dynamics simulations using
            the velocity Verlet algorithm. It has also the capability to detect
            non-adiabatic transition using a surface hopping algorithm.
            </HELP>

The :program:`DYNAMIX` program performs molecular dynamics (MD)
simulations in |molcas|. Here the nuclei are moved according to the
classical Newton's equations which are solved numerically using the
velocity Verlet algorithm :cite:`swope:637`. The algorithm requires
coordinates, velocities and forces as input. :program:`DYNAMIX` can be
used with any electronic structure method in |molcas|. Also environmental
effects can be taken into account in the MD simulation: the solvent can be
considered implicitly using the reaction field keyword in :program:`GATEWAY`
or explicitly in hybrid QM/MM calculation which requires the :program:`ESPF`
program.

When multiple electronic states are involved in a MD simulation, a trajectory
surface hopping (TSH) algorithm allows non-adiabatic transitions between
different states. This TSH algorithm evaluates the change of the wavefunction
along the trajectory and induces a hop if certain criteria a met (for further
details read the :program:`RASSI` section). In the current implementation the
surface hopping algorithm can be used only with state averaged CASSCF
wavefunction. However, an extension for CASPT2 and other methods are in preparation.

The Tully algorithm is available in a separate module :program:`Surfacehop`.

.. _UG\:sec\:dynamix_dependencies:

Dependencies
------------

The coordinates and the forces are required by the :program:`DYNAMIX` program.
:program:`DYNAMIX` reads the initial coordinates from the :file:`RUNFILE` and
updates them in each iteration. In addition :program:`DYNAMIX` depends on the
:program:`ALASKA` program, since it generates forces.

.. _UG\:sec\:dynamix_files:

Files
-----

.. _UG\:sec\:dynamix_inp_files:

Input files
...........

.. class:: filelist

:file:`velocity.xyz`
  Contains the initial velocities of the MD simulation.

.. _UG\:sec\:dynamix_output_files:

Output files
............

.. class:: filelist

:file:`RUNFILE`
  Trajectory information such as current time, velocities, etc. are stored in this file.

:file:`md.xyz`
  The coordinates for each step of the MD trajectory are saved here.

:file:`md.energies`
  The potential, kinetic and total energies are written to this file. In case of multiple
  electronic states, the energies of all roots are saved.

.. _UG\:sec\:dynamix_inp:

Input
-----

This section describes the input syntax of :program:`DYNAMIX` in the |molcas| program
package. In general a MD simulation requires a :kword:`DoWhile` or :kword:`ForEach` loop which contains
several programs to compute the energy and :program:`ALASKA` for subsequent gradient
computation. The :program:`DYNAMIX` input begins with the program name,
and is followed by the only compulsory keyword :kword:`VELV` which specifies the
velocity Verlet algorithm: ::

  &DYNAMIX
  VELV

General keywords
................

.. class:: keywordlist

:kword:`VELVerlet`
  This keyword specifies the velocity Verlet algorithm :cite:`swope:637` to solve Newton's
  equations of motion. It's the only compulsory keyword in the program.

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="VELVER" APPEAR="Velocity Verlet algorithm" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: VELVerlet <basic>
              <HELP>
              Specifies the velocity Verlet algorithm for MD simulation.
              </HELP>
              </KEYWORD>

:kword:`DTime`
  Defines the :math:`\delta t` which is the time step in the MD simulation and which is
  used for the integration of Newton's equations of motion.
  The program expects the time to be given in floating point
  format and in atomic unit of time (1 a.u. of time = :math:`2.42\cdot10^{-17}` s). (Default = 10).

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="DT" APPEAR="Time step" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="10.0" MIN_VALUE="0.0">
              %%Keyword: DTime <advanced>
              <HELP>
              Defines the time step of the MD simulation.
              </HELP>
              </KEYWORD>

:kword:`VELOcities`
  Specifies how the initial velocities are generated.
  This keyword is followed by an integer on the next line. The internal
  unit of the velocities is [bohr\ :math:`\cdot`\(a.u. of time)\ :math:`^{-1}`].

  .. container:: list

    **0** --- Zero velocities. (Default)

    **1** --- The velocities are read from the file :file:`$Project.velocity.xyz`
    in :file:`$WorkDir`. This file contains velocities in the xyz format given in the same
    order as the atoms in coordinate file. The unit of the velocities is [bohr\ :math:`\cdot`\(a.u. of time)\ :math:`^{-1}`].

    **2** --- This option allows to read in mass-weighted velocities from the
    file :file:`$Project.velocity.xyz` in [bohr\ :math:`\cdot\sqrt{\text{a.m.u.}}\cdot`\(a.u. of time)\ :math:`^{-1}`].

    **3** --- This option takes random velocities from a Maxwell--Boltzmann distribution, at
    a given temperature, assuming that every component of the velocity can be considered as an independent gaussian random variable.

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="VELO" APPEAR="Initial velocities" KIND="CHOICE" LIST="0: Zero,1: Read Cartesian,2: Read mass-weighted,3: Maxwell-Boltzmann" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              %%Keyword: VELOcities <advanced>
              <HELP>
              Specifies the initial velocities.
              </HELP>
              </KEYWORD>

:kword:`THERmostat`
  Regulates the control of the temperature by scaling the velocities. The option
  is an integer given on the next line.

  .. container:: list

    **0** --- No velocity scaling. (Default)

    **1** --- The velocities are scaled in order to keep the total energy constant.

    **2** --- The velocities are scaled according to the Nosé--Hoover chain of thermostats algorithm, used to perform molecular symulation at
    constant temperature, resulting in statistics belonging to the canonical ensemble (NVT).

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="THER" APPEAR="Thermostat" KIND="CHOICE" LIST="0: No scaling,1: Constant energy,2: Nosé-Hoover" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              %%Keyword: THERmostat <advanced>
              <HELP>
              Keyword for temperature control.
              </HELP>
              </KEYWORD>

:kword:`TEMPerature`
  Defines the numerical value of the temperature, which is used together with the Nosé--Hoover
  chain of thermostats to perform molecular dynamics at constant temperature. (Default = 298.15 K)

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="TEMP" APPEAR="Temperature of the simulation" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="298.15" MIN_VALUE="0.0">
              %%Keyword: TEMPerature <advanced>
              <HELP>
              Keyword to state the temperature of the simulation.
              </HELP>
              </KEYWORD>

:kword:`HOP`
  Enables the trajectory surface hopping algorithm if the integer given in
  the next line is bigger than 0. The integer also specifies how many
  non-adiabatic transitions are allowed between electronic states.

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="HOP" APPEAR="Maximum number of surface hops" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: HOP <basic>
              <HELP>
              Specifies the maximum number of transitions between electronic states.
              </HELP>
              </KEYWORD>

:kword:`OUT`
  Enables dynamics in reduced dimensionality.
  This keyword is followed by an integer on the next line, which defines the number of nuclear coordinates to project out from the trajectory (default 0).
  The coordinates to project out are then read from the files :file:`out.00X.xyz`, in the xyz format given in the same order as the atoms in coordinate file.
  The projection is performed in mass-weighted coordinates and can be applied directly to normal modes for instance.
  Note: In case of several coordinates to project out, these are first orthogonalised (in mass-weighted coordinates).

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="OUT" APPEAR="Number of coordinates to project out" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: OUT <advanced>
              <HELP>
              Enables reduced dimensionality by projecting out the selected modes.
              Specify an integer N, and provide N files out.00X.xyz.
              </HELP>
              </KEYWORD>

:kword:`IN`
  Enables dynamics in reduced dimensionality.
  This keyword is followed by an integer on the next line, which defines the number of nuclear coordinates to keep in in the trajectory (default 3 * number of atoms).
  The coordinates to keep in are then read from the files :file:`in.00X.xyz`, in the xyz format given in the same order as the atoms in coordinate file.
  The projection is performed in mass-weighted coordinates and can be applied directly to normal modes for instance.
  Note: In case of several coordinates to keep in, these are first orthogonalised (in mass-weighted coordinates).

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="IN" APPEAR="Number of coordinates to keep in" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: IN <advanced>
              <HELP>
              Enables reduced dimensionality by keeping only the selected modes.
              Specify an integer N, and provide N files in.00X.xyz.
              </HELP>
              </KEYWORD>

:kword:`RESTART`
  This keyword allows to restart the trajectory at a given time.
  The time is given on the next line in atomic units.

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="RESTART" APPEAR="Restart the trajectory" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: RESTart <advanced>
              <HELP>
              Restarts the trajectory at a given time, which is specified on the next line.
              </HELP>
              </KEYWORD>

:kword:`H5RESTART`
  This keyword allows to restart a trajectory calculation from an HDF5 file.
  The name of the restart file is given on the next line.

  .. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="H5RESTART" APPEAR="Restart the trajectory from a H5 file" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: H5REstart <advanced>
              <HELP>
              Restarts a trajectory calculation from an HDF5 file, whose name is given on the next line.
              </HELP>
              </KEYWORD>

Input examples
..............

The following example shows the input for an excited state CASSCF molecular dynamics
simulation of a methaniminium cation using the :program:`DYNAMIX` program. The :kword:`DoWhile` loop
allows 1000 steps with 10 a.u. of time step size which leads to a total duration of
242 fs. In the :program:`RASSCF` program the second root is selected for gradient
calculation using the keyword :kword:`MDRLXR`. This input assumes that the a
:file:`JOBIPH` file with orbitals is already given. In each iteration the :file:`JOBIPH`
is updated to achieve a fast convergence of the CASSCF wavefunction.
A Nosé--Hoover chain of thermostats, enabled with :kword:`THERmo`\=2, is used to
reproduce dynamics at constant temperature, where the initial velocities are
taken from a Maxwell--Boltzmann distribution at 300 K.

.. extractfile:: ug/DYNAMIX.input

  &GATEWAY
   COORD
   6
   Angstrom
   C  0.00031448  0.00000000  0.04334060
   N  0.00062994  0.00000000  1.32317716
   H  0.92882820  0.00000000 -0.49115611
   H -0.92846597  0.00000000 -0.49069213
   H -0.85725321  0.00000000  1.86103989
   H  0.85877656  0.00000000  1.86062860
   BASIS= 3-21G
   GROUP= nosym

  >> EXPORT MOLCAS_MAXITER=1000
  >> DOWHILE

  &SEWARD

  >> IF ( ITER = 1 )

  &RASSCF
   LUMORB
   FileOrb= $Project.GssOrb
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1

  >> COPY $Project.JobIph $Project.JobOld

  >> ENDIF

  &RASSCF
   JOBIPH; CIRESTART
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1
   MDRLXR= 2

  >> COPY $Project.JobIph $Project.JobOld

  &ALASKA

  &DYNAMIX
   VELVer
   DT= 10.0
   VELO= 3
   THER= 2
   TEMP=300
   HOP= 1

  >> END DO

.. xmldoc:: <KEYWORD MODULE="DYNAMIX" NAME="VV_FIRST" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>

Dynamixtools
------------

This tool can be found into the :file:`Tools/` folder and it will provide some general tools to manage molecular dynamics calculations. At the moment it can be used to generate intial conditions (geometries and momenta) based on a frequency calculation using several sampling methods. It is working with a :file:`freq.molden` file (:file:`.h5` support coming soon...). 

From the command prompt: ::

  $ python3 dynamixtools.py -h
  usage: dynamixtools.py [-h] [-s SEED] [-l LABEL] [-i I] [-c CONDITION] [-t TEMP] [-v] [-T] [-D] [-m METHOD]

  optional arguments:
  -h, --help            show this help message and exit
  -s SEED, --seed SEED  indicate the SEED to use for the generation of randoms
  -l LABEL, --label LABEL
                        label for your project (default is "geom")
  -i I, --input I       path of the frequency h5 or molden file
  -c CONDITION, --condition CONDITION
                        number of initial conditions (default 1)
  -t TEMP, --temperature TEMP
                        temperature in kelvin for the initial conditions
  -v, --verbose         more verbose output
  -T, --TEST            keyword use to test the routines
  -D, --DIGIT           keyword to suppress the counter in the filename (needed for debug)
  -m METHOD, --method METHOD
                        Keyword to specify the sampling method:
                        1 Initial conditions based on the molecular vibrational frequencies and energies sampled from a Boltzmann distribution (Default).
                        2 Thermal normal mode sampling where the cumulitative distribution function for a classical boltzmann distribution at temperature T is used to approximate the energy of each mode.
                        3 Wigner distribution for the ground vibrational state, n=0.

Having a :file:`water.freq.molden` file, this is the command to generate 200 initial conditions using 3435432 as seed and a temperature of 300 kelvin: ::

  $ python3 dynamixtools.py -i water.freq.molden -t 300 -c 200 -s 3435432

.. index::
   single: Program; RASSI
   single: RASSI

.. _UG\:sec\:rassi:

:program:`rassi`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="RASSI">
            %%Description:
            <HELP>
            The RASSI program calculates overlaps, and matrix
            elements of one-electron operators, and of the electronic Hamiltonian,
            over a basis of RASSCF wave functions, which may each have its own
            independent set of orbitals. Energies and matrix elements are
            computed also for the non-interacting linear combinations of states,
            i.e., doing a limited CI using the RASSCF states as a non-orthogonal basis.
            RASSI is extensively used for computing dipole oscillator strengths.
            Finally, it can also compute e.g. spin-orbit interaction matrix elements,
            transition dipole moments, (bi-)natural orbitals and other quantities.
            </HELP>

The
:program:`RASSI` (RAS :index:`State Interaction`) program forms overlaps and
other :index:`matrix
elements <single: Matrix elements; RASSCF>` of the Hamiltonian and other operators
over a wave function basis, which consists of RASSCF wave functions,
each with an individual set of orbitals. It is extensively used
for computing dipole :index:`oscillator strengths <single: Oscillator strength>`, but any
one-electron operator, for which the :program:`Seward` has computed
integrals to the :file:`ORDINT` file, can be used, not just dipole
moment components.

Also, it solves the Schrödinger
equation projected on the space spanned by these wave functions,
i.e., it forms non-interacting linear combinations of the input
state functions, and computes matrix elements over the resulting
eigenbasis as well.

Finally, using these spin-free eigenstates as a basis, it can
compute spin--orbit interaction matrix elements, diagonalize
the resulting matrix, and compute various matrix elements over
the resulting set of spin--orbit eigenstates.

If only matrix
elements of some one-electron operator(s), such as the dipole
transition moments, are required, the calculation of Hamiltonian
matrix elements and the transformation to the eigenbasis of this
matrix can be skipped. However, if any states have the same symmetry
and different orbitals, it is desirable to use the transitions strengths
as computed between properly non-interacting and orthonormal states.
The reason is that the individually optimized RASSCF states are
interacting and non-orthogonal, and the main error in the computed
transition matrix elements is the difference in electronic dipole
moment times the overlap of any two states involved. For excited
states, the overlap is often in the order of 10%.

Please note: Due to the increasing number of calculations done with
a hundred input states, or more, there has been a demand to change
the output. Until |molcas| 6.2, the default assumption has been to print
all expectation values and matrix elements that can be computed from
the selection of one-electron integrals. From 6.4, this is requested by
keywords, see the keyword list below for XVIN, XVES, XVSO, MEIN,
MEES, and MESO.

Apart from computing oscillator strengths, overlaps and Hamiltonian
matrix elements can be used to compute :index:`electron transfer rates <single: Electron transfer rate>`, or
to form :index:`quasi-diabatic states <single: Quasi-diabatic states>` and reexpress matrix elements over a
basis of such states.

The CSF space of a RASSCF wave function is closed under deexcitation.
For any given pair of RASSCF wave functions, this is used in the
way described in reference :cite:`Malmqvist:86` to allow the pair of orbital
sets to be transformed to a biorthonormal pair, while simultaneously
transforming the CI expansion coefficients so that the wave functions
remain unchanged. The basic principles are the same as in the earlier
program :cite:`Malmqvist:89`, but is adapted to allow RASSCF as well as
CASSCF wave functions. It uses internally a Slater determinant
expansion. It can now use spin-dependent operators,
including the AMFI spin--orbit operator, and can compute matrix elements
over spin--orbit states, i.e. the eigenstates of the sum of the
spin-free hamiltonian and the spin--orbit operator.

One use of the RASSI eigenstates is to resolve ambiguities due
to the imperfect description of highly excited states.
Association between individually optimized states and the exact
electronic eigenstates is often not clear, when the calculation
involves several or many excited states. The reason is that the
different states each use a different set of orbitals. The State
Interaction calculation gives an unambiguous set of non-interacting and
orthonormal eigenstates to the projected Schrödinger equation, and
also the overlaps between the original RASSCF wave functions and the
eigenstates. The latter is a very efficient diagnostic, since it
describes the RASSCF states in terms of one single wave-function basis
set.

.. index::
   single: RASSCF; Multiple solutions

To make the last point clear, assume the following situation:
We have
performed three RASSCF calculations, one where we optimize for the
lowest state, one for the first excited state, and one for the 2nd
excited state in the same symmetry. The active orbitals are fairly
much mixed around, so a simple inspection of the CI coefficient is
insufficient for comparing the states. Assume that for each state, we
have calculated the three lowest CI roots. It can now happen, that the
2nd root of each calculation is a fair approximation to the exact 2nd
eigenstate, and the same with the 3rd, or possibly that the order gets
interchanged in one or two of the calculation. In that case, a RASSI
calculation with these 9 states will give three improved solutions
close to the original ones, and of course 6 more that are considered
to be the removed garbage. The overlaps will confirm that each of the
input states consists mainly of one particular out of the three lowest
eigenstates. This situation is the one we usually assume, if no
further information is available.

However, it happens that the active orbitals of the three calculations
do not span approximately the same space. The orbital optimization
procedure has made a qualitatively different selection of correlating
orbitals for the three different calculation. Then the :program:`RASSI`
calculation may well come out with 4 lowest roots that overlap
strongly with the original RASSCF states. This may change the
assignments and may also give valuable information about the
importance of some state. The natural orbitals of the eigenstates will
show that the active space used in the RASSCF was in some way
inappropriate.

Another bothersome situation is also solved by the RASSI method. The
analysis of the original states in terms of RASSI eigenstates may
reveal that the three optimized RASSCF states consists mainly of TWO
low RASSI eigenstates! This is because the RASSCF optimization
equations are non-linear and may sometimes offer spurious extra
solutions. Two of the calculations are in this case to be regarded
qualitatively, as two different (local) solutions that
approximate (imperfectly) the same excited state. Also in this case, the
natural orbitals will probably offer a clue to how to get rid of the
problem. Extra solutions rarely occur for low states in CASSCF
calculations, provided a generous active space can be afforded.
Problems occur when the active space is too small, and in
particular with general RASSCF calculations.

A further application is the preparation of a suitable orbital basis
for a subsequent CI calculation. Note that such an application also
allows the use of badly converged RASSCF wave functions, or of RASSCF
wave functions containing multiple minima solutions close to a common
exact eigenstate. In effect, the :program:`RASSI` program cleans up the situation
by removing the errors due to bad convergence (pushing the errors into
a garbage part of the spectrum). This requires that the set of input
states (9 in this example) provides flexibility enough to remove at
least a major part of the error. As one would expect, this is usually
true: The erratic non-convergent, or the too slowly convergent, error
mode is to a large extent spanned by the few lowest RASSCF wave
functions.

Finally, there are situations where there is no problem to obtain
adiabatic RASSCF solutions, but where it is still imperative to use
RASSI natural orbitals in a subsequent CI. Consider the case of
transition metal chemistry, where there is in general two or more
electronic states involved. These states are supposed to interact
strongly, at least within some range of interatomic distances. Here,
an MCSCF solution, such as RASSCF, will have at least two very
different solutions, one associated with each configuration of the
transition metal atom. Using one set of orbitals, one electronic state
has a reasonably described potential energy curve, while other states
get pushed far up in energy. Using another set of orbitals, another
state gets correctly described. In no calculation with a single
orbital set do we obtain the avoided crossings, where one switches
from one diabatic state to another. The only way to accomplish this is
via a RASSI calculation. In this case, it is probably necessary also to
shift the energies of the RASSCF states to ensure that the crossing
occur at the correct places. The shifts can be determined by
correcting the atomic spectrum in the separated-atoms limit.

Note, however, that most of the problems described above can be
solved by performing state-averaged RASSCF calculations.

.. In the latest version of |molcas|, derivatives of transition dipole moments
   have been added to RASSI :cite:`Bernhardsson:99b`. The derivatives are
   calculated as the matrix element of the product of the (CI/orbital)
   rotation operator and the dipole moment operator.

.. index::
   pair: Dependencies; RASSI

.. _UG\:sec\:rassi_dependencies:

Dependencies
------------

The :program:`RASSI` program needs one or more :file:`JOBIPH` files produced
by the :program:`RASSCF` program. Also, it needs a :file:`ONEINT` file from
:program:`SEWARD`, with overlap integrals and any one-electron
property integrals for the requested matrix elements. If Hamiltonian
matrix elements are used, also the :file:`ORDINT` file is needed.

.. For derivatives the :program:`RASSI` needs the :file:`MCKINT` file
   produced by :program:`MCKINLEY` and :program:`MCLR` containing
   the derivatives of the dipole operator and the orbital rotations and the
   state transfer operators.

   The existence of a file with the name :file:`MCKINT1` will automatically
   change :program:`RASSI` to from ordinary calculation of state interaction
   properties, to calculation of derivatives of state interaction properties,
   like transition dipole derivatives and non adiabatic coupling constants.

   It is important that if derivatives of state interaction properties should
   be calculated, the expansion center for that property must be (0,0,0).
   For derivatives of transition dipole moments, the following keyword has to be
   added to the :program:`SEWARD` input. ::

     Center= 1; 1 0.0 0.0 0.0

.. index::
   pair: Files; RASSI

.. _UG\:sec\:rassi_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`ORDINT*`
  Ordered two-electron integral file produced by the :program:`SEWARD`
  program. In reality, this is up to 10 files in a multi-file system,
  named ORDINT, ORDINT1,...,ORDINT9. This is necessary on some platforms
  in order to store large amounts of data.

:file:`ONEINT`
  The one-electron integral file from :program:`SEWARD`

:file:`JOBnnn`
  A number of :file:`JOBIPH` files from different :program:`RASSCF` jobs.
  An older naming convention assumes file names JOB001, JOB002, etc. for these files.
  They are automatically linked to default files named :file:`$Project.JobIph`,
  :file:`$Project.JobIph01`, :file:`$Project.JobIph02`, etc. in directory :file:`$WorkDir`,
  unless they already exist as files or links before the program starts.
  You can set up such links yourself, or else you can specify file names
  to use by the keyword :kword:`IPHNames`.

:file:`JOBIPHnn`
  A number of :file:`JOBIPH` files from different :program:`RASSCF` jobs.
  The present naming convention assumes file names JOBIPH, JOBIPH01, etc. for
  such files, when created by subsequent :program:`RASSCF` runs, unless
  other names were specified by input.
  They are automatically linked to default files named :file:`$Project.JobIph`,
  :file:`$Project.JobIph01`, :file:`$Project.JobIph02`, etc. in directory :file:`$WorkDir`,
  unless they already exist as files or links before the program starts.
  You can set up such links yourself, or else you can specify file names
  to use by the keyword :kword:`IPHNames`.

  .. :file:`MCKINTn`
       A number of :file:`MCKINT` files from different Single state calculations.
       The numbering of the MCKINTn files should be the same as the
       numbering of JOBnnn files, files with the same number should correspond to
       the same state.

Output files
............

.. class:: filelist

:file:`SIORBnn`
  A number of files containing natural orbitals, (numbered sequentially as
  :file:`SIORB01`, :file:`SIORB02`, etc.)

:file:`BIORBnnmm`
  A number of files containing binatural orbitals for the transition between
  states ``nn`` and ``mm``. Each such file contains pairs of orbitals, in the same format
  as the :math:`\alpha` and :math:`\beta` components of UHF orbitals. The file for transition
  to state ``nn``\ =2 from state ``mm``\ =1 will be named :file:`BIORB.2_1`.

:file:`TOFILE`
  This output is only created if :kword:`TOFIle` is given in the input.
  It will contain the transition density matrix computed by :program:`Rassi`.
  Currently, this file is only used as input to :program:`QmStat`.

:file:`EIGV`
  Like :file:`TOFILE` this file is only created if :kword:`TOFIle` is given
  in the input. It contains auxiliary information that is picked up
  by :program:`QmStat`.

:file:`NTORB` and :file:`MD_NTO`
  This output is only created if :kword:`NTOCalc` is given in the input. The files
  will contain natural transition orbitals in INPORB (:file:`NTORB`) and Molden (:file:`MD_NTO`) formats.

  .. :file:`UNSYM`
       The derivative of the transition dipole moment desymmetrized.

.. index::
   pair: Input; RASSI

.. _UG\:sec\:rassi_input:

Input
-----

This section describes the input to the
:program:`RASSI` program in the |molcas| program system,
with the program name: ::

  &RASSI

When a keyword is followed by additional mandatory lines of input,
this sequence cannot be interrupted by a comment line. The first 4
characters of keywords are decoded. An unidentified keyword makes the
program stop.

.. index::
   pair: Keywords; RASSI

Keywords
........

.. :kword:`CHOLesky`
     :program:`RASSI` will use Cholesky (or RI/DF) representation of the two-electron integrals to compute
     the corresponding contributions to the Fock matrices and to perform the MO integral transformations.
     The default (LK) algorithm is used. The configuration may be tailored using the ChoInput section.
     Default is to not use Cholesky unless the Cholesky (or RI/DF) representation of the two-electron
     integrals has been produced by :program:`SEWARD`.

..   .. xmldoc:: %%Keyword: Cholesky <basic>
                 Use of Cholesky (or RI/DF) representation for the two-electron integrals
                 with default RASSI settings.

.. class:: keywordlist

:kword:`CHOInput`
  This marks the start of an input section for modifying
  the default settings of the Cholesky RASSI.
  Below follows a description of the associated options.
  The options may be given in any order,
  and they are all optional except for
  :kword:`ENDChoinput` which marks the end of the :kword:`CHOInput` section.

  .. xmldoc:: <GROUP MODULE="RASSI" NAME="CHOINPUT" APPEAR="Cholesky input section" KIND="BLOCK" LEVEL="ADVANCED">
              %%Keyword: Choinput <advanced>
              <HELP>
              Manually modify the settings of the Cholesky RASSI.
              </HELP>

  * :kword:`NoLK`
    Available only within ChoInput. Deactivates the "Local Exchange" (LK) screening algorithm :cite:`Aquilante:07a` in computing
    the Fock matrix. The loss of speed compared to the default algorithm can be substantial, especially for electron-rich systems.
    Default is to use LK.

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="NOLK" APPEAR="Turn Off LK screening" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NoLK <advanced>
                <HELP>
                Deactivates LK screening.
                </HELP>
                </KEYWORD>

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="LOCK" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  * :kword:`DMPK`
    Available only within ChoInput. Modifies the thresholds used in the LK screening.
    The keyword takes as argument a (double precision) floating point (non-negative) number used
    as correction factor for the LK screening thresholds.
    The default value is 1.0d-1. A smaller value results in a slower but more accurate calculation.

    **Note:** the default choice of the LK screening thresholds is tailored to achieve as much as possible an
    accuracy of the RASSI energies consistent with the choice of the Cholesky decomposition
    threshold.

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DMPK" APPEAR="Damping for LK" LEVEL="ADVANCED" KIND="REAL" EXCLUSIVE="NOLK">
                %%Keyword: DMPK <advanced>
                <HELP>
                Modifies the thresholds used in the LK screening.
                The default value is 1.0d-1. A smaller value results in a slower but more accurate calculation.
                </HELP>
                </KEYWORD>

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ALGORITHM" LEVEL="UNDOCUMENTED" KIND="INT" />

  * :kword:`NODEcomposition`
    Available only within ChoInput. The inactive Exchange contribution to the Fock matrix is computed using inactive canonical orbitals
    instead of (localized) "Cholesky MOs".
    This choice is effective only in combination with the LK screening.
    Default is to use Cholesky MOs. **Note:** the Cholesky MOs in RASSI are computed by decomposing the
    density type supermatrix :math:`\mat{D}=(\mat{C}_A, \mat{C}_B)(\mat{C}_A, \mat{C}_B)^{\text{T}}` where :math:`\mat{C}` is the corresponding canonical
    MOs matrix for the state :math:`A` and :math:`B`.

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="NODE" APPEAR="Turn Off density decomposition" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NODE <advanced>
                <HELP>
                The inactive Exchange contribution to the Fock matrix is computed using inactive canonical orbitals
                instead of (localized) "Cholesky MOs".
                </HELP>
                </KEYWORD>

  * :kword:`PSEUdo`
    When computing the coupling between 2 different
    states A and B, only for the first state we use pure Cholesky MOs. The invariance of the Fock matrix
    is then ensured by rotating the orbitals of B according to the orthogonal matrix defined in A
    through the Cholesky localization. These orbitals used for B are therefore called "pseudo Cholesky MOs".

    .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="PSEU" APPEAR="Use PseudoCholesky orbitals" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: PSEU <advanced>
                <HELP>
                The inactive Exchange contribution to the Fock matrix is computed using pseudo Cholesky orbitals.
                </HELP>
                </KEYWORD>

    .. xmldoc:: </GROUP>

  * :kword:`TIME`
    Activates printing of the timings of each task of the Fock matrix build.
    Default is to not show these timings.

  * :kword:`MEMFraction`
    Set the fraction of memory to use as global Cholesky vector buffer.
    Default: for serial runs 0.0d0; for parallel runs 0.3d0.

:kword:`MEIN`
  Demand for printing matrix elements of all selected one-electron
  properties, over the input RASSCF wave functions.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="MEIN" APPEAR="RASSCF matrix elements" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: MEIN <basic>
              <HELP>
              Demand for printing matrix elements of all selected one-electron
              properties, over the input RASSCF wave functions.
              </HELP>
              </KEYWORD>

:kword:`MEES`
  Demand for printing matrix elements of all selected one-electron
  properties, over the spin-free eigenstates.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="MEES" APPEAR="spin-free matrix elements" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: MEES <basic>
              <HELP>
              Demand for printing matrix elements of all selected one-electron
              properties, over the spin-free eigenstates.
              </HELP>
              </KEYWORD>

:kword:`MESO`
  Demand for printing matrix elements of all selected one-electron
  properties, over the spin--orbit states.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="MESO" APPEAR="SO matrix elements" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: MESO <basic>
              <HELP>
              Demand for printing matrix elements of all selected one-electron
              properties, over the spin-orbit states.
              </HELP>
              </KEYWORD>

  .. :kword:`PRINT`
     Set individual print levels for various subroutines of the code, mainly
     for debugging purposes.
     This keyword requires an entry with number of name,value
     pairs, with the same format as that used for the PROP input. The names
     are subroutine names, and each value is the print level setting for that
     subroutine.

  .. .. xmldoc:: %%Keyword: Print <advanced>
                 Set individual print levels for various subroutines of the code.

:kword:`PROPerty`
  Replace the default selection of one-electron operators, for which
  matrix elements and expectation values are to be calculated, with a
  user-supplied list of operators.

  .. compound::

    From the lines following the keyword the selection list is
    read by the following *FORTRAN* code: ::

      READ({*},{*}) NPROP,(PNAME(I),ICOMP(I),I=1,NPROP)

    NPROP is the number of selected properties, PNAME(I) is a
    character string with the label of this operator on :program:`SEWARD`'s
    one-electron integral file, and ICOMP(I) is the component number.

  The default selection is to use dipole and/or velocity integrals, if
  these are available in the :file:`ONEINT` file. This choice is replaced by the
  user-specified choice if the :kword:`PROP` keyword is used.
  Note that the character strings are read using list directed input and
  thus must be within single quotes, see sample input below.
  For a listing of presently available operators, their labels, and
  component conventions, see
  :program:`SEWARD` program description.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="PROPERTY" APPEAR="Properties" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: Property <basic>
              <HELP>
              Enter a user-supplied selection of one-electron operators, for which
              matrix elements and expectation values are to be calculated. Without
              this keyword and list, the default choice is to use every operator,
              for which the one-electron integral file supplies integrals.
              </HELP>
              </KEYWORD>

:kword:`SOCOupling`
  Enter a positive threshold value. Spin--orbit interaction matrix
  elements over the spin components of the spin-free eigenstates
  will be printed, unless smaller than this threshold.
  The value is given in cm\ :math:`^{-1}` units. The keyword is
  ignored unless an SO hamiltonian is actually computed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SOCOUPLING" APPEAR="Spin-orbit coupling threshold" KIND="REAL" LEVEL="BASIC">
              %%Keyword: SOCoupling <basic>
              <HELP>
              Enter a positive threshold value. Spin-orbit interaction matrix
              elements over the spin components of the spin-free eigenstates
              will be printed, unless smaller than this threshold.
              The value is given in cm^-1 units. The keyword is ignored unless
              an SO hamiltonian is actually computed.
              </HELP>
              </KEYWORD>

:kword:`SOPRoperty`
  Enter a user-supplied selection of one-electron operators, for which
  matrix elements and expectation values are to be calculated over the
  spin--orbit eigenstates. This keyword has no effect unless the
  :kword:`SPIN` keyword has been used. Format: see :kword:`PROP` keyword.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SOPROPERTY" APPEAR="SO Properties" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: SOProperty <basic>
              <HELP>
              Enter a selection of one-electron operators, for which
              matrix elements and expectation values are to be calculated over the
              spin-orbit eigenstates. This keyword has no effect unless the
              SPIN keyword has been used. Format: see PROP keyword.
              </HELP>
              </KEYWORD>

:kword:`SPINorbit`
  Spin--orbit interaction matrix elements will be computed. Provided that
  the :kword:`ONEL` keyword was not used, the resulting Hamiltonian including the
  spin--orbit coupling, over a basis consisting of all the spin components
  of wave functions constructed using the spin-free eigenstates, will be
  diagonalized. NB: For this keyword to have any effect, the SO integrals
  must have been computed by :program:`SEWARD`! See :kword:`AMFI` keyword in :program:`SEWARD` documentation.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SPIN" APPEAR="spin-orbit calc." KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Spinorbit <basic>
              <HELP>
              Spin-orbit interaction matrix elements will be computed and the resulting
              Hamiltonian including will be diagonalized.
              NB: For this keyword to have any effect, the SO integrals
              must have been computed by SEWARD (AMFI integrals)!
              </HELP>
              </KEYWORD>

:kword:`ONEL` or :kword:`ONEE`
  The two-electron integral file will not be accessed. No Hamiltonian
  matrix elements will be calculated, and only matrix elements for the
  original RASSCF wave functions will be calculated.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ONEL" APPEAR="One-electron properties only" KIND="SINGLE" LEVEL="BASIC" ALSO="ONEE">
              %%Keyword: Onel <basic>
              <HELP>
              The two-electron integral file will not be accessed. No hamiltonian
              matrix elements will be calculated. Non-interacting states will not
              be formed.
              </HELP>
              Onee is a valid synonym for this keyword.
              </KEYWORD>

:kword:`J-VAlue`
  For spin--orbit calculations with single atoms, only: The output lines
  with energy for each spin--orbit state will be annotated with the
  approximate J and Omega quantum numbers.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="J-VALUE" APPEAR="J-Value" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: J-Value <basic>
              <HELP>
              For spin-orbit calculations with single atoms, only: The output lines
              with energy for each spin-orbit state will be annotated with the
              approximate J quantum number.
              </HELP>
              </KEYWORD>

:kword:`OMEGa`
  For spin--orbit calculations with linear molecules, only: The output lines
  with energy for each spin--orbit state will be annotated with the
  approximate Omega quantum number.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="OMEGA" APPEAR="Omega-Value" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Omega <basic>
              <HELP>
              For spin-orbit calculations on linear molecules, only: The output lines
              with energy for each spin-orbit state will be annotated with the
              approximate Omega quantum number.
              </HELP>
              </KEYWORD>

:kword:`NROF jobiphs`
  Number of
  :file:`JOBIPH` files used as input. This keyword should be
  followed by the number of
  states to be read from each :file:`JOBIPH`. Further, one line per
  :file:`JOBIPH` is required with a list of the states to be
  read from the particular file. See sample input below.
  Alternatively, the first line can contain the number of :file:`JOBIPH` used
  as input followed by the word "``ALL``", indicating that all states
  will be taken from each file. In this case no further lines are required.
  For :file:`JOBIPH` file names, see the Files section.
  Note: If this keyword is missing, then by default all files named "JOB001",
  "JOB002", etc. will be used, and all states found on these files will be
  used.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="NROFJOBIPHS" APPEAR="Input states from JOBIPHs" KIND="CUSTOM" LEVEL="BASIC" ALSO="NR OF JOBIPHS">
              %%Keyword: NrOf <basic>
              <HELP>
              Number of JOBIPH files used as input, followed by a list of
              the number of states to read from each JOBIPH, and finally,
              for each JOBIPH a list of which states to select.
              </HELP>
              </KEYWORD>

:kword:`SUBSets`
  In many cases, RASSI is used to compute the transition moments between
  a set of initial states (for example the ground state) and a set of final states.
  This keyword allows to restrict the computation of transition moments between the two sets
  and not within each set, thus saving time and reducing the output size.
  The keyword is followed by the index where the two sets split (assuming energy ordering).
  For a calculation between one ground state and several excited states, :kword:`SUBSets` should be 1.
  Default is to compute the transition moments between all states.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SUBSETS" APPEAR="Subsets" KIND="INT" LEVEL="BASIC">
              %%Keyword: Subsets <basic>
              <HELP>
              Restricts the computation of transition moments to be only between
              two sets of states, and not also within each set.
              The keyword is followed by the number of states
              in the first set (assuming energy ordering).
              </HELP>
              </KEYWORD>

:kword:`IPHNames`
  Followed by one entry for each :file:`JOBIPH` file to be used, with the
  name of each file. Note: This keyword presumes that the number of
  :file:`JOBIPH` files have already been entered using keyword :kword:`NROF`.
  For default :file:`JOBIPH` file names, see the Files section.
  The names will be truncated to 8 characters and converted to uppercase.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="IPHNAMES" APPEAR="JobIph names" KIND="STRINGS_LOOKUP" SIZE="NROFJOBIPHS" LEVEL="BASIC">
              %%Keyword: IPHNames <basic>
              <HELP>
              Followed by one entry for each JOBIPH file to be used, with the
              name of each file. Note: This keyword presumes that the number of
              JOBIPH files have already been entered using keyword NROF.
              The names will be truncated to 8 characters and converted to uppercase.
              </HELP>
              </KEYWORD>

  .. :kword:`NACMe`
       Switch from calculations of transition dipole moment to calculation of
       non adiabatic coupling constants. Only valid if :file:`MCKINT1` file exist.

       .. .. xmldoc:: %%Keyword: NACM <advanced>
                      For computing non-adiabatic coupling matrix elements. This requires
                      that a MCKINT1 file exist. After this keyword should follow a list
                      of energy shifts, one for each wave function. Such shifts are
                      usually needed in order to ensure that energy crossings occur where
                      they should. Note: this keyword must not precede the NROF input.

:kword:`SHIFt`
  The next entry or entries gives an energy shift for each wave function,
  to be added to diagonal elements of the Hamiltonian matrix.
  This may be necessary e.g. to ensure that an energy crossing occurs
  where it should. NOTE: The number of states must be known
  (See keyword :kword:`NROF`) before this input is read.
  In case the states are not orthonormal, the actual quantity added to
  the Hamiltonian is ``0.5D0*(ESHFT(I)+ESHFT(J))*OVLP(I,J)``. This is necessary
  to ensure that the shift does not introduce artificial interactions.
  :kword:`SHIFT` and :kword:`HDIAG` can be used together.

  .. xmldoc:: %%Keyword: Shift <basic>
              The next entry or entries gives an energy shift for each wave function,
              to be added to diagonal elements of the Hamiltonian matrix.

:kword:`HDIAg`
  The next entry or entries gives an energy for each wave function,
  to replace the diagonal elements of the Hamiltonian matrix.
  Non-orthogonality is handled similarly as for the :kword:`SHIFT` keyword.
  :kword:`SHIFT` and :kword:`HDIAG` can be used together.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="HDIAG" APPEAR="Diagonal elements" KIND="REALS_COMPUTED" SIZE="1" LEVEL="BASIC">
              %%Keyword: HDiag <basic>
              <HELP>
              Enter an energy for each spin-free wave function,
              to replace the diagonal elements of the Hamiltonian matrix.
              For example to use CASPT2 shifted energies in the diagonal.
              </HELP>
              </KEYWORD>

:kword:`NATOrb`
  The next entry gives the number of eigenstates for which natural
  orbitals will be computed. They will be written, formatted, commented,
  and followed by natural occupancy numbers, on one file each state.
  For file names, see the Files section.
  The format allows their use as standard orbital input files to
  other |molcas| programs.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="NATORB" APPEAR="Natural Orbitals" KIND="INT" LEVEL="BASIC">
              %%Keyword: NatOrb <basic>
              <HELP>
              Enter the number of eigenstates for which natural orbitals should
              be computed and written to file. These will be written together with
              natural occupation numbers in the usual format used by MOLCAS.
              </HELP>
              </KEYWORD>

:kword:`BINAtorb`
  The next entry gives the number of transitions for which binatural
  orbitals will be computed. Then a line should follow for each transition,
  with the two states involved. The orbitals and singular values provide a
  singular value decomposition of a transition density matrix :cite:`Malmqvist:2012`.
  The bra and ket orbitals are written followed by the singular values in the
  usual UHF format used by other |molcas| programs.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="BINATORB" APPEAR="Binatural Orbitals" KIND="INTS_COMPUTED" SIZE="2" LEVEL="BASIC">
              %%Keyword: BiNatOrb <basic>
              <HELP>
              Enter the number of transitions, for which binatural orbitals should
              be computed and written to file. Then a line should follow with the two
              states for each transition. The ket and the bra orbitals are written
              followed by the singular values in the the usual format used by MOLCAS.
              </HELP>
              </KEYWORD>

:kword:`ORBItals`
  Print out the Molecular Orbitals read from each
  :file:`JOBIPH` file.

  .. xmldoc:: %%Keyword: Orbitals <advanced>
              Print out the molecular orbitals read from each JOBIPH file.

:kword:`OVERlaps`
  Print out the overlap integrals between the various orbital sets.

  .. xmldoc:: %%Keyword: Overlaps <advanced>
              Print out the overlap integrals between the various orbital sets.

:kword:`CIPRint`
  Print out the CI coefficients read from
  :file:`JOBIPH`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="CIPRINT" APPEAR="Print input CI coeff." KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: CIPrint <advanced>
              <HELP>
              Print out the CI coefficients read from JOBIPH.
              </HELP>
              </KEYWORD>

:kword:`THRS`
  The next line gives the threshold for printing CI coefficients. The
  default value is 0.05.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="THRS" APPEAR="Threshold for CI coeff." KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: Thrs <advanced>
              <HELP>
              Enter the threshold for printing CI coefficients. Default 0.05.
              </HELP>
              </KEYWORD>

:kword:`DIPRint`
  The next entry gives the threshold for printing dipole intensities.
  Default is 1.0D-5.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DIPR" APPEAR="Threshold dipole intensities" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0D-5" LEVEL="ADVANCED">
              %%Keyword: DIPR <advanced>
              <HELP>
              Enter the threshold for printing dipole intensities.
              Default is 1.0D-5.
              </HELP>
              </KEYWORD>

:kword:`QIPRint`
  The next entry gives the threshold for printing quadrupole intensities.
  Default is 1.0D-5.
  Will overwrite any value chosen for dipole intensities.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="QIPR" APPEAR="Threshold quadrupole intensities" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0D-5" LEVEL="ADVANCED">
              %%Keyword: QIPR <advanced>
              <HELP>
              Enter the threshold for printing quadrupole intensities.
              Default is 1.0D-5.
              Will overwrite any value chosen for dipole intensities.
              </HELP>
              </KEYWORD>

:kword:`RSPR`
  The next entry gives the threshold for printing reduced rotatory strength intensities.
  Default is 1.0D-7.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="RSPR" APPEAR="Threshold for reduced rotatory strength intensities" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0D-7" LEVEL="ADVANCED">
              %%Keyword: RSPR <advanced>
              <HELP>
              Enter the threshold for printing reduced rotatory strength.
              Default is 1.0D-7.
              </HELP>
              </KEYWORD>

:kword:`QIALL`
  Print all quadrupole intensities.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="QIALL" APPEAR="Print all quadrupole intensities" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: QIALL <advanced>
              <HELP>
              Print all quadrupole intensities.
              </HELP>
              </KEYWORD>

:kword:`CD`
  Compute rotatory strengths (for circular dichroism) from the multipole expansion of transition moments.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="CD" APPEAR="Circular dichroism" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CD <basic>
              <HELP>
              Compute rotatory strengths from the multipole expansion of transition moments.
              </HELP>
              </KEYWORD>

:kword:`TINTensities`
  Activate the computation of transition intensities (oscillator strengths and rotatory strengths) using the
  non-relativistic Hamiltonian with the explicit Coulomb-field vector operator (:math:`A`) in
  the weak field approximation.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TINT" APPEAR="Transition intensities (exponential)" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TINTensities <advanced>
              <HELP>
              Activate the computation of transition intensities (oscillator strengths and rotatory strengths) using the
              non-relativistic Hamiltonian with the explicit Coulomb-field vector operator (A) in
              the weak field approximation.
              </HELP>
              </KEYWORD>

:kword:`TIGRoup`
  Group the states close in energy for the purpose of computing transition intensities wi the exponential operator
  (:kword:`TINTensities` keyword). A single wave vector will be used for all transitions to the states in the group.
  This is a good approximation when the energy difference between the states in a group is negligible with respect
  to the energy of the transition. The keyword reads a real value, that is the maximum relative difference for
  transitions in a group with respect to the average energy.
  This keyword requires the use of :kword:`SUBSets` and :kword:`TINTensities`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TIGROUP" KIND="REAL" LEVEL="ADVANCED" REQUIRE="SUBSETS,TINT">
              %%Keyword: TIGRoup <advanced>
              <HELP>
              Group states close in energy for computing transition intensities with the exponential operator
              (TINTensities keyword). Specify a real value as the grouping threshold, relative to the average
              transition energy to a group. Requires SUBSets and TINTensities.
              </HELP>
              </KEYWORD>

:kword:`IIORder`
  Set the order of the Lebedev grids used in the isotropic integration of transition intensities
  in association with the :kword:`TINT` option. Default value is 5.
  Other allowed values are: 7, 11, 17, 23, 29, 35, 41, 47, 53, and 59.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="IIORDER" APPEAR="Isotropic integration order" KIND="INT" MIN_VALUE="5" DEFAULT_VALUE="5" LEVEL="ADVANCED">
              %%Keyword: IIORder <advanced>
              <HELP>
              Set the order of the Lebedev grids used in the isotropic integration of transition intensities
              in association with the TINT option. Default value is 5.
              Other allowed values are: 7, 11, 17, 23, 29, 35, 41, 47, 53, and 59.
              </HELP>
              </KEYWORD>

:kword:`PRRAw`
  Print the raw directions for the exact semi-classical intensities (see the :kword:`TINT` keyword).

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="PRRA" APPEAR="Print raw directions" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PRRAw <advanced>
              <HELP>
              Print the raw directions for the exact semi-classical intensities
              </HELP>
              (see the TINT keyword).
              </KEYWORD>

:kword:`PRWEighted`
  Print the weighted directions for the exact semi-classical intensities (see the :kword:`TINT` keyword).

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="PRWE" APPEAR="Print weighted directions" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PRWEighted <advanced>
              <HELP>
              Print the weighted directions for the exact semi-classical intensities
              </HELP>
              (see the TINT keyword).
              </KEYWORD>

:kword:`DIREction`
  Define the direction of the incident light for which we will
  compute transition moments and oscillator strengths. The keyword
  is followed by an integer :math:`n`, the number of directions,
  and then :math:`n` lines with three real numbers each specifying the direction. The values
  do not need to be normalized.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DIRECTION" APPEAR="Direction of propagation" KIND="REALS_COMPUTED" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: DIREction <advanced>
              <HELP>
              Define the direction of the incident light for which we will
              compute transition moments and oscillator strengths. The keyword
              is followed by an integer n, the number of directions,
              and then n lines with three real numbers each specifying the direction. The values
              do not need to be normalized.
              </HELP>
              </KEYWORD>

:kword:`POLArization`
  Define the direction of the polarization of the incident light, see :kword:`DIREction`.
  The keyword is followed by three real numbers specifying the components of a vector (not necessarily normalized),
  the polarizarion direction is defined by orthogonalizing this vector with each vector specified in :kword:`DIREction`.
  Currently, this keyword only works with the oscillator strengths computed with the :kword:`TINTensities` keyword.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="POLARIZATION" APPEAR="Direction of polarization" KIND="REALS" SIZE="3" REQUIRE="DIRECTION,TINT" LEVEL="ADVANCED">
              %%Keyword: POLArization <advanced>
              <HELP>
              Define the direction of the polarization of the incident light, see DIREction.
              The keyword is followed by three real numbers specifying the components of a vector (not necessarily normalized),
              the polarizarion direction is defined by orthogonalizing this vector with each vector specified in DIREction.
              Currently, this keyword only works with the oscillator strengths computed with the TINTensities keyword.
              </HELP>
              </KEYWORD>

:kword:`RFPErt`
  :program:`RASSI` will read from :file:`RUNOLD` (if not present defaults to :file:`RUNFILE`) a response field contribution
  and add it to the Fock matrix.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="RFPE" APPEAR="Response field" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Rfpe <basic>
              <HELP>
              RASSI will read from RUNOLD (if not present defaults to RUNFILE) a response field contribution
              and add it to the Fock matrix.
              </HELP>
              </KEYWORD>

:kword:`HCOM`
  The spin-free Hamiltonian is computed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="HCOMPUTE" APPEAR="Computed Hamiltonian" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: HCom <basic>
              <HELP>
              The spin-free Hamiltonian is computed.
              </HELP>
              </KEYWORD>

:kword:`HEXT`
  It is read from the following few lines, as a triangular matrix: One element
  of the first row, two from the next, etc., as list-directed input of reals.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="HEXT" APPEAR="External Hamiltonian" KIND="UNKNOWN" LEVEL="ADVANCED">
              %%Keyword: HExt <advanced>
              <HELP>
              The spin-free Hamiltonian is read from a file instead of being computed.
              </HELP>
              It is read from the following entries, as a triangular matrix: One element
              of the first row, two from the next, etc., as list-directed input of reals.
              </KEYWORD>

:kword:`HEFF`
  A spin-free effective Hamiltonian is read from :file:`JOBIPH` instead of being computed.
  It must have been computed by an earlier program. Presently, this is done by
  a multi-state calculation using :program:`CASPT2`. In the future, other programs may add
  dynamic correlation estimates in a similar way. This keyword is not needed if the input
  file is in HDF5 format.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="HEFF" APPEAR="Effective Hamiltonian" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: HEff <advanced>
              <HELP>
              A spin-free effective Hamiltonian is read from JOBIPH instead of being computed.
              It must have been computed by an earlier program. Presently, this is done by
              a multi-state calculation using CASPT2.
              </HELP>
              </KEYWORD>

:kword:`EJOB`
  The spin-free effective Hamiltonian's diagonal is filled with energies
  read from a :file:`JOBIPH` or :file:`JOBMIX` file. If an effective Hamiltonian
  is read (using :kword:`HEFF` or reading from an HDF5 file), the diagonal
  elements are taken from the stored Hamiltonian;
  this can be useful for using the SS-CASPT2 energies from a MS-CASTP2 calculation.
  The off-diagonal elements are approximated as :math:`H_{ij} \approx \frac{1}{2} S_{ij}(H_{ii}+H_{ij})`,
  where :math:`S_{ij}` is the overlap between two states; so if the input states
  are orthogonal, the effective Hamiltonian will be diagonal.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="EJOB" APPEAR="Read energies from file" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: EJob <advanced>
              <HELP>
              The spin-free effective Hamiltonian's diagonal is filled with energies
              read from a JOBIPH or JOBMIX file. Off-diagonal elements are approximated
              from overlaps and diagonal.
              </HELP>
              </KEYWORD>

:kword:`TOFIle`
  Signals that a set of files with data from :program:`Rassi` should be
  created. This keyword is necessary if :program:`QmStat` is to be run
  afterwards.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TOFILE" APPEAR="Data to file" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: TOfile <basic>
              <HELP>
              Signals that a set of files with data from Rassi should be
              created. This keyword is necessary if QmStat is to be run
              afterwards.
              </HELP>
              </KEYWORD>

:kword:`XVIN`
  Demand for printing expectation values of all selected one-electron
  properties, for the input RASSCF wave functions.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="XVIN" APPEAR="input expectation values" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XVIN <basic>
              <HELP>
              Demand printing expectation values of all selected one-electron
              properties, for the input RASSCF wave functions.
              </HELP>
              </KEYWORD>

:kword:`XVES`
  Demand for printing expectation values of all selected one-electron
  properties, for the spin-free eigenstates.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="XVES" APPEAR="spin-free expectation values" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XVES <basic>
              <HELP>
              Demand printing expectation values of all selected one-electron
              properties, for the spin-free eigenstates.
              </HELP>
              </KEYWORD>

:kword:`XVSO`
  Demand for printing expectation values of all selected one-electron
  properties, for the spin--orbit states.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="XVSO" APPEAR="spin-orbit expectation values" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XVSO <basic>
              <HELP>
              Demand printing expectation values of all selected one-electron
              properties, for the spin-orbit states.
              </HELP>
              </KEYWORD>

:kword:`EPRG`
  This computes the g matrix and principal g values for the
  states lying within the energy range supplied on the next line.
  A value of 0.0D0 or negative will select only the ground state,
  a value E will select all states within energy E of the ground state.
  The states should be ordered by increasing energy in the input.
  The angular momentum and spin--orbit coupling matrix elements
  need to be available (use keywords :kword:`SPIN` and :kword:`PROP`).
  For a more detailed description see ref :cite:`EPRG:2008`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="EPRG" APPEAR="EPR g Matrix" KIND="REAL" LEVEL="ADVANCED" REQUIRE="SPIN">
              %%Keyword: EPRg <advanced>
              <HELP>
              This computes the g matrix and principal g values for the
              states lying within the energy range supplied on the next line.
              A value of 0.0D0 or negative will select only the ground state,
              a value E will select all states within energy E of the ground state.
              The states should be ordered by increasing energy in the input.
              The angular momentum and spin-orbit coupling matrix elements
              need to be available (use keywords SPIN and PROP).
              </HELP>
              </KEYWORD>

:kword:`MAGN`
  This computes the magnetic moment and magnetic susceptibility.
  On the next two lines you have to provide the magnetic field and
  temperature data. On the first line put the number of magnetic
  field steps, the starting field (in tesla), size of the steps (in tesla),
  and an angular resolution for sampling points in case of powder magnetization
  (for a value of 0.0d0 the powder magnetization is deactivated).
  The second line reads the number of temperature steps, the starting
  temperature (K), and the size of the temperature steps (K).
  The angular momentum and spin--orbit coupling matrix elements
  need to be available (use keywords :kword:`SPIN` and :kword:`PROP`).
  For a more detailed description see ref :cite:`MAGN:2009`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="MAGN" APPEAR="Magnetism" KIND="REAL" LEVEL="ADVANCED" REQUIRE="SPIN">
              %%Keyword: Magnetic properties <advanced>
              <HELP>
              This computes the magnetic moment and magnetic susceptibility.
              On the next two lines you have to provide the magnetic field and
              temperature data. On the first line put the number of magnetic
              field steps, the starting field (in tesla), size of the steps (in tesla),
              and an angular resolution for sampling points in case of powder magnetization
              (for a value of 0.0d0 the powder magnetization is deactivated).
              The second line reads the number of temperature steps, the starting
              temperature (K), and the size of the temperature steps (K).
              The angular momentum and spin-orbit coupling matrix elements
              need to be available (use keywords SPIN and PROP).
              For a more detailed description see J. Phys. Chem. A 113 6149.
              </HELP>
              </KEYWORD>

:kword:`HOP`
  Enables a trajectory surface hopping (TSH) algorithm which allow
  non-adiabatic transitions between electronic states during molecular
  dynamics simulation with :program:`DYNAMIX` program. The algorithm
  computes the scalar product of the amplitudes of different
  states in two consecutive steps. If the scalar product
  deviates from the given threshold a transition between the states
  is invoked by changing the root for the gradient computation.
  The current implementation is working only with SA-CASSCF.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="HOP" APPEAR="Trajectory surface hopping algorithm" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Hop <advanced>
              <HELP>
              Allows transitions between electronic states during molecular
              dynamics simulations.
              </HELP>
              </KEYWORD>

:kword:`STOVerlaps`
  Computes only the overlaps between the input states.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="STOV" APPEAR="State overlaps" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: StOverlaps <advanced>
              <HELP>
              Computes only the overlaps between the input states.
              </HELP>
              </KEYWORD>

:kword:`TRACk`
  Tries to follow a particular root during an optimization.
  Needs two :file:`JOBIPH` files (see :kword:`NrOfJobIphs`) with the same
  number of roots. The first file corresponds to the current iteration,
  the second file is the one from the previous iteration (taken as a reference).
  With this keyword :program:`RASSI` selects the root from the first :file:`JOBIPH`
  with highest overlap with the root that was selected in the previous
  iteration. It also needs :kword:`MDRlxRoot`, rather than :kword:`RlxRoot`,
  to be specified in :program:`RASSCF`.
  No other calculations are done by :program:`RASSI` when :kword:`Track`
  is specified.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TRACK" APPEAR="Track root" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Track <advanced>
              <HELP>
              Tries to follow a particular root during an optimization.
              </HELP>
              </KEYWORD>

:kword:`DQVD`
  Perfoms DQΦ diabatization :cite:`Hoyer:2014fk` by using properties that are computed with :program:`RASSI`.
  Seven properties must be computed with RASSI in order for this keyword to work
  (:math:`x`, :math:`y`, :math:`z`, :math:`xx`, :math:`yy`, :math:`zz`, :math:`1/r`), they will be automatically selected with the default input
  if the corresponding integrals are available (see keywords :kword:`MULT` and :kword:`EPOT` in :program:`GATEWAY`).
  At present, this keyword also requires :kword:`ALPHa` and :kword:`BETA`, where
  :kword:`ALPHa` is the parameter in front of :math:`rr` and :kword:`BETA` is the parameter
  in front of :math:`1/r`. When :kword:`ALPHa` and :kword:`BETA` are equal to zero, this
  method reduces to Boys localized diabatization :cite:`Subotnik:2008fk`.
  At present, this method only works for one choice of origin for each quantity.

  .. See Test/input/test393.input for an example.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DQVD" APPEAR="DQV diabatization" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: DQVD <advanced>
              <HELP>
              Diabatizes by using dipole, quadrupole, and/or electrostatic potential.
              </HELP>
              </KEYWORD>

:kword:`ALPHa`
  :kword:`ALPHa` is the prefactor for the quadrupole term in DQΦ diabatization. This
  keyword must be used in conjunction with :kword:`DQVD` and :kword:`BETA`. You must
  specify a real number (e.g. :math:`\alpha = 1.0` not :math:`\alpha = 1`).

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ALPHA" APPEAR="Alpha parameter" KIND="REAL" LEVEL="ADVANCED" REQUIRE="DQVD">
              %%Keyword: Alpha <advanced>
              <HELP>
              Alpha parameter in front of the quadrupole term for DQΦ diabatization.
              </HELP>
              </KEYWORD>

:kword:`BETA`
  :kword:`BETA` is the prefactor for the electrostatic potential term in DQΦ diabatization. This
  keyword must be used in conjunction with :kword:`DQVD` and :kword:`ALPHa`. You must
  specify a real number (e.g. :math:`\beta = 1.0` not :math:`\beta = 1`).

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="BETA" APPEAR="Beta parameter" KIND="REAL" LEVEL="ADVANCED" REQUIRE="DQVD">
              %%Keyword: Beta <advanced>
              <HELP>
              Beta parameter in front of the electrostatic potential term for DQΦ diabatization.
              </HELP>
              </KEYWORD>

:kword:`TRDI`
  Prints out the components and the module of the transition dipole
  vector. Only vectors with sizes large than 1.0D-4 a.u. are printed.
  See also the :kword:`TDMN` keyword.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TRDI" APPEAR="Transition dipole" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TRDI <advanced>
              <HELP>
              Prints out the components and the size of the transition dipole
              vector. Only vectors with sizes large than 1.0D-4 a.u. are printed.
              See also the TDMN keyword.
              </HELP>
              </KEYWORD>

:kword:`TRDC`
  Prints out COMPLEX valued components of the transition dipole vector
  for spin-orbit calculations,
  otherwise functionally equivalent to :kword:`TRDI` and :kword:`TDMN`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TRDC" APPEAR="Transition dipole" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TRDC <advanced>
              <HELP>
              Prints out COMPLEX valued components of the transition dipole vector for spin-orbit calculations,
              otherwise functionally equivalent to TRDI TDMN.
              </HELP>
              </KEYWORD>

:kword:`TDMN`
  Prints out the components and the module of the transition dipole
  vector. On the next line, the minimum size, in a.u., for the dipole
  vector to be printed must be given.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TDMN" APPEAR="Transition dipole threshold" KIND="REAL" LEVEL="ADVANCED" REQUIRE="TRDI">
              %%Keyword: TDMN <advanced>
              <HELP>
              Prints out the components and the module of the transition dipole
              vector. On the next line, the minimum size, in a.u., for the dipole
              vector to be printed must be given.
              </HELP>
              </KEYWORD>

:kword:`TRD1`
  Prints the 1-electron (transition) densities to ASCII files and to
  the HDF5 file :file:`rassi.h5`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TRD1" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TRD1 <advanced>
              <HELP>
              Prints the 1-electron (transition) densities to ASCII files and to
              the HDF5 file rassi.h5.
              </HELP>
              </KEYWORD>

:kword:`TRD2`
  Prints the 1-/2-electron (transition) densities to ASCII files.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="TRD2" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TRD2 <advanced>
              <HELP>
              Prints the 1-/2-electron (transition) densities to ASCII files.
              </HELP>
              </KEYWORD>

:kword:`DYSOn`
  Enables calculation of Dyson amplitudes (an approximation of photo-electron intensities) between states that differ by exactly one in their number of electrons.

  Calculations are performed for spin-free states, and for spin-orbit coupled states if the keyword :kword:`SPINorbit` has also been specified. Note that spin-orbit coupled amplitudes are per default obtained from an approximation where a transformation is applied directly to the spin-free amplitudes rather than the Dyson orbitals, which may severly impact the accuracy. For a complete calculation also for spin-orbit states see the :kword:`DYSExport` keyword.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DYSON" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: DYSON <advanced>
              <HELP>
              Enables calculation of Dyson amplitudes (an approximation of photo-electron intensities) between states that differ by exactly one in their number of electrons.
              </HELP>
              </KEYWORD>

:kword:`DYSExport`
  Requires the :kword:`DYSOn` keyword and enables exportation of Dyson orbitals (from which Dyson amplitudes are obtained). The next line specifies the number (starting from the first) of spin-free and spin-orbit states (two numbers, both mandatory) for which the exportation will be done. Note that the ordering of spin-free states depends on the ordering of JOBfiles, whereas spin-orbit states are always energy ordered.

  Dyson amplitudes for the spin-orbit states are here correctly obtained from a transformation of the Dyson orbitals (as opposed to the amplitudes, see :kword:`DYSOn` keywpord), but only for the specified number of initial states. Note that this calculation may be time consuming, i.e. the number of initial states should be limited.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="DYSEXPORT" KIND="INTS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: DYSEXPORT <advanced>
              <HELP>
              Requires the DYSOn keyword and enables exportation of Dyson orbitals (from which Dyson amplitudes are obtained). The next line specifies the number (starting from the first) of spin-free and spin-orbit states (two numbers, both mandatory) for which the exportation will be done. Note that the ordering of spin-free states depends on the ordering of JOBfiles, whereas spin-orbit states are always energy ordered.
              </HELP>
              </KEYWORD>

:kword:`RHODyn`
  Required to run :program:`RHODYN` program. Enable saving pure spin--orbit coupling Hamiltonian and SO Dyson amplitudes (not squared!) to HDF5 file of :program:`RASSI`.
  Keywords :kword:`SPINorbit`, :kword:`MESO`, :kword:`XVES`, :kword:`XVSO`, :kword:`DYSOn` are required to print corresponding properties.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="RHOD" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: RHODyn <advanced>
              <HELP>
              Enables saving V_SOC and Dyson amplitudes to HDF5.
              </HELP>
              </KEYWORD>

:kword:`NTOCalc`
  Enables natural transition orbital (NTO) calculation of two states from two JobIph files (which can be identical to each other).
  The NTO calculations can be performed for states with different spatial symmetries.
  To perform an NTO calculation, two JobIph files, which by convention are named :file:`JOB001` and :file:`JOB002`, are needed. Since NTO calculations are performed usually between the ground state and an excited state, :file:`JOB001` is used to provide the information for the ground state, and :file:`JOB002` is used to provide the information for excited states. This way of storing information was chosen so that NTO calculations can be performed either for states with the same symmetry or states with different symmetries, but in the former case, if two states are obtained in a single SA-CASSCF or SA-RASSCF calculation, one may make a copy of the JobIph file to get the second JobIph file. The two states are specified in the keyword :kword:`NROF` to tell the program for which two states the NTO calculation is to be performed.
  The NTO files are named as :file:`$Project.NTOrb.I_J.Spin.NTOType`, which has the same format as :file:`.ScfOrb` or :file:`.RasOrb`, where :file:`Spin` is `a` for alpha NTOs and `b` for beta NTOs, and where :file:`I` and :file:`J` are the RASSI states between which the NTOs are calculated, and where :file:`NTOType` is `PART` for particle NTOs and `HOLE` for hole NTOs. In addition, Molden files for the orbitals named :file:`$Project.nto.molden.I_J.Spin.NTOType` are also generated.
  One may search for ``Nr of states`` in the RASSI part of the output and the three lines after this information tell the correspondence of the RASSI states (in the line starting with ``State:``) with the actual states (in the line starting with ``Root nr:``) in each JobIph file (in the line starting with ``JobIph:``). If the states for which the NTO calculation is performed are singlets, only the alpha NTOs are printed out.
  For more information and examples of this method, please refer to the Minnesota OpenMolcas webpage\ [#fn1]_.

  .. [#fn1] https://comp.chem.umn.edu/openmolcas/

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="NTOC" APPEAR="Natural transition orbitals" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NTOC <advanced>
              <HELP>
              Enables natural transition orbital calculation from two JobIph files.
              </HELP>
              </KEYWORD>

:kword:`SONT`
  This computes the spin--orbit natural transition orbitals (SO-NTOs) for two spin--orbit coupled states, and it also
  performs the transition dipole moment (TDM) partitioning study based on the obtained SO-NTOs. It starts by an integer number
  specifying the number of requested SO-NTO pairs, followed by the same number of lines. Each line contains two integers
  for the two spin--orbit (SO) coupled states. An input example has been shown below.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SONT" APPEAR="Spin-orbit natural transition orbitals" KIND="INTS_COMPUTED" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: SONT <advanced>
              <HELP>
              This computes the spin--orbit natural transition orbitals (SO-NTOs) for two spin--orbit coupled states, and it also
              performs the transition dipole moment (TDM) partitioning study based on the obtained SO-NTOs.
              </HELP>
              </KEYWORD>

:kword:`ARGU`
  This minimizes the imaginary component of the calculated SO-NTOs.
  The keyword :kword:`SONT` is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ARGU" APPEAR="Argument Phi" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="SONT">
              %%Keyword: ARGU <advanced>
              <HELP>
              This minimizes the imaginary component of the calculated SO-NTOs. The SO-NTOs are required (use keyword SONT).
              </HELP>
              </KEYWORD>

:kword:`EPRA`
  This computes the hyperfine tensor matrix and the principal magnetic axes values for the ground
  spin--orbit state. The hyperfine and spin--orbit coupling matrix elements are required upon calculation
  (use keywords :kword:`SPIN` and :kword:`PROP`). For the hyperfine matrix elements, either the spin-dependent (ASD)
  or the paramagnetic spin orbital (PSOP) part is needed, while in most cases both are recommended for the same atom.
  See reference for details :cite:`Feng_JChemTheoryComput_Electron_2021`.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="EPRA" APPEAR="EPR hyperfine Matrix" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="SPIN">
              %%Keyword: EPRa <advanced>
              <HELP>
              This computes the hyperfine tensor matrix and the principal magnetic axes values for the ground
              spin-orbit state. The hyperfine and spin-orbit coupling matrix elements are required upon calculation
              (use keywords SPIN and PROP). For the hyperfine matrix elements, either the spin-dependent (ASD)
              or the paramagnetic spin orbital (PSOP) part is needed, while in most cases both are recommended 
              for the same atom.
              </HELP>
              </KEYWORD>

:kword:`AFCC`
  This computes the Fermi contact contribution of the total hyperfine coupling matrix.
  The keyword :kword:`EPRA` is needed. The spin-dependent (ASD) part of the hyperfine matrix elements is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="AFCC" APPEAR="Hyperfine Fermi contact" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="EPRA">
              %%Keyword: AFCC <advanced>
              <HELP>
              This computes the Fermi contact contribution of the total hyperfine coupling matrix.
              The keyword EPRA is needed. The spin-dependent (ASD) part of the hyperfine matrix
              elements is needed.
              </HELP>
              </KEYWORD>

:kword:`ASDC`
  This computes the spin-dipolar contribution of the total hyperfine coupling matrix.
  The keyword :kword:`EPRA` is needed. The spin-dependent (ASD) part of the hyperfine matrix elements is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ASDC" APPEAR="Hyperfine spin dipole" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="EPRA">
              %%Keyword: ASDC <advanced>
              <HELP>
              This computes the spin-dipolar contribution of the total hyperfine coupling matrix.
              The keyword EPRA is needed. The spin-dependent (ASD) part of the hyperfine matrix
              elements is needed.
              </HELP>
              </KEYWORD>

:kword:`FCSD`
  This computes the spin-dependent contribution of the total hyperfine coupling matrix.
  The keyword :kword:`EPRA` is needed. The spin-dependent (ASD) part of the hyperfine matrix elements is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="FCSD" APPEAR="Hyperfine spin dependent" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="EPRA">
              %%Keyword: FCSD <advanced>
              <HELP>
              This computes the spin-dependent contribution of the total hyperfine coupling matrix.
              The keyword EPRA is needed. The spin-dependent (ASD) part of the hyperfine matrix
              elements is needed.
              </HELP>
              </KEYWORD>

:kword:`APSO`
  This computes the paramagnetic spin orbital contribution of the total hyperfine coupling matrix.
  The keyword :`EPRA` is needed. The paramagnetic spin orbital (PSOP) part of the hyperfine matrix
  elements is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="APSO" APPEAR="Hyperfine paramagnetic" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="EPRA">
              %%Keyword: APSO <advanced>
              <HELP>
              This computes the paramagnetic spin orbital contribution of the total hyperfine coupling matrix.
              The keyword EPRA is needed. The paramagnetic spin orbital (PSOP) part of the hyperfine matrix
              elements is needed.
              </HELP>
              </KEYWORD>

:kword:`ATSA`
  This keyword activates the pseudospin approach to compute the same hyperfine constants as :kword:`EPRA`.
  For Kramers pair ground states this keyword is optional, otherwise (non-Kramers pair ground state) it is needed.
  See reference for details :cite:`Feng_JChemTheoryComput_Electron_2021`.
  The keyword :kword:`EPRA` is needed.

  .. xmldoc:: <KEYWORD MODULE="RASSI" NAME="ATSA" APPEAR="Hyperfine A-Tensor" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="EPRA">
              %%Keyword: ATSA <advanced>
              <HELP>
              This keyword activates the pseudospin approach to compute the same hyperfine constants as EPRA.
              For Kramers pair ground states this keyword is optional, otherwise (non-Kramers pair ground state) it is needed.
              The keyword EPRA is needed.
              </HELP>
              </KEYWORD>

Input example
.............

::

  >>COPY  "Jobiph file 1" JOB001
  >>COPY  "Jobiph file 2" JOB002
  >>COPY  "Jobiph file 3" JOB003

  &RASSI
  NR OF JOBIPHS= 3 4 2 2    --- 3 JOBIPHs. Nr of states from each.
  1 2 3 4; 3 4; 3 4         --- Which roots from each JOBIPH.
  CIPR; THRS= 0.02
  Properties= 4; 'MltPl  1'  1   'MltPl  1'  3    'Velocity'  1 'Velocity'  3
  * This input will compute eigenstates in the space
  * spanned by the 8 input functions. Assume only the first
  * 4 are of interest, and we want natural orbitals out
  NATO= 4

An NTO input example using the JobIph file from a state-averaged calculation is as follows: ::

  >>COPY  "Jobiph file 1" JOB001
  >>COPY  "Jobiph file 2" JOB002

  &RASSI
  NTOC
  Nr of JobIphs=2 1 1
  1; 2
  *This NTO calculation is performed for the ground state and the first
  *excited state of the previous calculation done in the &RASSCF module.

An SO-NTO input example from three singlets and two triplets: ::

  >>COPY  $Project.JobIph.s0s1s2 JOB001
  >>COPY  $Project.JobIph.t1t2 JOB002

  &RASSI
  Nr of JobIphs
  2 3 2
  1 2 3
  1 2
  SPINorbit
  ARGU *This minimizes the imaginary component of SO-NTOs
  SONT
  3
  1 2
  1 3
  2 3
  *Three pairs of SO-NTOs are requested, between SO state 1 and 2,
  *SO state 1 and 3, and SO state 2 and 3.
  *Note that the states are SO coupled states.

An illustrative hyperfine calculation input for a diatomic molecule: ::

  >>COPY "Jobiph file 1" JOB001

  &RASSI
  Nr of JobIphs
  1 4
  1 2 3 4
  SPIN
  EPRA
  AFCC
  ASDC
  FCSD
  APSO
  ATSA
  PROPerties
  18
  'ASD    1' 1
  'ASD    1' 2
  'ASD    1' 3
  'ASD    1' 4
  'ASD    1' 5
  'ASD    1' 6
  'ASD    2' 1
  'ASD    2' 2
  'ASD    2' 3
  'ASD    2' 4
  'ASD    2' 5
  'ASD    2' 6
  'PSOP   1' 1
  'PSOP   1' 2
  'PSOP   1' 3
  'PSOP   2' 1
  'PSOP   2' 2
  'PSOP   2' 3
  * Note that the strings following PROP have to be of sizes of 8, each 
  * followed by an integer number for the property component. 
  * The last digit of the string is the atom number.
  * Note that there are 6 ASD and 3 PSOP components for each atom, respectively.
  * One has to include all 6 of ASD components to obtain principle
  * spin-dependent hyperfine contributions, and one has to include all 3 of PSOP
  * components to obtain principle paramagnetic spin orbital contributions.

It is also possible to calculate only the non-relativistic part of the spin--dependent hyperfine contributions: ::

  &RASSI
  Nr of JobIphs
  1 4
  1 2 3 4
  SPIN
  EPRA
  AFCC
  ASDC
  FCSD
  APSO
  ATSA
  PROPerties
  12
  'ASDO   1' 1
  'ASDO   1' 2
  'ASDO   1' 3
  'ASDO   1' 4
  'ASDO   1' 5
  'ASDO   1' 6
  'ASDO   2' 1
  'ASDO   2' 2
  'ASDO   2' 3
  'ASDO   2' 4
  'ASDO   2' 5
  'ASDO   2' 6
  * Note that 'ASD' is now 'ASDO' for the non-relativistic integrals.


.. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SONORB" KIND="INTS_COMPUTED" SIZE="1" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="RASSI" NAME="SODIAG" KIND="INTS_COMPUTED" SIZE="1" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="RASSI" NAME="FILE" KIND="STRINGS_COMPUTED" SIZE="1" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; Numerical_Gradient
   single: Numerical_Gradient

.. _UG\:sec\:numerical_gradient:

:program:`numerical_gradient`
=============================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="NUMERICAL_GRADIENT">
            %%Description:
            <HELP>
            The Numerical_Gradient module is a program which numerically evaluates the
            gradient of the energy with respect to nuclear perturbations.
            </HELP>

The :program:`Numerical_Gradient` module is a program which numerically evaluates the gradient
of the energy with respect to nuclear perturbations.

Note that this module is automatically invoked by the :program:`Alaska` module if the wave function
method is MBPT2, CCSDT, CASPT2, MS-CASPT2, or a calculation using the Cholesky decomposition.
The user should normally never request the execution of this module; instead it is advised to use the
:kword:`NUMErical` keyword in Alaska, if it is necessary to force the use of numerical gradients rather than
analytical ones.

The module is parallelized over the displacements, which in case of large jobs gives a linear
speed up compared to a serial execution, although in order to obtain this it is important to
choose the number of nodes such that the number of contributing perturbations is a multiple of
the number of nodes. For a given molecule the number of perturbations equals the number of atoms
times 6 (a perturbation with plus and minus delta for each of the three axes). Symmetry can of
course reduce this number. If the request of execution originates from the :program:`Slapaf`
module further reduction in perturbations is achieved due to the utilization of rotational and
translational invariance.

.. index::
   pair: Dependencies; Numerical_Gradient

.. _UG\:sec\:numerical_gradient_dependencies:

Dependencies
------------

The dependencies of the :program:`Numerical_Gradient` module is the union
of the dependencies of the :program:`SEWARD`, :program:`SCF`, :program:`RASSCF`,
:program:`MBPT2`, :program:`MOTRA`, :program:`CCSDT`, and
:program:`CASPT2` modules.

.. index::
   pair: Files; Numerical_Gradient

.. _UG\:sec\:numerical_gradient_files:

Files
-----

The files of the :program:`Numerical_Gradient` module is the union
of the files of the :program:`SEWARD`, :program:`SCF`, :program:`RASSCF`,
:program:`MBPT2`, :program:`MOTRA`, :program:`CCSDT`, and
:program:`CASPT2` modules.

.. xmldoc:: </MODULE>
.. _UG\:sec\:symmetrize:

:program:`symmetrize`
=====================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: %%Description:
            This module is still undocumented

This module is still undocumented.
.. index::
   single: Program; RASSCF
   single: RASSCF

.. _UG\:sec\:rasscf:

:program:`rasscf`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="RASSCF">
            %%Description:
            <HELP>
            The RASSCF program generates CASSCF, RASSCF, GASSCF and Stochastic-CASSCF type wave functions.
            It requires the one- and two-electron integral files generated by
            SEWARD, and starting orbitals from either a previous RASSCF
            calculation or from any of the other wave function generating programs,
            or from the GUESSORB facility.
            The RASSCF module can be used also for Multiconfiguration
            Pair-Density Functional Theory (MC-PDFT) calculations.
            The resulting orbitals can be visualized, e.g. by LUSCUS.
            </HELP>

The :program:`RASSCF` program in |molcas| performs
multiconfigurational SCF calculations using the Complete Active Space (CAS) :cite:`caspek1,Roos:87`, Restricted Active
Space (RAS) :cite:`raspek` or the Generalized Active Space (GAS) :cite:`gas2011` SCF construction of the wave function.

Within the :program:`RASSCF` program in |molcas| Stochastic-CASSCF calculations can be performed :cite:`limanni2016`.
The Stochastic-CASSCF method allows for CASSCF calculations with a large active space selection (calculations with about
40 electrons and 40 orbitals have been reported) :cite:`limanni2016,limanni2018,limanni2019`.

The RASSCF method is based on a partitioning of the occupied molecular
orbitals into the following groups:

* **Inactive orbitals:** Orbitals that are doubly occupied in all
  configurations.

* **Active orbitals:** These orbitals are subdivided into three separate
  groups:

  * **RAS1 orbitals:** Orbitals that are doubly occupied except for
    a maximum number of holes allowed in this orbital subspace.

  * **RAS2 orbitals:** In these orbitals all possible occupations are
    allowed (former Complete Active Space orbitals).

  * **RAS3 orbitals:** Orbitals that are unoccupied except for
    a maximum number of electrons allowed in this subspace.

CASSCF (or Stochastic-CASSCF) calculations can be performed with the program, by allowing
orbitals only in the RAS2 space. For building more general GASSCF wave functions read the dedicated section below.

A single reference SDCI wave function is obtained by allowing a maximum of 2 holes in RAS1 and a maximum of
2 electrons in RAS3, while RAS2 is empty (the extension to SDT- and SDTQ-CI is
obvious). Multireference CI wave functions can be constructed by adding orbitals also in RAS2.

The :program:`RASSCF` program is based on the split GUGA formalism.
However, it uses determinant based algorithms to solve the configuration
interaction problem :cite:`rasdet`. To ensure a proper spin function,
the transformation to a determinant basis is only performed in the
innermost loops of the program to evaluate the :math:`\sigma`\-vectors in the
Davidson procedure and to compute the two-body density matrices.
The upper limit to the size of the CASSCF wave function that can be
handled with the present program is about :math:`10^7` CSFs and is,
in general, limited by the dynamic work array available to the
program. The GUGA formalism is available both for CAS, RAS and GAS wave functions.

The orbital optimization in the :program:`RASSCF` program is performed
using the super-CI method. The reader is referred to the
references :cite:`raspek,caspek3` for more details.
A quasi-Newton (QN) update method is used in order to improve
convergence. No explicit CI-orbital coupling is used in the present
version of the program, except for the coupling introduced in the QN
update.

Convergence of the orbital optimization procedure is normally good for
CASSCF type wave functions, but problems can occur in calculations on
excited states, especially when several states are close in energy.
In such applications it is better to optimize the orbitals for the
average energy of several electronic states.
Further, convergence can be slower in some cases when orbitals in RAS1
and RAS3 are included. The program is not optimal for SDCI
calculations with a large number of orbitals in RAS1 and RAS3.
Also for the GASSCF variant a slower convergence might occur.

As with other program modules, please observe that the input is preprocessed
and may therefore differ in some respects to the input file prepared by the
user. In most cases, this does not imply any functional changes as
compared to the user's requests. However, when the input
has some minor mistakes or contradictory requests, it can be modified
when it is felt that the correction is beneficial. Also, see below for
the keyword :kword:`EXPERT`. Without this keyword, the program is
assuming more flexibility to optimize the calculation, e.g. by using
CIRESTART, if the RASSCF module is called during a numerical differentiation,
even if the input requested doing CI calculations from scratch.
Using keyword :kword:`EXPERT`, such automatic modification of the
user's input is no longer done, and the input is obeyed exactly (when
possible).

It is best to provide a set of good input orbitals.
(The program can be started from scratch by using :kword:`CORE`,
but this should be used only if other possibilities fail).
They can either be from some
other type of calculation, for example :program:`SCF`, or generated by
:program:`GUESSORB`, or from a previous
:program:`RASSCF` calculation on the same system. In the first case the
orbitals are normally given in formatted form, file :file:`INPORB`, in the
second case they can also be read from a :program:`RASSCF` input unit
:file:`JOBOLD`.
Input provides both possibilities. Some care has to be taken in choosing the
input orbitals, especially for the weakly occupied ones. Different choices
may lead to convergence to different local minima. One should therefore make
sure that the input orbitals have the correct general structure. A good strategy
is often to start using a smaller basis set (MB or DZ) and once the orbitals
have been defined, increase the basis set and use :program:`EXPBAS` to generate
input orbitals.

When we speak of files like :file:`INPORB` or :file:`JOBIPH`, please note that
these can be regarded as generic names. You may have various files with different
file names available, and when invocating the :program:`RASSCF` program, these
can be linked or copied (See EMIL command LINK and COPY) so that the program
treats them as having the names INPORB or JOBIPH. Alternatively, by the keywords
:kword:`FILEORB` and :kword:`IPHNAME`, you can instruct the program to use
other file names.

There are two kinds of specifications to make for orbitals: One is the coefficient
arrays that describe the molecular orbitals, commonly called "CMO data". The other
kind is the number of inactive, RAS1, etc. orbitals of each symmetry type, which
will be called "orbital specifications". The
program can take either or both kinds of data from :file:`INPORB`, :file:`JOBIPH`
or runfile. The program selects where to fetch such data, based on rules and
input keywords. Avoid using conflicting keywords: the program may sometimes go
ahead and resolve the problem, or it may decide to stop, not to risk wasting
the user's time on a calculation that was not intended. This decision may be
in error.

The orbital specification by keyword input is easy: See keywords :kword:`FROZEN`,
:kword:`INACTIVE`, etc. If any such keyword is used, then all the orbital
specifications are assumed to be by input, and any such input that is lacking
is determined by default rules. These are
that there are no such orbitals, with the exception of
:kword:`DELETED`: If earlier calculations deleted some orbitals for reason of
(near) linear dependence, then these will continue being deleted in subsequent
calculations, and cannot be "undeleted". Another special case occurs if both
:kword:`CHARGE` and :kword:`NACTEL` are given in the input and there is no
symmetry, then the default value of :kword:`INACTIVE` will be automatically
determined.

If no such keyword has been given, but keyword :kword:`LUMORB` is used to instruct
the program to fetch CMO data from :file:`INPORB`, then also the orbitals specs
are taken from :file:`INPORB`, if (as is usually the case) this file contains
so-called **typeindex** information. The :program:`LUSCUS` program may have been
used to graphically view orbital pictures and pick out suitable active orbitals,
etc., producing a file with extension ".GvOrb". When this is used as :file:`INPORB`
file, the selected orbitals will be picked in the correct order.

An :file:`INPORB` file with typeindex can also be used to provide orbital specs while
the CMO data are taken from another source (:file:`JOBOLD`, :file:`RUNFILE`, ...).
This is achieved by :kword:`TYPEINDEX`, and you can look in the manual for this
keyword to see an explanation of how the typeindex is written. (This is usually
done by the program generating the file, but since these are ASCII files, you may
find it expedient to look at, or edit, the typeindex).

In case both keywords, such as :kword:`INACTIVE`, **and** :kword:`LUMORB`, is
given, this is of course the very common case that CMO data are read from :file:`INPORB`
but orbital specs are given by input. This is perhaps the most common usage.
However, when the :file:`INPORB` file is a produced by :program:`GV`, it happens
frequently that also keyword specs are left in the input, since the user knows
that these merely duplicate the specs in :file:`INPORB`. But the latter may also
imply a reordering of the orbitals.
For this reason, when the keyword input merely duplicates the number of
inactive, etc., that is also specified by typeindex, then the typeindex input
overrides, to produce the correct ordering. If they do **not** match precisely,
then the CMO data are read, without reordering, and the keyword input (as usual)
takes precedence.

The CMO data are obtained as follows:
With the following keywords, it is assumed that the user knows what he wants.

* :kword:`CORE`: (A bad choice, but here for completeness). Creates orbitals
  from scratch.
* :kword:`LUMORB` or :kword:`FILEORB`: Try :file:`INPORB`, or fail.
* :kword:`JOBIPH`: Try :file:`JOBOLD`, if not usable, try :file:`JOBIPH`, or fail.

If none of these keywords were used, then the user accepts defaults, namely

* look for RASSCF orbitals on :file:`RUNFILE`
* look for SCF orbitals on :file:`RUNFILE`
* look for GUESSORB orbitals on :file:`RUNFILE`
* If still nothing found, create orbitals from scratch.

As for earlier versions, notice the possibility
to read the orbitals on :file:`JOBIPH`, at a later time, by using
the keywords :kword:`OUTOrbital` and :kword:`ORBOnly`. This results in
editable ASCII files, with names like :file:`Project.RasOrb` (or :file:`Project.RasOrb5`
for the fifth root). Such orbitals will be produced by default for the lowest
roots --- up to the tenth, named now, e.g., :file:`Project.RasOrb.5`. There is a keyword :kword:`MAXORB`
to produce more (or fewer) such files.

The :program:`RASSCF` program has special input options, which will limit the degrees of
freedoms used in the orbital rotations. It is, for example, possible to impose
averaging of the orbital densities in :math:`\pi` symmetries for linear molecules.
Use the keyword :kword:`Average` for this purpose. It is also
possible to prevent specific orbitals from rotating with each other. The
keyword is :kword:`Supsym`. This can be used, for example, when the molecule
has higher symmetry than one can use with the |molcas| system. For example, in
a linear molecule the point group to be used is :math:`C_{2v}` or :math:`D_{2h}`. Both
:math:`\sigma`\- and :math:`\delta`\-orbitals will then appear in irrep 1. If the input
orbitals have been prepared to be adapted to linear symmetry, the
:kword:`Supsym` input can be used to keep this symmetry through the iterations.
The program will do this automatically with the use of the
input keyword :kword:`LINEAR`. Similarly, for single atoms, spherical
symmetry can be enforced by the keyword :kword:`ATOM`.

.. _UG\:sec\:core-hole:

States with a core hole
-----------------------

.. compound::

  For stable calculation of states with a deep hole, e.g. for X-ray transitions, one needs to compute
  a (number of) states with a core hole, and a (number of) states without the core hole, with quite
  different orbitals, and then presumably combine these states in a RASSI calculation. The core-hole
  state(s) cannot be computed in the same calculation as the full-core states, since they will be very highly excited states
  compared to the states without that hole. There is also the problem of preventing orbital optimization
  from filling the core hole. In order to make the calculation in a way that is stable, also across
  calculations with changing geometry, there is a special input to :program:`RASSCF`.
  The option :kword:`CRPR` stands for "core projection", and is followed by two numbers, e.g. as ::

      CRPR
        1   33.0

  which has the effect of selecting one orbital, in this case orbital nr. 1, from the starting orbitals.
  This orbital should be in symmetry 1, a non-degenerate orbital, doubly occupied in the state without
  core hole. A projection operator is constructed from the AO basis set, and in the subsequent
  CI calculations, in each new iteration of the orbital optimizer, this operator is multiplied with
  a shift, in this case 33.0 a.u., and added to the Hamiltonian. Regardless of the changing
  orbitals, this operator is defined by the stable AO basis, and any configuration where the core
  orbital is doubly occupied is shifted upwards in energy, above the core hole states, and are
  prevented from playing any role in the calculation. The converged solution(s) are used in a
  subsequent RASSI, for instance (then with the unperturbed Hamiltonian, of course), where it is
  combined with states without core hole, for energies and transition properties.

The perturbation on the core hole states by the projection shift is small, provided that the
basis set is able to to include the core relaxation effect, and the subsequent RASSI is
helpful in correcting for any effects of the perturbation since it will anyway compute
eigenstates which are non-interacting and orthogonal by state mixing.

.. _UG\:sec\:StochasticCAS:

Stochastic-CASSCF method
------------------------

.. warning::

   This program requires an external package to run

The Stochastic-CASSCF :cite:`limanni2016` has been developed since 2015 by Li Manni and Alavi,
initially into a locally modified version of |molcas| and now available in |openmolcas|.
The method retains the simplicity of CASSCF, while circuventing the the exponential scaling of CAS wave functions.
This is obtained by replacing the Davidson diagonalization technique, in its direct-CI implementation (default in |molcas|),
with the full-CI quantum Monte-Carlo (FCIQMC) algorithm :cite:`Alavi2009`, whilst the Super-CI method is used
for the orbital optimization.

The method is compatible with density fitting techniques available within |openmolcas|.
The method is also compatible with subsequent MC-PDFT method to recover correlation outside the active space.

.. _UG\:sec\:StochCAS_dependencies:

Dependencies
............

In addition to the normal :program:`RASSCF` dependencies, the Stochastic-CASSCF requires that the :program:`NECI` program is installed externally
(the :program:`NECI` program can also be embedded into |openmolcas|. This form of installation is however not fully developed and not suggested).
For the :program:`NECI` program a parallel installation (using MPI) is assumed as well as the use of hdf5 libraries to store and process
the walker population. Using the FCIQMC algorithm the user will produce one- and two-body density matrix files (:file:`ONERDM`, :file:`TwoRDM_XXXX`), that are required for the subsequent orbital optimization step.

.. _UG\:sec\:StochCAS_InpOutFiles:

Input/Output Files
..................

Two files are produced by the :program:`RASSCF` module at each MCSCF macro-iteration when the Stochastic-CASSCF method is used (in addition to the one produced by default by :program:`RASSCF`). These files are:

.. class:: filelist

:file:`FCIINP`
  The :file:`$Project.FciInp` (or :file:`FCIINP`) file contains input keywords for the NECI code.
  These keywords need to be adjusted depending on the chemical system under investigation for an optimal FCIQMC dynamics.

:file:`FCIDMP`
  The :file:`$Project.FciDmp` (or :file:`FCIDMP`), also know as FCIDUMP, contains the MO integrals in the active space.
  It is a ASCII formatted file. Indices are sorted by symmetry (Irrep).

The Input and the FCIDUMP files are the only files necessary to :program:`NECI` to run a FCIQMC simulation from scratch.
For questions about the FCIQMC dynamics we invite to contact its developers.

As accurate density matrices are necessary for a successful Stochastic-CASSCF calculation,
users are invited to use the :file:`dneci.x` binary (this will run the FCIQMC dynamic in replica mode) :cite:`Overy2014`.
The FCIQMC dymanics can be followed in the :file:`fciqmc.out` output file or in the NECI generated :file:`FCIMCStats` file.
In the :file:`fciqmc.out` there are important pieces of information, such as the list of Slater determinants dominating the FCI wave function and the RDM energy. The latter is passed to |molcas| as shown in the script below.
When a stationary condition is reached and density matrices sampled these are passed to the :file:`RASSCF` program to continue.
This can be achieved by a simple script, such as the following: ::

  cp TwoRDM_aaaa.1 $WorkDir/$Project.TwoRDM_aaaa
  cp TwoRDM_abab.1 $WorkDir/$Project.TwoRDM_abab
  cp TwoRDM_abba.1 $WorkDir/$Project.TwoRDM_abba
  cp TwoRDM_bbbb.1 $WorkDir/$Project.TwoRDM_bbbb
  cp TwoRDM_baba.1 $WorkDir/$Project.TwoRDM_baba
  cp TwoRDM_baab.1 $WorkDir/$Project.TwoRDM_baab
  cp   OneRDM.1    $WorkDir/$Project.OneRDM
  grep 'REDUCED D' fciqmc.out | sed "s/^.*: //" > NEWCYCLE
  mv NEWCYCLE $WorkDir/.

.. class:: filelist

:file:`$Project.TwoRDM_XXXX`
  These files are ASCII NECI generated output files.
  They contain spin-resolved two-body density matrix elements (and one-RDM) and are necessary
  to |molcas| to continue with the Stochastic-CASSSCF calculation.

.. _UG\:sec\:StochCAS_Keywords:

Input keywords
..............

This section describes the input to the Stochastic-CASSCF method in the |openmolcas| program.
Two input keywords are strictly required in the :program:`RASSCF` module for activating the Stochastic-CASSCF:

.. class:: keywordlist

:kword:`NECI`
  This keyword is needed to enable the Stochastic-CASSCF method.

  Additional keywords like ``totalwalkers`` have the same meaning as in NECI
  and are just passed on.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NECI" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="DMRG">
              %%Keyword: NECI <advanced>
              <HELP>
              This keyword is used to enable Stochastic-CASSSCF
              calculations and features related to it (such as produce a FCIDUMP file).
              Additional keywords like "totalwalkers" have the
              same meaning as in NECI and are just passed on.
              </HELP>
              </KEYWORD>

:kword:`EMBD`
  This keyword enables the embedded version of the Stochastic-CASSCF where :program:`NECI` runs as subroutine of |molcas|.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="EMBD" APPEAR="Embedded NECI" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="NECI">
              %%Keyword: EMBD <advanced>
              <HELP>
              This keyword is used jointly to the NECI keyword in the context of the Stochastic-CASSCF method,
              to enable the embedded Stochastic-CASSSCF
              calculations, where NECI runs as subroutine of Molcas.
              </HELP>
              </KEYWORD>

Optional important keywords are:

.. class:: keywordlist

:kword:`DMPO`
  This keyword is used to generate the FCIDUMP file only. The program will deallocate memory and quit in a clean manner.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DMPO" APPEAR="Dump only" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: DMPO <advanced>
              <HELP>
              This keyword is used in the context of the Stochastic-CASSCF method
              to produce a FCIDUMP file in a ASCII format that can be recognized by
              the NECI program and quit in a clean way (no CI or CASSCF calculation will be done).
              </HELP>
              </KEYWORD>

:kword:`DEFD`
  This keyword is used to define an initial Slater determinant as starting guess for the FCIQMC dynamics.
  During the FCIQMC dynamics, if another Slater determinant is more populated (advanced keywords apply) than the guess determinant
  provided, the more populated determinant is used as reference, overwriting the user choice. Possible changes of reference
  determinants can be tracked in the FCIQMC output file. An example of the :kword:`DEFD` keyword follows: ::

    DEFD
      1 2 3 4 5 13 14 17 18 21 22 27 28 29 30 31 32 39 40 41 42 43 51 52 53 54 55 56 63 64 65 66

  It contains a list of the occupied spin-orbitals in the order given by the :file:`INPORB` file (space symmetry sorted).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DEFD" APPEAR="Define determinant" KIND="STRING" LEVEL="ADVANCED" REQUIRE="NECI">
              %%Keyword: DEFD <advanced>
              <HELP>
              This keyword is used in the context of the Stochastic-CASSCF method
              to provide the FCIQMC algorithm with an initial guess for the reference Slater determinant.
              It is followed (new line) by a string of integers representing spin-orbitals in the order
              given in the INPORB file.
              </HELP>
              </KEYWORD>

:kword:`GUGA`
  Use spin eigenfunctions instead of Slater determinants in the basis for the FCIQMC dynamics to target specific
  spin states and perhaps benefit from sparsity in this basis.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="GUGA" APPEAR="GUGA" KIND="STRING" LEVEL="ADVANCED" REQUIRE="NECI">
              %%Keyword: GUGA <advanced>
              <HELP>
              Use spin eigenfunctions instead of Slater determinants in the basis for the FCIQMC dynamics.
              </HELP>
              </KEYWORD>

:kword:`REOR`
  The user can input a permutation by specifying the number of non
  fixed point elements, followed by the order of the non fixed point elements.

  .. compound::

     If the total number of active orbitals is e.g. 6
     the following example of the :kword:`REOR` keyword::

          REOR
            3
            4 5 1

     leads to an order of ``[4 2 3 5 1 6]``.

  .. compound::

     If GAS is used one can specify -1 as flag::

          REOR
            -1

     to follow the order of GAS spaces.
     This means that the orbitals are ordered by GAS space first
     and by symmetry second.
     First all orbitals of GAS1 and within it orbitals of Irrep 1 come first,
     Irrep 2 next...
     Once all orbitals of GAS1 are exhausted we continue with orbitals of GAS2
     and so on.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="REOR" APPEAR="Reordering orbitals" KIND="STRING" LEVEL="ADVANCED" REQUIRE="NECI">
              %%Keyword: REOR <advanced>
              <HELP>
              The user can input a permutation by specifying the number of non
              fixed point elements, followed by the order of the non fixed point elements.
              If the total number of active orbitals is e.g. 6
              the following example of the REOR keyword

                REOR
                  3
                  4 5 1

              leads to an order of [4 2 3 5 1 6].
              </HELP>
              </KEYWORD>

.. _UG\:sec\:StochCAS_InputExample:

Input Example
.............

A minimal input example follows where the use of the Stochastic-CASSCF joinlty with RICD and MC-PDFT is shown: ::

  &GATEWAY
   RICD
   COORD
     coor.xyz
   BASIS
     ANO-RCC-VTZP
   GROUP
     full

  &SEWARD

  &RASSCF
   NECI
    ExNe
   NACTEL
     26 0 0
   INACTIVE
     20 17 17 14 0 0 0 0
   RAS2
     0 0 0 0 7 6 6 5
   SYMMETRY
     1

  >>foreach DFT in (T:PBE, T:BLYP, T:LSDA)

     >>COPY $CurrDir/converged.RasOrb INPORB
     &RASSCF
        LumOrb
        CIONLY
        KSDFT
          ROKS; $DFT
        NECI
          ExNe
        NACTEL
          26 0 0
        INACTIVE
          20 17 17 14 0 0 0 0
        RAS2
          0 0 0 0 7 6 6 5
        SYMMETRY
          1
  >>enddo

.. _UG\:sec\:gasscf:

GASSCF method
-------------

In certain cases it is useful/necessary to enforce restrictions on electronic
excitations within the active space beyond the ones accessible by RASSCF.
These restrictions are meant to remove configurations that contribute only
marginally to the total wave function.
In |molcas| this is obtained by the GASSCF approach :cite:`gas2011`.
GASSCF is a further generalization of the active space concept.
This method, like RASSCF, allows restrictions on the active space,
but they are more flexible than in RASSCF. These restrictions allow GASSCF to be applied to
larger and more complex systems at affordable cost. If the active space is well chosen and the
restrictions are not too severe, MCSCF methods recover most of the static correlation energy,
and part of the dynamic correlation energy. In the GASSCF method, instead
of three active spaces, an in-principle arbitrary number of active spaces (GAS1, GAS2...) may
be chosen by the user. Instead of a maximum number of holes in RAS1 and particles in RAS3,
accumulated minimum and maximum numbers of electrons are specified for GAS1,
GAS1+GAS2, GAS1+GAS2+GAS3, etc. in order to define the desired CI expansion (:numref:`fig:gas`).
All intra-space excitations are allowed (Full-CI in subspaces).
Constraints are imposed by user choice on inter-space excitations.

.. figure:: gas.*
   :name: fig:gas
   :align: center

   Pictorial representation of GAS active space.

When and how to use the GAS approach?
We consider three examples: (1) an organometallic material with separated metal
centers and orbitals not delocalized across the metal centers. One can include
the near degenerate orbitals of each center in its own GAS space.
This implies that one may choose as many GAS spaces as the number of
multiconfigurational centers. (2) Lanthanide or actinide metal compounds where
the :math:`f`-electrons require a MC treatment but they do not participate in bonding
neither mix with :math:`d` orbitals. In this case one can put the :math:`f` orbitals and their
electrons into one or more separated GAS spaces and not allow excitations
from and/or to other GAS spaces. (3) Molecules where each bond and its correlating
anti-bonding orbital could form a separate GAS space as in GVB approach.
Finally, if a wave function with a fixed number of holes in one or more
orbitals is desired, without interference of configurations where those
orbitals are fully occupied the GAS approach is the method of choice instead
of the RAS approach. There is no rigorous scheme to choose a GAS partitioning.
The right GAS strategy is system-specific. This makes the method versatile but
at the same time it is not a black box method.
An input example follows: ::

  &RASSCF
  nActEl
   6 0 0
  FROZen
  0 0 0 0 0 0 0 0
  INACTIVE
  2 0 0 0 2 0 0 0
  GASScf
  3
   1 0 0 0 1 0 0 0
  2 2
   0 1 0 0 0 1 0 0
  4 4
   0 0 1 0 0 0 1 0
  6 6
  DELEted
  0 0 0 0 0 0 0 0

In this example the entire active space counts six active electrons
and six active orbitals. These latter are partitioned in three GAS spaces
according to symmetry consideration and in the spirit of the GVB strategy.
Each subspace has a fixed number of electrons, *two*, and no interspace
excitations are allowed. This input shows clearly the difference
with the RAS approach.
Also for the GASSCF variant a slower convergence might occur.

MC-PDFT method
--------------

The RASSCF module can be used also for Multiconfiguration Pair-Density Functional Theory (MC-PDFT) calculations,
as described in :cite:`limanni2014,limanni2015`. The MC-PDFT method involves two steps:
(i) a CASSCF, RASSCF, or GASSCF wave function calculation to obtain the kinetic energy, classical Coulomb energy,
total electron density, and on-top pair density; (ii) a post-SCF calculation of the remaining energy using an on-top density functional.
In the current implementation, the on-top pair density functional is obtained by "translation" (t) of exchange-correlation functionals.
Three translated functionals are currently available: tPBE, tLSDA and tBLYP.
As multiconfigurational wave functions are used as input quantities, spin and space symmetry are correctly conserved.

.. _UG\:sec\:rasscf_orbitals:

RASSCF output orbitals
----------------------

The :program:`RASSCF` program produces a binary output file called
:file:`JOBIPH`, which can be used in subsequent calculations. Previously, this
was usually a link, pointing to whichever file the user wanted, or by default
to the file :file:`$Project.JobIph` if no such links had been made. This default
can be changed, see keyword :kword:`NewIph` and :kword:`IphName`.
For simplicity, we refer to this as :file:`JOBIPH` in the manual. The job interface,
:file:`JOBIPH`, contains four different sets of MO's and
it is important to know the difference between the sets:

#. **Average orbitals:**
   These are the orbitals produced in the optimization
   procedure. Before performing the final CI wave function they are
   modified as follows: inactive and secondary orbitals are rotated
   (separately) such as to diagonalize an effective Fock operator, and
   they are then ordered after increasing energy. The orbitals in the
   different RAS subspaces are rotated (within each space separately)
   such that the corresponding block of the state-average density matrix becomes
   diagonal. These orbitals are therefore called "pseudo-natural
   orbitals". They become true natural orbitals only for CAS type wave
   functions. These orbitals are not ordered. The corresponding
   "occupation numbers" may therefore appear in the output in arbitrary
   order. The final CI wave function is computed using these orbitals.
   They are also the orbitals found in the printed output.

#. **Natural orbitals:**
   They differ from the above orbitals, in the active
   subspace. The entire first order density matrix has been diagonalized.
   Note that in a RAS calculation, such a rotation does not in general
   leave the RAS CI space invariant. One set of such orbitals is produced
   for each of the wave functions in an average :program:`RASSCF`
   calculation. The main use of these orbitals is in
   the calculation of one-electron properties. They are extracted by default
   (up to ten roots)
   to the working directory from :file:`JOBIPH` and named :file:`$Project.RasOrb.1`,
   :file:`$Project.RasOrb.2`, etc.
   Each set of MO's is stored together with the
   corresponding occupation numbers. The natural orbitals are identical
   to the average orbitals only for a single state CASSCF wave function.

#. **Canonical orbitals:**
   This is a special set of MO's generated for use in the
   :program:`CASPT2` and :program:`CCSDT` programs.
   They are obtained by a specific input option to the
   :program:`RASSCF` program. They are identical to the above
   orbitals in the inactive and secondary subspaces. The active orbitals
   have been obtained by diagonalizing an effective one-electron
   Hamiltonian, a procedure that leaves the CI space invariant only for
   CAS type wave functions.

#. **Spin orbitals:**
   This set of orbitals is generated by diagonalizing the first order
   spin density matrix and can be used to compute spin properties.

#. **Improved virtual orbitals:**
   This refers only to virtual orbitals, when the :kword:`IVO` keyword is employed
   in the input. In this case, the virtual orbitals are those which diagonalize
   the core Hamiltonian. Since the energies of virtual orbitals become thus undefined,
   the obtained :file:`RASORB` and :file:`JOBIPH` files can **not** be used for CASPT2 or MRCI or any correlated
   calculations. The printed virtual orbitals are quite localized and could be used only to
   decide which ones should be included in an (enlarged) active space in a subsequest
   :program:`RASSCF` calculation.

.. _UG\:sec\:rasscf_dependencies:

Dependencies
------------

To start the :program:`RASSCF` module at least the one-electron
and two-electron integrals generated by :program:`SEWARD` have to
be available (exception: See keyword :kword:`ORBONLY`). Moreover, the
:program:`RASSCF` requires a suitable start wave function such as the
orbitals from a RHF-SCF calculation or produced by :program:`GUESSORB`.

For MC-PDFT calculations, it is recommended to use a fine grid via the following input specifications (see the :program:`SEWARD`, :numref:`UG:sec:seward`, for details): ::

  &SEWARD
  grid input
  grid=ultrafine
  end of grid input

CI coefficients are needed to generate one- and two-body density matrices. They are usually pre-optimized vectors passed to the :program:`RASSCF` module via :program:`EMIL` command: ::

  >>> COPY $WorkDir/$Project.JobIph JOBOLD

A pre-optimized CI vector is not compulsory; however, it is recommended to use a pre-optimized CI vector stored in a :file:`JOBIPH` file.
A set of input orbitals is required. They may be stored in :file:`JOBIPH` or in a formatted :file:`INPORB` file.

.. _UG\:sec\:rasscf_files:

Files
-----

.. _UG\:sec\:rasscf_inp_files:

Input files
...........

:program:`RASSCF` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`INPORB`,
:file:`JOBIPH`
(for more information see :numref:`UG:sec:files_list`).

A number of additional files generated by :program:`SEWARD` are also used by the
:program:`RASSCF` program.
The availability of either of the files named :file:`INPORB` and
:file:`JOBOLD` is optional and determined by the input options
LUMORB and JOBIPH, respectively.

.. _UG\:sec\:rasscf_output_files:

Output files
............

.. class:: filelist

:file:`JOBIPH`
  This file is written in binary format and carries the results
  of the wave function optimization such as MO- and CI-coefficients.
  If several consecutive RASSCF calculations are made, the file names will
  be modified by appending "01","02", etc.

:file:`RUNFILE`
  The :file:`RUNFILE` is updated with information from the RASSCF calculation
  such as the first order density and the Fock matrix.

:file:`MD_CAS.x`
  Molden input file for molecular orbital analysis for CI root x.

:file:`RASORB`
  This ASCII file contains molecular orbitals, occupation numbers, and
  orbital indices from a :program:`RASSCF` calculation. The natural orbitals
  of individual states in an average-state calculation are also produced,
  and are named :file:`RASORB.1`, :file:`RASORB.2`, etc.

:file:`MCDENS`
  This ASCII file is generated for MC-PDFT calculations.
  It contains spin densities, total density and on-top pair density values on grid (coordinates in a.u.).

.. _UG\:sec\:rasscf_inp:

Input
-----

This section describes the input to the
:program:`RASSCF` program in the |molcas| program system. The input starts
with the program name ::

  &RASSCF

There are no compulsory keywords, but almost any meaningful calculation
will require some keyword. At the same time, most choices have default
settings, and many are able to take relevant values from earlier
calculations, from available orbital files, etc.

To run an MC-PDFT calculation in the :program:`RASSCF` module, the keywords :kword:`CIONLY`, :kword:`KSDFT`,
:kword:`ROKS` and the functional choice are needed. The currently available functionals are tPBE,
tBLYP and tLSDA. Also: :kword:`LUMORB` is needed if external orbitals are used.
:kword:`JOBIPH` is needed if external orbital stored in :file:`JobIph` files are used.
:kword:`CIRESTART` is needed if a pre-optimized CI vector stored in :file:`JOBIPH` is to be used.

Optional keywords
.................

There is a large number of optional keywords you can specify. They are
used to specify the orbital spaces, the CI wave function etc., but also
more arcane technical details that can modify e.g. the convergence or
precision. The first 4 characters of the keyword are recognized by the
input parser and the rest is ignored. If not otherwise stated the numerical
input that follows a keyword is read in free format.
A list of these keywords is given below:

.. class:: keywordlist

:kword:`TITLe`
  Follows the title for the calculation in a single line

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              Follows the title in a single line
              </HELP>
              </KEYWORD>

:kword:`SYMMetry`
  Specify the selected symmetry type (the irrep) of the wave
  function as a number between 1 and 8 (see SYMMETRY keyword in GATEWAY section). Default is 1, which always
  denote the totally symmetric irrep.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="SPIN/SYMMETRY" KIND="BOX">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SYMMETRY" APPEAR="Symmetry" LEVEL="BASIC" KIND="INT" DEFAULT_VALUE="1" MIN_VALUE="1" MAX_VALUE="8">
              %%Keyword: SYMMetry <basic>
              <HELP>
              Specify symmetry type (irrep) as a number between 1 and 8. Default is 1.
              </HELP>
              </KEYWORD>

:kword:`SPIN`
  The keyword is followed by an integer giving the value of spin
  multiplicity (:math:`2S+1`). Default is 1 (singlet).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SPIN" APPEAR="Spin" LEVEL="BASIC" KIND="INT" DEFAULT_VALUE="1" MIN_VALUE="1">
              %%Keyword: SPIN <basic>
              <HELP>
              The keyword is followed by an integer giving the value of spin
              multiplicity (2S+1). Default is 1 (singlet).
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`CHARge`
  Specify the total charge on the system as an integer. If this keyword is used, the
  :kword:`NACTEL` keyword should not be used, unless the symmetry group is C1 and
  :kword:`INACTIVE` is not used (in this case the number of inactive orbitals will
  be computed from the total charge and active electrons). Default value: 0

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="TOTALCHARGE" KIND="BOX">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CHARGE" LEVEL="BASIC" APPEAR="Charge" KIND="INT" DEFAULT_VALUE="0">
              %%Keyword: CHARge <basic>
              <HELP>
              Specify the total charge of the system as an integer.
              </HELP>
              </KEYWORD>

:kword:`RASScf`
  Specify two numbers: maximum number of holes in RAS1 and the maximum number of electrons
  occupying the RAS3 orbitals
  Default values are: 0,0
  See also keyword :kword:`CHARGE` and :kword:`NACTEL`. The specification using
  :kword:`RASSCF`, and :kword:`CHARGE` if needed, together replace the single keyword
  :kword:`NACTEL`.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RASSCF" LEVEL="BASIC" APPEAR="Allow RAS holes/electrons" KIND="INTS" SIZE="2" EXCLUSIVE="NACTEL" MIN_VALUE="0">
              %%Keyword: RASScf <basic>
              <HELP>
              Specify two numbers: maximum number of RAS1 holes, and maximum number of RAS3 electrons.
              </HELP>
              </KEYWORD>

:kword:`NACTel`
  Requires one or three numbers to follow, specifying

  #. the total number of active electrons
     (all electrons minus twice the number of inactive and frozen orbitals)
  #. the maximum number of holes in RAS1
  #. the maximum number of electrons occupying the RAS3 orbitals

  If only one number is given, the maximum number of holes in RAS1 and of electrons in RAS3 are both set to zero.
  Default values are: x,0,0, where x is the number needed to get a neutral system.
  See also keywords :kword:`CHARGE` and :kword:`RASSCF`, which offer an alternative specification.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NACTEL" LEVEL="BASIC" APPEAR="Active electrons" KIND="INTS" SIZE="3" EXCLUSIVE="RASSCF" MIN_VALUE="0">
              <ALTERNATE KIND="INT" />
              %%Keyword: NACTel <basic>
              <HELP>
              Specify three numbers: total number of active electrons,
              maximum number of RAS1 holes, and maximum number of RAS3 electrons.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`CIROot`
  Specifies the CI root(s) and the dimension of
  the starting CI matrix used in the CI Davidson procedure. This input
  makes it possible to perform orbital optimization for the average
  energy of a number of states. The first line of input gives two or three
  numbers, specifying the number of roots used in the average
  calculation (NROOTS), the dimension of the small CI matrix in
  the Davidson procedure (LROOTS), and possibly a non-zero integer IALL.
  If IALL\ :math:`\ne`\1 or there is no IALL, the second line gives the index of
  the states over which the average is taken (NROOTS numbers,
  IROOT). **Note** that the size of the CI matrix, LROOTS, must be at least as
  large as the highest root, IROOT. If, **and only if**, NROOTS\ :math:`>`\1 a third
  line follows, specifying the weights of the different states in the average
  energy. If IALL=1 has been specified, no more lines are read. A state average
  calculation will be performed over the NROOTS lowest states with equal weights.
  energy. Examples: ::

    CIRoot= 3 5; 2 4 5; 1 1 3

  The average is taken over three states corresponding to roots 2, 4, and
  5 with weights 20%, 20%, and 60%, respectively. The size of the
  Davidson Hamiltonian is 5. Another example is: ::

    CIRoot= 19 19 1

  A state average calculation will be performed over the 19 lowest states each
  with the weight 1/19
  Default values are NROOTS = LROOTS = IROOT = 1 (ground state), which is the same
  as the input: ::

    CIRoot= 1 1; 1

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CIROOT" LEVEL="BASIC" APPEAR="CI root(s)" KIND="CUSTOM" SIZE="3">
              %%Keyword: CIROot <basic>
              <HELP>
              Specifies the CI root(s) and the dimension of the
              starting CI matrix used in the CI Davidson procedure.
              This input makes it possible to perform orbital
              optimization for the average energy of a number of
              states. The first line of input gives two or three
              numbers, specifying the number of roots used in the
              average calculation (NROOTS), the dimension of the
              small CI matrix in the Davidson procedure (LROOTS),
              and possibly a non-zero integer IALL. If IALL.ne.1 or
              there is no IALL, the second line gives the index of
              the states over which the average is taken (NROOTS
              numbers,IROOT). Note, that the size of the CI matrix,
              LROOTS, must be at least as large as the highest root,
              IROOT. If, and only if, NROOTS > 1 a third line follows,
              specifying the weights of the different states in the
              average energy. If IALL=1 has been specified, no more
              lines are read. A state average calculation will be
              performed over the NROOTS lowest states with equal
              weights.
              </HELP>
              </KEYWORD>

:kword:`CISElect`
  This keyword is used to select CI roots by an overlap
  criterion. The input consists of three lines per root
  that is used in the CI diagonalization (3*NROOTS lines in total).
  The first line gives the number of configurations used in the comparison,
  :math:`n_{\text{Ref}}`, up to five.
  The second line gives :math:`n_{\text{Ref}}` reference configuration indices.
  The third line gives estimates of CI coefficients for these CSF's.
  The program will select the roots which have the largest overlap with
  this input.
  Be careful to use a large enough value for LROOTS (see above) to cover
  the roots of interest.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CISELECT" LEVEL="ADVANCED" APPEAR="CI select" KIND="UNKNOWN">
              %%Keyword: CISElect <advanced>
              <HELP>
              This keyword is used to select CI roots by an overlap
              criterion. The input consists of three lines per root
              that is used in the CI diagonalization (3*NROOTS lines in total).
              The first line gives the number of configurations used in the comparison,
              nRef, where nRef at most 5.
              The second line gives nRef reference configuration indices.
              The third line gives estimates of CI coefficients for these CSF's.
              </HELP>
              </KEYWORD>

:kword:`CRPRoject`
  This keyword is followed by two numbers, which define a Hamiltonian shift by a
  projection operator times a scalar number. For choosing these numbers, please
  read the section about core hole states above.
  The shift acts to raise the energy of any configuration where the selected
  orbital is doubly occupied so the lie far enough above the target core hole
  states for the duration of the calculation. The purpose is to obtain RASSCF
  states that are properly optimized, yet with no risk of collapsing the core
  hole, for use in subsequent RASSI calculations.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CRPR" LEVEL="ADVANCED" APPEAR="Core project" KIND="STRING">
              %%Keyword: CRPRoject <advanced>
              <HELP>
              This keyword is followed by two numbers, which define a Hamiltonian shift by a
              projection operator times a scalar number. For choosing these numbers (integer
              and real), please read the section about core hole states in the manual for
              the RASSCF program.
              </HELP>
              </KEYWORD>

:kword:`ATOM`
  This keyword is used to get orbitals with pure spherical
  symmetry for atomic calculations (the radial dependence can vary for different
  irreps though). It causes super-symmetry to be
  switched on (see :kword:`SUPSym` keyword) and generates automatically the
  super-symmetry vector needed. Also, at start and after each iteration,
  it sets to zero any CMO coefficients with the wrong symmetry. Use this keyword
  instead of :kword:`SUPSym` for atoms.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ATOM" APPEAR="Purify spherical" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="LINEAR,SUPSYM">
              %%Keyword: ATOM <advanced>
              <HELP>
              This keyword is used to get orbitals with pure spherical
              symmetry for atoms. Use this instead of SUPSYM for single atoms.
              </HELP>
              </KEYWORD>

:kword:`LINEar`
  This keyword is used to get orbitals with pure rotational
  symmetry for linear molecules. It causes super-symmetry to be
  switched on (see :kword:`SUPSym` keyword) and generates automatically the
  super-symmetry vector needed. Also, at start and after each iteration,
  it sets to zero any CMO coefficients with the wrong symmetry. Use this keyword
  instead of :kword:`SUPSym` for linear molecules.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="LINEAR" APPEAR="Purify linear" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="ATOM,SUPSYM">
              %%Keyword: LINEar <advanced>
              <HELP>
              This keyword is used to get orbitals with pure rotational
              symmetry for linear molecules. Use this instead of SUPSYM for linear molecules.
              </HELP>
              </KEYWORD>

:kword:`RLXRoot`
  .. compound::

    Specifies which root to be relaxed in a geometry optimization of a
    state average wave function. Thus, the keyword has to be combined
    with :kword:`CIRO`.
    In a geometry optimization the following input ::

      CIRoot= 3 5; 2 4 5; 1 1 3
      RLXRoot= 4

    will relax CI root number 4.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RLXROOT" APPEAR="Relaxed root" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: RLXRoot <advanced>
              <HELP>
              Specifies which root to be relaxed in a geometry optimization of a
              state average wave function. Thus, the key word has to be combined
              with CIRO.
              </HELP>
              </KEYWORD>

:kword:`MDRLxroot`
  Selects a root from a state average wave function for gradient computation in
  the first step of a molecular dynamics simulation. The root is specified in
  the same way as in the :kword:`RLXR` keyword. In the following steps the
  trajectory surface hopping can change the root if transitions between the
  states occur. This keyword is mutually exclusive with the :kword:`RLXR` keyword.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="MDRL" APPEAR="Dynamic relaxed root" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MDRLxroot <advanced>
              <HELP>
              Defines the root for gradient computation in the first step of a
              molecular dynamics simulation. It is used like RLXR keyword except
              that its value is determined by the trajectory surface hopping
              algorithm in the following steps.
              </HELP>
              </KEYWORD>

:kword:`EXPErt`
  This keyword forces the program to obey the input. Normally, the program can
  decide to change the input requests, in order to optimize the calculation.
  Using the :kword:`EXPERT` keyword, such changes are disallowed.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="EXPERT" APPEAR="Expert input" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: EXPErt <advanced>
              <HELP>
              This keyword forces the program to obey the input. Normally, the program can
              decide to change the input requests, in order to optimize the calculation.
              Using the EXPERT keyword, such changes are disallowed.
              </HELP>
              </KEYWORD>

:kword:`RFPErt`
  This keyword will add a constant reaction field perturbation to the
  Hamiltonian. The perturbation is read from the :file:`RUNOLD` (if not present defaults to :file:`RUNFILE`) and
  is the latest self-consistent perturbation generated
  by one of the programs :program:`SCF` or :program:`RASSCF`.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="RF" APPEAR="Reaction field" KIND="BOX">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RFPERT" APPEAR="Add reaction field" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: RFPErt <advanced>
              <HELP>
              This keyword will add a constant reaction field perturbation to the
              bare nuclei Hamiltonian. The perturbation is read from the
              RUNOLD (if not present defaults to RUNFILE) and is the latest self consistent perturbation generated
              by one of the programs SCF or RASSCF.
              </HELP>
              </KEYWORD>

:kword:`NONEquilibrium`
  Makes the slow components of the reaction field of another state present in the
  reaction field calculation (so-called non-equilibrium solvation). The slow component
  is always generated and stored on file for equilibrium solvation calculations so that
  it potentially can be used in subsequent non-equilibrium calculations on other states.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NONEQUILIBRIUM" APPEAR="Non-equilibrium reaction field" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NONEquilibrium <advanced>
              <HELP>
              Makes the slow components of the reaction field of another state present in the
              reaction field calculation (so-called non-equilibrium solvation). The slow component
              is always generated and stored on file for equilibrium solvation calculations so that
              it potentially can be used in subsequent non-equilibrium calculations on other states.
              </HELP>
              </KEYWORD>

:kword:`RFROot`
  Enter the index of that particular root in a state-average
  calculation for which the reaction-field is generated. It is used with the PCM model.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RFROOT" APPEAR="Reaction field root" LEVEL="ADVANCED" KIND="INT">
              %%Keyword: RFROot <advanced>
              <HELP>
              Enter the index number of that particular root in a state-average
              calculation for which the reaction-field is generated. Used with the PCM model.
              </HELP>
              </KEYWORD>

:kword:`CIRFroot`
  Enter the relative index of one of the roots specified in CISElect
  for which the reaction-field is generated. Used with the PCM model.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CIRFROOT" APPEAR="Reaction field CISE root" LEVEL="ADVANCED" KIND="INT">
              %%Keyword: CIRFroot <advanced>
              <HELP>
              Enter the relative index of one of the roots specified in CISElect
              for which the reaction-field is generated. Used with the PCM model.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`NEWIph`
  The default name of the :file:`JOBIPH` file will be determined by any already existing such files
  in the work directory, by appending "01", "02", etc. so a new unique name is
  obtained.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NEWI" LEVEL="ADVANCED" APPEAR="Automatic JOBIPH name" KIND="SINGLE">
              %%Keyword: NEWIph <advanced>
              <HELP>
              The default name of the JOBIPH file will be determined by any already existing such files
              in the work directory, by appending "01", "02", etc. so a new unique name is
              obtained.
              </HELP>
              </KEYWORD>

:kword:`FROZen`
  Specifies the number of frozen orbitals in each symmetry.
  (see below for condition on input orbitals). Frozen
  orbitals will not be modified in the calculation. Only doubly occupied
  orbitals can be left frozen. This input can be used for example for
  inner shells of heavy atoms to reduce the basis set superposition
  error. Default is 0 in all symmetries.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="ORBITALS" APPEAR="Orbital spaces" LEVEL="BASIC" KIND="BOX">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="FROZEN" APPEAR="Frozen" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: FROZen <basic>
              <HELP>
              Specifies the number of frozen orbitals in each symmetry.
              (see below for condition on input orbitals). Frozen
              orbitals will not be modified in the calculation. Only doubly occupied
              orbitals can be left frozen. This input can be used for example for
              inner shells of heavy atoms to reduce the basis set superposition
              error. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`INACtive`
  Specify on the next line the number of inactive (doubly occupied) orbitals in each
  symmetry. Frozen orbitals should not be included here. Default is 0 in
  all symmetries, but if there is no symmetry (C1) and both :kword:`CHARGE` and
  :kword:`NACTEL` are given, the number of inactive orbitals will be calculated
  automatically.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="INACTIVE" APPEAR="Inactive" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: INACtive <basic>
              <HELP>
              Specify the number of inactive (doubly occupied) orbitals in each
              symmetry, not counting frozen orbitals. Default is 0 in
              all symmetries.
              </HELP>
              </KEYWORD>

:kword:`RAS1`
  On the next line specify the number of orbitals in each symmetry
  for the RAS1 orbital subspace. Default is 0 in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RAS1" APPEAR="RAS1" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: RAS1 <basic>
              <HELP>
              Specify the number of orbitals in each symmetry
              for the RAS1 orbital subspace. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`RAS2`
  On the next line specify the number of orbitals in each symmetry
  for the RAS2 orbital subspace. Default is 0 in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RAS2" APPEAR="RAS2" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: RAS2 <basic>
              <HELP>
              Specify the number of orbitals in each symmetry
              for the RAS2 orbital subspace. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`RAS3`
  On the next line specify the number of orbitals in each symmetry
  for the RAS3 orbital subspace. Default is 0 in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="RAS3" APPEAR="RAS3" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: RAS3 <basic>
              <HELP>
              Specify the number of orbitals in each symmetry
              for the RAS3 orbital subspace. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`DELEted`
  Specify the number of deleted orbitals in each
  symmetry. These orbitals will not be allowed to mix into the occupied
  orbitals. It is always the last orbitals in each symmetry that are deleted.
  Default is 0 in all symmetries, unless orbitals wer already deleted by previous
  programs due to near-linear dependence.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DELETED" LEVEL="BASIC" APPEAR="Deleted" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: DELEted <basic>
              <HELP>
              Specify the number of deleted orbitals in each
              symmetry. Default is normally 0 in all symmetries, but see manual for exception.
              </HELP>
              </KEYWORD>

:kword:`GASScf`
  Needed to perform a Generalized Active Space (GASSCF) calculation.
  It is followed by an integer that defines the number of active subspaces,
  and two lines for each subspace. The first line gives the number of orbitals
  in each symmetry, the second gives the minimum and maximum number of
  electrons in the accumulated active space.

  An example of an input that uses this keyword is the following: ::

    GASSCF
     5
     2 0 0 0 2 0 0 0
     4 4
     0 2 0 0 0 2 0 0
     8 8
     0 0 2 0 0 0 2 0
     12 12
     0 0 0 1 0 0 0 1
     14 14
     4 2 2 1 4 2 2 1
     20 20

  In the example above (20in32), excitations from one subspace to another are not allowed since
  the values of MIN and MAX for GSOC are identical for each of the five subspaces.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="GASSCF" APPEAR="GASSCF" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: GASSCF <advanced>
              <HELP>
              Needed to perform a Generalized Active Space (GASSCF) calculation.
              It is followed by an integer that defines the number of active subspaces,
              and two lines for each subspace. The first line gives the number of orbitals
              in each symmetry, the second gives the minimum and maximum number of
              electrons in the accumulated active space.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`KSDFT`
  Needed to perform MC-PDFT calculations. It must be used together with
  :kword:`CIONLY` keyword (it is a post-SCF method not compatible with SCF) and :kword:`ROKS` keyword.
  The functional choice follows. Specify the functional by prefixing
  ``T:`` or ``FT:`` to the standard DFT functionals (see keyword :kword:`KSDFT` of :program:`SCF`)
  An example of an input that uses this keyword follows: ::

    &RASSCF
    JOBIPH
    CIRESTART
    CIONLY
    Ras2
    1 0 0 0 1 0 0 0
    KSDFT
    ROKS; T:PBE

  In the above example, :kword:`JOBIPH` is used to use orbitals stored in :file:`JobIph`, :kword:`CIRESTART` is used to
  use a pre-optimized CI vector, :kword:`CIONLY` is used to avoid conflicts between the standard :program:`RASSCF` module
  and the MC-PDFT method (not compatible with SCF so far). The functional chosen is the translated-PBE.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="KSDFT" APPEAR="MC-PDFT" KIND="STRINGS" SIZE="2" LEVEL="ADVANCED" REQUIRE="CIONLY">
              %%Keyword: KSDFT <advanced>
              <HELP>
              Needed to perform MC-PDFT calculations. It must be used together with
              CIONLY keyword (it is a post-SCF method not compatible with SCF) and ROKS keyword.
              The functional choice follows. Currently available functionals are
              prefix T: or FT: to the standard DFT functionals (see keyword KSDFT of SCF program)
              </HELP>
              </KEYWORD>

:kword:`JOBIph`
  Input molecular orbitals are read from an unformatted file with
  FORTRAN file name :file:`JOBOLD`.
  **Note**, the keywords :kword:`Lumorb`, :kword:`Core`, and
  :kword:`Jobiph` are mutually exclusive. If none is given the program will
  search for input orbitals on the runfile in the order: :program:`RASSCF`,
  :program:`SCF`, :program:`GUESSORB`. If none is found, the keyword :kword:`CORE`
  will be activated.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="ORBSTART" APPEAR="Starting orbitals" KIND="BOX">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="JOBIPH" APPEAR="JobIph" KIND="SINGLE" EXCLUSIVE="LUMORB,CORE" LEVEL="BASIC">
              %%Keyword: JOBIph <basic>
              <HELP>
              Get starting molecular orbitals from a binary file called JOBOLD.
              </HELP>
              </KEYWORD>

:kword:`IPHName`
  Override the default choice of name of the :file:`JOBIPH` file by giving the file name you want.
  The name will be truncated to 8 characters and converted to uppercase.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="IPHN" LEVEL="ADVANCED" APPEAR="JobIph Name" KIND="STRING" DEFAULT_VALUE="JOBIPH">
              %%Keyword: IPHName <advanced>
              <HELP>
              Override the default choice of name of the JOBIPH file by giving the file name you want.
              The name will be truncated to 8 characters and converted to uppercase.
              </HELP>
              </KEYWORD>

:kword:`LUMOrb`
  Input molecular orbitals are read from a formatted file with
  FORTRAN file name :file:`INPORB`.
  **Note**, the keywords :kword:`Lumorb`, :kword:`Core`, and
  :kword:`Jobiph` are mutually exclusive. If none is given the program will
  search for input orbitals on the runfile in the order: :program:`RASSCF`,
  :program:`SCF`, :program:`GUESSORB`. If none is found, the keyword :kword:`CORE`
  will be activated.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="LUMORB" APPEAR="Orbitals file" KIND="SINGLE" EXCLUSIVE="CORE,JOBIPH" LEVEL="BASIC">
              %%Keyword: LUMOrb <basic>
              <HELP>
              Get starting molecular orbitals from an ASCII file called INPORB.
              </HELP>
              </KEYWORD>

:kword:`FILEorb`
  Override the default name (:file:`INPORB`) for starting orbital file by giving the file name you want.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="FILE" LEVEL="ADVANCED" APPEAR="Starting orbitals file" KIND="STRING" DEFAULT_VALUE="INPORB">
              %%Keyword: FILEorb <advanced>
              <HELP>
              Override the default name (INPORB) for starting orbital file by giving the file name you want.
              </HELP>
              </KEYWORD>

:kword:`CORE`
  Input molecular orbitals are obtained by diagonalizing the core Hamiltonian.
  This option is only recommended in simple cases. It often leads to divergence.
  **Note**, the keywords :kword:`Lumorb`, :kword:`Core`, and
  :kword:`Jobiph` are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CORE" APPEAR="Core Hamiltonian" KIND="SINGLE" EXCLUSIVE="LUMORB,JOBIPH" LEVEL="BASIC">
              %%Keyword: CORE <basic>
              <HELP>
              Get starting molecular orbitals by diagonalizing the core Hamiltonian.
              Not recommended.
              </HELP>
              </KEYWORD>

:kword:`ALPHaOrBeta`
  With UHF orbitals as input, select alpha or beta as starting orbitals. A positive value selects alpha,
  a negative value selects beta. Default is 0, which fails with UHF orbitals. This keyword does not
  affect the spin of the wave function (see the :kword:`SPIN` keyword).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ALPH" LEVEL="ADVANCED" APPEAR="Alpha or beta" KIND="INT" DEFAULT_VALUE="0" MIN_VALUE="-1" MAX_VALUE="1">
              %%Keyword: ALPHaOrBeta <advanced>
              <HELP>
              With UHF orbitals as input, select alpha (1) or beta (-1) as starting orbitals.
              </HELP>
              </KEYWORD>

:kword:`TYPEIndex`
  This keyword forces the program to use information about subspaces from the
  :file:`INPORB` file.

  User can change the order of orbitals by editing of "Type Index" section
  in the :file:`INPORB` file. The legend of the types is:

  * **F** --- Frozen
  * **I** --- Inactive
  * **1** --- RAS1
  * **2** --- RAS2
  * **3** --- RAS3
  * **S** --- Secondary
  * **D** --- Deleted

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="TYPEINDEX" APPEAR="Use type index" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: TYPEindex <advanced>
              <HELP>
              Use extra information from the INPORB file to decide about orbital
              subspaces.
              </HELP>
              </KEYWORD>

:kword:`ALTEr`
  This keyword is used to change the ordering of MO in :file:`INPORB` or
  :file:`JOBOLD`. The keyword requires first the number of pairs to be interchanged,
  followed, for each pair, the symmetry species of
  the pair and the indices of the two permuting MOs. Here is an example: ::

    ALTEr= 2; 1 4 5; 3 6 8

  In this example, 2 pairs of MO will be exchanged: 4 and 5 in symmetry 1 and
  6 and 8 in symmetry 3.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ALTER" APPEAR="Change order" KIND="INTS_COMPUTED" SIZE="3" MIN_VALUE="1" LEVEL="ADVANCED">
              %%Keyword: ALTEr <advanced>
              <HELP>
              ALTEr interchanges pairs of MOs taken from the files INPORB or JOBOLD before
              starting the RASSCF calculation. Specify the number of pairs to exchange and,
              for each pair, by symmetry species and indices of the two permuting MOs.
              </HELP>
              </KEYWORD>

:kword:`ORTH`
   Specify the orthonormalization scheme to apply on the read orbitals.
   The possibilities are ``Gram_Schmidt``, ``Lowdin``, ``Canonical``, or ``no_ON``
   (no_orthonormalization).
   For a detailed explanation see :cite:`szabo_ostlund` (p. 143).
   The default is Gram_Schmidt.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ORTHON" APPEAR="Orthonormalization" LEVEL="ADVANCED" KIND="CHOICE" LIST="----,Gram_Schmidt,Lowdin,Canonical,no_ON">
              %%Keyword: ORTH <basic>
              <HELP>
              Specify the orthonormalization scheme to apply on the input orbitals.
              The possibilities are Gram_Schmidt, Lowdin, Canonical, or no_ON
              (no_orthonormalization).
              The default is Gram_Schmidt.
              </HELP>
              </KEYWORD>

:kword:`CLEAnup`
  This input is used to set to zero specific coefficients of the input
  orbitals. It is of value, for example, when the actual symmetry is
  higher than given by input and the trial orbitals are contaminated
  by lower symmetry mixing. The input requires at least one line
  per symmetry specifying the number of additional groups of orbitals
  to clean. For each group of orbitals within the symmetry, three lines
  follow. The first line indicates the number of considered orbitals
  and the specific number of the orbital (within the symmetry) in the
  set of input orbitals. Note the input lines can not be longer than 72
  characters and the program expects as many continuation lines as are
  needed. The second line indicates the number of
  coefficients belonging to the prior orbitals which are going to be
  set to zero and which coefficients. The third line indicates the
  number of the coefficients of all the complementary orbitals of
  the symmetry which are going to be set to zero and which are these
  coefficients. Here is an example of what an input would look like: ::

    CLEAnup
    2
       3 4 7 9; 3 10 11 13; 4 12 15 16 17
       2 8 11; 1 15; 0
    0; 0; 0

  In this example the first entry indicates that two groups of orbitals are
  specified in the first symmetry. The first item of the
  following entry indicates that there are three orbitals considered
  (4, 7, and 9). The first item of the following entry indicates that there
  are three coefficients of the orbitals 4, 7, and 9 to be set to zero,
  coefficients 10, 11, and 13. The first item of the following entry indicates
  that there are four coefficients (12, 15, 16, and 17) which will be zero
  in all the remaining orbitals of the symmetry. For the second group of
  the first symmetry orbitals 8 and 11 will have their coefficient 15 set
  to zero, while nothing will be applied in the remaining orbitals.
  If a geometry optimization is performed the keyword is inactive after
  the first structure iteration.

  .. xmldoc:: %%Keyword: CLEAnup <advanced>
              This input is used to set to zero specific coefficients of the input
              orbitals. The option is, for instance, of great value if the symmetry of a
              molecule is higher than given by input and hence the trial orbitals are
              contaminated by components of lower symmetry. The restrictions are
              introduced by grouping orbitals of the same symmetry into additional
              classes. Orbitals belonging to a given classes are requested to obey a set
              of rules. In addition, all orbitals not belonging to that class, can be
              requested to obey another set of rules. Here, a rule is defined as being
              identical to the instruction: set coefficient i in orbital j to zero.

              The keyword requires at least one line of input per symmetry specifying
              the number of additional classes in this symmetry (a 0 (zero) denotes that
              there is no additional classes). If the number of additional classes is not
              zero then the program expects for each classes three lines of input: The
              first entry includes as first datum the dimension of the class followed by
              the list of orbitals included in this class. The second entry defines the
              set of rules which are applied to all orbitals within the class. The first
              datum defines the number of MO-coefficients to be set to zero and is
              followed by a list of which coefficients are to be touched. Finally, the
              third entry of input define the set of rules to be applied to all orbital
              not belonging to the class. Here too, the first value defines the number of
              MO-coefficients to be set to zero and is followed by a list of which
              coefficients are to be touched.

  .. xmldoc:: </GROUP>

:kword:`CIREstart`
  Starting CI-coefficients are read from a binary file :file:`JOBOLD`.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CIRESTART" APPEAR="CI restart" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CIRESTART <basic>
              <HELP>
              Starting CI-coefficients are read from a binary file JOBOLD.
              </HELP>
              </KEYWORD>

:kword:`ORBOnly`
  This input keyword is used to get a formated ASCII file
  (:file:`RASORB`, :file:`RASORB.2`, etc.)
  containing molecular orbitals and occupations reading from a
  binary :file:`JobIph` file. The program will not perform any other operation.
  (In this usage, the program can be run without any files, except the :file:`JOBIPH` file).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ORBONLY" APPEAR="Orbitals only" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ORBOnly <basic>
              <HELP>
              This input keyword is used to get a formated ASCII file (RASORB, RASORB.2, etc.)
              containing molecular orbitals and occupations reading from a
              binary JobIph file. The program will not perform any other operation.
              </HELP>
              </KEYWORD>

:kword:`CIONly`
  This keyword is used to disable orbital optimization, that is,
  the CI roots are computed only for a given set of input orbitals.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CIONLY" APPEAR="CI only" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CIONly <basic>
              <HELP>
              This keyword is used to disable orbital optimization, that is,
              the CI roots are computed only for a given set of input orbitals.
              </HELP>
              </KEYWORD>

:kword:`CHOInput`
  This marks the start of an input section for modifying
  the default settings of the Cholesky RASSCF.
  Below follows a description of the associated options.
  The options may be given in any order,
  and they are all optional except for
  :kword:`ENDChoinput` which marks the end of the :kword:`CHOInput` section.

  :kword:`NoLK`
    Available only within ChoInput. Deactivates the "Local Exchange" (LK) screening algorithm :cite:`Aquilante:07a` in computing
    the Fock matrix. The loss of speed compared to the default algorithm can be substantial, especially for electron-rich systems.
    Default is to use LK.

    .. xmldoc:: <GROUP MODULE="RASSCF" NAME="CHOINPUT" APPEAR="Cholesky input section" KIND="BLOCK" LEVEL="ADVANCED">
                %%Keyword: Choinput <advanced>
                Manually modify the settings of the Cholesky RASSCF.

    .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NOLK" APPEAR="Turn off LK screening" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NoLK <advanced>
                <HELP>
                Deactivates LK screening.
                </HELP>
                </KEYWORD>

    .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ALGORITHM" LEVEL="UNDOCUMENTED" KIND="INT" />

    .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="LOCK" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  :kword:`DMPK`
    Available only within ChoInput. Modifies the thresholds used in the LK screening.
    The keyword takes as argument a (double precision) floating point (non-negative) number used
    as correction factor for the LK screening thresholds.
    The default value is 1.0d-1. A smaller value results in a slower but more accurate calculation.

    **Note:** The default choice of the LK screening thresholds is tailored to achieve as much as possible an
    accuracy of the converged RASSCF energies consistent with the choice of the Cholesky decomposition
    threshold.

    .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DMPK" APPEAR="Damping for LK" LEVEL="ADVANCED" KIND="REAL" EXCLUSIVE="NOLK">
                %%Keyword: dmpK <advanced>
                <HELP>
                Modifies the thresholds used in the LK screening.
                The default value is 1.0d-1. A smaller value results in a slower but more accurate calculation.
                </HELP>
                </KEYWORD>

  :kword:`NODEcomposition`
    Available only within ChoInput. Deactivates the Cholesky decomposition of the inactive AO 1-particle density matrix.
    The inactive Exchange contribution to the Fock matrix is therefore computed using inactive canonical orbitals
    instead of (localized) "Cholesky MOs" :cite:`Aquilante:06a`. This choice tends to lower the performances of the
    LK screening.
    Default is to perform this decomposition in order to obtain the Cholesky MOs.

    .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NODE" APPEAR="Turn off density decomposition" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NODE <advanced>
                <HELP>
                The inactive exchange contribution to the Fock matrix is computed using inactive canonical orbitals
                instead of (localized) "Cholesky MOs".
                </HELP>
                </KEYWORD>

    .. xmldoc:: </GROUP>

  :kword:`TIME`
    Activates printing of the timings of each task of the Fock matrix build.
    Default is to not show these timings.

  :kword:`MEMFraction`
    Set the fraction of memory to use as global Cholesky vector buffer.
    Default: for serial runs 0.0d0; for parallel runs 0.3d0.

:kword:`OFEMbedding`
  Performs a Orbital-Free Embedding (OFE)RASSCF calculation, available only in combination with Cholesky or RI integral representation.
  The runfile of the environment subsystem renamed AUXRFIL is required.
  An example of input for the keyword :kword:`OFEM` is the following: ::

    OFEMbedding
     ldtf/pbe
    dFMD
     1.0   1.0d2
    FTHAw
     1.0d-4

  The keyword :kword:`OFEM` requires the specification of two functionals in the form fun1/fun2, where fun1 is the functional
  used for the Kinetic Energy (available functionals: Thomas-Fermi, with acronym LDTF, and the NDSD functional), and where
  fun2 is the xc-functional (LDA, LDA5, PBE and BLYP available at the moment).
  The OPTIONAL keyword :kword:`dFMD` has two arguments: first, the fraction of correlation potential to be added to the OFE potential;
  second, the exponential decay factor for this correction (used in PES calculations).
  The OPTIONAL keyword :kword:`dFMD` specifies the fraction of correlation potential to be added to the OFE potential.
  The OPTIONAL keyword :kword:`FTHA` is used in a freeze-and-thaw cycle (EMIL Do While) to specify the (subsystems) energy convergence threshold.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="OFEMBEDDING" APPEAR="Orbital-free embedding" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: OFEM <advanced>
              <HELP>
              Performs a Orbital-Free Embedding (OFE)RASSCF calculation, available only in combination with Cholesky or RI integral representation.
              The runfile of the environment subsystem renamed AUXRFIL is required.
              An example of input for the keyword OFEM is the following:

                OFEMbedding
                 ldtf/pbe
                dFMD
                 1.0   1.0d2
                FTHAw
                 1.0d-4

              The keyword OFEM requires the specification of two functionals in the form fun1/fun2, where fun1 is the functional used for the
              Kinetic Energy (available functionals: Thomas-Fermi, with acronym LDTF, and the NDSD functional), and where
              fun2 is the xc-functional (LDA, LDA5, PBE and BLYP available at the moment).
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DFMD" LEVEL="ADVANCED" KIND="REALS" SIZE="2" REQUIRE="OFEMBEDDING">
              %%Keyword: dFMD <advanced>
              <HELP>
              The OPTIONAL keyword dFMD has two arguments: first, the fraction of correlation potential to be added to the OFE potential;
              second, the exponential decay factor for this correction (used in PES calculations).
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="FTHAW" LEVEL="ADVANCED" KIND="REAL" REQUIRE="OFEMBEDDING">
              %%Keyword: FTHAw <advanced>
              <HELP>
              The OPTIONAL keyword FTHA is used in a freeze-and-thaw cycle (EMIL Do While) to specify the (subsystems) energy
              convergence threshold.
              </HELP>
              </KEYWORD>

:kword:`ITERations`
  Specify the maximum number of
  :program:`RASSCF` iterations, and the maximum number of iterations used in the orbital
  optimization (super-CI) section. Default and maximum values are 200,100.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="CNVCTL" APPEAR="Convergence control" KIND="BOX" WINDOW="POPUP" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ITER" LEVEL="BASIC" APPEAR="Maximum iterations" KIND="INTS" SIZE="2" DEFAULT_VALUES="200,100">
              %%Keyword: ITERations <basic>
              <HELP>
              Specify the maximum number of
              RASSCF iterations and the maximum number of iterations used in the orbital optimization
              section. Default and maximum values are 200,100.
              </HELP>
              </KEYWORD>

:kword:`LEVShft`
  Define a level shift value for the super-CI Hamiltonian. Typical values are in the range
  0.0--1.5. Increase this value if a calculation diverges. The default value 0.5,
  is normally the best choice when Quasi-Newton is performed.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="LEVSHFT" LEVEL="BASIC" APPEAR="Level shift" KIND="REAL" DEFAULT_VALUE="0.5">
              %%Keyword: LEVShft <basic>
              <HELP>
              Define a level shift value for the super-CI Hamiltonian. Typical values are in the range
              0.0-1.5. Increase this value if a calculation diverges. The default value 0.5,
              is normally the best choice when Quasi-Newton is performed.
              </HELP>
              </KEYWORD>

:kword:`THRS`
  Specify convergence thresholds for: energy,
  orbital rotation matrix, and energy gradient. Default values are:
  1.0e-08, 1.0e-04, 1.0e-04.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="THRS" APPEAR="Thresholds" LEVEL="ADVANCED" KIND="REALS" SIZE="3" DEFAULT_VALUES="1.0e-8,1.0e-4,1.0e-4">
              %%Keyword: THRS <advanced>
              <HELP>
              Specify convergence thresholds for: energy,
              orbital rotation matrix, and energy gradient. Default values are:
              1.0e-08, 1.0e-04, 1.0e-04.
              </HELP>
              </KEYWORD>

:kword:`TIGHt`
  Convergence thresholds for the Davidson diagonalization procedure. Two
  numbers should be given: THREN and THFACT. THREN specifies the energy
  threshold in the first iteration. THFACT is used to compute the
  threshold in subsequent iterations as THFACT\ :math:`\cdot`\DE, where DE is the
  RASSCF energy change. Default values are 1.0d-04 and 1.0d-3.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="TIGHT" APPEAR="Davidson thresholds" LEVEL="ADVANCED" KIND="REALS" SIZE="2" DEFAULT_VALUES="1.0e-4,1.0e-3">
              %%Keyword: TIGHt <advanced>
              <HELP>
              Convergence thresholds for the Davidson diagonalization procedure. Two
              numbers should be given: THREN and THFACT. THREN specifies the energy
              threshold in the first iteration. THFACT is used to compute the
              threshold in subsequent iterations as THFACT*DE, where DE is the
              RASSCF energy change. Default values are 1.0d-04 and 1.0d-3.
              </HELP>
              </KEYWORD>

:kword:`NOQUne`
  This input keyword is used to switch off the
  Quasi-Newton update procedure for the Hessian. Pure super-CI
  iterations will be performed. (Default setting: QN update is used
  unless the calculation involves numerically integrated DFT contributions.)

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NOQUNE" KIND="SINGLE" APPEAR="No quasi-Newton update" LEVEL="ADVANCED" EXCLUSIVE="QUNE">
              %%Keyword: NOQUne <advanced>
              <HELP>
              This input keyword is used to switch off the Quasi-Newton update procedure for the
              Hessian. Pure super-CI iterations will be performed. (Default setting: QN update is
              used unless the calculation involves numerically integrated DFT contributions.)
              </HELP>
              </KEYWORD>

:kword:`QUNE`
  This input keyword is used to switch on the
  Quasi-Newton update procedure for the Hessian.
  (Default setting: QN update is used
  unless the calculation involves numerically integrated DFT contributions.)

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="QUNE" KIND="SINGLE" APPEAR="Quasi-Newton update" LEVEL="ADVANCED" EXCLUSIVE="NOQU">
              %%Keyword: QUNE <advanced>
              <HELP>
              This input keyword is used to switch on the Quasi-Newton update procedure for the
              Hessian. (Default setting: QN update is used unless the calculation involves
              numerically integrated DFT contributions.)
              </HELP>
              </KEYWORD>

:kword:`CIMX`
  Specify the maximum number of iterations allowed in the CI
  procedure. Default is 100 with maximum value 200.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CIMX" APPEAR="Maximum CI iterations" KIND="INT" DEFAULT_VALUE="100" MIN_VALUE="0" MAX_VALUE="200" LEVEL="BASIC">
              %%Keyword: CIMX <basic>
              <HELP>
              Specify the maximum number of iterations allowed in the CI
              procedure. Default is 100 with maximum value 200.
              </HELP>
              </KEYWORD>

:kword:`HEXS`
  Highly excited states. Will eliminate the maximum occupation in
  one or more RAS/GAS's thereby eliminating all roots below.
  Very helpful for core excitations where the ground-state input
  can be used to eliminate unwanted roots. Works with RASSI.
  First input is the number of RAS/GAS where the maximum occupation
  should be eliminated. Second is the RAS/GAS or RAS/GAS's where
  maximum occupation will not be allowed.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="HEXS" APPEAR="Highly excited states" KIND="INTS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: HEXS <advanced>
              <HELP>
              Highly excited states. Will eliminate the maximum occupation in
              one or more RAS/GAS's thereby eliminating all roots below.
              Very helpful for core excitations where the ground-state input
              can be used to eliminate unwanted roots. Works with RASSI.
              First input is the number of RAS/GAS where the maximum occupation
              should be eliminated. Second is the RAS/GAS or RAS/GAS's where
              maximum occupation will not be allowed.
              </HELP>
              </KEYWORD>

:kword:`SDAV`
  Here follows the dimension of the explicit Hamiltonian used to speed up
  the Davidson CI iteration process. An explicit H matrix is constructed
  for those configurations that have the lowest diagonal elements.
  This H matrix is used instead of the corresponding diagonal elements
  in the Davidson update vector construction. The result is a large saving
  in the number if CI iterations needed. Default value is the smallest of 100
  and the number of configurations. Increase this value if there is problems
  converging to the right roots.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SDAV" APPEAR="Davidson explicit Hamiltonian" LEVEL="ADVANCED" KIND="INT">
              %%Keyword: SDAV <advanced>
              <HELP>
              The keyword is followed by one line of input giving the dimension
              of the explicit Hamiltonian used as preconditioner in the
              Davidson procedure.Increase this value if there is problems
              converging to the right roots.
              </HELP>
              </KEYWORD>

:kword:`NKEE`
  Here follows the maximum dimension of the full Davidson Hamiltonian.
  This Hamiltonian contains the current CI vectors for each state as well
  as a set of correction vectors from a number of past iterations.
  Default value is the smallest of 400 and 6 times the number of states, though
  at least 2 times the number of states.
  Increasing this size reduces the number of CI iterations but increases memory requirements and can
  increase the computational cost associated with forming and diagonalizing the Hamiltonian matrix.
  Very large values can lead to numerical instabilities.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NKEE" APPEAR="Number of kept vectors" LEVEL="ADVANCED" KIND="INT">
              %%Keyword: SDAV <advanced>
              <HELP>
              The keyword is followed by one line of input giving the maximum dimension
              of the Hamiltonian used in the Davidson procedure.
              Increase this value if the CI does not converge.
              </HELP>
              </KEYWORD>

:kword:`SXDAmp`
  A variable called SXDAMP regulates the size of the orbital rotations.
  Use keyword :kword:`SXDAmp` and enter a real number.
  The default value is 0.0002. Larger values can give slow
  convergence, very low values may give problems e.g. if some active
  occupations are very close to 0 or 2.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SXDAMP" APPEAR="Orbital rotation damp" LEVEL="ADVANCED" KIND="REAL">
              %%Keyword: SXDAmp <advanced>
              <HELP>
              SXDAMP (default 0.0002) regulates the speed of orbital relaxation.
              Large values give slower but safer convergence.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`SUPSym`
  This input is used to restrict possible orbital
  rotations. It is of value, for example, when the actual symmetry is
  higher than given by input. Each orbital is given a label IXSYM(I).
  If two orbitals in the same symmetry have different labels they will
  not be allowed to rotate into each other and thus prevents from obtaining
  symmetry broken solutions. Note, however, that the starting orbitals must
  have the right symmetry. The input requires one or more entries
  per symmetry. The first specifies the number of additional subgroups in this
  symmetry (a 0 (zero) denotes that there is no additional subgroups and the
  value of IXSYM will be 0 (zero) for all orbitals in that symmetry ).
  If the number of additional subgroups is not zero there are additional
  entries for each subgroup: The dimension of the subgroup and
  the list of orbitals in the subgroup counted relative to the first orbital
  in this symmetry. Note, the input lines can not be longer than 180 characters
  and the program expects continuation lines as many as there are needed.
  As an example assume an atom treated in :math:`C_{2v}` symmetry for
  which the d\ :math:`_{z^2}` orbitals (7 and 10) in symmetries 1 may mix with the
  s orbitals. In addition, the d\ :math:`_{z^2}` and d\ :math:`_{x^2-y^2}` orbitals (8 and 11)
  may also mix. Then the input would look like:

  .. If the number of additional subgroups is not zero then the
     program expects for each subgroup at least one additional entry of which
     the first number denotes the dimension of the subgroup (number of
     orbitals involved) followed by the orbital index relative to the first
     orbital in this symmetry.

  ::

    SUPSym
    2
       2 7 10; 2 8 11
    0; 0; 0

  In this example the first entry indicates that we would like to specify
  two additional subgroups in the first symmetry (total symmetric group). The
  first item in the following two entries declares that each subgroup consists
  of two orbitals. Orbitals 7 and 10 constitute the first group and it is
  assumed that these are orbitals of d\ :math:`_{z^2}` character. The second group
  includes the d\ :math:`_{x^2-y^2}` orbitals 8 and 11. The following three entries
  denote that there are no further subgroups defined for the remaining
  symmetries. Ordering of the orbitals according to energy is deactivated
  when using :kword:`SUPSym`. If you activate ordering using :kword:`ORDEr`,
  the new labels will be printed in the output section.
  If a geometry optimization is performed the reordered matrix will be stored
  in the :file:`RUNFILE` file and read from there instead of from the input
  in each new structure iteration.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SUPSYM" APPEAR="Supersymmetry" LEVEL="ADVANCED" KIND="CUSTOM">
              %%Keyword: SUPSym <advanced>
              <HELP>
              Used to prohibit certain orbital rotations. Please consult the manual!
              </HELP>
              This input is used to restrict possible orbital rotations. The
              restrictions are introduced by grouping orbitals of the same
              symmetry into additional classes. Orbitals belonging to different
              classes are not allowed to mix up during optimization.
              The input requires at least one entry per symmetry specifying
              the number of additional classes in this symmetry (a 0 (zero)
              denotes that there is no additional classes).
              If the number of additional classes is not zero then the program expects
              for each classes the following input: The dimension of the classes and
              the list of orbitals in the classes counted relative to the first orbital
              in this symmetry.
              </KEYWORD>

:kword:`HOME`
  With this keyword, the root selection in the Super-CI orbital update
  is by maximum overlap rather than lowest energy.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="HOME" APPEAR="Root homing" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: HOME <advanced>
              <HELP>
              Make the root selection in the Super-CI orbital update
              by maximum overlap rather than by energy ordering.
              </HELP>
              </KEYWORD>

:kword:`IVO`
  The :program:`RASSCF` program will diagonalize the core Hamiltonian in the space of virtual orbitals,
  before printing them in the output. The resulting orbitals are only suitable to select which ones
  should enter the active space in a subsequent :program:`RASSCF` calculation. The :program:`RASSCF` wave function and
  orbitals are not suitable for CASPT2, MRCI or any other correlated methods, because the energies
  of the virtual orbitals are undefined.
  This keyword is equivalent to the :kword:`IVO` keyword of the :program:`SCF` program.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="IVO" APPEAR="Improved Virtual Orbitals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: IVO <basic>
              <HELP>
              The RASSCF program will diagonalize the core Hamiltonian in the space of virtual orbitals,
              before printing them in the output. The resulting orbitals are only suitable to select which ones
              should enter the active space in a subsequent RASSCF calculation. The RASSCF wave function and
              orbitals are not suitable for CASPT2, MRCI or any other correlated methods, because the energies
              of the virtual orbitals are undefined.
              This keyword is equivalent to the IVO keyword of the SCF program.
              </HELP>
              </KEYWORD>

:kword:`VB`
  .. _vbinrasscf:

  Using this keyword, the CI optimization step in the :program:`RASSCF` program will be
  replaced by a call to the :program:`CASVB` program, such that fully variational valence
  bond calculations may be carried out. The :kword:`VB` keyword can be followed by any
  of the directives described in :numref:`UG:sec:casvb` and should be terminated
  by :kword:`ENDVB`. Energy-based optimization of the VB parameters is the default,
  and the output level for the main :program:`CASVB` iterations is reduced to :math:`-1`,
  unless the print level for :program:`CASVB` print option 6 is :math:`\geq`\2.

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="VB" APPEAR="CASVB" KIND="BLOCK" LEVEL="BASIC">
              %%Keyword: VB <basic>
              <HELP>
              Perform fully variational VB calculations, by
              invoking CASVB in place of the CI optimization step.
              </HELP>

  .. xmldoc:: <INCLUDE MODULE="CASVB" EXCEPT="FROZEN,INACTIVE,NACTEL,RAS2,SPIN,SYMMETRY" />

  .. xmldoc:: </GROUP>

:kword:`PRINt`
  The keyword is followed by a line giving the print
  levels for various logical code sections. It has the following structure:
  IW IPR IPRSEC(I), I=1,7

  * IW --- logical unit number of printed output (normally 6).
  * IPR --- is the overall print level (normally 2).
  * IPRSEC(I) --- gives print levels in different sections of the program.

    #. Input section
    #. Transformation section
    #. CI section
    #. Super-CI section
    #. Not used
    #. Output section
    #. Population analysis section

  The meaning of the numbers: 0=Silent, 1=Terse, 2=Normal, 3=Verbose, 4=Debug,
  and 5=Insane. If input is not given, the default (normally=2) is determined
  by a global setting which can be altered bubroutine call.
  (Programmers: See programming guide). The local print level in any section is
  the maximum of the IPRGLB and IPRSEC() setting, and is automatically reduced
  e.g. during structure optimizations or numerical differentiation. Example: ::

    Print= 6 2 2 2 3 2 2 2 2

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="PRINT" LEVEL="ADVANCED" APPEAR="Print" KIND="INTS" SIZE="9">
              %%Keyword: Print <advanced>
              <HELP>
              Enter the print levels for seven logical code sections (see users guide).
              </HELP>
              </KEYWORD>

:kword:`MAXOrb`
  Maximum number of :file:`RasOrb` files to produce, one for each root up to the maximum.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="MAXORB" APPEAR="Maximum orbital files" KIND="INT" LEVEL="BASIC">
              %%Keyword: MAXOrb <basic>
              <HELP>
              Maximum number of RasOrb files to produce, one for each root.
              </HELP>
              </KEYWORD>

:kword:`OUTOrbitals`
  This keyword is used to select the type of orbitals to be written
  in a formated ASCII file. By default a formated :file:`RASORB` file
  containing average orbitals and subsequent :file:`RASORB.1`,
  :file:`RASORB.2`, etc., files containing natural orbitals for each
  of the computed (up to ten) roots will be generated in the working directory.
  An entry follows with an additional keyword selecting the orbital type.
  The possibilities are:

  AVERage orbitals: this is the default option.
  This keyword is used to produce a formated ASCII file of orbitals
  (:file:`RASORB`) which correspond to the final state average density matrix obtained by
  the :program:`RASSCF` program. The inactive and
  secondary orbitals have been transformed to make an effective Fock
  matrix diagonal. Corresponding diagonal elements are given as orbital
  energies in the :program:`RASSCF` output listing. The active orbitals have been
  obtained by diagonalizing the sub-blocks of the average density matrix
  corresponding to the three different RAS orbital spaces, thereby
  the name pseudo-natural orbitals. They will be true natural orbitals
  only for a CASSCF wave function.

  CANOnical orbitals:
  Use this keyword to produce the canonical orbitals. They differ from
  the natural orbitals, because also the active part of the Fock matrix is
  diagonalized. Note that the density matrix is no longer diagonal and
  the CI coefficients have not been transformed to this basis.
  This option substitutes the previous keyword :kword:`CANOnical`.

  NATUral orbitals:
  Use this keyword to produce the true natural orbitals. The keyword
  should be followed by a new line with an integer specifying the maximum
  CI root for which the orbitals and occupation numbers are needed.
  One file for each root will be generated up to the specified number.
  In a one state RASSCF calculation this number is always 1, but if an average
  calculation has been performed, the NO's can be obtained for all the states
  included in the energy averaging. Note that the natural orbitals main
  use is as input for property calculations using :program:`SEWARD`.
  The files will be named :file:`RASORB`, :file:`RASORB.2`, :file:`RASORB.3`, etc.
  This keyword is on by default for up to ten roots.

  SPIN orbitals.
  This keyword is used to produce a set of spin orbitals and is
  followed by a new line with an integer specifying the maximum CI root
  for which the orbitals
  and occupation numbers are needed. One file for each root will be
  generated up to the specified number. Note, for convenience the
  doubly occupied and secondary orbitals have been added to these
  sets with occupation numbers 0 (zero). The main use of these orbitals
  is to act as input to property calculations and for graphical
  presentations.
  This keyword is on by default for up to ten roots.

  An example input follows in which five files are requested containing
  natural orbitals for roots one to five of a RASSCF calculation.
  The files are named :file:`RASORB.1`, :file:`RASORB.2`, :file:`RASORB.3`, :file:`RASORB.4`, and :file:`RASORB.5`,
  respectively for each one of the roots.
  Although this is the default, it can be used complemented by the :kword:`ORBOnly`
  keyword, and the orbitals will be read from
  a JobIph file from a previous calculation, in case the formated files
  were lost or you require more than ten roots. As an option the
  :kword:`MAXOrb` can be also used to increase the number of files
  over ten. ::

    OUTOrbital= Natural; 15

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="OUTORBITALS" APPEAR="RASSCF orbital type" KIND="RADIO">
              <HELP>
              Type of orbitals to put in RASORB file.
              </HELP>
              %%Keyword: OUTOrbitals <basic>
              Type of orbitals to put in RASORB file. Specify in the next entry any of:

              AVERage   -- Average MCSCF orbitals.
              CANOnical -- Average pseudocanonical orbitals.
              NATUral   -- State-specific natural orbitals. Next entry, number of states.
              SPIN      -- State-specific spin orbitals. Next entry, number of states.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="AVERAGEORB" APPEAR="Average" KIND="SINGLE" LEVEL="BASIC">
              <HELP>
              Average MCSCF orbitals.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CANONICALORB" APPEAR="Canonical" KIND="SINGLE" LEVEL="BASIC">
              <HELP>
              Average pseudocanonical orbitals.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NATURALORB" APPEAR="Natural" KIND="INT" LEVEL="BASIC">
              <HELP>
              State-specific natural orbitals. Enter number of roots which should produce RASORB files.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SPINORB" APPEAR="Spin" KIND="INT" LEVEL="BASIC">
              <HELP>
              State-specific spin orbitals. Enter number of roots which should produce RASORB files.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`ORBListing`
  .. compound::

    This keyword is followed with a word showing
    how extensive you want the orbital listing to be in the printed output.
    The alternatives are:

    * **NOTHing:** No orbitals will be printed (suggested for
      numerical CASPT2 optimization). (Also, the old VERYbrief will be accepted).
    * **FEW:** The program will print the occupied orbitals, and any
      secondary with less than 0.15 a.u. orbital energy. (Old BRIEF also accepted).
    * **NOCOre:** The program will print the active orbitals, and any
      secondary with less than 0.15 a.u. orbital energy.
    * **ALL:** All orbitals are printed. (Old LONG also accepted).

    (unless other limits are specified by the :kword:`PROR` keyword).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ORBLISTING" LEVEL="BASIC" APPEAR="Printed orbitals" KIND="CHOICE" LIST="----,Nothing,Few,NoCore,All">
              %%Keyword: ORBListing <basic>
              <HELP>
              Select how extensive orbital list you want in the output file.
              </HELP>
              </KEYWORD>

:kword:`ORBAppear`
  This keyword requires an entry with a word showing
  the appearance of the orbital listing in the printed output.
  The alternatives are:

  * **COMPact:** The format of the orbital output is changed from a
    tabular form to a list giving the orbital indices and MO-coefficients.
    Coefficients smaller than 0.1 will be omitted.
  * **FULL:** The tabular form will be chosen.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ORBAPPEAR" LEVEL="BASIC" APPEAR="Orbital appearance" KIND="CHOICE" LIST="----,Compact,Full">
              %%Keyword: ORBAppear <basic>
              <HELP>
              Select appearance of orbital list in the output file.
              </HELP>
              </KEYWORD>

:kword:`PROR`
  This keyword is used to alter the printout of the MO-coefficients.
  Two numbers must be given of which the first is an upper boundary for the
  orbital energies and the second is a lower boundary for the occupation
  numbers. Orbitals with energy higher than the threshold or occupation
  numbers lower that the threshold will not be printed.
  By default these
  values are set such that all occupied orbitals are printed, and
  virtual orbitals with energy less than 0.15 au. However, the values
  are also affected by use of :kword:`OUTPUT`.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="PROR" LEVEL="BASIC" APPEAR="Orbital print thresholds" KIND="REALS" SIZE="2">
              %%Keyword: PROR <basic>
              <HELP>
              Enter upper limit for orbital energies, and lower limit for occupation
              number, for printing orbitals to the output.
              </HELP>
              </KEYWORD>

:kword:`PRSD`
  This keyword is used to request that not only CSFs are printed with
  the CI coefficients, but also the determinant expansion.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="PRSD" APPEAR="Print determinant expansion" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PRSD <advanced>
              <HELP>
              Activate printing of CSFs in terms of determinants.
              </HELP>
              </KEYWORD>

:kword:`ORDEr`
  This input keyword is used to deactivate or activate ordering of the output orbitals
  according to energy.
  One number must be given: 1 if you want ordering
  and 0 if you want to deactivate ordering. Default is 1 and with :kword:`SUPSym` keyword
  default is 0.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ORDER" APPEAR="Orbital print order" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: ORDEr <advanced>
              <HELP>
              Enter 1 to order the output orbitals by energy, 0 if not.
              </HELP>
              </KEYWORD>

:kword:`PRSP`
  Use this keyword to get the spin density matrix for the active orbitals printed.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="PRSP" APPEAR="Print spin density" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: PRSP <basic>
              <HELP>
              Use this keyword to get the spin density matrix for the active orbitals printed.
              </HELP>
              </KEYWORD>

:kword:`PRWF`
  Enter the threshold for CI coefficients to be printed (Default: 0.05).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="PRWF" LEVEL="BASIC" APPEAR="CI coefficients print threshold" KIND="REAL" DEFAULT_VALUE="0.05">
              %%Keyword: PRWF <basic>
              <HELP>
              Enter the threshold for CI coefficients to be printed.
              </HELP>
              (Default: 0.05)
              </KEYWORD>

:kword:`TDM`
  If this keyword is given, and if HDF5 support is enabled, the active 1-electron transition
  density matrix between every pair of states in the current calculation
  (and transition spin density matrix for non-singlet states) will be computed and
  stored in the HDF5 file.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="TDM" LEVEL="BASIC" APPEAR="Transition density matrices" KIND="SINGLE">
              %%Keyword: TDM <basic>
              <HELP>
              Compute and save active transition density matrices. Requires HDF5.
              </HELP>
              </KEYWORD>

:kword:`XMSInter`
  This keyword can be used in an XMS-PDFT calculation (which needs :program:`RASSCF` and :program:`MCPDFT` modules). This keyword stands for XMS Intermediate states. It rotates the CASSCF, CASCI, RASSCF or RASCI states into the XMS intermediate states.
  This keyword generates a file named :file:`Do_Rotate.txt` that stores the rotation vector and another file named :file:`H0_Rotate.txt` that stores the Hamiltonian matrix, called the intermediate Hamiltonian matrix, for the XMS intermediate states. The intermediate Hamiltonian matrix is the XMS-PDFT effective Hamiltonian matrix before one replaces the diagonal elements with the MC-PDFT energies.
  This keyword currently does not work for wave functions optimized with the DMRG algorithm.
  This keyword performs the functions called by :kword:`ROSTate`; therefore one does not need to use :kword:`ROSTate` when this keyword is used.
  More information regarding XMS-PDFT can be found on the Minnesota OpenMolcas page\ [#fn1]_.

  .. [#fn1] https://comp.chem.umn.edu/openmolcas/

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="XMSI" APPEAR="XMS Intermediate States" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: XMSI <basic>
              <HELP>
              This keyword rotates the states after the last diagonalization of the CASSCF, CASCI, RASSCF or RASCI calculation into XMS intermediate states.
              </HELP>
              </KEYWORD>

:kword:`CMSInter`
  This keyword can be used in a CMS-PDFT calculation (which needs :program:`RASSCF` and :program:`MCPDFT` modules). This keyword stands for CMS Intermediate states. It rotates the CASSCF, CASCI, RASSCF or RASCI states into the CMS intermediate states.
  This keyword generates a file named :file:`Do_Rotate.txt` that stores the rotation vector and another file named :file:`H0_Rotate.txt` that stores the Hamiltonian matrix, called intermediate the Hamiltonian matrix, for the CMS intermediate states. The intermediate Hamiltonian matrix is the CMS-PDFT effective Hamiltonian matrix before one replaces the diagonal elements with the MC-PDFT energies.
  This keyword currently does not work for wave functions optimized with the DMRG algorithm.
  This keyword performs the functions called by :kword:`ROSTate`; therefore one does not need to use :kword:`ROSTate` when this keyword is used.
  More information regarding CMS-PDFT can be found on the Minnesota OpenMolcas page\ [#fn1]_.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CMSI" APPEAR="CMS Intermediate States" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CMSI <basic>
              <HELP>
              This keyword rotates the states after the last diagonalization of the CASSCF, CASCI, RASSCF or RASCI calculation into CMS intermediate states.
              </HELP>
              </KEYWORD>

:kword:`CMMAx`
   This keyword defines the maximum number of cycles to find the CMS intermediate states (see :kword:`CMSInter`). The default value is 100.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CMMA" APPEAR="CMS Maximum Cycles" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="100" MIN_VALUE="1">
              %%Keyword: CMMA <advanced>
              <HELP>
              This keyword specifies the maximum number of cycles to optimize the CMS intermediate states.
              </HELP>
              </KEYWORD>

:kword:`CMMIn`
   This keyword defines the minimum number of cycles to find the CMS intermediate states (see :kword:`CMSInter`). The default value is 5.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CMMI" APPEAR="CMS Mininum Cycles" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="5" MIN_VALUE="1">
              %%Keyword: CMMI <advanced>
              <HELP>
              This keyword specifies the minimum number of cycles to optimize the CMS intermediate states.
              </HELP>
              </KEYWORD>

:kword:`CMTHreshold`
   This keyword defines the threshold for the change in the sum over states of the classical Coulomb energy for CMS intermediate states to converge (see :kword:`CMSInter`). The default value is 1.0d-6.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CMTH" APPEAR="CMS Threshold" LEVEL="ADVANCED" KIND="REAL" DEFAULT_VALUE="1.0d-6">
              %%Keyword: CMTH <advanced>
              <HELP>
              This keyword specifies the threshold for the change of sum over states of the classical Coulomb energy for CMS intermediate states to converge.
              </HELP>
              </KEYWORD>

:kword:`ROSTate`
  This keyword can be used in an MS-PDFT calculation. This keyword stands for ROtate STates, and it rotate the states after the last diagonalization of the CASSCF, CASCI, RASSCF or RASCI calculation.
  This keyword is only effective when there is a file named :file:`Do_Rotate.txt` present in the scratch directory; otherwise the states will not be rotated.
  The file :file:`Do_Rotate.txt` stores the rotation vector that rotates the states; the rotation vector is stored in a format such that the first line of the file records the first row of the rotation matrix, and so on. This keyword writes a file called :file:`H0_Rotate.txt` in the scratch directory; :file:`H0_Rotate.txt` contains the Hamiltonian matrix of the rotated states.
  This keyword currently does not work for wave functions optimized with the DMRG algorithm.
  More information regarding XMS-PDFT or CMS-PDFT can be found on the Minnesota OpenMolcas page\ [#fn1]_.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="ROSTate" APPEAR="Rotate states" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ROSTate <basic>
              <HELP>
              This keyword rotates the states after the last diagonalization of the CASSCF, CASCI, RASSCF or RASCI calculation.
              </HELP>
              </KEYWORD>

DMRG keywords
.............

.. warning::

   The :kword:`DMRG` keyword has different meanings for QCMaquis, Block and CheMPS2 DMRG interfaces.

.. class:: keywordlist

:kword:`DMRG`
  For QCMaquis interface, this keyword is used standalone and activates the DMRG calculation with QCMaquis. In this case, the input should also contain :kword:`RGINPUT` block with parameters controlling the DMRG optimization settings in QCMaquis.

  For Block and CheMPS2 interfaces, it should be followed by an integer :math:`m`
  Specify maximum number of renormalized states in the DMRG calculation, also known as (virtual) bond dimension :math:`m` in each microiteration in DMRG calculations.
  :math:`m` should be at least 500.
  This keyword is supported in both CheMPS2 and Block interfaces.
  Note that DMRG-CASSCF calculations for excited states are not fully supported by the Block interface.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DMRG" LEVEL="BASIC" APPEAR="DMRG flag" KIND="INT" DEFAULT_VALUE="0" EXCLUSIVE="NECI">
              <ALTERNATE KIND="SINGLE" />
              %%Keyword: DMRG <basic>
              <HELP>
              DMRG flag:
              - for QCMaquis interface, activates the DMRG calculation
              - for Block and CheMPS2 interfaces, sets the number of renormalized states m
              </HELP>
              </KEYWORD>

Keywords for the QCMaquis DMRG interface:

.. warning::

   Using :kword:`DMRG` with QCMaquis interface is deprecated. It is advised to use the :program:`DMRGSCF` module for QCMaquis DMRG calculations.

.. class:: keywordlist

:kword:`RGInput`
  This block, terminated by :kword:`EndRG`, is mandatory and contains parameters to QCMaquis which control the DMRG wavefunction optimization. This block is equivalent to the
  :kword:`DMRGSettings..EndDMRGSettings` block of the :program:`DMRGSCF` module (see :numref:`UG:sec:dmrgsettings_input`).

  .. xmldoc:: <GROUP MODULE="RASSCF" NAME="RGINPUT" APPEAR="QCMaquis DMRG settings" KIND="BLOCK" LEVEL="BASIC">
              <INCLUDE MODULE="DMRGSCF" EXCEPT="ACTIVESPACEOPTIMIZER,FIEDLER,CIDEAS,OOPTIMIZATIONSETTINGS,FCIDUMP,SOCCUPY,NEVPT2PREP" />
              </GROUP>

:kword:`SOCCupy`
  Initial electronic configuration for the calculated state(s). This keyword is equivalent to the :kword:`hf_occ` card in the **QCMaquis** input (see Table 8 of the QCMaquis manual), but allows input for multiple states. The occupation is inserted as a string (strings) of aliases of occupations of the active (RAS2) orbitals with the aliases ``2`` = full, ``u`` = up, ``d`` = down, ``0`` = empty. For several states, the occupation strings for each state are separated by newlines.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="SOCCUPY" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: soccupy <basic>
              <HELP>
              Set HF determinant start guess for MPS wave functions. (QCMaquis)
              </HELP>
              </KEYWORD>

:kword:`NEVPT2prep`
  Prepare for a subsequent DMRG-NEVPT2 or CASPT2 calculation. Then the four- and transition three-particle density matrices (4- and t-3RDMs), required for the MRPT2 calculations, will be evaluated and stored on disk in :file:`$WorkDir`. **QCMaquis** input files for the 4- and t-3RDMs evaluation are prepared and the RDM evaluation may be performed externally or directly in the :program:`NEVPT2` program. More about external RDM evaluation in Section 6.3 of the QCMaquis manual.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NEVPT2PREP" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NEVPT2prep <basic>
              <HELP>
              Prepare input for higher-order RDM/TDM evaluation. (QCMaquis)
              </HELP>
              </KEYWORD>

Keywords for the CheMPS2 DMRG interface:

.. class:: keywordlist

:kword:`3RDM`
  Use this keyword to get the 3-particle and Fock matrix contracted with the 4-particle reduced density
  matrices (3-RDM and F.4-RDM) for DMRG-CASPT2.
  :kword:`OUTOrbitals` = ``CANOnical`` is automatically activated.
  In CheMPS2 interface, both 3-RDM and F.4-RDM are calculated.
  In Block interface, only 3-RDM is calculated while F.4-RDM is approximated in the CASPT2 module.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="3RDM" APPEAR="Calculate 3- and 4-particle reduced density matrices" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: 3RDM <basic>
              <HELP>
              Use this keyword to get the 3-particle and 4-particle reduced density matrices (3-RDM and F.4-RDM) for DMRG-CASPT2 with CheMPS2 interface.
              </HELP>
              </KEYWORD>

:kword:`CHBLb`
  Specify a threshold for activating restart in CheMPS2.
  After each macroiteration, if the max BLB value is smaller than CHBLb, activate partial restart in CheMPS2.
  If the max BLB value is smaller than CHBLb/10.0, activate full restart in CheMPS2.
  Default value is: 0.5d-2.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CHBLB" LEVEL="BASIC" APPEAR="Threshold for restart (CheMPS2)" KIND="REAL" DEFAULT_VALUE="0.05">
              %%Keyword: CHBLb <basic>
              <HELP>
              Threshold for activating restart in CheMPS2.
              </HELP>
              (Default: 0.05)
              </KEYWORD>

:kword:`DAVTolerance`
  Specify value for Davidson tolerance in CheMPS2.
  Default value is 1.0d-7.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DAVTOLERANCE" LEVEL="BASIC" APPEAR="Davidson tolerance (CheMPS2)" KIND="REAL" DEFAULT_VALUE="1.0d-7">
              %%Keyword: DAVTolerance <basic>
              <HELP>
              Davidson tolerance in CheMPS2.
              </HELP>
              (Default: 1.0d-7)
              </KEYWORD>

:kword:`NOISe`
  Specify value for noise pre-factor in CheMPS2.
  This noise is set to 0.0 in the last instruction.
  Default value (recommended) is: 0.05.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="NOISE" LEVEL="BASIC" APPEAR="Noise pre-factor (CheMPS2)" KIND="REAL" DEFAULT_VALUE="0.05">
              %%Keyword: NOISe <basic>
              <HELP>
              Noise pre-factor in CheMPS2.
              </HELP>
              (Default: 0.05)
              </KEYWORD>

:kword:`MXSWeep`
  Maximum number of sweeps. in the last instruction in CheMPS2.
  Default value is: 8.
  In the last iteration of DMRG-SCF, :kword:`MXSW` is increased by five times (default 40).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="MXSWEEP" LEVEL="BASIC" APPEAR="Maximum number of sweeps (CheMPS2)" KIND="INT" DEFAULT_VALUE="8">
              %%Keyword: MXSWeep <basic>
              <HELP>
              Maximum number of sweeps in the last instruction in CheMPS2.
              </HELP>
              (Default: 8)
              </KEYWORD>

:kword:`MXCAnonical`
  Maximum number of sweeps in the last instruction with pseudocanonical orbitals in CheMPS2.
  Default value is: 40.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="MXCANONICAL" LEVEL="BASIC" APPEAR="Maximum number of sweeps with pseudocanonical orbitals (CheMPS2)" KIND="INT" DEFAULT_VALUE="40">
              %%Keyword: MXCAnonical <basic>
              <HELP>
              Maximum number of sweeps in the last instruction with pseudocanonical orbitals in CheMPS2.
              </HELP>
              (Default: 40)
              </KEYWORD>

:kword:`CHREstart`
  Use this keyword to activate restart in the first DMRG iteration from a previous calculation.
  The working directory must contain :file:`molcas_natorb_fiedler.txt` and :file:`CheMPS2_natorb_MPSx.h5` (``x``\=0 for the ground state,
  1 for the first excited state, etc.).
  If these files are not in the working directory, a warning is printed at the beginning of
  the calculation and restart is skipped (start from scratch).

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="CHRESTART" APPEAR="Restart in the first DMRG iteration (CheMPS2)" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CHREstart <basic>
              <HELP>
              Use this keyword to activate restart in the first DMRG iteration from a previous calculation in CheMPS2.
              </HELP>
              </KEYWORD>

:kword:`DMREstart`
  Use this keyword to activate restart in the last DMRG iteration from the previous iteration or calculation.
  This keyword only works when using :kword:`OUTOrbitals` = ``CANOnical`` or :kword:`3RDM`.
  :kword:`DMREstart` = ``0`` (default): start from scratch to calculate 3-RDM and F.4-RDM.

  :kword:`DMREstart` = ``1``: start form user-supplied checkpoint files.
  The working directory must contain :file:`molcas_canorb_fiedler.txt` and :file:`CheMPS2_canorb_MPSx.h5` (``x``\=0 for the ground state,
  1 for the first excited state, etc.).
  If these files are not in the working directory, a warning is printed at the
  beginning of the calculation and restart is skipped (start from scratch).

  :kword:`DMREstart` = ``2`` (Not recommended): start form previous checkpoint files with natural orbitals.
  :kword:`DMREstart` = ``2`` is not recommended since this may produce non-optimal energy
  because the orbital ordering is not optimized.

  .. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="DMRESTART" LEVEL="BASIC" APPEAR="Restart in the last DMRG iteration (CheMPS2)" KIND="INT" DEFAULT_VALUE="0">
              %%Keyword: DMREstart <basic>
              <HELP>
              Activate restart in the last DMRG iteration in CheMPS2.
              </HELP>
              (Default: 0)
              </KEYWORD>

A general comment concerning the input orbitals: The orbitals are ordered by
symmetry. Within each symmetry block the order is assumed to be:
frozen, inactive, active, external (secondary), and deleted. Note that
if the :kword:`Spdelete` option has been used in a preceding
:program:`SCF` calculation, the deleted orbitals will automatically be placed as
the last ones in each symmetry block.

For calculations of a molecule in a reaction field see :numref:`UG:sec:rfield`
of the present manual and :numref:`TUT:sec:cavity` of the examples manual.

Input example
.............

The following example shows the input to the
:program:`RASSCF` program for a calculation on the water molecule. The calculation is
performed in :math:`C_{2v}` symmetry (symmetries: :math:`a_1`, :math:`b_2`, :math:`b_1`, :math:`a_2`, where the two
last species are antisymmetric with respect to the molecular plane). Inactive
orbitals are :math:`1a_1` (oxygen 1s) :math:`2a_1` (oxygen 2s) and
:math:`1b_1` (the :math:`\pi` lone-pair orbital). Two bonding and two anti-bonding
OH orbitals are active, :math:`a_1` and :math:`b_2` symmetries. The calculation is
performed for the :math:`^1A_1` ground state. Note that no information about basis set,
geometry, etc. has to be given. Such information is supplied by the
:program:`SEWARD` integral program via the one-electron integral file :file:`ONEINT`. ::

  &RASSCF
  Title= Water molecule. Active orbitals OH and OH* in both symmetries
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0

The following input is an example of how to use the RASSCF program to run MC-PDFT calculations: ::

  &RASSCF
  Ras2
  1 0 0 0 1 0 0 0

  >>COPY $CurrDir/$Project.JobIph JOBOLD

  &RASSCF
  JOBIPH
  CIRESTART
  CIONLY
  Ras2
  1 0 0 0 1 0 0 0
  KSDFT
  ROKS; T:PBE

The first RASSCF run is a standard CASSCF calculation that leads to variationally optimized orbitals and CI coefficients.
The second call to the RASSCF input will use the CI vector and the orbitals previously optimized. The second RASSCF will
require the :kword:`CIONLY` keyword as the MC-PDFT is currently not compatible with SCF. :kword:`KSDFT` :kword:`ROKS` and the functional choice will
provide MC-PDFT energies.

More advanced examples can be found in the tutorial section of the manual.

Input example for DMRG-CASSCF with Molcas-CheMPS2 interface: ::

  &RASSCF
  Title= Water molecule. Active orbitals OH and OH* in both symmetries
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0
  DMRG     = 500
  3RDM

.. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="H5CI" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

.. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="AVERAGE" LEVEL="UNDOCUMENTED" KIND="INTS_COMPUTED" SIZE="2" />

.. xmldoc:: <KEYWORD MODULE="RASSCF" NAME="FAROALD" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; ALASKA
   single: ALASKA

.. _UG\:sec\:alaska:

:program:`alaska`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="ALASKA">
            %%Description:
            <HELP>
            This program computes the first derivatives of the one- and
            two-electron integrals with respect to the nuclear positions.
            The derivatives are not stored on files, but contracted
            immediately with the one- and two-electron densities to form the
            molecular gradients.
            </HELP>

This module is automatically invoked by the :program:`Slapaf` module.
This is the preferred mode of operation! In connection with numerical gradients
it will ensure that the rotational and translational invariance is fully
utilized in order to reduce the number of used displacements.

The :program:`Alaska` module compute analytic or for numerical gradients requests the execution of
an alternative module.
The :program:`Alaska` module figures out
the method automatically. Analytic methods are implemented for the HF, MBPT2, KS-DFT, and
RASSCF and SA-CASSCF method. Numerical methods are implemented for SCF, KS-DFT, RASSCF,
MBPT2, CCSDT, the CASPT2 and MS-CASPT2 methods, including the use of the Cholesky
decomposition for the methods were that has been implemented.

Both analytic and numerical procedures are parallelized.

For SA-CASSCF gradient the :program:`Alaska` module will automatically
start up the :program:`MCLR` module if required.

Analytic gradients
------------------

Gradients of the energy with respect to nuclear coordinates can be computed for
any type of wave function as long as an effective first order density matrix, an
effective Fock matrix, and an effective second order density matrix is provided.
The term effective is related to that
these matrices in the case of non-variational parameters in the wave function
(e.q. CI, MP2, CASPT2, etc.) are modified to include contributions from
the associated Lagrange
multipliers. The gradient expression apart from these modifications is
the same for any wave function type. :program:`ALASKA`
is the gradient program, which will generate
the necessary integral derivatives and combine them with the matrices
mentioned in the text above.

.. _UG\:sec\:alaska_description:

Description
-----------

:program:`ALASKA` is written such that gradients can be
computed for any kind of basis function that :program:`SEWARD` will accept.

:program:`ALASKA` is able to compute the following integral derivatives:

* overlap integrals,
* kinetic energy integrals,
* nuclear attraction integrals (point charges or finite nuclei),
* electron repulsion integrals,
* external electric field integrals,
* ECP and PP integrals,
* reaction field integrals,
* and Pauli repulsion integrals.

:program:`ALASKA` employs
two different integration schemes
to generate the
one- and two-electron integral derivatives.
The nuclear attraction and electron repulsion
integrals are evaluated by a modified Rys--Gauss quadrature :cite:`Alaska`.
All other integral
derivatives are evaluated with the Hermite--Gauss quadrature. The same
restriction of the basis sets applies as to :program:`SEWARD`.
None of the integral derivatives are written to disk but rather combined
immediately with the corresponding matrix from the wave function.

At present the following limitations are built into :program:`ALASKA`:

.. include:: ../limitations.inc

Numerical gradients
-------------------

The module is parallelized over the displacements, which in case of large jobs gives a linear
speed up compared to a serial execution, although in order to obtain this it is important to
choose the number of nodes such that the number of contributing perturbations is a multiple of
the number of nodes. For a given molecule the number of perturbations equals the number of atoms
times 6 (a perturbation with plus and minus delta for each of the three axes). Symmetry can of
course reduce this number.

.. _UG\:sec\:alaska_dependencies:

Dependencies
------------

:program:`ALASKA` depends on the density and Fock matrices generated by
:program:`SCF` or :program:`RASSCF`. In addition it needs the basis set
specification defined in :program:`SEWARD`.
The dependencies of the numerical part of the module is the union
of the dependencies of the
:program:`SEWARD`,
:program:`SCF`,
:program:`RASSCF`,
:program:`MBPT2`,
:program:`MOTRA`,
:program:`CCSDT`, and
:program:`CASPT2`
modules.
All these dependencies, however, are totally transparent to the user.

.. _UG\:sec\:alaska_files:

Files
-----

Input files
...........

Apart from the standard input unit :program:`ALASKA`
will use the following input
files: :file:`RYSRW`, :file:`ABDATA`, :file:`ONEINT`, :file:`RUNFILE`
(for more information see :numref:`UG:sec:files_list`).

The files of the
:program:`SEWARD`,
:program:`SCF`,
:program:`RASSCF`,
:program:`MBPT2`,
:program:`MOTRA`,
:program:`CCSDT`, and
:program:`CASPT2`
modules are needed for the numerical procedure.

Output files
............

In addition to the standard output unit :program:`ALASKA` will generate the following
files.

.. class:: filelist

:file:`RUNFILE`
  The :file:`runfile` is updated with information needed by the :program:`SLAPAF`
  relaxation program.
  :program:`ALASKA` will write the molecular Cartesian gradients on this file.

:file:`ALASKA.INPUT`
  File with the latest input processed by :program:`ALASKA`.

.. _UG\:sec\:alaska_input:

Input
-----

Below follows a description of the input to :program:`ALASKA`.
Note that input options are related to the analytic gradient procedure if
not otherwise noted!

In addition to the keywords and the comment lines the input may contain blank
lines. The input is always preceded by the program name: ::

  &ALASKA

Optional keywords for analytical gradients

.. class:: keywordlist

:kword:`TEST`
  With this keyword the program will process only the input.
  It is a debugging aid to help you check your input.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="TEST" APPEAR="Test" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Test <basic>
              <HELP>
              With this keyword the program will process only the input.
              It is a debugging aid to help you check your input.
              </HELP>
              </KEYWORD>

:kword:`NAC`
  Requests a calculation of the nonadiabatic coupling vector between the
  two specified roots in a SA-CASSCF calculation. If the roots are :math:`i`,
  :math:`j`, the vector computed will be :math:`\braket{\Psi_j}{\nabla\Psi_i}`.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="NAC" APPEAR="Nonadiabatic coupling" KIND="INTS" SIZE="2" LEVEL="BASIC" MIN_VALUE="1">
              %%Keyword: NAC <basic>
              <HELP>
              Requests a calculation of the nonadiabatic coupling vector between the
              two specified roots in a SA-CASSCF calculation.
              </HELP>
              </KEYWORD>

:kword:`NOCSF`
  In a NAC calculation, neglects the so-called CSF contribution.
  Note that this contribution is responsible for the translational and
  rotational non-invariance, and it has been suggested that not including
  it may give more physical results in dynamics simulations :cite:`Fatehi2012`.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="NOCSF" APPEAR="Do not compute CSF contribution" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="NAC">
              %%Keyword: NOCSF <advanced>
              <HELP>
              In a NAC calculation, neglects the so-called CSF contribution.
              </HELP>
              </KEYWORD>

:kword:`ONEOnly`
  Compute only the nuclear repulsion and one-electron integrals
  contribution to the gradient. The default is to compute all
  contributions to the molecular gradient.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="ONEONLY" APPEAR="One-electron integrals only" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:Oneonly <advanced>
              <HELP>
              Compute only the nuclear repulsion and one-electron integrals
              contribution to the gradient. The default is to compute all
              contributions to the molecular gradient.
              </HELP>
              </KEYWORD>

:kword:`CUTOff`
  Threshold for ignoring contributions to the molecular gradient
  follows on the next line. The default is ``1.0d-7``. The prescreening
  is based on the 2nd order density matrix and the radial
  overlap contribution to the integral derivatives.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="CUTOFF" APPEAR="Gradient threshold" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0D-7" LEVEL="BASIC">
              %%Keyword: Cutoff <advanced>
              <HELP>
              Specify the threshold for ignoring contributions to the molecular gradient.
              The prescreening
              is based on the 2nd order density matrix and the radial
              overlap contribution to the integral derivatives.
              </HELP>
              The default is 1.0d-7.
              </KEYWORD>

:kword:`OFEMbedding`
  Performs an Orbital-Free Embedding gradient calculation, available only in combination with Cholesky or RI integral representation.
  The runfile of the environment subsystem renamed AUXRFIL is required.
  An example of input for the keyword :kword:`OFEM` is the following: ::

    OFEMbedding
     ldtf/pbe
    dFMD
     1.0

  (see the OPTIONAL keyword :kword:`DFMD` below).
  The keyword :kword:`OFEM` requires the specification of two functionals in the form fun1/fun2, where fun1 is the functional
  used for the Kinetic Energy (available functionals: Thomas--Fermi, with acronym LDTF, and the NDSD functional), and where
  fun2 is the xc-functional (LDA, LDA5, PBE and BLYP available at the moment).

  .. xmldoc:: <GROUP MODULE="ALASKA" NAME="OFEMBED" APPEAR="Orbital-free embedding" KIND="BOX" WINDOW="POPUP" LEVEL="ADVANCED">
              <HELP>
              Orbital-Free Embedding gradient calculation, available only in combination with Cholesky or RI integral representation.
              The runfile of the environment subsystem renamed AUXRFIL is required.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="OFEM" APPEAR="Functionals" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: OFEM <advanced>
              Orbital-Free Embedding gradient calculation, available only in combination with Cholesky or RI integral representation.
              The runfile of the environment subsystem renamed AUXRFIL is required.
              <HELP>
              The keyword OFEM requires the specification of two functionals in the form fun1/fun2
              (see the manual for available functionals)
              </HELP>
              </KEYWORD>

:kword:`DFMD`
  In combination with :kword:`OFEM`, specifies the fraction of correlation potential to be added to the OFE potential
  (zero for KSDFT and one for HF).

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="DFMD" APPEAR="Fraction of correlation" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.0">
              %%Keyword: DFMD <advanced>
              <HELP>
              In combination with OFEM, specifies the fraction of correlation potential to be added to the OFE potential
              (zero for KSDFT and one for HF).
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

  .. :kword:`NOINvariance`
       No utilization of the rotational and translational invariance
       of the energy. This is the default.

  .. :kword:`EQUIvalence`
       This option is used to indicate that some of the gradients have
       the same magnitude and only one has to be computed. This line
       is followed by a line with
       ``nGroup``
       being the number of different
       groups that are equivalent. Then on
       ``nGroup``
       subsequent lines follow:
       ``nElem,(index(iElem), iElem = 1, nElem)``
       where ``nElem`` is the
       number of equivalent displacements and index is the index of
       such a displacement. This option will disable the automatic
       utilization of the translational and rotational energy.

  .. :kword:`SELEction`
       This option will allow the user to exclude some symmetrical
       displacements from the list of gradients to compute. This card
       is followed by a line specifying the number of gradients which
       will be computed. A second additional line contains all indices
       of those symmetrical displacements for which we will compute
       gradients. This option will disable the automatic utilization
       of the translational and rotational invariance of the energy.
       The :kword:`Selection` option can be used together with the
       :kword:`Equivalence` option, however,
       for this to work the :kword:`Selection` option has to be specified first.

  .. :kword:`2DOPrescreening`
       This option will activate prescreening based on the 2nd order
       density matrix only. The default prescreening method is the 2DI
       approach which is based on the 2nd order density matrix and
       bounded estimates of the integral gradient.

  .. :kword:`2DIPrescreening`

  .. :kword:`PRINt`

  .. :kword:`NOTRiangular`

:kword:`POLD`
  The gradient is printed in the old format. Note: by default gradient
  is not printed any longer.

  .. xmldoc:: <GROUP MODULE="ALASKA" NAME="PRINT" APPEAR="Print options" KIND="BOX" WINDOW="POPUP" LEVEL="BASIC">

  .. xmldoc:: <SELECT MODULE="ALASKA" NAME="PRINTF" APPEAR="Print format" CONTAINS="POLD,PNEW">

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="POLD" APPEAR="Old format" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="PNEW">
              %%Keyword: POLD <basic>
              <HELP>
              The gradient is printed in the old format. Note: by default gradient
              is not printed any longer.
              </HELP>
              </KEYWORD>

:kword:`PNEW`
  The gradient is printed in the new human-readable format.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="PNEW" APPEAR="New format" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="POLD">
              %%Keyword: PNEW <basic>
              <HELP>
              The gradient is printed in the new human-readable format.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`VERBose`
  The output will be a bit more verbose.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="VERBOSE" APPEAR="Verbose printout" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Verbose <basic>
              <HELP>
              The output will be a bit more verbose.
              </HELP>
              </KEYWORD>

:kword:`SHOW gradient contributions`
  The gradient contributions will be printed.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="SHOW" APPEAR="Show contributions" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Show <basic>
              <HELP>
              The gradient contributions will be printed.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Optional keywords for numerical gradients

.. class:: keywordlist

:kword:`NUMErical`
  Forces the use of numerical gradients even if analytical ones
  are implemented. The default is to use analytical gradients whenever
  possible.

  .. xmldoc:: <GROUP MODULE="ALASKA" NAME="NUMGRAD" APPEAR="Numerical gradient" KIND="BOX" WINDOW="POPUP" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="NUMERICAL" APPEAR="Force numerical gradient" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Numerical <basic>
              <HELP>
              Forces the use of numerical gradients even if analytical ones
              are implemented. The default is to use analytical gradients whenever
              possible.
              </HELP>
              </KEYWORD>

:kword:`ROOT`
  Specifies which root to compute the gradient for, if there is more than
  one root to choose from. In a RASSCF optimization, the default is to
  compute the gradient for the same root as is relaxed. In a MS-CASPT2 calculation, the
  default is to compute it for root 1. It can be used to override the default
  root in an analytical calculation too.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="ROOT" APPEAR="Root selection" KIND="INT" LEVEL="ADVANCED" MIN_VALUE="1">
              %%Keyword: Root <advanced>
              <HELP>
              Specifies which root to compute the gradient the geometry for, if there is more than
              one root to choose from. In a RASSCF optimization, the default is to
              compute the gradient for the same root as is relaxed. In a MS-CASPT2 calculation, the
              default is to compute it for root 1.
              </HELP>
              </KEYWORD>

:kword:`DELTa`
  For use with numerical gradients only!
  The displacement for a given center is chosen as the distance to the nearest
  neighbor, scaled by a factor. This factor can be set through the :kword:`DELTa`
  keyword. The default value is :math:`0.01`.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="DELTA" APPEAR="Displacement value" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.01" MIN_VALUE="0.0">
              %%Keyword: Delta <advanced>
              <HELP>
              For use with numerical gradients only!
              The displacement for a given center is chosen as the distance to the nearest
              neighbor scaled by a factor. This factor can be set through the DELTa
              keyword. The default is 0.01.
              </HELP>
              </KEYWORD>

:kword:`KEEPOldGradient`
  When computing numerical gradients with constraints, the gradient of the constrained degrees
  of freedom is normally set to zero. If this keyword is specified, the existing value of the gradient
  (probably computed analytically with a different method) is maintained instead.
  This is used in combination with :kword:`NGEXclude` in :program:`Gateway` (or "phantom"
  constraints), to set up composite gradients :cite:`Stenrup2015`.

  .. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="KEEP" APPEAR="Keep old gradient" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: KeepOldGradient <advanced>
              <HELP>
              Keep the existing gradient for constrained coordinates when doing numerical differentiation.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

The following is an example of an input which will work for
almost all practical cases. Note that it is very rarely that you need to run
this program explicitly. It is usually controlled by the program
:program:`Slapaf`. ::

  &Alaska

.. xmldoc:: <KEYWORD MODULE="ALASKA" NAME="AUTO" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; MCPDFT
   single: MCPDFT

.. _UG\:sec\:MCPDFT:

:program:`mcpdft`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MCPDFT">
            %%Description:
            <HELP>
            The MCPDFT program performs an MC-PDFT calculation following a
            CASSCF, RASSCF, GASSCF or DMRG-SCF wave function run. It requires the
            one- and two-electron integral files generated by SEWARD, and
            a JOBIPH file generated by the RASSCF module. In the case of DMRG-SCF
            the .h5 file generated by the DMRGSCF module suffices for an MC-PDFT run.
            </HELP>

The :program:`MCPDFT` program in |molcas| performs multiconfiguration pair-density functional theory (MC-PDFT) calculations,
as described in :cite:`limanni2014,limanni2015`. The MC-PDFT method involves two steps:
(i) a CASSCF, RASSCF, GASSCF or DMRG-SCF wave function calculation to obtain the kinetic energy, classical Coulomb energy,
total electron density, and on-top pair density; (ii) a post-SCF calculation of the remaining energy using an on-top density functional.
In the current implementation, the on-top pair density functional is obtained by "translation" (t) of exchange-correlation functionals.
Four translated functionals are currently available: tLSDA, tPBE, tBLYP, and trevPBE, in addition to the "fully-translated" (ft)
variants :cite:`Carlson2015`: ftLSDA, ftPBE, ftBLYP, and ftrevPBE.
As multiconfigurational wave functions are used as input quantities, spin and space symmetry are correctly conserved.

The molecular orbitals and one- and two-body density matrices are read from the :file:`JOBIPH` (or :file:`JOBOLD`) file
generated during a :program:`RASSCF` run. In the DMRG-SCF case, the one- and two-body density matrices are read
from an :file:`.h5` file generated during a :program:`DMRGSCF` run.

.. _UG\:sec\:mcpdft_dependencies:

Dependencies
------------

.. compound::

  To start the :program:`MCPDFT` module, the one-electron
  and two-electron integrals generated by :program:`SEWARD` are required. For MC-PDFT calculations it is suggested to use a fine or ultrafine
  grid via the following input specifications (see the :program:`SEWARD` section for further details): ::

    &SEWARD
    grid input
    grid=ultrafine
    end of grid input

  Additionally, a :file:`JOBIPH` file (or :file:`wavefunction.h5`) must be supplied to provide the molecular orbitals and one- and two-body density matrices.

.. _UG\:sec\:mcpdft_files:

Files
-----

.. _UG\:sec\:mcpdft_inp_files:

Input files
...........

:program:`MCPDFT` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`JOBOLD`,
:file:`JOBIPH`, :file:`wavefunction.h5`.

If Cholesky options are selected, additional Cholesky-related files will also be used.
Only :file:`JOBIPH` or :file:`JOBOLD` or :file:`wavefunction.h5` is needed; the code will first look for :file:`JOBOLD`
first and :file:`JOBIPH` second. To switch to the HDF5 :file:`wavefunction.h5` file mandatory for a DMRGSCF reference
wave function, use the keyword :kword:`FILEORB`.

.. _UG\:sec\:mcpdft_output_files:

Output files
............

.. class:: filelist

:file:`JOBPDFT`
  This file is written in binary format and has the same structue of the :file:`JOBIPH` file.

:file:`wavefunction.h5` (optional)
  This file is written in HDF5 format and updates the content (state energies) of the input :file:`wavefunction.h5` file.

:file:`RUNFILE`
  The :file:`RUNFILE` is updated with information from the MC-PDFT calculation.

:file:`MCDENS`
  This ASCII file is generated for MC-PDFT calculations.
  It contains spin densities, total density and on-top pair density values on grid (coordinates in a.u.).

.. _UG\:sec\:mcpdft_inp:

Input
-----

This section describes the input to the
:program:`MCPDFT` program in the |molcas| program system. The input starts
with the program name ::

  &MCPDFT

The :kword:`KSDFT` is the only required keyword.

.. class:: keywordlist

:kword:`KSDFT`
  The functional choice follows. Specify the functional by prefixing
  ``T:`` or ``FT:`` to the standard DFT functionals (see keyword :kword:`KSDFT` of :program:`SCF`)

  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="KSDFT" APPEAR="Pair-density functional" KIND="STRING" > LEVEL="BASIC"
              %Keyword: KSDFT <basic>
              <HELP>
              Needed to perform MC-PDFT calculations.
              The functional choice follows. Specify the functional by prefixing
              T: or FT: to the standard DFT functionals (see keyword KSDFT of SCF program)
              </HELP>
              </KEYWORD>

:kword:`DFCF`
  Use this keyword to scale the exchange terms and/or correlation terms of the functional requested.
  This keyword should be followed by the scaling factor for the exchange terms and the scaling factor for the correlation terms, separated by a space.
  If the values are 1.0 (default), then the original functional is used.
  For an HLE-type functional, use 1.25 (for exchange) and 0.5 (for correlation).
  Example: ``DFCF=1.25 0.5``

  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="DFCF" APPEAR="DFT exch. &amp; corr. scaling factors" KIND="REALS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: DFCF <advanced>
              <HELP>
              Use this keyword to scale the exchange terms and/or correlation terms of the functional requested.
              This keyword should be followed by the scaling factor for the exchange terms
              and the scaling factor for the correlation terms, separated by a space.
              If the values are 1.0 (default), then the original functional is used.
              For an HLE-type functional, use 1.25 (for exchange) and 0.5 (for correlation).
              Example: DFCF=1.25 0.5
              </HELP>
              </KEYWORD>

:kword:`GRAD`
  The keyword is needed to calculate potentials for analytical gradients.
  This keyword can be used with both state-specific and state-averaged CASSCF reference wavefunctions.

  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="GRAD" APPEAR="Potentials for Gradients" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: GRAD <basic>
              <HELP>
              Needed to compute potentials for MC-PDFT analytical gradients.
              </HELP>
              </KEYWORD>

:kword:`MSPDFT`
  This keyword allows one to run Multi-State Pair-Density Functional Theory (MS-PDFT). This keyword is only effective when a file named :file:`H0_Rotate.txt` is present in the scratch directory, otherwise only state-specific MC-PDFT calculations will be performed.  With the :kword:`MSPD` keyword, the program reads the Hamiltonian matrix from :file:`H0_Rotate.txt`, replaces the diagonal elements with the MC-PDFT energies of the rotated states (presumably obtained from a previous :program:`RASSCF` module in which the keyword :kword:`ROST`, :kword:`XMSI` or :kword:`CMSI` is used), and diagonalizes the Hamiltonian matrix in the intermediate basis (called the effective Hamiltonian matrix) to obtain the MS-PDFT states and energies. An input example is shown below.  More details regarding the theory, the input, and the output can be found on the Minnesota OpenMolcas page\ [#fn1]_.

  XMS-PDFT and CMS-PDFT are two MS-PDFT options in the code.

  .. [#fn1] https://comp.chem.umn.edu/openmolcas/

  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="MSPD" APPEAR="MS-PDFT" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: MSPDFT <basic>
              <HELP>
              Enable MS-PDFT. Requires H0_Rotate.txt file in the scratch directory.
              </HELP>
              </KEYWORD>

:kword:`WJOB`
    This keyword allows one to write the energies and eigenstates of MC-PDFT or MS-PDFT into :file:`JOBIPH` (or :file:`wavefunction.h5`). For MC-PDFT, only the energy of each state is written into :file:`JOBIPH` (or :file:`wavefunction.h5`), since an MC-PDFT calculation is based on a previous wave function (CASSCF, SA-CASSCF, RASSCF, GASSCF, DMRG-SCF, CASCI, RASCI...); for MS-PDFT, both the energy and the CI coefficients of the eigenstates are written into :file:`JOBIPH`, because an MS calculation changes the wave functions. The latter option is not yet available for DMRG-SCF reference wave functions.


  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="WJOB" APPEAR="Write into JOBIPH" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: WJOB <basic>
              <HELP>
              Enable one to write the energies and eigenstates of MC-PDFT or MS-PDFT into the JOBIPH file.
              </HELP>
              </KEYWORD>

:kword:`FILEORB`
  This keyword allows one to set as reference wave function file instead of :file:`JOBIPH` a different one, in particular an HDF5 file. If the MC-PDFT is to be followed by an MPSSI calculation for a reference DMRG wave function, please also add the keyword :kword:`WJOB`.
  Example: ``FileOrb = wavefunction.h5``

  .. xmldoc:: <KEYWORD MODULE="MCPDFT" NAME="FILEORB" APPEAR="Set reference wave function file" KIND="STRING" LEVEL="BASIC">
              %%Keyword: FILEORB <basic>
              <HELP>
              Enables one to set the reference wave function file for an MC-PDFT run, in particular for an HDF5 formatted file.
              </HELP>
              </KEYWORD>

Input example
.............

The following example shows the input to the
:program:`RASSCF` and :program:`MCPDFT` programs for a calculation on the water molecule.
The tPBE functional is used. The calculation is
performed in |Ctv| symmetry (symmetries: |ao|, |bt|, |bo|, |at|, where the two
last species are antisymmetric with respect to the molecular plane). Inactive
orbitals are 1\ |ao| (oxygen 1\ |s|) 2\ |ao| (oxygen 2\ |s|) and
1\ |bo| (the :math:`\pi` lone-pair orbital). Two bonding and two anti-bonding
:math:`\ce{OH}` orbitals are active, |ao| and |bt| symmetries. The calculation is
performed for the |SAO| ground state. Note that no information about basis set,
geometry, etc. has to be given. Such information is supplied by the
:program:`SEWARD` integral program via the one-electron integral file :file:`ONEINT`. ::

  &RASSCF
  Title= Water molecule. Active orbitals OH and OH* in both symmetries
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0

  &MCPDFT
  KSDFT=T:PBE

The first RASSCF run is a standard CASSCF calculation that leads to variationally optimized orbitals and CI coefficients.
The MC-PDFT run will use the orbitals and density matrices optimized during the preceding RASSCF run.

The following example shows a part of the input to run CMS-PDFT calculation.
For XMS-PDFT calculations, one simply replaces :kword:`CMSI` with :kword:`XMSI`.
The system is :math:`\ce{LiF}` and the point group used is |Ctv|. ::

   &RASSCF
   Spin=1
   Symmetry=1
   CIRoot= 2 2 1
   Inactive=2 0 0 0
   Ras2=4 1 0 1
   Nactel=8 0 0

   >>COPY $CurrDir/LiF.RasOrb $CurrDir/UseOrb

   &RASSCF
   CIOnly
   Spin=1
   Symmetry=1
   CIRoot= 2 2 1
   Inactive=2 0 0 0
   Ras2=4 1 0 1
   Nactel=8 0 0
   CMSI

   &MCPDFT
   KSDFT=T:PBE
   NoGrad
   MSPDft

The following example shows a part of the input to run CMS-PDFT geometry optimization. The additional keywords are :kword:`RLXR` in :program:`RASSCF` and :kword:`GRAD` in :program:`MCPDFT`. The additional modules include :program:`MCLR`, :program:`ALASKA` and :program:`SLAPAF`. ::

   &GATEWAY
    Coord
    2
    Angstrom
    Li 0.0 0.0  1.3
    F  0.0 0.0 -1.3
    Group=XY Y
    Basis=STO-3G

   >>> DO WHILE
    &Seward

    &RASSCF
    Spin=1
    Symmetry=1
    CIRoot= 2 2 1
    Inactive=2 0 0 0
    Ras2=4 1 0 1
    Nactel=8 0 0
    CMSI
    RLXRoot=2

    &MCPDFT
    KSDFT=T:PBE
    Grad
    MSPDft

    &MCLR

    &ALASKA

    &SLAPAF
    >>> EndDo

.. xmldoc:: </MODULE>
.. index::
   single: Program; CCSDT
   single: CCSDT

.. _sec\:ccsdt:

:program:`ccsdt`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="CCSDT">
            %%Description:
            <HELP>
            The CCSDT set of programs performs the iterative ROHF CCSD
            procedure, optionally followed by the (T) calculation contribution.
            It requires the JOBIPH file produced by RASSCF, and TRAONE and TRAINT
            files produced by MOTRA.
            </HELP>

:program:`CCSDT` performs the iterative single determinant CCSD procedure for
open shell systems and the noniterative triple contribution calculation to
the CCSD energy.
For further details the reader is referred to
:numref:`Sections %s <TUT:sec:ccsdt>` and
:numref:`%s <TUT:sec:rp_wf>` of the tutorials and examples manual.

.. index::
   pair: Dependencies; CCSDT

.. _sec\:ccsdt_dependencies:

Dependencies
------------

:program:`CCSDT` requires a previous run of the :program:`RASSCF` program
to produce orbital energies, Fock matrix elements, wave function
specification, and some other parameters stored in file :file:`JOBIPH`.
The :program:`RASSCF` program should be run with the options that produce
canonical output orbitals, which is not default.
:program:`CCSDT` also requires transformed integrals produced by :program:`MOTRA`
and stored in the files :file:`TRAONE` and :file:`TRAINT`.

It is well known that the CCSD procedure brings the spin
contamination into the final
wave function :math:`\ket{\Psi}` even in the case where the reference function
:math:`\ket{\Phi}` is the proper
spin eigenfunction. The way how to reduce the spin
contamination and mainly the number of independent amplitudes is to introduce
the spin adaptation.
Besides the standard nonadapted (spinorbital) CCSD procedure this program
allows to use different levels of spin
adaptation of CCSD amplitudes (the recommended citations are Refs.
:cite:`ccsd_neo2,ccsd_neo1`):

* DDVV T2 adaptation.

  This is the most simple and most universal scheme, in which only the dominant
  part of T2 amplitudes, namely those where both electrons are excited from
  *doubly occupied (inactive)* to *virtual (secondary)* orbitals, are adapted.
  The remaining types of amplitudes are left unadapted, i.e. in the spinorbital form.
  This alternative is an excellent approximation to the full adaptation and
  can be used for any multiplet.

* Full T1 and T2 adaptation (only for doublet states yet).

  In this case full spin adaptation of all types of amplitudes is performed.
  In the present implementation this version is limited to systems with
  the single unpaired electrons, i.e. to the doublet states only.

Besides these two possibilities there are also available some
additional partial ones (see keyword
:kword:`ADAPTATION` in :numref:`sec:ccsdt_input`). These adaptations are
suitable only for some specific purposes. More details on spin adaptation in
the CCSD step can be found in Refs. :cite:`ccsd_neo1,ccsd_neo2,ccsd_kno`.
The current implementation of the spin adaptation saves no computer time. A more
efficient version is under development.

The noniterative triples calculation can follow these approaches:

* CCSD + T(CCSD) --- according to Urban et al. :cite:`t3_urban`
* CCSD(T) --- according to Raghavachari et al. :cite:`t3_ragh`
* CCSD(T) --- according e.g. to Watts et al. :cite:`t3_watts`

Actual implementation and careful analysis and discussion of these
methods is described in Ref. :cite:`t3_neo`, which is a recommended reference
for this program.

The first alternative represents the simplest noniterative T3 treatment and contains
only pure :math:`\braket{T3}{W T2}` term. Second possibility represents the well known
extension to the first one by the :math:`\braket{T3}{W T1}` term
(:math:`W` is the two electron perturbation). For closed shell
systems this is the most popular and most frequently used noniterative triples
method. For single determinant open shell systems, described by the
ROHF reference
function standard (Raghavachari et. al.) method needs to be extended by the
additional fourth order energy term, namely
:math:`\braket{T3}{U T2}` (:math:`U` is the off-diagonal part of the Fock operator).

In contrast to the iterative CCSD procedure, noniterative approaches are not
invariant with respect to the partitioning of the Hamiltonian.
Hence, we obtain
different results using orbital energies, Fock matrix elements
or some other quantities in the
denominator. According to our experiences :cite:`t3_neo`,
diagonal Fock matrix elements in the
denominator represent the best choice. Using of other alternatives
requires some experience.
Since the triple excitation contribution procedure works strictly within the restricted formalism, resulting
noniterative triples contributions depend also on the choice of the reference
function. However, differences between this approach (with the reference
function produced by a single determinant RASSCF procedure and the diagonal
Fock matrix elements considered in the denominator) and the corresponding
invariant treatment (with the semicanonical orbitals)
are found to be chemically negligible.

For noniterative T3 contribution both non-adapted (spin-orbital) and spin-adapted
CCSD amplitudes can be used. For more details, see Ref. :cite:`t3_neo`.

.. index::
   pair: Files; CCSDT

.. _sec\:ccsdt_files:

Files
-----

Input files
...........

:program:`CCSDT` will use the following input
files: :file:`TRAONE`, :file:`TRAINT`, :file:`RUNFILE`, :file:`JOBIPH`,
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist

:file:`RSTART`
  file with CC amplitudes and CC energy.
  The name of the file can be changed using keyword :kword:`RESTART`.
  It contains restart information, like
  T1aa, T1bb, T2aaaa, T2bbbb, T2abab, CC energy and the number of iterations.

:file:`T3hfxyy`
  These files contain integrals of :math:`\braket{ia}{bc}` type where *x*
  represents
  the symmetry and *yy* the value of the given index :math:`i`.
  The number of
  these files is equal to the number of :math:`\alpha` occupied orbitals
  (*inactive + active*).

.. index::
   pair: Input; CCSDT

.. _sec\:ccsdt_input:

Input
-----

The input for each module is preceded by its name like: ::

  &CCSDT

.. class:: keywordlist

:kword:`TITLe`
  This keyword should be followed by precisely one title line.
  It should not begin with a blank (else it will not be printed!)
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              Followed by precisely one title line, not beginning with a blank.
              </HELP>
              </KEYWORD>

:kword:`CCSD`
  This keyword specifies that only CCSD calculation will follow
  and the integrals will be prepared for the CCSD procedure only.
  This keyword is *optional*. (Default=OFF)

  .. xmldoc:: <SELECT MODULE="CCSDT" NAME="ANYTRIP" APPEAR="Any triples?" CONTAINS="CCSD,CCT" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="CCSD" APPEAR="CCSD only" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="CCT">
              %%Keyword: CCSD <basic>
              <HELP>
              Specifies that only CCSD calculation will follow.
              </HELP>
              </KEYWORD>

:kword:`CCT`
  This keyword specifies that after CCSD calculation also noniterative
  T3 step will follow. For such calculations this key must
  be switched on. The integrals for the triple contribution calculation
  will then be prepared.
  This keyword is *optional*. (Default=ON)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="CCT" APPEAR="Triples (default)" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="CCSD">
              %%Keyword: CCT <basic>
              <HELP>
              Specifies that after CCSD, also the noniterative T3 calculation will follow.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`ADAPtation`
  The parameter on the following line defines the type of spin adaptations
  of CCSD amplitudes.

  .. container:: list

    0 --- no spin adaptation --- full spinorbital formalism

    1 --- T2 DDVV spin adaptation

    2 --- T2 DDVV + T1 DV spin adaptation (only recommended for specific purposes,
    since the adaptation of T1 included incompletely)

    3 --- full T2 and T1 spin adaptation (in current implementations
    limited to doublets only)

    4 --- full T2 adaptation without SDVS coupling (for doublets only)

  This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="ADAP" APPEAR="Adaptation" KIND="CHOICE" LIST="0: No adaptation,1: T2 DDVV,2: T2 DDVV and T1 DV,3: Full T2 and T1,4: Full T2" LEVEL="BASIC" DEFAULT_VALUE="0">
              <HELP>
              Choose how CCSD amplitudes should be spin adapted (if at all).
              </HELP>
              </KEYWORD>
              %%Keyword: ADAPtation <basic>
              Sets the type of CCSD amplitudes spin adaptation.

              0 -- None
              1 -- T2 DDVV
              2 -- T2 DDVV + T1 DV
              3 -- Full T2 and T1 spin adaptation (doublets only)
              4 -- Full T2 adaptation without SDVS coupling (doublets only)

:kword:`DENOminators`
  The parameter on the following line specifies the type of denominators that
  will be used in the CCSD procedure.

  .. container:: list

    0 --- diagonal Fock matrix elements (different for :math:`\alpha` and :math:`\beta`
    spins)

    1 --- spin averaged diagonal Fock matrix elements ---
    :math:`\frac{f_{\alpha\alpha}+f_{\beta\beta}}{2}`

    2 --- orbital energies

  In some cases alternatives 1 and 2 are identical.
  For nonadapted CCSD calculations the resulting CCSD energy
  is invariant with respect to the selection of denominators.
  However, convergence may be affected.

  In the present implementation a symmetric denominators
  (i.e. the input 1 or 2) should be used for spin adapted CCSD calculations.
  This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="DENO" APPEAR="Denominators" KIND="CHOICE" LIST="0: Diagonal Fock matrix elements,1: Spin averaged diagonal,2: Orbital energies" LEVEL="BASIC" DEFAULT_VALUE="0">
              <HELP>
              Choose the type of denominators in the CCSD procedure.
              </HELP>
              </KEYWORD>
              %%Keyword: DENOminators <basic>
              Sets the type of denominators in the CCSD procedure.

              0 -- Diagonal Fock matrix elements
              1 -- Spin averaged diagonal Fock matrix elements
              2 -- Orbital energies

:kword:`SHIFts`
  Following line contains *socc* and *svirt* levelshift values for occupied and
  virtual orbitals respectively. Typical values are in the range 0.0--0.5 (in *a.u.*) ::

    dp(occ)=dp(occ)-socc
    dp(virt)=dp(virt)+svirt

  For spin adaptations 3 and 4 only inactive (D) and active (V) orbitals
  will be shifted, due to the character of the adaptation scheme. For other cases all
  orbitals are shifted.

  This keyword is *optional*. (Defaults: *socc* = 0.0, *svirt* = 0.0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="SHIFT" APPEAR="Shifts" KIND="REALS" SIZE="2" LEVEL="ADVANCED" DEFAULT_VALUE="0.0">
              <HELP>
              Enter level shift values for occupied and virtual orbitals.
              </HELP>
              </KEYWORD>
              %%Keyword: SHIFts <advanced>
              On the following line the level shift values for occupied and virtual
              orbitals needs to be specified, typically around 0.0 - 0.5.

:kword:`TRIPles`
  The parameter on the following line specifies the
  type of noniterative triples
  procedure. There are three different types of perturbative triples available
  (see :numref:`sec:ccsdt`).

  .. container:: list

    0 --- CCSD approach (no triples step)

    1 --- CCSD+T(CCSD) according to Urban et. al :cite:`t3_urban`

    2 --- CCSD(T) according to Raghavachari et. al. :cite:`t3_ragh`

    3 --- CCSD(T) according e.g. to Watts et. al. :cite:`t3_watts`

  This keyword is *optional*. (Default=3)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="TRIPLES" APPEAR="What triples" KIND="CHOICE" LIST="0: CCSD,1: CCSD + T(CCSD),2: CCSD(T) Raghavachari,3: CCSD(T) Watts" LEVEL="BASIC" DEFAULT_VALUE="3">
              <HELP>
              Choose the type of triples contribution calculation.
              </HELP>
              </KEYWORD>
              %%Keyword: TRIPles <basic>
              Sets the type of triples contribution calculation.

              0 -- CCSD
              1 -- CCSD + T(CCSD)   (Urban et al.)
              2 -- CCSD(T)          (Raghavachari et al.)
              3 -- CCSD(T)          (Watts et al.)

:kword:`T3DEnominators`
  The parameter on the following line specifies the type of denominators that
  will be used in noniterative triples procedure.

  .. container:: list

    0 --- diagonal Fock matrix elements (different for :math:`\alpha` and :math:`\beta`
    spins)

    1 --- spin averaged diagonal Fock matrix elements ---
    :math:`\frac{f_{\alpha\alpha}+f_{\beta\beta}}{2}`

    2 --- orbital energies

  In some cases alternatives 1 and 2 are identical.
  This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="T3DEN" APPEAR="T3 denominators" KIND="CHOICE" LIST="0: Diagonal,1: Spin averaged,2: Orbital energies" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              <HELP>
              Choose the type of denominators used in the (T) calculation procedure.
              </HELP>
              </KEYWORD>
              %%Keyword: T3DEnominators <advanced>
              Sets the type of denominators used in the (T) calculation procedure.

              0 -- Diagonal Fock matrix elements
              1 -- Spin averaged Fock matrix elements
              2 -- Orbital energies

:kword:`T3SHifts`
  The following line contains *socc* and *svirt* levelshift values for
  occupied and virtual orbitals respectively.
  Typical values are in the range 0.0--0.5 (in *a.u.*) ::

    dp(occ)=dp(occ)-socc
    dp(virt)=dp(virt)+svirt

  In contrast to the iterative CCSD procedure, in noniterative T3 step results are
  not invariant with respect to the denominator shifting. It is extremely dangerous
  to use any other than 0.0 0.0 shifts here, since resulting T3 energy may have
  no physical meaning. This keyword may be useful only in estimating some
  trends in resulting energy, however, using of default values is strongly
  recommended.

  This keyword is *optional*. (Defaults: *socc* = 0.0, *svirt* = 0.0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="T3SH" APPEAR="T3 Shifts" KIND="REALS" SIZE="2" LEVEL="ADVANCED">
              <HELP>
              Enter two numbers with level shifts for occupied and virtual orbitals
              in (T) calculations. Use with care, if at all, and consult the manual.
              </HELP>
              </KEYWORD>
              %%Keyword: T3SHifts <advanced>
              This keyword is followed by two numbers that set the levelshift values
              for occupied and virtual orbitals in (T) calculations. The default values
              (0,0) should not normally be changed.

:kword:`ITERations`
  This keyword is followed on the next line by the maximum number
  of iterations in the CCSD procedure. In the case of the RESTART run this is the
  number of last allowed iteration, since counting of iterations in
  RESTART run starts from the value taken from the :file:`RSTART` file.
  This keyword is *optional*. (Default=30)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="ITER" APPEAR="MAX iter" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="30">
              %%Keyword: ITERations <basic>
              <HELP>
              Sets the maximum number of CCSD iterations (Default:30).
              </HELP>
              </KEYWORD>

:kword:`ACCUracy`
  The real value on the following line defines the convergence criterion on
  CCSD energy. This keyword is *optional*. (Default=1.0d-7)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="ACCU" APPEAR="Accuracy" KIND="REAL" LEVEL="BASIC" MIN_VALUE="0.0" DEFAULT_VALUE="1.0d-7">
              <HELP>
              Change the default convergence criterion (1.0D-7) on CCSD energy.
              </HELP>
              </KEYWORD>
              %%Keyword: ACCUracy <basic>
              This keyword sets the convergence criterion on CCSD energy.

:kword:`END of input`
  This keyword indicates that there is no more input
  to be read.
  This keyword is *optional*.

:kword:`EXTRapolation`
  This keyword switches on the DIIS extrapolation. This keyword is followed
  by two additional parameters on the next line *n1* and *n2*.

  .. container:: list

    *n1* --- specifies the first iteration, in which DIIS extrapolation procedure
    will start for the first time. This value must not be less then *n2*,
    recommended
    value is 5--7.

    *n2* --- specifies the size of the DIIS procedure, i.e. the number of previous
    CCSD steps which will be used for new prediction. In the present implementation
    *n2* is limited to 2--4.

  This keyword is *optional*. (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="EXTR" APPEAR="Extrapolation" KIND="INTS" SIZE="2" LEVEL="BASIC">
              <HELP>
              Switch on DIIS extrapolation, and set two parameters:
              The first iteration to employ DIIS, and the number of previous iterations
              to use for new prediction.
              </HELP>
              </KEYWORD>
              %%Keyword: EXTRapolation <basic>
              Switches the DIIS extrapolation on. Two additional parameters are required
              on the next line: the first iteration to employ DIIS and the number of
              previous iterations to use for new prediction.

:kword:`PRINt`
  The parameter on the next line specifies the level of output printing

  .. container:: list

    0 --- minimal level of printing

    1 --- medium level of printing

    2 --- full output printing (useful for debugging purposes)

  This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="PRINT" APPEAR="Print level" KIND="CHOICE" LIST="0: Minimal,1: Medium,2: Full" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              <HELP>
              Sets the amount of the program verbosity.
              </HELP>
              </KEYWORD>
              %%Keyword: PRINtlevel <advanced>
              Sets the amount of the program verbosity as 0..2. Default: 0.

:kword:`LOAD`
  This keyword is followed by the line which specifies the
  name of the CCSD amplitudes and energy file. The default name is :file:`RSTART`,
  but it can be changed in CCSD step using :kword:`RESTART` keyword.
  This keyword is *optional*. (Default=:file:`RSTART`)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="LOAD" APPEAR="Load" KIND="STRING" LEVEL="ADVANCED" DEFAULT_VALUE="RSTART">
              <HELP>
              Alter the file name used to save restart information (Default: RSTART)
              </HELP>
              </KEYWORD>
              %%Keyword: LOAD <advanced>
              This keyword is followed by the line that specifies the name, where the
              restart information was saved.

:kword:`RESTart`
  This keyword defines the restart conditions and modifies the name of the file,
  in which restart information (CC amplitudes, CC energy and the number
  of iterations) is saved. On the following two lines there
  are control key *nn* and the name of restart information storing file
  *name*.

  *nn* --- restart status key

  .. container:: list

    0 --- restart informations will be not saved

    1 --- restart informations will be saved after each iteration in
    *name*.

    2 --- restart run. CC amplitudes and energy will be taken from
    *name* file and the CCSD procedure will continue with
    these values as an estimate.

  *name* --- specifies the restart information storing key. The name is limited
  to 6 characters.

  This keyword is *optional*. (Defaults: *nn* = 1,
  *name* = RSTART)

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="REST" APPEAR="Restart" KIND="STRINGS" SIZE="2" LEVEL="ADVANCED">
              <HELP>
              LINE 1: Choose restart conditions. 0=nothing saved, 1=just save restart info,
              2=also start using restart info. LINE2: The restart file name (at most 6 char).
              </HELP>
              </KEYWORD>
              %%Keyword: RESTart <advanced>
              Followed by two lines.
              LINE 1: Choose restart conditions. 0=nothing saved, 1=just save restart info,
              2=also start using restart info. LINE2: The restart file name (at most 6 char).

:kword:`IOKEy`
  This keyword specifies the input-output file handling.

  .. container:: list

    1 --- Internal Fortran file handling

    2 --- |molcas| DA file handling

  The default (1) is recommended in majority of cases, since when calculating relatively
  large systems with low symmetry, the size of some intermediate files produced may become large,
  what could cause some troubles on 32-bit machines (2 GB file size limit).

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="IOKEY" APPEAR="I/O key" KIND="CHOICE" LIST="0: Fortran I/O,1: MOLCAS I/O" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              <HELP>
              Specify the file type handling. Fortran I/O is default.
              </HELP>
              </KEYWORD>
              %%Keyword: IOKEy <advanced>
              Specifies the file type handling, with Fortran I/O being the default.

              1 -- Fortran I/O
              2 -- MOLCAS DA I/O

:kword:`MACHinetyp`
  This keyword specifies which type of matrix multiplication is preferred on a given
  machine. The following line contains two parameters *nn*, *limit*.

  .. container:: list

    *nn* = 1 --- standard multiplication :math:`A B` is preferred

    *nn* = 2 --- transposed multiplication :math:`A^{\text{T}} B` is preferred

  Parameter *limit* specifies the limit for using :math:`A^{\text{T}} B`
  multiplication, when *nn* = 2. (It has no meaning for *nn* = 1.)

  If *size(A)/size(B)* :math:`\geq` *limit* --- standard multiplication is performed,
  *size(A)/size(B)* :math:`<` *limit* --- transposed multiplication is
  performed.

  (*size(A,B)* --- number of elements in matrix A,B).

  Recommended value for *limit* is 2--3.

  Using of transposed matrix (*nn* = 2)
  multiplication may bring some computer time reduction only in special
  cases, however, it requires some additional work space. Default is optimal
  for absolute majority of cases.

  This keyword is *optional*. (Default=1).

  .. xmldoc:: <KEYWORD MODULE="CCSDT" NAME="MACH" APPEAR="Machine" KIND="INTS" SIZE="2" LEVEL="ADVANCED">
              <HELP>
              Use two integers to specify preferred matrix multiply type.
              Usually default is good, and input requires care: Consult manual!
              </HELP>
              </KEYWORD>
              %%Keyword: MACHinetyp <advanced>
              This keyword sets the preferred type of matrix multiplication.
              On the following line n, limit must be specified:

              n=1 -- standard matrix multiplication is performed
              n=2 -- A(T)*B matrix multiplication is performed, if
                     size(A)/size(B) is less than limit. See manual!

Note, that :kword:`CCSD` and :kword:`CCT` keywords are mutually exclusive.

.. index::
   single: CCSDT; Closed-shell

.. _sec\:ccsdt_cs:

How to run closed shell calculations using ROHF CC codes
--------------------------------------------------------

First of all it should be noted here, that it is not advantageous
to run closed shell calculations using ROHF CC codes, since
in the present implementation it will require the same number of
arithmetical operations and the core and disk space like corresponding
open shell calculations.

Since ROHF CC codes are connected to the output of :program:`RASSCF` code (through the
:file:`JOBIPH` file), it is necessary to run closed shell Hartree--Fock using
the :program:`RASSCF` program. This can be done by setting the number of active orbitals
and electrons to zero (also by including only doubly occupied orbitals into the
active space; this has no advantage but increases the computational effort).
to guarantee the single reference character of the wave function.

The CC program will recognize the closed shell case automatically and will reorganize
all integrals in a required form.
For more information the reader is referred to the tutorials and examples manual.

Below is an input file for :math:`\ce{HF+}` CCSD(T) calculation. ::

  &CCSDT
  Title
   HF(+) CCSD(T) input example
  CCT
  Triples
  3

.. xmldoc:: </MODULE>
.. index::
   single: Program; MkNemo
   single: MkNemo

.. _UG\:sec\:mknemo:

:program:`mknemo` |extramark|
=============================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: %%Description:
            This module generates intermolecular potential between two subsystems
            and saves all information in the NEMO file format.

The :program:`MkNemo` module generates intermolecular potential between two subsystems and saves all informations in the NEMO file format.

.. _UG\:sec\:mknemo_description:

Description
-----------

According to the NEMO model of interaction between two subsystems, the :program:`MkNemo` module splits super-system into two clusters: :math:`A` and :math:`B`. The subsystems :math:`A` and :math:`B` are defined in the main coordinate system, :math:`R`. Calculations of the interaction potential between two subsystems are performed for different configurations. At the first step one has to transform both subsystems to the first configuration. An identical transformation to the first configuration is only allowed for one of the subsystems if any coordinates of atoms in the A-subsystem are the same as any atom's coordinates of the B-subsystem. Generally, we define :math:`T_A` and :math:`T_B` as transformation operations of the first and second subsystem to the first configuration :math:`(R_A,R_B)` from the main coordinate system (:math:`R`):

.. math:: T_A: R \rightarrow R_A, \\
          T_B: R \rightarrow R_B.

.. VV 120918: this picture is missing. So, the call has been commented out.

   .. figure:: mknemo.*
      :scale: 60%
      :align: center

      The transformations of the subsystems from the main coordinate system, :math:`R`, to the first configuration (:math:`R_A,R_B`).

Any other configuration can be obtained by transformation, i.e., translation or rotation of one of the subsystems. For any configuration, one has to calculate the total energy of super-system, A-subsystem with the virtual orbitals of the B-subsystem, and the B-subsystem with virtual orbitals of the A-subsystem at first (unperturbed theory) and second (perturbation) level of theory.

The :program:`MkNemo` is written in such way that at first step user has to:

#. Define different molecules in global coordinate system, :math:`R` and the molecules can overlay.
#. Define the clusters, :math:`A` and :math:`B`, using translation and rotation operations applied for the molecules and for the clusters themselves.
#. Define all possible displacements of any cluster to obtain new configuration.

In the second step user has to provide any input of |molcas| module which is able to calculate the total energy of the super-system, A-subsystem, and B-subsystem on the first and second level of theory for a given configuration. After any calculation of total energy, one has to call proper block of :program:`MkNemo` module, GetE, to save energy in the MKNEMO.Conf file. Finally, in the third step, user has to generate new configuration, according to displacement transformations. All three steps are placed in the do-while loop.

.. _UG\:sec\:mknemo_files:

Files
-----

Standard input
..............

The :program:`MkNemo` obeys all rules for format of |molcas|'s input except order of :program:`MkNemo`'s blocks in an input. The input is always preceded by the dummy namelist reference
:kword:`&MkNemo &End` and ended by :kword:`End Of Input`.

Example: ::

  &MkNemo &End
    .................
  End of input

.. compound::

  The :program:`MkNemo` defines *transformation* as translation, :math:`T`, or rotation, :math:`R`, operation in a format: ::

    [ x y z angle]

  where the ``[x y z]`` is a 3D-vector of translation, or the ``[x,y  z]`` is a 3D-vector of rotation if the ``angle`` parameter is presented, and the ``angle`` is an optional parameter which is an angle of rotation around this vector in degrees. Generally, translation and rotation operation do not commute, since that the :program:`MkNemo` first applys transformation from left to right, i.e.: product :math:`T R` means that the :program:`MkNemo` will apply first rotation and then translation.

The input of :program:`MkNemo` module has been split into four groups of keywords:

* **Mole**\cules, **Clus**\ters, and **Disp**\lacement,
* **GetE**\energy,
* **Next**,
* **Test**.

All keywords can be provided in a full name but only first 4 characters (bold characters) are recognize by :program:`MkNemo`.

.. class:: keywordlist

:kword:`MOLE`, :kword:`CLUS`, and :kword:`DISP`
  The keywords must be provided in right order in the input file. And the blocks of keywords, MOLE, CLUS, and DISP, cannot be split between separated :program:`MkNemo` inputs.

  .. compound::

    The definition of a **Mole**\cule has format: ::

      Mole : MoleculeName
        AtomLabel  x  y  z
        .........  .. .. ..
        AtomLabel  x  y  z
      End

    where the **Mole** is keyword which marks beginning of a molecule's block, the MoleculeName is an unique name of molecule, the AtomLabel is the label of atom, and x, y, and z are coordinates of atoms. The name of the molecule is case sensitive, but atom's label is not.

  .. xmldoc:: %%Keyword: MOLE <basic>
              The Mole block specifies a molecule, in the format:

                Mole : MoleculeName
                  AtomLabel  x  y  z
                  .........  .. .. ..
                  AtomLabel  x  y  z
                End

              where the Mole is keyword which marks begining of a molecule's block,
              the MoleculeName is an unique name of molecule, the AtomLabel is the label
              of atom, and x, y, and z are coordinates of atoms. The name of the molecule
              is case sensitive, but atom's label is not.

  .. compound::

    In the **Clus**\ter's block, user defines a cluster in format: ::

      Clus : ClusterName  ClusterTransformation
        MoleculeName  MoleculeTransformation
        ............  ......................
        MoleculeName
      End

    where the **Clus** keyword marks beginning of cluster's block, the ClusterName[MoleculeName] is an unique name of cluster[molecule], and the ClusterTransformation[MoleculeTransformation] is an optional argument which defines a transformation of the cluster[molecule]. The cluster and molecule names are case sensitive. The MoleculeName must be defined in a **Mole** block.

  .. xmldoc:: %%Keyword: CLUS <basic>
              In the Clus block, user defines a cluster in format:

                Clus : ClusterName : ClusterTransformation
                  MoleculeName : MoleculeTransformation
                  ............
                  MoleculeName
                End

              where the Clus keyword marks beginning of cluster's block,
              the ClusterName[MoleculeName] is an unique name of cluster[molecule],
              and the ClusterTransformation[MoleculeTransformation] is an optional
              argument which definies a transformation of the cluster[molecule].
              The cluster and molecule names are case sensitive. The MoleculeName
              must be defined in a Mole block.

  .. compound::

    The **Disp** block contains information about transformations of one of the clusters in the format: ::

      Disp
        ClusterName  NumberOfSteps Transformation
        ...........  ............. ......... .....
        ClusterName  NumberOfSteps Transformation
      End

    where the ClusterName is a name of one of the clusters which has been defined in **Clus** block, the NumberOfSteps is a number of steps in which transformation will be reached, the Transformation is a translation or rotation. Any kind of transformations must be provided line by line in the **Disp**\lacement block and number of transformations is not limited. It means that any row of the DISPlacement block contains information about different transformations. Any new configuration is simply generated from the previous configuration. In this point we can construct final transformation, from the starting configuration to current configuration, as a product of all previous transformations for given subsystem. The :program:`MkNemo` will store final transformation in order :math:`TR`.

  .. xmldoc:: %%Keyword: DISP <basic>
              The Disp block contains information about transformations
              of one of the clusters in the format:

                Disp
                  ClusterName : NumberOfSteps Transformation
                  ........... : ............. ......... .....
                  ClusterName : NumberOfSteps Transformation
                End

              where the ClusterName is a name one of the clusters which has been
              defined in Clus block, the NumberOfSteps is a number of steps in which
              transformation will be reached, and the Transformation is a translation
              or rotation operation.

  Any atomic coordinates and vectors of transformations must be provided in a.u. units. The coordinates of transformation vector can be separated by space or a comma. Moreover, the **Mole**\cule blocks must be provided first, then the **Clus**\ter blocks must appear, and finally **Disp**\lacement block. In a mixed order, the :program:`MkNemo` will not be able to recognize a label of molecule[cluster] defined below a block which is using it.

  An execution of :program:`MkNemo` module within defined **Mole**, **Clus**, and **Disp** blocks in an input will generate a two coordinate files, named MKNEMO.Axyz and MNEMO.Bxyz. Those files contain coordinates of atoms for clusters :math:`B` and :math:`A` respectively, and can be used directly in the :program:`SEWARD` and :program:`GATEWAY` (see documentation of :program:`GATEWAY` for COORD keyword).

  By default, the :program:`Seward` or :program:`Gateway` will apply symmetry, so **user must be aware that the displacement transformation can break symmetry of the system and the** :program:`MkNemo` **does not control it**. If you do not want use symmetry see documentation of :program:`Seward` or :program:`Gateway` for details.

  Example: ::

    &MkNemo&End

      * Molecules definitions

      Mole : H2o
       H   1.43  0.0  1.07
       H  -1.43  0.0  1.07
       O   0.00  0.0  0.00
      End

      Mole : Cm3+
       Cm  0.0 0.0 0.0
      End

      * Clusters definitions

      Clus : Cm3+H2o
       H2o  [0.0 0.0 -1.0] [0.0 1.0 0.0 180.0]
       Cm3+
      End

      Clus : H2O [0.0 0.0 2.0]
       H2o  [0.0 0.0 1.0]
      End

      Disp
        Cm3+H2o   : 3 [0.0,0.0,3.0]
        Cm3+H2o   : 1 [0.0,3.0 0.0]
        H2O       : 2 [0.0 0.0,1.0 90.0]
      End

    End Of Input

  In this example, we define two molecules, H2o and Cm3+. Then we define a Cm3+H2o cluster which has been build from H2o and Cm3+ molecule. The H2o molecule has been rotated around Y-axis by the 180 degree and translated along Z-axis by 2 a.u. The Cm3+ molecule stays unchanged. The second cluster, named H2O has been constructed from translated H2o molecule. The H2o molecule has been translated along Z-axis by 1 a.u. Then the H2O cluster has been translated along Z-direction by 2 a.u. In the **Disp** block Cm3+H2o subsystem is translated by vector [0,0,3] in the three steps. Then, in the second row we define translation of H2O cluster by vector [0,3,0] in one step. Finally we rotate H2O cluster by 90 degree around [0,0,1] vector in the two steps. The total number of different configurations is simply a sum of steps: 9=3+1+2+first configuration.

:kword:`GETE`
  The **GetE**\nergy block is used to read total energy stored at RUNFILE, and to save it into the MKNEMO.Conf file. The argument of GetEnergy block must be present and it must be a label from the list below. Use

  .. container:: list

    **S1** to save the energy of super-system at the first level of theory,

    **S2** to save the energy of super-system at the second level of theory,

    **A1** to save the energy of the A-subsystem with virtual orbitals of B-subsystem at the first level of theory,

    **A2** to save the energy of the A-subsystem with virtual orbitals of B-subsystem at the second level of theory,

    **B1** to save the energy of the B-subsystem with virtual orbitals of A-subsystem at the first level of theory,

    **B2** to save the energy of the B-subsystem with virtual orbitals of A-subsystem at the second level of theory.

  Please note, that :program:`MkNemo` does not have any possibility to check what kind of total energy was computed in the previous step by any |molcas| module. The user has to pay attention on what kind of energy was computed in the previous step.

  Example: ::

    &MkNemo&End
      GetE
        A1
    End Of Input

  In this case the total energy which has been computed by a |molcas| module will be saved as energy of the A-subsystem with virtual orbitals of B-subsystem at the first level of theory.

  .. xmldoc:: %%Keyword: GETE <basic>
              The GETEnergy block is used to read total energy stored at RUNFILE,
              and to save it into the MKNEMO.Conf file. The format of this block is

                &MkNemo&End
                 GetE
                   Arg
                End Of Input

              where the Arg must be any label from the list below. Use

              S1 -- to save the energy of super-system at the first level of theory,
              S2 -- to save the energy of super-system at the second level of theory,
              A1 -- to save the energy of the A-subsystem with virtual orbitals of
                    the B-subsystem at the first level of theory,
              A2 -- to save the energy of the A-subsystem with virtual orbitals of
                    the B-subsystem at the second level of theory,
              B1 -- to save the energy of the B-subsystem with virtual orbitals of
                    the A-subsystem at the first level of theory,
              B2 -- to save the energy of the B-subsystem with virtual orbitals of
                    the A-subsystem at the second level of theory.

              Please note, that MKNEMO does not have any possibility to check what
              kind of total energy was computed in the previous step by called
              MOLCAS module.

:kword:`NEXT`
  The **Next** block is used to save all information about potential curve from previous step into the MKNEMO.Nemo file (the command Next will move data from MKNEMO.Conf file into MKNEMO. Nemo file and will delete MKNEMO.Conf file) and to continue or break an EMIL's loop. **This block cannot be used before Mole, Clus, and Disp blocks.**

  Example: ::

    &MkNemo&End
      Next
    End Of Input

  .. xmldoc:: %%Keyword: NEXT <basic>
              The NEXT block is used to generate new configuration according to displacements
              provided in the DISPlacement block and to save all information about potential
              curve from previous step into the MKNEMO.Nemo file. This block cannot be used
              before Mole, Clus, and Disp blocks.
              Format:

                &MkNemo&End
                  Next
                End Of Input

:kword:`TEST`
  The **TEST** block CAN BE ONLY USED to save verification data for |molcas| command *verify*.

  Example: ::

    &MkNemo&End
      Test
    End Of Input

  .. xmldoc:: %%Keyword: TEST <basic>
              The TEST block CAN BE ONLY USED to save verification data for MOLCAS command verify.
              Format:

                &MkNemo&End
                  Test
                End Of Input

Finally the structure of a standard input file for :program:`MkNemo` module has the following form: ::

  * Loop over configurations

  >>>>>>>>>>>>>>>>>>> Do While <<<<<<<<<<<<<<<<<<<<

    &MkNemo&End

      * Molecules definitions

      Mole : MoleculeName
        AtomLabel  x  y  z
        .........  .. .. ..
        AtomLabel  x  y  z
      End

      ....................

      Mole : MoleculeName
        AtomLabel  x  y  z
        .........  .. .. ..
        AtomLabel  x  y  z
      End

      *
      Clus : ClusterName  ClusterTransformation
        MoleculeName  MoleculeTransformation
        ............  ......................
        MoleculeName
        MoleculeName
      End

      Clus : ClusterName  ClusterTransformation
        MoleculeName  MoleculeTransformation
        ............
        MoleculeName
      End

      Disp
        ClusterName  NumberOfSteps [x y z alpha]
        ClusterName  NumberOfSteps [x y z]
        ...........  ............. .............
        ClusterName  NumberOfSteps [x y z alpha]
      End

    End Of Input

    *************** SUPER-SYSTEM CALCULATION *********************

    * Calculation of integrals
    &Seward
      coord=$Project.MkNemo.Axyz
      coord=$Project.MkNemo.Bxyz
      basis=........
       ................................

    * Energy calculation on the first level of the theory
    &Scf
       ...............................

    * Save energy
    &MkNemo
      GetE=S1

    * Energy calculation on the second level of the theory
    &MBPT2
       ...............................

    * Save energy
    &MkNemo
      GetE=S2

    *************** A-SUBSYSTEM CALCULATION *********************

    * Calculation of integrals
    &Seward
      coord=$Project.MkNemo.Axyz
      coord=$Project.MkNemo.Bxyz
      * the B-subsytem has charge equal to zero
      BSSE=2
      basis=........
       ................................

    * Energy calculation on the first level of the theory
    &Scf
       ...............................

    * Save energy
    &MkNemo&End
      GetE=A1

    * Energy calculation on the second level of the theory
    &MBPT2
       ...............................

    * Save energy
    &MkNemo
      GetE=A2

    *************** B-SUBSYSTEM CALCULATION *********************

    * Calculation of integrals
    &Seward
      coord=$Project.MkNemo.Axyz
      coord=$Project.MkNemo.Bxyz
      * the A-subsytem has charge equal to zero
      BSSE=1
      basis=........
       ................................

    * Energy calculation on the first level of the theory
    &Scf
       ...............................

    * Save energy
    &MkNemo
      GetE=B1

    * Energy calculation on the second level of the theory
    &MBPT2
       ...............................

    * Save energy and take next configuration
    &MkNemo
      GetE=B2; Next

  >>>>>>>>>>>>>>>>>>> EndDo <<<<<<<<<<<<<<<<<<<<

Example: ::

  *
  * Loop over all configurations
  *
  >>>>>>>>>>>>>>>>>>> Do While <<<<<<<<<<<<<<<<<<<<

    *
    * H2O and H2O clusters
    *
    &MkNemo&End

      * Molecules definitions

      Mole : H2O
       H   1.43  0.0  1.07
       H  -1.43  0.0  1.07
       O   0.00  0.0  0.00
      End

      * Clusters definitions

      Clus : H2O
       H2O : [0.0 1.0 0.0 180.0]
      End

      Clus : h2o [ 0.0 0.0 2.0]
       H2O
      End

      Disp
        h2o : 10 [0.0  0.0, 5.0       ]
        h2o : 10 [0.0, 0.0, 20.0      ]
        h2o : 18 [0.0  0.0  1.0  180.0]
      End

    End Of Input

    *************** SUPER-SYSTEM CALCULATION *********************

    * Calculation of integrals

    &Seward
      NEMO
      Title=Sypersystem
      Douglas-Kroll
      ANGM= 0.0 0.0 0.0; AMFI
      COORD=$Project.MkNemo.Axyz;Coord=$Project.MkNemo.Bxyz
      basis=H.ano-rcc...2s1p.,O.ano-rcc.Roos..4s3p2d1f.

    * Energy calculation on the first level of the theory
    &Scf
      Title=Supersystem; Occupied=10; Iterations=30; Disk=1 0

    * Save energy
    &MkNemo
      GetE=S1

    * Energy calculation on the second level of the theory
    &MBPT2
      Title=Sypersystem; Threshold=1.0d-14 1.0d-14 1.0d-14

    * Save energy
    &MkNemo
      GetE=S2

    *************** A-SUBSYSTEM CALCULATION *********************

    * Calculation of integrals

    &Seward
      NEMO
      Title=A-system
      Douglas-Kroll
      ANGM= 0.0 0.0 0.0; AMFI
      COORD=$Project.MkNemo.Axyz;Coord=$Project.MkNemo.Bxyz
      basis=H.ano-rcc...2s1p.,O.ano-rcc.Roos..4s3p2d1f.
      BSSE=2

    * Energy calculation on the first level of the theory
    &Scf
      Title=A-subsystem; Occupied=5; Iterations=30; Disk=1 0

    * Save energy
    &MkNemo
      GetE=A1

    * Energy calculation on the second level of the theory
    &MBPT2
      Title=A-subsystem; Threshold=1.0d-14 1.0d-14 1.0d-14

    * Save energy
    &MkNemo
      GetE=A2

    *************** B-SUBSYSTEM CALCULATION *********************

    * Calculation of integrals

    &Seward
      NEMO
      Title=A-system
      Douglas-Kroll
      ANGM= 0.0 0.0 0.0; AMFI
      COORD=$Project.MkNemo.Axyz;Coord=$Project.MkNemo.Bxyz
      basis=H.ano-rcc...2s1p.,O.ano-rcc.Roos..4s3p2d1f.
      BSSE=1

    * Energy calculation on the first level of the theory

     &Scf
       Title=B-subsystem; Occupied=5; Iterations=30; Disk=1 0

     * Save energy
     &MkNemo
       GetE=B1

    * Energy calculation on the second level of the theory
     &MBPT2
       Title=B-subsytem; Threshold= 1.0d-14 1.0d-14 1.0d-14

    * Save energy and take next configuration
     &MkNemo
      GetE=B2; Next

  >>>>>>>>>>>>>>>>>>> EndDo <<<<<<<<<<<<<<<<<<<<

In this example we calculate potential energy curve for interaction between two water clusters. The A-cluster, H2O, was rotated around Y-axis about 180 degrees. The B-subsystem, h2o,has been translated along Z-axis by 2 a.u.. In the **Disp** block we have defined 20 translation operations for h2o cluster and 18 rotation operations for H2O cluster. For energy calculations of super-system, A-subsystem, and B-subsystem, at first level of theory we used SCF module, and MBPT2 at second level of theory, respectively. After a calculation of energy we save calculated results using keyword **GetE** with proper argument in the MKNEMO.Conf file of :program:`MkNemo` module. Finally, by calling block **Next** of :program:`MkNemo`, we save all informations about potential for given configuration and we generate new configuration. This procedure will be repeated for all translations and rotations defined in the Displacement block.

Input files
...........

Apart from the standard input unit :program:`MkNemo` will use the following input files.

.. class:: filelist

:file:`MKNEMO.Input`
  A :program:`MkNemo`'s input file contains the latest preprocessed input.

:file:`MKNEMO.Restart`
  The MKNEMO.Restart is a restart file, which will be generated by :program:`MkNemo` at the first run if the file does not exist. Any call of **group of command: Mole, Clus, and Disp** will be updated and the restart file is saved in user's $CurrDir. If :program:`MkNemo` calculation crashes, one can fix a reason of crash, copy restart and MKNEMO.Nemo files to $WorkDir, and run the calculation again. The :program:`MkNemo` will restart calculation from the last point which has been finished successfully. If the MKNEMO.Nemo file will not be copied the :program:`MkNemo` will generate a new one and will overwrite the file in your $CurrDirr if any exist. Beware of it.

  .. compound::

    The restart file is formated: ::

      <Restart>   RowInDisp   Step'sNum LoopControl</Restart>

    where the RowInDisp is the index of currently used row in the **Disp** block and the Step'sNum is the current number of step for a given displacement's row. Ex. If a displacement row, RowInDisp, is 3, which corresponds to a displacement row, H2O 4 [0,4,0], and Step'sNum is equal to 2 then it means that current displacement vector is [0,2,0]. The LoopControl parameter is a return code. The command **Next** will read this value and use it to continue looping or breaking a loop.

:file:`MKNEMO.Conf`
  .. compound::

    The MKNEMO.Conf is a file which stores block **Mole**, **Clus**, and **Energies** in similar format like it is define in the input of the:program:`MkNemo`, but within XML format. The propose of this file is to share definition of molecules, clusters, and energies between different blocks of namelist, :kword:`&MkNemo`. A format of this file is: ::

      * Configuration definition - contains informations
      * about configuration
      <Configuration>

        * Definition of molecule
        <Molecule Name=''Name of molecule''>
          labelOfAtom x  y  z
          ........... .. .. ..
          labelOfAtom x  y  z
        </Molecule>

        ....................................

        <Molecule Name=''Name of molecule''>
          labelOfAtom x  y  z
          ........... .. .. ..
          labelOfAtom x  y  z
        </Molecule>

        * Definition of cluster
        <Cluster Name=''Name of cluster A'' Transformation=''x y z q0 q1 q2 q3''>
          labelOfMolecule x' y' z'  q0' q1' q2' a3'
          ............... .. .. ..  ..  ..  ..  ..
          labelOfMolecule x' y' z'  q0' q1' q2' a3'
        </Cluster>

        <Cluster Name=''Name of cluster B'' Transformation=''x y z q0 q1 q2 q3''>
          labelOfMolecule x' y' z'  q0' q1' q2' a3'
          ............... .. .. ..  ..  ..  ..  ..
          labelOfMolecule x' y' z'  q0' q1' q2' a3'
        </Cluster>

        * Enerigies definition
        <Energies>
          EnegyLabel MethodLabel Energy
          .......... ........... ......
          EnegyLabel MethodLabel Energy
        </Energies>
      </Configuration>

    where the EnergyLabel is one of labels defined in the {\bf GetE} block, the MethodLabel is a name of method which has been used to calculate energy, and Energy is a vector of eigenvalues. The **Next** command will save energy information into a MKNEMO.Nemo file, and will clear this file. Hacking hint: If you want to use :program:`Rassi` then do not use call of command **GetE** but postprocess output and print eigenvalues to the MKNEMO.Conf file in the right format (use ! in user input to execute shell command for postprocessing of output)

Files of the :program:`SEWARD`, :program:`SCF`, :program:`RASSCF`, :program:`MBPT2`, :program:`MOTRA`, :program:`CCSDT`, and :program:`CASPT2` modules are needed to get total energy on each level of theory for subsystems and super-system.

Output files
............

In addition to the standard output unit :program:`MkNemo` will generate the following files.

.. class:: filelist

:file:`MKNEMO.Axyz`, :file:`MKNEMO.Bxyz`
  .. compound::

    The MKNEMO.*xyz file is a file of coordinates in format: ::

      NumberOfAtoms
      AdditionalLine
      AtomLabel x  y  z
      ......... .. .. ..
      AtomLabel x  y  z

    where the NumberOfAtoms is a number of atoms in the file, the AdditionalLine is a line where one can provide unit of coordinate (currently :program:`MkNemo` supports only a.u.), the AtomLabel is a label of atom, and x, y, z is a vector of coordinates.

:file:`RUNFILE`
  A file with informations needed by the block of |molcas|.

:file:`MKNEMO.Nemo`
  .. compound::

    On this file :program:`MkNemo` will store all information about intermolecular potential in the NEMO file format. This format is used by :program:`NEMO` to fit intermolecular potential to the NEMO model. The format of this file is defined as follows: ::

      <Nemo>
        * Definition of configuration
        <Configuration>
          .............................
        </Configuration>

        .............................

        <Configuration>
          .............................
        </Configuration>

      </Nemo>

    where configuration block is defined like in the MKNEMO.Conf.

.. _UG\:sec\:mknemo_dependencies:

Dependencies
------------

The :program:`MkNemo` depends on the modules of |molcas| program, which calculate the total energy of the system.
.. index::
   single: Program; QMstat
   single: QMstat

.. _UG\:sec\:qmstat:

:program:`qmstat`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:qmstat_description:

Description
-----------

.. xmldoc:: <MODULE NAME="QMSTAT">
            %%Description:
            <HELP>
            Under construction
            </HELP>

:program:`QmStat` couples a quantum chemical region to a
statistically mechanically described surrounding thus creating
an effective Hamiltonian for the quantum chemical region
:math:`H_{\text{eff.}}`. This way solvent effects can be
accounted for.

The surrounding is discrete in contrast to the
continuum models, such as PCM (also available in |molcas|, see
:program:`Seward`). The explicit representation of the solvent
enables a more accurate description of the solvation,
but also makes the model more complex and significantly
less "black-box".
For example, the interaction within the statistical
mechanical surrounding has to be accounted for with an
accurate enough force-field. In its present implementation
:program:`QmStat` only treats water as described by an early
version of NEMO, which includes polarization of the
molecules :cite:`Wallqvist:90`. Also, the interaction
between the quantum chemical region (typically the solute) and
the surrounding (typically the solvent) has to be considered
in more detail than in a continuum model.
Several approaches to discrete (or explicit) solvation are
thus possible.
The approach in :program:`QmStat` is summarized below, see
also :cite:`Moriarty:96,Ohrn:06a,Ohrn:07a,Ohrn:Thesis`.

To include entropic effects to the solvation phenomena,
:program:`QmStat` uses the Metropolis--Monte Carlo simulation
technique. This means that random steps are taken in the
space of solute--solvent configurations, some of which are
accepted, others rejected, on account of the usual energy
difference criteria. This implies that at each step, an
energy has to be evaluated. Using normal quantum chemical
methods, this is usually too restrictive, since roughly one
million Monte Carlo steps are required to converge the statistical
mechanical treatment. :program:`QmStat` proceeds by doing
simplifications to the quantum chemistry, not the statistical
mechanics, as is the more common way forward. :program:`QmStat`
is therefore a *hybrid* QM/MM methods (according to one
existing terminology).

Two simplified quantum chemical methods are presently available:
orbital basis Hartree--Fock and a state basis formulation, which
is approximate to the CASSCF method. Both formulations uses the
fact that there is only minor differences in the electronic
structure for the different configurations in the Monte Carlo
simulation. Therefore, a basis as general as the standard atomic
orbital basis sets is redundant. :program:`QmStat` constructs
either a more compact orbital basis or a more compact basis
in terms of states to expand the solvated wave function. This
requires some work before the simulation, but has the advantage
that during the simulation, less computational work is
needed.

Finally, a comment on the way the energy is computed for a given
configuration is needed. The evaluation of the interactions between the solvent
molecules is prescribed by the construction of the force-field and
are relatively simple.
The interaction between the quantum chemical region and the
solvent is formulated to include electrostatic and non-electrostatic
interactions. The former is described in a multi-center multipole
expanded way, while the latter models the effect the antisymmetry
principle between solute and solvent electrons has on the
solute electronic structure. Its formulation is similar to
pseudo-potentials. Also a phenomenological term for the dispersion
is added. Long range electrostatics, finally, is described with a
dielectric cavity model.

.. _UG\:sec\:qmstat_dependencies:

Dependencies
------------

The dependencies of :program:`QmStat` differ for the two quantum
chemical methods. In the Hartree--Fock description, :program:`Seward`,
:program:`FfPt`, :program:`Scf`, :program:`Averd`, :program:`MpProp` and
:program:`Motra` typically have to precede. If an orbital basis is taken from
somewhere else :program:`FfPt`, :program:`Scf` and :program:`Averd`
are not mandatory. For the RASSI alternative, typically
:program:`Seward`, :program:`Scf`, :program:`RasScf`, :program:`MpProp`
and :program:`Rassi` precede :program:`QmStat`.

.. _UG\:sec\:qmstat_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`QmStat`.

Input files
...........

.. class:: filelist

:file:`ONEINT`
  One-electron integral file generated by the program :program:`SEWARD`.

:file:`RUNFILE`
  File for communication of auxiliary information generated by the program
  :program:`SEWARD`.

:file:`RUNFILEW`
  File for communication of auxiliary information generated by the program
  :program:`SEWARD` for the solvent molecule.

:file:`AVEORB`
  (Only for Hartree--Fock alternative). Average orbitals generated by :program:`AVERD`.
  If other orbitals are to
  be used, they should be given the above name; in other words, the orbitals
  must not be created by :program:`AVERD`, it is only customary.

:file:`SOLORB`
  Solvent orbitals generated by :program:`SCF`.

:file:`TRAONE`
  (Only for Hartree--Fock alternative). Molecular orbital transformed one-electron
  integrals generated by :program:`MOTRA`.

:file:`TRAINT`
  (Only for Hartree--Fock alternative). Molecular orbital transformed two-electron
  integral generated by :program:`MOTRA`.

:file:`MPPROP`
  File generated by :program:`MPPROP`.

:file:`DIFFPR`
  Exponents and Prefactors for a Slater desciption of the Electrostatics to take
  into account the penetration effects due to the overlap. File generated by :program:`MPPROP`.

:file:`RASSIM`
  (Only for the RASSI alternative). The transition density matrix generated
  by :program:`RASSI`. The keyword :kword:`TOFILE` has to be given in
  the input to :program:`RASSI`.

:file:`EIGV`
  (Only for the RASSI alternative). Information about the eigenvectors and
  their energy generated by :program:`RASSI` (:kword:`TOFILE` needed).

:file:`ADDON*`
  File with additional one-electron perturbation to be added
  to the Hamiltonian matrix. This file is only required if :kword:`EXTERNAL`
  is used.

Output files
............

.. class:: filelist

:file:`STFIL*`
  Start files in which solvent configurations are stored at intervals during
  the simulation. They enable the simulation to restart, hence they can
  also be as input to :program:`Qmstat`.

:file:`SAFIL*`
  Sampling files in which a selection of configurations are stored for
  analysis. They can in some applications also act as input to :program:`Qmstat`,
  usually in free-energy perturbation calculations.

:file:`EXTRA*`
  Extract files which are formatted files in which data from the analysis
  of the sampling files are stored.

.. _UG\:sec\:qmstat_input:

Input
-----

The complexity inherit in a discrete solvent model engenders a,
potentially, complex input. To (hopefully) make the input transparent
the set of keywords are ordered in several tiers. Below all keywords and
their sub- and subsubkeywords are presented.
A keyword with several tiers should typically be of the
following form ::

  SIMUlation
  ...(keywords on higher tier)
  END simulation

Also consult the input example below and the examples in
:numref:`TUT:sec:cavity` for guidance. Mandatory keywords
are highlighted.

.. class:: keywordlist

:kword:`TITLe`
  Title to the calculation.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="TITLE" LEVEL="UNDOCUMENTED" KIND="STRING" />

:kword:`SIMUlation`
  Keywords relating to the how the simulation is to be performed and under
  which conditions.

  * **RADIus** Initial radius of the dielectric cavity. The radius is also
    specified on the startfile and has higher priority than the radius given
    with the present keyword.
  * **PERMittivity** Permittivity of the dielectric continuum. 80 on
    default.
  * **TEMPerature** Temperature in kelvin. Default is 300.
  * **PRESsure** Macroscopic pressure in atmosphere. Default is 1 atm.
  * **SURFace** Surface tension parameter for the cavity. Default is
    for air--water interface.
  * **TRANslation** Maximal translation in the simulation
    (in a.u.) Default is 0.0 a.u.
  * **ROTAtion** Maximal angle for rotation of solvent around
    molecular axes. Default is 0\ |o|.
  * **CAVIty** Maximal modification of radius of dielectric cavity.
    Default is 0.0 a.u.
  * **FORCe** Force constant for the harmonic potential that presents
    a bias in the simulation for configurations with the QM-region close
    to the center of the cavity. Default is 0.001.
  * **BREPulsion** Parameter for the Repulsion energy that keeps the QM-region away from the boundary. Default is 0.0 a.u.
  * **SEED** Seed to the pseudo-random number generator.
  * **PARAlleltemp** A parallel tempering procedure is performed to boost sampling. It is mainly used in systems with small transition elements in the Markov chain, which will give difficult samplings. Three lines follow: First line
    gives the number of different temperatures to perform the simulation, :math:`N_{\text{Temp}}`. In the second line :math:`N_{\text{Temp}}` integers are given, each of these specify a file to store the configuration for each temperature. Third line gives the :math:`N_{\text{Temp}}` temperatures used
    for the tempering procedure.
  * **END_Simulation Parameters** Marks the end of the input to the simulation parameters.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="SIMULATION" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="RADIUS" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="PERMITTIVITY" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="TEMPERATURE" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="PRESSURE" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="SURFACE" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="TRANSLATION" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="ROTATION" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="CAVITY" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="FORCE" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="SEED" LEVEL="UNDOCUMENTED" KIND="INT" />

  .. xmldoc:: </GROUP>

:kword:`THREshold`
  Followed by three numbers. First the threshold for the induced
  dipoles in the generalized self-consistent field method for the solution
  of the mutual polarization problem is specified. Second the the threshold
  for the energy in the same method is given. Finally the maximum
  number of iterations in the method is specified. Defaults are 0.0001 0.0000001
  and 30.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="THRESHOLD" LEVEL="UNDOCUMENTED" KIND="REALS" SIZE="3" />

:kword:`STEPs`
  Followed by two entries. Number of macrosteps and number of microsteps.
  The total number of steps is the product of the two numbers above. At
  the end of each macrostep the relevant STFIL is up-dated. Default
  is 1 and 1.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="STEPS" LEVEL="UNDOCUMENTED" KIND="INTS" SIZE="2" />

:kword:`RUN`
  Specify type of simulation. "QMEQ" means quantum chemical equilibration;
  only the startfile is up-dated. "QMPR" means quantum chemical
  production; startfile is up-dated and sampfile constructed. **Observe**
  that if "QMPR" is specified a line with two entries follows in which
  the interval of sampling is specified and on which sampfile (1-7) the
  data is to be stored. "ANAL" means an analysis of the stored results
  is to be performed.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="RUN" LEVEL="UNDOCUMENTED" KIND="RADIO">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="QMEQ" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="QMPR" LEVEL="UNDOCUMENTED" KIND="INTS" SIZE="2" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="ANAL" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: </GROUP>

:kword:`PRINt`
  Print level. 1 is default and anything above this number can generate
  large outputs. No higher than 10 is recommended for non-developers.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="PRINT" LEVEL="UNDOCUMENTED" KIND="INT" />

:kword:`EXTErnal`
  An external perturbation is to be added to the Hamiltonian
  in the Rassi alternative. The arguments are number of perturbation
  matrices, :math:`N`, followed by :math:`N` lines. Each line has the form: :math:`c_i` a scalar
  with which the perturbation can be scaled, :math:`V_i` is a character string with
  the label of the perturbation as given on SEWARD's one-electron integral file,
  :math:`nc_i` is the component number of the perturbation.
  A final expression for the perturbation would be: :math:`c_1V_1(nc_1)+c_2V_2(nc_2)+\cdots+c_NV_N(nc_N)`.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="EXTERNAL" LEVEL="UNDOCUMENTED" KIND="CUSTOM" />

:kword:`CONFiguration`
  Keywords relating to from which source the initial solvent
  configuration is to be obtained. *It is mandatory to
  specify a source.*

  * **ADD** Followed by one number specifying how many solvent
    molecules that are to be added at random to the cavity. This is the
    worst way to start a simulation since it will take a lot of time to
    equilibrate the system.
  * **FILE** Signify that start configuration is to be read from
    some file.

    * **STARtfile** Read solvent configuration from startfile.

      * **SCRAtch** Read solvent configuration from startfile and place
        the QM-region as given on :file:`RUNFILE`.
      * **COPY** Read solvent and QM configuration from startfile.
        This is he keyword to use if a simulation is to be restarted.
        **Observe** that consistent startfile and :file:`RUNFILE` must be used.
      * **CM_,_** Read solvent configuration from startfile and place
        the QM in the center of mass of the QM placed on startfile.
        For any of the previous keywords two numbers are given, :math:`N_{\text{in}}` and :math:`N_{\text{out}}` which specify from
        which startfile :program:`QmStat` is supposed to read and write,
        respectively

    * **SAMPfile** Read solvent configurations put on a
      sampfile and analyze them. Two numbers are given, :math:`N_{\text{in}}` and
      :math:`N_{\text{extr}}` which specify from which sampfile :program:`QmStat` is
      supposed to read and on which extract file the results are to
      be put.

  * **INPUt** The starting configuration is to be read from
    the input. The coordinates are given after the keyword
    :kword:`COORdinates` in the second tier to the :kword:`SOLVent`
    keyword. One number as argument: the startfile to which
    configurations are written.
  * **END_Configuration** Marks the end of the input to the initial configuration.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="CONFIGURATION" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="ADD" LEVEL="UNDOCUMENTED" KIND="INT" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="INPUT" LEVEL="UNDOCUMENTED" KIND="INT" />

  .. xmldoc:: </GROUP>

:kword:`EDIT`
  Signify that a startfile is to be edited. If this keyword is
  given, then no simulation will be performed.

  * **DELEte** Two rows follow; on the first :math:`N_{\text{in}}` and :math:`N_{\text{out}}`
    are given which specify the startfile to read from and write to,
    respectively; on the second the number of solvent molecules to
    delete. The solvent molecules farthest away from origin are
    deleted.
  * **ADD** The form of the arguments as :kword:`DELEte`
    above, only the second row give number of molecules to add.
    **Observe** that the keyword :kword:`RADIus` will with the
    present keyword specified give the radius of the cavity of
    the edited startfile.
  * **QMDElete** Delete the QM-region and substitute it by water molecules.
    One row follows with two numbers, which specify the startfile to read from and write to, respectively.
  * **DUMP** Dump startfile coordinates in a way suitable for graphical display.
    Two rows follow; on the first a character string with the format the coordinated
    will be dumped; on the second :math:`N_{\text{in}}` specifies the startfile to read.
    Currently there is only one format for this keyword: :kword:`MOLDen`.
  * **END_EditStartFile** Marks the end of the input to edit the startfile.

:kword:`QMSUrrounding`
  Keywords that are related to the interaction between surrounding
  and the quantum chemical region.

  * **DPARameters**
    Parameters for the dispersion interaction.
    Follow :math:`N` lines, with :math:`N` the number of atoms in the QM-region. The general form for each line is: :math:`d_1` and :math:`d_2` where :math:`d_1` is the dispersion parameter between one atom of the QM-region and the water oxygen, and :math:`d_2` is the same but regarding to the hydrogen of the water. The order of the QM atoms is given by :file:`RUNFILE`.
  * **ELECtrostatic**
    Parameters to describe the electrostatic penetration using Slater integrals.

    * **THREsholds**
      Two number follow. First, the cutoff (distance Quantum Site-Classical molecule) to evaluate penetration effects. Default is 6 a.u.
      Second, difference between two Slater exponents to not be consider the same value. Default is 0.001.
    * **NOPEnetration**
      No electric penetration is considered in the calculations. Penetration is considered by default.
    * **QUADrupoles**
      Electrostatic Penetration computed in quadrupoles. Default is that penetration is computed up to dipoles.
    * **END Electrostatic**
      Marks the end of the input to the electrostatic penetration computed by Slater.

  * **XPARameters**
    Parameters to describe the repulsion energy.

    * **S2**
      The parameter for the :math:`\sim S^2` term. Default zero.
    * **S4**
      The parameter for the :math:`\sim S^4` term. Default zero.
    * **S6**
      The parameter for the :math:`\sim S^6` term. Default zero.
    * **S10**
      The parameter for the :math:`\sim S^{10}` term. Default zero.
    * **CUTOff**
      Two numbers follow. The first is the cut-off radius such as if
      any distance from the given solvent molecule is longer than
      this number, the overlap term is set to zero. The second
      is a cut-off radius such as if any distance from the given
      solvent molecule is shorter than this number the energy is
      set to infinity, or practically speaking, this configuration is
      rejected with certainty. Defaults are 10.0 a.u.~and 0.0 a.u.
    * **END XParameters** Marks the end of the input to the repulsive parameters.

  * **DAMPing**

    * **DISPersion**
      Input parameters to a dispersion damping expression. The parameters
      are numbers obtained from a quantum chemical calculation. All lines
      have the form: :math:`C_{\text{val}}`, :math:`Q_{xx}`, :math:`Q_{yy}`, :math:`Q_{zz}` where
      :math:`C_{\text{val}}` is the valence charge and :math:`Q_{**}` are diagonal terms
      in the quadrupole tensor. First two lines are for the hydrogen
      atom then the oxygen atom in a water molecule. Next follows as
      many lines as atoms in the QM region. All these quantities
      can be obtained from a calculation with :program:`MpProp`.
      The numbers are given as input so that the user can if it is found
      to be needed, modify the damping. Default is no damping.
      The order of the atoms in the QM region is given by :file:`RUNFILE`.
    * **FIELd**
      The electric field between QM region and surrounding is damped.
      Three numbers are arguments: :math:`C_{\text{O}}`, :math:`C_{\text{H}}`, :math:`N` where they are
      parameters to a field damping expression
      (:math:`E=\tilde{E}(1-e^{C_x R})^N`) where :math:`x` is :math:`\text{O}` if the point
      in the surrounding is on a oxygen atom, :math:`\text{H}` if on a hydrogen
      atom; :math:`R` is the distance between the point in the QM region
      and the points in the surrounding.
    * **END Damping**
      Marks the end of the input to the Damping parameters.

  * **END QmSurrounding**
    Marks the end of the input related to the interaction between surrounding
    and the quantum chemical region.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="QMSURROUNDING" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="DPARAMETERS" LEVEL="UNDOCUMENTED" KIND="CUSTOM" />

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="ELECTROSTATIC" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="NOPENETRATION" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: </GROUP>

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="XPARAMETERS" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="S2" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="S4" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="S6" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="CUTOFF" LEVEL="UNDOCUMENTED" KIND="REALS" SIZE="2" />

  .. xmldoc:: </GROUP>

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="DAMPING" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="DISPERSION" LEVEL="UNDOCUMENTED" KIND="CUSTOM" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="FIELD" LEVEL="UNDOCUMENTED" KIND="REALS" SIZE="3" />

  .. xmldoc:: </GROUP>

  .. xmldoc:: </GROUP>

:kword:`SOLVent`
  Keywords that govern the solvent-solvent interaction and some
  other initial data. Most of these numbers are presently fixed
  and should not be altered.

  * **COORdinates**
    If solvent coordinates are to be given explicitly in input. First
    line gives number of particles to add. Then follows three times
    that number lines with coordinates for the oxygen atom and the
    hydrogen atoms.
    If the keyword :kword:`SINGle-point` has been given the
    present keyword assumes a different meaning (see description
    of :kword:`SINGle-point`).
  * **CAVRepulsion**
    Two parameters that regulate the repulsion with the boundary
    of the cavity. Defaults are 30.0 and 0.06.
  * **ATCEchpol**
    Five numbers follow: number of atoms, centers, charges, polarizabilities and
    slater sites. Defaults are 3, 5, 4, 3 and 5, respectively.
  * **CHARge**
    Four numbers follow: the partial charge on the hydrogen atoms
    and the partial charge on the pseudo-centers.
  * **POLArizability**
    Three numbers follow: the polarizability on the oxygen atom
    and on the two hydrogen atoms.
  * **SLATer**
    Magnitude of Slater Prefactors and exponents. One mumber follow: 0 is slater description of electrostatics up to charges, 1 up to dipoles.
    Then it follows N times (where N is the number of Slater centers) three lines if description up to charge. First line Slater exponent
    for charges, second line Slater Prefactor and third line nuclear charge of the center. If the description goes up to dipole, N times
    five lines follows. First two lines are the same as charge description, third line is Slater exponent for dipole, fourth line is the
    three Slater Prefactors for the dipole (one for each cartesian coordinate) and fith line is the nuclear charge of the center. Defaults: See papers of Karlstrom. If the number of Slater sites is modified this keyword should be after :kword:`ATCEchpol`
  * **END Solvent**
    Marks the end of the input that govern the solvent-solvent interaction.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="SOLVENT" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="COORDINATES" LEVEL="UNDOCUMENTED" KIND="REALS_COMPUTED" SIZE="9" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="ATCECHPOL" LEVEL="UNDOCUMENTED" KIND="INTS" SIZE="5" />

  .. xmldoc:: </GROUP>

:kword:`RASSisection`
  This section provides the information needed to perform QMSTAT calculations
  using the RASSI-construction of the wave function.

  * **JOBFiles** First number give the number of JOB-files
    that was generated by :program:`RasScf` (i.e., how many
    RASSCF calculations that preceded :program:`QmStat`). The
    following numbers (as many as the number of JOB-files) specify
    how many states each calculation rendered. So for example if
    a State-Average (SA) RASSCF calculation is performed with two
    states, the number should be 2.
  * **EQSTate** Which state interacts with the surrounding.
    Should be 1 if it is the ground state, which also is the
    default.
  * **MOREduce** A Reduction of the Molecular Orbitals is performed.
    One number as argument: the threshold giving the value of the lowest
    occupation number of the selected natural orbitals :cite:`Ohrn:07a`.
  * **CONTract** The RASSI state basis are contracted.
    One number as argument: the threshold giving the value of the lowest
    RASSCF overlap for the RASSI state basis :cite:`Ohrn:07a`.
  * **LEVElshift** Introduce levelshift of RASSI states. Three lines must be written.
    First line gives the number of levelshifts to perform. Then follows the states
    to levelshift (as many as the number of levelshifts). Finally, the value of the
    levelshift for each state is given.
  * **CISElect** The QM solvent overlap is used as the criterion to choose
    the state that interacts with the surrounding. Three lines follow. One entire:
    among how many states can be chosen the interacting state, :math:`N`. The
    second line, :math:`N` entries giving the number of each state. Finally, :math:`N` scaling
    factors, one for each state, of the overlap.
  * **END RassiSection**
    Marks the end of the input that govern the Rassi calculations.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="RASSISECTION" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="JOBFILES" LEVEL="UNDOCUMENTED" KIND="INTS_COMPUTED" SIZE="1" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="EQSTATE" LEVEL="UNDOCUMENTED" KIND="INT" />

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="MOREDUCE" LEVEL="UNDOCUMENTED" KIND="REAL" />

  .. xmldoc:: </GROUP>

:kword:`SCFSection`
  This section provides additional information to perform QMSTAT calculations
  using the SCF-construction of the wave function.

  * **ORBItals**
    Two numbers are required: how many orbitals that are to be used
    how many occupied orbitals there are in the QM region.
    as a basis in which to solve the Hartree--Fock equation, and
  * **END ScfSection**
    Marks the end of the input that govern the SCF calculations.

  .. xmldoc:: <GROUP MODULE="QMSTAT" NAME="SCFSECTION" LEVEL="UNDOCUMENTED" KIND="BLOCK">

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="ORBITALS" LEVEL="UNDOCUMENTED" KIND="INTS" SIZE="2" />

  .. xmldoc:: </GROUP>

:kword:`SINGle-point`
  This keywords signals that a set of single point calculations
  should be performed; this is typically what one needs when
  fitting parameters. The keyword gives the :kword:`COORdinates`
  keyword in the :kword:`SOLVent` section a new meaning. The first
  row then gives the number of points in which a single-point calculation
  should be performed and the coordinates that follow give the
  coordinates for the water monomer. :program:`QmStat` then run each
  solute-monomer solvent configuration specified and the energy (among
  other things) is computed. The keyword
  thus overrides
  the usual meaning of the input. **Observe** that the permittivity
  has to be set to 1 if one attempts to reproduce a quantum chemical
  supermolecular potential.

  .. xmldoc:: <KEYWORD MODULE="QMSTAT" NAME="SINGLE-POINT" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`EXTRact Section`
  Give details about the analysis performed to the results stored in the
  sampfile.

  * **TOTAl energy**
    The total energy of the whole system is extracted.
  * **DIPOle**
    The three components and the total dipole of the QM-region are extracted.
  * **QUADrupole**
    The six components and the quadrupole of the QM-region are extracted.
  * **EIGEn**
    The Eigenvalues of the RASSI matrix and the eigenvectors are extracted.
    Follow by a number and a "YES" or "NON" statement. The number gives the
    highest state where the eigenvalue is extracted. YES means that also the
    corresponding eigenvectors are extracted.
  * **EXPEctation values**
    The expectation values of :math:`H_0` and main perturbations: :math:`V_{\text{el}}`, :math:`V_{\text{pol}}` and
    :math:`V_{\text{n}-\text{el}}` are extracted. If keyword :kword:`EIGEn` is specified it is done
    for the same states as this keyword, otherwise the extraction is performed for
    the equilibrated state. **Observe** that the expectation values are for the
    final wave function of the QM-region in solution, so :math:`H_0` is not the same as
    for the isolated QM-region.
  * **ELOCal**
    The local expectation values of :math:`V_{\text{el}}` and :math:`V_{\text{pol}}` for the multipole
    expansion sites are extracted. Two lines follow. First, gives for how many sites
    these values will be extracted, :math:`N`. Second line, :math:`N` entries giving the number
    of each site. If keyword :kword:`EIGEn` is specified the extraction is done
    for the same states as this keyword, otherwise it is performed for the
    equilibrated state.
  * **MESP**
    The Main Electrostatic potential, field and field gradients will
    be obtained in order to produce perturbation integrals that will
    be used to optimize the intramolecular geometry of the QM system.
    **Observe** that this keyword will change the one electron integrals file,
    so it is advised to make a copy of the original file.
    After running this option ALASKA and SLAPAF must be running with the new one
    electron integrals file in order to produce the gradients and a new geometry
    in the geometry optimization procedure.
  * **END ExtractSection**
    Marks the end of the input that give details about the analysis performed.

Input example
.............

The following input uses the Rassi alternative and restarts from
startfile.0 and write to startfile.1 every 1000th step, where
the total number of steps is 200*1000. A set of parameters are
given which are for an organic molecule with one carbon,
one oxygen and two hydrogen atoms. The order in the previous
SEWARD and RASSCF calculations for the atoms is carbon,
oxygen, hydrogen 1 and hydrogen 2. The dispersion is damped. Finally,
there are sixteen RASSCF calculations preceeding and the last
two are state-average since two states are collected from these
files; the ground state interacts with the surrounding. ::

  &QmStat &End

  Simulation       * Simulation parameters.
  Translation
  0.03             * Maximun translation step of water.
  Rotation
  1.0              * Maximun rotation step of water.
  Cavity
  0.05             * Maximun variation of the cavity radius for step.
  End Simulation

  Steps            * Number of macro and microsteps.
  200 1000

  Configuration    * How the start configuration is readed.
  Start            * The cordinates are taken form a startfile.
  Copy             * The coordinates of the QM region are the same as in the startfile.
  0 1
  End Configuration

  QmSurrounding
  DParameters      * Dispersion parameters.
  35.356 4.556     * Carbon_{QM}-Oxygen_{wat}     Carbon_{QM}-Hydrogen_{wat}.
  16.517 2.129     * Oxygen_{QM}-Oxygen_{wat}     Oxygen_{QM}-Hydrogen_{wat}.
  10.904 1.405     * Hydrogen1_{QM}-Oxygen_{wat}  Hydrogen1_{QM}-Hydrogen_{wat}.
  10.904 1.405     * Hydrogen2_{QM}-Oxygen_{wat}  Hydrogen2_{QM}-Hydrogen_{wat}.

  XParameters      * QM-Solvent Repulsion Parameters.
  S2
  -0.375
  S6
  1.7
  End XParameters
  Damping          * Dispersion Damping.
  Dispersion
  -6.64838476  -5.22591434  -4.32517889 -4.58504467     * Water Hydrogen.
  -.34146881   -0.21833165  -0.22092206 -0.21923063     * Water Oxygen.
  -4.23157193  -1.91850438  -2.28125523  -1.91682521    * Quamtum Carbon.
  -6.19610865  -3.90535461  -4.73256142  -3.77737447    * Quantum Oxygen.
  -.57795931   -0.42899268  -0.43228880  -0.43771290    * Quantum Hydrogen 1.
  -.57795931   -0.42899268  -0.43228880  -0.43771290    * Quantum Hydrogen 2.
  End Damping
  End QmSurrounding

  RassiSection
  JobFiles          * Number of JobFiles.
  16
  1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2      * One state is collected form all JobFiles
  *                                      except from the two last ones, which two
  *                                      are collected.
  EqState           * The state interacting with the surrounding.
  1
  End RassiSection

  End of Input

.. xmldoc:: </MODULE>
.. index::
   single: Program; ESPF
   single: ESPF

.. _UG\:sec\:espf:

:program:`espf` (+ QM/MM interface)
===================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:espf_description:

Description
-----------

.. xmldoc:: <MODULE NAME="ESPF">
            %%Description:
            <HELP>
            The ElectroStatic Potential Fitted (ESPF) method adds contributions
            to the one-electron hamiltonian to compute the interaction between
            the charge distribution and any external electrostatic potential,
            field, and field derivatives. This module may be used for QM/MM
            computations. Use of symmetry is forbidden.
            </HELP>

.. compound::

  The ElectroStatic Potential Fitted (ESPF) method adds contributions to the one-electron Hamiltonian for computing the interaction between the charge distribution in |molcas| and *any* external electrostatic potential, field, and field derivatives. The approximate interaction energy is expressed as:

  .. math:: \Delta E^{\text{ESPF}} = \left ( \sum_a \braopket {\Psi} {Q^a} {\Psi} + Z_a \right ) V^a

  with :math:`Q^a` a multipole-like operator whose matrix elements are fitted to the electron potential integrals (determined on a grid surrounding the QM atoms) and :math:`V^a` the *external* electrostatic potential (and derivatives) at nucleus :math:`a`. Both energy and gradient computations are available. A call to :program:`ESPF` right after :program:`SEWARD` is required to carry out such calculations.

*NOTE:* Always run :program:`SEWARD` + :program:`ESPF`. If not, very strange results may happen due to interactions counted twice or more!

*NOTE:* Symmetry is ignored since the external potential usually breaks the one given in :program:`GATEWAY`.

If no external potential is given, the :program:`ESPF` module can be used to compute atomic point charges fitted to the electrostatic potential produced by the nuclei and electrons.

ESPF and QM/MM
--------------

Whereas the ESPF method can be used standalone, it has been developed for hybrid quantum mechanics/molecular mechanics (QM/MM) computations, in which an extended molecular system is divided into two subsystems: the "active" center described by any QM method and its surroundings qualitatively treated with an empirical atomic forcefield. The current implementation can be used with either a modified version of the :program:`TINKER` program or with the :program:`GROMACS` program as MM code.

Using |molcas| together with :program:`Tinker`
..............................................

In order to obtain the modified :program:`TINKER` code, you must run the ":command:`molcas get_tinker`" command.

The current patched version of :program:`TINKER`\ [#fn1]_ is **6.3.3**.

.. [#fn1] https://dasher.wustl.edu/tinker/

*IMPORTANT:* The environment variable :variable:`TINKER` must point to the directory in which the :program:`TINKER` executable binaries are stored (usually in :file:`$MOLCAS/tinker/bin`).

The most convenient way to define (i) the QM and MM subsystems and (ii) which atoms are to be known by |molcas| (all the QM ones and some MM ones, see below) requires to simply add the keyword :kword:`TINKER` in :program:`GATEWAY`. This way, :program:`GATEWAY` will ask :program:`TINKER` to pass it all information needed.

Alternatively, the normal coordinate input in :program:`GATEWAY` can be used. For MM atoms that are to be known by |molcas|, if the atomic symbol is Xx, specify ``Xx...... / MM`` or ``Xx_MM`` in native or XYZ format, respectively. In this case you should make sure there is no mismatch between the |molcas| and :program:`TINKER` coordinates.

A final option is specifying :kword:`COORD`, with the atom labels to be used |molcas| and some dummy coordinates; and then :kword:`TINKER`, which will pick up the :program:`TINKER` coordinates, but keep the |molcas| labels. In order to use this combination, the :kword:`Expert` keyword must be specified before :kword:`TINKER` too.

Using |molcas| together with :program:`Gromacs`
...............................................

The interface to :program:`GROMACS` differs from the :program:`TINKER` interface in that the MM code is not run as a separate program but included in |molcas| as a library. In this way, the communication between the QM and MM codes is handled by simple function calls instead of using data files. The interface is automatically installed along with |molcas| provided that the :program:`GROMACS` library (currently a development version\ [#fn2]_) is available at configuration time\ [#fn3]_. Instructions how to install the :program:`GROMACS` library can be found at the official web site\ [#fn4]_. Make sure that the installation is done in double precision since this is the precision used by |molcas|. Also make sure to source the :program:`GROMACS` GMXR script in your shell startup file. otherwise the |molcas| configuration procedure will not be able to detect the relevant library path.

.. [#fn2] https://repo.or.cz/w/gromacs.git/shortlog/refs/heads/qmmm
.. [#fn3] Configuration with CMake requires the flag ``-D GROMACS=ON``
.. [#fn4] https://www.gromacs.org/

The recommended (and the only verified) approach of using the |molcas|/:program:`GROMACS` interface is to define the full QM+MM system in the :program:`GROMACS` input. The system definition can then be imported into |molcas| by adding the keyword :kword:`GROMACS` in :program:`GATEWAY` (see :numref:`UG:sec:gateway` for details). For efficiency reasons, the |molcas| part of the interface separates the MM subsystem into two different atom types: *inner* MM atoms and *outer* MM atoms. These are completely equivalent as far as interactions are concerned. However, whereas the coordinates of the inner MM atoms are stored and updated using |molcas| standard mechanism, the outer MM atoms are handled using a mechanism specifically designed with large systems in mind. The division into inner and outer MM atoms can be controlled with options to the :kword:`GROMACS` keyword in :program:`GATEWAY` (see :numref:`UG:sec:gateway`).

Please note that the |molcas|/:program:`GROMACS` interface is still under development and is currently provided for evaluation purposes only.

The QM/MM method
................

.. compound::

  The Hamiltonian of the full QM/MM system is divided into three terms:

  .. math:: H=H_{\text{QM}}+H_{\text{MM}}+H_{\text{QM/MM}}

  The first one describes the QM part as it would be *in vacuo*, the second one describes the surroundings using a classical MM forcefield and the last one deals with the interactions between the QM and the MM subsystems. In its usual formulation, the last term is (for :math:`q` point charges interacting with :math:`N` nuclei and :math:`n` electrons):

  .. math:: H_{\text{QM/MM}}=\sum_{a=1}^{q}\sum_{b=1}^{N}\frac{Q_{a}Z_{b}}{R_{ab}}-
          \sum_{a=1}^{q}\sum_{i=1}^{n}\frac{Q_{a}}{r_{ai}}+\sum_{a=1}^{q}\sum_{b=1}^{N}E_{ab}^{\text{vdw}}+
          E^{\text{bonded}}

The first two terms deal with the electrostatic interactions between the QM charge distribution and the MM electrostatic potential. In |molcas| the ESPF method is used for this purpose.
A short-range van der Waals term is added (van der Waals parameters are assigned to all the atoms --- both QM and MM). If the frontier between the two subsystems involves a bond, some empirical bonded terms may also be used. For the sake of simplicity, the standard MM parameters are kept unchanged for the MM atoms but should be modified (or calculated) for the QM atoms (e.g. it may be necessary to fit the QM van der Waals parameters).

The usual forcefields use the "1--4 condition" to separate the bonded interactions (stretching, bending, torsion) from the non-bonded ones (electrostatic and vdw). This means than the non-bonded potentials are applied only if atoms are separated by 3 bonds or more. As for the QM/MM interactions, this procedure is kept with the exception that all the QM atoms experience the electrostatic potential generated by *all* the MM point charges (the QM/MM frontier case is considered later).

*NOTE:* Starting with |molcasviii|, all MM point charges interact with the QM charge distribution using the ESPF method (at variance with previous |molcas| versions in which the few MM atoms defined in :program:`GATEWAY` were interacting directly with the QM electrons and nuclei).

Link atoms
..........

When no bonds are involved between the QM and the MM parts, the QM/MM frontier definition is obvious and only the electrostatic and vdw interactions are taken into account. However, if one or several chemical bonds exist, the definition of a smooth but realistic frontier is needed. Several schemes, more or less sophisticated, have been proposed. In the current implementation, only the most basic one, the link atom (LA) approach is included. In the LA approach, each QM/MM bond that should be cut is saturated with a monovalent atom --- most often a hydrogen atom --- on the QM side. The position of a link atom is often restrained: frozen distance from the corresponding QM frontier atom and always on the segment defined by the two frontier atoms (Morokuma's method, selected by the :kword:`LAMOROKUMA` keyword).

From the macromolecular point of view, link atoms do not exist, i.e. they should not interact with the MM part. However, this leads to severe overpolarization of the frontier, due to unbalanced interactions. Hence interactions between the link atoms and the MM potential is kept. To remove problems that may arise from too strong interactions between a link atom and the closest MM point charges, these point charges may be spread in the MM neighborhood. For instance, in a protein, this procedure is mainly justified if the MM frontier atom is an :math:`\alpha` carbon (Amber- or Charmm-typed forcefields usually set these point charges close to zero).

Geometry optimization --- microiterations
.........................................

In a QM/MM geometry optimization job, a |molcas| step costs as hundreds of :program:`TINKER` or :program:`GROMACS` steps. Thus it is very convenient to use the microiteration technique, that is, converging the MM subsystem geometry every |molcas| step. In the case of :program:`TINKER`, this is requested in the :program:`TINKER` keyword file, whereas if :program:`GROMACS` is used, it is requested directly in :program:`ESPF`. In order to improve the optimization convergence, an improved QM/MM Hessian can be built in :program:`SLAPAF` using the :kword:`RHIDDEN` keyword (note that adding the keyword :kword:`CARTESIAN` may help too).

.. TEMPORARILY REMOVED.
   The :program:`TINKER` package incorporates several polarizable forcefields, eg Amoeba, based on the induced dipoles approach. They can be selected for a QM/MM calculation. In that case, both the QM wavefunction and the MM induced dipoles are converged self-consistently during the SCF procedure, similarly to reaction-field calculations. In case of a State-Average CASSCF calculation, you must use the :kword:`RFRoot` keyword (see :program:`RASSCF`) to select the electronic state which is electrostatically coupled to the polarizable surroundings.

.. _UG\:sec\:espf_dependencies:

Dependencies
------------

The :program:`ESPF` program depends on :program:`SEWARD` for modifying the core Hamiltonian matrix and on :program:`ALASKA` for computing the extra contributions to the gradient.

.. index::
   pair: Files; ESPF

.. _UG\:sec\:espf_files:

Files
-----

:program:`ESPF` will use the following input
files: :file:`RYSRW`, :file:`ABDATA`, :file:`RUNFILE`, :file:`ONEINT` (for more information see :numref:`UG:sec:files_list`).
In addition, :program:`ESPF` uses :file:`ESPFINP` (the ESPF input file) and :file:`SEWARINP` (the Seward input file).

Please note that the external potential can be given within a file, separated from the :program:`ESPF` input file.

In calculations using the |molcas|/:program:`GROMACS` interface, :program:`ESPF` will additionally need access to the :program:`GROMACS` tpr file.

Intermediate files
..................

All the intermediate files are related to the use of :program:`ESPF` together :program:`TINKER`. The files allow for communication between the :program:`ESPF` program and the MM code. |molcas| uses one file to pass the QM atoms coordinates and ESPF-derived point charges to :program:`TINKER`. :program:`TINKER` uses the same file to pass the external potential, the MM-only energy and gradient components to |molcas|.

.. class:: filelist

:file:`TINKER.LOG`
  The log file of the Tinker run.

:file:`$Project.xyz`
  The coordinate file for :program:`TINKER`.

:file:`$Project.key`
  The keyword file for :program:`TINKER`.

:file:`$Project.qmmm`
  The communication file between |molcas| and :program:`TINKER`.

Output files
............

.. class:: filelist

:file:`ONEINT`
  One-electron integral file generated by the :program:`SEWARD` program.

:file:`RUNFILE`
  Communication file for subsequent programs.

:file:`ESPF.DATA`
  Ascii file containing some specific informations needed for subsequent calls to the :program:`ESPF` module.

:file:`GMX.LOG`
  Logfile for the :program:`GROMACS` library routines.

.. _UG\:sec\:espf_input:

Input
-----

Below follows a description of the input to :program:`ESPF`.

In addition to the keywords and the comment lines the input may contain blank lines. The input for each module is preceded by its name like: ::

  &ESPF

Compulsory keywords

.. class:: keywordlist

:kword:`EXTErnal`
  Specify how the external potential is given. This keyword is compulsory in the first run of :program:`ESPF`. On the next line, one integer or a text string must be given:

  * One integer :math:`n` is given. If :math:`n` is 0, the next lines give the numbering, the values for the external potential, the field and field gradients for each atom. If :math:`n` is greater than 0, the :math:`n` next lines specify the sources of the external potential, each line gives three cartesian coordinates, one point charge, and (optionally) three dipole components. If Å is used as the length unit, the :kword:`ANGSTROM` keyword must be given right after :math:`n`.
  * The :kword:`NONE` word means that no external potential is given. Accordingly, the :program:`ESPF` module will compute the atomic point charges (and optionally dipoles) deriving from the electrostatic potential due to all electrons and nuclei.
  * The word is :kword:`TINKER`, which means that the current job is a QM/MM job using the |molcas|/:program:`TINKER` interface. Accordingly the external potential will be computed directly by :program:`TINKER`. Note that :program:`TINKER` requires at least two input files, ending with .xyz (coordinates) and .key (keywords). These files must share the name of the current |molcas| project. Optionally, you can add the :kword:`MULLIKEN` or :kword:`LOPROP` keyword after :kword:`TINKER`: it indicates what kind of charges are passed to :program:`TINKER`. These charges may be used during the MM microiterations. If no keyword is given, the ESPF multipoles are selected.
  * The word is :kword:`GROMACS`, which means that the current job is a QM/MM job using the |molcas|/:program:`GROMACS` interface, with the external potential computed by :program:`GROMACS`. The binary input file read by :program:`GROMACS`, the so-called tpr file, must be named as ":file:`topol.tpr`" and must be manually copied to the working directory. As above, a second keyword on the same line can be used to select the type of multipoles sent to the MM code. Default is to use the ESPF multipoles.

  * Any other word. The following characters up to the next space are taken as a file name and the rest of the line is ignored. Instead, the full input (including the first line) is read from the specified file and must follow the syntax specified above.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="EXTERNAL" APPEAR="External potential" INPUT="REQUIRED" KIND="CUSTOM" LEVEL="BASIC">
               <ALTERNATE KIND="CHOICE" LIST="NONE,TINKER,GROMACS" />
               <ALTERNATE KIND="STRING" />
               %%Keyword: External potential <basic>
               %%Tested ##055 ##803
               <HELP>
               Specify how the external potential is given. Can be given inline or in another file.
               </HELP>
               </KEYWORD>

Optional keywords

.. class:: keywordlist

:kword:`TITLE`
  Title of the job.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
               %%Keyword: Title <basic>
               <HELP>
               One line following this one is regarded as title.
               </HELP>
               </KEYWORD>

:kword:`MULTipoleorder`
  Multipolar order of the ESPF operators. For :program:`TINKER`, allowed values are 0 (charge-like) or 1 (charge- and dipole-like). For :program:`GROMACS`, only 0 is allowed. Default value is 0.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="MULT" APPEAR="Multipole order" KIND="INT" DEFAULT_VALUE="0" LEVEL="ADVANCED">
               %%Keyword: MultipoleOrder <basic>
               %%Tested ##803
               <HELP>
               Give the order of the ESPF operators. Only 0 (charge) or 1 (charge and
               dipole).
               </HELP>
               </KEYWORD>

:kword:`GRID`
  Modify the grid specifications. The grid is made of points belonging to molecular surfaces defined according to the van der Waals radii of each quantum atom. Two schemes are available. The first one is the GEPOL procedure, as implemented into the PCM SCRF method. The other one is called PNT and is the default. On the next line, first select the method with the GEPOL or PNT option. On the same line, one integer number and one real number are given if PNT is selected. The first one gives the maximum number of shells around the van der Waals surface of the quantum atoms. The second one gives the distance between the shells. Note that all points within the van der Waals envelope are discarded to avoid the penetration effects. Default values are 4 shells separated by 1 Å.
  Alternatively, if GEPOL is selected, the same line must contain 1 integer indicating the number of surfaces to be computed (must be < 6).

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="GRID" APPEAR="Grid spec." KIND="STRING" LEVEL="ADVANCED">
               %%Keyword: Grid <advanced>
               %%Tested ##803
               <HELP>
               Modify the grid specifications.
               </HELP>
               </KEYWORD>

:kword:`SHOW`
  Requires the printing of the ESPF.DATA file.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="SHOW" KIND="SINGLE" LEVEL="ADVANCED">
               %%Keyword: Show <advanced>
               %%Tested NONE
               <HELP>
               Printing of the ESPF.DATA file.
               </HELP>
               </KEYWORD>

:kword:`LAMOrokuma`
  Activate the Morokuma scheme for scaling the link atom positions in a QM/MM calculation. Note that in the case of :program:`TINKER`, the scaling factor is currently hard-coded and is determined from the radii of the atoms involved in the QM/MM frontier bond. This differs from the :program:`GROMACS` interface in which this factor must be provided by the user through the :kword:`LINKATOMS` keyword in :program:`GATEWAY`.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="LAMO" KIND="SINGLE" LEVEL="ADVANCED">
               %%Keyword: LAMorokuma <advanced>
               %%Tested ##055
               <HELP>
               Set on the Morokuma's scheme for scaling the link atom positions.
               </HELP>
               </KEYWORD>

:kword:`MMITerations`
  Maximum number of microiterations used to optimize the outer MM atoms in a |molcas|/:program:`GROMACS` run. The default is 0, which disables microiterations and leaves the outer MM atoms frozen. For the :program:`TINKER` interface, microiterations are requested in the :program:`TINKER` keyword file.

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="MMIT" KIND="INT" LEVEL="BASIC">
               %%Keyword: MMIterations <basic>
               <HELP>
               Maximum number of microiterations to optimize the MM subsystem (with Gromacs interface).
               </HELP>
               </KEYWORD>

:kword:`MMCOnvergence`
  Convergence threshold for the MM microiterations (:program:`GROMACS` only). The optimization of the (outer) MM atoms will stop when the maximum force component is smaller than this number, in atomic units. The default is 0.001 atomic units (50 kJ/mol/nm).

  .. xmldoc::  <KEYWORD MODULE="ESPF" NAME="MMCO" KIND="REAL" LEVEL="BASIC">
               %%Keyword: MMConvergence <basic>
               <HELP>
               Convergence for the MM microiterations (with Gromacs interface).
               </HELP>
               </KEYWORD>

.. xmldoc:: </MODULE>

Examples
--------

ESPF example
............

This is a typical input for the calculation of the energy and the gradient of a glycine molecule feeling the external potential of 209 TIP3P water molecules.

.. extractfile:: ug/ESPF.input

  &Gateway
  Basis set
  C.sto-3g.....
    C1   1.11820     0.72542    -2.75821 Angstrom
    C2   1.20948     0.66728    -1.25125 Angstrom
  End of basis
  Basis set
  O.sto-3g.....
    O1   2.19794     1.10343    -0.67629 Angstrom
  End of basis
  Basis set
  H.sto-3g.....
    H1   2.02325     1.18861    -3.14886 Angstrom
    H2   0.25129     1.31794    -3.04374 Angstrom
    H3   1.02458    -0.28460    -3.15222 Angstrom
  End of basis
  Basis set
  N.sto-3g.....
    N1   0.17609     0.12714    -0.61129 Angstrom
  End of basis
  Basis set
  C.sto-3g.....
    C3   0.09389    -0.01123     0.84259 Angstrom
    C4  -1.21244    -0.67109     1.28727 Angstrom
  End of basis
  Basis set
  O.sto-3g.....
    O2  -2.06502    -1.02710     0.48964 Angstrom
  End of basis
  Basis set
  H.sto-3g.....
    H4  -0.61006    -0.21446    -1.14521 Angstrom
    H5   0.92981    -0.61562     1.19497 Angstrom
    H6   0.16338     0.97444     1.30285 Angstrom
  End of basis
  Basis set
  N.sto-3g.....
    N2  -1.41884    -0.85884     2.57374 Angstrom
  End of basis
  Basis set
  H.sto-3g.....
    H7  -0.73630    -0.57661     3.25250 Angstrom
    H8  -2.28943    -1.29548     2.82140 Angstrom
  End of basis

  &seward

  &espf
  MultipoleOrder = 0
  External = 0
  1  -0.048 -0.002 -0.006 -0.001  0.007 -0.009  0.002 -0.001  0.001 -0.001
  2  -0.047 -0.002  0.001 -0.002  0.003  0.000 -0.004  0.000 -0.001  0.000
  3  -0.053  0.004  0.000 -0.011  0.002  0.002 -0.004  0.002  0.003 -0.007
  4  -0.046  0.011 -0.009 -0.001  0.006 -0.005 -0.001  0.003  0.003 -0.004
  5  -0.042 -0.016 -0.011 -0.006  0.005 -0.007  0.003 -0.004 -0.001 -0.005
  6  -0.050  0.000  0.008  0.001  0.006 -0.006  0.000 -0.002  0.000 -0.001
  7  -0.039 -0.008  0.001  0.000  0.001 -0.002  0.001 -0.001 -0.001 -0.001
  8  -0.032 -0.007 -0.002  0.004  0.002 -0.003  0.001 -0.002  0.002 -0.001
  9  -0.011 -0.009  0.004  0.001  0.002  0.000 -0.002 -0.001  0.001  0.001
  10  0.000 -0.011  0.003  0.004  0.001  0.002 -0.003  0.001 -0.001  0.001
  11 -0.028 -0.008  0.004 -0.001 -0.001 -0.002  0.002 -0.001  0.001 -0.002
  12 -0.026  0.003 -0.008  0.014  0.002 -0.001 -0.001 -0.008  0.006 -0.009
  13 -0.037 -0.008 -0.003  0.004 -0.007  0.007  0.000  0.001  0.007 -0.001
  14 -0.016 -0.007  0.007 -0.008  0.003  0.003 -0.006  0.000  0.002  0.002
  15 -0.025  0.003  0.012 -0.007  0.003 -0.001 -0.002 -0.006  0.005  0.009
  16 -0.010 -0.011  0.000 -0.014  0.001  0.007 -0.008  0.001  0.000 -0.001

  &scf
  Charge = 0

  &alaska

|molcas|/:program:`Tinker` example
..................................

A typical start for a QM/MM calculation with the |molcas|/:program:`TINKER` interface is given in the following input. It is quite general since all the information related to the QM and MM subsystem definitions are already included in the :program:`TINKER` key file.

.. extractfile:: ug/QMMM.input

  > EXPORT TINKER=$MOLCAS/tinker/bin_qmmm
  > COPY $PATH_TO/$Project.xyz $WorkDir/$Project.xyz
  > COPY $PATH_TO/$Project.key $WorkDir/$Project.key

   &Gateway
  Tinker
  Basis = STO-3G
  Group = Nosym

   &Seward

   &Espf
  External = Tinker
  LAMorok

This can be used, e.g. with the following :program:`TINKER` files. In this example, the asparate anion is cut into two pieces, the QM subsystem contains the end of the side-chain until the :math:`\beta` carbon atom. There is a link atom between the QM :math:`\beta` and MM :math:`\alpha` carbon atoms.

QMMM.xyz

.. extractfile:: ug/QMMM.xyz

  16  ASP
   1 N3    -0.040452    0.189961    0.173219   448     2     6    14    15
   2 CT    -0.011045   -0.060807    1.622395   449     1     3     7    11
   3 C      1.446535   -0.110535    2.028518   450     2     4     5
   4 O      1.902105    0.960982    2.409042   452     3
   5 O      2.137861   -0.898168    1.387158   452     3
   6 H      0.559257   -0.496270   -0.262338   451     1
   7 CT    -0.789906   -1.336520    1.982558   216     2     8    12    13
   8 C     -2.256402   -1.184505    1.571038   218     7     9    10
   9 O2    -2.460769   -0.949098    0.356151   219     8
  10 O2    -3.120135   -1.188969    2.465678   219     8
  11 H1    -0.478878    0.773493    2.145163   453     2
  12 HC    -0.356094   -2.194944    1.466324   217     7
  13 HC    -0.720511   -1.505463    3.058628   217     7
  14 H     -0.996208    0.061130   -0.151911   451     1
  15 H      0.304306    1.116522   -0.018698   451     1
  16 HLA   -0.283317   -0.506767    1.748300  2999     2     7

QMMM.key

.. extractfile:: ug/QMMM.key

  * Change $PATH_TO_TINKER
  parameters $PATH_TO_TINKER/params/amber99.prm
  QMMM 8
  QM -8 10 7 12 13
  MM 2
  LA 16
  * Add the atom type for the LA
  atom   2999    99    HLA     "Hydrogen Link Atom"        1      1.008     0
  charge -2  0.0
  charge -11 0.0
  QMMM-MICROITERATION ON

|molcas|/:program:`Gromacs` example
...................................

To be provided soon.
.. index::
   single: Program; SCF
   single: SCF

.. _UG\:sec\:scf:

:program:`scf`
==============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:scf_description:

Description
-----------

.. xmldoc:: <MODULE NAME="SCF">
            %%Description:
            <HELP>
            The SCF program of the molcas program system generates
            closed-shell Hartree-Fock, open-shell UHF, and Kohn Sham DFT wave functions.
            </HELP>

The :program:`SCF` program of the |molcas| program system generates
closed-shell Hartree--Fock, open-shell UHF, and Kohn Sham DFT wave functions.

The construction of the Fock
matrices is either done conventionally from the two-electron integral
file :file:`ORDINT`,
which was generated in a previous step by the :program:`SEWARD`
integral code, or alternatively (only for closed shell calculations)
integral-direct by recomputing all the
two-electron integrals when needed :cite:`AlmlofFaegriKorsell_DirSCF`.
The later route is recommended for
large basis sets or molecules, when the two-electron integral file would
become extensively large. It is automatically taken, when the :program:`SCF`
program cannot find any :file:`ORDINT` file in the work directory.
The direct Fock matrix construction employs an efficient integral prescreening
scheme, which is based on differential densities
:cite:`CremerGauss_SCFprescreening,HaeserAhlrichs_SCFprescreening`: only
those AO integrals are computed, where the estimated contractions with the
related differential density matrix elements give significant (Coulomb or
exchange) contributions to the (differential) two-electron part of the Fock
matrix. Integral prescreening is performed at two levels, (i) at the level
of shell quadruples, and (ii) at the level of individual primitive Gaussians.
Prescreening at the level of contracted functions is not supported, because
this would be inefficient in the context of a general contraction scheme.
In order to work with differential density and Fock matrices, a history of
these entities over previous iterations has to be kept. All these matrices
are partly kept in memory, and partly held on disk. The :program:`SCF` program
either works with simple differences of the actual and the previous density,
or alternatively with minimized densities, obtained from linear combinations
of the actual density and all the previous minimized densities.

Besides the conventional and the fully-direct algorithms there is also a
semi-direct path, which allows for the storage of some of the AO integrals
during the first iteration, which then are retrieved from disk in subsequent
iterations. That path is taken, if the keyword :kword:`DISK` with an
appropriate
argument specifying the amount of AO integrals to store is found on the
input stream. The semi-direct path is recommended for medium sized problems,
where the two-electron integral file would become a bit too large (but not
orders of magnitude).

.. compound::

  The program contains a feature that allows you to make the
  orbitals partially populated during the aufbau procedure.
  This feature is not primarily intended to accelerate the convergence
  but rather to ensure that you do get convergence in
  difficult cases.
  The orbitals are populated with with electrons according to

  .. math:: \eta_i=\frac{2}{1+e^{(\varepsilon_i-\varepsilon_f)/kT}}

  where
  :math:`\varepsilon_i`
  is the orbital energy of orbital :math:`i` and
  :math:`\varepsilon_f`
  is the Fermi energy.
  In this "Fermi aufbau" procedure
  the temperature is slowly lowered until it reaches a minimum
  value and then kept constant until
  a stable closed shell configuration is determined.
  Then normal SCF iterations will be performed with the selected
  closed shell configuration.
  For systems that are not really closed shell systems, for example
  diradicals, you might end up in the situation that the program
  does not find any stable closed shell configuration.
  In that case it will continue to optimize the closed shell
  energy functional with partial occupation numbers.
  If this is the case, this is probably what you want, and such
  orbitals would be ideal as starting orbitals for an MCSCF
  calculation.

The initial orbital guess is either obtained by diagonalizing the bare nuclei
Hamiltonian, from an initial guess produced by the module :program:`Guessorb`
or from orbitals of a previous Hartree--Fock SCF calculation.
These starting orbitals are automatically located in the order

#. SCF orbitals from a previous calculation located in the :file:`RUNFILE`

#. SCF orbitals from a previous calculation located in a formatted orbitals file, :file:`INPORB`.

#. initial guess orbitals from module :program:`Guessorb` located in the :file:`RUNFILE` and

The program has three types of convergence accelerating schemes:
(i) dynamic damping :cite:`Karlstroem_SCFdyndumping`, (ii) the :math:`C^2`\-DIIS method
using the orbital gradient as error vector :cite:`c2-diis`, and (iii)
a combined second-order update/\ :math:`C^2`\-DIIS procedure. The latter eliminates the
Brillouin violating elements of the Fock matrix by proper orbital rotations
and hence avoids diagonalization of the Fock matrix: the approximate inverse
Hessian is updated (BFGS) in a first step, and then the new orbital
displacement vector is obtained from the updated Hessian using :math:`C^2`\-DIIS
extrapolation :cite:`FischerAlmloef_OrbRot`.
Dynamic damping gives substantial improvements in highly anharmonic
regions of the energy hyper surface, while the second-order
update/\ :math:`C^2`\-DIIS procedure exhibits excellent convergence for less anharmonic
regions. By default, dynamic damping is used during the first few iterations.
When the change in the density between two subsequent iterations drops below
a certain threshold the second-order update/\ :math:`C^2`\-DIIS procedure kicks in.
It is also possible to use the older first order :math:`C^2`\-DIIS scheme instead of
the second-order update/\ :math:`C^2`\-DIIS procedure by setting the density threshold
for the latter to zero in the corresponding input card (keyword
:kword:`QNRThreshold`).

By default :program:`SCF` behaves in different ways depending on what
kind of start orbitals are found according to

#. No start orbitals are found. In this case the core hamiltonian
   is diagonalized and these orbitals are used as start.
   The "Fermi aufbau" procedure is used until a stable configuration is found.

#. Start orbitals from :program:`Guessorb` are found.
   In this case the HOMO LUMO gap is analyzed and if it is small
   the "Fermi aufbau" procedure is used until a stable configuration is found.
   Otherwise the configuration suggested by :program:`Guessorb` is used.

#. Start orbitals from a previous :program:`SCF` calculation is found.
   The configuration from the previous :program:`SCF` calculation is used,
   unless some problem is detected such as partial occupation numbers
   from an unconverged calculation. In the latter case "Fermi aufbau" is used.

#. Start orbitals from an :file:`INPORB` is in the same way as for
   start orbitals from an :program:`SCF` calculation, see last point.

This behavior can be changed by suitable keywords described below.

One of the main objects of the :program:`SCF` program in the context of the
|molcas| program system is to generate starting
orbitals for subsequent MCSCF calculations.
Two options are available to
improve the canonical Hartree--Fock orbitals in this respect.

(i) It is possible to specify pseudo occupation numbers that are neither
zero nor two, thus simulating to some extent an open shell system. The
resulting wavefunction does not have any physical meaning, but will
provide better starting orbitals for open shell systems.

(ii) Usually, the lowest virtual canonical Hartree--Fock orbitals are
too diffuse as correlating orbitals in an MCSCF calculation.
If the keyword :kword:`IVO` is encountered in the input stream, the
:program:`SCF` program will diagonalize the core Hamiltonian matrix within
the virtual space and write the resulting more compact eigenvectors to the
:file:`SCFORB` and :file:`RUNFILE` files,
rather than the virtual eigenvectors of the Fock
matrix. It should be noted, that this option must never be used, if the
:program:`SCF` wave function itself is used subsequently as a reference
function: no MP2 or coupled cluster calculations after an
:program:`SCF` run with :kword:`IVO`!

A further method to generate starting orbitals for MCSCF calculations is
to perform an SCF calculation for a slightly positively charged moiety.

.. _UG\:sec\:scf_dependencies:

Dependencies
------------

The :program:`SCF` program requires the one-electron integral file
:file:`ONEINT` and the communications file :file:`RUNFILE`,
which contains among others the
basis set specifications processed by :program:`SEWARD`. For conventional
(not integral-direct) runs the two-electron integral file :file:`ORDINT`
is required as well. All these files are generated by a preceding
:program:`SEWARD` run.

.. index::
   pair: Files; SCF

.. _UG\:sec\:scf_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`SCF`.

Input files
...........

:program:`SCF` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`INPORB`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist:

:file:`SCFORB`
  :program:`SCF` orbital output file.
  Contains the canonical Hartree--Fock orbitals for closed shell calculations.
  If the :kword:`IVO` option
  was specified, the virtual orbitals instead are those that diagonalize the bare
  nuclei Hamiltonian within that subspace.

:file:`UHFORB`
  Contains the canonical Hartree--Fock orbitals for open shell calculations.

:file:`UNAORB`
  This file is produced if you make a UHF calculation and it contain
  natural orbitals.

:file:`MD_SCF`
  Molden input file for molecular orbital analysis.

.. index::
   pair: Input; SCF

.. _UG\:sec\:scf_inpscf:

Input
-----

Below follows a description of the input to :program:`SCF`.

The input for each module is preceded by its name like: ::

  &SCF

Argument(s) to a keyword, either individual or composed by several entries,
can be placed in a separated line or in the same line separated by a semicolon.
If in the same line, the first argument requires an equal sign after the
name of the keyword.

Basic general keywords
......................

Below is a list of keywords that should cover the needs of most users.

.. class:: keywordlist

:kword:`TITLe`
  One line for the title

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              One line for the title
              </HELP>
              </KEYWORD>

:kword:`UHF`
  Use this keyword to run Unrestricted Hartree--Fock code.
  Note that current implementation of UHF code has some
  restrictions, and not all features of :program:`SCF` program are supported.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="UHF" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: UHF <basic> GUI:keyword
              <HELP>
              Use this keyword to run Unrestricted Hartree-Fock code
              Note that current implementation of UHF code has some
              restrictions, and not all features of SCF program are supported
              </HELP>
              </KEYWORD>

:kword:`HFC`
  Requests the computation of hyperfine coupling tensor matrix on each atom using spin polarization in
  the calculated spin unrestricted wavefunctions, has to be used with the keyword :kword:`UHF`.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="HFC" KIND="SINGLE" REQUIRE="UHF" LEVEL="BASIC">
              %%Keyword: HFC <basic>
              <HELP>
              Requests the computation of hyperfine coupling tensor matrix using spin polarization in
              the calculated spin unrestricted wavefunctions, has to be used with the keyword UHF.
              </HELP>
              </KEYWORD>

:kword:`ZSPIN`
  Use this keyword to specify the difference in the number of :math:`\alpha` and :math:`\beta`
  electrons in the system. The default is 0 or 1 depending on if there is an even
  or odd number of electrons.
  Any value different from 0 requires the :kword:`UHF` keyword.
  This keyword is not needed when you specify the number of electrons with
  the keyword :kword:`OCCUpied`.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="ZSPIN" APPEAR="zSpin" KIND="INT" LEVEL="BASIC" REQUIRE="UHF" EXCLUSIVE="SPIN">
              %%Keyword: zSpin <basic>
              <HELP>
              Use this keyword to specify the difference in the number of alpha
              and beta electrons in the system. The default is 0 or 1 depending
              on if there is an even or odd number of electrons. This keyword
              is not needed when you specify the number of electrons with the
              keyword OCCUpied.
              </HELP>
              </KEYWORD>

:kword:`SPIN`
  Alternative way of specifying the electronic spin of the system.
  The keyword is followed by an integer giving the value of spin multiplicity (:math:`2S+1`).
  Default is 1 (singlet) or 2 (doublet) depending on if there is an even or odd number of electrons.
  Any value different from 1 requires the :kword:`UHF` keyword.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="SPIN" APPEAR="Spin" LEVEL="BASIC" KIND="INT" MIN_VALUE="1" REQUIRE="UHF" EXCLUSIVE="ZSPIN">
              %%Keyword: Spin <basic>
              <HELP>
              The keyword is followed by an integer giving the value of spin
              multiplicity (2S+1). Default is 1 (singlet) or 2 (doublet)
              depending on if there is an even or odd number of electrons.
              </HELP>
              </KEYWORD>

:kword:`KSDFT`
  Use this keyword to do density functional theory calculations.
  This keyword should be followed by a functional keyword.
  Use :command:`pymolcas help_func` to see a list of available functionals,
  you can also specify a `Libxc <https://www.tddft.org/programs/libxc/>`_ functional name, or a number :math:`N` followed
  by :math:`N` lines, each of them containing a weight factor and a Libxc
  functional name (or ``HF_X`` for exact exchange).
  Examples (all three should be equivalent): ::

     KSDFT=B3LYP                 * A functional keyword

  ::

     KSDFT=HYB_GGA_XC_B3LYP      * A Libxc functional name

  ::

     KSDFT=5                     * Five components with their weights
           0.20 HF_X             * Keyword for exact exchange
           0.08 XC_LDA_X         * Libxc functional names
           0.72 XC_GGA_X_B88     *  .
           0.19 XC_LDA_C_VWN_RPA *  .
           0.81 XC_GGA_C_LYP     *  .

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="KSDFT" APPEAR="DFT" KIND="STRINGS_COMPUTED" SIZE="1" LEVEL="BASIC">
              <ALTERNATE KIND="STRING" />
              %%Keyword: KSDFT <basic>
              <HELP>
              Use this keyword to do density functional theory calculations
              This keyword should be followed by a functional keyword , a Libxc functional
              name, or a functional specification. See "pymolcas help_func" for
              available functionals keywords.
              </HELP>
              </KEYWORD>

:kword:`DFCF`
  Use this keyword to scale the exchange terms and/or correlation terms of a density functional.
  This keyword should be followed by the scaling factor for the exchange terms and the scaling factor for the correlation terms, separated by a space.
  If the values are 1.0 (default), then the original density functional is used.
  For an HLE-type functional, use 1.25 (for exchange) and 0.5 (for correlation).
  Example: `DFCF=1.25 0.5`

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="DFCF" APPEAR="DFT exch. &amp; corr. scaling factors" KIND="REALS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: DFCF <advanced>
              <HELP>
              Use this keyword to scale the exchange terms and/or correlation terms of a density functional.
              This keyword should be followed by the scaling factor for the exchange terms
              and the scaling factor for the correlation terms, separated by a space.
              If the values are 1.0 (default), then the original density functional is used.
              For an HLE-type functional, use 1.25 (for exchange) and 0.5 (for correlation).
              Example: DFCF=1.25 0.5
              </HELP>
              </KEYWORD>

:kword:`CHARge`
  .. compound::

    Use this keyword to set the number of electrons in the system.
    This number is defined by giving the net charge of the system.
    If this keyword is not specified, the molecule is assumed to
    have net charge zero.
    The input is given as ::

      Charge=n

    where ``n`` is the charge of the system.

  .. xmldoc:: <SELECT MODULE="SCF" NAME="ELECTRONS" APPEAR="Electron Count" LEVEL="BASIC" CONTAINS="DEFAULT,CHARGE,OCCUPIED">

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="CHARGE" KIND="INT" LEVEL="BASIC" EXCLUSIVE="OCCUPIED">
              %%Keyword: Charge <basic>
              <HELP>
              Use this keyword to set the number of electrons in the system.
              This number is defined by giving the net charge of the system.
              If this keyword is not specified, the molecule is assumed to
              have net charge zero.
              The input is given as

                Charge=n

              where n is the charge of the system.
              </HELP>
              </KEYWORD>

:kword:`OCCUpied`
  .. compound::

    Use this keyword to set the number of electrons in the system.
    This number is defined by giving the number of electron pairs
    per irreducible representation of the subgroup of :math:`D_{2h}` used
    in the calculation.
    You can use one and only one of the keywords,
    :kword:`CHARge` and
    :kword:`OCCUpied` for this purpose.
    If neither of these keywords are specified
    :kword:`CHARge` is assumed with a net charge of zero.
    It should be noted that the "Fermi aufbau"
    procedure is not used when you specify this keyword.
    The input for one of the point groups :math:`D_2`, :math:`C_{2h}` or :math:`C_{2v}`
    is given as ::

      OCCUpied= n1 n2 n3 n4

    where ``n1`` is the number of electron pairs (occupied orbitals)
    in the first irreducible representation, etc.

  If :kword:`UHF` keyword was specified, occupation numbers
  must be specified in two lines: for alpha and beta spins

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="OCCUPIED" KIND="CUSTOM" LEVEL="BASIC" EXCLUSIVE="CHARGE">
              %%Keyword: Occupied <basic>
              <HELP>
              Use this keyword to set the number of electrons in the system.
              This number is defined by giving the number of electron pairs
              per irreducible representation of the subgroup of D2h used in
              the calculation. You can use one and only one of the keywords,
              CHARge and OCCUpied for this purpose. If neither of
              these keywords are specified CHARge is assumed with a net
              charge of zero. It should be noted that the "fermi aufbau"
              procedure is not used when you specify this keyword.
              The input for one of the point groups D2, C2h or C2v
              is given as

                OCCUpied= n1 n2 n3 n4

              where n1 is the number of electron pairs (occupied orbitals)
              in the first irreducible representation, etc.
              If UHF keyword was specified, occupation numbers
              must be specified in two lines: for alpha and beta spins
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`FERMi`
  .. compound::

    Use this keyword to specify that you want to use the "Fermi aufbau"
    procedure for the first few iterations to ensure convergence.
    The orbitals will be partially populated according to a Fermi
    population.
    The input is gives as ::

      Fermi= m

    where ``m`` is the temperature parameter according to

  * ``m=0``: No temperature is used. Not recommended.
  * ``m=1``: A low temperature is used and will yield swift convergence
    for well behaved systems.
  * ``m=2``: A medium low temperature is used and will yield swift and
    safe convergence for most systems. This is the default value.
  * ``m=3``: A medium temperature is used and you will obtain good
    convergence for closed shell systems. If the system is not
    a closed shell system, the temperature dependent aufbau
    procedure may not terminate. This will result in a density
    matrix with fractional occupation numbers.
  * ``m=4``: A medium high temperature is used and the temperature
    dependent aufbau procedure will most probably not terminate.
    This is useful for generating starting orbitals for an MCSCF
    calculation.
  * ``m=5``: A high temperature is used. Behaves as m=4 only more so.

  It should be noted that only dynamic damping is used until the
  program have found a stable closed shell configuration. When
  this have happened the more efficient methods: the ordinary
  :math:`C^2`\-DIIS and the second order update/\ :math:`C^2`\-DIIS procedure, are
  enabled.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="FERMI" KIND="INT" LEVEL="BASIC">
              %%Keyword: Fermi <basic> GUI:number
              <HELP>
              Use this keyword to specify that you want to use the "Fermi aufbau"
              procedure for the first few iterations to ensure convergence.
              The orbitals will be partially populated according to a Fermi
              population.
              The input is gives as

                Fermi= m

              where m is the temperature parameter according to

              m=0 -- No temperature is used. Not recommended.
              m=1 -- A low temperature is used and will yield swift convergence
                     for well behaved systems.
              m=2 -- A medium low temperature is used and will yield swift and
                     safe convergence for most systems. This is the default value.
              m=3 -- A medium temperature is used and you will obtain good
                     convergence for closed shell systems. If the system is not
                     a closed shell system, the temperature dependent aufbau
                     procedure may not terminate. This will result in a density
                     matrix with fractional occupation numbers.
              m=4 -- A medium high temperature is used and the temperature
                     dependent aufbau procedure will most probably not terminate.
                     This is useful for generating starting orbitals for an MCSCF
                     calculation.
              m=5 -- A high temperature is used. Behaves as m=4 only more so.

              It should be noted that only dynamic damping is used until the
              program have found a stable closed shell configuration. When
              this have happened the more efficient methods: the ordinary
              C2-DIIS and the second order update/C2-DIIS procedure, are
              enabled.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="ITER" APPEAR="Max Iterations" KIND="INT" LEVEL="BASIC">
              %%Keyword: Iterations <basic>
              <HELP>
              Specifies the maximum number of iterations. The default is 400 which
              is also the largest number you can specify.
              </HELP>
              </KEYWORD>

:kword:`CHOLesky`
  :program:`SCF` will use Cholesky (or RI/DF) representation of the two-electron integrals to compute
  the corresponding contributions to the Fock or KS matrices. The default (LK)
  algorithm is used. The configuration may be tailored using the :kword:`ChoInput` section.
  Default is to not use Cholesky unless the Cholesky (or RI/DF) representation of the two-electron
  integrals has been produced by :program:`SEWARD`.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="CHOLESKY" APPEAR="Default Cholesky" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: Cholesky <advanced>
              <HELP>
              Use of Cholesky (or RI/DF) representation for the two-electron integrals
              with default SCF settings.
              </HELP>
              </KEYWORD>

:kword:`CHOInput`
  This marks the start of an input section for modifying
  the default settings of the Cholesky SCF.
  Below follows a description of the associated options.
  The options may be given in any order,
  and they are all optional except for
  :kword:`ENDChoinput` which marks the end of the :kword:`CHOInput` section.

  * :kword:`NoLK`
    Available only within :kword:`ChoInput`. Deactivates the "Local Exchange" (LK) screening algorithm :cite:`Aquilante:07a` in computing
    the Fock matrix. The loss of speed compared to the default algorithm can be substantial, especially for electron-rich systems.
    Default is to use LK.

    .. xmldoc:: <GROUP MODULE="SCF" NAME="CHOINPUT" APPEAR="Cholesky input section" KIND="BLOCK" LEVEL="ADVANCED">
                %%Keyword: Choinput <advanced>
                <HELP>
                Manually modify the settings of the Cholesky SCF.
                </HELP>

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NOLK" APPEAR="Turn off LK screening" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NoLK <advanced>
                <HELP>
                Deactivates LK screening. Available only within ChoInput.
                </HELP>
                </KEYWORD>

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="LOCK" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  * :kword:`DMPK`
    Available only within :kword:`ChoInput`. Modifies the thresholds used in the LK screening.
    The keyword takes as argument a (double precision) floating point (non-negative) number used
    as correction factor for the LK screening thresholds.
    The default value is 1.0d0. A smaller value results in a slower but more accurate calculation.

    **Note:** The default choice of the LK screening thresholds is tailored to achieve as much as possible an
    accuracy of the converged SCF energy consistent with the choice of the Cholesky decomposition
    threshold.

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="DMPK" APPEAR="Damping for LK" LEVEL="ADVANCED" KIND="REAL" EXCLUSIVE="NOLK">
                %%Keyword: dmpK <advanced>
                <HELP>
                Modifies the thresholds used in the LK screening. Available only within ChoInput
                The default value is 1.0d0. A smaller value results in a slower but more accurate calculation.
                </HELP>
                </KEYWORD>

  * :kword:`NODEcomposition`
    Available only within :kword:`ChoInput`. Deactivates the Cholesky decomposition of the AO 1-particle density matrix.
    The Exchange contribution to the Fock matrix is therefore computed using occupied canonical orbitals
    instead of (localized) "Cholesky MOs" :cite:`Aquilante:06a`. This choice tends to lower the performances of the
    LK screening.
    Default is to perform this decomposition in order to obtain the Cholesky MOs.

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NODE" APPEAR="Turn off density decomposition" LEVEL="ADVANCED" KIND="SINGLE">
                %%Keyword: NODE <advanced>
                <HELP>
                The Exchange contribution to the Fock matrix is computed using occupied canonical orbitals
                instead of (localized) "Cholesky MOs". Available only within ChoInput.
                </HELP>
                </KEYWORD>

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="ALGORITHM" LEVEL="UNDOCUMENTED" KIND="INT" />

  * :kword:`TIME`
    Activates printing of the timings of each task of the Fock matrix build.
    Default is to not show these timings.

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="TIME" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  * :kword:`MEMFraction`
    Set the fraction of memory to use as global Cholesky vector buffer.
    Default: for serial runs 0.0d0; for parallel runs 0.3d0.

    .. xmldoc:: <KEYWORD MODULE="SCF" NAME="REOR" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

    .. xmldoc:: </GROUP>

:kword:`CONStraints`
  Performs a Constrained (Natural Orbitals) SCF calculation, available only in combination with Cholesky or RI integral representation.
  An example of input for the keyword :kword:`CONS` is the following: ::

    CONStraints
     2  3
     1 -1
     1  1  1

    ADDCorrelation
    pbe

    SAVErage

  The keyword :kword:`CONS` has two compulsory arguments: the number of constrained NOs
  (in each irrep) to be used in the CNO-SCF calculation, followed by one line per irrep specifying the spin configuration
  of the so-called (+) wavelet (-1 :math:`\rightarrow` beta, 1 :math:`\rightarrow` alpha)
  The OPTIONAL keyword :kword:`ADDC` is used to include a correlation energy correction through a DFT functional specified as argument (LDA, LDA5, PBE and BLYP available at the moment)
  The OPTIONAL keyword :kword:`SAVE` forces the program to use spin-averaged wavelets.

  .. xmldoc:: %%Keyword: CONS <advanced>
              Performs a Constrained (Natural Orbitals) SCF calculation, available only in combination with Cholesky or RI integral representation.
              An example of input for the keyword CONS is the following:

                CONStraints
                 2  3
                 1 -1
                 1  1  1

                ADDCorrelation
                pbe

                SAVErage

              The keyword CONS has two compulsory arguments: the number of constrained NOs
              (in each irrep) to be used in the CNO-SCF calculation, followed by one line per irrep specifying the spin configuration
              of the so-called (+) wavelet (-1 --> beta, 1 --> alpha)
              The OPTIONAL keyword ADDC is used to include a correlation energy correction through a DFT functional specified as argument (LDA, LDA5,
              PBE and BLYP available at the moment)
              The OPTIONAL keyword SAVE forces the program to use spin-averaged wavelets.

:kword:`OFEMbedding`
  Performs a Orbital-Free Embedding (OFE)SCF calculation, available only in combination with Cholesky or RI integral representation.
  The runfile of the environment subsystem renamed AUXRFIL is required.
  An example of input for the keyword :kword:`OFEM` is the following: ::

    OFEMbedding
     ldtf/pbe
    dFMD
     1.0   1.0d2
    FTHAw
     1.0d-4

  The keyword :kword:`OFEM` requires the specification of two functionals in the form fun1/fun2, where fun1 is the functional
  used for the Kinetic Energy (available functionals: Thomas--Fermi, with acronym LDTF, and the NDSD functional), and where
  fun2 is the xc-functional (LDA, LDA5, PBE and BLYP available at the moment).
  The OPTIONAL keyword :kword:`dFMD` has two arguments: first, the fraction of correlation potential to be added to the
  OFE potential (zero for KSDFT and one for HF); second, the exponential decay factor for this correction (used in PES calculations).
  The OPTIONAL keyword :kword:`FTHA` is used in a freeze-and-thaw cycle (EMIL Do While) to specify the (subsystems) energy convergence threshold.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="OFEMBEDDING" APPEAR="Orbital-free embedding" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: OFEM <advanced>
              <HELP>
              Performs a Orbital-Free Embedding (OFE)SCF calculation, available only in combination with Cholesky or RI integral representation.
              The runfile of the environment subsystem renamed AUXRFIL is required.
              An example of input for the keyword OFEM is the following:

                OFEMbedding
                 ldtf/pbe
                dFMD
                 1.0  1.0d2
                FTHAw
                 1.0d-4

              The keyword OFEM requires the specification of two functionals in the form fun1/fun2, where fun1 is the functional used for the
              Kinetic Energy (available functionals: Thomas-Fermi, with acronym LDTF, and the NDSD functional), and where
              fun2 is the xc-functional (LDA, LDA5, PBE and BLYP available at the moment).
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="DFMD" LEVEL="ADVANCED" KIND="REALS" SIZE="2" REQUIRE="OFEMBEDDING">
              %%Keyword: dFMD <advanced>
              <HELP>
              The OPTIONAL keyword dFMD has two arguments: first, the fraction of correlation potential to be added to the OFE potential (zero for
              KSDFT and one for HF); second, the exponential decay factor for this correction (used in PES calculations).
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="FTHAW" LEVEL="ADVANCED" KIND="REAL" REQUIRE="OFEMBEDDING">
              %%Keyword: FTHAw <advanced>
              <HELP>
              The OPTIONAL keyword FTHA is used in a freeze-and-thaw cycle (EMIL Do While) to specify the (subsystems) energy convergence
              threshold.
              </HELP>
              </KEYWORD>

:kword:`ITERations`
  Specifies the maximum number of iterations. The default is 400 which
  is also the largest number you can specify.

:kword:`CORE`
  The starting vectors are obtained from a diagonalization of the core
  Hamiltonian.

  .. xmldoc:: <SELECT MODULE="SCF" NAME="GUESS" APPEAR="Initial guess" LEVEL="BASIC" CONTAINS="CORE,LUMORB,FILEORB,GSSRUNFILE">

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="CORE" APPEAR="Core" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="LUMORB,FILEORB,GSSRUNFILE">
              %%Keyword: Core <basic>
              <HELP>
              The starting vectors are obtained from a diagonalization of the core
              Hamiltonian.
              </HELP>
              </KEYWORD>

:kword:`LUMORB`
  The starting vectors are taken from a previous :file:`SCFORB` file called
  :file:`INPORB`.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="LUMORB" APPEAR="LUMORB" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="FILEORB,CORE,GSSRUNFILE">
              %%Keyword: LUMORB <basic>
              <HELP>
              The starting vectors are taken from a previous SCFORB file called
              INPORB.
              </HELP>
              </KEYWORD>

:kword:`FILEORB`
  The starting vectors are taken from a previous :file:`SCFORB` file, specified by user.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="FILEORB" APPEAR="FILEORB" KIND="STRING" LEVEL="BASIC" EXCLUSIVE="LUMORB,CORE,GSSRUNFILE">
              %%Keyword: FILEORB <basic>
              <HELP>
              The starting vectors are taken from a previous SCFORB file, specified by user.
              </HELP>
              </KEYWORD>

:kword:`GSSRunfile`
  The starting vectors are taken from the orbitals produced by :program:`Guessorb`.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="GSSRUNFILE" APPEAR="GSSRUNFILE" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="CORE,LUMORB,FILEORB">
              %%Keyword: GssRunfile <basic>
              <HELP>
              The starting vectors are taken from the orbitals produced by Guessorb.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`HLGAp`
  This keyword is used to make the program level shift the virtual
  orbitals in such a way that the HOMO LUMO gap is at least the value
  specified on the next line. This will help convergence in difficult
  cases but may lead to that it converges to an excited configuration.
  A suitable value is 0.2.

  .. xmldoc:: %%Keyword: HLgap <basic>
              This keyword is used to make the program levelshift the virtual
              orbitals in such a way that the HOMO LUMO gap is at least the value
              specified on the next line. This will help convergence in difficult
              cases but may lead to that it converges to an excited configuration.
              A suitable value is 0.2.

Advanced general keywords
.........................

.. class:: keywordlist

:kword:`SCRAmble`
  This keyword will make the start orbitals slightly scrambled,
  accomplished by making a few small random orbital rotations.
  How much the orbitals are scrambled is determined by the
  parameter read on the next entry. A reasonable choice for
  this parameter is 0.2 which correspond to maximum rotation angle
  of :math:`\arcsin 0.2`.
  Using this keyword may be useful for UHF calculations with
  same number of :math:`\alpha` and :math:`\beta` electrons that are not
  closed shell cases.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="SCRAMBLE" KIND="REAL" LEVEL="ADVANCED" REQUIRE="UHF">
              %%Keyword: Scramble <advanced>
              <HELP>
              This keyword will make the start orbitals slightly scrambled,
              accomplished by making a few small random orbital rotations.
              How much the orbitals are scrambled is determined by the
              parameter read on the next entry. A reasonable choice for
              this parameter is 0.2 which correspond to maximum rotation angle
              of arcsin(0.2).
              Using this keyword may be useful for UHF calculations with
              same number of alpha and beta electrons that are not
              closed shell cases.
              </HELP>
              </KEYWORD>

:kword:`ORBItals`
  Specifies the number of orbitals in the subspace of the full
  orbital space defined by the basis set, in which the SCF energy
  functional is optimized. The size of this subspace is given for each
  of the irreducible representations of the subgroup of :math:`D_{2h}`.
  If this keyword is not specified when starting orbitals are read, the
  full orbital space is assumed.
  The keyword takes as argument *nIrrep* (# of irreps) integers.
  **Note** that this keyword is only meaningful when the :program:`SCF`
  program is fed with input orbitals (cf. :kword:`LUMORB`).

  .. xmldoc:: %%Keyword: Orbitals <advanced>
              Specifies the number of orbitals in the subspace of the full
              orbital space defined by the basis set, in which the SCF energy
              functional is optimized. The size of this subspace is given for each
              of the irreducible representations of the subgroup of D2h.
              If this keyword is not specified when starting orbitals are read, the
              full orbital space is assumed.
              The keyword takes as argument nIrrep (# of irreps) integers.
              Note that this keyword is only meaningful when the SCF
              program is fed with input orbitals (cf. LUMORB).

:kword:`FROZen`
  Specifies the number of orbitals not optimized during
  iterative procedure. The size of this subspace is given for each
  of the irreducible representations of the subgroup of :math:`D_{2h}`.
  If this keyword is not specified the number of frozen orbitals
  is set to zero for each irreducible representation.
  If the starting vectors are obtained from a diagonalization of the bare
  nuclei Hamiltonian the atomic orbitals with the lowest one-electron energy
  are frozen. If molecular orbitals are read from :file:`INPORB` the frozen
  orbitals are those that are read in first in each symmetry.
  The keyword takes as argument *nIrrep* (# of irreps) integers.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="FROZEN" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED">
              %%Keyword: Frozen <advanced>
              <HELP>
              Specifies the number of orbitals not optimized during
              iterative procedure. The size of this subspace is given for each
              of the irreducible representations of the subgroup of D2h.
              If this keyword is not specified the number of frozen orbitals
              is set to zero for each irreducible representation.
              If the starting vectors are obtained from a diagonalization of the bare
              nuclei Hamiltonian the atomic orbitals with the lowest one-electron energy
              are frozen. If molecular orbitals are read from the file INPORB the frozen
              orbitals are those that are read in first in each symmetry.
              The keyword takes as argument nIrrep (# of irreps) integers.
              </HELP>
              </KEYWORD>

:kword:`OVLDelete`
  Specifies the threshold for deleting near linear dependence in the
  basis set. The eigenvectors of the overlap matrix with eigenvalues
  less than that threshold are removed from the orbital subspace, and
  do not participate in the optimization procedure. The default value
  is 1.0d-5.
  The keyword takes as argument a (double precision) floating point number.
  Note that the :file:`SCFORB` file will contain the deleted orbitals as a
  complementary set to the actual SCF orbitals! In future use of this orbital
  file the complementary set should always be deleted from use.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="OVLDELETE" APPEAR="Delete threshold" KIND="REAL" DEFAULT_VALUE="1.0d-5" LEVEL="ADVANCED">
              %%Keyword: Ovldelete <advanced>
              <HELP>
              Specifies the threshold for deleting near linear dependence in the
              basis set. The eigenvectors of the overlap matrix with eigenvalues
              less than that threshold are removed from the orbital subspace, and
              do not participate in the optimization procedure. The default value
              is 1.0d-5.
              </HELP>
              The keyword takes as argument a (double precision) floating point number.
              Note that the SCFORB file will contain the deleted orbitals as a
              complemental set to the actual SCF orbitals! In future use of this orbital
              file the complemental set should always be deleted from use.
              </KEYWORD>

:kword:`PRORbitals`
  Specifies which orbitals are to be printed in the log file (standard output).
  The keyword takes as argument two integers.
  The possible values are:

  .. container:: list

    0 --- No orbitals printed.

    1 --- orbitals with orbital energies smaller than
    :math:`2E_{\text{HOMO}}-E_{\text{LUMO}}` are printed.

    2 --- followed by real number (ThrEne); orbitals with orbital
    energies smaller than ThrEne are printed.

  Default value is 1.

  Second (optional) argument specifies a format:

  .. container:: list

    0 --- No orbitals printed

    1 --- Print only one-electron energies and occupation numbers

    2 --- Short print format

    3 --- Extended print format

  Default value is 3 for small numbers of MOs and 2 for number of MOs > 256.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="PRORBITALS" APPEAR="Orbital printout" KIND="INTS" SIZE="2" LEVEL="ADVANCED">
              <ALTERNATE KIND="INT" />
              %%Keyword: Prorbitals <advanced>
              <HELP>
              Specifies which orbitals are to be printed in the logfile (standard output).
              The keyword takes as argument two integers.
              The possible values of first argument are:

              0 -- No orbitals printed;
              1 -- orbitals with orbital energies smaller than
                   2E(homo)-E(lumo) are printed; and
              2 -- followed by real number (ThrEne); orbitals with orbital
                   energies smaller than ThrEne are printed.

              Default value is 1.
              Second (optional) argument specifies a format:

              0 -- No orbitals printed
              1 -- Print only one-electron energies and occupation numbers
              2 -- Short print format
              3 -- Extended print format
              </HELP>
              </KEYWORD>

:kword:`PRLScf`
  Specifies the general print level of the calculation. An integer
  has to be supplied as argument.
  The default value, 1, is recommended for production calculations.

  .. xmldoc:: %%Keyword: prlscf <advanced>
              Specifies the general print level of the calculation. An integer
              has to be supplied as argument.
              The default value, 1, is recommended for production calculations.

  .. :kword:`PRLInt`
       .. compound ::

         Specifies the print level in individual subroutines, primarily of those
         related to the direct construction of the Fock matrix.
         The first argument, an integer :math:`n`, specifies the number of
         subroutines. Follow :math:`n` pairs of subroutine specifiers and
         corresponding print levels are given. E.g. the input segment ::

           PRLInt= 2; 3 7 9 8

         rises the print level in subroutine 3 from 5 (default) to 7, and in
         subroutine 9 from 5 to 8. This provides more extensive information
         about how the wave function is converging (subroutine 3), and statistics
         about the efficiency of the integral prescreening (subroutine 9). This
         option is certainly not used in production calculations.

:kword:`ROBU`
  Robust LDF integral representation (non-hybrid KS-DFT only).
  Requires Local Density Fitting (LDF) in SEWARD. This is the default for LDF.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="ROBU" APPEAR="Robust LDF integral representation" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: ROBU <advanced>
              <HELP>
              Robust LDF integral representation (non-hybrid KS-DFT only). Requires Local Density Fitting (LDF) in SEWARD. This is the default for LDF.
              </HELP>
              </KEYWORD>

:kword:`NR-2`
  Nonrobust LDF integral representation with 2-index integrals only (non-hybrid KS-DFT only).
  Requires Local Density Fitting (LDF) in SEWARD. Default is robust integral representation.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NR-2" APPEAR="Nonrobust LDF integral representation with 2-index integrals only" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NR-2 <advanced>
              <HELP>
              Nonrobust LDF integral representation with 2-index integrals only (non-hybrid KS-DFT only). Requires Local Density Fitting (LDF) in SEWARD. Default is robust integral representation.
              </HELP>
              </KEYWORD>

:kword:`NR-3`
  Nonrobust LDF integral representation with 3-index integrals only (non-hybrid KS-DFT only).
  Requires Local Density Fitting (LDF) in SEWARD. Default is robust integral representation.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NR-3" APPEAR="Nonrobust LDF integral representation with 3-index integrals only" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NR-3 <advanced>
              <HELP>
              Nonrobust LDF integral representation with 3-index integrals only (non-hybrid KS-DFT only). Requires Local Density Fitting (LDF) in SEWARD. Default is robust integral representation.
              </HELP>
              </KEYWORD>

:kword:`XIDI`
  Use exact integral diagonal blocks with LDF.
  Reduces the risk of negative eigenvalues of the approximate integral matrix.
  Default is to not use exact integral diagonal blocks.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="XIDI" APPEAR="Use exact integral diagonal blocks with LDF" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XIDI <advanced>
              <HELP>
              Use exact integral diagonal blocks with LDF. Reduces the risk of negative eigenvalues of the approximate integral matrix. Default is to not use exact integral diagonal blocks.
              </HELP>
              </KEYWORD>

:kword:`THREsholds`
  Specifies convergence thresholds. Four individual thresholds are specified
  as arguments, which have to be fulfilled simultaneously to reach convergence:
  EThr, DThr and FThr
  specify the maximum permissible difference in energy, density matrix elements
  and Fock matrix elements, respectively, in the last two iterations. The
  DltNTh finally specifies the norm of the orbital displacement vector used
  for the orbital rotations in the second-order/\ :math:`C^2`\-DIIS procedure.
  The corresponding values are read in the order given above.
  The default values are 1.0d-9, 1.0d-4, 1.5d-4, and 0.2d-4,
  respectively.
  **Note** that these thresholds automatically define the threshold
  used in the direct Fock matrix construction to estimate individual
  contributions to the Fock matrix such that
  the computed energy will have an accuracy that is better than the
  convergence threshold.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="THRESHOLD" KIND="REALS" SIZE="4" LEVEL="ADVANCED">
              %%Keyword: Thresholds <advanced>
              <HELP>
              Specifies convergence thresholds. Four individual thresholds are specified
              as arguments, which have to be fulfilled simultaneously to reach convergence:
              EThr, DThr and FThr
              specify the maximum permissible difference in energy, density matrix elements
              and Fock matrix elements, respectively, in the last two iterations. The
              DltNTh finally specifies the norm of the orbital displacement vector used
              for the orbital rotations in the second-order/C2-DIIS procedure.
              The corresponding values are read in the order given above.
              The default values are 1.0d-9, 1.0d-4, 1.5d-4, and 0.2d-4,
              respectively.
              Note that these thresholds automatically define the threshold
              used in the direct Fock matrix construction to estimate individual
              contributions to the Fock matrix such that
              the computed energy will have an accuracy that is better than the
              convergence threshold.
              </HELP>
              </KEYWORD>

:kword:`NODIis`
  Disable the DIIS convergence acceleration procedure.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NODIIS" APPEAR="NoDIIS" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NoDIIS <advanced>
              <HELP>
              Disable the DIIS convergence acceleration procedure.
              </HELP>
              </KEYWORD>

:kword:`DIISthr`
  Set the threshold on the change in density, at which the DIIS procedure
  is turned on.
  The keyword takes as argument a (double precision) floating point number.
  The default value is 0.15.

  .. xmldoc:: %%Keyword: DIISthr <advanced>
              Set the threshold on the change in density, at which the DIIS procedure
              is turned on.
              The keyword takes as argument a (double precision) floating point number.
              The default value is 0.15.

:kword:`QNRThr`
  Set the threshold on the change in density, at which the
  second-order/\ :math:`C^2`\-DIIS
  procedure kicks in.
  The keyword takes as argument a (double precision) floating point number.
  The default value is 0.15.

  **Note:** the change in density has to drop under both the
  :kword:`DIISthr` and the :kword:`QNRThr` threshold, for the
  second-order/\ :math:`C^2`\-DIIS to be activated. If the latter is set to zero
  the older first order :math:`C^2`\-DIIS procedure will be used instead.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="QNRTHR" APPEAR="QNR threshold" KIND="REAL" DEFAULT_VALUE="0.15" LEVEL="ADVANCED">
              %%Keyword: QNRTHR <advanced>
              <HELP>
              Set the threshold on the change in density, at which the
              second-order/C2-DIIS
              procedure kicks in.
              The keyword takes as argument a (double precision) floating point number.
              The default value is 0.15.
              </HELP>
              Note: the change in density has to drop under both the
              DIISthr and the QNRThr threshold, for the
              second-order/C2-DIIS to be activated. If the latter is set to zero
              the older first order C2-DIIS procedure will be used instead.
              </KEYWORD>

:kword:`C1DIis`
  Use :math:`C^1`\-DIIS for convergence acceleration rather than :math:`C^2`\-DIIS
  which is the default (not recommended).

  .. xmldoc:: %%Keyword: C1DIIS <advanced>
              Use C1-DIIS for convergence acceleration rather than C2-DIIS
              which is the default (not recommended).

:kword:`NODAmp`
  Disable the Damping convergence acceleration procedure.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="NODAMP" APPEAR="NoDAMP" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NODAMP <advanced>
              <HELP>
              Disable the Damping convergence acceleration procedure.
              </HELP>
              </KEYWORD>

:kword:`OCCNumbers`
  Gives the option to specify occupation numbers other than 0 and 2.
  This can be useful for generating starting orbitals for open shell
  cases. It should be noted however, that it is still the closed shell
  SCF energy functional that is optimized, thus yielding unphysical
  energies. Occupation numbers have to be provided for all occupied
  orbitals.
  In the case of UHF calculation occupation numbers should be specified
  on two different entries: for alpha and beta spin.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="OCCNUMBERS" APPEAR="Occupation numbers " KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: Occnumbers <advanced>
              <HELP>
              Gives the option to specify occupation numbers other than 0 and 2.
              This can be useful for generating starting orbitals for open shell
              cases. It should be noted however, that it is still the closed shell
              SCF energy functional that is optimized, thus yielding unphysical
              energies. Occupation numbers have to be provided for all occupied
              orbitals.
              In the case of UHF calculation occupation numbers should be specified
              on two different entries: for alpha and beta spin
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="MCCNUMBERS" APPEAR="Muonic ccupation numbers " KIND="CUSTOM" LEVEL="ADVANCED" />

:kword:`IVO`
  Specifies that the virtual orbitals are to be improved for
  subsequent MCSCF calculations. The core Hamiltonian is diagonalized
  within the virtual orbital subspace, thus yielding as compact orbitals
  as possible with the constraint that they have to be orthogonal to the
  occupied orbitals.
  **Note** that this option must not be used whenever the Hartree--Fock
  wavefunction itself is used as a reference in a subsequent calculation.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="IVO" APPEAR="IVO" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: IVO <advanced> GUI:keyword
              <HELP>
              Specifies that the virtual orbitals are to be improved for
              subsequent MCSCF calculations. The core Hamiltonian is diagonalized
              within the virtual orbital subspace, thus yielding as compact orbitals
              as possible with the constraint that they have to be orthogonal to the
              occupied orbitals.
              Note that this option must not be used whenever the Hartree-Fock
              wavefunction itself is used as a reference in a subsequent calculation.
              </HELP>
              </KEYWORD>

:kword:`NOMInimization`
  Program will use density differences
  :math:`D^{(k)}-D^{(k-1)}`
  rather than minimized differences.

  .. xmldoc:: %%Keyword: nominimization <advanced>
              Program will use density differences
              D(k)-D(k-1)
              rather than minimized differences.

:kword:`ONEGrid`
  Disable use of a smaller intermediate grid in the integration of the
  DFT functional during the first SCF iterations.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="ONEGRID" APPEAR="OneGrid" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="KSDFT">
              %%Keyword: ONEGrid <advanced>
              <HELP>
              Disable use of a smaller intermediate grid in the integration of the
              DFT functional during the first SCF iterations.
              </HELP>
              </KEYWORD>

:kword:`RFPErt`
  This keyword will add a constant reaction field perturbation to the
  bare nuclei hamiltonian.
  The perturbation is read from :file:`RUNOLD` (if not present defaults to :file:`RUNFILE`) and
  is the latest self consistent perturbation generated
  by one of the programs :program:`SCF` or :program:`RASSCF`.

  .. xmldoc:: %%Keyword: Rfpert <advanced>
              This keyword will add a constant reaction field perturbation to the
              bare nuclei hamiltonian.
              The perturbation is read from RUNOLD (if not present defaults to RUNFILE) and
              is the latest selfconsistent perturbation generated
              by one of the programs SCF or RASSCF.

:kword:`STAT`
  This keyword will add an addition print outs with statistic information.

  .. xmldoc:: %%Keyword: STAT <advanced>
              This keyword will add an addition print outs with statistic information

For calculations of a molecule in a reaction field see :numref:`UG:sec:rfield`
of the present manual and :numref:`TUT:sec:cavity` of the examples manual.

.. include:: ../dft_functionals.inc

Keywords for direct calculations
................................

*Note* again that the threshold for contributions to
the Fock matrix depends on the convergence thresholds
mentioned above. The choice between the conventional and direct SCF
methods is based on the presence of a two-electron integral file
(file :file:`ORDINT`). The keyword
:kword:`Direct` in the :program:`SEWARD` input controls that no
two-electron integral file is to be generated and that integral direct
algorithms can be used in subsequent modules. Thus, *the
choice between conventional and direct SCF is done already in the input
for the integral program* :program:`SEWARD`. The direct (or semi-direct)
path will be taken whenever there are no two-electron integrals available.

.. class:: keywordlist

:kword:`CONVentional`
  This option will override the automatic choice between the conventional
  and the direct SCF algorithm such that the conventional method will
  be executed regardless of the status of the :file:`ORDINT` file.

  .. xmldoc:: %%Keyword: conventional <advanced>
              This option will override the automatic choice between the conventional
              and the direct SCF algorithm such that the conventional method will
              be executed regardless of the status of the ORDINT file.

:kword:`DISK`
  This option enables/disables the semi-direct algorithm. It requires
  two arguments which specifies the max Mbyte of integrals that are written
  on disk during the first iteration (and retrieved later in subsequent
  iterations)
  and the size of the corresponding I/O buffer in kbyte.
  The default values are
  2000 MByte and 512 kByte. In case the specified disk space is zero and the I/O buffer
  is different from zero it will default to a semi-direct SCF with in-core storage
  of the integrals. The size of the memory for integrals storage is the size of the
  I/O buffer. If the size of the disk is non-zero and the I/O buffer size is zero the
  latter will be reset to the default value.

  .. xmldoc:: <KEYWORD MODULE="SCF" NAME="DISK" APPEAR="Semi-direct" KIND="INTS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: Disk <advanced>
              <HELP>
              This option enables/disables the semi-direct algorithm. It requires
              two arguments which specifies the max Mbyte of integrals that are written
              on disk during the first iteration (and retrieved later in subsequent
              iterations) and the size of the I/O buffer in kbyte.
              The default values are 2000 MByte and 512 kByte.
              </HELP>
              In case the specified disk space is zero and the I/O buffer
              is different from zero it will default to a semi-direct SCF with in-core storage
              of the integrals. The size of the memory for integrals storage is the size of the
              corresponding I/O buffer. If the size of the disk is non-zero and the I/O buffer size is zero the
              latter will be reset to the default value.
              </KEYWORD>

:kword:`THIZe`
  This option specifies a threshold for two-electron integrals.
  Only integrals above this threshold (but not necessarily all of those) are kept
  on disk for the semi-direct algorithm.
  The keyword takes as argument a (double precision) floating point number.

  .. xmldoc:: %%Keyword: Thize <advanced>
              This option specifies a threshold for two-electron integrals.
              Only integrals above this threshold (but not necessarily all of those) are kept
              on disk for the semi-direct algorithm.
              The keyword takes as argument a (double precision) floating point number.

:kword:`SIMPle`
  If this option is specified, only a simple prescreening scheme,
  based solely on the
  estimated two-electron integral value will be employed (no density involved).

  .. xmldoc:: %%Keyword: Simple <advanced>
              If this option is specified, only a simple prescreening scheme,
              based solely on the
              estimated two-electron integral value will be employed (no density involved).

Limitations
...........

The limitations/MODULE on the number of basis functions are the same as specified
for :program:`SEWARD`.

Input examples
..............

First we have the bare minimum of input. This will work well for almost
all systems containing an even number of electrons. ::

  &SCF

The next example is almost as simple. Here we have an open shell case,
i.e. you have an odd number of electrons in the neutral system and you
need to generate starting orbitals for :program:`RASSCF`.
In this case we recommend that you perform a calculation on the
cation with the input below. ::

  &SCF; Charge= 1

The next example explains how to run UHF code for a nitrogen atom: ::

  &SCF; UHF; ZSPIN=3

The next example is a bit more elaborate and show how to use
a few of the keywords. The system is water that have the
electron configuration :math:`\text{1a}_1^2 \text{2a}_1^2 \text{3a}_1^2 \text{1b}_1^2 \text{1b}_2^2`. ::

  &SCF; Title= Water molecule. Experimental equilibrium geometry. The symmetries are a1, b2, b1 and a2.
  Occupied= 3 1 1 0
  Threshold= 0.5D-9 0.5D-6 0.5D-6 0.5D-5
  * semi-direct algorithm writing max 128k words (1MByte) to disk
  * the size of the I/O buffer by default (512 kByte)
  Disk= 1 0
  Ivo

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="USELDF" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="USECONVENTIONAL" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="QPRINT" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="FCKAUF" KIND="CHOICE" LIST="True,False" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="CONSTRAINTS" KIND="CUSTOM" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="SAVERAGED" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SCF" NAME="ADDCORRELATION" KIND="STRING" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; MBPT2
   single: MBPT2

.. _UG\:sec\:mbpt2:

:program:`mbpt2`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MBPT2">
            %%Description:
            <HELP>
            This program computes the second order Many Body Perturbation Theory
            correction to an SCF wavefunction.
            </HELP>

.. _UG\:sec\:mbpt2_description:

Description
-----------

The :program:`MBPT2` program of the |molcas| program system computes
the second order correlation energy and the reference weight for a
closed-shell Hartree--Fock reference wave function, based on a
Møller--Plesset partitioning of the Hamiltonian and canonical orbitals.

If :program:`SEWARD` performed a Cholesky decomposition of the two-electron integrals prior to running
the :program:`MBPT2` program, Cholesky vectors will be employed for computing
the second order energy correction. This is done by first transforming the
Cholesky vectors to MO basis and subsequently computing the :math:`(ai|bj)` integrals.
These integrals are either computed, stored on disk, and then read back in to
memory during the energy evaluation (i.e. mimicking a conventional calculation)
or they may be computed on-the-fly. The user may choose either algorithm
through the Cholesky-specific options described below.

If :program:`SEWARD` did not perform a Cholesky decomposition,
the transformation of the two-electron integrals in AO basis
(:math:`\mathcal{O}(N^4)`, where :math:`N` is the number of basis functions)
to the exchange operator matrices :math:`\mat{K}^{ij}` in MO basis
(:math:`\mathcal{O}(O^2)` matrices of size :math:`V^2`, where :math:`O` and :math:`V` denote the number
of occupied and virtual orbitals, respectively), is either done
conventionally, using the two-electron integral file :file:`ORDINT`, which
was generated in a previous step by the :program:`SEWARD` integral code.

.. _UG\:sec\:mbpt2_dependencies:

Dependencies
------------

The :program:`MBPT2` program requires the communications file :file:`RUNFILE`.
It contains specifications processed by :program:`SEWARD`,
the Hartree--Fock canonical orbitals, eigenvalues and energy generated
by :program:`SCF`.
For Cholesky-based calculations, all Cholesky related files (see the
manual pages for :program:`SEWARD`) must be available, whereas
for conventional (not integral-direct) calculations
the two-electron integral file :file:`ORDINT`
is required. Hence, before running :program:`MBPT2`, a :program:`SEWARD`
and a :program:`SCF` run have to be performed.

.. index::
   pair: Files; MBPT2

.. _UG\:sec\:mbpt2_files:

Files
-----

Input files
...........

:program:`MBPT2` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`.
For Cholesky runs: :file:`CHVEC`, :file:`CHORST`, :file:`CHRED` and
:file:`CHOR2F`
(for more information see :numref:`UG:sec:files_list`).

.. Intermediate files
   ..................

   All the intermediate files are created, used and removed
   automatically, unless you yourself create a link or a file
   with the specified name.

   .. class:: filelist

   :file:`MOLINT*`
     Resulting file of transformed integrals.
     Scratch file; conventional calculation only.

   :file:`LUHLFn*`
     :math:`n`\=1 to 3. Intermediate files used in the 1st, 2nd, and 3rd, respectively,
     transformation step. Conventional calculation only.

Output files
............

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information.

.. _UG\:sec\:mbpt2_input:

Input
-----

Below follows a description of the input to :program:`MBPT2`.
The input for each module is preceded by its name like: ::

  &MBPT2

No compulsory keywords are required for :program:`MBPT2`.
The reference statement mentioned
above is sufficient for a default :program:`MBPT2` run.

Optional keywords
.................

.. class:: keywordlist

:kword:`TITLe`
  The line following this line is regarded as a title line

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              <HELP>
              Print a title line
              </HELP>
              %%Keyword: Title <basic>
              The line following this line is regarded as a title line
              </KEYWORD>

:kword:`PRINt`
  Specifies the general print level of the calculation. An integer
  has to be supplied as argument.
  The default value, 0, is recommended for production calculations.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="PRINT" APPEAR="Print level" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="0">
              %%Keyword: Print <advanced>
              <HELP>
              Specifies the general print level of the calculation. An integer
              has to be supplied as argument.
              </HELP>
              The default value, 0, is recommended for production calculations.
              </KEYWORD>

:kword:`FREEze`
  Specifies the total number of frozen occupied orbitals.
  The lowest-energy occupied orbitals are then automatically identified and frozen.
  The keyword takes as argument one integer.
  Incompatible with the :kword:`FROZen` keyword.

  .. xmldoc:: <SELECT MODULE="MBPT2" NAME="ORBITAL_FREEZE" APPEAR="Frozen orbitals selection" CONTAINS="FREEZE,FROZEN">

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="FREEZE" APPEAR="freeze orbitals" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="0" EXCLUSIVE="FROZEN">
              %%Keyword: Freeze <advanced>
              <HELP>
              Specifies the total number of frozen occupied orbitals.
              </HELP>
              Incompatible with the FROZen keyword.
              </KEYWORD>

:kword:`FROZen`
  Specifies the number of frozen occupied orbitals in each of the irreducible
  representations (irreps) of the subgroup of :math:`D_{2h}` in which the system
  is represented. The counting of the orbitals follows the *increasing*
  orbital energy within each irrep, with those orbitals being frozen first
  that correspond to lowest orbital energies.
  The keyword takes as argument *nIrrep* (# of irreps) integers.
  Incompatible with the :kword:`FREEze` keyword.
  Default is to freeze non-valence orbitals.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="FROZEN" APPEAR="frozen orbitals" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="NSYM" EXCLUSIVE="FREEZE">
              %%Keyword: Frozen <advanced>
              <HELP>
              Specifies the number of frozen orbitals in each irrep
              of the point group. The orbitals with the lowest energies are frozen.
              </HELP>
              The keyword takes as argument nIrrep (# of irreps) integers.
              Incompatible with the FREEze keyword.
              Default is to freeze non-valence orbitals.
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`DELEted`
  Specifies the number of deleted orbitals in each of the irreducible
  representations (irreps) of the subgroup of :math:`D_{2h}` in which the system
  is represented. The counting of the orbitals follows the *decreasing*
  orbital energy within each irrep, with those orbitals being deleted first
  that correspond to highest orbital energies.
  The keyword takes as argument *nIrrep* (# of irreps) integers.

  **NOTE:** Those orbitals, which have been deleted already in the
  :program:`SCF` calculation (cf. :kword:`SPDElete`, :kword:`OVLDelete` of
  the :program:`SCF` program description) are never seen by the
  :program:`MBPT2` program and hence are **not** to be deleted again with
  the present option.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="DELETED" APPEAR="deleted orbitals" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="NSYM">
              %%Keyword: Deleted <advanced>
              <HELP>
              Specifies the number of deleted orbitals in each irrep of the point group.
              The orbitals with the highest energies are deleted.
              </HELP>
              The keyword takes as argument nIrrep (# of irreps) integers.
              NOTE: Those orbitals, which have been deleted already in the
              SCF calculation (cf. SPDElete, OVLDelete of
              the SCF program description) are never seen by the
              MBPT2 program and hence are not to be deleted again with
              the present option.
              </KEYWORD>

:kword:`SFROzen`
  Allows to specify specific orbitals to freeze in each of the irreducible
  representations (irreps) of the subgroup of :math:`D_{2h}` in which the system
  is represented. In the 1st line after the keyword the number of orbitals
  to freeze for each irrep is specified (*nIrrep* (# of irreps) integers).
  The next :math:`\leq` *nIrrep* lines reference the orbitals to freeze for the
  related irrep, following an enumeration of the individual orbitals
  of 1, 2, 3,... according to
  *increasing* orbital energy. Note that the orbital reference numbers
  obey the original ordering and also include those orbitals which
  may have been frozen already by the
  :kword:`FROZen` or :kword:`FREEze` options. If the corresponding irrep does not contain any
  specific orbitals to freeze (i.e. a zero was supplied for this irrep in the
  1st line), no line orbital reference input line is supplied for that irrep.

  .. xmldoc:: %%Keyword: Sfrozen <advanced>
              Allows to specify specific orbitals to freeze in each of the irreducible
              representations (irreps) of the subgroup of D2h in which the system
              is represented. In the 1st line after the keyword the number of orbitals
              to freeze for each irrep is specified (nIrrep (# of irreps) integers).
              The next <= nIrrep lines reference the orbitals to freeze for the
              related irrep, following an enumeration of the individual orbitals
              of 1, 2, 3,... according to
              increasing orbital energy. Note that the orbital reference numbers
              obey the original ordering and also include those orbitals which
              may have been frozen already by the
              FROZEN option. If the corresponding irrep does not contain any
              specific orbitals to freeze (i.e. a zero was supplied for this irrep in the
              1st line), no line orbital reference input line is supplied for that irrep.

:kword:`SDELeted`
  Allows to specify specific orbitals to delete in each of the irreducible
  representations (irreps) of the subgroup of :math:`D_{2h}` in which the system
  is represented. In the 1st line after the keyword the number of orbitals
  to delete for each irrep is specified (*nIrrep* (# of irreps) integers).
  The next :math:`\leq` *nIrrep* lines reference the orbitals to delete for the
  related irrep, following an enumeration of the individual orbitals
  of 1, 2, 3,... according to
  *increasing* orbital energy. Note that the orbital reference numbers
  obey the original ordering.
  If the corresponding irrep does not contain any
  specific orbitals to freeze (i.e. a zero was supplied for this irrep in the
  1st line), no line orbital reference input line is supplied for that irrep.

  .. xmldoc:: %%Keyword: Sdeleted <advanced>
              Allows to specify specific orbitals to delete in each of the irreducible
              representations (irreps) of the subgroup of D2h in which the system
              is represented. In the 1st line after the keyword the number of orbitals
              to delete for each irrep is specified (nIrrep (# of irreps) integers).
              The next <= nIrrep lines reference the orbitals to delete for the
              related irrep, following an enumeration of the individual orbitals
              of 1, 2, 3,... according to
              increasing orbital energy. Note that the orbital reference numbers
              obey the original ordering.
              If the corresponding irrep does not contain any
              specific orbitals to freeze (i.e. a zero was supplied for this irrep in the
              1st line), no line orbital reference input line is supplied for that irrep.

:kword:`GHOStdelete`
  Excludes from PT2 treatment orbitals localized on ghost atoms. A threshold for this selection must be specified.

  .. xmldoc:: %%Keyword: GHOS <advanced>
              Excludes from PT2 treatment orbitals localized on ghost atoms. A threshold for this selection must be specified.

:kword:`LUMOrb`
  Molecular orbital coefficients and energies read from :file:`INPORB` file rather
  than :file:`RunFile`.

  .. xmldoc:: %%Keyword: LUMO <basic>
              Molecular orbital coefficients and energies read from INPORB file rather
              than RunFile.

:kword:`EREF`
  Specifies the value of the reference energy. Available only in combination
  with :kword:`LumOrb`. Default value of the reference energy is set to zero.

  .. xmldoc:: %%Keyword: EREF <basic>
              Specifies the value of the reference energy. Available only in combination
              with LumOrb. Default value of the reference energy is set to zero.

:kword:`TEST`
  If this keyword is specified the input is checked without performing any
  calculation.

  .. xmldoc:: %%Keyword: TEST <basic>
              If this keyword is specified the input is checked without performing any
              calculation.

:kword:`T1AM`
  Singles amplitudes/energy introduced according to Thouless formula.
  An INPORB file containing MOs different from HF orbitals is required.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="T1AM" APPEAR="Thouless singles amplitudes" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: T1AM <advanced>
              <HELP>
              Singles amplitudes/energy introduced according to Thouless formula.
              An INPORB file containing MOs different from HF orbitals is required.
              </HELP>
              </KEYWORD>

:kword:`LOVMp2`
  "Freeze-and-Delete" type of MP2, available only in connection with Cholesky or RI.
  An example of input for the keyword :kword:`LOVM` is the following: ::

    LovMP2
    2  0.2  (nCenters,thrs)
    C1 N    (Center labels)
    DoMP2

  In this case, both occupied and virtual orbitals (localized by the program) are divided in two groups: those (A) mainly located on the
  two (symmetry independent) centers C1 and C2, and the remaining ones (B), which are obviously "outside" this region.
  The value of the threshold (between 0 and 1) is used to perform this selection
  (in the example, 20% of the gross Mulliken population of a given orbital on the specified atoms).
  By default, the MP2 calculation is performed only for the correlating orbitals associated with the region A ("active site").
  The keyword :kword:`DoMP2` is optional and forces the program to perform also an independent MP2 calculation on
  the "frozen region" (B).
  Alternatively, one can specify the keyword :kword:`VirAll` in order to use all virtual orbitals as correlating space for the
  occupied orbitals of the active site.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="LOVMP2" APPEAR="Localized occupied-virtual MP2" LEVEL="ADVANCED" KIND="CUSTOM">
              %%Keyword: LOVM <advanced>
              <HELP>
              "Freeze-and-Delete" type of MP2, available only in connection with Cholesky or RI.
              An example of input for the keyword LOVM is the following:

                LovMP2
                2  0.2  (nCenters,thrs)
                C1 N    (Center labels)
                DoMP2

              In this case, both occupied and virtual orbitals (localized by the program) are divided in two groups: those (A) mainly located on the
              two (symmetry independent) centers C1 and N, and the remaining ones (B), which are obviously "outside" this region.
              The value of the threshold (between 0 and 1) is used to perform this selection
              (in the example, 20% of the gross Mulliken population of a given orbital on the specified atoms).
              By default, the MP2 calculation is performed only for the correlating orbitals associated with the region A ("active site").
              The keyword DoMP2 is optional and forces the program to perform also an independent MP2 calculation on
              the "frozen region" (B).
              Alternatively, one can specify the keyword VirAll in order to use all virtual orbitals as correlating space for the
              occupied orbitals of the active site.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="DOMP2" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="VIRALL" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`FNOMp2`
  Performs a Frozen Natural Orbital (FNO) MP2 calculation, available only in combination with Cholesky or RI integral representation.
  An example of input for the keyword :kword:`FNOM` is the following: ::

    FNOMp2
    0.4
    DoMP2

  The keyword :kword:`FNOM` has one compulsory argument (real number in ]0,1]) specifying the fraction of virtual orbitals
  (in each irrep) to be retained in the FNO-MP2 calculation.
  The keyword :kword:`DoMP2` is optional and used to compute the (estimated) correction for the truncation error.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="FNOMP2" APPEAR="Frozen natural orbital MP2" LEVEL="ADVANCED" KIND="REAL">
              %%Keyword: FNOM <advanced>
              <HELP>
              Performs a Frozen Natural Orbital (FNO) MP2 calculation, available only in combination with Cholesky or RI integral representation
              An example of input for the keyword FNOM is the following:

                FNOMp2
                 0.4
                DoMP2

              The keyword FNOM has one compulsory argument (real number in ]0,1]) specifying the fraction of virtual orbitals
              (in each irrep) to be retained in the FNO-MP2 calculation.
              The keyword DoMP2 is optional and used to compute the (estimated) correction for the truncation error.
              </HELP>
              </KEYWORD>

:kword:`PRPT`
  Multipole moments (dipoles and quadrupoles) are calculated and printed. The moments
  are calculated by using a variational one-particle MP2 density matrix.
  The calculation of the density matrix substantially increases
  the computational effort compared to an ordinary energy calculation. If the call
  to :program:`MBPT2` is followed by a :program:`LoProp` call the variational MP2
  density matrix will automatically be passed on to that module when this keyword
  is active.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="PRPT" APPEAR="Properties" LEVEL="BASIC" KIND="SINGLE">
              <HELP>
              Multipole moments are calculated and printed.
              </HELP>
              %%Keyword: PrPt <basic>
              Multipole moments (dipoles and quadrupoles) are calculated and printed.
              The computational effort is increased substantially compared to an energy-only
              calculation.
              </KEYWORD>

:kword:`GRDT`
  Variational one and two-particle MP2 densities are calculated to prepare for
  analytical gradient calculations. The default for subsequent gradient
  calculations are changed from numerical to analytical when this keyword is
  invoked. When using :program:`mbpt2` in a :program:`slapaf`\-loop with only :math:`C_1` symmetry
  analytical gradients are automatically default and this keyword is not
  needed. :kword:`grdt`
  prints Multipole moments and prepare for :program:`LoProp` in the exact same way
  as :kword:`prpt`.
  Use of this keyword therefore makes it
  redundant (but harmless) to also specify the keyword :kword:`prpt`.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="GRDT" APPEAR="Analytic Gradient" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="NOGRDT">
              %%Keyword: Grdt <advanced>
              <HELP>
              Analytical gradients are used in subsequent gradient calculations.
              </HELP>
              </KEYWORD>

:kword:`NOGRdt`
  Disables the calculation of variational densities for analytical gradients.
  This is useful to cancel the implicit :kword:`grdt` added when using :program:`mbpt2`
  inside a :program:`slapaf`\-loop, if no analytical gradients are actually needed.
  Note that using the :kword:`Numerical` keyword in :program:`gateway` already disables
  :kword:`grdt`, so :kword:`nogrdt` is only needed in some advanced situations.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="NOGRDT" APPEAR="No Analytic Gradient" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="GRDT">
              %%Keyword: NoGrdt <advanced>
              <HELP>
              Disables calculation of variational densities for analytical gradients.
              </HELP>
              </KEYWORD>

Optional keywords specific to Cholesky calculations
...................................................

*Observe* that these keywords are disregarded if the integrals
were not Cholesky decomposed by :program:`SEWARD`. Furthermore, they
are disregarded for algorithm 0 (see below).

.. class:: keywordlist

:kword:`CHOAlgorithm`
  Takes as argument one positive integer specifying
  the algorithm to use for Cholesky MP2.
  Options: 0 [generate MO integrals on disk from Cholesky vectors],
  1 [compute integrals on-the-fly, minimal operation count, level 2 BLAS],
  2 [compute integrals on-the-fly, not minimal operation count, level 3 BLAS],
  Default is 2.

  .. xmldoc:: <GROUP MODULE="MBPT2" NAME="CHOINPUT" APPEAR="Cholesky input section" KIND="BOX" LEVEL="ADVANCED">

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="CHOALGORITHM" APPEAR="CD algorithm" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="2">
              %%Keyword: ChoAlgorithm <advanced>
              <HELP>
              Specifies the algorithm to use for Cholesky MP2.
              </HELP>
              Options:

              0 -- generate MO integrals on disk from Cholesky vectors
              1 -- compute integrals on-the-fly, minimal operation count
              2 -- compute integrals on-the-fly, minimal disk access (default)
              </KEYWORD>

:kword:`VERBose`
  Increases printing from the Cholesky MP2 routines, although not
  by much.
  Default is (almost) no printing.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="VERBOSE" APPEAR="Verbose printout" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: Verbose <advanced>
              <HELP>
              Increases printing from the Cholesky MP2 routines.
              </HELP>
              </KEYWORD>

:kword:`DECOmpose`
  Requests Cholesky decomposition of the :math:`(ai|bj)` integrals.
  Unless user-defined (see below), the threshold used is identical
  to that used by :program:`SEWARD` for decomposing the two-electron
  integrals. Default is to not decompose.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="DECOMPOSE" APPEAR="MO integrals CD" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: Decompose <advanced>
              <HELP>
              Requests Cholesky decomposition of the (ai|bj) integrals.
              </HELP>
              </KEYWORD>

:kword:`THRCholesky`
  Specifies the threshold for :math:`(ai|bj)` Cholesky decomposition.
  Takes as argument one real number.
  Default is the threshold used by :program:`SEWARD` for decomposing the two-electron
  integrals.

  .. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="THRCHOLESKY" APPEAR="CD threshold" LEVEL="ADVANCED" KIND="REAL">
              %%Keyword: ThrCholesky <advanced>
              <HELP>
              Specifies the threshold for (ai|bj) Cholesky decomposition.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`NODEcompose`
  Turns off Cholesky decomposition of the :math:`(ai|bj)` integrals.
  Default is to not decompose.

  .. xmldoc:: %%Keyword: Nodecompose <advanced>
              Turns off Cholesky decomposition of the (ai|bj) integrals.

:kword:`SPAN`
  Specifies the span factor used for :math:`(ai|bj)` Cholesky decomposition.
  Takes as argument one real number.
  Default is the span factor used by :program:`SEWARD` for decomposing the two-electron
  integrals.

  .. xmldoc:: %%Keyword: Span <advanced>
              Specifies the span factor used for (ai|bj) Cholesky decomposition.

:kword:`MXQUal`
  Specifies the max. number of qualified diagonals treated during :math:`(ai|bj)` Cholesky decomposition.
  Takes as argument one integer.
  Default is 10% of the max. rank of :math:`(ai|bj)`, although never more than 200.

  .. xmldoc:: %%Keyword: MxQual <advanced>
              Specifies the max. number of qualified diagonals treated during (ai|bj) Cholesky decomposition.

:kword:`PRESort`
  Presort the MO Cholesky vectors according to the batches over occupied orbitals.
  This will reduce the amount of I/O performed during on-the-fly
  assembly of the :math:`(ai|bj)` integrals.
  This keyword is obsolete.

  .. Default is to sort when more than 2 batches over occupied orbitals are required.

  .. xmldoc:: %%Keyword: Presort <advanced>
              Presort the MO Cholesky vectors according to the batches over occupied orbitals.

Limitations
...........

The limitations on the number of basis functions are the same as specified
for :program:`SEWARD`.

Input example
.............

::

  &MBPT2
  Title
   H2O:  O(9.5/4.2), H(4/2)
  * The lowest energy occupied orbital in the repr. no.1 will be frozen in
  * MBPT2 calculations. The number of representations is 4 and all zeros
  * must be explicitly given
  Frozen
  1 0 0 0
  * Two highest energy external orbitals in the repr. no.3 will be deleted
  * in MBPT2 calculations. The number of representations is 4 and all
  * zeros must be explicitly given
  Deleted
  0 0 2 0
  * One occupied orbital in symmetry no.1 will be additionally frozen by
  * using the SFRO option. Let it be the third SCF occupied orbital in
  * this symmetry
  sFrozen
  1 0 0 0   // Gives the number of frozen orbitals in each symmetry
  3         // Gives the frozen orbital reference number in symmetry no. 1
  * Two external orbitals in symmetry no.1 and one external orbital in
  * symmetry 3 will be deleted. In symmetry 1 let it be the second and
  * third external orbitals, and in symmetry 3 the third (already deleted
  * in by using the option DELE) external orbital
  sDeleted
  2 0 1 0   // Gives the number of orbitals to be deleted in each symmetry
  2 3       // Gives the reference numbers of external orbitals in sym. 1
  3         // Gives the reference number of the external orb. in sym. 3

.. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="SOSMP2" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

.. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="FORCEBATCH" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

.. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="OEDTHRESHOLD" LEVEL="UNDOCUMENTED" KIND="REAL" />

.. xmldoc:: <KEYWORD MODULE="MBPT2" NAME="OSFACTOR" LEVEL="UNDOCUMENTED" KIND="REAL" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; CASPT2
   single: CASPT2

.. _UG\:sec\:caspt2:

:program:`caspt2`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="CASPT2">
            %%Description:
            <HELP>
            The CASPT2 program is used to compute a dynamic correlation correction to
            a RASSCF energy, and optionally to the density matrix and properties.
            It can be regarded as a Møller-Plesset perturbation method through
            second order (MP2), except that is is equally useful for general RASSCF
            root functions, also excited states, regardless of symmetry and multiplicity.
            </HELP>

Second order multiconfigurational perturbation theory is used in the program
:program:`CASPT2` :cite:`Andersson:90,Andersson:92a` to compute the (dynamic)
:index:`correlation energy <single: Perturbation theory; CASPT2>`. The reference state is
usually of the CAS type, but the program has been extended to also accept
RAS reference states :cite:`Malmqvist:2008,Sauri:2011`.
The first step is therefore a RASSCF calculation and the CASPT2
calculation gives a second order estimate of the difference between the RASSCF
and the full CI energy. For calculations using a true RAS reference, benchmark
calculations were reported by Sauri et al. :cite:`Sauri:2011`. For CASSCF
references, the CASPT2 method has been tested in a large number
of applications :cite:`Roos:95a,Roos:96b`. Here follows a brief summary of
results.

.. index::
   single: CASPT2; Precision
   single: Bond length; CASPT2
   single: Bond energy; CASPT2
   single: Heat of reaction; CASPT2

Bond distances are normally obtained with an accuracy of better that 0.01
Å for bonds between first and second row atoms. With the standard Fock
matrix formulation, bond energies are normally underestimated with between 2
and 5 kcal/mol for each bond formed. This is due to a systematic error in the
method :cite:`Andersson:93a`. In every process where the number of paired
electrons is changed, an error of this size will occur for each electron pair.
For example, the singlet-triplet energy difference in the methylene radical
(:math:`\ce{CH2}`) is overestimated with about 3 kcal/mol :cite:`Andersson:92a`. Heats of
reactions for isogyric reactions are predicted with an accuracy of |+-|\ 2
kcal/mol. These results have been obtained with saturated basis sets and all
valence electrons active. The use of smaller basis sets and other types of
active spaces may, of course, affect the error.

These systematic errors have recently been considerably reduced by the
introduction of a modified zeroth order Hamiltonian :cite:`Ghigo:04a`. The method
introduces a shift (the IPEA shift) that modifies the energies of active
orbitals such that they become closer to ionization energies when excited from
and closer to electron affinities when excited out of. The approach has been
tested for 49 diatomic molecules, reducing the mean error in :math:`D_0` from 0.2 to
0.1 eV. For the triply bonded molecules :math:`\ce{N2}`, :math:`\ce{P2}`, and :math:`\ce{As2}` it was reduced
from 0.45 eV to less than 0.15 eV. Similar improvements were obtained for
excitation and ionization energies. The IPEA modified :math:`H_0` (with a shift
parameter of 0.25) is default in |molcas| from version 6.4.
If :variable:`MOLCAS_NEW_DEFAULTS` is set to ``YES``, the default will be no IPEA shift.

An alternative to IPEA is to use the options, called ":math:`g_1`", ":math:`g_2`", and
":math:`g_3`" (See Ref. :cite:`Andersson:95a`), that stabilizes the energies of the
active orbitals. The remaining error is no longer systematic, and is generally
reduced. For example, the error in the singlet-triplet separation of :math:`\ce{CH2}` is
reduced to 1 kcal/mol :cite:`Andersson:95a`. This option is, however, not
recommended any longer because it has been replaced by the IPEA Hamiltonian.

The CASPT2 method can be used in any case where a valid reference function can
be obtained with the CASSCF method. There is thus no restriction in the number
of open shells or the spin coupling of the electrons. Excited states can be
treated at the same level as ground states. Actually one of the major
successes with the method has been in the calculation of excitation energies.
A large number of applications have been performed for conjugated organic
molecules. Both :index:`Rydberg <single: Rydberg states; CASPT2>` and valence excited states can be treated and the
:index:`error in computed excitation energies <single: Excitation energy; CASPT2>` is normally in the range 0.0--0.2 eV.
Similar results have been obtained for ligand field and charge-transfer
excitations in transition metal compounds. From |molcasvi| it is possible to use
the CASPT2 method in conjunction with the Douglas--Kroll--Hess relativistic
Hamiltonian, which has made possible calculations on heavy element compounds
such a third row transition metal compounds and actinides with accurate results.

The CASPT2 method can also be used in combination with the :program:`FFPT`
program to compute dynamic correlation contributions to properties with good
results in most cases. Numerical gradients are available with the
:program:`slapaf` module.

The CASPT2 method is based on second order perturbation theory. To be
successful, the perturbation should be small. A correct selection of
the active space in the preceding CASSCF calculation is therefore of
utmost importance. All near-degeneracy effects leading to configurations
with large weights must be included at this stage of the calculation.
If this is not done, the first order wave function will contain large
coefficients. When this occurs, the :program:`CASPT2` program issues a warning.
If the energy contribution from such a configuration is large, the results is
not to be trusted and a new selection of the active space should be made.

Especially in calculations on excited states, :index:`intruder <single: Intruders; CASPT2>` states may occur in the
first order wave function. Warnings are then issued by
the program that an energy denominator is small or negative. Such intruder
states often arise from Rydberg orbitals, which have not been included in the
active space. Even if this sometimes leads to large first order CI coefficients,
the contribution to the second order energy is usually very small, since the
interaction with the intruding Rydberg state is small. It might then be
safe to neglect the warning. A safer procedure is to include the Rydberg
orbital into the active space. It can sometimes be deleted from the MO space.

Calculations on compounds with heavy atoms (transition metals, actinides, etc.)
may yield many virtual orbitals with low energies. The interaction energies for
excitations to states where these orbitals are occupied are often very small and
the low denominators can then be removed by a suitable level shift (see below).
But it is always safer to include such orbitals in the active space.

Two keywords have been introduced to deal with this fairly common
situation, for excited states, that weakly coupled intruders cause
spurious singularities, "spikes" in e.g. a potential curve. The two
keywords :kword:`SHIFT` and :kword:`IMAGINARY SHIFT` (mutually exclusive) will introduce a :index:`shift <single: Level shift; CASPT2>`
in the energy denominators,
thus avoiding singularities, and will also correct the energy for the use of
this shift. The net effect is that the energy is almost unaffected except in
the vicinity of the weak singularity, which is removed. The :kword:`SHIFT` keyword adds
a real shift, and the use of this procedure is well tested
:cite:`Roos:95b,Roos:96a`. The :kword:`IMAGINARY SHIFT` adds an imaginary quantity, and
then uses the real value of the resulting second-order energy
:cite:`Forsberg:96`. This offers some advantage, in particular for weak intruder
states.

In some cases, where one can expect strong interaction between different CASSCF
wave functions, it is advisable to use the Multi-State (MS) CASPT2 method
:cite:`Finley:98b`, the extended Multi-State (XMS) method :cite:`Granovsky2011,Shiozaki2011`
or the new extended dynamically weighted CASPT2 :cite:`Battaglia2020`.
A second order effective Hamiltonian is constructed for a
number of CASSCF wave functions obtained in a state-average calculation. This
introduces interaction matrix elements at second order between the different
CASSCF states. The effective Hamiltonian is diagonalized to obtain the final
second order energies. The program also produces a file, :file:`JOBMIX`, with the new
effective zeroth order wave functions, which are linear combinations of the
original CASSCF states. This method has been used successfully to separate
artificially mixed valence and Rydberg states and for transition metal compounds
with low lying excited states of the same symmetry as the ground state.
In the original multi-state method,
perturbed wave functions are computed for each of several root functions,
separately; these are used to compute the effective Hamiltonian.
In the XMS-CASPT2 method, the perturbations are computed with one
common zeroth-order Hamiltonian.
The new XDW-CASPT2 method interpolates between the MS and XMS variants,
retaining the advantages of both approaches.

It is clear from the discussion above that it is not a "black box" procedure
to perform CASPT2 calculations on excited states. It is often necessary to
iterate the procedure with modifications of the active space and the selection
of roots in the CASSCF calculation until a stable result is obtained. Normally,
the CASSCF calculations are performed as average calculations over the number
of electronic states of interest, or a larger number of states.
It is imperative that the result is checked
before the CASPT2 calculations are performed. The solutions should contain
the interesting states. If all of them are not there, the number of roots in
the CASSCF calculation has to be increased. Suppose for example, that four
states of a given symmetry are required. Two of them are valence excited states
and two are Rydberg states. A CASSCF calculation is performed as an average
over four roots. Inspection of the solution shows only one valence excited
state, the other three are Rydberg states. After several trials it turns out
that the second valence excited state occurs as root number seven in the
CASSCF calculation. The reason for such a behavior is, of course, the
very different dynamic correlation energies of the valence excited states as
compared to the Rydberg states. It is important that the AO basis set is
chosen to contain a good representation of the Rydberg orbitals, in order to
separate them from the valence excited states. For more details on how to
perform calculations on excited states we refer to the
literature :cite:`Roos:95b,Roos:96a` and :numref:`TUT:sec:excited` of
the examples manual.

The first order wave function is obtained in the :program:`CASPT2` program as an
iterative solution to a large set of linear equations. The size of the
equation system is approximately :math:`n^2 m^2/2` where :math:`n` is the sum of inactive
and active orbitals and :math:`m` is the sum of active and secondary orbitals.
Symmetry will reduce the size with approximately a factor :math:`g_{\text{sym}}`, the
number of irreps of the point group.

:program:`CASPT2` produces a set of :index:`molecular orbitals <pair: Orbitals; CASPT2>` that can be used
as start orbitals for other programs or further calculations.
A minimal CASSCF and CASPT2 gives orbitals and occupation numbers
which can be used to design a proper larger calculation.
By default, the orbitals are natural orbitals obtained from the
density matrix of the (normalized) wave function through first order.
However, the active/active block of that density matrix is not computed
exactly. An approximation has been designed in such a way that the trace
is correct, and the natural occupation numbers of active orbitals are
between zero and two. Due to the approximation, any properties computed
using these orbitals are inexact and can be used only qualitatively. An exact
first order density matrix can be computed but this is more time-consuming. It
is controlled by the keyword :kword:`DENSity`. Use this keyword to compute
properties like dipole moments, etc. The most secure accurate way to do that is.
however, to use finite field perturbation theory (FFPT).

.. index::
   pair: Dependencies; CASPT2

.. _UG\:sec\:caspt2_dependencies:

Dependencies
------------

The :program:`CASPT2` program needs the :file:`JOBIPH` file from a :program:`RASSCF`
calculation, and in addition one- and two-electron integrals and some auxiliary
files from :program:`SEWARD`.

.. index::
   pair: Files; CASPT2

.. _UG\:sec\:caspt2_files:

Files
-----

Input files
...........

:program:`CASPT2` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`JOBIPH`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist

:file:`PT2ORB`
  Molecular orbitals.

.. index::
   pair: Input; CASPT2

.. _UG\:sec\:caspt2_input:

Input
-----

This section describes the input to the :program:`CASPT2` program, starting with its name: ::

  &CASPT2

.. index::
   pair: Keywords; CASPT2

Keywords
........

.. class:: keywordlist

:kword:`TITLe`
  This keyword is followed by one title line.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              Enter one title line for this job.
              </HELP>
              </KEYWORD>

:kword:`MULTistate`
  Perform a single-state CASPT2 (SS-CASPT2) or a multi-state CASPT2 (MS-CASPT2)
  calculation.
  Enter the total number of states desired followed by a list of which CASSCF
  roots to include, for example "``3 1 2 4``" would specify a 3-state calculation
  including the first, second and fourth root.
  To perform a single-state calculation, simply enter "``1``" followed by
  the desired root state, for example "``1 3``" would specify the third root.
  The special value "``all``" can be used if all the states included in the
  CASSCF calculation (keyword :kword:`CIRoot` in :program:`RASSCF`) are desired.
  This keyword is mutually exclusive with :kword:`XMULtistate` and :kword:`RMULtistate`.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="MULTISTATE" APPEAR="Multi-State" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC" EXCLUSIVE="XMULTISTATE,RMULTISTATE">
              <ALTERNATE KIND="CHOICE" LIST="all" />
              %%Keyword: Multistate <basic> GUI:list
              <HELP>
              Enter the number of states to include in the CASPT2 calculation
              followed by a list of numbers indicating which CASSCF roots to use.
              Alternatively, enter "all" to include all roots optimized in the
              CASSCF calculation.
              </HELP>
              </KEYWORD>

:kword:`XMULtistate`
  Perform an extended MS-CASPT2 (XMS-CASPT2) calculation according to :cite:`Granovsky2011,Shiozaki2011`.
  This keyword works in the same exact way as :kword:`MULTistate` and is
  mutually exclusive with :kword:`MULTistate` and :kword:`RMULtistate`.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="XMULTISTATE" APPEAR="Extended Multi-State" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC" EXCLUSIVE="MULTISTATE,RMULTISTATE">
              <ALTERNATE KIND="CHOICE" LIST="all" />
              %%Keyword: XMultistate <basic> GUI:list
              <HELP>
              Enter the number of states to include in the CASPT2 calculation
              followed by a list of numbers indicating which CASSCF roots to use.
              Alternatively, enter "all" to include all roots optimized in the
              CASSCF calculation.
              </HELP>
              </KEYWORD>

:kword:`RMULtistate`
  Perform a rotated MS-CASPT2 (RMS-CASPT2) calculation according to :cite:`Battaglia2021`.
  In this type of calculation the input CASSCF states are rotated to diagonalize the
  state-average Fock operator and subsequently used in a conventional MS-CASPT2 calculation.
  This keyword works in the same exact way as :kword:`MULTistate` and is
  mutually exclusive with :kword:`MULTistate` and :kword:`XMULtistate`.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="RMULTISTATE" APPEAR="Rotated Multi-State" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC" EXCLUSIVE="MULTISTATE,XMULTISTATE">
              <ALTERNATE KIND="CHOICE" LIST="all" />
              %%Keyword: RMultistate <basic> GUI:list
              <HELP>
              Enter the number of states to include in the CASPT2 calculation
              followed by a list of numbers indicating which CASSCF roots to use.
              Alternatively, enter "all" to include all roots optimized in the
              CASSCF calculation.
              </HELP>
              </KEYWORD>

:kword:`DWMS`
  Used in conjunction with :kword:`XMULtistate` and :kword:`DWTYpe` it performs
  an extended dynamically weighted CASPT2 (XDW-CASPT2) calculation according to
  :cite:`Battaglia2020,Battaglia2021`, thereby rotating the input CASSCF states
  to diagonalize the state-average Fock operator and constructing the zeroth-order
  Hamiltonians using dynamically weighted densities.
  A non-negative real number for the exponential factor :math:`\zeta`
  has to be explicitly specified; reasonable values associated to :kword:`DWTYpe`
  equal to 1, 2 and 3 are 50, 1e-8 and 1, respectively (see
  :cite:`Battaglia2020,Battaglia2021` for more details).
  It is also possible to use this option with :kword:`MULTistate` instead of
  :kword:`XMULtistate`, in which case the original CASSCF states are used
  instead of the rotated ones.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DWMS" APPEAR="Dynamically Weighted Multi-State" KIND="REAL" LEVEL="BASIC">
              %%Keyword: DWMS <basic> GUI:number
              <HELP>
              Enter a non-negative value specifying the exponent zeta used to
              compute the weights.
              </HELP>
              </KEYWORD>

:kword:`DWTYpe`
  This keyword specifies which exponent is used to compute the weights
  in a XDW-CASPT2 calculation.
  Three options are available: :kword:`DWTYpe` equal to 1 uses the squared energy
  difference between the states according to :cite:`Battaglia2020`. Note that this
  option might mix states of different symmetry.
  :kword:`DWTYpe` equal to 2 uses the square of the state total energy divided by
  the Hamiltonian coupling between the states, while :kword:`DWTYpe` equal to 3
  uses the energy difference divided by the square root of the
  Hamiltonian coupling (see :cite:`Battaglia2021` for more info).
  We suggest to use the third option associated with a value of 1 in
  :kword:`DWMS`.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DWTYPE" APPEAR="Dynamically Weighted Exponent" KIND="CHOICE" LIST="1: Squared energy difference,2: Square of total energy divided by Hamiltonian coupling,3: Energy difference divided by square root of Hamiltonian coupling" LEVEL="BASIC">
              %%Keyword: DWType <basic> GUI:number
              <HELP>
              Set to either 1, 2 or 3 to select the exponent used to obtain
              the weights in a XDW-CASPT2 calculation.
              </HELP>
              </KEYWORD>

:kword:`IPEAshift`
  This shift corrects the energies of the active orbitals and is
  specified in atomic units. It will be weighted by a function of the
  diagonal density matrix element :math:`D_{pp}`.
  This option is used to modify the standard definition of the
  zeroth order Hamiltonian (:math:`H_0`), which includes an IPEA shift of 0.25
  :cite:`Ghigo:04a`. The modification of :math:`H_0` has been introduced (Nov 2005) to
  reduce the systematic error which leads to a relative overestimation of the
  correlation energy for open shell system. It also reduces the intruder problems.
  Default is to use an IPEA shift of 0.25, unless :variable:`MOLCAS_NEW_DEFAULTS` is set to ``YES``.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="IPEA" APPEAR="IPEA shift" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.25">
              %%Keyword: IPEAshift <basic> GUI:number
              <HELP>
              Parameter (Default 0.25), adds a shift dependent on density matrix for active
              orbitals, reducing overestimated correlation energy for open shells.
              </HELP>
              </KEYWORD>

:kword:`IMAGinary`
  Add an imaginary shift to the external part of the zero order
  Hamiltonian. The correlation energy computed is the real part
  of the resulting complex perturbation energy.
  Also, a corrected
  value, obtained by Hylleraas' variational formula, is computed.
  See Ref. :cite:`Forsberg:96`.
  As with the real shift, this option is used to eliminate intruder
  problems.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="IMAGINARY" APPEAR="Imaginary shift" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.0">
              %%Keyword: Imaginary <advanced> GUI:number
              <HELP>
              Add an imaginary shift (Default 0.0) to eliminate weak intruders.
              </HELP>
              </KEYWORD>

:kword:`SHIFt`
  Add a shift to the external part of the zero order Hamiltonian.
  See Refs. :cite:`Forsberg:96,Roos:95b,Roos:96b`.
  In addition to the conventionally computed second order energy
  value, another energy obtained by Hylleraas' variational formula
  is computed. This energy is then very close to the unshifted
  energy, except close to singularities due to intruders.
  This option should only be used to eliminate intruder state problems.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="SHIFT" APPEAR="Real shift" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.0">
              %%Keyword: Shift  <advanced> GUI:number
              <HELP>
              Add a shift to the external part of the zero order Hamiltonian,
              which may shift away weak intruders. Imaginary shift is better.
              </HELP>
              </KEYWORD>

:kword:`AFREeze`
  This keyword is used to select atoms for defining the correlation orbital
  space for the CASPT2 calculation. Assume that you have a large molecule where
  the activity takes place in a limited region (the active site). It could be a
  metal atom with its surrounding ligands. You can then use this option to reduce
  the size of the CASPT2 calculation by freezing and deleting orbitals that have
  only a small population in the active site. An example: The cobalt imido complex
  :math:`\ce{Co^{III}(nacnac)(NPh)}` has 43 atoms. The active site was cobalt and the
  surrounding ligand atoms. Using the AFRE option reduces the time for the CASPT2
  calculation from 3 h to 3 min with a loss of accuracy in relative energies for
  24 electronic states of less than 0.1 eV. The first line after the keyword
  contains the number of selected atoms then the selection thresholds (the
  recommended value is 0.1 or less). An additional line gives the names of the
  atoms as defined in the Seward input. Here is a sample input for the cobalt
  complex mentioned above. ::

    AFREeze
     6 0.10 0.00
     Co N1 N2 C5 C6 C7

  This input means that inactive orbitals with less than 0.1 of the density on
  the active sites will be frozen, while no virtual orbitals will be deleted.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="AFREEZE" LEVEL="ADVANCED" KIND="CUSTOM">
              %%Keyword: AFREeze <advanced>
              <HELP>
              This keyword is used to select atoms for defining the correlation orbital
              space for the CASPT2 calculation. Inactive orbitals with Mulliken populations
              smaller than a given threshold on the selected atoms will be frozen and
              virtual orbitals will be deleted. The next line give the number of atoms and
              selection thresholds. An additional line gives the names of the atoms as
              defined in the Seward input. Use with care! Not much tested yet, but is very
              effective in reducing the computational time for CASPT2 in large molecules.
              </HELP>
              </KEYWORD>

:kword:`LOVCaspt2`
  "Freeze-and-Delete" type of CASPT2, available only in connection with Cholesky or RI.
  Needs (pseudo)canonical orbitals from RASSCF. An example of input for the keyword :kword:`LOVC` is the following: ::

    LovCASPT2
     0.3
    DoMP2  (or DoEnv)

  In this case, both occupied and virtual orbitals (localized by the program) are divided in two groups: those mainly located on
  the region determined (automatically) by the spatial extent of the active orbitals ("active site"),
  and the remaining ones, which are obviously "outside" this region.
  The value of the threshold (between 0 and 1) is used to perform this selection
  (in the example, 30% of the gross Mulliken population of a given orbital on the active site).
  By default, the CASPT2 calculation is performed only for the correlating orbitals associated with the active site.
  The keyword :kword:`DoMP2` is optional and forces the program to perform also an MP2 calculation on
  the "frozen region".
  Alternatively, one can specify the keyword :kword:`VirAll` in order to use all virtual orbitals as correlating space for the
  occupied orbitals of the active site.
  A third possibility is to use the keyword :kword:`DoEnv` to compute the energy of the environment as total MP2 energy
  minus the MP2 energy of the active site.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="LOVCASPT2" APPEAR="Localized occupied-virtual CASPT2" LEVEL="ADVANCED" KIND="REAL">
              %%Keyword: LOVC <advanced>
              <HELP>
              "Freeze-and-Delete" type of CASPT2, available only in connection with Cholesky or RI.
              Needs (pseudo)canonical orbitals from RASSCF. An example of input for the keyword LOVC is the following:

                LovCASPT2
                 0.3
                DoMP2  (or DoEnv)

              In this case, both occupied and virtual orbitals (localized by the program) are divided in two groups: those mainly located on
              the region determined (automatically) by the spatial extent of the active orbitals ("active site"),
              and the remaining ones, which are obviously "outside" this region.
              The value of the threshold (between 0 and 1) is used to perform this selection
              (in the example, 30% of the gross Mulliken population of a given orbital on the active site).
              By default, the CASPT2 calculation is performed only for the correlating orbitals associated with the active site.
              The keyword DoMP2 is optional and forces the program to perform also an MP2 calculation on
              the "frozen region".
              Alternatively, one can specify the keyword VirAll in order to use all virtual orbitals as correlating space for the
              occupied orbitals of the active site.
              A third possibility is to use the keyword DoEnv to compute the energy of the environment as total MP2 energy
              minus the MP2 energy of the active site.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DOMP2" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="VIRALL" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DOENV" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`FNOCaspt2`
  Performs a Frozen Natural Orbital (FNO) CASPT2 calculation, available only in combination with Cholesky or RI integral representation.
  Needs (pseudo)canonical orbitals from RASSCF. An example of input for the keyword :kword:`FNOC` is the following: ::

    FNOCaspt2
     0.4
    DoMP2

  The keyword :kword:`FNOC` has one compulsory argument (real number in ]0,1]) specifying the fraction of virtual orbitals
  (in each irrep) to be retained in the FNO-CASPT2 calculation.
  The keyword :kword:`DoMP2` is optional and used to compute the (estimated) correction for the truncation error.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="FNOCASPT2" APPEAR="Frozen natural orbital CASPT2" LEVEL="ADVANCED" KIND="REAL">
              %%Keyword: FNOC <advanced>
              <HELP>
              Performs a Frozen Natural Orbital (FNO) CASPT2 calculation, available only in combination with Cholesky or RI integral representation.
              Needs (pseudo)canonical orbitals from RASSCF. An example of input for the keyword FNOC is the following:

                FNOCaspt2
                 0.4
                DoMP2

              The keyword FNOC has one compulsory argument (real number in ]0,1]) specifying the fraction of virtual orbitals
              (in each irrep) to be retained in the FNO-CASPT2 calculation.
              The keyword DoMP2 is optional and used to compute the (estimated) correction for the truncation error.
              </HELP>
              </KEYWORD>

:kword:`FOCKtype`
  Use an alternative Fock matrix. The default Fock matrix is described in
  :cite:`Andersson:90,Andersson:92a` and the other original CASPT2 references.
  The three different modifications named G1, G2 and G3 are described in
  :cite:`Andersson:95a`.
  Note: from 6.4 it is not recommended to use this keyword but
  stay with the IPEA modified :math:`H_0`, which is default.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="FOCKTYPE" APPEAR="Fock type" KIND="CHOICE" LIST="G1,G2,G3" LEVEL="ADVANCED">
              %%Keyword: Focktype <basic> GUI:select(G1,G2,G3)
              <HELP>
              Present choices: G1, G2, G3. Refers to modified Fock matrices
              (See manual). It is better to use the default IPEA shift.
              </HELP>
              </KEYWORD>

:kword:`FROZen`
  This keyword is used to specify the number of frozen orbitals,
  i.e. the orbitals that are not correlated in the calculation.
  The next line contain the number of frozen orbitals per
  symmetry. The default is to freeze the maximum of those that were frozen in the
  :program:`RASSCF` calculation and the deep core orbitals.
  The frozen orbitals are always the first ones in each symmetry.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="FROZEN" APPEAR="Frozen" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" MIN_VALUE="0">
              %%Keyword: Frozen <advanced> GUI:list
              <HELP>
              Replace default number of frozen orbitals of each symmetry type with user input.
              Default: Those that were frozen in the RASSCF, or standard table dependent on
              basis set, whichever is larger.
              </HELP>
              </KEYWORD>

:kword:`DELEted`
  This keyword is used to specify the number of deleted orbitals,
  i.e. the orbitals that are not used as correlating orbitals in
  the calculation. The next line contain the number deleted orbitals per symmetry.
  The default is to delete those that were deleted in the :program:`RASSCF`
  calculation.
  The deleted orbitals are always the last ones in each symmetry.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DELETED" APPEAR="Deleted" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" MIN_VALUE="0">
              %%Keyword: Deleted <advanced>
              <HELP>
              Replace default number of deleted orbitals of each symmetry type with user input.
              Default: Those that were deleted in the RASSCF.
              </HELP>
              </KEYWORD>

:kword:`DENSity`
  Computes the full density matrix from the first order wave function,
  rather than approximated as is the (faster) default option. Used to
  compute :program:`CASPT2` properties, such as dipole moments, etc.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="DENSITY" APPEAR="Exact density" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Density <advanced>
              <HELP>
              Force calculation of accurate density matrix from the
              CASPT2 wave function. Used for dipole moments, etc.
              </HELP>
              </KEYWORD>

:kword:`RFPErt`
  This keyword makes the program add reaction field effects to the energy
  calculation. This is done by adding the reaction field effects to the
  one-electron Hamiltonian as a constant perturbation, i.e. the reaction field
  effect is not treated self consistently. The perturbation is extracted from RUNOLD,
  if that file is not present if defaults to RUNFILE.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="RFPERT" APPEAR="Reaction field perturbation" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: RFPert  <advanced>
              <HELP>
              Add reaction field from environment as static perturbation
              to the one-electron Hamiltonian.
              The perturbation is extracted from RUNOLD if it exists, otherwise from RUNFILE.
              </HELP>
              </KEYWORD>

:kword:`RLXRoot`
  Specifies which root to be relaxed in a geometry optimization of a
  multi-state CASPT2 wave function. Defaults to the highest root or
  root defined by the same keyword in the :program:`RASSCF` module.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="RLXROOT" APPEAR="Relaxed root" KIND="INT" LEVEL="ADVANCED" MIN_VALUE="1">
              %%Keyword: RLXRoot <advanced>
              <HELP>
              Which root to use in a geometry optimization of a
              multi-state CASPT2 wave function. Default: root
              defined by RLXROOT in the RASSCF module, if any,
              else the highest root.
              </HELP>
              </KEYWORD>

  .. :kword:`HZERo`
       (No official variants. Perhaps in later versions.)

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="HZERO" KIND="STRING" LEVEL="UNDOCUMENTED" />

:kword:`THREsholds`
  On next line, enter two
  thresholds: for removal of zero-norm components in the
  first-order perturbed wave function, and for removal of near linear
  dependencies in the first-order perturbed wave function. Default
  values are 1.0d-10 and 1.0d-08 respectively.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="THRESHOLD" APPEAR="Thresholds" KIND="REALS" SIZE="2" LEVEL="ADVANCED" DEFAULT_VALUES="1.0D-10,1.0D-8" MIN_VALUE="0.0">
              %%Keyword: Thresholds  <advanced>
              <HELP>
              The first threshold is for removing redundant excitations, the second is
              for removing linear dependences of standardized linear equation system.
              Default: 1.0d-10 and 1.0d-08.
              </HELP>
              </KEYWORD>

:kword:`MAXIter`
  On next line, enter the maximum allowed number of iterations
  in a procedure for solving a system of
  linear equations using a conjugate gradient method. Default is 20.
  A gradient norm is reported. This gradient is a residual error from the
  CASPT2 equation solution and should be small, else the number of iterations
  must be increased.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="MAXITER" APPEAR="Maximum iterations" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="20" MIN_VALUE="0">
              %%Keyword: MaxIter <advanced>
              <HELP>
              The maximum allowed number of iterations.
              (Zero iterations gives diagonal approximation. Default:20)
              </HELP>
              </KEYWORD>

:kword:`CONVergence`
  On next line, enter the convergence threshold for the procedure described above.
  The iterative procedure is repeated until the norm of the residual
  (RNORM) is less than this convergence threshold. Default is 1.0d-06.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="CONV" APPEAR="Convergence" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="1.0D-6" MIN_VALUE="0.0">
              %%Keyword: Convergence <advanced>
              <HELP>
              Convergence threshold for norm of residual vector. Default 1.0d-06
              </HELP>
              </KEYWORD>

:kword:`NOMIx`
  Normally, an (X)MS-CASPT2 calculation produces a new jobiph file named :file:`JOBMIX`.
  It has the same CASSCF wave functions as the original ones, except that those CI vectors
  that were used in the (Extended) Multi-State CASPT2 calculation have been mixed,
  using the eigenvectors of the effective Hamiltonian matrix as transformation coefficients.
  Keyword :kword:`NOMIX` prevents creation of this :file:`JOBMIX` file.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="NOMIX" APPEAR="No JobMix" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NoMix <advanced>
              <HELP>
              Do not produce a JobMix file, even if this is a multi-state calculation.
              </HELP>
              </KEYWORD>

:kword:`NOMUlt`
  This keyword removes the multi-state part of the calculation and only runs a
  series of independent CASPT2 calculations for the roots specified by the
  :kword:`MULTistate` or :kword:`XMULtistate` keyword. Useful when many roots are required,
  but multi-state is not needed, or desired. Note that a :file:`JOBMIX` file is produced
  anyway, but the vectors will not be mixed, and the energies will be single-state CASPT2
  energies. If used with the :kword:`XMULtistate` keyword, the zeroth-order Hamiltonian
  will be constructed with the state-average density and therefore will be the same for
  all the states.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="NOMULTI" APPEAR="No Multi-State" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoMultistate <basic>
              <HELP>
              Do just a series of independent CASPT2 runs, without any multi-state coupling.
              Useful when many roots are required, but multi-state is not needed, or desired.
              </HELP>
              </KEYWORD>

:kword:`ONLY`
  This keyword requires the :kword:`MULTistate` or :kword:`XMULtistate` keyword,
  and is followed by an integer specifying one of the roots.
  In a (Extended) Multistate calculation, it requests to compute the energy of
  only the specified root. However, the effective Hamiltonian coupling terms
  between this root and all the others included in the (Extended) Multistate
  treatment will be computed and printed out.
  This output will be used in a subsequent calculation, in conjunction
  with the :kword:`EFFE` keyword.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="ONLY" APPEAR="Only root" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: ONLY <advanced>
              <HELP>
              This keyword requires the MULTistate or XMULtistate keyword, and is
              followed by an integer specifying one of the roots.
              In a Multistate calculation, it requests to compute the energy of only
              the specified root. However, the effective Hamiltonian coupling terms
              between this root and all the others included in the Multistate
              treatment will be computed and printed out.
              This output will be used in a subsequent calculation, in conjunction
              with the EFFE keyword.
              </HELP>
              </KEYWORD>

:kword:`EFFE`
  This keyword requires the :kword:`MULTistate` or :kword:`XMULtistate` keyword.
  It is followed by the number of states and a matrix of real numbers,
  specifying the effective Hamiltonian couplings, as provided in a previous
  calculation using the :kword:`ONLY` keyword.
  In a (Extended) Multistate calculation over, e.g., 3 states, 3 separate
  calculations with the :kword:`ONLY` keyword will be performed, possibly
  on separate computing nodes, so as to speed up the overall process.
  The three couplings vectors will be given to the :kword:`EFFE`
  keyword in matrix form, i.e. the first column is made by the
  couplings of the first computed root, etc.
  The program will then quickly compute the (Extended) Multistate energies.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="EFFE" APPEAR="Effective Hamiltonian couplings" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: EFFE <advanced>
              <HELP>
              This keyword requires the MULTistate or XMULtistate keyword. It is
              followed by the number of states and a matrix of real numbers,
              specifying the effective Hamiltonian couplings, as provided in
              a previous calculation using the ONLY keyword.
              In a (Extended) Multistate calculation over, e.g., 3 states, 3 separate
              calculations with the ONLY keyword will be performed, possibly
              on separate computing nodes, so as to speed up the overall process.
              The three couplings vectors will be given to the EFFE
              keyword in matrix form, i.e. the first column is made by the
              couplings of the first computed root, etc.
              The program will then quickly compute the (Extended) Multistate energies.
              </HELP>
              </KEYWORD>

:kword:`NOORbitals`
  In calculations with very many orbitals, use this keyword to skip the
  printing of the MO orbitals.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="NOORBITALS" APPEAR="No orbitals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoOrbitals <basic>
              <HELP>
              Skip printing of the MO orbitals.
              </HELP>
              </KEYWORD>

:kword:`PROPerties`
  Normally, a CASPT2 calculation does not produce any density matrix,
  natural orbitals or properties in order to save time and memory
  (especially for large calculations).
  Keyword :kword:`PROP` activates these calculations, at the expense of (some)
  extra time and memory (especially if used together with the :kword:`DENS` keyword).

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="PROPERTIES" APPEAR="Properties" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Properties <basic>
              <HELP>
              Compute (approximate) density matrix, natural orbitals and properties.
              </HELP>
              </KEYWORD>

:kword:`NOTRansform`
  This keyword specifies that the wave function should not be transformed
  to use quasi-canonical orbitals, even if :program:`CASPT2` does not know if this
  was done or not and by default would do such a transformation.
  Effectively, the Fock matrix is replaced by a diagonal
  approximation in the input orbital system.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="NOTRANSFORM" APPEAR="No transform" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NoTransform <advanced>
              <HELP>
              Prevent transformation to pseudo-canonical orbitals, even if CASPT2
              would assumed this is needed (Default is: transform when assumed necessary.)
              </HELP>
              </KEYWORD>

:kword:`TRANsform`
  This keyword specifies that the wave function should be transformed
  to use pseudo-canonical orbitals, even if this was specified
  as option to the CASSCF calculation and should be unnecessary.
  (Default is: to transform when necessary, and not else.)

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="TRANSFORM" APPEAR="Transform" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Transform <advanced>
              <HELP>
              Demand transformation to pseudo-canonical orbitals
              even if this was specified as option of CASSCF so it ought to
              be unnecessary. (Default is: transform only when assumed necessary.)
              </HELP>
              </KEYWORD>

:kword:`OFEMbedding`
  Adds an Orbital-Free Embedding potential to the Hamiltonian. Available only in combination with Cholesky or RI integral representation.
  No arguments required. The runfile of the environment subsystem (:file:`AUXRFIL`) must be available.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="OFEMBEDDING" APPEAR="Orbital-free embedding" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: OFEM <advanced>
              <HELP>
              Adds an Orbital-Free Embedding potential to the Hamiltonian. Available only in combination with Cholesky or RI integral representation.
              No arguments required. The runfile of the environment subsystem (AUXRFIL) must be available.
              </HELP>
              </KEYWORD>

:kword:`GHOStdelete`
  Excludes from PT2 treatment orbitals localized on ghost atoms. A threshold for this selection must be specified.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="GHOSTDELETE" APPEAR="Ghost delete" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: GHOS <advanced>
              <HELP>
              Excludes from PT2 treatment orbitals localized on ghost atoms. A threshold for this selection must be specified.
              </HELP>
              </KEYWORD>

:kword:`OUTPut`
  Use this keyword, followed by any of the words :kword:`BRIEF`, :kword:`DEFAULT`, or :kword:`LONG`, to
  control the extent of orbital listing.
  :kword:`BRIEF` gives a very short orbital listing,
  :kword:`DEFAULT` a normal output, and :kword:`LONG` a detailed listing.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="OUTPUT" APPEAR="Orbital printing" KIND="CHOICE" LIST="BRIEF,DEFAULT,LONG" LEVEL="BASIC">
              %%Keyword: OUTPut <basic>
              <HELP>
              BRIEF gives a very short orbital listing,
              DEFAULT a normal output, and LONG a detailed listing.
              </HELP>
              </KEYWORD>

:kword:`PRWF`
  This keyword is used to specify the threshold for printing the
  CI coefficients, default is 0.05.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="PRWF" APPEAR="Print threshold" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.05" MIN_VALUE="0.0" MAX_VALUE="1.0">
              %%Keyword: PRWF <advanced>
              <HELP>
              Threshold for printing CI coefficients. Default 0.05.
              </HELP>
              </KEYWORD>

:kword:`PRSD`
  This keyword is used to request that not only CSFs are printed with
  the CI coefficients, but also the determinant expansion.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="PRSD" APPEAR="Print determinant expansion" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PRSD <advanced>
              <HELP>
              Activate printing of CSFs in terms of determinants.
              </HELP>
              </KEYWORD>

:kword:`CHEMps2`
  Activate DMRG-CASPT2 calculation with |molcas|--CheMPS2 interface.
  The keyword :kword:`3RDM` must be used in :program:`RASSCF`.
  The program will skip the calculations of the :math:`n`-particle reduced density matrix.
  Note that multi-state calculations are not supported, the calculation will run but produce wrong CASPT2 total energy.
  Always specify :kword:`MULTi` = 1 *iroot*, where *iroot* is the root index.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="CHEMPS2" APPEAR="DMRG-CASPT2 (CheMPS2)" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CHEMps2 <basic>
              <HELP>
              Activate DMRG-CASPT2 calculation with Molcas-CheMPS2 interface.
              </HELP>
              </KEYWORD>

:kword:`CUMUlant`
  Activate DMRG-cu(4)-CASPT2 calculation with |molcas|--Block interface.
  The keyword :kword:`3RDM` must be used in :program:`RASSCF`.
  The program will skip the calculations of the 3-particle reduced density matrix and approximate
  the 4-particle reduced density matrix.

  .. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="CUMULANT" APPEAR="DMRG-cu(4)-CASPT2 (Block)" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CUMUlant <basic>
              <HELP>
              Activate DMRG-cu(4)-CASPT2 calculation with Molcas-Block interface.
              </HELP>
              </KEYWORD>

The given default values for the keywords
:kword:`Convergence` and
:kword:`Thresholds` normally give a second order energy which is correct
in eight decimal places.

Input example
.............

::

  &CASPT2
  Title
   The water molecule
  Density matrix

The CASPT2 energy and density matrix is computed for the water molecule with the
O(1s) orbital frozen. The standard IPEA-:math:`H_0` is used.

Input example for SS-DMRG-CASPT2 with |molcas|--CheMPS2 interface

::

  &RASSCF
  Title    = Water molecule. Ground state
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0
  DMRG     = 500
  LUMOrb
  3RDM

  &CASPT2
  CHEMps2

Input example for SA-DMRG-CASPT2 with |molcas|--CheMPS2 interface

::

  &RASSCF
  Title    = Water molecule. Averaging two states
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0
  CIROot   = 2 2 1
  DMRG     = 500

  &RASSCF
  Title    = Ground state
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0
  CIROot   = 1 1 ; 1
  DMRG     = 500
  LUMOrb
  CIONly
  3RDM

  &CASPT2
  CHEMps2
  MULTistate = 1 1

  &RASSCF
  Title    = First excited state
  Spin     = 1
  Symmetry = 1
  Inactive = 2 0 1 0
  Ras2     = 2 2 0 0
  CIROot   = 1 2 ; 2
  DMRG     = 500
  CIONly
  3RDM

  &CASPT2
  CHEMps2
  MULTistate = 1 2

.. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="LROOT" KIND="INT" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="FILE" KIND="STRING" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="RHSD" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="WTHR" KIND="REALS" SIZE="3" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="CASPT2" NAME="G1SE" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; Surfacehop
   single: Surfacehop

.. _UG\:sec\:surfacehop:

:program:`surfacehop`
=====================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="SURFACEHOP">
            %%Description:
            <HELP>
            This module deals with surface hop semiclassical molecular dynamics (SHMD) and has to be used together with module DYNAMIX.
            Its purpose is the calculation of the relax root for the next step of the SHMD.
            </HELP>

This module deals with surface hop semiclassical molecular dynamics (SHMD) and has to be used together with module DYNAMIX. Its purpose is the calculation of the relax root for the next step of the SHMD. The implemented algorithm under this module is the Tully's fewest switches :cite:`Tully1990`, using the Hammes-Schiffer/Tully scheme :cite:`Hammes-Schiffer1994` and the decoherence correction proposed by Granucci and Persico :cite:`Granucci2007`. 

Under the Hammes-Schiffer/Tully scheme, the non-adiabatic population transfer between states of the same multiplicity is determined using the wavefunction overlap between the current timestep and the two previous timesteps, in an interpolation-extrapolation scheme. This is done in lieu of calculating explicitly the non-adiabatic coupling, and thus allows for surface-hopping when explicit non-adiabatic coupling is not available or is too expensive. 

There are two methods to calculate the wavefunction overlap available through the :program:`SURFACEHOP` module. The default implementation calls the :program:`RASSI` module to obtain the overlap matrix between all states at the current and previous timestep. The alternative method (previously default) can be requested using the keyword :kword:`NORASSI` and uses instead a dot product of the CI vectors to approximate the overlap matrix.  

.. _UG\:sec\:surfacehop_output_files:

Output files
............

.. class:: filelist

:file:`RUNFILE`
  Surface hop information such as Amatrix and CI coefficients for previous steps are stored in this file.

:file:`$Project.md.xyz`
  Contains the geometry of every timestep in the dynamics, in standard xyz coordinates.

:file:`$Project.md.energies`
  Contains the Potential energy of the current active state, Kinetic energy, and Total energy of the system throughout the simulation, followed by the potential energies of all states in the dynamics.

.. _UG\:sec\:surfacehop_inp:

Input
-----

::

  &Gateway
  coord=$Project.xyz
  basis=6-31G*
  group=nosym

  >> EXPORT MOLCAS_MAXITER=400
  >> DOWHILE

  &Seward

  &rasscf
   jobiph
   cirestart
   nactel = 6 0 0
   inactive = 23
   ras2 = 6
   ciroot = 2 2 1
   prwf = 0.0
   mdrlxroot = 2

  &Surfacehop
   tully
   decoherence = 0.1
   psub

  &alaska

  &Dynamix
   velver
   dt = 41.3
   velo = 1
   thermo = 0
  >>> End Do

General keywords
................

.. class:: keywordlist

:kword:`TULLY`
  This keyword enables the Tully--Hammes-Schiffer integration of the TDSE for the Tully Surface Hop Algorithm. If you use this keyword you should not use the :kword:`HOP` keyword in :program:`DYNAMIX`.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="TULLY" APPEAR="Tully surface hop" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: TULLy <basic>
              <HELP>
              This keyword enables the Tully--Hammes-Schiffer integration of the TDSE for the Tully Surface Hop Algorithm.
              </HELP>
              </KEYWORD>

:kword:`NORASSI`
  This keyword must be used after the :kword:`TULLY` keyword. It disables the use of :program:`RASSI` to calculate wavefunction overlaps, instead using the dot product of CI vectors (previous default option). 

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="NORASSI" APPEAR="Wavefunction Overlap by CI vectors" KIND="SINGLE" LEVEL="BASIC" REQUIRE="TULLY">
              %%Keyword: NORAssi <basic>
              This keyword must be used after the TULLY keyword.
              <HELP>
              It disables the use of RASSI to calculate wavefunction overlaps.
              </HELP>
              </KEYWORD>

:kword:`DECOHERENCE`
  This keyword must be used after the :kword:`TULLY` keyword. It enables the decoherence correction in the population density matrix as reported by Persico and Granucci. The value is called decay factor and it is usually 0.1 hartree. It can be seen as how strongly this correction is applied. It is recommendable to leave it to 0.1, unless you really know what you're doing.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="DECOHERENCE" APPEAR="Decoherence correction" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.1" REQUIRE="TULLY">
              %%Keyword: DECOherence <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              It enables the decoherence correction in the population density matrix as reported by Persico-Granucci.
              </HELP>
              </KEYWORD>

:kword:`SUBSTEP`
  This keyword must be used after the :kword:`TULLY` keyword. This keyword specifies how many steps of integration we use to interpolate/extrapolate between two Newton's consecutive steps. The default is usually a good compromise between quickness and precision (200 substeps each femtoseconds of MD).

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="SUBSTEP" APPEAR="Electronic integration substeps" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="200" MIN_VALUE="0" REQUIRE="TULLY">
              %%Keyword: SUBStep <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              It specifies how many steps of integration we use to interpolate/extrapolate between two Newton's consecutive steps.
              </HELP>
              </KEYWORD>

:kword:`PSUB`
  This keyword must be used after the :kword:`TULLY` keyword. To print in |molcas| output :math:`\mat{D}` matrix, :math:`\mat{A}` matrix, :math:`\mat{B}` matrix, probabilities, randoms, population and energies at each substep (quite verbose, but gives you a lot of useful information).

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="PSUB" APPEAR="Verbose output for each substep" KIND="SINGLE" LEVEL="BASIC" REQUIRE="TULLY">
              %%Keyword: PSUB <basic>
              This keyword must be used after the TULLY keyword.
              <HELP>
              To print in molcas output D matrix, A matrix, B matrix, probabilities, randoms, population and energies at each substep.
              </HELP>
              </KEYWORD>

:kword:`DMTX`
  This keyword must be used after the :kword:`TULLY` keyword. With this keyword you can start your calculation with an initial :math:`\mat{A}` matrix (population density matrix). It is a complex matrix. In the first line after the keyword you must specify its dimension :math:`N`. Then :math:`N` lines (:math:`N` values each line) with the real part of the matrix followed by :math:`N` more lines with the imaginary part.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="DMTX" APPEAR="Initial population density matrix" KIND="UNKNOWN" LEVEL="ADVANCED" REQUIRE="TULLY">
              %%Keyword: DMTX <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              Initial A matrix (population density matrix). It is a complex matrix.
              In the first line after the keyword you must specify its dimension N. Then N lines (with N values each line) with the REAL part of the matrix followed by N more lines with the imaginary part.
              </HELP>
              </KEYWORD>

:kword:`FRANDOM`
  This keyword must be used after the :kword:`TULLY` keyword. It fixes the random number to one provided by the user, in case a deterministic trajectory is needed

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="FRANDOM" APPEAR="Random number constant (deterministic MD)" KIND="REAL" LEVEL="ADVANCED" REQUIRE="TULLY">
              %%Keyword: FRANdom <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              It fixes the random number to one provided by the user, in case a deterministic trajectory is needed.
              </HELP>
              </KEYWORD>

:kword:`ISEED`
  This keyword must be used after the :kword:`TULLY` keyword. The initial seed number is read from the input file. Then, seed numbers are modified (in a deterministic way), saved in the :file:`RunFile` and read in the next call to the module. This way, MD simulations are reproducible.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="ISEED" APPEAR="Initial seed number (reproducible MD)" KIND="INT" LEVEL="ADVANCED" REQUIRE="TULLY">
              %%Keyword: ISEEd <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              The initial seed number is read from the input file.
              Then, seed numbers are modified (in a deterministic way), saved in the RunFile and read in the next call to the module.
              This way, MD simulations are reproducible.
              </HELP>
              </KEYWORD>

:kword:`MAXHOP`
  This keyword must be used after the :kword:`TULLY` keyword. It specifies how many non-adiabatic transitions are allowed between electronic states.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="MAXHOP" APPEAR="Maximum number of hops allowed" KIND="INT" LEVEL="ADVANCED" REQUIRE="TULLY">
              %%Keyword: MAXHop <advanced>
              This keyword must be used after the TULLY keyword.
              <HELP>
              It specifies how many non-adiabatic transitions are allowed between electronic states.
              </HELP>
              </KEYWORD>

:kword:`H5RESTART`
  This keyword allows to restart a surface hopping trajectory calculation from an HDF5 file.
  The name of the restart file is given on the next line.

  .. xmldoc:: <KEYWORD MODULE="SURFACEHOP" NAME="H5RESTART" APPEAR="Restart the surface hopping trajectory from an H5 file" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: H5REstart <advanced>
              <HELP>
              Restarts a surface hopping trajectory calculation from an HDF5 file, whose name is given on the next line.
              </HELP>
              </KEYWORD>

Input examples
..............

This example shows an excited state CASSCF MD simulation
of a methaniminium cation using the Tully Surface Hop algorithm.
Within the :program:`Surfacehop` module The keyword :kword:`TULLY` enables the TDSE integration. The options used in this case are:
(:kword:`SUBSTEP`\=200) to specify 200 substep of electronic integration between Newton's,
(:kword:`DECOHERENCE`\=1) to deal with the decoherence using a decay constant of 0.1 hartree and
(:kword:`PSUB`) to print the substeps matrices verbosely into the |molcas| log.

.. extractfile:: ug/surfacehopTULLY.input

  &GATEWAY
   COORD
   6
   Angstrom
   C  0.00031448  0.00000000  0.04334060
   N  0.00062994  0.00000000  1.32317716
   H  0.92882820  0.00000000 -0.49115611
   H -0.92846597  0.00000000 -0.49069213
   H -0.85725321  0.00000000  1.86103989
   H  0.85877656  0.00000000  1.86062860
   BASIS= 3-21G
   GROUP= nosym

  >> EXPORT MOLCAS_MAXITER=1000
  >> DOWHILE

  &SEWARD

  >> IF ( ITER = 1 )

  &RASSCF
    LUMORB
   FileOrb= $Project.GssOrb
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1

  >> COPY $Project.JobIph $Project.JobOld

  >> ENDIF

  &RASSCF
   JOBIPH; CIRESTART
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1
   MDRLXR= 2

  >> COPY $Project.JobIph $Project.JobOld

  &surfacehop
   TULLY
   SUBSTEP = 200
   DECOHERENCE = 0.1
   PSUB

  &ALASKA

  &Dynamix
   VELVer
   DT= 10.0
   VELO= 3
   THER= 2
   TEMP=300

  >> END DO

.. xmldoc:: </MODULE>
.. index::
   single: Program; LoProp
   single: LoProp

.. _UG\:sec\:loprop:

:program:`LoProp`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="LOPROP">
            %%Description:
            <HELP>
            A tool to compute molecular properties based on the one-electron density
            or transition-density and one-electron integrals like charges, dipole moments
            and polarizabilities
            </HELP>

The program
:program:`LoProp`
is a tool to compute molecular properties based on the one-electron density
or transition-density and one-electron integrals like charges, dipole moments and polarizabilities.
:program:`LoProp` allows to partition such properties into atomic and interatomic
contributions. The method requires a subdivision of the atomic orbitals into
occupied and virtual basis functions for each atom in the molecular system.
It is a requirement for the approach to have any physical significance that the
basis functions which are classified as "occupied" essentially are the atomic
orbitals of each species. It is therefore advisable to use an ANO type basis set,
or at least a basis set with general contraction.

The localization procedure is organized into a series of orthogonalizations of
the original basis set, which will have as a final result a localized
orthonormal basis set.
**Note that this module does not operate with symmetry.**

A static property, which can be evaluated as an expectation value, like a charge,
a component of the dipole moment or an exchange-hole dipole moment,
is localized by transforming the integrals
of the property and the one-electron density matrix to the new basis and
restricting the trace to the subspace of functions of a single center or the
combination of two centers.

The molecular polarizability is the first order derivative of the dipole moment
with respect to an electric field and the localized molecular polarizability
can be expressed in terms of local responses. In practical terms a calculation
of localized polarizabilities will require to run seven energy calculations. The
first one is in the absence of the field and the other six calculations are in
the presence of the field in the |+-| x,y,z axis respectively.

For a detailed description of the method and its implementation see
:cite:`Gagliardi:04a`.

.. _UG\:sec\:loprop_dependencies:

Dependencies
------------

The dependencies of the :program:`LoProp` module is the union
of the dependencies of the :program:`SEWARD`, and
the program used to perform the energy calculation, namely
the :program:`SCF`, :program:`MBPT2`,
:program:`RASSCF`, or :program:`CASPT2` module. The user
can also provide :program:`LoProp` with a density matrix as input; then
:program:`LoProp` only depends on :program:`SEWARD`. The one-electron
transition density matrix can also be localized to compute, for
example, Förster transition probabilities; then :program:`LoProp`
depends on :program:`RASSI` to compute the transition density.

.. _UG\:sec\:loprop_files:

Files
-----

The files of the :program:`LoProp` module is the union
of the files of the :program:`SEWARD` module,
and the :program:`SCF` or :program:`MBPT2`,
or :program:`RASSCF`, or :program:`CASPT2` module.
An exception is if a density matrix is given as input or
when a transition density matrix is localized, see below.

Input files
...........

.. class:: filelist

:file:`USERDEN`
  The density matrix given as input when the keyword :kword:`USERdensity` is
  included in the input. The density matrix should be of the following
  form: triangularly stored ((1,1),(2,1),(2,2),(3,1), etc.) with
  all off-diagonal elements multiplied by two.

:file:`USERDEN1`
  The density matrix for a field-perturbed calculation (X = +delta)

:file:`USERDEN2`
  The density matrix for a field-perturbed calculation (X = -delta)

:file:`USERDEN3`
  The density matrix for a field-perturbed calculation (Y = +delta)

:file:`USERDEN4`
  The density matrix for a field-perturbed calculation (Y = -delta)

:file:`USERDEN5`
  The density matrix for a field-perturbed calculation (Z = +delta)

:file:`USERDEN6`
  The density matrix for a field-perturbed calculation (Z = -delta)

:file:`TOFILE`
  The one-electron transition density matrix, which optionally can be
  put to disk by :program:`RASSI`, see its manual pages.

Output files
............

In addition to the standard output unit :program:`LoProp` will generate the following
file.

.. class:: filelist

:file:`MpProp`
  File with the input for :program:`NEMO`.

.. index::
   pair: Input; LoProp

.. _UG\:sec\:loprop_input:

Input
-----

This section describes the input to the
:program:`LoProp` program. The program name is: ::

  &LOPROP

.. index::
   pair: Keywords; LoProp

Keywords
........

There are no compulsory keywords.

.. class:: keywordlist

:kword:`NOFIeld`
  The calculation is run in the absence of a field and only static properties
  like charges and dipole moments are computed. The default is to go beyond the
  static properties.

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="NOFI" APPEAR="Only static properties" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoField <basic>
              <HELP>
              The calculation is run in the absence of a field and only static properties
              like charges and dipole moments are computed. The default is to go beyond the
              static properties.
              </HELP>
              </KEYWORD>

:kword:`DELTa`
  The magnitude of the electric field in the finite field perturbation
  calculations to determine the polarizabilities. Default value is 0.001 au.

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="DELT" APPEAR="Finite field perturbation value" KIND="REAL" DEFAULT_VALUE="0.001" LEVEL="BASIC">
              %%Keyword: Delta <basic>
              <HELP>
              The magnitude of the electric field in the finite field perturbation
              calculations to determine the polarizabilities.
              </HELP>
              Default value is 0.001 au.
              </KEYWORD>

:kword:`ALPHa`
  A parameter in the penalty function used for determining the
  charge fluctuation contribution to the polarizabilities. See eq. 17 in
  :cite:`Gagliardi:04a`. The default value of 7.14 is good for small molecules
  (less than 50 atoms). For larger molecules, a smaller alpha (e.g. 2.0)
  may be needed for numerical stability.

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="ALPHA" APPEAR="Penalty parameter" KIND="REAL" DEFAULT_VALUE="7.14" LEVEL="ADVANCED">
              %%Keyword: Alpha <basic>
              <HELP>
              A parameter in the penalty function used for determining the
              charge fluctuation contribution to the polarizabilities. See eq. 17 in
              Gagliardi et al, JCP 121,4497. The default value of 7.14 is good for small molecules
              (less than 50 atoms). For larger molecules, a smaller alpha (e.g. 2.0)
              may be needed for numerical stability.
              </HELP>
              </KEYWORD>

:kword:`BOND`
  Defines the maximum allowed bond length based on the ratio compared to
  Bragg--Slater radii. All contributions in bonds longer than this radius will
  be redistributed to the two atoms involved in the bond, so the the total
  molecular properties are left unaltered. The default value is 1.5.

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="BOND" APPEAR="Max bond length" KIND="REAL" DEFAULT_VALUE="1.5" LEVEL="BASIC">
              %%Keyword: Bond <basic>
              <HELP>
              Defines the maximum allowed bond length based on the ratio compared to
              Bragg-Slater radii. All contributions in bonds longer than this radius will
              be redistributed to the two atoms involved in the bond, so the the total
              molecular properties are left unaltered.
              </HELP>
              The default value is 1.5.
              </KEYWORD>

:kword:`MPPRop`
  Defines the maximum l value for the multipole moments written to the MpProp
  file. If the value specified is larger than the highest multipole moment
  calculated it will be reset to this value, which is also the default value.
  The "MULTipoles" keyword in Seward can change the default value.

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="MPPR" APPEAR="MpProp interface" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: MpProp <basic>
              <HELP>
              Defines the maximum l value for the multipole moments written to the MpProp
              file. If the value specified is larger than the highest multipole moment
              calculated it will be reset to this value, which is also the default value.
              </HELP>
              The 'MULTipoles' keyword in Seward can change the default value.
              </KEYWORD>

:kword:`EXPAnsion center`
  Defines which points will be used as the expansion centers for the bonds. The
  next line must contain either "MIDPoint" in order just to use the midpoint of
  the bond or "OPTImized" in order to let LoProp move the expansion center along
  the bond. The latter is still highly experimental!

  .. xmldoc:: <KEYWORD MODULE="LOPROP" NAME="EXPA" APPEAR="Expansion center" KIND="CHOICE" LIST="Midpoint,Optimized" LEVEL="BASIC">
              %%Keyword: Expansion center <basic>
              <HELP>
              Defines which points will be used as the expansion centers for the bonds. The
              next line must contain either 'MIDPoint' in order just to use the midpoint of
              the bond or 'OPTImized' in order to let LoProp move the expansion center along
              the bond. The latter is still highly experimental!
              </HELP>
              </KEYWORD>

:kword:`USERdensity`
  No density matrix is computed instead it is read as an input from the file
  :file:`USERDEN`. This enables :program:`LoProp` to obtain localized
  properties for densities that currently can not be computed with |molcas|.
  If the keyword :kword:`NOFIeld` is not given, six additional files are
  required (:file:`USERDEN1`--:file:`USERDEN6`), each containing the density matrix of
  a perturbed calculation, see above. Observe the form
  of :file:`USERDEN`, see above.

  .. xmldoc:: %%Keyword: UserDensity <basic>
              No density matrix is computed instead it is read as an input from the file
              USERDEN. This enables LoProp to obtain localized
              properties for densities that currently can not be computed with molcas.
              If the keyword NOFIeld is not given, six additional files are
              required (USERDEN1-USERDEN6), each containing the density matrix of
              a perturbed calculation, see above. Observe the form
              of USERDEN, see above.

:kword:`TDENsity`
  This keyword signals that the one-electron density matrix which is to
  be read comes from the TOFILE file generated by :program:`RASSI`. The
  keyword is followed by two integers that gives number of initial and
  final state of the transition. For example, if it is the transition
  density between the first and second state which should be localized,
  the integers should be 1 and 2. The keyword implies :kword:`NOFIeld`

  .. xmldoc:: %%Keyword: TDensity <basic>
              This keyword signals that the one-electron density matrix which is to
              be read comes from the TOFILE file generated by RASSI. The
              keyword is followed by two integers that gives number of initial and
              final state of the transition. For example, if it is the transition
              density between the first and second state which should be localized,
              the integers should be 1 and 2. The keyword implies NOFIeld.

Input example
.............

Below follows an example input to determine the localized charges, and dipole
moments of acetone at the CASSCF level of theory.

.. extractfile:: ug/LOPROP.acetone.input

  &GATEWAY
  Title = acetone
  Coord = $MOLCAS/Coord/Acetone.xyz
  Basis = ANO-L-VDZP
  Group = C1

  &SEWARD

  &SCF
  Occupation = 15

  &RASSCF
  SPIN       = 1
  SYMMETRY   = 1
  NACTEL     = 4 0 0
  INACTIVE   = 13
  RAS2       = 4

  &LOPROP
  NoField
  Expansion Center
  Optimized
  Bond       = 1.5
  MpProp     = 2

In case the density matrix is given as input the input is of the
form below (where $CurrDir is a variable defined by the user pointing
to the directory where the input density is). ::

  &Gateway
  Coord = Water.xyz
  Basis = 6-31G*
  Group = C1

  &Seward

  >>COPY $CurrDir/Density $WorkDir/$Project.UserDen

  &LoProp
  UserDensity

.. xmldoc:: </MODULE>
.. index::
   single: Program; WFA
   single: WFA

.. _UG\:sec\:wfa:

:program:`wfa`
================

.. warning::

   This program requires a submodule

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="WFA">
            %%Description:
            <HELP>
            The WFA program of the molcas program system provides various
            visual and quantitative wavefunction analysis methods.
            </HELP>

The :program:`WFA` program of the |molcas| program system provides various
visual and quantitative wavefunction analysis methods.
It is based on the libwfa :cite:`libwfa` wavefunction analysis library.
The interface to |molcas| is described in Ref. :cite:`Molcas_libwfa`.

.. Quantitative analysis methods are printed to the standard output, orbital coefficients are
   written to the HDF5 file that is used for input and output, and input files
   for the external TheoDORE program are created.

The program computes natural transition
orbitals (NTO) :cite:`Martin2003,Plasser2014`, which provide a compact description of
one-electron excited states. Natural difference orbitals (NDO) :cite:`Plasser2014` can be
computed to visualize many-body effects and orbital relaxation effects :cite:`Plasser2014b`. A module for the
statistical analysis of exciton wavefunctions is included :cite:`Bappler2014,Plasser2015`,
which provides various quantitative descriptors to describe the excited states.
Output is printed for the 1-electron transition density matrix (1TDM) and for the 1-electron difference density matrix (1DDM).
A decomposition into local and charge transfer contributions on different chromophores
is possible through the charge transfer number analysis :cite:`Plasser2012`,
which has been integrated into |molcas| recently.
Postprocessing is possible through the external `TheoDORE <https://theodore-qc.sourceforge.net/>`_ :cite:`TheoDORE` program.

Installation
------------

The :program:`WFA` module is currently not installed by default.
Its installation occurs via CMake.
It requires a working HDF5 installation and access to the include files of the Armadillo C++ linear algebra library.
In the current settings, external BLAS/LAPACK libraries have to be used.
Use, e.g., the following commands for installation: ::

  FC=ifort cmake -D LINALG=MKL -D WFA=ON -D ARMADILLO_INC=../armadillo-7.300.0/include ..

.. _UG\:sec\:wfa_dependencies:

Dependencies
------------

The :program:`WFA` program requires HDF5 files, which are written by either
:program:`SCF`, :program:`RASSCF`, or :program:`RASSI`. In the case of :program:`RASSI`,
the :kword:`TRD1` keyword has to be activated.

.. _UG\:sec\:wfa_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`WFAH5`
  All information that the :program:`WFA` program needs is contained in this HDF5 file.
  The name can be adjusted with the :kword:`H5FIle` option.

Output files
............

.. class:: filelist

:file:`WFAH5`
  The orbital coefficients of NOs, NTOs, and NDOs are written to the same HDF5 file that
  is also used for input.

:file:`*.om`
  These are input files for the external TheoDORE program.

:file:`OmFrag.txt`
  Input file for TheoDORE.

For a seamless interface to TheoDORE, you can also create the :file:`tden_summ.txt` file via ::

  grep '^|' molcas.log > tden_summ.txt

The NOs, NTOs, and NDOs on the HDF5 file can be accessed via `Pegamoid <https://pypi.org/project/Pegamoid/>`_.
Alternatively, the orbitals can be converted to Molden format via the `Molpy program <https://github.com/felixplasser/molpy>`_. Call, e.g.: ::

  penny molcas.rassi.h5 --wfaorbs molden

.. _UG\:sec\:wfa_input:

Input
-----

The input for the :program:`WFA` module is preceded by: ::

  &WFA

Keywords
........

Basic Keywords:

.. class:: keywordlist

:kword:`H5FIle`
  Specifies the name of the HDF5 file used for reading and writing
  (e.g. :file:`$Project.scf.h5`, :file:`$Project.rasscf.h5`, :file:`$Project.rassi.h5`).
  You either have to use this option or rename the file of
  interest to :file:`WFAH5`.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="H5FILE" APPEAR="HDF5 file" KIND="STRING" LEVEL="BASIC">
              %%Keyword:H5FIle <basic>
              <HELP>
              Specifies the name of the HDF5 file used for reading and writing
              (e.g. $Project.scf.h5, $Project.rasscf.h5, $Project.rassi.h5).
              You either have to use this option or rename the file of
              interest to WFAH5.
              </HELP>
              </KEYWORD>

:kword:`WFALevel`
  Select how much output is produced (0-4, default: 3).

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="WFALEVEL" APPEAR="Print level" KIND="CHOICE" LIST="0,1,2,3,4" LEVEL="BASIC" DEFAULT_VALUE="3">
              %%Keyword:WFALevel <basic>
              <HELP>
              Select how much output is produced (0-4, default: 3).
              </HELP>
              </KEYWORD>

:kword:`CTNUmmode`
  Specifies what properties are computed in a `TheoDORE <https://theodore-qc.sourceforge.net/>`_-style fragment-based analysis (0-3, default: 1).
  This requires defining fragments via :kword:`ATLIsts`.

  0 --- none

  1 --- Basic: POS, PR, DEL, CT, CTnt

  2 --- Extended:  POS, POSi, POSf, PR, PRi, PRf, DEL, COH, CT, CTnt

  3 --- For transition metal complexes: POSi, POSf, PR, CT, MC, LC, MLCT, LMCT, LLCT

  The definition of the descriptors is provided
  `here <https://sourceforge.net/p/theodore-qc/wiki/Transition%20density%20matrix%20analysis/attachment/Om_desc.pdf>`_.
  For a more fine-grained input use :kword:`PROPlist`.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="CTNUMMODE" APPEAR="Computed properties" KIND="CHOICE" LIST="0: None,1: Basic,2: Extended,3: Metal complexes" LEVEL="BASIC" DEFAULT_VALUE="1" REQUIRE="ATLISTS">
              %%Keyword:CTNUmmode <basic>
              <HELP>
              Define what properties are computed in a TheoDORE-style analysis. (0-3, default: 1).
              </HELP>
              </KEYWORD>

:kword:`ATLIsts`
  Define the fragments in a `TheoDORE <https://theodore-qc.sourceforge.net/>`_-style analysis.

  The first entry is the number of fragments.
  Then enter the atomic indices of the fragment followed by a \*.
  Example: ::

    ATLISTS
    2
    1 2 4 *
    3 *

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="ATLISTS" APPEAR="Fragment definition" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword:ATLIsts <basic>
              <HELP>
              Define the fragments in a TheoDORE-style analysis.
              </HELP>
              </KEYWORD>

:kword:`REFState`
  Index of the reference state for 1TDM and 1DDM analysis (default: 1).

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="REFSTATE" APPEAR="Reference state" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword:REFState <basic>
              <HELP>
              Index of the reference state for 1TDM and 1DDM analysis.
              </HELP>
              </KEYWORD>

Advanced keywords for fine grain output options and debug information:

.. class:: keywordlist

:kword:`MULLiken`
  Activate Mulliken population analysis (also for CT numbers).

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="MULLIKEN" APPEAR="Mulliken population analysis" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:MULLiken <advanced>
              <HELP>
              Activate Mulliken population analysis.
              </HELP>
              </KEYWORD>

:kword:`LOWDin`
  Activate Löwdin population analysis (also for CT numbers).

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="LOWDIN" APPEAR="Lowdin population analysis" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:LOWDin <advanced>
              <HELP>
              Activate Lowdin population analysis.
              </HELP>
              </KEYWORD>

:kword:`NXO`
  Activate NO, NTO, and NDO analysis.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="NXO" APPEAR="NXO analysis" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:NXO <advanced>
              <HELP>
              Activate NO, NTO, and NDO analysis.
              </HELP>
              </KEYWORD>

:kword:`EXCIton`
  Activate exciton and multipole analysis.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="EXCITON" APPEAR="Exciton analysis" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:EXCIton <advanced>
              <HELP>
              Activate exciton and multipole analysis.
              </HELP>
              </KEYWORD>

:kword:`DOCTnumbers`
  Activate charge transfer number analysis and creation of :file:`*.om` files.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="DOCTNUMBERS" APPEAR="Charge transfer numbers" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:DOCTnumbers <advanced>
              <HELP>
              Activate charge transfer number analysis and creation of *.om files.
              </HELP>
              </KEYWORD>

:kword:`H5ORbitals`
  Print the NOs, NTOs, and/or NDOs to the HDF file.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="H5ORBITALS" APPEAR="Save orbitals in HDF5" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:H5ORbitals <advanced>
              <HELP>
              Print the NOs, NTOs, and/or NDOs to the HDF file.
              </HELP>
              </KEYWORD>

:kword:`PROPlist`
  Manual input of properties to be printed out in a `TheoDORE <https://theodore-qc.sourceforge.net/>`_-style fragment based analysis.
  Use only if :kword:`CTNUMMODE` does not provide what you want.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="PROPLIST" APPEAR="Property list" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword:PROPlist <advanced>
              <HELP>
              Manual input of properties to be printed out in a TheoDORE-style analysis.
              </HELP>
              </KEYWORD>

  Enter as a list followed by a \*, e.g. ::

    PROPLIST
    Om POS PR CT COH CTnt *

  The full list of descriptors is provided
  `here <https://sourceforge.net/p/theodore-qc/wiki/Transition%20density%20matrix%20analysis/attachment/Om_desc.pdf>`_.

:kword:`DEBUg`
  Print debug information.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="DEBUG" APPEAR="Print debug information" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:DEBUg <advanced>
              <HELP>
              Print debug information.
              </HELP>
              </KEYWORD>

:kword:`ADDInfo`
  Add info for verification runs with :command:`molcas verify`.

  .. xmldoc:: <KEYWORD MODULE="WFA" NAME="ADDINFO" APPEAR="Add info" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword:ADDInfo <advanced>
              <HELP>
              Add info for verifications runs with molcas verify.
              </HELP>
              </KEYWORD>

Input example
.............

::

  * Analysis of SCF job
  &SCF

  &WFA
  H5file = $Project.scf.h5

::

  * Analysis of RASSCF job
  * Reduced output
  &RASSCF

  &WFA
  H5file = $Project.rasscf.h5
  wfalevel = 1

::

  * Analysis of RASSI job, use the TRD1 keyword
  &RASSI
  TRD1

  &WFA
  H5file = $Project.rassi.h5
  ATLISTS
  2
  1 2 4 *
  3 *

.. _UG\:sec\:wfa_output:

Output
------

State/difference density matrix analysis (:program:`SCF`/:program:`RASSCF`/:program:`RASSI`)
............................................................................................

.. compound::

  ::

    RASSCF analysis for state 2 (3) A

  or ::

    RASSI analysis for state R_2

.. _tab\:wfa_dm:

======================= ===================================================================================================
Descriptor              Explanation
======================= ===================================================================================================
``n_u``                 Number of unpaired electrons :math:`n_u=\sum_i\min(n_i, 2-n_i)` :cite:`Head-Gordon2003,Plasser2014`
``n_u,nl``              Number of unpaired electrons :math:`n_{u,nl}=\sum_i n_i^2(2-n_i)^2`
``PR_NO``               NO participation ratio :math:`\text{PR}_{\text{NO}}`
``p_D`` and ``p_A``     Promotion number :math:`p_D` and :math:`p_A`
``PR_D`` and ``PR_A``   D/A participation ratio :math:`\text{PR}_D` and :math:`\text{PR}_A`
``<r_h> [Ang]``         Mean position of detachment density :math:`\vec{d}_D` :cite:`Plasser2015`
``<r_e> [Ang]``         Mean position of attachment density :math:`\vec{d}_A`
``|<r_e - r_h>| [Ang]`` Linear D/A distance :math:`\vec{d}_{D\rightarrow A} = \vec{d}_A - \vec{d}_D`
``Hole size [Ang]``     RMS size of detachment density :math:`\sigma_D`
``Electron size [Ang]`` RMS size of attachment density :math:`\sigma_A`
======================= ===================================================================================================

Transition density matrix analysis (:program:`RASSI`)
.....................................................

::

  RASSI analysis for transiton from state 1 to 2 (Tr_1-2)

.. _tab\:wfa_tdm:

====================================== =============================================================================================================================
Output listing                         Explanation
====================================== =============================================================================================================================
``Leading SVs``                        Largest NTO occupation numbers
``Sum of SVs (Omega)``                 :math:`\Omega`, Sum of NTO occupation numbers
``PR_NTO``                             NTO participation ratio :math:`\text{PR}_{\text{NTO}}` :cite:`Plasser2012`
``Entanglement entropy (S_HE)``        :math:`S_{H|E}=-\sum_i\lambda_i\log_2\lambda_i` :cite:`Plasser2016`
``Nr of entangled states (Z_HE)``      :math:`Z_{HE}=2^{S_{H|E}}`
``Renormalized S_HE/Z_HE``             Replace :math:`\lambda_i\rightarrow \lambda_i/\Omega`
``omega``                              Norm of the 1TDM :math:`\Omega`, single-exc. character
``<Phe>``                              Exp. value of the particle-hole permutation operator, measuring de-excitations :cite:`Kimber2020`
``<r_h> [Ang]``                        Mean position of hole :math:`\langle\vec{x}_h\rangle_{\text{exc}}` :cite:`Plasser2015`
``<r_e> [Ang]``                        Mean position of electron :math:`\langle\vec{x}_e\rangle_{\text{exc}}`
``|<r_e - r_h>| [Ang]``                Linear e/h distance :math:`\vec{d}_{h\rightarrow e} = \langle\vec{x}_e - \vec{x}_h\rangle_{\text{exc}}`
``Hole size [Ang]``                    RMS hole size: :math:`\sigma_h = (\langle\vec{x}_h^2\rangle_{\text{exc}} - \langle\vec{x}_h\rangle_{\text{exc}}^2)^{1/2}`
``Electron size [Ang]``                RMS electron size: :math:`\sigma_e = (\langle\vec{x}_e^2\rangle_{\text{exc}} - \langle\vec{x}_e\rangle_{\text{exc}}^2)^{1/2}`
``RMS electron-hole separation [Ang]`` :math:`d_{\text{exc}} = (\langle \left|\vec{x}_e - \vec{x}_h\right|^2\rangle_{\text{exc}})^{1/2}` :cite:`Bappler2014`
``Covariance(r_h, r_e) [Ang^2]``       :math:`\text{COV}\left(\vec{x}_h,\vec{x}_e\right) = \langle\vec{x}_h\cdot\vec{x}_e\rangle_{\text{exc}} -
                                       \langle\vec{x}_h\rangle_{\text{exc}}\cdot\langle\vec{x}_e\rangle_{\text{exc}}`
``Correlation coefficient``            :math:`R_{eh} = \text{COV}\left(\vec{x}_h,\vec{x}_e\right)/\sigma_h\cdot\sigma_e` :cite:`Plasser2015`
``Center-of-mass size``                :math:`(\langle \left|\vec{x}_e + \vec{x}_h\right|^2\rangle_{\text{exc}}-\langle \vec{x}_e + \vec{x}_h\rangle_{\text{exc}}^2)^{1/2}`
====================================== =============================================================================================================================

.. xmldoc:: </MODULE>
.. index::
   single: Program; MOTRA
   single: MOTRA

.. _UG\:sec\:motra:

:program:`motra`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MOTRA">
            %%Description:
            <HELP>
            This program transforms one- and two-electron integrals from AO
            basis to MO basis. The integrals that are transformed are the
            one-electron Hamiltonian and the two-electron repulsion integrals.
            </HELP>

The program
:program:`MOTRA` is used to transform one- and two-electron
integrals from AO to MO basis. It reads the
one-electron file and the file of ordered
and symmetry blocked two-electron integrals generated by
:program:`SEWARD`.

The two-electron integral transformation is performed
one symmetry block at a time, as a series of four
sequential one-index transformations. The process
includes a sorting of the half transformed integrals
prior to the second half transformation. This step is
performed in core if there is space enough of memory
available to keep one symmetry block of integrals.
Otherwise the half transformed integrals are written
out on an temporary file. The result of the transformation
is two files, :file:`TRAONE` and :file:`TRAINT` which
contain the transformed one- and two-electron integrals, respectively.

The one-electron transformation is performed for the
kinetic integrals and the bare nuclei Hamiltonian. If there
are frozen orbitals :program:`MOTRA` replaces the bare nuclei
Hamiltonian by an effective Fock operator, which incorporates
the interaction between the frozen (core) electrons and the
remaining electrons. In practice this means that in any
subsequent calculation (for example :program:`MRCI`,
:program:`CPF` or :program:`MBPT`) the effect of the frozen
orbitals is incorporated into the one-electron Hamiltonian,
and these orbitals need not be explicitly accounted for. The
total energy of the frozen electrons is added to the
nuclear--nuclear repulsion energy and transferred from
:program:`MOTRA` to the subsequent program(s).

The two-electron transformation is performed from the list of ordered
integrals generated by
:program:`SEWARD` (file :file:`ORDINT`).

.. _UG\:sec\:motra_dependencies:

Dependencies
------------

To run the program :program:`MOTRA` successfully the one-
and two-electron integrals are needed. In addition, a
set of MO coefficients must be available. The latter may
be obtained by any wave function optimization program.

.. _UG\:sec\:motra_files:

Files
-----

Input files
...........

The following is a list of input files

.. class:: filelist

:file:`ONEINT`
  One-electron integral file generated by :program:`SEWARD`.

:file:`ORDINT*`
  Ordered two-electron integrals generated by :program:`SEWARD`.

:file:`INPORB`
  If MO's are read in formatted form.

:file:`JOBIPH`
  If molecular orbitals are read from a :program:`RASSCF` interface.

In general, input orbitals are supplied in the form of
a formatted ASCII file, but can also be taken directly from
the binary interface file, :file:`JOBIPH`, created by the
:program:`RASSCF` program. The selection in controlled by
input options.

Output files
............

The program :program:`MOTRA`
creates two files: The first carries all basic information
and a list of transformed one-electron integrals. The second
file includes the transformed two-electron integrals.

The following is a list of output files

.. class:: filelist

:file:`TRAONE`
  Auxiliary data and transformed one-electron integrals.

:file:`TRAINT*`
  Transformed two-electron integrals.

.. Intermediate files
   ..................

   :program:`MOTRA` generates one intermediate file with half
   transformed one-electron integrals,
   :file:`LUHALF`. It is scratched at the end of the run.
   This file can be large in calculations with extended basis sets.
   It is used to store one symmetry block of integrals at a time.

   The following is a list of local files

   .. class:: filelist

   :file:`LUHALF*`
     Auxiliary data and transformed one-electron integrals.

.. _UG\:sec\:motra_input:

Input
-----

This section describes the input to the :program:`MOTRA` program in the |molcas| program system.
The input for each module is preceded by its name like: ::

  &MOTRA

Compulsory keywords
...................

The following keywords are compulsory.

.. class:: keywordlist

:kword:`LUMOrb`
  Specifies that the molecular orbitals are read from a formatted file
  produced by one of the wave function generating programs.
  **Note** that either of :kword:`Lumorb` or :kword:`Jobiph` should be
  specified. LUMORB is the default keyword.
  No additional input is required.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="LUMORB" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: LUMOrb <basic>
              <HELP>
              Specifies that the molecular orbitals are read from a formatted file
              produced by one of the wave function generating programs (default).
              </HELP>
              No additional input is required.
              NOTE: Either of keywords LUMORB or JOBIPH should be specified
              LUMORB is the default option.
              </KEYWORD>

:kword:`JOBIph`
  Specifies that the molecular orbitals are read from a :program:`RASSCF` job
  interface file. :program:`MOTRA` will in this case read the average orbitals.
  No additional input is required.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="JOBIPH" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: JOBIph <basic>
              <HELP>
              Specifies that the molecular orbitals are read from the job
              interface file, called JOBIPH, produced by the RASSCF program.
              MOTRA will in this case read the average orbitals.
              </HELP>
              </KEYWORD>

When natural orbitals from a RASSCF (or a state averaged CASSCF)
calculation are to be used in
:program:`MOTRA`, they can be produced, or extracted from an existing
:file:`JOBIPH` file, by :program:`RASSCF`, using keyword :kword:`OUTOrbitals`.

Optional keywords
.................

There are a few useful optional keywords that can be specified.
The following is a list

.. class:: keywordlist

:kword:`AUTO`
  This keyword specified automatic deletion of orbitals based on
  occupation numbers. The following line contain one
  threshold per symmetry, and all orbitals with occupation
  numbers smaller that the threshold will be deleted.
  If :kword:`AUTO` and :kword:`DELEte` are both specified,
  the larger number will be used.

  .. xmldoc:: %%Keyword: AUTO <basic>
              This keyword specified automatic deletion of orbitals based on
              occupation numbers. The following line contain one
              threshold per symmetry, and all orbitals with occupation
              numbers smaller that the threshold will be deleted.
              NOTE: If the keywords AUTO and DELEte are both specified,
              the larger number will be used.

:kword:`DELEted`
  Specifies the number of virtual orbitals that are not to be used as
  correlating orbitals in the subsequent CI calculation. The last
  orbitals in each symmetry are deleted. The default is no deleted
  orbitals.
  One additional line with the number of deleted orbitals in each
  symmetry (free format).

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="DELETE" APPEAR="delete orbitals" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM">
              %%Keyword: DELEted <basic>
              <HELP>
              Specifies the number of virtual orbitals that are not to be used as
              correlating orbitals in subsequent correlation calculation(s). The
              default is no deleted orbitals.
              </HELP>
              The keyword requires one additional line of input with the number
              of deleted orbitals in each symmetry.
              NOTE: The deleted orbitals are the last orbitals in each symmetry block.
              </KEYWORD>

:kword:`FROZen`
  Specifies the number of doubly occupied orbitals that are left
  uncorrelated in subsequent correlation calculation(s). Additional orbitals can
  be frozen in these programs, but from an efficiency point of view it
  is preferable to freeze orbitals in the transformation.
  One additional line with the number of frozen
  orbitals in each symmetry (free format). For more details on freezing
  orbitals in :program:`MOTRA` see the program description. The frozen
  orbitals are the first in each symmetry block.
  Default is to freeze the core (but not semi-core) orbitals.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="FROZEN" APPEAR="frozen orbitals" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM">
              %%Keyword: FROZen <basic>
              <HELP>
              Specifies the number of doubly occupied orbitals that are left
              uncorrelated in subsequent correlation calculation(s).
              </HELP>
              The keyword requires one additional line of input with the number
              of frozen orbitals in each symmetry (free format).
              NOTE: The frozen orbitals are the first in each symmetry block.
              Default is to freeze the core (but not semi-core) orbitals.
              </KEYWORD>

:kword:`ONEL`
  Specifies that only one-electron integrals are to be transformed.
  No additional input is required.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="ONEL" APPEAR="one-el transf." LEVEL="BASIC" KIND="SINGLE">
              %%Keyword: ONEL <basic>
              <HELP>
              Specifies that only one-electron integrals are to be transformed.
              </HELP>
              No additional input is required.
              </KEYWORD>

:kword:`PRINt`
  Specifies the print level in the program. The default (1) does not
  print the orbitals that are used in the transformation, but they
  appear at print level 2. Beware of large print levels since vast amounts
  of output may be produced. The value is read from the line after the
  keyword, in free format.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="PRINT" APPEAR="print level" LEVEL="ADVANCED" KIND="INT">
              %%Keyword: PRINt <basic>
              <HELP>
              Specifies the print level in the program. The default (1) does not
              print the orbitals that are used in the transformation, but they
              appear at print level 2.
              </HELP>
              Beware of large print levels since vast amounts
              of output may be produced. The value is read from the line after the
              keyword, in free format.
              </KEYWORD>

:kword:`RFPErt`
  Add a constant reaction field perturbation to the bare nuclei Hamiltonian.
  The perturbation is read from the file :file:`RUNOLD` (if not present defaults to :file:`RUNFILE`) and
  is the latest self consistent perturbation generated
  by one of the programs :program:`SCF` or :program:`RASSCF`.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="RFPERT" APPEAR="reaction field" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: RFPErt <basic>
              <HELP>
              Add a constant reaction field perturbation to the bare nuclei Hamiltonian.
              The perturbation is read from the file RUNOLD (if not present defaults to RUNFILE) and
              is the latest self consistent perturbation generated
              by one of the programs SCF or RASSCF.
              </HELP>
              </KEYWORD>

:kword:`CTONly`
  Specifies that Cholesky vectors are to be transformed without subsequent calculation of the two-el integrals.
  It requires as input one of the two following strings: "pqK" or "Kpq", which indicate the storage format as
  L(pq,K) or L(K,pq), respectively. The former is the default option. Transformed vectors are stored in the files :file:`_CHMOT`,
  one for each compound symmetry.
  Available only in combination with Cholesky or RI integral representation.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="CTON" APPEAR="Cholesky vectors transf." LEVEL="BASIC" KIND="STRING">
              %%Keyword: CTON <basic>
              <HELP>
              Specifies that Cholesky vectors are to be transformed without subsequent calculation of the two-el integrals.
              It requires as input one of the two following strings: "pqK" or "Kpq", which indicate the storage format as
              L(pq,K) or L(K,pq), respectively. The former is the default option. Transformed vectors are stored in the files _CHMOT,
              one for each compound symmetry.
              Available only in combination with Cholesky or RI integral representation.
              </HELP>
              </KEYWORD>

:kword:`DIAGonal integrals`
  Activates the evaluation of the diagonal integrals in MO basis. Requires the keyword CTONly.
  The file :file:`DIAGINT` is generated which contains these integrals.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="DIAG" KIND="STRING" LEVEL="BASIC">
              %%Keyword: DIAG <basic>
              <HELP>
              Activates the evaluation of the diagonal integrals in MO basis. Requires the keyword CTONly.
              The file DIAGINT is generated which contains these integrals.
              </HELP>
              </KEYWORD>

:kword:`TITLe`
  This keyword should be followed by exactly one title line.

  .. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              Print a title line
              </HELP>
              This keyword should be followed by exactly one title line.
              </KEYWORD>

Input example
.............

::

  &MOTRA
  Title  =  Water molecule.
  * Don't correlate 1s on oxygen
  Frozen =  1 0 0 0
  Lumorb

.. xmldoc:: <KEYWORD MODULE="MOTRA" NAME="HDF5" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; GUGA
   single: GUGA

.. _UG\:sec\:guga:

:program:`Guga`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="GUGA">
            %%Description:
            <HELP>
            The GUGA program generates coupling coefficients
            used by the MRCI and the CPF programs. The program was written
            by P. E. M. Siegbahn, and has since been slightly modified to fit MOLCAS.
            </HELP>

The :program:`GUGA` program generates :index:`coupling coefficients <single: Coupling coefficients; GUGA>`
used in the :program:`MRCI` and the :program:`CPF` programs
in :index:`Direct CI` calculations :cite:`Roos:72`.
These coupling coefficients are evaluated by the :index:`Graphical Unitary
Group Approach` :cite:`Shavitt:77,Shavitt:78,Siegbahn:80`,
for wavefunctions with at most two electrons excited from a set of
reference configurations. The program was written by :index:`P. E. M. Siegbahn <single: Siegbahn, P. E. M>`,
Institute of Physics, Stockholm University, Sweden.
Only the :program:`MRCI` program can use several reference
configurations. The reference configurations can be specified as a
list, where the occupation numbers are given for each active orbital
(see below) in each reference configuration, or as a :index:`Full CI`
the space defined by the active orbitals. In the :program:`GUGA`, :program:`MRCI`
and :program:`CPF` programs, the orbitals are classified as follows:
Frozen, Inactive, Active, Secondary, and Deleted orbitals. Within each
symmetry type, they follow this order. For the :program:`GUGA` program,
only the inactive and active orbitals are relevant.

* **Inactive:** :index:`Inactive orbitals <single: GUGA; Inactive>` are doubly occupied
  in all reference configurations, but excitations out of this orbital
  space are allowed in the final CI wavefunction, i.e., they are
  correlated but have two electrons in all *reference* configurations.
  Since only single and double excitations are allowed, there can be no
  more than two holes in the active orbitals.
  Using keyword :index:`NoCorr <single: GUGA; NoCorr>` (See input description) a subset of the
  inactive orbitals can be selected, and at most a single hole
  is then allowed in the selected set. This allows the core-polarization
  part of core-valence correlation, while preventing large but usually
  inaccurate double-excitation core correlation.

* **Active:** :index:`Active orbitals <single: GUGA; Active>` are those which may have
  different occupation in different reference configurations.
  Using keyword :index:`OneOcc <single: GUGA; OneOcc>` (See input description) a restriction may be
  imposed on some selection of active orbitals, so that the selected
  orbitals are always singly occupied. This may be useful for transition
  metal compounds or for deep inner holes.

.. index::
   pair: Dependencies; GUGA

.. _UG\:sec\:guga_dependencies:

Dependencies
------------

The :program:`GUGA` program does not depend on any other program for its
execution.

.. index::
   pair: Files; GUGA

.. _UG\:sec\:guga_files:

Files
-----

Input files
...........

The :program:`GUGA` program does not need any input files apart from the file of
input keywords.

Output files
............

.. class:: filelist

:file:`CIGUGA`
  This file contains the coupling coefficients that are needed in
  subsequent CI calculations. For information about how these
  coefficients are structured you are referred to the source
  code :cite:`Siegbahn:80`. The theoretical background for the
  coefficient can be found in Refs :cite:`Shavitt:77,Shavitt:78,Siegbahn:80` and
  references therein.

.. index::
   pair: Input; GUGA

.. _UG\:sec\:guga_input:

Input
-----

This section describes the input to the
:program:`GUGA` program in the |molcas| program system, with the program name: ::

  &GUGA

.. index::
   pair: Keywords; GUGA

Keywords
........

Formally, there are no compulsory keyword. Obviously, some
input must be given for a meaningful calculation.

.. class:: keywordlist

:kword:`TITLe`
  The line following this keyword is treated as title line

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              The line following this keyword is treated as title line
              </HELP>
              </KEYWORD>

:kword:`SPIN`
  The spin degeneracy number, i.e. 2S+1. The value is read from the
  line following the keyword, in free format. The default value is
  1, meaning a singlet wave function.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="SPIN" APPEAR="Spin (2S+1)" KIND="INT" LEVEL="BASIC">
              %%Keyword: Spin <basic>
              <HELP>
              Spin degeneracy number (multiplicity), 2S+1. Default 1=Singlet.
              </HELP>
              </KEYWORD>

:kword:`ELECtrons`
  The number of electrons to be correlated in the CI of CPF calculation.
  The value is read from the line following the keyword, in free format.
  Note that this number should include the nr of electrons in inactive
  orbitals. An alternative input specification is NACTEL.
  Default: Twice nr of inactive orbitals.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="ELECTRONS" APPEAR="Nr of electrons." KIND="INT" LEVEL="BASIC">
              %%Keyword: Electrons <basic>
              <HELP>
              Number of electrons to be correlated.
              </HELP>
              </KEYWORD>

:kword:`NACTel`
  The number of electrons in active orbitals in the reference configurations.
  The value is read from the line following the keyword, in free format.
  Note that this number includes only the of electrons in active
  orbitals. An alternative input specification is ELECTRONS.
  Default: Zero.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="NACTEL" APPEAR="Number of active electrons." KIND="INT" LEVEL="BASIC">
              %%Keyword: NACTEL <basic>
              <HELP>
              Number of active electrons in the reference CI (if multireference).
              </HELP>
              </KEYWORD>

:kword:`INACtive`
  The number of inactive orbitals, i.e. orbitals that have
  occupation numbers of 2 in all reference configurations. Specified for
  each of the symmetries. The values are read from the line
  following the keyword, in free format.

  .. xmldoc:: <GROUP MODULE="GUGA" NAME="ORBITALS" APPEAR="Orbitals" KIND="BOX">
              <HELP>
              Various orbital spaces.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="INACTIVE" APPEAR="Inactive orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="BASIC">
              <HELP>
              Number of inactive orbitals for each irrep.
              </HELP>
              %%Keyword: Inactive <basic>
              List which tells, for each symmetry species, how many orbitals
              to keep fully occupied always. Default is 0 in all symmetries.
              </KEYWORD>

:kword:`ACTIve`
  The number of active orbitals, i.e. orbitals that have varying
  occupation numbers in the reference configurations. Specified for each
  of the symmetries. The values are read from the line following
  the keyword, in free format.

  At least one of the :kword:`Inactive` or :kword:`Active` keywords must
  be present for a meaningful calculation. If one of them is left out,
  the default is 0 in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="ACTIVE" APPEAR="Active orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="BASIC">
              <HELP>
              Number of active orbitals for each irrep.
              </HELP>
              %%Keyword: Active <basic>
              List which tells, for each symmetry species, how many orbitals
              that are active. Default is 0 in all symmetries.
              </KEYWORD>

:kword:`ONEOcc`
  Specify a number of active orbitals per symmetry that are required to have occupation
  number one in all configurations. These orbitals are the first active orbitals.
  The input is read from the line after the keyword, in free format.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="ONEOCC" APPEAR="Singly occupied orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED">
              <HELP>
              Number of always open active orbitals.
              </HELP>
              %%Keyword: OneOcc <advanced>
              List which tells, for each symmetry species, how many orbitals
              that are required to be singly occupied always. Default is 0 in all symmetries.
              </KEYWORD>

:kword:`NOCOrr`
  Specify the number of inactive orbitals per symmetry out of which at most one electron
  (total) is excited. These orbitals are the first inactive orbitals.
  The input is read from the line after the keyword, in free format.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="NOCORR" APPEAR="Always non-empty orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED">
              <HELP>
              Number of always non-empty active orbitals.
              </HELP>
              %%Keyword: NoCorr <advanced>
              List which tells, for each symmetry species, how many orbitals
              that are not allowed to be empty. Default is 0 in all symmetries.
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`REFErence`
  Specify selected reference configurations. The additional input
  that is required usually spans more than one line. The first line
  after the keyword contains the number of reference configurations, and
  the total number of active orbitals, and these two numbers are
  read by free format. Thereafter the input has one line per
  reference configuration, specifying the occupation number for each of
  the active orbitals, read by 80I1 format. Note that
  :kword:`Reference` and :kword:`CIall` are mutually exclusive.

  .. xmldoc:: <GROUP MODULE="GUGA" NAME="REF_SPACE" APPEAR="Reference space" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="REFERENCE" APPEAR="Reference occupations" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              A single string like '22010' for occupations.
              </HELP>
              %%Keyword: Reference <basic>
              One way of specifying the reference space -- see manual.
              One of the two keywords REFERENCE and CIALL should be chosen.
              </KEYWORD>

:kword:`CIALl`
  Use a Full CI within the subspace of the active orbitals as
  reference configurations. The symmetry of the wavefunction must be
  specified. The value is read from the line following the keyword, in
  free format. Note that
  :kword:`CIall` and :kword:`Reference` are mutually exclusive.
  One of these two alternatives must be chosen for a meaningful calculation.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="CIALL" APPEAR="Full reference" KIND="INT" LEVEL="BASIC">
              <HELP>
              Use a full reference.
              </HELP>
              %%Keyword: CIAll <basic>
              Use a Full CI space as reference -- see manual.
              One of the two keywords REFERENCE and CIALL should be chosen.
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`FIRSt`
  Perform a first order calculation, i.e. only single excitations
  from the reference space. No additional input is required.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="FIRST" APPEAR="First-order" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: First-order <advanced>
              <HELP>
              Allow only single excitations from the reference space.
              </HELP>
              </KEYWORD>

:kword:`NONInteracting space`
  By default, those double excitations from inactive
  to virtual orbitals are excluded, where the inactive and virtual electrons
  would couple to a resulting triplet.
  With the NonInteracting Space option, such 'non-interacting' configurations
  are included as well.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="NONINTERACT" APPEAR="Non-interacting space" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NonInteracting <advanced>
              <HELP>
              Include triplet-coupled double excitations from inactive to virtual orbitals.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="INTERACT" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

:kword:`PRINt`
  Printlevel of the program. Default printlevel (0) produces very
  little output. Printlevel 5 gives some information that may be of
  interest. The value is read from the line following the keyword, in free
  format.

  .. xmldoc:: <KEYWORD MODULE="GUGA" NAME="PRINT" APPEAR="Print level" KIND="INT" LEVEL="ADVANCED">
              <HELP>
              Enter print level, from 0 (default) up to 5.
              </HELP>
              </KEYWORD>
              %%Keyword: PrintLevel <advanced>
              Requested print level. Default 0. 5 is reasonable.

Input example
.............

::

  &GUGA
  Title
   Water molecule. 2OH correlated.
  Electrons =     4
  Spin      =     1
  Active    =     2    2    0    0
  Interacting space
  Reference
      3    4
    2020 ; 0220 ; 2002

.. xmldoc:: </MODULE>
.. index::
   single: Program; CHCC
   single: CHCC

.. _sec\:chcc:

:program:`chcc`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="CHCC">
            %%Description:
            <HELP>
            The CHCC is a Closed-Shell Coupled-Clusters Singles and Doubles program
            based exclusively on the Cholesky (or RI) decomposed 2-electron integrals aimed
            towards calculation of large system. Use of point-group symmetry is not
            implemented.
            It requires RUNFILE from the SCF module and Cholesky vectors from SEWARD.
            </HELP>

The :program:`CHCC` is a Closed-Shell Coupled-Clusters Singles and Doubles
program based exclusively on the Cholesky (or RI) decomposed 2-electron integrals
aimed towards calculation of large systems on highly parallel architectures. Use of
point-group symmetry is not implemented. Main advantage compared to the
:program:`CCSDT` module in |molcas| is in its more efficient parallelization and
dramatically lowered memory (and eventually disk) requirements.

.. For further details the reader is referred to :numref:`TUT:sec:chcc`.

.. index::
   pair: Dependencies; CHCC

.. _sec\:chcc_dependencies:

Dependencies
------------

:program:`CHCC` requires a previous run of the RHF :program:`SCF` program
to produce molecular orbitals and orbital energies stored in :file:`RUNFILE`.
The :program:`SCF` program (as well as :program:`SEWARD`) must be run
in Cholesky/RI mode.

The algorithm used for almost complete elimination of the :program:`CHCC`
limits in calculated system size due to the computer memory bottleneck relies
on blocking of the virtual orbitals. Number of blocks (further also referred to as the
"large" segmentation, :kword:`LARGe`), :math:`N'`, should be as small as
possible, because increasing of the segmentation brings in more CPU and I/O overhead.
Furthermore, blocking can be "fine tuned" by, so called, "small" segmentation (:kword:`SMALl`), :math:`N''`,
which affects only the (typically) most demanding :math:`O^2V^4` scaling
terms. The "large" segmentation can range from 1 to 32, "small" segmentation from 1 to 8, but
their product, i.e. "large" |x| "small" must be no more than 64.

Selected blocking also determines the
number of "independent" parallel tasks that must be executed in each iteration of
the CCSD equations. In other words, particular segmentation predetermines the optimal
number of computational nodes (i.e., if the best possible parallelization is desired).
If the requested "large" segmentation is :math:`N'`, then :math:`N'^2` terms scaling as
:math:`O^3V^3` and :math:`N'^2/2` terms scaling as :math:`O^2V^4` result.
Depending on which of these terms dominated in the calculations (:math:`O^3V^3`
is more demanding for systems with large number of occupied orbitals and rather small
basis set, while :math:`O^2V^4` dominated for relatively large basis sets,
i.e. large number of virtual orbitals), number of these task should be divisible by the number of
computational nodes for optimal performance. To make it simple, as a rule of thumb, :math:`N'^2/2`
should be divisible by the number of nodes, since the :math:`O^3V^3` are typically twice less
expensive then the :math:`O^2V^4` step. Otherwise, any reasonable (i.e. the number
of tasks is larger than the number of computational nodes, obviously) combination is allowed.

.. index::
   pair: Files; CHCC

.. _sec\:chcc_files:

Files
-----

Input files
...........

:program:`CHCC` will use the following input
files: :file:`CHVEC`, :file:`CHRED`, :file:`CHORST`, :file:`RUNFILE`,
and :file:`CHOR2F`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist

:file:`L0xxxx`, :file:`L1xxxx`, :file:`L2xxxx`
  MO-transformed Cholesky vectors

:file:`T2xxxx`
  T2 :math:`(ij,a'b')` excitation amplitudes

:file:`RstFil`
  Communication file containing T1 amplitudes, restart informations, etc.

.. index::
   pair: Input; CHCC

.. _sec\:chcc_input:

Input
-----

The input for each module is preceded by its name like: ::

  &CHCC

Optional keywords

.. class:: keywordlist

:kword:`TITLe`
  This keyword is followed by one title line.

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="TITLE" APPEAR="Title" KIND="STRINGS" SIZE="10" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              Enter up to ten title lines. Do not put any keyword in the beginning of a title line.
              </HELP>
              </KEYWORD>

:kword:`FROZen`
  Integer on the following line specifies number of inactive occupied
  orbitals in the CCSD calculation. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="FROZ" APPEAR="Frozen orbitals" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="0">
              %%Keyword: FROZen <basic>
              <HELP>
              Specifies number of inactive occupied orbitals in the CCSD procedure
              </HELP>
              </KEYWORD>

:kword:`DELEted`
  Integer on the following line specifies number of inactive virtual
  orbitals in the CCSD calculation. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="DELE" APPEAR="Deleted orbitals" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="0">
              %%Keyword: DELEted <basic>
              <HELP>
              Specifies number of inactive virtual orbitals in the CCSD procedure
              </HELP>
              </KEYWORD>

:kword:`LARGe`
  Integer on the following line specifies the main segmentation of the virtual orbitals.
  Value must be between 1 (no segmentation) and 32. Product of Large and Small segmentation
  must be lower than 64. (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="LARG" APPEAR="Large segmentation" KIND="INT" LEVEL="BASIC" MIN_VALUE="1" MAX_VALUE="32" DEFAULT_VALUE="1">
              %%Keyword: LARGe <basic>
              <HELP>
              Specifies the segmentation of virtual orbitals
              </HELP>
              </KEYWORD>

:kword:`SMALl`
  Integer on the following line specifies the auxiliary segmentation of the virtual orbitals.
  Value must be between 1 (no segmentation) and 8. Product of Large and Small segmentation
  must be lower than 64. Small segmentation doesn't generate extra parallel tasks.
  (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="SMAL" APPEAR="Small segmentation" KIND="INT" LEVEL="BASIC" MIN_VALUE="1" MAX_VALUE="8" DEFAULT_VALUE="1">
              %%Keyword: SMALl <basic>
              <HELP>
              Specifies the auxiliary segmentation of virtual orbitals
              </HELP>
              </KEYWORD>

:kword:`CHSEgmentation`
  Integer on the following line specifies the block size of the auxiliary (Cholesky/RI)
  index. Value must be lower than the minimal dimension of the auxiliary index on each
  computational node. (Default=100)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="CHSE" APPEAR="Auxiliary block size" KIND="INT" LEVEL="BASIC" MIN_VALUE="1" DEFAULT_VALUE="100">
              %%Keyword: CHSEgmentation <basic>
              <HELP>
              Specifies the block size of auxiliary (Cholesky/RI) index
              </HELP>
              </KEYWORD>

:kword:`MHKEy`
  Integer on the following line specifies if library BLAS (MHKEy=1) or hard-coded
  fortran vector-vector, matrix-vector and matrix-matrix manipulation is used.
  (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="MHKE" APPEAR="Use BLAS" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" MAX_VALUE="1" DEFAULT_VALUE="1">
              %%Keyword: MHKEy <basic>
              <HELP>
              Specifies if BLAS libraries (=1) or hard-code fortran is used.
              </HELP>
              </KEYWORD>

:kword:`NOGEnerate`
  This keyword specifies that the pre-CCSD steps (regeneration of integrals from
  the Cholesky/RI vectors, etc.) are skipped.
  (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="NOGE" APPEAR="Skip pre-CCSD steps" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOGEnerate <basic>
              <HELP>
              Pre-CCSD steps, like integrals generation, etc. are skipped.
              </HELP>
              </KEYWORD>

:kword:`ONTHefly`
  This keyword specifies that all integral types scaling steeper then :math:`O^2V^2`
  are generated "on-the-fly" from the Cholesky/RI vectors. Use of this keyword leads
  to dramatically savings of the disk resources, but leads to significant arithmetic
  overhead. Keywords "ONTHefly"
  and "PRECalculate" are mutually exclusive.
  (Default=OFF)

  .. xmldoc:: <SELECT MODULE="CHCC" NAME="INTEGRALS" APPEAR="Integrals" CONTAINS="ONTH,PREC">

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="ONTH" APPEAR="On the fly" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="PREC">
              %%Keyword: ONTHefly <basic>
              <HELP>
              Integrals with 3- and 4-virtual indexes are generated "on-the-fly".
              </HELP>
              </KEYWORD>

:kword:`PRECalculate`
  This keyword specifies that all integral are precalculated before the
  CCSD iterative procedure starts. Use of this keyword leads to significant
  consumption of the disk space, especially is single-processor runs.
  (Default=ON)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="PREC" APPEAR="Precalculate (default)" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="ONTH">
              %%Keyword: PRECalculate <basic>
              <HELP>
              All integrals are precalculated prior to the CCSD iterations.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`NODIstribute`
  This keyword (in combination with the "PRECalculate" keyword) specifies that all
  integral are stored on each computational node. In case of all integrals being
  stored on each node, extra permutation symmetry can be applied, thus leading to
  significant savings of the disk space. However, in case of massively parallel runs
  (i.e. more than ~8 nodes), savings from keeping only subset of integrals
  required on particular node are more significant than savings due to permutational
  symmetry. (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="NODI" APPEAR="No distribute" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NODIstribute <basic>
              <HELP>
              All integrals are precalculated on all computational nodes.
              </HELP>
              </KEYWORD>

:kword:`JOINlkey`
  The parameter on the following line specifies, which algorithm is used for
  precalculation and of the integrals in parallel run. In parallel runs, :program:`SEWARD`
  produces AO Cholesky/RI vectors segmented in auxiliary index over
  parallel nodes. Depending on the network bandwidth and computational power
  of each node, different algorithms can lead to optimal performance.
  Following options are available:

  .. container:: list

    0 --- None: no cumulation of Cholesky/RI vectors is needed (debug only).

    1 --- Minimal: Cholesky/RI vectors are cumulated prior to integral precalculation. Low network bandwidth is required.

    2 --- Medium: :math:`O^2V^2` integrals are generated from local Cholesky/RI vectors and cumulated along with the Cholesky/RI vectors afterwards.
    Other integrals are calculated from cumulated intermediates.

    3 --- Full: All integrals are generated from local Cholesky/RI vectors and cumulated afterwards. High network bandwidth is required.

  (Default=2)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="JOIN" APPEAR="Parallel integral generation" KIND="CHOICE" LIST="0: None (debug),1: Minimal,2: Medium,3: Full" LEVEL="BASIC" DEFAULT_VALUE="2">
              <HELP>
              Choose the type of parallel integral generation
              </HELP>
              %%Keyword: JOINlkey <basic>
              Sets the type of parallel integral generation

              0 -- None (debug)
              1 -- Minimal (low network bandwdith required)
              2 -- Medium
              3 -- Full (high network bandwidth required)
              </KEYWORD>

:kword:`MAXIterations`
  Integer on the following line specifies maximum number of CCSD iteration
  (Default=40)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="MAXI" APPEAR="Maximum iterations" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="40">
              %%Keyword: MAXIterations <basic>
              <HELP>
              Maximum number of CCSD iterations.
              </HELP>
              </KEYWORD>

:kword:`RESTart`
  This keyword specifies that CCSD calculation is restarted from previous
  run. This keyword is currently under development,
  thus disabled. (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="REST" APPEAR="Restart" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: RESTart <basic>
              <HELP>
              Restart from previous run. Currently disabled.
              </HELP>
              </KEYWORD>

:kword:`THREshold`
  Double precision floating point number on the following line specifies
  the convergence threshold for the CCSD correlation energy.
  (Default=1.0d-6)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="THRE" APPEAR="Convergence threshold" KIND="REAL" LEVEL="BASIC" MIN_VALUE="0.0" DEFAULT_VALUE="1.0d-6">
              %%Keyword: THREshold <basic>
              <HELP>
              Convergence threshold for the CCSD correlation energy.
              </HELP>
              </KEYWORD>

:kword:`PRINtkey`
  The integer on the following line specifies the print level in output

  .. container:: list

    1  --- Minimal

    2  --- Minimal + timings of each step of the CCSD iterations

    10 --- Debug

  (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHCC" NAME="PRIN" APPEAR="Print level" KIND="CHOICE" LIST="1: Minimal,2: Minimal + timings,10: Debug" LEVEL="ADVANCED" DEFAULT_VALUE="1">
              <HELP>
              Choose the print level
              </HELP>
              </KEYWORD>
              %%Keyword: PRINtkey <advanced>
              Sets the print level

              1  -- Minimal
              2  -- Minimal + timings
              10 -- Debug

:kword:`END of input`
  This keyword indicates that there is no more input
  to be read.

::

  &CHCC &END
  Title
  Benzene dimer
  Frozen
  12
  Deleted
  0
  Large
  4
  Small
  2
  CHSEgment
  100
  Precalculate
  Join
  2
  Maxiter
  50
  Threshold
  1.0d-6
  Print
  2
  End of Input

.. xmldoc:: </MODULE>
o. index::
   single: Program; Extf
   single: Extf

.. _UG\:sec\:extf:

:program:`extf`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="EXTF">
            %%Description:
            <HELP>
            This module calculates the contribution of an external force that is acting on the system.
            </HELP>

This module calculates the contribution of an external force that is acting on the system. It applies the modification directly on the gradient and it needs to be called after the execution of :program:`ALASKA`, in an optimization or molecular dynamics calculation. At present time, just the :kword:`LINEAR` keyword is present, that applies a constant linear force between two atoms :cite:`valentini2017optomechanical`.

.. _UG\:sec\:extf_inp:

Input
-----

General keywords
................

.. class:: keywordlist

:kword:`LINEAR`
  This keyword works by specifying 4 parameters, each one in its own line after the keyword itself. First parameter (Integer) is the first atom number following the numeration of the geometry. Second parameter (Integer) is the second atom number. Third parameter is the force (Float) in nanonewton applied along the vector between the two atoms. Fourth parameter is 0 or 1 (Bool), where 0 indicates a repulsive force, and 1 is for an attractive force.

  .. xmldoc:: <KEYWORD MODULE="EXTF" NAME="LINEAR" APPEAR="Linear external force" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: LINEar <basic>
              This keyword enables the linear external force between two atoms.
              <HELP>
              This keyword works by specifying 4 parameters, each one in its own line after the keyword itself. First parameter (Integer) is the first atom number following the numeration of the geometry. Second parameter (Integer) is the second atom number. Third parameter is the force (Float) in nanonewton applied along the vector between the two atoms. Fourth parameter is 0 or 1 (Bool), where 0 indicates a repulsive force, and 1 is for an attractive force.
              </HELP>
              </KEYWORD>

Input examples
..............

The following input example is a semiclassical molecular dynamics with tully surface hop, where a linear force of 2.9 nN is applied between atom 1 and atom 2. ::

  &Gateway
  coord=$Project.xyz
  basis=6-31G*
  group=nosym

  >> EXPORT MOLCAS_MAXITER=400
  >> DOWHILE

  &Seward

  &rasscf
   nactel = 6 0 0
   inactive = 23
   ras2 = 6
   ciroot = 2 2 1
   prwf = 0.0
   mdrlxroot = 2

  &alaska

  &surfacehop
   tully
   decoherence = 0.1
   psub

  &Extf
   LINEAR
   1
   2
   2.9
   0

  &Dynamix
   velver
   dt = 41.3
   velo = 1
   thermo = 0
  >>> End Do

This example shows an excited state CASSCF MD simulation
of a methaniminium cation using the Tully Surface Hop algorithm. In the simulation, the carbon and the nitrogen are pulled apart with a constant force of 1.5 nN (nanonewton).
Within the :program:`Extf` module the keyword :kword:`LINEAR` is used. Note :program:`Extf` needs to be called after the execution of :program:`ALASKA`, inside the loop. The options are:
``1``: the atom number corresponding to the C atom,
``2``: the atom number corresponding to the N atom,
``1.5``: the force intensity,
``0``: to indicate a repulsive force.

.. extractfile:: ug/extf.input

  &GATEWAY
   COORD
   6
   Angstrom
   C  0.00031448  0.00000000  0.04334060
   N  0.00062994  0.00000000  1.32317716
   H  0.92882820  0.00000000 -0.49115611
   H -0.92846597  0.00000000 -0.49069213
   H -0.85725321  0.00000000  1.86103989
   H  0.85877656  0.00000000  1.86062860
   BASIS= 3-21G
   GROUP= nosym

  >> EXPORT MOLCAS_MAXITER=1000
  >> DOWHILE

  &SEWARD

  >> IF ( ITER = 1 )

  &RASSCF
    LUMORB
   FileOrb= $Project.GssOrb
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1

  >> COPY $Project.JobIph $Project.JobOld

  >> ENDIF

  &RASSCF
   JOBIPH; CIRESTART
   Symmetry= 1
   Spin= 1
   nActEl= 2 0 0
   Inactive= 7
   RAS2= 2
   CIroot= 3 3 1
   MDRLXR= 2

  >> COPY $Project.JobIph $Project.JobOld

  &surfacehop
   TULLY
   SUBSTEP = 200
   DECOHERENCE = 0.1
   PSUB

  &ALASKA

  &extf
   LINEAR
   1
   2
   1.5
   0

  &Dynamix
   VELVer
   DT= 10.0
   VELO= 3
   THER= 2
   TEMP=300

  >> END DO

.. xmldoc:: </MODULE>
.. index::
   single: Program; Poly_aniso
   single: Poly_aniso

.. _UG\:sec\:poly_aniso:

:program:`poly_aniso`
=====================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="POLY_ANISO" APPEAR="Poly_Aniso">
            %%Description:
            <HELP>
            The POLY_ANISO program allows the non-perturbative calculation of
            effective spin (pseudospin) Hamiltonians and static magnetic properties
            of mononuclear complexes and fragments completely ab initio,including
            the spin-orbit interaction. As a starting point it uses the results
            of a RASSI calculation for the ground and several excited spin-orbital
            multiplets.

            The following quantities can be computed:

            1. Parameters of pseudospin magnetic Hamiltonians:
              a) First order (linear after pseudospin) Zeeman splitting tensor (g tensor),
                 including the determination of the sign of the product gX*gY*gZ
              b) Second order (bilinear after pseudospin) zero-field splitting tensor (D tensor)
              c) Higher order zero-field splitting tensors (D^2, D^4, D^6, ..., etc.)
              d) Higher order Zeeman splitting tensors (G^1, G^3, G^5, ..., etc.)
              e) Angular Moments along the main magnetic axes

            2. Crystal-Field parameters for the ground atomic multiplet for lanthanides

            3. Static magnetic properties:
              a) Van Vleck susceptibility tensor
              b) Powder magnetic susceptibility function
              c) Magnetization vector for specified directions of the applied magnetic field
              d) Powder magnetization
            </HELP>

The :program:`POLY_ANISO` program is a routine which allows a semi-ab initio
description of the (low-lying) electronic structure and magnetic properties
of polynuclear compounds. It is based on the localized nature of the magnetic
orbitals (i.e. the |d.| or |f.| orbitals containing unpaired electrons :cite:`Anderson1959,Anderson1963`).
For many compounds of interest, the localized character of magnetic orbitals leads
to very weak character of the interactions between magnetic centers. Due to this weakness of the
interaction, the metals' orbitals and corresponding localized ground and excited states
may be optimized in the absence of the magnetic interaction at all. For this purpose, various fragmentation
models may be applied. The most commonly used fragmentation model is exemplified in :numref:`fig:fragment`.

.. figure:: fragment.*
   :name: fig:fragment
   :width: 100%
   :align: center

   Fragmentation model of a polynuclear compound. The upper scheme shows a schematic overview of a tetranuclear compound and the resulting four mononuclear fragments obtained by *diamagnetic atom substitution* method. By this scheme, the neighboring magnetic centers, containing unpaired electrons are computationally replaced by their diamagnetic equivalents. As example, transition metal sites TM(II) are best replaced by either diamagnetic :math:`\ce{Zn(II)}` or :math:`\ce{Sc(III)}`, in function which one is the closest. For lanthanides :math:`\ce{Ln(III)}` the same principle is applicable, :math:`\ce{La(III)}` or :math:`\ce{Lu(III)}` are best suited to replace a given magnetic lanthanide. Individual mononuclear metal framgents are then investigated by common CASSCF/CASPT2/RASSI/SINGLE_ANISO computational method. A single file for each magnetic site, produced by the :program:`SINGLE_ANISO` run, is needed by the :program:`POLY_ANISO` code as input.

Magnetic interaction between metal sites is very important for accurate description of low-lying states and their properties.
It can be considered as a sum of various interaction mechanisms: magnetic exchange, dipole-dipole interaction, antisymmetric exchange, etc.
In the :program:`POLY_ANISO` code we have implemented several mechanisms.

The description of the magnetic exchange interaction is done within the Lines model :cite:`Lines1971`.
This model is exact in three cases:

a) interaction between two isotropic spins (Heisenberg),
b) interaction between one Ising spin (only :math:`S_z` component) and one isotropic (i.e. usual) spin, and
c) interaction between two Ising spins.

In all other cases of interaction between magnetic sites with intermediate anisotropy, the Lines model represents an
approximation. However, it was succesfully applied for a wide variety of polynuclear compounds so far.

.. compound::

  In addition to the magnetic exchange, magnetic dipole-dipole interaction can be accounted exactly, by
  using the information about each metal site already computed *ab initio*. In the case of
  strongly anisotropic lanthanide compounds, the dipole-dipole interaction is usualy the dominant
  one. Dipolar magnetic coupling is one kind of long-range interaction between magnetic moments.
  For example, a system containing two magnetic dipoles :math:`\mu_1` and :math:`\mu_2`, separated by
  distance :math:`\vec{r}` have a total energy:

  .. math:: E_{\text{dip}} = \frac{\mu_{\text{Bohr}}^{2}}{r^3} [\vec{\mu}_1 \cdot \vec{\mu}_2 - 3(\vec{\mu}_1 \vec{n}_{12}) \cdot (\vec{\mu}_2 \vec{n}_{12})],

  where :math:`\vec{\mu}_{1,2}` are the magnetic moments of sites 1 and 2, respectively; :math:`r` is the distance between
  the two magnetic dipoles, :math:`\vec{n}_{12}` is the directional vector connecting the two magnetic dipoles (of unit length).
  :math:`\mu_{\text{Bohr}}^2` is the square of the Bohr magneton; with an approximative value of 0.43297 in :math:`\text{cm}^{-1}/\text{T}`.
  As inferred from the above Equation, the dipolar magnetic interaction depends on the distance and on the angle between the magnetic moments on magnetic
  centers. Therefore, the Cartesian coordinates of all non-equivalent magnetic centers must be provided in the input (see the keyword :kword:`COOR`).

Files
-----

Input files
...........

The program :program:`Poly_Aniso` needs the following files:

.. class:: filelist

:file:`aniso_XX.input`
  This is an ASCII text file generated by the |molcas|/SINGLE_ANISO program.
  It should be provided for :program:`POLY_ANISO` :file:`aniso_i.input` (:math:`i=1, 2, 3`, etc.): one file for each magnetic center.
  In cases when the entire polynuclear cluster or molecule has exact point group symmetry, only
  :file:`aniso_i.input` files for crystallographically non-equivalent centers should be given.

:file:`chitexp.input`
  set directly in the standard input (key :kword:`TEXP`)

:file:`magnexp.input`
  set directly in the standard input (key :kword:`HEXP`)

Output files
............

.. class:: filelist

:file:`zeeman_energy_xxx.txt`
  A series of files named :file:`zeeman_energy_xxx.txt` is produced in the :file:`$WorkDir` only in case keyword :kword:`ZEEM` is
  employed (see below). Each file is an ASCII text formated and contains Zeeman spectra of the investigated
  compound for each value of the applied magnetic field.

:file:`chit_compare.txt`
  A text file contining the experimental and calculated magnetic susceptibility data.

:file:`magn_compare.txt`
  A text file contining the experimental and calculated powder magnetisation data.

Files :file:`chit_compare.txt` and :file:`chit_compare.txt` may be used in connection with a simple gnuplot script
in order to plot the comparison between experimental and calculated data.

.. index::
   pair: Input; Poly_aniso

.. _UG\:sec\:poly_aniso_input:

Input
-----

This section describes the keywords used to control the standard input file.
Only two keywords :kword:`NNEQ`, :kword:`PAIR` (and :kword:`SYMM` if the polynuclear cluster has symmetry) are
mandatory for a minimal execution of the program, while the other keywords allow
customization of the execution of the :program:`POLY_ANISO`.

Mandatory keywords defining the calculation
...........................................

*Keywords defining the polynuclear cluster*

.. class:: keywordlist

:kword:`NNEQ`
  This keyword defines several important parameters of the calculation. On the
  first line after the keyword the program reads 2 values:
  1) the number of types of different magnetic centers (NON-EQ) of the cluster and
  2) a letter ``T`` or ``F`` in the second position of the same line.
  The number of NON-EQ is the total number of magnetic centers of the cluster
  which cannot be related by point group symmetry.
  In the second position the answer to the question: *Have all NON-EQ centers been computed ab initio?*
  is given: ``T`` for *True* and ``F`` for *False*.
  On the third position, the answer to the question: *Are the rassi.h5 files to be read for input?*
  is given. For the current status, the letter ``F`` is the only option.
  On the following line the program will read NON-EQ values specifying the
  number of equivalent centers of each type.
  On the following line the program will read NON-EQ integer numbers specifying
  the number of low-lying spin-orbit functions from each center forming the local
  exchange basis.

  Some examples valid for situations where all sites have been
  computed *ab initio* (case ``T``, *True*):

  .. class:: poly_aniso

  +----------------------------------------+----------------------------------------+----------------------------------------+
  | ::                                     | ::                                     | ::                                     |
  |                                        |                                        |                                        |
  |   NNEQ                                 |   NNEQ                                 |   NNEQ                                 |
  |   2  T  F                              |   3  T  F                              |   6  T  F                              |
  |   1  2                                 |   2  1  1                              |   1  1  1  1  1  1                     |
  |   2  2                                 |   4  2  3                              |   2  4  3  5  2  2                     |
  +----------------------------------------+----------------------------------------+----------------------------------------+
  | There are two kinds of magnetic centers| There are three kinds of magnetic      | There are 6 kinds of magnetic centers  |
  | in the cluster; both have been computed| centers in the cluster; all three have | in the cluster; all six have been      |
  | ab initio; the cluster consists of 3   | been computed ab initio; the cluster   | computed ab initio; the cluster        |
  | magnetic centers: one center of the    | consists of four magnetic centers: two | consists of 6 magnetic centers: one    |
  | first kind and two centers of the      | centers of the first kind, one center  | center of each kind. From the center of|
  | second kind. From each center we take  | of the second kind and one center of   | the first kind we take into exchange   |
  | into the exchange coupling only the    | the third kind. From each of the       | coupling two spin-orbit states, four   |
  | ground doublet. As a result the        | centers of the first kind we take into | states from the second center, three   |
  | :math:`N_{\text{exch}}=2^1 \times      | exchange coupling four spin-orbit      | states from the third center, five     |
  | 2^2=8` :file:`aniso_1.input` (for ---  | states, two states from the second kind| states from the fourth center and two  |
  | type 1) and :file:`aniso_2.input`      | and three states from the third center.| states from the fifth and sixth        |
  | (for --- type 2) files must be present.| As a result the                        | centers. As a result the               |
  |                                        | :math:`N_{\text{exch}}=4^2 \times 2^1  | :math:`N_{\text{exch}}=2^1 \times 4^1  |
  |                                        | \times 3^1=96`. Three files            | \times 3^1 \times 5^1 \times 2^1 \times|
  |                                        | :file:`aniso_i.input` for each center  | 2^1=480`. Six files                    |
  |                                        | (:math:`i=1,2,3`) must be present.     | :file:`aniso_i.input` for each center  |
  |                                        |                                        | (:math:`i=1,2,\ldots,6`) must be       |
  |                                        |                                        | present.                               |
  +----------------------------------------+----------------------------------------+----------------------------------------+

  Only in cases when some centers have NOT been computed ab initio (i.e. for which no :file:`aniso_i.input` file exists),
  the program will read an additional line consisting of NON-EQ letters (``A`` or ``B``) specifying the type of each of
  the NON-EQ centers:
  ``A`` --- the center is computed ab initio and ``B`` --- the center is considered isotropic.
  On the following ``number-of-B-centers`` line(s) the isotropic :math:`g` factors of the
  center(s) defined as ``B`` are read. The spin of the ``B`` center(s) is defined: :math:`S=(N-1)/2`,
  where :math:`N` is the corresponding number of states to be taken into the exchange coupling
  for this particular center.

  Some examples valid for mixed situations: the system consists of centers computed *ab initio* and
  isotropic centers (case ``F``, *False*):

  .. class:: poly_aniso

  +----------------------------------------+----------------------------------------+----------------------------------------+
  | ::                                     | ::                                     | ::                                     |
  |                                        |                                        |                                        |
  |   NNEQ                                 |   NNEQ                                 |   NNEQ                                 |
  |   2  F  F                              |   3  F  F                              |   6  T  F                              |
  |   1  2                                 |   2  1  1                              |   1  1  1  1  1  1                     |
  |   2  2                                 |   4  2  3                              |   2  4  3  5  2  2                     |
  |   A  B                                 |   A  B  B                              |   B  B  A  A  B  A                     |
  |   2.3                                  |   2.1                                  |   2.12                                 |
  |                                        |   2.0                                  |   2.43                                 |
  |                                        |                                        |   2.00                                 |
  +----------------------------------------+----------------------------------------+----------------------------------------+
  | There are two kinds of magnetic centers| There are three kinds of magnetic      | There are six kinds of magnetic centers|
  | in the cluster; the center of the first| centers in the cluster; the first      | in the cluster; only three centers have|
  | type has been computed *ab initio*,    | center type has been computed *ab      | been computed *ab initio*, while the   |
  | while the centers of the second type   | initio*, while the centers of the      | other three centers are considered     |
  | are considered isotropic with          | second and third types are considered  | isotropic; the :math:`g` factor of the |
  | :math:`g=2.3`; the cluster consists of | isotropic with :math:`g=2.1` (second   | first center is 2.12 (:math:`S=1/2`);  |
  | three magnetic centers: one center of  | type) and :math:`g=2.0` (third type);  | of the second center 2.43              |
  | the first kind and two centers of the  | the cluster consists of four magnetic  | (:math:`S=3/2`); of the fifth center   |
  | second kind. Only the ground doublet   | centers: two centers of the first kind,| 2.00 (:math:`S=1/2`); the entire       |
  | state from each center is considered   | one center of the second kind and one  | cluster consists of six magnetic       |
  | for the exchange coupling. As a result | center of the third kind. From each of | centers: one center of each kind. From |
  | the :math:`N_{\text{exch}}=2^1 \times  | the centers of the first kind, four    | the center of the first kind, two      |
  | 2^2=8`. File :file:`aniso_1.input` (for| spin-orbit states are considered for   | spin-orbit states are considered in the|
  | --- type 1) must be present.           | the exchange coupling, two states from | exchange coupling, four states from the|
  |                                        | the second kind and three states from  | second center, three states from the   |
  |                                        | the center of the third kind. As a     | third center, five states from the     |
  |                                        | result the :math:`N_{\text{exch}}=4^2  | fourth center and two states from the  |
  |                                        | \times 2^1 \times 3^1=96`. The file    | fifth and sixth centers. As a result   |
  |                                        | :file:`aniso_1.input` must be present. | the :math:`N_{\text{exch}}=2^1 \times  |
  |                                        |                                        | 4^1 \times 3^1 \times 5^1 \times 2^1   |
  |                                        |                                        | \times 2^1=480`. Three files           |
  |                                        |                                        | :file:`aniso_3.input` and              |
  |                                        |                                        | :file:`aniso_4.input` and              |
  |                                        |                                        | :file:`aniso_6.input` must be present. |
  +----------------------------------------+----------------------------------------+----------------------------------------+

  There is no maximal value for :kword:`NNEQ`, although the calculation becomes quite heavy in case the number of
  exchange functions is large.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="NNEQ" APPEAR="Definition of input magnetic sites" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: NNEQ <basic>
              <HELP>
              This keyword defines several important parameters of the calculation. On the
              first line after the keyword the program reads 2 values:

              1) the number of types of different magnetic centers (NON-EQ) of the cluster and
              2) a letter "T" or "F" in the second position of the same line.

              The number of NON-EQ is the total number of magnetic centers of the cluster
              which cannot be related by point group symmetry.
              In the second position the answer to the question: "Have all NON-EQ centers been computed ab initio?"
              is given: "T" for True and "F" for False.
              On the third position, the answer to the question: "Are the rassi.h5 files to be read for input?"
              is given. For the current status, the letter "F" is the only option.
              On the following line the program will read NON-EQ values specifying the
              number of equivalent centers of each type.
              On the following line the program will read NON-EQ integer numbers specifying
              the number of low-lying spin-orbit functions from each center forming the local
              exchange basis.
              </HELP>
              </KEYWORD>

:kword:`SYMM`
  Specifies rotation matrices to symmetry equivalent sites. This keyword is mandatory in the case more centers of a given type are present in the calculation.
  This keyword is mandatory when the calculated polynuclear compound has exact crystallographic point group symmetry. In other words, when the number of
  equivalent centers of any kind :math:`i` is larger than 1, this keyword must be employed. Here the rotation matrices from the one
  center to all the other of the same type are declared.
  On the following line the program will read the number ``1`` followed on the next lines by as many :math:`3\times3` rotation matrices as the total number of
  equivalent centers of type ``1``. Then the rotation matrices of centers of type ``2``, ``3`` and so on, follow in the same format.
  When the rotation matrices contain irrational numbers (e.g. :math:`\sin{\frac{\pi}{6}}=\frac{\sqrt{3}}{2}`), then more digits than presented in the examples
  below are advised to be given: :math:`\frac{\sqrt{3}}{2}=0.86602540378`.

  Examples:

  .. class:: poly_aniso

  +----------------------------------------+----------------------------------------+----------------------------------------+
  | ::                                     | ::                                     | ::                                     |
  |                                        |                                        |                                        |
  |     NNEQ                               |   NNEQ                                 |   NNEQ                                 |
  |     2  F  F                            |   3  F  F                              |   6  F  F                              |
  |     1  2                               |   2  1  1                              |   1  1  1  1  1  1                     |
  |     2  2                               |   4  2  3                              |   2  4  3  5  2  2                     |
  |     A  B                               |   A  B  B                              |   B  B  A  A  B  A                     |
  |     2.3                                |   2.1                                  |   2.12                                 |
  |                                        |   2.0                                  |   2.43                                 |
  |     SYMM                               |   2.0                                  |   2.00                                 |
  |     1                                  |                                        |                                        |
  |     1.0 0.0 0.0                        |   SYMM                                 |                                        |
  |     0.0 1.0 0.0                        |   1                                    |                                        |
  |     0.0 0.0 1.0                        |   1.0 0.0 0.0                          |                                        |
  |     2                                  |   0.0 1.0 0.0                          |                                        |
  |     1.0 0.0 0.0                        |   0.0 0.0 1.0                          |                                        |
  |     0.0 1.0 0.0                        |   0.0 -1.0 0.0                         |                                        |
  |     0.0 0.0 1.0                        |   1.0 0.0  0.0                         |                                        |
  |     -1.0 0.0 0.0                       |   0.0 0.0  1.0                         |                                        |
  |     0.0 -1.0 0.0                       |   2                                    |                                        |
  |     0.0 0.0 -1.0                       |   1.0 0.0 0.0                          |                                        |
  |                                        |   0.0 1.0 0.0                          |                                        |
  |                                        |   0.0 0.0 1.0                          |                                        |
  |                                        |   3                                    |                                        |
  |                                        |   1.0 0.0 0.0                          |                                        |
  |                                        |   0.0 1.0 0.0                          |                                        |
  |                                        |   0.0 0.0 1.0                          |                                        |
  +----------------------------------------+----------------------------------------+----------------------------------------+
  | The cluster computed here is a         | In this input a tetranuclear compound  | In this case the computed system has no|
  | trinuclear compound, with one center   | is defined, all centers are computed ab| symmetry. Therefore, the :kword:`SYMM` |
  | computed ab initio, while the other two| initio. There are two centers of type  | keyword may be skipped.                |
  | centers, related to each other by      | "1", related one to each other by      |                                        |
  | inversion, are considered isotropic    | :math:`C_2` symmetry around the        |                                        |
  | with :math:`g_x=g_y=g_z=2.3`. The      | Cartesian Z axis. Therefore the        |                                        |
  | rotation matrix for the first center is| :kword:`SYMM` keyword is mandatory.    |                                        |
  | :math:`I` (identity, unity) since the  | There are two matrices for centers of  |                                        |
  | center is unique. For the centers of   | type 1, and one matrix (identity) for  |                                        |
  | type 2, there are two matrices         | the centers of type 2 and type 3.      |                                        |
  | :math:`3\times3` since we have two     |                                        |                                        |
  | centers in the cluster. The rotation   |                                        |                                        |
  | matrix of the first center of type 2 is|                                        |                                        |
  | Identity while the rotation matrix for |                                        |                                        |
  | the equivalent center of type 2 is the |                                        |                                        |
  | inversion matrix.                      |                                        |                                        |
  +----------------------------------------+----------------------------------------+----------------------------------------+

  More examples are given in the *Tutorial* section.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="SYMM" APPEAR="Definition of symmetry of the polynuclear cluster, if any" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: SYMM <basic>
              <HELP>
              Specifies rotation matrices to symmetry equivalent sites. This keyword is mandatory in the case more centers of a given type are present in the calculation.
              This keyword is mandatory when the calculated polynuclear compound has exact crystallographic point group symmetry. In other words, when the number of
              equivalent centers of any kind "i" is larger than 1, this keyword must be employed. Here the rotation matrices from the one
              center to all the other of the same type are declared.
              On the following line the program will read the number "1" followed on the next lines by as many 3x3 rotation matrices as the total number of
              equivalent centers of type "1". Then the rotation matrices of centers of type "2", "3" and so on, follow in the same format.
              </HELP>
              </KEYWORD>

*Keywords defining the magnetic exchange interactions*

This section defines the keywords used to set up the interacting pairs of magnetic centers
and the corresponding exchange interactions.

A few words about the numbering of the magnetic centers of the
cluster in the :program:`POLY_ANISO`. First all equivalent centers of the type 1 are
numbered, then all equivalent centers of the type 2, etc. These labels of the magnetic
centers are used further for the declaration of the magnetic coupling.
The pseudo-code is: ::

  k=0
  Do i=1, number-of-non-equivalent-sites
    Do j=1, number-of-equivalent-sites-of-type(i)
       k=k+1
       site-number(i,j)=k
    End Do
  End Do

.. class:: keywordlist

:kword:`PAIR` or :kword:`LIN1`
  Specifies the Lines interaction(s) between metal pairs. One parameter per interacting pair is required.

  ::

    LIN1
       READ number-of-interacting-pairs
       Do i=1, number-of-interacting-pairs
          READ site-1, site-2,   J
       End Do

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="PAIR" KIND="REALS_COMPUTED" SIZE="3" LEVEL="UNDOCUMENTED" ALSO="LIN1" />

:kword:`ALIN` or :kword:`LIN3`
  Specifies the anisotropic interactions between metal pairs. Three parameters per interacting pair are required.

  ::

    LIN3
       READ number-of-interacting-pairs
       Do i=1, number-of-interacting-pairs
          READ site-1, site-2,   Jxx, Jyy, Jzz
       End Do

  :math:`J_{\alpha\beta}`, where :math:`\alpha` and :math:`\beta` are main values of the Cartesian components of the (:math:`3\times3`) matrix defining the exchange interaction between site-1 and site-2.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ALIN" KIND="REALS_COMPUTED" SIZE="5" LEVEL="UNDOCUMENTED" ALSO="LIN3" />

:kword:`LIN9`
  Specifies the full anisotropic interaction matrices between metal pairs. Nine parameters per interacting pair is required.

  ::

    LIN9
       READ number-of-interacting-pairs
       Do i=1, number-of-interacting-pairs
          READ site-1, site-2,   Jxx, Jxy, Jxz,   Jyx, Jyy, Jyz,  Jzx, Jzy, Jzz
       End Do

  :math:`J_{\alpha\beta}`, where :math:`\alpha` and :math:`\beta` are main values of the Cartesian components of the (:math:`3\times3`) matrix defining the exchange interaction between site-1 and site-2.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="LIN9" KIND="REALS_COMPUTED" SIZE="11" LEVEL="UNDOCUMENTED" />

:kword:`COOR`
  Specifies the symmetrized coordinates of the metal sites. This keyword enables computation of dipole-dipole
  magnetic interaction between metal sites defined in the keywords :kword:`PAIR`, :kword:`ALIN`, :kword:`LIN1`, :kword:`LIN3` or :kword:`LIN9`.

  ::

    COOR
       Do i=1, number-of-non-equivalent-sites
          READ coordinates of center 1
          READ coordinates of center 2
          ...
       End Do

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="COOR" KIND="REALS_LOOKUP" SIZE="3NNEQ" LEVEL="BASIC">
              %%Keyword: COOR <basic>
              <HELP>
              Specifies the symmetrized coordinates of the metal sites. This keyword enables computation of dipole-dipole interaction.
              </HELP>
              </KEYWORD>

*Other keywords*

Normally :program:`POLY_ANISO` runs without specifying any of the following keywords.

Argument(s) to a keyword are always supplied on the next line of the input file.

Optional general keywords to control the input
..............................................

.. class:: keywordlist

:kword:`MLTP`
  The number of molecular multiplets (i.e. groups of spin-orbital eigenstates) for which
  :math:`g`, :math:`D` and higher magnetic tensors will be calculated (default :kword:`MLTP`\=1).
  The program reads two lines: the first is the number of multiplets (:math:`N_{\text{MULT}}`) and the
  second the array of :math:`N_{\text{MULT}}` numbers specifying the dimension (multiplicity) of each multiplet.

  Example: ::

    MLTP
    10
    2 4 4 2 2   2 2 2 2 2

  :program:`POLY_ANISO` will compute the :math:`g` and :math:`D{-}` tensors for 10 groups of states.
  The groups 1 and 4--10 are doublets (:math:`\tilde{S}=\ket{1/2}`), while the groups 2 and 3 are quadruplets,
  having the effective spin :math:`\tilde{S}=\ket{3/2}`. For the latter cases, the ZFS (:math:`D{-}`) tensors will be computed.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="MLTP" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: MLTP <basic>
              <HELP>
              The number of molecular multiplets (i.e. groups of spin-orbital eigenstates) for
              which g, D and higher magnetic tensors will be calculated.
              The program reads two lines: the first is the number of multiplets (NMULT) and
              on the second line the array of NMULT numbers specifying the dimension of each multiplet.
              By default, the code will first analyze the energy spectra by itself and will
              compute the g and D tensors for ten low-lying groups of states. By using this
              keyword the user overwrites the default.
              </HELP>
              </KEYWORD>

:kword:`TINT`
  Specifies the temperature points for the evaluation of the magnetic susceptibility. The program will read three numbers: :math:`T_{\text{min}}`, :math:`T_{\text{max}}`, :math:`n_T`.

  .. container:: list

    :math:`T_{\text{min}}` --- the minimal temperature (Default 0.0 K)

    :math:`T_{\text{max}}` --- the maximal temperature (Default 300.0 K)

    :math:`n_T` --- number of temperature points (Default 101)

  Example: ::

    TINT
    0.0  330.0  331

  :program:`POLY_ANISO` will compute temperature dependence of the magnetic susceptibility in 331 points evenly distributed in temperature interval: 0.0 K -- 330.0 K.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="TINT" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TINT <basic>
              <HELP>
              Specifies the temperature points for the evaluation of the magnetic susceptibility.
              The program will read three numbers: Tmin, Tmax, nT. Units of temperature = kelvin (K).

              Tmin -- the minimal temperature (Default 0.0 K)
              Tmax -- the maximal temperature (Default 300.0 K)
              nT   -- number of temperature points (Default 101)
              </HELP>
              </KEYWORD>

:kword:`HINT`
  Specifies the field points for the evaluation of the magnetization in a certain direction. The program will read four numbers: :math:`H_{\text{min}}`, :math:`H_{\text{max}}` and :math:`n_H`

  .. container:: list

    :math:`H_{\text{min}}` --- the minimal field (Default 0.0 T)

    :math:`H_{\text{max}}` --- the maximal filed (Default 10.0 T)

    :math:`n_H` --- number of field points (Default 101)

  .. compound::

    Example: ::

      HINT
      0.0  20.0  201

    :program:`POLY_ANISO` will compute the molar magnetization in 201 points evenly distributed in field interval: 0.0 T -- 20.0 T.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="HINT" KIND="REAL" LEVEL="BASIC">
              %%Keyword: HINT <basic>
              <HELP>
              Specifies the field points for the evaluation of the molar magnetization.
              The program will read four numbers: Hmin, Hmax, nH, and dltH0. Units of magnetic field = tesla (T).

              Hmin -- the minimal field (Default 0.0 T)
              Hmax -- the maximal field (Default 300.0 T)
              nH   -- number of field points (Default 101)
              </HELP>
              </KEYWORD>

:kword:`TMAG`
  Specifies the temperature(s) at which the field-dependent magnetization is calculated. Default is one temperature point, :math:`T`\=2.0 K.
  Example: ::

    TMAG
    6   1.8 2.0 2.4  2.8 3.2 4.5

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="TMAG" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TMAG <basic>
              <HELP>
              Specifies the temperature at which the field-dependent magnetization is calculated. Default is 2.0 K
              </HELP>
              </KEYWORD>

:kword:`ENCU`
  .. compound::

    This flag is used to define the cut-off energy for the lowest states for which Zeeman interaction is taken into account exactly. The contribution to the magnetization coming from states that are higher in energy than :math:`E` (see below) is done by second order perturbation theory. The program will read two integer numbers: :math:`N_K` and :math:`M_G`. Default values are: :math:`N_K`\=100, :math:`M_G`\=100.

    .. math:: E=N_K \cdot k_{\text{B}} \cdot T_{\text{MAG}} + M_G \cdot \mu_{\text{Bohr}} \cdot H_{\text{max}}

    The field-dependent magnetization is calculated at the (highest) temperature value defined in either :kword:`TMAG` or :kword:`HEXP`.
    Example: ::

      ENCU
      250  150

    If :math:`H_{\text{max}}` = 10 T and :kword:`TMAG` = 1.8 K, then the cut-off energy is:

    .. math:: E=100 \cdot 250 \cdot k_{\text{B}} \cdot 1.8 + 150 \cdot \mu_{\text{Bohr}} \cdot 10 = 1013.06258\,\text{cm}^{-1}

    This means that the magnetization coming from all spin-orbit states with energy lower than :math:`E=1013.06258\,\text{cm}^{-1}` will be computed exactly.
    :kword:`ERAT`, :kword:`NCUT` and :kword:`ENCU` are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ENCU" KIND="INT" LEVEL="BASIC">
              %%Keyword: ENCU <basic>
              <HELP>
              This keyword is used to define the cut-off energy for the lowest states for which
              Zeeman interaction is taken into account exactly. The contribution to the
              magnetization coming from states that are higher in energy than E (see below)
              is done by second order perturbation theory. The program will read two integer
              numbers: NK and MG. Default values are: NK=100, MG=100. The field-dependent magnetization
              is calculated at the temperature value TMAG.
              </HELP>
              </KEYWORD>

:kword:`ERAT`
  .. compound::

    This flag is used to define the cut-off energy for the lowest states for which Zeeman interaction
    is taken into account exactly. The contribution to the molar magnetization coming from states that
    are higher in energy than :math:`E` (see below) is done by second order perturbation theory.
    The program reads one real number in the domain (0.0--1.0). Default is 1.0 (all exchange states are
    included in the Zeeman interaction).

    .. math:: E = \text{ERAT} \cdot \text{Maximal-spread-of-exchange-splitting}

    The field-dependent magnetization is calculated at all temperature points defined in either :kword:`TMAG` or :kword:`HEXT`.
    Example: ::

      ERAT
      0.75

    :kword:`ERAT`, :kword:`NCUT` and :kword:`ENCU` are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ERAT" KIND="INT" LEVEL="BASIC">
              %%Keyword: ERAT <basic>
              <HELP>
              This keyword is used to define the cut-off energy for the lowest states for which
              Zeeman interaction is taken into account exactly. The contribution to the
              magnetization coming from states that are higher in energy than E (see below)
              is done by second order perturbation theory. The program will read one real number in the domain 0.0-1.0.
              The field-dependent magnetization
              is calculated at the temperature value TMAG.
              </HELP>
              </KEYWORD>

:kword:`NCUT`
  .. compound::

    This flag is used to define the number of low-lying exchange states for which Zeeman interaction is taken into
    account exactly. The contribution to the magnetization coming from the remaining exchange states is done by second
    order perturbation theory. The program will read one integer number. The field-dependent magnetization is calculated at all temperature points defined in either :kword:`TMAG` or :kword:`HEXT`.
    Example: ::

      NCUT
      125

    In case the defined number is larger than the total number of exchange states in the calculation (:math:`N_{\text{exch}}`), then :math:`n_{\text{Cut}}` is set to be equal to :math:`N_{\text{exch}}`.
    :kword:`ERAT`, :kword:`NCUT` and :kword:`ENCU` are mutually exclusive.

:kword:`MVEC`
  Defines the number of directions for which the magnetization vector will be computed.
  On the first line below the keyword, the number of directions should be mentioned (:math:`N_{\text{DIR}}`. Default 0).
  The program will read :math:`N_{\text{DIR}}` lines for Cartesian coordinates specifying the direction :math:`i` of the
  applied magnetic field (:math:`\theta_i` and :math:`\phi_i`). These values may be arbitrary real numbers.
  The direction(s) of applied magnetic field are obtained by normalizing the length of each vector to one.
  Example: ::

    MVEC
    4
    0.0000  0.0000   0.1000
    1.5707  0.0000   2.5000
    1.5707  1.5707   1.0000
    0.4257  0.4187   0.0000

  The above input requests computation of the magnetization vector in four directions of applied field.
  The actual directions on the unit sphere are: ::

    4
    0.00000  0.00000  1.00000
    0.53199  0.00000  0.84675
    0.53199  0.53199  0.33870
    0.17475  0.17188  0.00000

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="MVEC" KIND="REALS_COMPUTED" SIZE="3" LEVEL="BASIC">
              %%Keyword: MVEC <basic>
              <HELP>
              Defines the number of directions for which the magnetization vector will be computed.
              On the first line below the keyword, the number of directions should be mentioned (NDIR. Default 0).
              The program will read NDIR lines for spherical coordinates specifying the direction
              "i" of the magnetic field (theta_i and phi_i). These values should be in radians.
              </HELP>
              </KEYWORD>

:kword:`ZEEM`
  Defines the number of directions for which the Zeeman energy will be computed/saved/plotted.
  On the first line below the keyword, the number of directions should be mentioned (:math:`N_{\text{DIR}}`. Default 0).
  The program will read :math:`N_{\text{DIR}}` lines for Cartesian coordinates specifying the direction :math:`i` of the
  applied magnetic field (:math:`\theta_i` and :math:`\phi_i`). These values may be arbitrary real numbers.
  The direction(s) of applied magnetic field are obtained by normalizing the length of each vector to one.
  Example: ::

    MVEC
    4
    0.0000  0.0000   0.1000
    1.5707  0.0000   2.5000
    1.5707  1.5707   1.0000
    0.4257  0.4187   0.0000

  The above input requests computation of the magnetization vector in four directions of applied field.
  The actual directions on the unit sphere are: ::

    4
    0.00000  0.00000  1.00000
    0.53199  0.00000  0.84675
    0.53199  0.53199  0.33870
    0.17475  0.17188  0.00000

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ZEEM" KIND="REALS_COMPUTED" SIZE="3" LEVEL="BASIC">
              %%Keyword: ZEEM <basic>
              <HELP>
              Defines the number of directions for which the magnetization vector will be computed.
              On the first line below the keyword, the number of directions should be mentioned (NDIR. Default 0).
              The program will read NDIR lines for spherical coordinates specifying the direction
              "i" of the magnetic field (theta_i and phi_i). These values should be in radians.
              </HELP>
              </KEYWORD>

:kword:`MAVE`
  This keyword specifies the grid density used for the computation of powder molar
  magnetization. The program uses Lebedev--Laikov distribution of points on the unit sphere.
  The program reads two integer numbers: :math:`n_{\text{sym}}` and :math:`n_{\text{grid}}`. The :math:`n_{\text{sym}}` defines which
  part of the sphere is used for averaging. It takes one of the three values: 1 (half-sphere),
  2 (a quater of a sphere) or 3 (an octant of the sphere). :math:`n_{\text{grid}}` takes values from 1
  (the smallest grid) till 32 (the largest grid, i.e. the densiest). The default is to
  consider integration over a half-sphere (since :math:`M(H)=-M(-H)`): :math:`n_{\text{sym}}=1` and :math:`n_{\text{grid}}=15`
  (i.e. 185 points distributed over half-sphere). In case of symmetric compounds, powder
  magnetization may be averaged over a smaller part of the sphere, reducing thus the number
  of points for the integration. The user is responsible to choose the appropriate integration scheme.
  Default value for :math:`n_{\text{grid}}=15` (185 directions equally distributed in the given area).
  Note that the program's default is rather conservative.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="MAVE" KIND="INT" LEVEL="BASIC">
              %%Keyword: MAVE <basic>
              <HELP>
              Specifies the number of directions of the applied magnetic field for the computation
              of the powder molar magnetization. The program will read two numbers: N_theta and N_phi.

              N_theta -- number of "theta" points in the interval (0, pi/2) (i.e. on the Z axis ) (Default 12)
              N_phi   -- number of  "phi"  points in the interval (0, 2*pi).(i.e. on the equator) (Default 24)

              The number of directions over which the actual averaging will take place is roughly the product of N_theta and N_phi.
              </HELP>
              </KEYWORD>

:kword:`TEXP`
  This keyword allows computation of the magnetic susceptibility :math:`\chi T(T)` at experimental points.
  On the line below the keyword, the number of experimental points :math:`N_T` is defined, and on the next :math:`N_T` lines the program reads the experimental temperature (in K) and the experimental magnetic susceptibility (in :math:`\text{cm}^3\text{K}\text{mol}^{-1}`). :kword:`TEXP` and :kword:`TINT` keywords are mutually exclusive. The magnetic susceptibility routine will also print the standard deviation from the experiment.

  ::

    TEXP
       READ  number-of-T-points
       Do i=1, number-of-T-points
          READ ( susceptibility(i, Temp), TEMP = 1, number-of-T-points )
       End Do

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="TEXP" KIND="REALS_COMPUTED" SIZE="2" LEVEL="BASIC">
              %%Keyword: TEXP <basic>
              <HELP>
              This keyword allows computation of the magnetic susceptibility at experimental
              temperature points. On the line below the keyword, the number of experimental
              points NT is defined, and on the next NT lines the program reads the experimental
              temperature (in K) and the experimental magnetic susceptibility (in cm^3 K mol^-1).
              TEXP and TINT keywords are mutually exclusive. The POLY_ANISO will also print the
              standard deviation from the experiment.
              </HELP>
              </KEYWORD>

:kword:`HEXP`
  This keyword allows computation of the molar magnetization :math:`M_{\text{mol}} (H)` at experimental points.
  On the line below the keyword,the number of experimental points :math:`N_H` is defined, and on the next :math:`N_H` lines the program reads the experimental field intensity (tesla) and the experimental magnetization (in :math:`\mu_{\text{Bohr}}`). :kword:`HEXP` and :kword:`HINT` are mutually exclusive. The magnetization routine will print the standard deviation from the experiment.

  ::

    HEXP
       READ  number-of-T-points-for-M,  all-T-points-for-M-in-K
       READ  number-of-field-points
       Do i=1, number-of-field-points
          READ ( Magn(i, iT), iT=1, number-of-T-points-for-M )
       End Do

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="HEXP" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: HEXP <basic>
              <HELP>
              This keyword allows computation of the molar magnetization at experimental field points.
              On the line below the keyword,the number of experimental points NH is defined, and on
              the next NH lines the program reads the experimental field strength (tesla) and the
              experimental magnetization (in Bohr magnetons). HEXP and HINT are mutually exclusive.
              The POLY_ANISO will print the standard deviation from the experiment.
              </HELP>
              </KEYWORD>

:kword:`ZJPR`
  This keyword specifies the value (in :math:`\text{cm}^{-1}`) of a phenomenological parameter of a mean molecular field acting on the spin of the complex (the average intermolecular exchange constant). It is used in the calculation of all magnetic properties (not for spin Hamiltonians) (Default is 0.0)

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ZJPR" KIND="REAL" LEVEL="BASIC">
              %%Keyword: ZJPR <basic>
              <HELP>
              This keyword specifies the value (in cm^-1) of a phenomenological parameter of a
              mean molecular field acting on the spin of the complex (the average intermolecular
              exchange constant). It is used in the calculation of all magnetic properties (not for
              spin Hamiltonians) (Default is 0.0)
              </HELP>
              </KEYWORD>

:kword:`ABCC`
  This keyword will enable computation of magnetic and anisotropy axes in the
  crystallographic :math:`abc` system. On the next line, the program will read six real
  values, namely :math:`a`, :math:`b`, :math:`c`, :math:`\alpha`, :math:`\beta`, and :math:`\gamma`, defining the
  crystal lattice. On the second line, the program will read the Cartesian coordinates
  of the magnetic center. The computed values in the output correspond to the
  crystallographic position of three "dummy atoms" located on the corresponding anisotropy axes, at the distance of 1 ångström from the metal site. ::

    ABCC
    20.17   19.83   18.76    90  120.32  90
    12.329  13.872  1.234

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="ABCC" KIND="STRING" LEVEL="BASIC">
              %%Keyword: ABCC <basic>
              <HELP>
              This keyword will enable computation of magnetic and anisotropy axes in the
              crystallographic abc system. On the next line, the program will read six real
              values, namely (a, b, c, alpha, beta, and gamma), defining the crystal lattice.
              On the second line, the program will read the Cartesian coordinates of the
              magnetic center. The computed values in the output correspond to the crystallographic
              position of three "dummy atoms" located on the corresponding anisotropy axes, at the
              distance of 1.0 angstrom from the metal site.
              </HELP>
              </KEYWORD>

:kword:`XFIE`
  This keyword specifies the value (in :math:`\text{T}`) of applied magnetic field
  for the computation of magnetic susceptibility by :math:`\mathrm{d}M/\mathrm{d}H` and :math:`M/H` formulas.
  A comparison with the usual formula (in the limit of zero applied field) is provided.
  (Default is 0.0)

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="XFIE" KIND="REAL" LEVEL="BASIC">
              %%Keyword: XFIE <basic>
              <HELP>
              This keyword specifies the value (in tesla) of applied magnetic field
              for the computation of magnetic susceptibility by: dM/dH and M/H formulas.
              A comparison with the usual formula (in the limit of zero applied field) is provided.
              (Default is 0.0)
              </HELP>
              </KEYWORD>

:kword:`PRLV`
  This keyword controls the print level.

  .. container:: list

    2 --- normal. (Default)

    3 or larger (debug)

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="PRLV" KIND="INT" LEVEL="BASIC">
              %%Keyword: PRLV <basic>
              <HELP>
              This keyword controls the print level.

              2  -- normal. (Default)
              3+ -- (debug)
              </HELP>
              </KEYWORD>

:kword:`PLOT`
  This keyword will generate a few plots (png or eps format) via an interface to the linux program *gnuplot*.
  The interface generates a datafile, a gnuplot script and attempts execution of the script for generation of the image.
  The plots are generated only if the respective function is invoked. The magnetic susceptibility, molar magnetisation and blocking barrier (UBAR) plots are generated.
  The files are named: :file:`XT.dat`, :file:`XT.plt`, :file:`XT.png`, :file:`MH.dat`, :file:`MH.plt`, :file:`MH.png`, :file:`BARRIER_TME.dat`, :file:`BARRIER_ENE.dat`, :file:`BARRIER.plt` and :file:`BARRIER.png`.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="PLOT" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: PLOT <basic>
              <HELP>
              This keyword will generate a few plots (png or eps format) via an interface to the linux program "gnuplot".
              The interface generates a datafile, a gnuplot script and attempts execution of the script for generation of the image.
              The plots are generated only if the respective function is invoked. The magnetic susceptibility, molar magnetisation and blocking barrier (UBAR) plots are generated.
              The files are named: XT.dat, XT.plt, XT.png, MH.dat, MH.plt, MH.png, BARRIER_TME.dat, BARRIER_ENE.dat, BARRIER.plt and BARRIER.png.
              </HELP>
              </KEYWORD>

:kword:`OLDA`
  This keyword requests to use the old-formatted ANISOINPUT files produced by :program:`SINGLE_ANISO` run. Please make use of the new DATAFILE :file:`$Project.aniso` produced in any successful run of :program:`SINGLE_ANISO`.

  .. xmldoc:: <KEYWORD MODULE="POLY_ANISO" NAME="OLDA" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: OLDA <basic>
              <HELP>
              This keyword requests to use the old-formatted ANISOINPUT files produced by SINGLE_ANISO run.
              Please make use the new DATAFILE $Project.aniso produced in any successful run of SINGLE_ANISO.
              </HELP>
              </KEYWORD>

.. xmldoc:: </MODULE>
.. index::
   single: Program; Geo
   single: Geo

.. _UG\:sec\:geo:

:program:`geo` |extramark|
==========================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="GEO" ONSCREEN="HF,HF-GEOMETRY,CAS,CAS-GEOMETRY">
            %%Description:
            <HELP>
            The GEO module handles geometry optimization in
            constrained internal coordinates.
            </HELP>

.. _UG\:sec\:geo_description:

Description
-----------

The :program:`geo` module handles geometry optimization in constrained
internal coordinates :cite:`Vysotskiy:13`. The module is called automatically when the
emil command :kword:`> DO GEO` is used and should never be called
explicitly by the user. All input relevant for these type of geometry
optimization should be supplied in :program:`gateway` and all the relevant
keywords are described in detail in the manual section for :program:`gateway`.

The purpose of the :program:`geo` module is to perform geometry optimization of
several molecular fragments by keeping the fragments rigid and only optimize
their relative position. The xyz-file of each fragment is supplied to the
program by a separate :kword:`coord` input in :program:`gateway`. Internal
coordinates for the whole complex is then constructed and stored into the
file :file:`$project.zmt` of the
directory :file:`$GeoDir` which is a communication directory set up and
used by the :program:`geo` module. The internal coordinates are chosen so that
only a maximum of six coordinates link each fragment. All coordinates within
fragments are frozen and the optimization is only carried out for these
linking coordinates. The geometry optimization is performed using a numerical
gradient (and hessian if needed) and could in principle be used together
with any energy
relaxation method that is implemented into molcas. (Currently it only works
with :program:`scf`, :program:`mp2`, :program:`rasscf`, :program:`caspt2`,
:program:`chcc`, :program:`cht3`, and :program:`ccsdt` but it is very simply to extend
it to other modules.)

The module is intended to use in cases where one knows
the geometry of each fragment and do not expect it to change much during the
optimization.

.. compound::

  Note that it is often advantageous to run a GEO job in parallel. The number of
  processors (cores) required can be easily evaluated by the following formula:cite:`Vysotskiy:13`:

  .. math:: N_{\text{procs}} = 2 + \frac{N_{\text{var}}\left(N_{\text{var}}+3\right)}{2},

  where :math:`N_{\text{var}}` is the total number of active coordinates. In the simplest
  case of the :math:`N_{\text{frag}}` rigid polyatomic fragments, when only relative positions of fragments are
  going to be optimized, the :math:`N_{\text{var}}` parameter reads:

  .. math:: N_{\text{var}} = 6 N_{\text{frag}}

  In particular, for constrained two-fragment geometry optimization one needs 29 processes
  to run GEO job in a fully parallel manner.

Creating the z-matrix
.....................

The z-matrix is created by choosing the first atom in the xyz-file and put that
in top of the z-matrix file (the example is a methane dimer): ::

  H

The next atom is chosen as the closest atom not already in the z-matrix and in
the same fragment
as the first. The distance to the closest neighbor within the z-matrix is
calculated and written into the zmatrix: ::

  C
  H   1.104408  0                         1

The number zero means "do not optimize" and is appended to all coordinates
within fragments and the 1 at the right hand side keeps track of which
atom that were the closest neighbour. The next molecule is again chosen
as the one not in the z-matrix but in the fragment. The distance between
the third atom and its closest neighbour and the angle between the third
atom, the closest atom and the second closest atom with the second closest
in the middle is added. ::

  C
  H     1.104408 0                                 1
  H     1.104438 0   109.278819 0                  1   2

For the fourth atom a dihedral angle is added and after that all remaining atoms
only have coordinates related to three neighbors. When all the molecule in the
fragment has entered the z-matrix the closest atom in another fragment is taken
as the next atom. Neighbors to atoms in that fragment is chosen from the same
fragment if possible and then from the previous fragment. When two atoms from
the second fragment has been added the z-matrix looks like this: ::

  C
  H     1.104408 0                                 1
  H     1.104438 0   109.278819 0                  1   2
  H     1.104456 0   109.279688 0  -119.533195 0   1   2   3
  H     1.104831 0   109.663377 0   120.232913 0   1   2   3
  H     3.550214 1    75.534230 1  -133.506752 1   3   4   1
  C     1.104404 0    78.859588 1  -146.087839 1   7   3   3

Note that coordinates linking fragments have a 1 after and will be optimized
and that the last carbon has one neighbor within its own fragment and two
within the previous fragment.

There are two special exceptions to the rules described above. Firstly, if
it is possible neighboring atoms are chosen from non-hydrogen atoms. (When
linking an atom to neighbors, not when choosing the next line in the z-matrix.)
Secondly, dihedral angles are rejected if the angles between the three first or
the three last atoms are smaller than 3 degrees since very small angles makes
the dihedral ill-defined.

.. _UG\:sec\:geo_dependencies:

Dependencies
------------

The :program:`GEO` program requires that :program:`gateway` have been run with
either the keyword :kword:`geo` or :kword:`hyper` to setup internal
communication files.

.. _UG\:sec\:geo_files:

Files
-----

Input files
...........

Apart from the standard file :program:`Geo` will use the following input files.

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information.

:program:`Geo` will also use internal communication files in the directory
:file:`$GeoDir` described in more detail in the next section.

Geo communication files
.......................

When the emil command :kword:`> DO GEO` or the keywords zonl or zcon
are used a directory
:file:`$GeoDir` is created (by default in the input-directory:
:file:`$CurrDir/$Project.Geo`).
This directory
is used to store files related to geometry optimization and z-matrix generation.

.. class:: filelist

:file:`$project.zmt`
  The file with the z-matrix as described above.

:file:`general.info`
  A file used for storing general info about the geometry optimization, it is human readable with labels.
  The file is automatically setup by the program.

  example: ::

    Number of iterations:              3
    Number of atoms:                   8
    Number of internal coordinates:    6
    Internal Coordinates:
        2.159252   99.560213  123.714490   99.612396 -179.885031 -123.791319
    Displacement parameters:
        0.150000    2.500000    2.500000    2.500000    2.500000    2.500000
    Coordinate types:
    badadd

  Most of the lines are self-explanatory, coordinate-type is one character for each
  internal coordinate to optimize with b=bond, a=angle and d=dihedral, displacement
  parameters is the coordinates defined by hyper.

:file:`disp????.info`
  A file that contains all displaced coordinates. A new instance of the file is created automatically for each geometry step.

  example: ::

    disp0001.xyz 2.16485  99.52171 123.71483  99.57425 -179.88493 -123.79124
    disp0002.xyz 2.17548 101.22524 124.91941 100.50733 -179.12307 -123.14735
    disp0003.xyz 2.16485 101.22952 124.92244 100.50968 -179.12116 -123.14573
    disp0004.xyz 2.17145  98.46360 125.21123 100.73337 -178.93851 -122.99136

:file:`$project.disp????.energy`
  A one line file that simply state the current energy for the displacement.
  If several energies are calculated this will first contain a scf energy
  and is then updated with the mp2 value when that calculation is finished.
  The file is written by a small addition to the add-info files and currently
  collects energies from :program:`scf`, :program:`mp2`, :program:`rasscf`, :program:`caspt2`,
  :program:`chcc`, :program:`cht3`, and :program:`ccsdt`. If
  it should be used with new energy relaxation methods this must be added manually.

:file:`$project.final????.xyz`
  An xyz-file with coordinates for all fragments after XXXX geometry optimizations.
  This is just for the benefit of the user and should probably be replaced with the
  same output as created by slapaf, opt.xyz-file for optimized geometry and molden-file
  for history. Some internal history would still be needed for building more advanced
  geometry optimization algorithms and convergence criteria though.

:file:`$project.geo.molden`
  A molden file with information about the geometry optimization.
  The file could be browsed in molden or LUSCUS. The last
  energy-value is set to zero since the file cannot be created
  after the last energy calculation and need to be inserted by the user.

.. _UG\:sec\:geo_input:

Input
-----

The general input structure of a geo-calculation looks like this: ::

  &Gateway
  [keywords to modify fragment position (frgm,origin)]
  coord=fragment1.xyz
  ...
  coord=fragmentN.xyz
  [regular :program:`gateway` keywords + keywords to modify :program:`geo`]

  >> DO GEO
  &Seward
  [energy relaxation methods with any of their keywords]
  >> END DO

Both the keywords used to translate and rotate xyz-files (:kword:`frgm`
and :kword:`origin`) and the keyword to modify the behaviour of the optimization
(:kword:`hyper`, and :kword:`oldz`) is
described in more details in the :program:`gateway` section of the manual.

Here is an example input to calculate the relative orientation of two methane
molecules:

.. extractfile:: ug/GEO.input

  >> export GeoDir=$CurrDir/$Project.GEO
  &Gateway
  Coord=$MOLCAS/Coord/Methane1.xyz
  Coord=$MOLCAS/Coord/Methane2.xyz
  Group=c1
  basis=aug-cc-pVDZ
  hyper
  0.15 2.5 2.5

  >> Do Geo

  &Seward
  CHOLESKY HIGH

  &SCF

  &MP2

  >> End Do

In order to run the job above in a task-farm parallel mode,
one just needs to slightly modify the original input:

.. extractfile:: ug/GEO.TASKFARM.input

  *activating an TaskFarm's interface in GEO/HYPER
  >> export MOLCAS_TASK_INPUT=NEW
  *specifying number of cores/cpus available for parallel execution
  >> export MOLCAS_NPROCS=2
  >> export GeoDir=$CurrDir/$Project.GEO
  &Gateway
  Coord=$MOLCAS/Coord/Methane1.xyz
  Coord=$MOLCAS/Coord/Methane2.xyz
  Group=c1
  basis=aug-cc-pVDZ
  hyper
  0.15 2.5 2.5

  >> Do Geo

  &Seward
  CHOLESKY HIGH

  &SCF

  &MP2

  >> End Do

  *setting the TaskMode's execution model to MPP
  *each energy/displacement is computed in paralel
  *by using 2 cores
  >>> EXPORT MOLCAS_TASKMODE=1
  *actual execution of TaskFarm via EMIL
  >>> UNIX SERIAL $MOLCAS/sbin/taskfarm

.. xmldoc:: </MODULE>
.. index::
   single: Program; GUGACI
   single: GUGACI

.. _UG\:sec\:gugaci:

:program:`GUGACI`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

Description
-----------

.. xmldoc:: <MODULE NAME="GUGACI">
            %%Description:
            <HELP>
            The GUGACI program is used for Multi-Reference
            SDCI calculations. The code originates in an MRCI
            program by Zhenyi Wen and Yubin Wang, Zhenting Gan, Bingbing Suo
            Yibo Lei also contribute to this program.
            It requires a file generated by the GUGADRT program.
            </HELP>

The
:program:`GUGACI`
program :index:`generates <single: Coupling coefficients; GUGACI>` :index:`Multi Reference <single: Multireference; SDCI>` :index:`SDCI <single: SDCI; using GUGACI>`
wavefunctions. The program is
based on the :index:`Direct CI <single: Direct CI>` method :cite:`Roos:72`,
and with distict row table generated by :program:`GUGADRT`
(See program description for
:program:`GUGADRT`). The hole-particle symmetry based on GUGA is used
in :program:`GUGACI` :cite:`YBWang:1,BSuo:1`.
If requested, :program:`GUGACI` computes matrix elements of those
one-electron properties for which it can find integrals in the
:file:`ONEINT` file. It also
generates natural orbitals that can be fed into
the property program to evaluate certain one electron properties.
The natural orbitals are also useful for Iterated Natural Orbital
(:index:`INO`) calculations.

The :program:`GUGACI` code is written by Yubin Wang,
Zhenyi Wen, Zhenting Gan, Bingbing Suo and Yibo Lei
(Institute of Modern Physics, Northwest University, China).

The program can calculate several eigenvectors simultaneously.

Orbital subspaces
.................

The orbital space is divided into the following subspaces: Frozen,
Inactive, Active, Secondary, and Deleted orbitals. Within each
symmetry type, they follow this order.

* **Frozen:**
  :index:`Frozen orbitals <single: GUGACI; Frozen>` are always doubly
  occupied, i.e., they are not correlated. Orbitals should be frozen
  already in the integral transformation step, program
  :program:`MOTRA`, and need not be specified in the input to the
  :program:`GUGACI` program. If it's specified, it will be ignored.

* **Inactive:**
  :index:`Inactive orbitals <single: GUGACI; Inactive>` are doubly occupied
  in all reference configurations, but excitations out of this orbital
  space are allowed in the final CI wavefunction, i.e., they are
  correlated but have two electrons in all reference configurations.

* **Active:**
  :index:`Active orbitals <single: GUGACI; Active>` are those which may have
  different occupation in different reference configurations.

* **Secondary:**
  :index:`This subspace <single: GUGACI; Secondary>` is empty in all
  reference configurations, but may be populated with up to two
  electrons in the excited configurations. This subspace is not
  explicitly specified, but consists of the orbitals which are left over
  when other spaces are accounted for.

* **Deleted:**
  :index:`This orbital subspace <single: GUGACI; Deleted>` does not
  participate in the CI wavefunction at all. Typically the 3s,4p,...
  components of 3d,4f,..., or orbitals that essentially describe core
  correlation, are deleted. Similar to freezing, deleting should be done in
  :program:`MOTRA`,
  which is more efficient, and do not need to be specified in the
  :program:`GUGACI` program.

Since ordinarily the frozen and deleted orbitals were handled by
:program:`MOTRA`
and the subdivision into inactive and
active orbitals were defined in
:program:`GUGADRT`, program :program:`GUGACI` will neglect them.

.. index::
   pair: Dependencies; GUGACI

.. _UG\:sec\:gugaci_dependencies:

Dependencies
------------

The program needs the distict row table generated by the program
:program:`GUGADRT` and transformed one- and two-electron integrals
generated by the program
:program:`MOTRA`.

.. index::
   pair: Files; GUGACI

.. _UG\:sec\:gugaci_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`GUGADRT`
  Distict row table from :program:`GUGADRT`.

:file:`TRAINT*`
  Transformed two-electron integrals from :program:`MOTRA`.

:file:`TRAONE`
  Transformed one-electron integrals from :program:`MOTRA`.

:file:`ONEINT`
  One-electron property integrals from :program:`SEWARD`.

:file:`MRCIVECT`
  Used for input only in restart case.

Output files
............

.. class:: filelist

:file:`CIORBnn`
  One or more sets of natural orbitals, one for each CI root, where
  nn stands for 01,02, etc.

:file:`CIVECT`
  CI vector, for later restart.

.. :file:`CIORBnn`
     only the first will be defined as default,
     with the FORTRAN file name

   :file:`CIORB`
     used for

   :file:`CIORB01`
     ..

Note that these file names are the FORTRAN file names used by the program,
so they have to be mapped to the actual file names. This is usually done
automatically in the |molcas| system. However, in the case of several
different numbered files

Local files
...........

.. class:: filelist

:file:`FTxxF01`
  :program:`MRCI` produces a few scratch files that are not needed by any other program
  in |molcas|. Presently, these are xx=14, 15, 16, 21, 25, 26, 27, and 30.
  The files are opened, used, closed and removed automatically.
  See source code for further information.

.. index::
   pair: Input; GUGACI

.. _UG\:sec\:gugaci_input:

Input
-----

This section describes the input to the
:program:`GUGACI` program in the |molcas| program system, with
the program name: ::

  &GUGACI

.. index::
   pair: GUGACI; Keywords

Keywords
........

The first four characters are decoded and the rest are ignored.

.. class:: keywordlist

:kword:`TITLe`
  The lines following this keyword are treated as title lines, until
  another keyword is encountered. A maximum of ten lines is allowed.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              <HELP>
              Enter at most ten lines of arbitrary title. Do not use any keywords
              as the first characters of each line.
              </HELP>
              %%Keyword: Title <basic>
              Followed by title lines, until the next keyword is recognized.
              </KEYWORD>

:kword:`NRROots`
  Specifies the number of CI roots (states) to be simultaneously
  optimized. The default is 1. The value is read from the next line.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="NRROOTS" APPEAR="Number of states" KIND="INT" LEVEL="BASIC">
              %%Keyword: NRRoots <basic>
              <HELP>
              The number of CI roots (states) to be computed. Default=1.
              </HELP>
              </KEYWORD>

:kword:`RESTart`
  Restart the calculation from a previous calculation. No additional
  input is required. The :file:`MRCIVECT` file is required for restarted
  calculations.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="RESTART" APPEAR="Restart CI calculation" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Restart <advanced>
              <HELP>
              Use a previous wavefunction from the MRCIVECT file as start approximation.
              </HELP>
              Require MRCISD calculation is restarted. MRCIVEC file should be exists.
              </KEYWORD>

:kword:`THRPrint`
  Threshold for printout of the wavefunction. All configurations with a
  coefficient greater than this threshold are printed.
  The default is 0.05. The value is read from the line
  following the keyword.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="THRPRINT" APPEAR="Threshold for printing CFSs" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: Thrprint <advanced>
              <HELP>
              Enter threshold of CI coefficients to be printed. Default 0.05.
              </HELP>
              </KEYWORD>

:kword:`CONvergence`
  Energy convergence threshold. The result is converged when the energy
  of all roots has been lowered less than this threshold in the last
  iteration. The default is 1.0d-8. The value is read from the line
  following the keyword.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="CONVERGENCE" APPEAR="Convergence threshold" KIND="REALS" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: Convergence <advanced>
              <HELP>
              Three float numbers to enter energy, ci vector, and residual vector
              convergence threshold. Default 1.0D-8,1.0D-6,1.0D-8
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  Print level of the program. Default is 5. The value is read from the
  line following the keyword.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="PRINT" APPEAR="Print control" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: Print <advanced>
              <HELP>
              Set print level. Default is 5.
              </HELP>
              </KEYWORD>

:kword:`MAXIterations`
  Maximum number of iterations. Default 20. The
  value is read from the line following the keyword.
  The maximum possible value is 200.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="MAXITERATIONS" APPEAR="Maximum number of CI iterations" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: Maxiterations <advanced>
              <HELP>
              Set maximum number of iterations. Default is 30. Largest possible is 200.
              </HELP>
              </KEYWORD>

:kword:`PRORbitals`
  Threshold for printing natural orbitals. Only orbitals with occupation
  number larger than this threshold appears in the printed output. The
  value is read from the line following the keyword.
  Default is 1.0d-5.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="PRORBITALS" APPEAR="Threshold for printing natural orbitals" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: Prorbitals <advanced>
              <HELP>
              Threshold on occupation number, for printing natural orbitals. Default 1.0D-5.
              </HELP>
              </KEYWORD>

:kword:`CPROperty`
  Request to calculate properties. Property integrals should be saved in file :file:`ONEINT`.

  .. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="CPROPERTY" APPEAR="Calculate properties" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Cproperty <advanced>
              <HELP>
              Request to calculate properties.
              </HELP>
              </KEYWORD>

Input example
.............

::

  &GUGACI
  Title
   Water molecule. 1S frozen in transformation.
  Nrroots
   1

.. xmldoc:: <KEYWORD MODULE="GUGACI" NAME="PTHR" KIND="REAL" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; Guessorb
   single: Guessorb

.. _UG\:sec\:guessorb:

:program:`guessorb`
===================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:guessorb_description:

Description
-----------

.. xmldoc:: <MODULE NAME="GUESSORB">
            %%Description:
            <HELP>
            The GUESSORB program generates a start guess for orbitals.
            These orbitals can be used as input for all wavefunction code.
            </HELP>

The :program:`GUESSORB` program generates a start guess for orbitals.
The file :file:`GSSORB` is created containing these orbitals.
They are also put to the runfile and their presence is automatically
detected by the programs :program:`SCF` and :program:`RASSCF`
if needed.

.. _UG\:sec\:guessorb_dependencies:

Dependencies
------------

The :program:`GUESSORB` program requires that the one electron
file :file:`ONEINT` as well as the communication file
:file:`RUNFILE` exist. These are generated by the program :program:`SEWARD`

.. index::
   pair: Files; Guessorb

.. _UG\:sec\:guessorb_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`GUESSORB`.

Input files
...........

:program:`GUESSORB` will use the following input
files: :file:`ONEINT`, :file:`RUNFILE`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist

:file:`GSSORB`
  :program:`GUESSORB` orbital output file.
  Contains a start guess for orbitals.

:file:`RUNFILE`
  Communication file for subsequent programs.

:file:`MD_GSS`
  Molden input file for molecular orbital analysis.

.. index::
   pair: Input; Guessorb

.. _UG\:sec\:guessorb_input:

Input
-----

Below follows a description of the input to :program:`GUESSORB`.

Keywords
........

.. class:: keywordlist

:kword:`PRMO`
  This keyword will make :program:`Guessorb` print the orbitals that are
  generated. On the next line an integer is to be specified that controls
  how much output you get, see below. On the same line you can optionally specify
  a floating point number that control how many orbitals are printed.
  Only orbitals with orbital energy less than this number will be printed,
  default is 5.0 au.

  * 1 --- Only occupation numbers and orbital energies are printed.
  * 2 --- As for 1 but with an additional sorted list of orbital energies.
  * 3 --- As for 2 but with orbitals printed in compact format.
  * 4 --- As for 3 but orbitals are printed in full format.

  .. xmldoc:: <KEYWORD MODULE="GUESSORB" NAME="PRMO" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: PRMO <basic>
              <HELP>
              Print the generated orbitals, an integer controls the output level.
              Optionally, a floating point number limits the orbitals printed to
              those with energy below the number (default 5.0 au).

              1 -- Only occupation numbers and orbital energies are printed.
              2 -- As for 1 but with an additional sorted list of orbital energies.
              3 -- As for 2 but with orbitals printed in compact format.
              4 -- As for 3 but orbitals are printed in full format.
              </HELP>
              </KEYWORD>

:kword:`PRPOpulation`
  This keyword will print a Mulliken population analysis based on the
  assumptions guessorb make with regards to populating orbitals.

  .. xmldoc:: <KEYWORD MODULE="GUESSORB" NAME="PRPO" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: PRPOpulation <basic>
              <HELP>
              Prints Mulliken population analysis.
              </HELP>
              </KEYWORD>

:kword:`STHR`
  This keyword controls how many orbitals will be deleted.
  On the next line you specify a threshold that have the default :math:`10^{-9}`.
  The overlap matrix is diagonalized and only eigenvectors
  with eigenvalues larger that this threshold will be used,
  the other will be deleted.
  This removes near linear dependence.

  .. xmldoc:: <KEYWORD MODULE="GUESSORB" NAME="STHR" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1e-9">
              %%Keyword: STHR <basic>
              <HELP>
              Threshold for deleting orbitals based on overlap. Default 1e-9.
              </HELP>
              </KEYWORD>

:kword:`TTHR`
  This keyword controls how many orbitals will be deleted.
  On the next line you specify a threshold that have the default :math:`10^6`.
  The kinetic energy matrix is diagonalized in the space
  of virtual orbitals and only orbitals with energies below
  this threshold is used, the other will be deleted.
  This removes degrees of freedom describing core correlation.

  .. xmldoc:: <KEYWORD MODULE="GUESSORB" NAME="TTHR" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1e6">
              %%Keyword: TTHR <basic>
              <HELP>
              Threshold for deleting orbitals based on kinetic energy. Default 1e6.
              </HELP>
              </KEYWORD>

:kword:`GAPThr`
  This keyword controls how guessorb attempt to populate
  the orbitals.
  On the next line a threshold is specified that have
  the default 0.01.
  Using this threshold guessorb will make a closed shell
  configuration if it can find a HOMO/LUMO gap that is larger
  than the specified threshold.
  If that can not be done, guessorb will place a number of orbitals
  in an active space in such a way that the gap between the
  three spaces (inactive, active and secondary) will be
  larger than the threshold.

  .. xmldoc:: <KEYWORD MODULE="GUESSORB" NAME="GAPT" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.01">
              %%Keyword: GAPThr <basic>
              <HELP>
              Threshold for populating orbitals. Default 0.01.
              </HELP>
              </KEYWORD>

:kword:`END of input`
  ..

Input examples
..............

In this example :program:`Guessorb` is used to produce
a Mulliken population based on assumptions that are made for
population of orbitals. ::

  &GUESSORB
  PrPopulation

In this example :program:`Guessorb` is used to construct
an active space for :program:`RASSCF` if there are
near degeneracies around the fermi level.
The orbital file that is produced can be fed directly
into :program:`RASSCF` without specifying the active space. ::

  &GUESSORB
  GapThr = 0.5

  &RASSCF
  LumOrb

.. xmldoc:: </MODULE>
.. index::
   single: Program; VibRot
   single: VibRot

.. _UG\:sec\:vibrot:

:program:`vibrot`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="VIBROT">
            %%Description:
            <HELP>
            This program computes the vibrational-rotational spectrum of a
            diatomic molecule. In addition, spectroscopic constants are computed.
            The program can also compute transition probabilities and lifetimes
            for excited states.
            </HELP>

The program :program:`VIBROT` is used to compute a vibration-rotation
spectrum for a diatomic molecule, using as input a potential
computed over a grid. The grid should be dense around equilibrium (recommended
spacing 0.05 au) and should extend to large distance (say 50 au) if
dissociation energies are computed.

The potential is fitted to an analytical form using cubic splines. The
ro-vibrational Schrödinger equation is then solved numerically
(using Numerov's method) for one vibrational state at a time and for a
number of rotational quantum numbers as specified by input. The
corresponding wave functions are stored on file
:file:`VIBWVS` for later use. The ro-vibrational energies
are analyzed in terms of spectroscopic constants. Weakly bound potentials can be
scaled for better numerical precision.

The program can also be fed with property functions, such as a dipole moment
curve. Matrix elements over the ro-vib wave functions for the property in
question are then computed. These results can be used to compute IR
intensities and vibrational averages of different properties.

:program:`VIBROT` can also be used to compute transition properties between
different electronic states. The program is then run twice to produce two files
of wave functions. These files are used as input in a third run, which will
then compute transition matrices for input properties. The main use is to
compute transition moments, oscillator strengths, and lifetimes for ro-vib
levels of electronically excited states. The asymptotic energy difference
between the two electronic states must be provided using the :kword:`ASYMptotic`
keyword.

.. index::
   pair: Dependencies; VibRot

.. _UG\:sec\:vibrot_dependencies:

Dependencies
------------

The :program:`VIBROT` is free-standing and does not depend on any
other program.

.. index::
   pair: Files; VibRot

.. _UG\:sec\:vibrot_files:

Files
-----

Input files
...........

The calculation of vibrational wave functions and spectroscopic
constants uses no input files (except for the standard input).
The calculation of transition properties uses
:file:`VIBWVS` files from two preceding
:program:`VIBROT` runs, redefined as
:file:`VIBWVS1` and
:file:`VIBWVS2`.

Output files
............

:program:`VIBROT` generates the file
:file:`VIBWVS` with vibrational wave functions for each :math:`v` and :math:`J` quantum
number, when run in the wave function mode. If requested :program:`VIBROT` can
also produce files :file:`VIBPLT` with the fitted potential and property
functions for later plotting.

.. index::
   pair: Input; VibRot

.. _UG\:sec\:vibrot_input:

Input
-----

This section describes the input to the :program:`VIBROT` program in the
|molcas| program system. The program name is ::

  &VIBROT

.. index::
   pair: Keywords; VibRot

Keywords
........

The first keyword to
:program:`VIBROT` is an indicator for the type of calculation
that is to be performed. Two possibilities exist:

.. class:: keywordlist

:kword:`ROVIbrational spectrum`
  :program:`VIBROT` will perform a vib-rot analysis and compute
  spectroscopic constants.

  .. xmldoc:: <SELECT MODULE="VIBROT" NAME="TYPE" APPEAR="Calculation type" CONTAINS="ROVIB,TRANS">

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ROVIB" APPEAR="Start vib-rot analysis" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="TRANS">
              %%Keyword: ROVIbrational <basic>
              <HELP>
              Perform a vib-rot analysis and compute spectroscopic constants.
              </HELP>
              </KEYWORD>

:kword:`TRANsition moments`
  :program:`VIBROT` will compute transition moment integrals
  using results from two previous calculations of the vib-rot wave
  functions. In this case the keyword :kword:`Observable` should be
  included, and it will be interpreted as the transition dipole moment.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="TRANS" APPEAR="Compute transition moments" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="ROVIB">
              %%Keyword: TRANsition <basic>
              <HELP>
              Compute transition moment integrals using previous vib-rot wave
              functions.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

Note that only one of the above keywords can be used in a single
calculation. If none is given the program will only process the input
section.

After this first keyword follows a set of keywords, which are used to
specify the run. Most of them are optional.

The compulsory keywords are:

.. class:: keywordlist

:kword:`ATOMs`
  Gives the mass of the two atoms. Write mass number (an integer) and the
  chemical symbol Xx, in this order, for each of the two atoms in free format. If
  the mass numbers is zero for any atom, the mass of the most abundant isotope
  will be used. All isotope masses are stored in the program. You may introduce
  your own masses by giving a negative integer value to the mass number (one of
  them or both). The masses (in unified atomic mass units, or Da) are then read
  on the next (or next two) entry(ies). The isotopes of hydrogen can be given as
  H, D, or T.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ATOMS" APPEAR="The two atoms" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: ATOMs <basic>
              <HELP>
              Read the mass number and chemical symbol of the atoms from the next line.
              If the mass number is zero the mass of the most abundant isotope will be
              used. Use a negative mass number to input the mass (in unified atomic mass
              units) in the next entry.
              </HELP>
              </KEYWORD>

:kword:`POTEntial`
  Gives the potential as an arbitrary number of lines. Each line
  contains a bond distance (in au) and an energy value (in au). A plot file of the
  potential is generated if the keyword
  :kword:`Plot` is added after the last energy input. One more entry should then follow
  with three numbers
  specifying the start and end value for the internuclear distance and
  the distance between adjacent plot points. This input must only be
  given together with the keyword :kword:`RoVibrational spectrum`.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="POTE" APPEAR="Potential" KIND="CUSTOM" LEVEL="BASIC">
              <ALTERNATE KIND="STRING" />
              %%Keyword: POTEntial <basic>
              <HELP>
              Read the potential from a file (in au). Format: distance, value one pair on
              each line. Only together with vib-rot calculation.
              </HELP>
              </KEYWORD>

In addition you may want to specify some of the following optional
input:

.. class:: keywordlist

:kword:`TITLe`
  One single title line

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              One single title line
              </HELP>
              </KEYWORD>

:kword:`GRID`
  The next entries give the number of grid points used in the numerical
  solution of the radial Schrödinger equation. The default value is
  199. The maximum value that can be used is 4999.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="GRID" APPEAR="Numerical grid" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="199" MIN_VALUE="1" MAX_VALUE="4999">
              %%Keyword: GRID <basic>
              <HELP>
              Give the number of numerical grid points (default is 199, max is 4999).
              </HELP>
              </KEYWORD>

:kword:`RANGe`
  The next entry contains two distances Rmin and Rmax (in au) specifying
  the range in which the vibrational wave functions will be computed.
  The default values are 1.0 and 5.0 au. Note that these values most
  often have to be given as input since they vary considerably from one
  case to another. If the range specified is too small, the program will
  give a message informing the user that the vibrational wave function
  is large outside the integration range.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="RANGE" APPEAR="Integration range" KIND="REALS" SIZE="2" LEVEL="BASIC" DEFAULT_VALUES="1.0,5.0">
              %%Keyword: RANGe <basic>
              <HELP>
              Give the range (Rmin-Rmax) in which the wave functions will be computed
              in atomic units. Default is 1.0-5.0 au.
              </HELP>
              </KEYWORD>

:kword:`VIBRational`
  The next entry specifies the number of vibrational quanta for which the
  wave functions and energies are computed. Default value is 3.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="VIBR" APPEAR="Vibrational quanta" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="3" MIN_VALUE="1">
              %%Keyword: VIBRational <basic>
              <HELP>
              Specify the number of vibrational quanta (default is 3).
              </HELP>
              </KEYWORD>

:kword:`ROTAtional`
  The next entry specifies the range of rotational quantum numbers.
  Default values are 0 to 5. If the orbital angular momentum quantum
  number (:math:`m_\ell`) is non zero, the lower value will be adjusted to
  :math:`m_\ell` if the start value given in input is smaller than
  :math:`m_\ell`.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ROTA" APPEAR="Rotational quanta" KIND="INTS" SIZE="2" LEVEL="BASIC" DEFAULT_VALUES="0,5" MIN_VALUE="0">
              %%Keyword: ROTAtional <basic>
              <HELP>
              Specify the range of rotational quantum numbers (default is 0-5).
              </HELP>
              </KEYWORD>

:kword:`ORBItal`
  The next entry specifies the value of the orbital angular momentum
  (0, 1, 2, etc.). Default value is zero.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ORBI" APPEAR="Orbital angular momentum" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: ORBItal <basic>
              <HELP>
              Specify the orbital angular momentum:, 0, 1, 2, ... (default is 0).
              </HELP>
              </KEYWORD>

:kword:`SCALe`
  This keyword is used to scale the potential, such that the
  binding energy is 0.1 au. This leads to better precision in the numerical
  procedure and is strongly advised for weakly bound potentials.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="SCALE" APPEAR="Scaled potential" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: SCALe <basic>
              <HELP>
              The potential will be scaled to a bond energy of 0.1 au.
              </HELP>
              </KEYWORD>

:kword:`NOSPectroscopic`
  Only the wave function analysis will be carried out but not the
  calculation of spectroscopic constants.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="NOSP" APPEAR="No spectroscopic constants" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NOSPectroscopic <advanced>
              <HELP>
              No calculation of spectroscopic constants.
              </HELP>
              </KEYWORD>

:kword:`OBSErvable`
  This keyword indicates the start of input for radial functions of observables
  other than the energy, for example the dipole moment function. The next line
  gives a title for this observable. An arbitrary number of input lines follows.
  Each line contains a distance and the corresponding value for the observable.
  As for the potential, this input can also end with the keyword :kword:`Plot`,
  to indicate that a file of the function for later plotting is to be constructed.
  The next line then contains the minimum and maximum R-values and the
  distance between adjacent points. When this input is given with the top keyword
  :kword:`RoVibrational spectrum` the program will compute matrix elements for
  vibrational wave functions of the current electronic state. Transition moment
  integrals are instead obtained when the top keyword is :kword:`Transition
  moments`. In the latter case the calculation becomes rather meaningless if
  this input is not provided. The program will then only compute the overlap
  integrals between the vibrational wave functions of the two states.
  The keyword :kword:`Observable` can be repeated up to ten times in a
  single run. All observables should be given in atomic units.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="OBSE" APPEAR="Observable" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: OBSErvable <basic>
              <HELP>
              Input for radial functions of observables (in au). The input is read from a
              file. The user is asked to read the users guide to learn how to construct
              this file.
              </HELP>
              </KEYWORD>

:kword:`TEMPerature`
  The next entry gives the temperature (in K) at which the vibrational
  averaging of observables will be computed. The default is 300 K.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="TEMP" APPEAR="Temperature" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="300.0" MIN_VALUE="0.0">
              %%Keyword: TEMPerature <advanced>
              <HELP>
              Temperature for vibrational averaging of observables (default is 300 K).
              </HELP>
              </KEYWORD>

:kword:`STEP`
  The next entry gives the starting value for the energy step used in
  the bracketing of the eigenvalues. The default value is 0.004 au
  (88 :math:`\text{cm}^{-1}`). This value must be smaller than the
  zero-point vibrational energy of the molecule.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="STEP" APPEAR="Numerical step size" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.004" MIN_VALUE="0.0">
              %%Keyword: STEP <advanced>
              <HELP>
              Give the starting value for the energy step used in bracketing eigenvalues.
              Should be smaller than the zero point energy (default is 0.004 au).
              </HELP>
              </KEYWORD>

:kword:`ASYMptotic`
  The next entry specifies the asymptotic energy difference between
  two potential curves in a calculation of transition matrix elements.
  The default value is zero atomic units.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ASYM" APPEAR="Asymptotic energy difference" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.0">
              %%Keyword: ASYMptotic <basic>
              <HELP>
              Specify the asymptotic energy difference between two potential curves in a
              calculation of transition matrix elements (default is 0.00 au).
              </HELP>
              </KEYWORD>

:kword:`ALLRotational`
  By default, when the :kword:`Transition moments` keyword is given, only the
  transitions between the lowest rotational level in each vibrational state are
  computed. The keyword :kword:`AllRotational` specifies that the transitions
  between all the rotational levels are to be included. Note that this may result
  in a very large output file.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="ALLR" APPEAR="All rotational levels" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: ALLRotational <advanced>
              <HELP>
              Include all rotational levels in a transition moments calculation.
              </HELP>
              </KEYWORD>

:kword:`PRWF`
  Requests the vibrational wave functions to be printed in the output file.

  .. xmldoc:: <KEYWORD MODULE="VIBROT" NAME="PRWF" APPEAR="Print wave functions" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PRWF <advanced>
              <HELP>
              Requests the vibrational wave functions to be printed.
              </HELP>
              </KEYWORD>

Input example
.............

::

  &VIBROT
  RoVibrational spectrum
  Title = Vib-Rot spectrum for FeNi
  Atoms = 0 Fe 0 Ni
  Potential
   1.0 -0.516768
   1.1 -0.554562
   [...]
  Plot  = 1.0 10.0 0.1
  Grid  = 150
  Range = 1.0 10.0
  Vibrations = 10
  Rotations  = 2 10
  Orbital    = 2
  Observable
   Dipole Moment
   1.0 0.102354
   1.1 0.112898
   [...]
  Plot  = 1.0 10.0 0.1

**Comments**: The vibrational-rotation spectrum for :math:`\ce{FeNi}`
will be computed using the potential curve given in input. The 10
lowest vibrational levels will be obtained and for each level the
rotational states in the range :math:`J`\=2 to 10. The vib-rot matrix elements
of the dipole function will also be computed. A plot file of the
potential and the dipole function will be generated. The masses for
the most abundant isotopes of :math:`\ce{Fe}` and :math:`\ce{Ni}` will be selected.

.. xmldoc:: </MODULE>
.. index::
   single: Program; LOCALISATION
   single: LOCALISATION

.. _UG\:sec\:localisation:

:program:`localisation`
=======================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:localisation_description:

Description
-----------

.. xmldoc:: <MODULE NAME="LOCALISATION">
            %%Description:
            <HELP>
            The LOCALISATION program of the molcas program system generates
            localised occupied orbitals according to one of the following procedures:
            Pipek-Mezey, Boys, Edmiston-Ruedenberg, or Cholesky.
            Orthonormal, linearly independent, local virtual orbitals may also be
            generated from projected atomic orbitals (Cholesky PAOs).
            </HELP>

The :program:`LOCALISATION` program of the |molcas| program system generates
localised occupied orbitals according to one of the following procedures:
Pipek--Mezey :cite:`Pipek:89`,
Boys :cite:`Boys:60,Foster:60`,
Edmiston--Ruedenberg :cite:`Edmiston:63`, or
Cholesky :cite:`Aquilante:06a`.
Orthonormal, linearly independent, local orbitals may also be
generated from projected atomic orbitals (Cholesky PAOs) :cite:`Aquilante:06a`.

.. compound::

  Orbital localisation makes use of the fact that a Hartree-Fock wave function
  is invariant under unitary transformations of the occupied orbitals,

  .. math:: \tilde{C}_{\mu i} = \sum_j C_{\mu j} \mat{U}_{ji} ,

  where :math:`\mat{U}` is unitary (i.e. orthogonal for real orbitals).
  The same is true for the inactive or active orbitals in a CASSCF wave function.
  Whereas the Pipek--Mezey :cite:`Pipek:89`,
  Boys :cite:`Boys:60,Foster:60`, and
  Edmiston--Ruedenberg :cite:`Edmiston:63` procedures define :math:`\mat{U}`
  through an iterative maximisation of a localisation functional,
  the Cholesky orbitals are simply defined through the Cholesky decomposition
  of the one-electron density, i.e.

  .. math:: \sum_i \tilde{C}_{\mu i}\tilde{C}_{\nu i} = P_{\mu\nu} = \sum_i C_{\mu i} C_{\mu i} .

  Cholesky orbitals are thus not optimum localised orbitals by any of the
  Pipek--Mezey, Boys, or Edmiston--Ruedenberg measures, but rather inherit locality
  from the density matrix, see :cite:`Aquilante:06a` for details.

Although these localisation schemes are mostly meant for localising occupied
orbitals (except for PAOs which are defined for the virtual orbitals), the
:program:`LOCALISATION` program will attempt to localise any set of orbitals
that the user specifies. This means that it is possible to mix
occupied and virtual orbitals and thereby break the Hartree--Fock
invariance. The default settings, however, do not break the invariance.

For Pipek--Mezey, Boys, and Edmiston--Ruedenberg localisations, iterative
optimisations are carried out. We use
the :math:`\eta`-steps of Subotnik *et al.* :cite:`Subotnik:04` for
Edmiston--Ruedenberg, whereas the traditional Jacobi sweeps (consecutive
two-by-two orbital rotations) :cite:`Pipek:89,Subotnik:04`
are employed for the Pipek--Mezey and Boys schemes.

.. _UG\:sec\:localisation_dependencies:

Dependencies
------------

The :program:`LOCALISATION` program requires the one-electron integral file
:file:`ONEINT` and the communications file :file:`RUNFILE`,
which contains, among other data, the
basis set specifications processed by :program:`GATEWAY` and :program:`SEWARD`.
In addition, the Edmiston--Ruedenberg procedure requires the presence
of Cholesky decomposed two-electron integrals produced by :program:`SEWARD`.

.. index::
   pair: Files; LOCALISATION

.. _UG\sec\:localisation_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`LOCALISATION`.

Input files
...........

:program:`LOCALISATION` will use the following input
files: :file:`ONEINT`, :file:`RUNFILE`, :file:`INPORB`.
For Edmiston--Ruedenberg localisation,
it also needs :file:`CHVEC`, :file:`CHRED` and :file:`CHORST` files
(for more information see :numref:`UG:sec:files_list`).

Output files
............

.. class:: filelist

:file:`LOCORB`
  Localised orthonormal orbital output file.
  Note that :file:`LOCORB` contains all orbitals (localised as well as non-localised
  according to the input specification).

:file:`DPAORB`
  Linearly dependent nonorthonormal projected atomic orbital output file
  (only produced for PAO runs).

:file:`IPAORB`
  Linearly independent nonorthonormal projected atomic orbital output file
  (only produced for PAO runs).

:file:`RUNFILE`
  Communication file for subsequent programs.

:file:`MD_LOC`
  Molden input file for molecular orbital analysis.

.. index::
   pair: Input; LOCALISATION

.. _UG\:sec\:localisation_input:

Input
-----

Below follows a description of the input to :program:`LOCALISATION`.
The :program:`LOCALISATION` program section of the |molcas| input is bracketed by
a preceding program reference ::

  &LOCALISATION

Optional general keywords
.........................

.. class:: keywordlist

:kword:`FILEorb`
  The next line specifies the filename containing the input orbitals that will
  be localised. By default a file named :file:`INPORB` will be used.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="FILE" APPEAR="Orbitals file" KIND="STRING" LEVEL="BASIC">
              %%Keyword: FileOrb <basic>
              <HELP>
              The next line specifies the filename containing the input orbitals that will
              be localised. By default a file named INPORB will be used.
              </HELP>
              </KEYWORD>

:kword:`NORBitals`
  The following line specifies the number of orbitals to localise in each
  irreducible representation. The default is to localise all occupied
  orbitals as specified in the :file:`INPORB` input file, except for PAO runs where
  all the virtual orbitals are treated by default.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="NORB" APPEAR="Number of orbitals" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM">
              <HELP>
              Please, specify the number of orbitals to localise in each irrep.
              </HELP>
              %%Keyword: NORB <basic>
              The following line specifies the number of orbitals to localise in each
              irreducible representation. The default is to localise all occupied
              orbitals as specified in the INPORB input file, except for PAO runs where
              all the virtual orbitals are treated by default.
              </KEYWORD>

:kword:`NFROzen`
  The following line specifies the number of orbitals to freeze in each
  irreducible representation. The default is not to freeze any orbitals,
  except for the localisations of the virtual space (see keywords :kword:`PAO` and
  :kword:`VIRTual`) where the default is to freeze all occupied orbitals (occupation
  number different from zero, as reported in the :file:`INPORB` file).

  .. xmldoc:: <SELECT MODULE="LOCALISATION" NAME="ORBITAL_FREEZE" APPEAR="Frozen orbitals selection" CONTAINS="NFROZEN,FREEZE">

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="NFROZEN" APPEAR="Orbitals to freeze" LEVEL="BASIC" KIND="INTS_LOOKUP" SIZE="NSYM" EXCLUSIVE="FREEZE">
              <HELP>
              Please, specify the number of orbitals to freeze in each irrep.
              </HELP>
              %%Keyword: NFRO <basic>
              The following line specifies the number of orbitals to freeze in each
              irreducible representation. The default is not to freeze any orbitals,
              except for the localisations of the virtual space (see keywords PAO and
              VIRTual) where the default is to freeze all occupied orbitals (occupation
              number different from zero, as reported in the INPORB file).
              </KEYWORD>

:kword:`FREEze`
  Implicit frozen core option. The default is not to freeze any orbitals,
  except for the localisations of the virtual space (see keywords :kword:`PAO` and
  :kword:`VIRTual`) where the default is to freeze all occupied orbitals (occupation
  number different from zero, as reported in the :file:`INPORB` file).
  The definition of core orbitals is taken from program :program:`SEWARD`.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="FREEZE" APPEAR="Freeze core orbitals" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="NFROZEN">
              <HELP>
              Freeze the core orbitals as defined by SEWARD.
              </HELP>
              %%Keyword: FREE <basic>
              Implicit frozen core option. The default is not to freeze any orbitals,
              except for the localisations of the virtual space (see keywords PAO and
              VIRTual) where the default is to freeze all occupied orbitals (occupation
              number different from zero, as reported in the INPORB file).
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`OCCUpied`
  Requests that the occupied orbitals should be localised. This is the default
  except for PAO where the default is virtual.

  .. xmldoc:: <SELECT MODULE="LOCALISATION" NAME="LOC_ORB" APPEAR="Orbitals to localise" CONTAINS="OCCU,VIRT,ALL">

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="OCCU" APPEAR="Localise occupied orbitals" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="VIRT,ALL">
              %%Keyword: OCCU <basic>
              <HELP>
              Requests that the occupied orbitals should be localised.
              </HELP>
              This is the default except for PAO where the default is virtual.
              </KEYWORD>

:kword:`VIRTual`
  Requests that the virtual orbitals should be localised. The default is
  to localise the occupied orbitals, except for PAO where the default is
  virtual.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="VIRT" APPEAR="Localise virtual orbitals" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="OCCU,ALL">
              %%Keyword: VIRT <basic>
              <HELP>
              Requests that the virtual orbitals should be localised.
              </HELP>
              The default is
              to localise the occupied orbitals, except for PAO where the default is
              virtual.
              </KEYWORD>

:kword:`ALL`
  Requests that all orbitals should be localised. The default is
  to localise the occupied orbitals, except for PAO where the default is
  virtual.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="ALL" APPEAR="Localise all orbitals" LEVEL="BASIC" KIND="SINGLE" EXCLUSIVE="OCCU,VIRT">
              %%Keyword: ALL <basic>
              <HELP>
              Requests that all orbitals should be localised.
              </HELP>
              The default is
              to localise the occupied orbitals, except for PAO where the default is
              virtual.
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`PIPEk-Mezey`
  Requests Pipek--Mezey localisation. This is the default.

  .. xmldoc:: <SELECT MODULE="LOCALISATION" NAME="LOC_METHODS" APPEAR="Localisation method" CONTAINS="PIPE,BOYS,EDMI,CHOL,PAO,SKIP">

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="PIPE" APPEAR="Pipek-Mezey" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="BOYS,EDMI,CHOL,PAO,SKIP">
              %%Keyword: PIPE <advanced>
              <HELP>
              Requests Pipek-Mezey localisation.
              </HELP>
              This is the default.
              </KEYWORD>

:kword:`BOYS`
  Requests Boys localisation. The default is Pipek--Mezey.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="BOYS" APPEAR="Boys-Forster" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="PIPE,EDMI,CHOL,PAO,SKIP">
              %%Keyword: BOYS <advanced>
              <HELP>
              Requests Boys localisation.
              </HELP>
              The default is Pipek-Mezey.
              </KEYWORD>

:kword:`EDMIston-Ruedenberg`
  Requests Edmiston--Ruedenberg localisation. The default is Pipek--Mezey.
  Note that this option requires that the Cholesky (or RI/DF) representation
  of the two-electron integrals has been produced by :program:`SEWARD`.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="EDMI" APPEAR="Edmiston-Ruedenberg" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="PIPE,BOYS,CHOL,PAO,SKIP">
              %%Keyword: EDMI <advanced>
              <HELP>
              Requests Edmiston-Ruedenberg localisation.
              </HELP>
              The default is Pipek-Mezey.
              Note that this option requires that the Cholesky (or RI/DF) representation
              of the two-electron integrals has been produced by SEWARD.
              </KEYWORD>

:kword:`CHOLesky`
  Requests Cholesky localisation (non-iterative). The default is Pipek--Mezey.
  This and PAO are the only options that can handle point group symmetry.
  The decomposition threshold is by default 1.0d-8 but may be changed
  through the :kword:`THREshold` keyword.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="CHOL" APPEAR="Cholesky" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="PIPE,BOYS,EDMI,PAO,SKIP">
              %%Keyword: CHOL <advanced>
              <HELP>
              Requests Cholesky localisation.
              </HELP>
              The default is Pipek-Mezey.
              </KEYWORD>

:kword:`PAO`
  Requests PAO localisation (non-iterative) using Cholesky decomposition
  to remove linear dependence.
  The default is Pipek--Mezey.
  This and Cholesky are the only options that can handle point group symmetry.
  The decomposition threshold is by default 1.0d-8 but may be changed
  through the :kword:`THREshold` keyword.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="PAO" APPEAR="PAO" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="PIPE,BOYS,EDMI,CHOL,SKIP">
              %%Keyword: PAO <advanced>
              <HELP>
              Requests PAO localisation.
              </HELP>
              The default is Pipek-Mezey.
              </KEYWORD>

:kword:`SKIP`
  Leaves the input orbitals unchanged. It is turned off by default.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="SKIP" APPEAR="None" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="PIPE,BOYS,EDMI,CHOL,PAO">
              %%Keyword: SKIP <advanced>
              <HELP>
              Leaves the input orbitals unchanged.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`ITERations`
  The following line specifies the maximum number of iterations to be
  used by the iterative localisation procedures. The default is 300.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="ITER" APPEAR="Iterations" LEVEL="ADVANCED" KIND="INT">
              <HELP>
              Please, specify the maximum number of iterations to be
              used by the iterative localisation procedures. The default is 300.
              </HELP>
              %%Keyword: ITER <advanced>
              The following line specifies the maximum number of iterations to be
              used by the iterative localisation procedures. The default is 100.
              </KEYWORD>

:kword:`THREshold`
  The following line specifies the convergence threshold used for
  changes in the localisation functional. The default is 1.0d-6.
  For Cholesky and PAO methods, it is the decomposition threshold and
  the default is 1.0d-8.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="THRE" APPEAR="Functional threshold" LEVEL="ADVANCED" KIND="REAL">
              <HELP>
              Please, specify the convergence threshold used for
              changes in the localisation functional (default: 1.0d-6)
              or the decomposition threshold (default: 1.0d-8).
              </HELP>
              %%Keyword: THRE <advanced>
              The following line specifies the convergence threshold used for
              changes in the localisation functional. The default is 1.0d-6.
              For Cholesky and PAO methods, it is the decomposition threshold and
              the default is 1.0d-8.
              </KEYWORD>

:kword:`THRGradient`
  The following line specifies the convergence threshold used for
  the gradient of the localisation functional. The default is 1.0d-2.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="THRG" APPEAR="Gradient threshold" LEVEL="ADVANCED" KIND="REAL">
              <HELP>
              Please, specify the convergence threshold used for
              changes in the gradient of the localisation functional. The default is 1.0d-2.
              </HELP>
              %%Keyword: THRG <advanced>
              The following line specifies the convergence threshold used for
              the gradient of the localisation functional. The default is 1.0d-2.
              </KEYWORD>

:kword:`THRRotations`
  The following line specifies the screening threshold used in
  the Jacobi sweep optimisation algorithm. The default is 1.0d-10.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="THRR" APPEAR="Screening threshold" LEVEL="ADVANCED" KIND="REAL">
              <HELP>
              Please, specify the convergence threshold used in
              the Jacobi sweep optimisation algorithm. The default is 1.0d-10.
              </HELP>
              %%Keyword: THRR <advanced>
              The following line specifies the screening threshold used in
              the Jacobi sweep optimisation algorithm. The default is 1.0d-10.
              </KEYWORD>

:kword:`CHOStart`
  Requests that iterative localisation procedures use Cholesky orbitals
  as initial orbitals. The default is to use the orbitals from
  :file:`INPORB` directly.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="CHOS" APPEAR="Cholesky guess" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: CHOS <advanced>
              <HELP>
              Requests that the localisation procedure uses Cholesky orbitals
              as initial orbitals.
              </HELP>
              The default is not to use Cholesky orbitals.
              </KEYWORD>

:kword:`ORDEr`
  Requests that the localised orbitals are ordered in the same way
  as the Cholesky orbitals would be. This is mainly useful when
  comparing orbitals from different localisation schemes. The
  ordering is done according to maximum overlap with the
  Cholesky orbitals. The default is not to order.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="ORDE" APPEAR="Orbital reordering" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: ORDE <advanced>
              <HELP>
              Requests that the localised orbitals are ordered in the same way
              as the Cholesky orbitals would be.
              </HELP>
              The default is not to order.
              </KEYWORD>

:kword:`DOMAin`
  Requests orbital domains and pair domains are set up and analysed.
  The default is not to set up domains.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="DOMA" APPEAR="Orbital and pair domains analysis" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: DOMA <advanced>
              <HELP>
              Requests orbital domains and pair domains are set up and analysed.
              </HELP>
              The default is not to set up domains.
              </KEYWORD>

:kword:`THRDomain`
  The following line specifies two thresholds to be used in defining
  orbital domains. The first is the Mulliken population threshold
  such that atoms are included in the domain until the population
  (divided by 2) is larger than this number (default: 9.0d-1).
  The second threshold is used for the Pulay completeness check of
  the domain (default: 2.0d-2).

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="THRD" APPEAR="Domain thresholds" LEVEL="ADVANCED" KIND="REALS" SIZE="2" REQUIRE="DOMA">
              <HELP>
              Please, specify two thresholds:
              The first is the Mulliken population threshold
              such that atoms are included in the domain (default: 9.0d-1).
              The second threshold is used for the Pulay completeness check of
              the domain (default: 2.0d-2).
              </HELP>
              %%Keyword: THRD <advanced>
              The following line specifies two thresholds to be used in defining
              orbital domains. The first is the Mulliken population threshold
              such that atoms are included in the domain until the population
              (divided by 2) is larger than this number (default: 9.0d-1).
              The second threshold is used for the Pulay completeness check of
              the domain (default: 2.0d-2).
              </KEYWORD>

:kword:`THRPairdomain`
  The following line specifies three thresholds to be used for
  classifying pair domains: R1, R2, and R3. (Defaults: 1.0d-10,
  1.0d1, and 1.5d1.)
  If R is the smallest distance
  between two atoms in the pair domain (union of the individual orbital
  domains), then pair domains are classified according to:
  R :math:`\leq` R1: strong pair,
  R1 :math:`<` R :math:`\leq` R2: weak pair,
  R2 :math:`<` R :math:`\leq` R3: distant pair, and
  R3 :math:`<` R: very distant pair.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="THRP" APPEAR="Pair domain threshold" LEVEL="ADVANCED" KIND="REALS" SIZE="3" REQUIRE="DOMA">
              <HELP>
              Please, specify three thresholds to be used for
              classifying pair domains: R1, R2, and R3. (Defaults: 1.0d-10,
              1.0d1, and 1.5d1.)
              </HELP>
              %%Keyword: THRP <advanced>
              The following line specifies three thresholds to be used for
              classifying pair domains: R1, R2, and R3. (Defaults: 1.0d-10,
              1.0d1, and 1.5d1.)
              </KEYWORD>

:kword:`LOCNatural orbitals`
  This keyword is used to select atoms for defining the localised natural
  orbitals (LNOs), thus a set of localised orbitals with well-defined occupation numbers.
  All other options specified in the :program:`LOCALISATION` program input apply (e.g., input orbitals,
  localisation method, etc.).
  On the next line give the number of atoms that identify the region of interest
  and the threshold used to select the localised orbitals belonging to this region
  (recommended values > 0.2 and < 1).
  An additional line gives the names of the (symmetry unique) atoms as defined in the :program:`SEWARD` input.
  The keyword :kword:`LOCN` is used to define suitable occupation numbers for RASSCF active orbitals
  that have been localised. It has proven useful in Effective Bond Order (EBO) analysis.
  Here is a sample input for a complex containing an iron-iron multiple bond. ::

    LOCN
    2  0.3
    Fe1  Fe2

  In this example, the (localised) orbitals constructed by the :program:`LOCALISATION` program
  are subdivided in two groups: those having less than 0.3 total Mulliken population on
  the two iron atoms, and the remaining orbitals, obviously localised on the iron-iron region. The resulting
  density matrices for the two subsets of orbitals are then diagonalised separately
  and the corresponding (localised) natural orbitals written to :file:`LOCORB` with the proper occupation
  numbers. Note that the two sets of LNOs are mutually non-orthogonal.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="LOCN" APPEAR="Localised natural orbitals" LEVEL="BASIC" KIND="CUSTOM">
              <HELP>
              Specify the number of atoms in the region and the threshold.
              Then the names of the symmetry unique atoms.
              </HELP>
              %%Keyword: LOCN <basic>
              This keyword is used to select atoms for defining the localised natural
              orbitals (LNOs), thus a set of localised orbitals with well-defined occupation numbers.
              All other options specified in the localisation input apply (e.g., input orbitals,
              localisation method, etc.).
              On the next line give the number of (symmetry unique) atoms that identify the region of interest
              and the threshold used to select the localised orbitals belonging to this region.
              An additional line gives the names of the atoms as defined in the SEWARD input.
              This keyword is used to define occupation numbers when localising active orbitals
              from RASSCF calculations. Particularly useful in Effective Bond Order (EBO) analysis.
              </KEYWORD>

:kword:`LOCCanonical orbitals`
  This keyword is used to select atoms for defining the localised canonical
  orbitals (LCOs), thus a set of localised orbitals with well-defined orbital energies
  (eigenvalues of a local Fock matrix).
  Please, refer to the analogous keyword :kword:`LOCN` in this manual for more details and input examples.

  .. xmldoc:: <KEYWORD MODULE="LOCALISATION" NAME="LOCC" APPEAR="Localised canonical orbitals" LEVEL="BASIC" KIND="CUSTOM">
              <HELP>
              Specify the number of atoms in the region and the threshold.
              Then the names of the symmetry unique atoms.
              </HELP>
              %%Keyword: LOCC <basic>
              This keyword is used to select atoms for defining the localised canonical
              orbitals (LCOs), thus a set of localised orbitals with well-defined orbital energies.
              All other options specified in the localisation input apply (e.g., input orbitals,
              localisation method, etc.).
              On the next line give the number of (symmetry unique) atoms that identify the region of interest
              and the threshold used to select the localised orbitals belonging to this region.
              An additional line gives the names of the atoms as defined in the SEWARD input.
              </KEYWORD>

Limitations
...........

The limitations on the number of basis functions are the same as specified
for :program:`SEWARD`.

Input examples
..............

This input is an example of the Boys localisation of the CO molecule. Note that no
symmetry should not be used in any calculation of localised orbitals except for
Cholesky and PAO orbitals.

.. extractfile:: ug/localisation.Boys.input

  &GATEWAY
  Coord = $MOLCAS/Coord/CO.xyz
  Basis = STO-3G
  Group = C1

  &SEWARD ; &SCF

  &LOCALISATION
  Boys

This input is an example of the Projected Atomic Orbital localisation of the
virtual orbitals of the CO molecule. The threshold for the Cholesky
decomposition that removes linear dependence is set to 1.0d-14.

.. extractfile:: ug/localisation.PAO.input

  &GATEWAY
  Coord = $MOLCAS/Coord/CO.xyz
  Basis = STO-3G
  Group = C1

  &SEWARD ; &SCF

  &LOCALISATION
  PAO
  Threshold = 1.0d-14

This input is an example of the Cholesky localisation (using default 1.0d-8 as
threshold for the decomposition) of the
valence occupied orbitals of the CO molecule.
Orbital domains are set up and analysed.

.. extractfile:: ug/localisation.Cholesky.input

  &GATEWAY
  Coord = $MOLCAS/Coord/CO.xyz
  Basis = STO-3G
  Group = C1

  &SEWARD ; &SCF

  &LOCALISATION
  Cholesky
  Freeze
  Domain

.. xmldoc:: </MODULE>
.. index::
   single: Program; Seward
   single: Seward

.. _UG\:sec\:seward:

:program:`seward`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="SEWARD">
            %%Description:
            <HELP>
            The Seward module generates one- and two-electron integrals needed
            by other programs. The input contains an additional and optional
            embedded input section for numerical quadrature options for the
            computation of integrals associated with DFT calculations. The
            embedded section starts and ends with the keywords "Grid Input"
            and "End of Grid", respectively. Keywords associated with this
            embedded input section is labelled "(NQ)" below.
            </HELP>

The :program:`SEWARD` module generates one- and two-electron integrals needed
by other programs. The two-electron integrals may optionally be
Cholesky decomposed. In addition, it will serve as the input parser
for parameters related to the specification of the quadrature grid
used in numerical integration in association with DFT and reaction
field calculations.

.. .. figure:: seward.*
      :width: 50%
      :align: center

      H. W. Seward, secretary of State in the Lincoln administration, who suggested and supervised
      the 1867 purchase of Alaska from tzar Russia. Price: 2 cents an acre.

In the following three subsections we will in detail describe the input parameters
for analytic integration, numerical integration, and relativistic operators.

.. ..include:: ../integrals.inc

Analytic integration
--------------------

Any conventional ab initio quantum chemical calculation starts by
computing overlap, kinetic energy, nuclear attraction and electron
repulsion integrals. These are used repeatedly to determine the
optimal wave function and the total energy of the system under
investigation. Finally, to compute various properties of the system
additional integrals may be needed, examples include multipole moments
and field gradients.

.. _UG\:sec\:seward_description:

Description
...........

:program:`SEWARD` is able to compute the following integrals:

* kinetic energy,

* nuclear attraction,

* two electron repulsion (optionally Cholesky decomposed),

* :math:`n`\th (default :math:`n`\=2) order moments (overlap, dipole moment, etc.),

* electric field (generated at a given point by all charges in the system),

* electric field gradients (spherical gradient operators),

* linear momentum (velocity),

* orbital angular momentum,

* relativistic mass-velocity correction (1st order),

* one-electron Darwin contact term,

* one-electron relativistic no-pair Douglas--Kroll,

* diamagnetic shielding,

* spherical well potential (Pauli repulsion),

* ECP and PP integrals,

* modified kinetic energy and multipole moment integrals
  (integration on a finite sphere centered at the origin) for use in
  the variational :math:`R`\-matrix approach,

* external field (represented by a large number of charges and dipoles),

* angular momentum products, and

* atomic mean-field integrals (AMFI) for spin--orbit coupling.

*Note that while* :program:`SEWARD` *compute these integrals the input to
select them and their settings are put in the input of* :program:`GATEWAY`.

In general these integrals will be written to a file, possibly in
the form of Cholesky vectors (two-electron integrals only). However,
:program:`SEWARD` can also compute the orbital contributions and total components of
these properties if provided with orbital coefficients and
orbital occupation numbers.

To generate the one- and two-electron integrals
:program:`SEWARD` uses two different integration schemes. Repulsion type integrals (two-electron
integrals, electric field integrals, etc.) are evaluated by
the reduced multiplication scheme of the Rys quadrature :cite:`seward`.
All other integrals are computed by the Gauss--Hermite quadrature.
:program:`SEWARD` use spherical Gaussians as basis functions,
the only exception to this are the diffuse/polarization functions
of the 6-31G family of basis sets.
The double coset :cite:`dcf` formalism is used to treat symmetry.
:program:`SEWARD` is especially designed to handle ANO-type basis sets, however, segmented basis
sets are also processed.

At present the following limitations are built into :program:`SEWARD`:

.. include:: ../limitations.inc

.. _UG\:sec\:seward_dependencies:

Dependencies
............

:program:`SEWARD` usually runs after program :program:`GATEWAY`. In the same time, any input used
in :program:`GATEWAY` can be placed into :program:`SEWARD` input. However, it is recommended to
specify all information about the molecule and the basis set in :program:`GATEWAY` input.

:program:`SEWARD` does normally not depend on any other code, except of :program:`GATEWAY`.
There are two exceptions however.
The first one is when :program:`SEWARD` is used as a property module. In these cases the file
:file:`INPORB` has to have been generated by a wave function code. The second case, which is
totally transparent to the user, is when :program:`SEWARD` picks up the new Cartesian coordinates
generated by :program:`SLAPAF` during a geometry optimization.

.. _UG\:sec\:seward_files:

Files
.....

Input Files
:::::::::::

Apart form the standard input file
:program:`SEWARD` will use the following input files: :file:`RYSRW`, :file:`ABDATA`,
:file:`RUNFILE`, :file:`INPORB` (for calculation of properties) (:numref:`UG:sec:files_list`).
In addition, :program:`SEWARD` uses the following files:

.. class:: filelist

:file:`BASLIB`
  The default directory for one-particle basis set information.
  This directory contains files which are part
  of the program system and could
  be manipulated by the user in accordance with the instructions in
  :numref:`UG:sec:the_basis_set_libraries` and following subsections.
  New basis set files can be added to this directory by the local
  |molcas| administrator.

:file:`QRPLIB`
  Library for numerical mass-velocity plus Darwin potentials (used for ECPs).

Output files
::::::::::::

In addition to the standard output file
:program:`SEWARD` may generate the following files:
:file:`ONEINT`, :file:`ORDINT`, :file:`CHVEC`, :file:`CHRED`, :file:`CHORST`,
:file:`CHOMAP`, :file:`CHOR2F` (:numref:`UG:sec:files_list`).

.. _UG\:sec\:seward_input:

Input
.....

Below follows a description of the input to :program:`SEWARD`.
Observe that if
nothing else is requested
:program:`SEWARD` will by default compute the overlap, the
dipole, the quadrupole, the nuclear attraction, the kinetic energy,
the one-electron Hamiltonian, and the two-electron repulsion
integrals.

The input for each module is preceded by its name like: ::

  &SEWARD

Argument(s) to a keyword, either individual or composed by several entries,
can be placed in a separated line or in the same line separated by a semicolon.
If in the same line, the first argument requires an equal sign after the
name of the keyword.

General keywords
::::::::::::::::

.. class:: keywordlist

:kword:`TITLe`
  One line of title card follows.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="TITLE" APPEAR="Title" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Enter one optional title card.
              </HELP>
              %%Keyword: Title <basic>
              One line of title card follows.
              </KEYWORD>

:kword:`TEST`
  :program:`SEWARD` will only process the input and generate a non-zero return code.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="TEST" APPEAR="Test" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Test <basic>
              <HELP>
              SEWARD will only process the input and generate a non-zero
              return code.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <GROUP MODULE="SEWARD" NAME="GATEWAY" APPEAR="Gateway input" KIND="BOX" LEVEL="ADVANCED">
              <HELP>
              When not using GATEWAY as a separate program, input for GATEWAY can be included in SEWARD.
              </HELP>
              <INCLUDE MODULE="GATEWAY" EXCEPT="TITLE,TEST,EXPE,VERB,PRINT" />
              </GROUP>

:kword:`ONEOnly`
  :program:`SEWARD` will not compute the two-electron integrals.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="ONEO" APPEAR="Only 1-el. Integrals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Oneonly <basic>
              <HELP>
              SEWARD will not compute the two-electron integrals.
              </HELP>
              </KEYWORD>

:kword:`NODKroll`
  :program:`SEWARD` will not compute Douglas--Kroll integrals.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NODK" APPEAR="Skip Douglas-Kroll Integrals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoDK <basic>
              <HELP>
              SEWARD will not compute Douglas-Kroll integrals.
              </HELP>
              </KEYWORD>

:kword:`DIREct`
  Prepares for later integral-direct calculations. As with keyword
  :kword:`OneOnly`, :program:`SEWARD` will evaluate no two-electron integrals.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="DIRE" APPEAR="Direct option" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Direct <basic>
              <HELP>
              Prepares for later integral-direct calculations. As with keyword
              oneonly, SEWARD will evaluate no two-electron integrals.
              </HELP>
              </KEYWORD>

:kword:`EXPErt`
  Sets "expert mode", in which various default settings are
  altered. Integral-direct calculations will be carried out
  if the two-electron integral file is unavailable.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="EXPE" APPEAR="Expert mode" KIND="SINGLE" LEVEL="ADVANCED">
              <HELP>
              Activates expert mode which will deactivate some checks. This will, for
              example, allow the used to combine relativistic and non-relativistic basis sets.
              </HELP>
              %%Keyword: Expert <advanced>
              Sets "expert mode", in which various default settings are
              altered. Integral-direct calculations will be carried out
              if the two-electron integral file is unavailable.
              </KEYWORD>

:kword:`CHOLesky`
  :program:`SEWARD` will Cholesky decompose the two-electron integrals using
  default configuration (in particular, the decomposition threshold is
  1.0d-4) of the decomposition driver.
  The decomposition threshold can be changed using keyword :kword:`THRC`.
  Default is to not decompose.

  .. xmldoc:: <GROUP MODULE="SEWARD" KIND="BOX" NAME="CDOPTIONS" APPEAR="CD options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CHOL" APPEAR="Cholesky" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,RICD,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: Cholesky <basic>
              <HELP>
              Cholesky decompose the two-electron integrals using default settings.
              </HELP>
              </KEYWORD>

:kword:`1CCD`
  :program:`SEWARD` will Cholesky decompose the two-electron integrals using
  the one-center approximation.
  The decomposition threshold can be changed using keyword :kword:`THRC`.
  Default is to not decompose.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="1CCD" APPEAR="1CCD" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: 1CCD <basic>
              <HELP>
              One-center Cholesky decomposition of the two-electron integrals.
              </HELP>
              </KEYWORD>

:kword:`THRCholesky`
  Specify decomposition threshold for Cholesky decomposition of two-electron integrals
  on the next line. Default value: 1.0d-4.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="THRCHOLESKY" APPEAR="ThrCholesky" KIND="REAL" LEVEL="BASIC">
              %%Keyword: ThrCholesky <basic>
              <HELP>
              Specify decomposition threshold for Cholesky decomposition of two-electron integrals.
              </HELP>
              </KEYWORD>

:kword:`SPAN`
  Specify span factor (0 :math:`<` span :math:`\leq` 1) for Cholesky decomposition of two-electron integrals on the next line.
  Span=1 implies full pivoting, Span=0 means no pivoting. If the span factor is too low, numerical errors may cause
  negative diagonal elements and force the program to quit; if the span factor is too large, the execution time may
  increase. Default value: 1.0d-2.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="SPANFACTOR" APPEAR="Span factor" KIND="REAL" LEVEL="BASIC">
              %%Keyword: Span <basic>
              <HELP>
              Specify span factor (in between, but not equal to, 0 and 1) for Cholesky decomposition of two-electron integrals on the next line.
              </HELP>
              </KEYWORD>

:kword:`LOW Cholesky`
  :program:`SEWARD` will Cholesky decompose the two-electron integrals using
  low accuracy (threshold 1.0d-4)
  configuration of the decomposition driver.
  Default is to not decompose.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LOW" APPEAR="Low" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,RICD,CHOL,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: Low <basic>
              <HELP>
              Cholesky decompose the two-electron integrals using low accuracy settings. Recommended.
              </HELP>
              </KEYWORD>

:kword:`MEDIum Cholesky`
  :program:`SEWARD` will Cholesky decompose the two-electron integrals using
  medium accuracy (threshold 1.0d-6)
  configuration of the decomposition driver.
  Default is to not decompose.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="MEDI" APPEAR="Medium" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,RICD,CHOL,LOW,HIGH" LEVEL="BASIC">
              %%Keyword: Medium <basic>
              <HELP>
              Cholesky decompose the two-electron integrals using medium accuracy settings.
              </HELP>
              </KEYWORD>

:kword:`HIGH Cholesky`
  :program:`SEWARD` will Cholesky decompose the two-electron integrals using
  high-accuracy (threshold 1.0d-8)
  configuration of the decomposition driver.
  Default is to not decompose.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="HIGH" APPEAR="High" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,RICD,CHOL,LOW,MEDI" LEVEL="BASIC">
              %%Keyword: High <basic>
              <HELP>
              Cholesky decompose the two-electron integrals using high accuracy settings.
              </HELP>
              </KEYWORD>

:kword:`LDF`
  Local Density Fitting: :program:`SEWARD` will fit each AO product using only auxiliary functions centered on the two parent atoms.
  Fitting coefficients are computed and stored for use in later modules (only non-hybrid KS-DFT at the moment).
  Requires an auxiliary basis set (generated by RICD in Gateway or externally defined).
  Can not be combined with Cholesky and (global) DF/RI. LDF is turned off by default.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LDF" APPEAR="Local Density Fitting" KIND="SINGLE" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: LDF <basic>
              <HELP>
              Local Density Fitting using auxiliary functions centered on the two parent atoms of each AO product.
              </HELP>
              </KEYWORD>

:kword:`LDF1`
  Local Density Fitting using auxiliary functions centered on the two parent atoms of each AO product. Equivalent to keyword :kword:`LDF`.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LDF1" APPEAR="Local Density Fitting" KIND="SINGLE" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: LDF1 <basic>
              <HELP>
              Local Density Fitting using auxiliary functions centered on the two parent atoms of each AO product. Equivalent to keyword LDF.
              </HELP>
              </KEYWORD>

:kword:`LDF2`
  LDF using auxiliary functions centered on the two parent atoms of each AO product as well as the two-center functions required to achieve the given target accuracy.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LDF2" APPEAR="Local Density Fitting with two-center auxiliary functions" KIND="SINGLE" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: LDF2 <basic>
              <HELP>
              Local Density Fitting using auxiliary functions centered on the two parent atoms of each AO product as well as the two-center functions required to achieve the given target accuracy.
              </HELP>
              </KEYWORD>

:kword:`TARGet accuracy`
  Specify the target accuracy for LDF2 on the next line. Default value: threshold used to generate the aCD or acCD auxiliary basis set
  (or 1.0d-4 in case of externally defined auxiliary basis sets).

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="TARG" APPEAR="Target accuracy for LDF2" KIND="REAL" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: TARG <basic>
              <HELP>
              Specify the target accuracy for LDF2 on the next line. Default value: threshold used to generate the aCD or acCD auxiliary basis set (or 1.0d-4 in case of externally defined auxiliary basis sets).
              </HELP>
              </KEYWORD>

:kword:`APTH`
  Specify the LDF/LDF2 atom pair prescreening threshold on the next line, thus defining which atom pairs are considered significant.
  Default value: the target accuracy or the cutoff threshold for primitive integral evaluation, whichever is smaller.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="APTH" APPEAR="Atom pair threshold" KIND="REAL" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: APTH <basic>
              <HELP>
              Specify the LDF/LDF2 atom pair prescreening threshold on the next line, thus defining which atom pairs are considered significant. Default value: the target accuracy or the cutoff threshold for primitive integral evaluation, whichever is smaller.
              </HELP>
              </KEYWORD>

:kword:`CLDF`
  Constrained LDF/LDF2: specify constraint order on the next line (-1 for unconstrained, 0 for charge constraint). Default: unconstrained LDF.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CLDF" APPEAR="Constrained LDF" KIND="INT" EXCLUSIVE="CHOL,LOW,MEDI,HIGH" LEVEL="BASIC">
              %%Keyword: CLDF <basic>
              <HELP>
              Constrained LDF/LDF2: specify constraint order on the next line (-1 for unconstrained, 0 for charge constraint). Default: unconstrained LDF.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`FAKE CD/RI`
  If CD/RI vectors are already available, :program:`SEWARD` will not redo work!

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="FAKE" APPEAR="Skip CD/RI vectors generation" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: FAKE <basic>
              <HELP>
              If CD/RI vectors are already available, SEWARD will not redo work!
              </HELP>
              </KEYWORD>

  .. :kword:`MOLPro`
       The integrals are normalized as in the program package
       :program:`MOLPRO`. The default is the normalization
       according to the double coset representatives (DCR) formalism
       for conventional calculations; for Cholesky decomposition, the
       default is the :kword:`MOLECULE` normalization (except when AMFI or
       Douglas--Kroll is specified, where the DCR formalism is again
       default).

  ..   .. xmldoc:: %%Keyword: MOLPRO <advanced>
                   The integrals are normalized as in the program package
                   MOLPRO. The default is the normalization
                   according to the double coset representatives (DCR) formalism
                   for conventional calculations; for Cholesky decomposition, the
                   default is the MOLECULE normalization (except when AMFI or
                   Douglas-Kroll is specified, where the DCR formalism is again
                   default).

  .. :kword:`MOLEcule`
       The integrals are normalized as in the integral program
       :program:`MOLECULE`. The default is the normalization
       according to the double coset representatives (DCR) formalism
       for conventional calculations; for Cholesky decomposition, the
       default is the :kword:`MOLECULE` normalization (except when AMFI or
       Douglas--Kroll is specified, where the DCR formalism is again
       default).

  ..   .. xmldoc:: %%Keyword: MOLECULE <advanced>
                   The integrals are normalized as in the integral program
                   MOLECULE. The default is the normalization
                   according to the double coset representatives (DCR) formalism
                   for conventional calculations; for Cholesky decomposition, the
                   default is the MOLECULE normalization (except when AMFI or
                   Douglas-Kroll is specified, where the DCR formalism is again
                   default).

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="MOLECULE" KIND="SINGLE" LEVEL="UNDOCUMENTED" />


  .. :kword:`MOLCas`
       The integrals are normalized according to the double coset
       representatives (DCR) formalism. This is the default for
       conventional calculations. The default for Cholesky decompositions
       is the :kword:`MOLECULE` normalization (except when AMFI or
       Douglas--Kroll is specified, where the DCR formalism is again
       default).

  ..   .. xmldoc:: %%Keyword: MOLCAS <advanced>
                   The integrals are normalized according to the double coset
                   representatives (DCR) formalism. This is the default
                   for conventional calculations; for Cholesky decomposition, the
                   default is the MOLECULE normalization (except when AMFI or
                   Douglas-Kroll is specified, where the DCR formalism is again
                   default).

:kword:`JMAX`
  The integer entry on the next line is the highest rotational quantum
  number for which
  :program:`SEWARD` will compute the rotational energy within the
  rigid rotor model. The default value is 5.

  .. xmldoc:: %%Keyword: JMAX <advanced>
              The integer entry on the next line is the highest rotational quantum
              number for which
              SEWARD will compute the rotational energy within the
              rigid rotor model. The default value is 5.

:kword:`SYMMetry`
  See the the description in the manual for the program :program:`GATEWAY`.

  .. :kword:`SKIP`
       The subsequent entry contains a sequence of integers, one for
       each irreducible representation. By setting an integer to a nonzero
       value all basis functions from the corresponding
       irreducible representation will be removed.
       The default is to skip no basis functions.

   ..  .. xmldoc:: %%Keyword: Skip <advanced>
                   The subsequent entry contains a sequence of integers, one for
                   each irreducible representation. By setting an integer to a nonzero
                   value all basis functions from the corresponding
                   irreducible representation will be removed.

  .. :kword:`NOTAbles`
       Indicates that no tables will be used for the the roots and weights
       of the Rys polynomials. The default is to use tables.
       This option is used to verify the data base for
       the calculation of roots and weights. Observe that the activation of
       this option will make the program perform rather slow.

  ..   .. xmldoc:: %%Keyword: Notables <advanced>
                   Indicates that no tables will be used for the the roots and weights
                   of the Rys polynomials. The default is to use tables.

:kword:`BASIs Set`
  See the the description in the manual for the program :program:`GATEWAY`.

:kword:`ZMAT`
  See the the description in the manual for the program :program:`GATEWAY`.

:kword:`XBAS`
  See the the description in the manual for the program :program:`GATEWAY`.

:kword:`XYZ`
  See the the description in the manual for the program :program:`GATEWAY`.

:kword:`NOGUessorb`
  Disable automatic generation of starting orbitals with the GuessOrb procedure.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NOGUESSORB" APPEAR="No guess orbitals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOGUESSORB <basic>
              <HELP>
              Disable automatic generation of starting orbitals with the GuessOrb procedure.
              </HELP>
              </KEYWORD>

:kword:`NODElete`
  Do not delete any orbitals automatically.

  .. xmldoc:: <GROUP MODULE="SEWARD" KIND="BOX" NAME="DELOPT" APPEAR="Delete options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NODE" APPEAR="No orbitals deleted" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NODElete <basic>
              <HELP>
              Do not delete any orbitals automatically.
              </HELP>
              </KEYWORD>

:kword:`SDELete`
  Set the threshold for deleting orbitals based on the eigenvalues of the overlap matrix.
  All eigenvalues with eigenvectors below this threshold will be deleted.
  If you want no orbitals deleted use keyword :kword:`NODElete`.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="SDEL" APPEAR="S delete threshold" KIND="REAL" LEVEL="BASIC">
              %%Keyword: SDELete <basic>
              <HELP>
              Set the threshold for deleting orbitals based on the eigenvalues of the overlap matrix.
              </HELP>
              </KEYWORD>

:kword:`TDELete`
  Set the threshold for deleting orbitals based on the eigenvalues of the kinetic energy matrix.
  All eigenvalues with eigenvectors above this threshold will be deleted.
  If you want no orbitals deleted use keyword :kword:`NODElete`.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="TDEL" APPEAR="T delete threshold" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TDELete <basic>
              <HELP>
              Set the threshold for deleting orbitals based on the eigenvalues of the kinetic energy matrix.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`VERBose`
  Force :program:`SEWARD` to print a bit more verbose.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="VERB" APPEAR="Verbose output" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Verbose <basic>
              <HELP>
              Force SEWARD to print a bit more verbose.
              </HELP>
              </KEYWORD>

:kword:`EMBEdding`
  Reads in an embedding potential from a file. It can also write out the
  density and the electrostatic potential on a grid. It is a block keyword
  which *must* be ended with :kword:`ENDEmbedding`.

  .. xmldoc:: <GROUP MODULE="SEWARD" NAME="EMBE" APPEAR="External embedding potential" KIND="BLOCK" LEVEL="ADVANCED">
              %%Keyword: Embedding <advanced>
              <HELP>
              Reads in an embedding potential from a file and can output the density and ESP on a grid.
              </HELP>

  The subkeywords are:

  :kword:`EMBInput` ---
    Specifies the path to the file which contains the embedding potential
    (e.g. ``EMBI=myEmbPot.dat``). The file contains a potential given on a grid. It
    has the number of grid points in the first line. Then in five columns
    data for each grid point is given (x, y, z, weight of this grid point,
    value of the potential). Default is ``EMBPOT``.

  :kword:`OUTGrid` ---
    Specifies the path to a file containing a grid on which the output is
    produced. It is only needed if you want to have the data on a grid different
    from the one given in :kword:`EMBInput`. The columns for the potential and weights
    are not needed in this file (and also not read in).

  :kword:`WRDEnsity` ---
    Switches on the calculation of the final electron density on a grid. The
    output file path must be specified along with this keyword (e.g. ``WRDE=myDens.dat``).

  :kword:`WREPotential` ---
    Switches on the calculation of the electrostatic potential on a grid. The
    output file path must be specified along with this keyword (e.g. ``WREP=myESP.dat``).

  :kword:`ENDEmbedding` ---
    Ends the :kword:`EMBEdding` section. This keyword *must* be present.

  The :kword:`EMBEdding` feature is currently only supported by the SCF part of |molcas|.

  .. xmldoc:: </GROUP>

Keywords associated to one-electron integrals
:::::::::::::::::::::::::::::::::::::::::::::

.. class:: keywordlist

:kword:`MULTipoles`
  Entry which specifies the highest order of the
  multipole for which integrals will be generated. The default center
  for the dipole moment operator is the origin.
  The default center for the higher order operators is the
  center of the nuclear mass.
  The default is to do up to quadrupole moment integrals (2).

  .. xmldoc:: <GROUP MODULE="SEWARD" KIND="BOX" NAME="ONE" APPEAR="1-electron Integral options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="MULTIPOLE" APPEAR="Set Max order of Multipole Moment Integrals" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="2">
              %%Keyword: Multipoles <basic>
              <HELP>
              Entry which specifies the highest order of the
              multipole for which integrals will be generated.
              For details consult the manual.
              </HELP>
              </KEYWORD>

:kword:`CENTer`
  This option is used to override the default selection of the origin
  of the multipole moment operators.
  On the first entry add an integer entry specifying the number of
  multipole moment operators for which the origin of expansion
  will be defined.
  Following this, one entry for each operator, the order of
  the multipole operator and the coordinates of the center (in au) of
  expansion are specified.
  The default is the origin for 0th and 1st multipoles, and the center of mass for higher-order multipoles.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CENT" KIND="REALS_COMPUTED" APPEAR="Multipole moments origins" SIZE="4" LEVEL="ADVANCED">
              %%Keyword: Center <advanced>
              <HELP>
              This option is used to override the default selection of the origin
              of the multipole moment operators.
              On the first entry specify the number of such modifications.
              On the following entries enter first the order of the multipole moment operators
              followed by the coordinates of the origin of the operator.
              </HELP>
              </KEYWORD>

:kword:`RELInt`
  Requests the computation of mass-velocity and one-electron Darwin
  contact term integrals for the calculation of a first order correction
  of the energy with respect to relativistic effects.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="RELI" APPEAR="1st order rel. corr." KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Relint <basic>
              <HELP>
              Requests the computation of mass-velocity and one-electron Darwin
              contact term integrals for the calculation of a first order correction
              of the energy with respect to relativistic effects.
              </HELP>
              </KEYWORD>

  .. :kword:`BSSMethod`
       Request that the one-electron Hamiltonian include the scalar relativistic
       effects according to the so-called Barysz--Sadlej--Snijders transformation.

  ..   .. xmldoc:: %%Keyword: BSSmethod <basic>
                   Request that the one-electron Hamiltonian include the scalar relativistic
                   effects according to the so-called Barysz-Sadlej-Snijders transformation.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="BSSMETHOD" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

:kword:`RELAtivistic`
  Request arbitrary scalar relativistic Douglas--Kroll--Hess (DKH) correction to the one-electron Hamiltonian
  and the so-called picture-change correction to the property integrals (multipole moments
  and electronic potential related properties). An argument of the form ``RXXPyy`` follows.
  Here XX represents the order of the DKH correction to the one-electron Hamiltonian and
  yy the order of the picture-change correction. The character P denotes the parameterization
  used in the DKH procedure.
  The possible parametrizations P of the unitary transformation used
  in the DKH transformation supported by |molcas| are:

  .. container:: list

    ``P=O``: Optimum parametrization (OPT)

    ``P=E``: Exponential parametrization (EXP)

    ``P=S``: Square-root parametrization (SQR)

    ``P=M``: McWeeny parametrization (MCW)

    ``P=C``: Cayley parametrization (CAY)

  Hence, the proper keyword for the 4th order relativistically corrected one-electron
  Hamiltonian and 3rd order relativistically corrected
  property integrals in the EXP parameterization would read as R04E03. If yy is larger than XX it is set to
  XX. If yy is omitted it will default to same value as XX. Recommended orders and parametrization is
  R02O02.
  Since the EXP parameterization employs a fast algorithm, it is
  recommended for high order DKH transformation.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="RELATIVISTIC" APPEAR="Relativistic correction order and parametrization (RXXPyy)" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: RELAtivistic <basic>
              <HELP>
              Request arbitrary scalar relativistic Douglas-Kroll-Hess (DKH) correction to the one-electron Hamiltonian
              and the so-called picture-change correction to the property integrals (multipole moments
              and electronic potential related properties). An argument of the form RXXPyy follows
              Here XX represents the order of the DKH correction to the one-electron Hamiltonian and
              yy the order of the picture-change correction. The character P denotes the parameterization
              used in the DKH procedure.

              The possible parametrizations P of the unitary transformation used
              in the DKH transformation supported by MOLCAS are:

              (P=O) -- Optimum parametrization (OPT)
              (P=E) -- Exponential parametrization (EXP)
              (P=S) -- Square-root parametrization (SQR)
              (P=M) -- McWeeny parametrization (MCW)
              (P=C) -- Cayley parametrization (CAY)

              Hence, the proper keyword for the 4th order relativistically corrected one-electron
              Hamiltonian and 3rd order relativistically corrected
              property integrals in the EXP parameterization would read as R04E03. If yy is larger than XX it is set to
              XX. If yy is omitted it will default to same value as XX. Recommended orders and parametrization is
              R02O02.
              Since the EXP parameterization employs a fast algorithm, it is
              recommended for high order DKH transformation.
              </HELP>
              </KEYWORD>

:kword:`RLOCal`
  Request local approximation to the relativistic exact decoupling approaches such
  as X2C, BSS and DKH. This option cannot be used together with point group symmetry.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="RLOCAL" APPEAR="Relativistic local approximation" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Rlocal <basic>
              <HELP>
              Request local approximation to the relativistic exact decoupling approaches such
              as X2C, BSS and DKH. This option cannot be used together with point group symmetry.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`Grid Input`
  Specification of numerical quadrature parameters, consult the numerical quadrature section of this
  manual.

Additional keywords for property calculations
:::::::::::::::::::::::::::::::::::::::::::::

.. class:: keywordlist

:kword:`VECTors`
  Requests a property calculation. For this purpose a file,
  :file:`INPORB`,
  must be available, which contains the MO's and occupation numbers
  of a wave function. A custom filename can be given with :kword:`FileOrb`.

  .. xmldoc:: <GROUP MODULE="SEWARD" NAME="PROPERTY" APPEAR="Property calculations options" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="VECT" APPEAR="Activate property calculation" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Vectors <basic>
              <HELP>
              Requests a property calculation. For this purpose an INPORB file must be available.
              </HELP>
              </KEYWORD>

:kword:`FILEorb`
  The next line specifies the filename containing the orbitals and occupation numbers
  from which the properties will be computed. By default a file named :file:`INPORB`
  will be used.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="FILE" APPEAR="Orbitals file" KIND="STRING" REQUIRE="VECT" LEVEL="BASIC">
              %%Keyword: FileOrb <basic>
              <HELP>
              The next line specifies the filename containing the orbitals and occupation numbers
              from which the properties will be computed. By default a file named INPORB
              will be used.
              </HELP>
              </KEYWORD>

:kword:`ORBCon`
  The keyword will force :program:`SEWARD`
  to produce a list of the orbital
  contributions to the properties being computed. The default is to
  generate a compact list.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="ORBC" APPEAR="List Orbital contributions" KIND="SINGLE" REQUIRE="VECT" LEVEL="ADVANCED">
              %%Keyword: Orbcon <advanced>
              <HELP>
              The keyword will force SEWARD to produce a list of the orbital
              contributions to the properties being computed. The default is to
              generate a compact list.
              </HELP>
              </KEYWORD>

:kword:`THRS`
  The real entry on the following line specifies the threshold for
  the occupation number of an orbital in order for the
  :kword:`OrbCon`
  option to list the contribution of that orbital to a property.
  The default is 1.0d-6.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="THRS" APPEAR="Property threshold" KIND="REAL" REQUIRE="ORBC" DEFAULT_VALUE="1.D-6" LEVEL="ADVANCED">
              <HELP>
              Specify the threshold for the occupation number of a orbital to allow that
              this orbital is included when listing orbital contributions to properties.
              </HELP>
              %%Keyword: Thrs <advanced>
              The real entry on the following line specifies the threshold for
              the occupation number of an orbital in order for the
              keyword "OrbCon" option to list the contribution of that orbital to a
              property. The default is 1.0d-6.
              </KEYWORD>

:kword:`ORBAll`
  When :kword:`OrbCon` is present, the keyword will force
  :program:`SEWARD` to produce a list of the computed properties
  of all orbitals (including unoccupied orbitals), and the
  properties are not weighted by orbital occupation numbers.
  The total electronic and nuclear
  contributions printed are the same as those printed by using
  :kword:`OrbCon` without :kword:`OrbAll`.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="ORBA" APPEAR="List properties of all orbitals" KIND="SINGLE" REQUIRE="ORBC" LEVEL="ADVANCED">
              %%Keyword: OrbAll <advanced>
              <HELP>
              Print computed properties for all orbitals (including unoccupied orbitals),
              and not weighted by orbital occupation numbers.
              </HELP>
              Requires "OrbCon".
              </KEYWORD>

  .. xmldoc:: </GROUP>

Keywords for two-electron integrals
:::::::::::::::::::::::::::::::::::

.. class:: keywordlist

:kword:`NOPAck`
  The two-electron integrals will not be packed. The default is to
  pack the two-electron integrals.

  .. xmldoc:: <GROUP MODULE="SEWARD" NAME="2EL" APPEAR="2-electron integral options" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NOPA" APPEAR="Unpacked 2-el. integrals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Nopack <advanced>
              <HELP>
              The two-electron integrals will not be packed. The default is to
              pack the two-electron integrals.
              </HELP>
              </KEYWORD>

:kword:`PKTHre`
  An entry specifies the desired accuracy for the packing
  algorithm, the default is 1.0d-14.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="PKTH" APPEAR="Packing threshold" KIND="REAL" DEFAULT_VALUE="1.0D-14" LEVEL="BASIC">
              <HELP>
              Specifies the desired accuracy for the packing algorithm.
              </HELP>
              %%Keyword: Pkthre <advanced>
              An entry specifies the desired accuracy for the packing
              algorithm, the default is 1.0d-14.
              </KEYWORD>

:kword:`STDOut`
  Generate a two-electron integral file according to the standard of
  version 1 of |molcas|. The default is to generate the
  two-electron integrals according to the standard used since version 2 of
  |molcas|.

  .. xmldoc:: %%Keyword: Stdout <advanced>
              Generate a two-electron integral file according to the standard of
              version 1 of MOLCAS. The default is to generate the
              two-electron integrals according to the standard used since version 2 of
              MOLCAS.

:kword:`THREshold`
  Threshold for writing integrals to disk follows. The default is 1.0d-14.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="THRE" APPEAR="To disk threshold" KIND="REAL" DEFAULT_VALUE="1.0D-14" LEVEL="BASIC">
              <HELP>
              Specify the threshold for writing integrals to disk.
              </HELP>
              %%Keyword: Threshold <advanced>
              Threshold for writing integrals to disk follows. The default is 1.0d-14.
              </KEYWORD>

:kword:`CUTOff`
  Threshold for ignoring the calculation of integrals based on the
  pair prefactor follows. The default is 1.0d-16.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CUTO" APPEAR="Integral threshold" KIND="REAL" DEFAULT_VALUE="1.0D-16" LEVEL="BASIC">
              <HELP>
              Specify the threshold for ignoring the calculation of integrals based on the pair prefactors.
              </HELP>
              %%Keyword: Cutoff <advanced>
              Threshold for ignoring the calculation of integrals based on the
              pair prefactor follows on the next line. The default is 1.0d-16.
              </KEYWORD>

  .. xmldoc:: </GROUP>

Keywords associated to electron--molecule scattering calculations within the framework of the :math:`R`\-matrix method
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

This section contains keyword which control the radial numerical integration
of the diffuse basis functions describing the scattered electrons in the
variational :math:`R`\-matrix approach. The activation of this option is controlled
by that the center of the diffuse basis is assigned the unique atom label DBAS.

.. class:: keywordlist

:kword:`RMAT`
  Radius of the :math:`R`\-matrix sphere (in bohr). This sphere is centered at the
  coordinate origin. The default is 10 bohr.

  .. xmldoc:: %%Keyword: RMAT <basic>
              Radius of the R-matrix sphere (in bohr). This sphere is centered
              at the coordinate origin. Default value is set to 10 bohr.

:kword:`RMEA`
  Absolute precision in radial integration.
  The default is 1d-9.

  .. xmldoc:: %%Keyword: RMEA <advanced>
              Absolute precision in radial integration for R-matrix calculation.
              The default is 1d-9.

:kword:`RMER`
  Relative precision in radial integration.
  The default is 1d-14.

  .. xmldoc:: %%Keyword: RMER <advanced>
              Relative precision in radial integration for R-matrix calculation.
              The default is 1d-14.

:kword:`RMQC`
  Effective charge of the target molecule.
  This is the effective charge seen by the incident electron outside
  of the :math:`R`\-matrix sphere. The default is 0d0.

  .. xmldoc:: %%Keyword: RMQC <advanced>
              Effective charge of the target molecule for R-matrix calculation.
              This is the effective charge seen by the incident electron outside
              of the R-matrix sphere. The default is 0d0.

:kword:`RMDI`
  Effective dipole of the target molecule.
  This is the effective dipole seen by the incident electron outside
  of the :math:`R`\-matrix sphere. The default is (0d0,0d0,0d0).

  .. xmldoc:: %%Keyword: RMDI <advanced>
              Effective dipole of the target molecule for R-matrix calculation.
              This is the effective dipole seen by the incident electron outside
              of the R-matrix sphere. The default is (0d0,0d0,0d0).

:kword:`RMEQ`
  Minimal value of the effective charge of the target molecule
  to be considered. This is also the
  minimal value of the components of the effective dipole
  to be considered. Default is 1d-8

  .. xmldoc:: %%Keyword: RMEQ <advanced>
              Minimal value of the effective charge of the target molecule
              to be considered in R-matrix calculation. This is also the
              minimal value of the components of the effective dipole
              to be considered in R-matrix calculation. Default is 1d-8.

:kword:`RMBP`
  Parameter used for test purposes in the definition of the
  Bloch term. Default is 0d0.

  .. xmldoc:: %%Keyword: RMBP <advanced>
              Parameter used for test purposes in the definition of the
              Bloch term in R-matrix calculation. Default is 0d0.

:kword:`CELL`
  Defines the three vectors of the unit cell (:math:`\vec{e}_1`, :math:`\vec{e}_2`, :math:`\vec{e}_3`).
  The optional keyword
  *Angstrom* before the definition of vectors would read data in Å.
  Must consist of three entries (four in the case of Å) which correspond to coordinates of the vectors. All the atoms which
  are defined after that key are considered as the atoms of the cell.

  .. xmldoc:: %%Keyword: CELL <advanced>
              Defines the three vectors of the unit cell (e1,e2,e3).
              The optional keyword
              Angstrom before the definition of vectors would read data in A.
              Must consist of three entries (four in the case of A) which correspond to coordinates of the vectors.
              All the atoms which
              are defined after that key are considered as the atoms of the cell.

:kword:`SPREad`
  Three integer numbers :math:`n_1`, :math:`n_2`, :math:`n_3` which define the spread of the unit cell along the unit cell vectors.
  For example, ``0 0 2`` would add all cell's atoms translated on :math:`-2\vec{e}_3`, :math:`-\vec{e}_3`, :math:`\vec{e}_3`, :math:`2\vec{e}_3`.
  This key must be placed **before** the definition of the unit cell atoms.

  .. xmldoc:: %%Keyword: SPREAD <advanced>
              Three integer numbers n_1, n_2, n_3 which define the spread of the unit cell along the unit cell vectors.
              For example, 0 0 2 would add all cell's atoms translated on -2*e3, -e3, e3, 2*e3.
              This key must be placed before the definition of the unit cell atoms.

Below follows an input for the calculation of integrals of a carbon
atom. The comments in the input gives a brief explanation of the
subsequent keywords.

.. extractfile:: ug/SEWARD.C.input

  &SEWARD
  Title= This is a test deck!
  * Remove integrals from a specific irreps
  Skip= 0 0 0 0 1 1 1 1
  * Requesting only overlap integrals.
  Multipole= 0
  * Request integrals for diamagnetic shielding
  DSHD= 0.0 0.0 0.0; 1; 0.0 0.0 0.0
  * Specify a title card
  * Request only one-electron integrals to be computed
  OneOnly
  * Specify group generators
  Symmetry= X Y Z
  * Enable an inline basis set
  Expert
  * Specify basis sets
  Basis set
  C.ANO-L...6s5p3d2f.
  Contaminant d
  C  0.0 0.0 0.0
  End of basis

The basis set label and the all electron basis set library
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

.. compound::

  The label, which defines the basis set for a given atom or set of atoms,
  is given as input after the
  keyword :kword:`Basis set`. It has the following general
  structure (notice that the last
  character is a period): ::

    atom.type.author.primitive.contracted.aux1.aux2.

  where the different identifiers have the following meaning:

.. class:: whatnotlist

``atom``
  Specification of the atom by its chemical symbol.

``type``
  Gives the type of basis set (ANO, STO, ECP, etc.) according to
  specifications given in the basis set library, *vide supra*.
  Observe that the upper cased character of the type label
  defines the file name in the basis directory.

``author``
  First author in the publication where that basis set appeared.

``primitive``
  Specification of the primitive set (e.g. 14s9p4d3f).

``contracted``
  Specification of the contracted set to be selected. Some basis
  sets allow only one type of contraction, others all types up
  to a maximum. The first basis functions for each angular
  momentum is then used.
  **Note**, for the basis set types ANO and ECP, on-the-fly decontraction of the most
  diffuse functions are performed in case the number of contracted functions specified in this field
  exceeds what formally is specified in the library file.

``aux1``
  Extra field that can be used to identify further variants.
  For an ECP, if the type is not ``ECP``, this field must be ``ECP``.

``aux2``
  Specification of the type of AIMP, for instance, to choose between
  different embedding AIMP's.
  non-relativistic and relativistic core AIMP's.

Only the identifiers ``atom``, ``type``,
and ``contracted`` have to be included in
the label. The others can be left out. However, the periods have to be
kept. Example --- the basis set label
"``C.ano-s...4s3p2d.``"
will by |molcas| be
interpreted as
"``C.ano-s.Pierloot.10s6p3d.4s3p2d.``",
which is the first
basis set in the ANO-S file in the
basis directory that fulfills the specifications given.

More information about basis set format can be found in
the section Advanced examples.

.. index::
   single: Numerical Integration

.. _UG\:sec\:dft:

Numerical integration
---------------------

Various Density Functional Theory (DFT) models can be used in |molcas|.
Energies and analytical gradients are available for all DFT models.
In DFT the exact exchange present in HF theory is replaced by a more general
expression, the exchange-correlation functional, which accounts for both the exchange energy, :math:`E_{\text{X}} [P]`
and the electron correlation energy, :math:`E_{\text{C}} [P]`.

.. _UG\:sec\:df_description:

Description
...........

We shall now describe briefly how the exchange and correlation energy terms look like.
The functionals used in DFT are integrals of some function of the electron density and optionally the gradient
of the electron density

.. math:: E_{\text{X}}[P] = \int f(\rho_{\alpha}(r), \rho_{\beta}(r), \nabla \rho_{\alpha}(r), \nabla \rho_{\beta}(r))\;dr

The various DFT methods differ in which function, :math:`f`, is used for :math:`E_{\text{X}}[P]` and for :math:`E_{\text{C}}[P]`.
In |molcas| pure DFT methods are supported, together with hybrid methods, in which the exchange functional
is a linear combination of the HF exchange and a functional integral of the above form.
The latter are evaluated by numerical quadrature.
In the :program:`SEWARD` input the parameters for the numerical integration can be set up.
In the :program:`SCF` and :program:`RASSCF` inputs the keywords for
using different functionals can be specified.
Names for the various pure DFT models are given by combining the names for the exchange and correlation functionals.

The DFT gradients has been implemented for both the fixed and the moving grid approach :cite:`Johnson:93,Handy:93,Baker:94`.
The latter is known to be translationally invariant by definition and is recommended in geometry optimizations.

.. .. _UG\:sec\:dft_files:

   Files
   .....

   .. class:: filelist

   :file:`RUNFILE`
     The run file will contain the parameters defining and controlling the numerical integration.

Input
.....

Below follows a description of the input to the numerical integration utility in the
:program:`SEWARD` input.

Compulsory keywords

.. class:: keywordlist

:kword:`GRID Input`
  This marks the beginning of the input to the numerical integration utility.

  .. xmldoc:: <GROUP MODULE="SEWARD" NAME="GRIDBLOCK" KIND="BLOCK" APPEAR="Numerical Quadrature Options" LEVEL="ADVANCED">
              %%Keyword: Grid input <basic>
              <HELP>
              Specification of numerical quadrature parameters.
              </HELP>

:kword:`END Of Grid-Input`
  This marks the end of the input to the numerical integration utility.

Optional keywords

.. class:: keywordlist

:kword:`GRID`
  It specifies the quadrature quality.
  The possible indexes that can follow are
  COARSE, SG1GRID, FINE, ULTRAFINE,
  following the Gaussian98 convention.
  Default is FINE.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="GRID" APPEAR="Generic Grids" KIND="CHOICE" LEVEL="ADVANCED" LIST="FINE,COARSE,SG1GRID,ULTRAFINE">
              %%Keyword: Grid (NQ) <advanced>
              <HELP>
              It specifies the quadrature quality.
              The possible indexes that can follow are
              COARSE, SG1GRID, FINE, ULTRAFINE,
              following the Gaussian98 convention.
              Default is FINE.
              </HELP>
              </KEYWORD>

  .. :kword:`GLOBal`
       It activates the use of the global partitioning technique.

       .. .. xmldoc:: %%Keyword: Global <advanced>
                      It activates the use of the global partitioning technique.

:kword:`RQUAd`
  It specifies the radial quadrature scheme.
  Options are LOG3 (Mura and Knowles) :cite:`Mura:96`, BECKE
  (Becke) :cite:`BeckeG:88`, MHL (Murray et al.) :cite:`Murray:93`, TA (Treutler and
  Ahlrichs, defined for :math:`\ce{H}`\--\ :math:`\ce{Kr}`) :cite:`Treutler:95`, and LMG (Lindh et
  al.) :cite:`LMG:01`, respectively. The default is MHL.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="RQUA" APPEAR="Radial grid type" KIND="CHOICE" LEVEL="ADVANCED" LIST="MHL,LOG3,BECKE,TA,LMG">
              %%Keyword: RQuad (NQ) <advanced>
              <HELP>
              It specifies the radial quadrature scheme.
              Options are LOG3 (Mura and Knowles), BECKE (Becke) , MHL (Murray et a.), TA (Treutler and
              Ahlrichs, defined for H-Kr), and LMG (Lindh et al.), respectively. The default is MHL.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <SELECT MODULE="SEWARD" NAME="AGRID" APPEAR="Angular Grid" CONTAINS="LEBEDEV,LOBATTO,GGL" LEVEL="ADVANCED">
              <HELP>
              Specifies the type of angular grid. Options are Gauss-Gauss-Legendre (GGL), Lobatto, and
              Lebedev. Lebedev is the default.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LEBEDEV" APPEAR="Lebedev angular grid" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="LOBATTO,GGL" />

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LOBATTO" APPEAR="Lobatto angular grid" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="LEBEDEV,GGL" />

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="GGL" APPEAR="GGL angular grid" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="LEBEDEV,LOBATTO" />

  .. xmldoc:: </SELECT>

:kword:`GGL`
  It activates the use of Gauss and Gauss--Legendre angular quadrature.
  Default is to use the Lebedev angular grid.

  .. xmldoc:: %%Keyword: GGL (NQ) <advanced>
              It activates the use of Gauss and Gauss-Legendre angular quadrature.
              Default is to use the Lebedev angular grid.

:kword:`LEBEdev`
  It turns on the Lebedev angular grid.

  .. xmldoc:: %%Keyword: Lebedev (NQ) <advanced>
              It turns on the Lebedev angular grid.

:kword:`LOBAtto`
  It activates the use of Lobatto angular quadrature.
  Default is to use the Lebedev angular grid.

  .. xmldoc:: %%Keyword: Lobatto (NQ) <advanced>
              It activates the use of Lobatto angular quadrature.
              Default is to use the Lebedev angular grid.

:kword:`LMAX`
  It specifies the angular grid size. Default is 29.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="LMAX" APPEAR="Angular Grid Size" KIND="INT" DEFAULT_VALUE="29" LEVEL="ADVANCED">
              %%Keyword: LMax (NQ) <advanced>
              <HELP>
              Specifies the highest order of a real spherical harmonic which the angular grid will integrate exact. Default is 29.
              </HELP>
              </KEYWORD>

:kword:`NGRId`
  It specifies the maximum number of grid points to process at one instance.
  Default is 128 grid points.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NGRI" APPEAR="Batch size" KIND="INT" DEFAULT_VALUE="128" LEVEL="ADVANCED">
              %%Keyword: nGrid (NQ) <advanced>
              <HELP>
              It specifies the maximum number of grid points to process at one instance.
              Default is 128 grid points.
              </HELP>
              </KEYWORD>

:kword:`NOPRunning`
  It turns off the the angular prunning. Default is to prune.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NOPR" APPEAR="No Prunning of Grid" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Noprunning (NQ) <advanced>
              <HELP>
              It turns off the the angular prunning. Default is to prune.
              </HELP>
              </KEYWORD>

:kword:`NR`
  It is followed by the number of radial grid points. Default is 75 radial grid points.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NR" APPEAR="Radial Grid Size" KIND="INT" DEFAULT_VALUE="75" LEVEL="ADVANCED">
              %%Keyword: nR (NQ) <advanced>
              <HELP>
              It is followed by the number of radial grid points. Default is 75 radial grid points.
              </HELP>
              </KEYWORD>

:kword:`NQDIrect`
  Recompute the values of the AOs on every SCF iteration. Default is to write them on disk on the
  first iteration and then retrieve them.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NQDI" APPEAR="Direct evaluation of AOs" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NQDirect (NQ) <advanced>
              <HELP>
              Recompute the values of the AOs on every SCF iteration. Default is to write them on disk on the
              first iteration and then retrieve them.
              </HELP>
              </KEYWORD>

  .. :kword:`WHOLe`
       It activates the use of routines which scan the whole atomic grid for
       each sub block. Default is to only scan the relevant part.

  ..   .. xmldoc:: %%Keyword: Whole (NQ) <advanced>
                   It activates the use of routines which scan the whole atomic grid for
                   each sub block. Default is to only scan the relevant part.

:kword:`FIXEd grid`
  Use a fixed grid in the evaluation of the gradient. This corresponds to
  using the grid to numerically evaluate the analytic gradient expression.
  Default is to use a moving grid.

  .. xmldoc:: <SELECT MODULE="SEWARD" NAME="GRID_TYPE" APPEAR="Grid type" CONTAINS="MOVING,FIXED" LEVEL="ADVANCED">
              <HELP>
              Specify if the grid should be fixed or moving. A moving grid is default.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="FIXE" APPEAR="Fixed grid" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Fixed Grid (NQ) <advanced>
              <HELP>
              Use a fixed grid in the evaluation of the gradient. This corresponds to
              using the grid to numerically evaluate the analytic gradient expression.
              Default is to use a moving grid.
              </HELP>
              </KEYWORD>

:kword:`MOVIng grid`
  Use a moving grid in the evaluation of the gradient. This correspond to
  evaluating the gradient of the numerical expression of the DFT energy. This is the default.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="MOVI" APPEAR="Moving grid" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Moving grid (NQ) <advanced>
              <HELP>
              Use a moving grid in the evaluation of the gradient. This correspond to
              evaluating the gradient of the numerical expression of the DFT energy. This is the default.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`RTHReshold`
  It is followed by the value for the the radial threshold.
  Default value is 1.0D-13.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="RTHR" APPEAR="Radial Grid Threshold" KIND="REAL" DEFAULT_VALUE="1.0D-13" LEVEL="ADVANCED">
              %%Keyword: RThreshold (NQ) <advanced>
              <HELP>
              Follows the value for the the radial threshold.
              Default value is 1.0D-13.
              </HELP>
              </KEYWORD>

:kword:`T_Y`
  Threshold for screening in the assembling of the integrals.
  Note that in the SCF module the value is optionally adjusted to be the lower of the input or
  a value one magnitude tighter than the energy threshold.
  Default value is 1.0D-11.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="T_Y" KIND="REAL" DEFAULT_VALUE="1.0D-11" LEVEL="ADVANCED">
              %%Keyword: T_Y (NQ) <advanced>
              <HELP>
              Threshold for screening in the assembling of the integrals.
              Note that in the SCF module the value is optionally adjusted to be the lower of the input or
              a value one magnitude tighter than the energy threshold.
              Default value is 1.0D-11.
              </HELP>
              </KEYWORD>

:kword:`NOSCreening`
  Turn off any screening in the numerical integration.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NOSC" APPEAR="NoScreening" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NOSCreening (NQ) <basic>
              <HELP>
              Turn off any screening in the numerical integration.
              </HELP>
              </KEYWORD>

:kword:`CROWding`
  The crowding factor, according to MHL, used in the pruning of the angular
  grid close to the nuclei. Default value 3.0.

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CROW" APPEAR="CROWDING" KIND="REAL" DEFAULT_VALUE="3.0" LEVEL="ADVANCED">
              %%Keyword: CROWding (NQ) <basic>
              <HELP>
              The crowding factor, according to MHL, used in the pruning of the angular
              grid close to the nuclei. Default value 3.0.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NORO" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: </GROUP>

The :program:`SCF` and :program:`RASSCF` programs have
their own keywords to decide which functionals to use in a DFT calculation.

Below follows an example of a DFT calculation with two different functionals.

.. extractfile:: ug/DFT.H.input

  &GATEWAY
  Basis set
  H.3-21G.....
  H1 0.0  0.0 0.0
  End of basis

  &SEWARD
  Grid input
   RQuad= Log3; nGrid= 50000; GGL; lMax= 26; Global
  End of Grid Input

  &SCF; Occupations=1; KSDFT=LDA5; Iterations= 1 1

  &SCF; Occupations= 1; KSDFT=B3LYP; Iterations= 1 1

Relativistic operators
----------------------

The current different implementation of all relativistic operators in |molcas| as
described in the following sections has been programmed and tested in
Ref. :cite:`R2C_review`

Using the Douglas--Kroll--Hess Hamiltonian
..........................................

For all-electron calculations, the preferred way is to use the scalar-relativistic
Douglas--Kroll--Hess (DKH) Hamiltonian, which, in principle, is available up to arbitrary
order in Molcas; for actual calculations, however,
the standard 2nd order is usually fine, but one may use a higher order than 8th order
by default to be on the safe side.

.. compound::

  The arbitrary-order Hamiltonian is activated by setting ::

    RXXPyy

  somewhere in the :program:`SEWARD` input, where
  the ``XX`` denotes the order of the DKH Hamiltonian in the external potential.
  I.e., for the standard 2nd-order Hamiltonian you may use ``R02O``.
  Note
  in particular that the parametrization ``P`` does not affect the Hamiltonian up to
  fourth order. Therefore, as long as you run calculations with DKH Hamiltonians below
  5th order you may use any symbol for the parametrization as they would all yield the
  same results.

The possible parametrizations ``P`` of the unitary transformation used
in the DKH transformation supported by |molcas| are:

.. container:: list

  ``P=O``: Optimum parametrization (OPT)

  ``P=E``: Exponential parametrization (EXP)

  ``P=S``: Square-root parametrization (SQR)

  ``P=M``: McWeeny parametrization (MCW)

  ``P=C``: Cayley parametrization (CAY)

Up to fourth order (``XX``\=04) the DKH Hamiltonian is independent of the chosen
parametrization.
Higher-order DKH Hamiltonians depend slightly on the chosen parametrization of the unitary
transformations applied in order to decouple the Dirac Hamiltonian.
Since the EXP parameterization employs a fast algorithm :cite:`DKH_polynomial`, it is recommended
for high-order DKH transformation.

For details on the arbitrary-order DKH Hamiltonians see :cite:`DKH_Theory` with respect to theory,
:cite:`DKH_Implementation` with respect to aspects of implementation, and
:cite:`DKH_Principles` with respect to general principles of DKH.
The current version of |molcas| employs different algorithms,
but the polynomial cost scheme of the DKH implementation as described in :cite:`DKH_polynomial` is
used as the default algorithm. The implementation in MOLCAS has been presented in :cite:`R2C_review`.

For details on the different parametrizations of the unitary transformations see :cite:`DKH_Parameterization`.

Douglas--Kroll--Hess transformed properties
...........................................

As mentioned above, four-component molecular property operators need to be DKH
transformed as well when going from a four-component to a two- or one-component description;
the results do not coincide with the well-known corresponding nonrelativistic expressions
for a given property but are properly picture change corrected.

.. compound::

  The transformation of electric-field-like molecular property operators can be carried
  out for any order smaller or equal to the order chosen for the scalar-relativistic DKH Hamiltonian.
  In order to change the default transformation of order 2, you may concatenate the
  input for the DKH Hamiltonian by 2 more numbers specifying the order in the property, ::

    RxxPyy

  where ``yy`` denotes the order of the Hamiltonian starting with first order 01.
  The DKH transformation is then done automatically for all one-electron electric-field-like
  one-electron property matrices.

Also note that the current implementation of both the Hamiltonian and the property
operators is carried out in the full, completely decontracted basis set of the
molecule under consideration. The local nature of the relativistic contributions is not
yet exploited and hence large molecules may require considerable computing time for
all higher-order DKH transformations.

For details on the arbitrary-order DKH properties see :cite:`DKH_Theory2` with respect to theory
and :cite:`DKH_Implementation2,R2C_review` with respect to implementation aspects.

Using the X2C/Barysz--Sadlej--Snijders Hamiltonian
..................................................

Exact decoupling of the relativistic Dirac Hamiltonian can be achieved with infinite-order
approaches, such as the so-called X2C (exact-two-component) and BSS (Barysz--Sadlej--Snijders)
method. In Molcas, both methods are available for all-electron calculations. The
evaluation of transformation matrices employs a non-iterative scheme.

.. which is superior to the iterative scheme in convergence behavior and computational cost.

The exact decoupling Hamiltonian is activated by setting either ``RX2C`` or ``RBSS``
somewhere in the :program:`SEWARD` input, where ``RX2C`` and ``RBSS`` denote using the
scalar (one-component) X2C and BSS Hamiltonian respectively. The one-electron Hamiltonian
as well as the property integrals will be transformed according to the given exact decoupling method.
In other words, all property integrals are by default picture change corrected.

The computation time of the X2C/BSS method is almost the same as of the DKH method at 8th order,
while X2C is a little bit faster than BSS since the additional free-particle Foldy--Wouthuysen
transformation is skipped in the X2C approach :cite:`R2C_review`. For molecules including only light atoms,
the DKH method with low orders (< 8) is enough to account for the relativistic effects.

.. As for heavy
   elements containing molecules, DKH with low orders is not accurate enough while DKH with high
   orders is computational expensive, the X2C method is then recommended in this case.

The differences between different exact decoupling relativistic methods are very small compared
to errors introduced by other approximations, such as the basis set incompleteness, approximate
density functionals, etc. Therefore, any exact decoupling model is acceptable for the
treatment of relativistic effects in molecular calculations.

For details on the exact decoupling approaches see :cite:`R2C_review` with respect to theories and
comparison of numerical results, :cite:`X2C_kut05jcp,X2C_liu06jcp,X2C_pen07jcp` for the X2C method, and
:cite:`BSS_bar97ijqc,BSS_ked07cpl` for the BSS method.

Local approximation to relativistic decoupling
..............................................

The computational cost for relativistic transformations increases rapidly if the molecule becomes
larger. The local DLU scheme :cite:`DLU_Theory` was proposed to reduce the computational cost
based on the atomic decomposition of the (unitary) decoupling transformation. It is important to note that
the DLU scheme can be applied to any kind of relativistic approaches mentioned above (i.e., DKH, BSS, and X2C). It was found :cite:`DLU_Theory`
that the DLU approximation introduces very small errors for total energies, which are less than
0.01 milli-hartree for molecules including heavy atoms.
The local approximation is activated by setting :kword:`RLOCal` somewhere in the :program:`SEWARD` input.

The direct local approximation to the Hamiltonian, called DLH in Ref. :cite:`DLU_Theory` may be activated by setting ``RLOCal=DLH``.
However, as DLH is not superior to the DLU scheme, but introduces slightly larger errors, it is not recommended.

The picture-change effect for molecular properties is automatically taken care of when a local approximation is employed for the transformed
operator. The default order of DKH transformed properties is set to the same as the order of the DKH Hamiltonian.

It is important to note the local approximation cannot be used together with point group symmetry
in the current implementation. Because the relativistic transformation is applied in the molecular
orbital (MO) representation instead of the atomic orbital (AO) representation. Thus, the program will
report an error and exit if symmetry is used.

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="FOOC" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="UNCONTRACTED" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="NEMO" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="CLIGHT" KIND="REAL" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="PAMFI" KIND="INT" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="DOANALYTICAL" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SEWARD" NAME="PRINT" KIND="INTS_COMPUTED" SIZE="2" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <GROUP MODULE="SEWARD" NAME="CHOINPUT" KIND="BLOCK" LEVEL="UNDOCUMENTED">
            <KEYWORD MODULE="SEWARD" NAME="THRC" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="PRIN" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="BUFF" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="THRD" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="DMP1" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="DMP2" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="SPAN" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="MINQ" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="MAXQ" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="SCRE" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="QUAL" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="THRN" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="WARN" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="TOON" KIND="REAL" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="NOAB" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="IOVE" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="FRAC" KIND="INTS" SIZE="2" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="PARA" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="1-CE" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="ONES" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="ADDR" KIND="INT" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="RSTD" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="RSTC" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="REOR" KIND="SINGLE" LEVEL="UNDOCUMENTED" />
            <KEYWORD MODULE="SEWARD" NAME="CHOM" KIND="INT" LEVEL="UNDOCUMENTED" />
            </GROUP>

.. xmldoc:: </MODULE>
.. _UG\:sec\:rpa:

:program:`rpa`
==============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="RPA">
            %%Description:
            <HELP>
            This module is still undocumented
            </HELP>

This module is still undocumented.

.. xmldoc:: </MODULE>
.. index::
   single: Program; MRCI
   single: MRCI

.. _UG\:sec\:mrci:

:program:`MRCI`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MRCI">
            %%Description:
            <HELP>
            The MRCI program is used for Multi-Reference
            SDCI or ACPF calculations. The code originates in an MRCI
            program by M. Blomberg and P. E. M. Siegbahn, later rewritten
            extensively. It requires a file generated by the GUGA program.
            </HELP>

.. index::
   single: Multireference; SDCI
   single: Multireference; ACPF

The
:program:`MRCI`
program generates Multi Reference :index:`SDCI <single: SDCI; using MRCI>` or :index:`ACPF <single: ACPF; using MRCI>` :cite:`Gdanitz:88`
wavefunctions. ACPF is a modification of the CPF :cite:`Ahlrichs:85`
method which allows more than one reference configuration. The program is
based on the :index:`Direct CI` method :cite:`Roos:72`,
and with the :index:`coupling coefficients <single: Coupling coefficients; MRCI>` generated with the Graphical Unitary Group
Approach :cite:`Shavitt:77,Shavitt:78,Siegbahn:80`.
(See program description for
:program:`GUGA`).
If requested, :program:`MRCI` computes matrix elements of those
one-electron properties for which it can find integrals in the
:file:`ONEINT` file. It also
generates natural orbitals that can be fed into
the property program to evaluate certain one electron properties.
The natural orbitals are also useful for Iterated Natural Orbital
(:index:`INO`) calculations.

The :program:`MRCI` code is a modification of an MRCI
program written by M. Blomberg and P. E. M. Siegbahn (Institute of Physics,
Stockholm University, Sweden), which has later been extensively modified
(P.-Å. Malmqvist)

The program can calculate several eigenvectors simultaneously, not
necessarily those with lowest eigenvalue. However, in the ACPF case,
only one single eigenvector is possible.

Orbital subspaces

The orbital space is divided into the following subspaces: Frozen,
Inactive, Active, Secondary, and Deleted orbitals. Within each
symmetry type, they follow this order.

* **Frozen:**
  :index:`Frozen orbitals <single: MRCI; Frozen>` are always doubly
  occupied, i.e., they are not correlated. Orbitals may be frozen
  already in the integral integral transformation step, program
  :program:`MOTRA`, but can also be specified in the input to the
  :program:`MRCI` program. The former method is more efficient,
  and has the effect that the frozen orbitals are effectively removed
  from the subsequent
  :program:`MRCI` calculation.

* **Inactive:**
  :index:`Inactive orbitals <single: MRCI; Inactive>` are doubly occupied
  in all reference configurations, but excitations out of this orbital
  space are allowed in the final CI wavefunction, i.e., they are
  correlated but have two electrons in all reference configurations.
  Restrictions may be applied to excitation from some inactive orbitals,
  see keyword :index:`NoCorr <single: MRCI; NoCorr>` in the :program:`GUGA` input section.

* **Active:**
  :index:`Active orbitals <single: MRCI; Active>` are those which may have
  different occupation in different reference configurations.
  Restrictions may be applied to occupation of some active orbitals,
  see keyword :index:`OneOcc <single: MRCI; OneOcc>` in the :program:`GUGA` input section.

* **Secondary:**
  :index:`This subspace <single: MRCI; Secondary>` is empty in all
  reference configurations, but may be populated with up to two
  electrons in the excited configurations. This subspace is not
  explicitly specified, but consists of the orbitals which are left over
  when other spaces are accounted for.

* **Deleted:**
  :index:`This orbital subspace <single: MRCI; Deleted>` does not
  participate in the CI wavefunction at all. Typically the 3s,4p,...
  components of 3d,4f,..., or orbitals that essentially describe core
  correlation, are deleted. Similar to freezing, deleting can be done in
  :program:`MOTRA`,
  which is more efficient, but also as input
  specifications to the
  :program:`MRCI` program.

Since ordinarily the frozen and deleted orbitals were handled by
:program:`MOTRA`
and the subdivision into inactive and
active orbitals were defined in
:program:`GUGA`, the only
time one has to specify orbital spaces in the input to
:program:`MRCI`
is when additional frozen or deleted orbitals are required without
recomputing the transformed integrals.

.. index::
   pair: Dependencies; MRCI

.. _UG\:sec\:mrci_dependencies:

Dependencies
------------

The program needs the coupling
coefficients generated by the program
:program:`GUGA` and transformed one- and two-electron integrals
generated by the program
:program:`MOTRA`.

.. index::
   pair: Files; MRCI

.. _UG\:sec\:mrci_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`CIGUGA`
  Coupling coefficients from :program:`GUGA`.

:file:`TRAINT*`
  Transformed two-electron integrals from :program:`MOTRA`.

:file:`TRAONE`
  Transformed one-electron integrals from :program:`MOTRA`.

:file:`ONEINT`
  One-electron property integrals from :program:`SEWARD`.

:file:`MRCIVECT`
  Used for input only in restart case.

Output files
............

.. class:: filelist

:file:`CIORBnn`
  One or more sets of natural orbitals, one for each CI root, where
  nn stands for 01, 02, etc.

:file:`MRCIVECT`
  CI vector, for later restart.

Note that these file names are the FORTRAN file names used by the program,
so they have to be mapped to the actual file names. This is usually done
automatically in the |molcas| system. However, in the case of several
different numbered files
:file:`CIORBnn` only the first will be defined as default,
with the FORTRAN file name
:file:`CIORB`
used for
:file:`CIORB01`.

.. Local files
   ...........

   .. class:: filelist

   :file:`FTxxF001`
     MRCI produces a few scratch files that are not needed by any other program
     in |molcas|. Presently, these are xx=14, 15, 16, 21, 23, 25, 26, 27, and 30.
     The files are opened, used, closed and removed automatically.
     See source code for further information.

.. index::
   pair: Input; MRCI

.. UG\:sec\:mrci_input:

Input
-----

This section describes the input to the
:program:`MRCI` program in the |molcas| program system, with
the program name: ::

  &MRCI

.. index::
   pair: Keywords; MRCI

Keywords
........

.. class:: keywordlist

:kword:`TITLe`
  The line following this keyword is treated as title line

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              Followed by a title line
              </HELP>
              </KEYWORD>

:kword:`SDCI`
  This keyword is used to perform an ordinary Multi-Reference
  Singles and Doubles CI, MR-SDCI, calculation. This is the default
  assumption of the program.
  Note that SDCI and ACPF are mutually exclusive.

  .. xmldoc:: <SELECT MODULE="MRCI" NAME="COMPMOD" APPEAR="Computation Model" CONTAINS="SDCI,ACPF" LEVEL="BASIC">
              <HELP>
              Choose one of the available quantum chemistry computational models.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="SDCI" APPEAR="MR-SDCI" KIND="SINGLE" EXCLUSIVE="ACPF" LEVEL="BASIC">
              <HELP>
              Choose MR-SDCI calculation.
              </HELP>
              %%Keyword: SDCI <basic>
              Make an MR-SDCI calculation. (This is presently the default anyway).
              Keywords ACPF and SDCI are mutually exclusive.
              </KEYWORD>

:kword:`ACPF`
  This keyword tells the program to use the Average Coupled Pair
  Functional, ACPF, when computing the energy and natural orbitals.
  Note that SDCI and ACPF are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="ACPF" APPEAR="MR-ACPF" KIND="SINGLE" EXCLUSIVE="SDCI" LEVEL="BASIC">
              <HELP>
              Choose MR-ACPF calculation (Gdanitz, see manual).
              </HELP>
              %%Keyword: ACPF <basic>
              Make an MR-ACPF calculation, rather than an SDCI.
              Keywords ACPF and SDCI are mutually exclusive.
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`GVALue`
  The coefficient g which is used in the ACPF functional. The default
  value is = 2.0/(Nr of correlated electrons).

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="GVALUE" APPEAR="g Value" KIND="REAL" LEVEL="BASIC">
              <HELP>
              Enter user-defined coefficient g, altering the ACPF functional.
              </HELP>
              %%Keyword: GValue <advanced>
              The coefficient g, altering the ACPF functional.
              </KEYWORD>

:kword:`NRROots`
  Specifies the number of CI roots (states) to be simultaneously
  optimized. The default is 1.

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="NRROOTS" APPEAR="Number of states to compute." KIND="INT" LEVEL="BASIC">
              %%Keyword: NRRoots <basic>
              <HELP>
              The number of CI roots (states) to be computed. Default=1.
              </HELP>
              </KEYWORD>

:kword:`ROOTs`
  Specifies which root(s) to converge to. These are defined as the
  ordinal number of that eigenvector of the reference CI which is
  used as start approximation. The default is the sequence 1,2,3,...
  The values are entered on the next line(s). If the number of roots is
  larger than 1, it must first have been entered using keyword NRROOTS.
  The keywords ROOTS and SELECT are mutually exclusive.

  .. xmldoc:: <GROUP MODULE="MRCI" NAME="HOWCHOOSE" APPEAR="How choose roots?" KIND="RADIO">
              <HELP>
              Two ways to choose which states to compute.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="ROOTS" APPEAR="Choose roots number" KIND="INTS" SIZE="10" LEVEL="BASIC">
              %%Keyword: Roots <basic>
              <HELP>
              Which roots to compute, as a list of numbers.
              </HELP>
              (counted in order of reference CI).
              Keywords ROOTS and SELECT are mutually exclusive.
              </KEYWORD>

:kword:`SELEct`
  Another way of specifying the roots: instead of using ordinal
  numbers, the roots selected will be those NRROOTS which have
  largest projections in a selection space
  which is specified on the next lines, as follows:
  One line gives NSEL, the number of vectors used to define the
  selection space. For each selection vector, program reads
  the number of CSFs (NC), and # NC pairs of CSEL (text strings) and SSEL (coefficients).
  The text string is composed of the
  digits 0,1,2,3 and denotes the GUGA case numbers of the active
  orbitals, defining uniquely a CSF belonging to the reference space.
  The keywords ROOTS and SELECT are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="MRCI" NAME="SELECT" APPEAR="Roots selected:" KIND="REALS_COMPUTED" SIZE="2" LEVEL="BASIC">
              %%Keyword: Select <advanced>
              <HELP>
              Which roots to select, specified as a selection space.
              See manual for details.
              </HELP>
              Keywords ROOTS and SELECT are mutually exclusive.
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`RESTart`
  Restart the calculation from a previous calculation. No additional
  input is required. The :file:`MRCIVECT` file is required for restarted
  calculations.

  .. xmldoc:: %%Keyword: Restart <advanced>
              Use a previous wavefunction from the MRCIVECT file as start approximation.

:kword:`THRPrint`
  Threshold for printout of the wavefunction. All configurations with a
  coefficient greater than this threshold are printed.
  The default is 0.05.

  .. xmldoc:: %%Keyword: ThrPrint <advanced>
              Enter threshold of CI coefficients to be printed. Default 0.05.

:kword:`ECONvergence`
  Energy convergence threshold. The result is converged when the energy
  of all roots has been lowered less than this threshold in the last
  iteration. The default is 1.0d-8.

  .. xmldoc:: %%Keyword: EConvergence <advanced>
              Enter energy convergence threshold. Default 1.0D-8.

:kword:`PRINt`
  Print level of the program. Default is 5.

  .. xmldoc:: %%Keyword: Print <advanced>
              Set print level. Default is 5.

:kword:`MAXIterations`
  Maximum number of iterations. Default 20. The maximum possible value is 49.

  .. xmldoc:: %%Keyword: MaxIterations <advanced>
              Set max number of iterations. Default is 20. Largest possible is 49.

:kword:`MXVEctors`
  Maximum number of trial vector pairs (CI+sigma) kept on
  disk. Default is MAX(NRROOTS,10). It should never be
  smaller than NRROOTS. A good value is 3*NRROOTS or more.

  .. xmldoc:: %%Keyword: MxVectors <advanced>
              Set max nr of trial vector pairs (CI+sigma) kept on disk. Default is
              MAX(NRROOTS,10). Must be at least NRROOTS. Not much point in using
              more than 3*NRROOTS except for very few roots.

:kword:`TRANsition`
  This keyword is relevant to a multi-root calculation. In addition
  to properties, also
  the transition matrix elements of various operators, for each pair
  of wave functions, will be computed.

  .. xmldoc:: %%Keyword: Transition <advanced>
              Relevant for multi-root calculations. The transition matrix elements
              of all operators, for which there are integrals on the ONEINT file,
              will be computed for each pair of states.

:kword:`FROZen`
  Specify the number of orbitals to be frozen in
  **addition** to the orbitals frozen in the integral transformation.
  Default is 0 in all symmetries.

  .. xmldoc:: %%Keyword: Frozen <advanced>
              Enter a list specifying, for each symmetry, how many orbitals to keep
              frozen (uncorrelated), in addition to those that were frozen already
              in the integral transformation (See MOTRA). Default is 0 in all symmetries.

:kword:`DELEted`
  Specify the number of orbitals to be deleted in
  **addition** to the orbitals deleted in the integral transformation.
  Default is 0 in all symmetries.

  .. xmldoc:: %%Keyword: Deleted <advanced>
              Enter a list specifying, for each symmetry, how many orbitals to delete
              in addition to those that were deleted already
              in the integral transformation (See MOTRA). Default is 0 in all symmetries.

:kword:`REFCi`
  Perform only reference CI.

  .. xmldoc:: %%Keyword: RefCI <advanced>
              Do only a reference CI.

:kword:`PRORbitals`
  Threshold for printing natural orbitals. Only orbitals with occupation
  number larger than this threshold appears in the printed output.
  Default is 1.0d-5.

  .. xmldoc:: %%Keyword: PrOrbitals <advanced>
              Threshold on occupation number, for printing natural orbitals. Default 1.0D-5.

Input example
.............

::

  &MRCI
  Title
   Water molecule. 1S frozen in transformation.
  Sdci

.. xmldoc:: </MODULE>
.. index::
   single: Program; CASVB
   single: CASVB

.. _UG\:sec\:casvb:

:program:`casvb`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. The input format of CASVB is not completely compatible with the XML specification
   format used by MolGUI.

.. xmldoc:: <MODULE NAME="CASVB">
            %%Description:
            <HELP>
            CASVB is a program for performing general valence bond calculations.
            It can be used in two basic modes:

            a) variational optimization of quite general types of
               nonorthogonal MCSCF or modern valence bond wavefunctions, or
            b) representation of CASSCF wavefunctions in modern valence form,
               using overlap- (relatively inexpensive) or energy-based criteria.
            </HELP>

This program can be used in two basic modes:

#. variational optimization of quite general types of
   nonorthogonal MCSCF or modern valence bond wavefunctions
#. representation of CASSCF wavefunctions in modern valence form,
   using overlap- (*relatively inexpensive*) or energy-based criteria.

For generating representations of CASSCF wavefunctions, the program
is invoked by the command :kword:`CASVB`.
For variational optimization of wavefunctions it is normally invoked
inside :program:`RASSCF` by the sub-command :kword:`VB` (see :ref:`the RASSCF documentation <vbinrasscf>`).

Bibliography: see :cite:`casvb1,casvb2,casvb3,casvb4`.

.. index::
   pair: Dependencies; CASVB

.. _UG\:sec\:casvb_dependencies:

Dependencies
------------

The :program:`CASVB` program needs the :file:`JOBIPH` file from a :program:`RASSCF` calculation,
and in addition also the :file:`ONEINT` and :file:`ORDINT` files from :program:`SEWARD`.

.. index::
   pair: Files; CASVB

.. _UG\:sec\:casvb_files:

Files
-----

Input files
...........

:program:`CASVB` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`JOBIPH`,
(for more information see :numref:`UG:sec:files_list`), and
:file:`VBWFN` with
valence bond wavefunction information (orbital and structure coefficients).

Output files
............

.. class:: filelist

:file:`JOBIPH`
  On exit, the :program:`RASSCF` interface file is overwritten with the
  CASVB wavefunction.

:file:`VBWFN`
  Valence bond wavefunction information (orbital and structure coefficients).

.. _UG\:sec\:casvb_input:

.. index::
   pair: Input; CASVB

Input
-----

This section describes the input to the :program:`CASVB` program.
The input for each module is preceded by its name like: ::

 &CASVB

.. index::
   pair: Keywords; CASVB

Keywords
........

Optional keywords

.. class:: keywordlist

:kword:`END of Input`
  This marks the end of the input to the program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="END" APPEAR="End of input" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: END of Input <basic>
              <HELP>
              This marks the end of the input to the program and is the only compulsory
              keyword.
              </HELP>
              </KEYWORD>

Optional keywords to define the CASSCF wavefunction. Not generally required
because values stored in the job interface
file or used by the :program:`RASSCF` program will normally be appropriate.

.. class:: keywordlist

:kword:`FROZen`
  Specifies frozen orbitals, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="FROZEN" APPEAR="Frozen orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" MIN_VALUE="0">
              %%Keyword: FROZen <advanced>
              <HELP>
              Specifies frozen orbitals, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

:kword:`INACtive`
  Specifies inactive orbitals, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="INACTIVE" APPEAR="Inactive orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="ADVANCED" MIN_VALUE="0">
              %%Keyword: INACtive <advanced>
              <HELP>
              Specifies inactive orbitals, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

:kword:`NACTel`
  Specifies the number of active electrons, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NACTEL" APPEAR="Active electrons" KIND="INTS" SIZE="3" LEVEL="ADVANCED" MIN_VALUE="0">
              %%Keyword: NACTel <advanced>
              <HELP>
              Specifies number of active electrons, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

:kword:`RAS2`
  Specifies RAS2 orbitals, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="RAS2" APPEAR="RAS2" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="NSYM" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: RAS2 <advanced>
              <HELP>
              Specifies RAS2 orbitals, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

:kword:`SPIN`
  Specifies the total spin, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SPIN" APPEAR="Spin" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="1" MIN_VALUE="1">
              %%Keyword: SPIN <advanced>
              <HELP>
              Specifies the total spin, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

:kword:`SYMMetry`
  Specifies the CASSCF wavefunction symmetry, as in the :program:`RASSCF` program.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SYMMETRY" APPEAR="Symmetry" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="1" MIN_VALUE="1" MAX_VALUE="8">
              %%Keyword: SYMMetry <advanced>
              <HELP>
              Specifies the CASSCF wavefunction symmetry, as in the RASSCF program. This
              keyword is generally not required because the value stored in the job
              interface file or used by the RASSCF program will normally be appropriate.
              </HELP>
              </KEYWORD>

Optional keywords to define the VB wavefunction

.. class:: keywordlist

:kword:`CON`
  .. index::
     single: CON

  The spatial
  VB configurations are defined in terms of the active orbitals, and may be
  specified using one or more :kword:`CON` keywords: ::

    CON
    n1 n2 n3 n4 ...

  The configurations can be specified by occupation numbers, so that
  :math:`n_i` is the occupation of the :math:`i`\th valence bond orbital. Alternatively a list of
  :math:`N_{\text{act}}` orbital numbers (in any order) may be provided --- the
  program determines which definition applies. The two specifications ``1 0 1 2``
  and ``1 3 4 4`` are thus equivalent.

  Input configurations are reordered by :program:`CASVB`, so that configurations have
  non-decreasing double occupancies. Configurations that are inconsistent with the
  value for the total spin are ignored.

  If no configurations are specified the single "covalent" configuration
  :math:`\phi_1\phi_2\cdots\phi_{N_{\text{act}}}` is assumed.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="CON" APPEAR="Configurations" LEVEL="BASIC" KIND="STRING">
              %%Keyword: CON <basic>
              <HELP>
              Specifies spatial VB configurations in terms of the active orbitals.
              The default is a single configuration of singly-occupied orbitals.
              </HELP>
              </KEYWORD>

:kword:`COUPle`
  .. index::
     single: COUPLE

  ::

    COUPLE
    key

  ``key`` may be chosen from ``KOTANI`` (default), ``SERBER``, ``RUMER``, ``PROJECT`` or ``LTRUMER``,
  specifying the scheme for constructing the
  spin eigenfunctions used in the definition of valence bond structures. ``PROJECT``
  refers to spin functions generated using a spin projection operator, ``LTRUMER`` to
  Rumer functions with the so-called "leading term" phase convention.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="COUPLE" APPEAR="Couple scheme" LEVEL="ADVANCED" KIND="CHOICE" LIST="KOTANI,SERBER,RUMER,PROJECT,LTRUMER" DEFAULT_VALUE="KOTANI">
              %%Keyword: COUPle <advanced>
              <HELP>
              Specifies the scheme for constructing the spin eigenfunctions to be used.
              Possible values: KOTANI (default), SERBER, RUMER, PROJECT, LTRUMER
              </HELP>
              </KEYWORD>

:kword:`WAVE`
  .. index::
     single: WAVE

  ::

    WAVE
    N S1 S2 ...

  This keyword can be used to specify explicitly the number of electrons and spin(s) to
  be used with a configuration list. If :math:`N` is less than the present number of active electrons,
  the input wavefunction fragment is assumed to form part of a direct product. Otherwise, the spins
  specified may be greater than or equal to the :kword:`SPIN` value specified as input to the :program:`RASSCF`
  program. Defaults, for both :math:`N` and :math:`S`, are the values used by :program:`RASSCF`.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="WAVE" APPEAR="Wavefunction" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: WAVE <advanced>
              <HELP>
              Specifies number of electrons and spins to be used with a configuration list.
              Defaults are the values used by RASSCF.
              </HELP>
              </KEYWORD>

Optional keywords for the recovery and/or storage of orbitals and vectors

.. class:: keywordlist

:kword:`STARt`
  .. index::
     single: START

  ::

    START
    key-1=filename-1
    key-2=filename-2
    ...

  Specifies input files for VB wavefunction (``key-i``\=VB),
  CASSCF CI vector (``key-i``\=CI) and/or CASSCF molecular orbitals
  (``key-i``\=MO).
  By default, the required information is taken from the file :file:`JOBOLD`.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="START" APPEAR="Input files" LEVEL="ADVANCED" KIND="UNKNOWN">
              %%Keyword: STARt <advanced>
              <HELP>
              Specifies various input files. Default is to take the required information
              from JOBOLD.
              </HELP>
              </KEYWORD>

:kword:`SAVE`
  .. index::
     single: SAVE

  ::

    SAVE
    key-1=filename-1
    key-2=filename-2
    ...

  Specifies output files for VB wavefunction (``key-i``\=VB)
  and/or the VB CI vector (``key-i``\=VBCI). By default, the VB CI
  vector is written to the file JOBIPH.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SAVE" APPEAR="Output files" LEVEL="ADVANCED" KIND="UNKNOWN">
              %%Keyword: SAVE <advanced>
              <HELP>
              Specifies output files. By default, the VB CI vector is written to the
              file JOBIPH.
              </HELP>
              </KEYWORD>

Optional keywords to override the starting guess

.. class:: keywordlist

:kword:`GUESs`
  .. index::
     single: GUESS

  ::

    GUESS
    key-1 ...
    key-2 ...
    ENDGUESs

  The :kword:`GUESS` keyword initiates the input of a guess for the valence bond orbitals and/or
  structure coefficients. ``key-i`` can be either :kword:`ORB` or :kword:`STRUC`.
  These keywords
  modify the guess provided by the program. It is
  thus possible to modify individual orbitals in a previous solution
  so as to construct the starting
  guess. The :kword:`ENDGUESs` keyword terminates the guess input. ::

    ORB
    i c1 c2 ... cmact

  Specifies a starting guess for valence bond orbital number :math:`i`. The guess is specified
  in terms of the :math:`m_{\text{act}}` active MOs defining the CASSCF wavefunction. ::

    STRUC
    c1 c2 ... cNVB

  Specifies a starting guess for the :math:`N_{\text{VB}}` structure coefficients. If this keyword
  is not provided, the perfect-pairing mode of
  spin coupling is assumed for the spatial configuration having the least
  number of doubly occupied orbitals.
  Note that the definition of structures depends on the value of :kword:`COUPLE`. Doubly occupied
  orbitals occur first in all configurations, and the spin eigenfunctions are based on the singly
  occupied orbitals being in ascending order.

  .. xmldoc:: <GROUP MODULE="CASVB" NAME="GUESS" APPEAR="Guess" KIND="BLOCK" LEVEL="BASIC">

  .. xmldoc:: %%Keyword: GUESs <basic>
              <HELP>
              Initiates guess input. Sub-keywords are ORB and STRUC, as described in the
              manual. The ENDGUESs keyword terminates the guess input.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ORB" APPEAR="Orbital" LEVEL="BASIC" KIND="CUSTOM" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="STRUC" APPEAR="Structure" LEVEL="BASIC" KIND="UNKNOWN" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="AOBASIS" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

  .. xmldoc:: </GROUP>

:kword:`ORBPerm`
  .. index::
     single: ORBPERM

  ::

    ORBPERM
    i1 ... imact

  Permutes the orbitals in the valence bond wavefunction and changes their phases according to
  :math:`\phi_j'=\sign(i_j)\phi_{\abs(i_j)}`. The guess may be further modified using the
  :kword:`GUESS` keyword. Additionally, the structure coefficients will be transformed
  according to the given permutation (note that the configuration list must be closed under
  the orbital permutation for this to be possible).

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ORBPERM" APPEAR="Orbital permutation" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: ORBPerm <advanced>
              <HELP>
              Permutes the VB orbitals, and modifies phases, as described in the manual.
              </HELP>
              </KEYWORD>

Optional keywords for optimization control

.. class:: keywordlist

:kword:`CRIT`
  .. index::
     single: CRIT

  ::

    CRIT
    method

  .. compound::

    Specifies the criterion for the optimization. ``method`` can be :kword:`OVERLAP` or :kword:`ENERGY`
    (:kword:`OVERLAP` is default).
    The former maximizes the normalized overlap with the CASSCF wavefunction:

    .. math:: \max\left(\frac{\braket{\Psi_{\text{CAS}}}{\Psi_{\text{VB}}}} {\left(\braket{\Psi_{\text{VB}}}{\Psi_{\text{VB}}}\right)^{1/2}}\right)

    and the latter simply minimizes the energy:

    .. math:: \min\left(\frac{\braopket{\Psi_{\text{VB}}}{\hat{H}}{\Psi_{\text{VB}}}}{\braket{\Psi_{\text{VB}}}{\Psi_{\text{VB}}}}\right).

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="CRIT" APPEAR="Optimization criterion" LEVEL="BASIC" KIND="CHOICE" LIST="OVERLAP,ENERGY" DEFAULT_VALUE="OVERLAP">
              %%Keyword: CRIT <basic>
              <HELP>
              Defines the optimization criterion.
              Possible values: OVERLAP (default) or ENERGY.
              </HELP>
              </KEYWORD>

:kword:`MAXIter`
  .. index::
     single: MAXITER

  ::

    MAXITER
    Niter

  Specifies the maximum number of iterations in the second-order optimizations. Default is :math:`N_{\text{iter}}`\=50.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="MAXITER" APPEAR="Maximum iterations" LEVEL="ADVANCED" KIND="INT" DEFAULT_VALUE="50" MIN_VALUE="1">
              %%Keyword: MAXIter <advanced>
              <HELP>
              Specifies the maximum number of iterations to be used. Default value is 50.
              </HELP>
              </KEYWORD>

:kword:`(NO)CASProj`
  .. index::
     single: CASPROJ
     single: NOCASPROJ

  ::

    (NO)CASPROJ

  With this keyword the structure coefficients are picked from the transformed CASSCF CI vector, leaving
  only the orbital variational parameters. For further details see the bibliography.
  This option may be useful to aid convergence.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="CASPROJ" APPEAR="CAS proj" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="NOCASPROJ,NOPROJCAS">
              %%Keyword: CASProj <advanced>
              <HELP>
              Defines structure coefficients from transformed CASSCF wavefunction.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NOCASPROJ" APPEAR="No CAS proj" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="CASPROJ,PROJCAS">
              %%Keyword: NOCASProj <advanced>
              <HELP>
              Disables CASProj
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="PROJCAS" LEVEL="UNDOCUMENTED" KIND="SINGLE" EXCLUSIVE="NOCASPROJ,NOPROJCAS" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NOPROJCAS" LEVEL="UNDOCUMENTED" KIND="SINGLE" EXCLUSIVE="CASPROJ,PROJCAS" />

:kword:`SADDle`
  .. index::
     single: SADDLE

  ::

    SADDLE
    n

  Defines optimization onto an :math:`n`\th-order saddle point.
  See also :cite:`casvb5`.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SADDLE" APPEAR="Saddle point" LEVEL="ADVANCED" KIND="INT" MIN_VALUE="1">
              %%Keyword: SADDLe <advanced>
              <HELP>
              Defines optimization onto an n-th order saddle point.
              </HELP>
              </KEYWORD>

:kword:`(NO)INIT`
  .. index::
     single: INIT
     single: NOINIT

  ::

    (NO)INIT`

  Requests a sequence of preliminary optimizations which aim to minimize the
  computational cost while maximizing the likelihood of stable
  convergence. This feature is the default if no wavefunction guess is available
  and no :kword:`OPTIM` keyword specified in the input.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="INIT" APPEAR="Initial optimizations" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="NOINIT">
              %%Keyword: INIT <advanced>
              <HELP>
              Requests a sequence of preliminary optimizations which aim to minimize
              the computational cost while maximizing the likelihood of stable
              convergence. This is the default behaviour when no wavefunction guess is
              available and no OPTIM keyword has been specified.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NOINIT" APPEAR="No initial optimizations" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="INIT">
              %%Keyword: NOINIT <advanced>
              <HELP>
              Disables INIT
              </HELP>
              </KEYWORD>

:kword:`METHod`
  .. index::
     single: METHOD

  ::

    METHOD
    key

  Selects the optimization algorithm to be used. ``key`` can be one
  of: :kword:`FLETCHER`, :kword:`TRIM`, :kword:`TRUSTOPT`, :kword:`DAVIDSON`,
  :kword:`STEEP`, :kword:`VB2CAS`, :kword:`AUGHESS`, :kword:`AUG2`,
  :kword:`CHECK`, :kword:`DFLETCH`, :kword:`NONE`, or :kword:`SUPER`. Recommended are
  the direct procedures :kword:`DFLETCH` or :kword:`AUGHESS`. For general
  saddle-point optimization :kword:`TRIM` is used. Linear (CI only) optimization
  problems use :kword:`DAVIDSON`. :kword:`NONE` suspends optimization, while
  :kword:`CHECK` carries out a finite-difference check of the gradient and Hessian.

  The default algorithm chosen by :program:`CASVB` will be usually be adequate.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="METHOD" APPEAR="Method" LEVEL="ADVANCED" KIND="CHOICE" LIST="FLETCHER,TRIM,TRUSTOPT,DAVIDSON,STEEP,VB2CAS,AUGHESS,AUG2,CHECK,DFLETCH,NONE,SUPER">
              %%Keyword: METHod <advanced>
              <HELP>
              Selects optimization algorithm.
              Possible values: FLETCHER, TRIM, TRUSTOPT, DAVIDSON, STEEP, VB2CAS,
              AUGHESS, AUG2, CHECK, DFLETCH, NONE or SUPER.
              The default algorithm chosen by CASVB will usually be adequate.
              </HELP>
              </KEYWORD>

:kword:`TUNE`
  .. index::
     single: TUNE

  ::

    TUNE
    ...

  Enables the input of individual parameters to be used in the optimization procedure
  (*e.g.* for controlling step-size selection and convergence testing).
  Details of the values used are output if ``print(3)`` :math:`\geq` 3 is specified.
  For expert use only.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="TUNE" APPEAR="Tune" LEVEL="ADVANCED" KIND="UNKNOWN">
              %%Keyword: TUNE <advanced>
              <HELP>
              Enables the input of individual parameters to be used in the optimization procedure. Expert use only. See manual.
              </HELP>
              </KEYWORD>

:kword:`OPTIm`
  .. index::
     single: OPTIM

  More than one optimization may be performed in the same :program:`CASVB` run,
  by the use of :kword:`OPTIM` keywords: ::

    OPTIM
    [...
    ENDOPTIM]

  The subcommands may be any optimization declarations defined in this
  section, as well as any symmetry or constraints specifications.
  Commands given as arguments to :kword:`OPTIM`
  will apply only to this optimization step, whereas commands specified
  outside will act as default definitions for all subsequent :kword:`OPTIM`
  specifications.

  The :kword:`OPTIM` keyword
  need not be specified if only one optimization step is required,

  When only a machine-generated guess is available, :program:`CASVB` will
  attempt to
  define a sequence of optimization steps that aims to maximize the
  likelihood of successful convergence (while minimizing
  CPU usage). To override this behaviour, simply specify one or more
  :kword:`OPTIM` keywords. The :kword:`ENDOPTIm` keyword marks the end of the
  specifications of an optimization step.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="OPTIM" APPEAR="Optimizations" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: OPTIm <advanced>
              <HELP>
              Defines one or more optimization steps. Subcommands can be any
              optimization declarations, as well as any symmetry or constraints
              specifications. Usually omitted if only one optimization step is required.
              Terminated by the keyword ENDOPTIm.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ENDOPTIM" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`ALTErn`
  .. index::
     single: ALTERN

  A loop over two or more optimization steps may be specified using: ::

    ALTERN
    Niter
    ...
    ENDALTERN

  The program will repeat the specified optimization steps
  until either all optimizations have converged, or the maximum iteration count,
  :math:`N_{\text{iter}}`, has been reached.
  The :kword:`ENDALTErn` keyword marks the end of the specification of an
  ALTERN loop.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ALTERN" APPEAR="Alternate" LEVEL="ADVANCED" KIND="UNKNOWN">
              %%Keyword: ALTErn <advanced>
              <HELP>
              Defines alternating optimizations over two or more optimization steps (see
              manual). Terminated by the ENDALTErn keyword.
              </HELP>
              </KEYWORD>

Optional keywords for definitions of molecular symmetry and any
constraints on the VB wavefunction

.. class:: keywordlist

:kword:`SYMElm`
  .. index::
     single: SIMELM

  Various issues associated with symmetry-adapting valence bond wavefunctions
  are considered, for example, in :cite:`casvb6`. ::

    SYMELM
    label sign

  Initiates the definition of a symmetry operation referred to by ``label`` (any three characters).
  ``sign`` can be :math:`+` or :math:`-`; it specifies whether the total wavefunction is symmetric or
  antisymmetric under this operation, respectively. A value for ``sign`` is not always necessary
  but, if provided, constraints will be put on the structure coefficients to ensure that the
  wavefunction has the correct overall symmetry (note that the configuration list must be closed
  under the orbital permutation induced by ``label`` for this to be possible).
  The default for ``label`` is the identity.

  The operator is defined in terms of its action on the active MOs as specified by
  one or more of the keywords :kword:`IRREPS`, :kword:`COEFFS`, or :kword:`TRANS`. Any
  other keyword, including optional use of the :kword:`ENDSYMElm` keyword, will
  terminate the definition of this symmetry operator. ::

    IRREPS
    i1 i2 ...

  The list :math:`i_1, i_2 \ldots` specifies which irreducible representations (as defined in
  the CASSCF wavefunction) are antisymmetric with respect to the ``label`` operation.
  If an irreducible representation is not otherwise specified it is assumed to be symmetric
  under the symmetry operation. ::

    COEFFS
    i1 i2 ...

  The list :math:`i_1, i_2 \ldots` specifies which individual CASSCF MOs are antisymmetric with
  respect to the ``label`` operation. If an MO is not otherwise specified, it is assumed to be
  symmetric under the symmetry operation. This specification may be useful if, for example, the
  molecule possesses symmetry higher than that exploited in the CASSCF calculation. ::

    TRANS
    ndim i1 ... indim c1,1 c1,2 ... cndim,ndim

  Specifies a general :math:`n_{\text{dim}}\times n_{\text{dim}}` transformation involving the MOs :math:`i_1,
  \ldots i_{n_{\text{dim}}}`,
  specified by the :math:`c` coefficients. This may be useful for systems with a two- or
  three-dimensional irreducible representation, or if localized orbitals define the CASSCF
  wavefunction. Note that the specified transformation must always be orthogonal.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SYMELM" APPEAR="Symmetry elements" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: SYMElm <advanced>
              <HELP>
              Initiates the definition of a symmetry operation (see manual).
              Sub-keywords are IRREPS, COEFFS, or TRANS. Terminated with ENDSYMElm.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="IRREPS" LEVEL="UNDOCUMENTED" KIND="INTS_LOOKUP" SIZE="ANY" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="COEFFS" LEVEL="UNDOCUMENTED" KIND="INTS_LOOKUP" SIZE="ANY" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ENDSYMELM" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`ORBRel`
  .. index::
     single: ORBREL

  In general, for a VB wavefunction to be symmetry-pure, the orbitals must form a representation
  (not necessarily irreducible) of the symmetry group. Relations between orbitals under
  the symmetry operations defined by :kword:`SYMELM` may be specified according to: ::

    ORBREL
    i1 i2 label-1 label-2 ...

  Orbital :math:`i_1` is related to orbital :math:`i_2` by the sequence of operations defined by the ``label``
  specifications (defined previously using :kword:`SYMELM`). The operators operate right to left. Note
  that :math:`i_1` and :math:`i_2` may coincide. Only the minimum number of
  relations required to define all the orbitals should be provided; an error exit
  will occur if redundant :kword:`ORBREL` specifications are found.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ORBREL" APPEAR="Orbital relations" LEVEL="ADVANCED" KIND="CUSTOM">
              %%Keyword: ORBRel <advanced>
              <HELP>
              Specifies the relationship between two VB orbitals under symmetry
              operation(s) defined by SYMElm. See manual.
              </HELP>
              </KEYWORD>

:kword:`(NO)SYMProj`
  .. index::
     single: SYMPROJ
     single: NOSYMPROJ

  As an alternative to incorporating constraints, one may also ensure correct
  symmetry of the wavefunction by use of a projection operator: ::

    (NO)SYMPROJ
    [irrep-1 irrep-2 ...]

  The effect of this keyword is to set to zero the coefficients in unwanted
  irreducible representations.
  For this purpose, the symmetry group defined for the CASSCF wavefunction
  is used (always a subgroup of :math:`D_{2h}`).
  The list of irreps in the command specifies which components
  of the wavefunction should be kept.
  If no irreducible representations are given, the current
  wavefunction symmetry is assumed. In a state-averaged calculation,
  all irreps are retained for which a non-zero weight has been specified in the
  wavefunction definition.
  The :kword:`SYMPROJ` keyword may also be used in combination with constraints.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SYMPROJ" APPEAR="Symmetry projection" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="NSYM" EXCLUSIVE="NOSYMPROJ">
              %%Keyword: SYMProj <advanced>
              <HELP>
              Projects the VB wavefunction onto given irrep(s). See manual.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NOSYMPROJ" APPEAR="No symmetry projection" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="NSYM" EXCLUSIVE="SYMPROJ">
              %%Keyword: NoSYMProj <advanced>
              <HELP>
              Disables SYMProj
              </HELP>
              </KEYWORD>

:kword:`FIXOrb`
  .. index::
     single: FIXORB

  ::

    FIXORB
    i1 i2 ...

  This command freezes the orbitals specified in the list
  :math:`i_1, i_2 \ldots` to that of the starting guess. Alternatively the
  special keywords :kword:`ALL` or :kword:`NONE` may be used. These orbitals
  are eliminated from the optimization procedure, but will still be
  normalized and symmetry-adapted according to any :kword:`ORBREL`
  keywords given.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="FIXORB" APPEAR="Freeze orbitals" LEVEL="ADVANCED" KIND="INTS_LOOKUP" SIZE="ANY">
              <ALTERNATE KIND="CUSTOM" />
              %%Keyword: FIXOrb <advanced>
              <HELP>
              Freezes a subset of VB orbitals (i1, i2, ...).
              </HELP>
              </KEYWORD>

:kword:`FIXStruc`
  .. index::
     single: FIXSTRUC

  ::

    FIXSTRUC
    i1 i2 ...

  Freezes the coefficients for structures :math:`i_1, i_2 \ldots`. Alternatively
  the special keywords :kword:`ALL` or :kword:`NONE` may be used. The
  structures are eliminated from the optimization procedure, but may
  still be affected by normalization or any symmetry keywords present.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="FIXSTRUC" APPEAR="Freeze coefficients" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: FIXStruc <advanced>
              <HELP>
              Freezes a subset of structure coefficients (i1, i2, ...).
              </HELP>
              </KEYWORD>

:kword:`DELStruc`
  .. index::
     single: DELSTRUC

  ::

    DELSTRUC
    i1 i2 ...

  Deletes the specified structures from the wavefunction. The
  special keywords :kword:`ALL` or :kword:`NONE` may be used. This specification should be compatible
  with the other structure constraints present, as defined by :kword:`SYMELM` and :kword:`ORBREL`.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="DELSTRUC" APPEAR="Delete structures" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: DELStruc <advanced>
              <HELP>
              Deletes a subset of structures from the wavefunction (i1, i2, ...). Other
              possible values: ALL or NONE.
              </HELP>
              </KEYWORD>

:kword:`ORTHcon`
  .. index::
     single: ORTHCON

  ::

    ORTHCON
    key-1 ...
    key-2 ...
    ...

  The :kword:`ORTHCON` keyword initiates the input of orthogonality
  constraints between pairs/groups of valence bond orbitals.
  The sub-keywords ``key-i`` can be any of :kword:`ORTH`, :kword:`PAIRS`,
  :kword:`GROUP`, :kword:`STRONG` or :kword:`FULL`. Orthogonality constraints
  should be used with discretion. Note that orthogonality constraints
  for an orbital generated from another by symmetry operations (using the
  :kword:`ORBREL` keyword) cannot in general be satisfied. The :kword:`ENDORTHcon`
  keyword can be used to terminate the input of orthogonality constraints. ::

    ORTH
    i1 i2 ...

  Specifies a list of orbitals to be orthogonalized. All overlaps
  between pairs of orbitals in the list are set to zero. ::

    PAIRS i1 i2 ...

  Specifies a simple list of orthogonalization pairs. Orbital :math:`i_1` is
  made orthogonal to :math:`i_2`, :math:`i_3` to :math:`i_4`, etc. ::

    GROUP label i1 i2 ...

  Defines an orbital group to be used with the :kword:`ORTH` or
  :kword:`PAIRS` keyword. The group is referred to by ``label`` which
  can be any three characters beginning with a letter a--z. Labels
  defining different groups can be used together or in combination
  with orbital numbers in :kword:`ORTH` or :kword:`PAIRS`.
  :math:`i_1, i_2 \ldots` specifies
  the list of orbitals in the group. Thus the combination
  :kword:`GROUP` AAA 1 2 :kword:`GROUP` BBB 3 4 :kword:`ORTH` AAA BBB will orthogonalize
  the pairs of orbitals 1--3, 1--4, 2--3 and 2--4. ::

    STRONG

  This keyword is short-hand for strong orthogonality. The only allowed
  non-zero overlaps are between pairs of orbitals (:math:`2n-1`, :math:`2n`). ::

    FULL

  This keyword is short-hand for full orthogonality and is mainly
  useful for testing purposes.

  .. xmldoc:: <GROUP MODULE="CASVB" NAME="ORTHCON" APPEAR="Orthogonality constraints" KIND="BLOCK" LEVEL="ADVANCED">

  .. xmldoc:: %%Keyword: ORTHcon <advanced>
              <HELP>
              Initiates input of orthogonality constraints information.
              Sub-keywords are ORTH, PAIRS, GROUP, STRONG and FULL, as described in the
              manual. The ENDORTHcon keyword terminates the ORTHcon input.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ORTH" APPEAR="Orbitals" LEVEL="ADVANCED" KIND="UNKNOWN" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="PAIRS" APPEAR="Pairs" LEVEL="ADVANCED" KIND="UNKNOWN" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="GROUP" APPEAR="Group" LEVEL="ADVANCED" KIND="UNKNOWN" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="STRONG" APPEAR="Strong orthogonality" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="FULL" />

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="FULL" APPEAR="Full orthogonality" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="STRONG" />

  .. xmldoc:: </GROUP>

Optional keywords for wavefunction analysis

.. class:: keywordlist

:kword:`CIWEights`
  .. index::
     single: CIWEIGHTS

  For further details regarding the calculation of weights in :program:`CASVB`, see
  :cite:`casvb7`. ::

    CIWEIGHTS
    key-1 key-2 ... [Nconf]

  Prints weights of the CASSCF wavefunction transformed
  to the basis of nonorthogonal VB structures. For the ``key-i`` options
  see :kword:`VBWEIGHTS` below. Note that the evaluation of inverse overlap
  weights involves an extensive computational overhead for large active
  spaces. Weights are given for the
  total CASSCF wavefunction, as well as the orthogonal complement to
  :math:`\Psi_{\text{VB}}`. The default for the number of configurations requested,
  :math:`N_{\text{conf}}`, is 10. If :math:`N_{\text{conf}} = -1` all configurations are
  included.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="CIWEIGHTS" APPEAR="Print CI weights" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: CIWEights <advanced>
              <HELP>
              Prints weights of VB structures in the CASSCF wavefunction. Options are
              the same as for VBWEights.
              </HELP>
              </KEYWORD>

:kword:`REPOrt`
  .. index::
     single: REPORT

  ::

    REPORT
    [...
    ENDREPORT]

  Outputs orbital/structure coefficients and derived information.
  The :kword:`ENDREPOrt` keyword can be used to mark the end of the specification
  of a report step.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="REPORT" APPEAR="Report" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: REPOrt <advanced>
              <HELP>
              Outputs orbital/structure coefficients and derived information. Terminated
              by ENDREPOrt.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="ENDREPORT" LEVEL="UNDOCUMENTED" KIND="SINGLE" />

:kword:`(NO)SCORr`
  .. index::
     single: SCORR
     single: NOSCORR

  ::

    (NO)SCORR

  With this option, expectation values of the spin operators
  :math:`(\hat{s}_\mu+\hat{s}_\nu)^2` are evaluated for all pairs of :math:`\mu` and
  :math:`\nu`. Default is :kword:`NOSCORR`. The procedure is described in
  :cite:`casvb8,casvb9,casvb10`.

  This analysis is currently only implemented for spin-coupled wavefunctions.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SCORR" APPEAR="Spin values" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="NOSCORR">
              %%Keyword: SCORr <advanced>
              <HELP>
              Performs spin-correlation analysis. Only implemented for spin-coupled
              wavefunctions
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="NOSCORR" APPEAR="No spin values" LEVEL="ADVANCED" KIND="SINGLE" EXCLUSIVE="SCORR">
              %%Keyword: NOSCORr <advanced>
              <HELP>
              Disables SCORr
              </HELP>
              </KEYWORD>

:kword:`VBWEights`
  .. index::
     single: VBWEIGHTS

  For further details regarding the calculation of weights in :program:`CASVB`, see
  :cite:`casvb7`. ::

    VBWEIGHTS
    key-1 key-2 ...

  Calculates and outputs weights of the structures in the valence bond
  wavefunction :math:`\Psi_{\text{VB}}`. ``key-i`` specifies the definition of
  nonorthogonal weights to be used, and can be one of:

  :kword:`CHIRGWIN`
    Evaluates Chirgwin--Coulson weights (see :cite:`casvb11`).
  :kword:`LOWDIN`
    Performs a symmetric orthogonalization of the
    structures and outputs the subsequent weights.
  :kword:`INVERSE`
    Outputs "inverse overlap populations" as in :cite:`casvb12`.
  :kword:`ALL`
    All of the above.
  :kword:`NONE`
    Suspends calculation of structure weights.

  The commands :kword:`LOWDIN` and :kword:`INVERSE` require the overlap matrix
  between valence bond structures, so that some additional computational
  overhead is involved.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="VBWEIGHTS" APPEAR="Print VB weights" LEVEL="ADVANCED" KIND="STRING">
              %%Keyword: VBWEights <advanced>
              <HELP>
              Prints weights of VB structures.
              Possible values CHIRGWIN, LOWDIN, INVERSE, ALL and NONE.
              </HELP>
              </KEYWORD>

Optional keywords for further general options

.. class:: keywordlist

:kword:`PREC`
  .. index::
     single: PREC

  ::

    PREC
    iprec iwidth

  Adjusts the precision for printed quantities. In most cases, ``iprec`` simply refers
  to the number of significant digits after the decimal point. Default is ``iprec``\=+8.
  ``iwidth`` specifics the maximum width of printed output, used when determining
  the format for printing arrays.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="PREC" APPEAR="Print precision" LEVEL="ADVANCED" KIND="INTS" SIZE="2" DEFAULT_VALUES="8,110" MIN_VALUE="0">
              %%Keyword: PREC <basic>
              <HELP>
              Adjusts the precision for printed quantities. See manual.
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  .. index::
     single: PRINT

  ::

    PRINT
    i1 i2 ...

  Each number specifies the level of output required at various stages of the execution, according to the
  following convention:

  .. container:: list

    **-1** No output except serious, or fatal, error messages.

    **0**  Minimal output.

    **1**  Standard level of output.

    **2**  Extra output.

  The areas for which output can be controlled are:
  :math:`i_1`

  .. container:: list

    :math:`i_1` Print of input parameters, wavefunction definitions, etc.

    :math:`i_2` Print of information associated with symmetry constraints.

    :math:`i_3` General convergence progress.

    :math:`i_4` Progress of the 2nd-order optimization procedure.

    :math:`i_5` Print of converged solution and analysis.

    :math:`i_6` Progress of variational optimization.

    :math:`i_7` File usage.

  For all, the default output level is +1. If :math:`i_5 \geq 2` VB orbitals will
  be printed in the AO basis (provided that the definition of MOs is
  available).

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="PRINTLEVELS" APPEAR="Print levels" LEVEL="BASIC" KIND="INTS" SIZE="7" DEFAULT_VALUES="1,1,1,1,1,1,1" MIN_VALUE="-1" MAX_VALUE="2">
              %%Keyword: PRINT <basic>
              <HELP>
              Controls the amount of output. See manual.
              </HELP>
              </KEYWORD>

:kword:`SHSTruc`
  Prints overlap and Hamiltonian matrices between VB structures.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="SHSTRUC" APPEAR="Print matrices" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: SHSTruc <advanced>
              <HELP>
              Prints overlap and Hamiltonian matrices between VB structures.
              </HELP>
              </KEYWORD>

:kword:`STATs`
  .. index::
     single: STATS

  ::

    STATS

  Prints timing and usage statistics.

  .. xmldoc:: <KEYWORD MODULE="CASVB" NAME="STATS" APPEAR="Print statistics" LEVEL="BASIC" KIND="SINGLE">
              %%Keyword: STATs <basic>
              <HELP>
              Prints timing and usage statistics.
              </HELP>
              </KEYWORD>

Input example
.............

.. extractfile:: ug/CASVB.input

  &seward
  symmetry
  x y
  basis set
  c.sto-3g....
  c 0 0 -0.190085345
  end of basis
  basis set
  h.sto-3g....
  h 0 1.645045225 1.132564974
  end of basis
  &scf
  occupied
  3 0 1 0
  &rasscf
  inactive
  1 0 0 0
  ras2
  3 1 2 0
  nactel
  6 0 0
  lumorb
  &casvb

.. index::
   single: CASVB; Plotting

Viewing and plotting VB orbitals
................................

In many cases it can be helpful to view the shape of the converged valence bond orbitals, and
Molcas therefore provides two facilities for doing this. For the Molden program, an interface file
is generated at the end of each :program:`CASVB` run (see also :numref:`UG:sec:Molden`).
Alternatively a :program:`CASVB` run may be followed by :program:`RASSCF` to get orbitals
(:numref:`UG:sec:rasscf`) and :program:`GRID_IT` with the :kword:`VB` specification
(:numref:`UG:sec:gridit`), in order to generate a three-dimensional grid, for viewing, for example,
with :program:`LUSCUS` program.

.. xmldoc:: </MODULE>
.. index::
   single: Program; MCLR
   single: MCLR

.. _UG\:sec\:mclr:

:program:`mclr`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MCLR">
            %%Description:
            <HELP>
            This program calculates the response of a SCF or MCSCF wave function
            and related second order properties.
            </HELP>

The :program:`mclr` program in |molcas| performs response calculations on
single and multiconfigurational SCF wave functions with the technique described
in :cite:`Bernhardsson:99a`.
The right hand side (RHS) and thus the perturbation has to be defined through a preceding
:program:`MCKINLEY` calculation. Second order derivatives are obtained from a :program:`MCKINLEY` and
a consecutive :program:`mclr` calculation, with a geometrical displacement as the external perturbation.
If the response of a geometrical perturbation is calculated, harmonic frequencies corresponding to
the most abundant masses are printed. :program:`MCLR` also calculates isotope shifted frequencies.
Per default, vibrational frequencies are calculated for all possible single isotopic substitutions.
:program:`MCLR` always calculates the response of an electric field and prints the polarizability.

Note that the user should not normally, for frequency calculations,
request the execution of this module since this will be automatic.

The :program:`mclr` code also calculates the Lagrangian multipliers required for a
SA-MCSCF single state gradient :cite:`Stalring:01a`, where the RHS is generated by the program itself.
Through an :program:`mclr` and a consecutive :program:`alaska` calculation, analytical gradients
of a SA-MCSCF state may be obtained. **Note** that :program:`alaska` will automatically run the :program:`mclr` module!
Thus, with :program:`slapaf` geometry optimizations of
excited MCSCF states can be performed.

The :program:`MCLR` program is based on the split GUGA formalism.
However, it uses determinant based algorithms to solve the configuration
interaction problem :cite:`rasdet`, in analogy to how it is done in the :program:`RASSCF`.
For spin symmetric wave function (:math:`M_S=0`) the time reversal symmetry is used, and the innermost loops are performed in
combinations instead of determinant.

The upper limit to the size of the CI wave function that can be
handled with the present program is about the same as for the :program:`RASSCF`.
The present version of the code is just able to handle CASSCF wave function, RASSCF
wave function will soon be included.

The orbital handling is based on a one index transformation technique.
The integrals is the transformed to occupied orbitals in two indexes,
this can be done directly or from disk based integrals generated by :program:`seward`.

.. _UG\:sec\:mclr_dependencies:

Dependencies
------------

To start the :program:`MCLR` module the one-electron integrals generated by
:program:`SEWARD` have to be available. Moreover, :program:`MCLR` requires
the wave function from a :program:`SCF` or :program:`RASSCF` calculation and
apart from in an evaluation of SA-MCSCF gradients, it also requires the differentiated integrals
from :program:`MCKINLEY`.

.. _UG\:sec\:mclr_files:

Files
-----

.. _UG\:sec\:mclr_input_files:

Input files
...........

:program:`MCLR` will use the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`ABDATA`,
:file:`RYSRW`, :file:`JOBIPH`, :file:`QDAT`, :file:`MOTRA`
(for more information see :numref:`UG:sec:files_list`).

.. _UG\:sec\:mclr_output_files:

Output files
............

.. class:: filelist

:file:`MCKINT`
  Communication file between :program:`mclr` and :program:`mckinley` and :program:`rassi`.

:file:`UNSYM`
  ASCII file where all essential information, like geometry, Hessian normal modes and dipole
  derivatives are stored.

:file:`MLDNFQ`
  Molden input file for harmonic frequency analysis.

.. _UG\:sec\:mclr_scratch_files:

Scratch files
.............

.. class:: filelist

:file:`TEMP0x`
  x=1,8 used for for integral transformation and storing half transformed integrals.

:file:`REORD`
  Used for storing data used in the transformation of CI vectors from determinant base to CSF base.

:file:`TEMPCIV`
  Exchange file for temporary storing the CI vectors during the PCG.

:file:`RESP`
  Binary file where the solution of the response equations are stored.

:file:`JOPR`
  Used for half transformed integrals in direct mode.

:file:`KOPR`
  Used for half transformed integrals in direct mode.

:file:`QDAT`
  Used for storing and transferring some data (FockI, FockA, Fock, Q). It is generated / read only if :kword:`TWOS` keyword is active.

:file:`MOTRA`
  Used for storing and transferring ERIs in MO bassis. It is generated / read only if :kword:`TWOS` keyword is active.

.. _UG\:sec\:mclr_input:

Input
-----

This section describes the input to the
:program:`MCLR` program in the |molcas| program system.
The input for each module is preceded by its name like: ::

  &MCLR

Optional keywords
.................

A list of these keywords is given below:

.. class:: keywordlist

:kword:`SALA`
  Makes :program:`MCLR` compute the Lagrangian multipliers for a state average
  MCSCF wave function. These multipliers are required by :program:`ALASKA`
  to obtain analytical gradients for an excited state, when the excited
  state is determined by a SA optimization. :kword:`SALA` has
  to be followed by an integer on the next line, specifying the
  excited state for which the gradient is required.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="SALA" APPEAR="SA-CASSCF Lagrangian: root selection" KIND="INT" LEVEL="BASIC">
              <HELP>
              Makes MCLR compute the Lagrangian multipliers for the specified root in a state average
              CASSCF wave function.
              </HELP>
              %%Keyword: Sala <basic>
              Makes MCLR compute the Lagrangian multipliers for a state average
              MCSCF wave function. These multipliers are required by ALASKA
              to obtain analytical gradients for an excited state, when the excited
              state is determined by a SA optimization. SALA has
              to be followed by an integer on the next line, specifying the
              excited state for which the gradient is required.
              </KEYWORD>
:kword:`CHOF`
  Makes :program:`MCLR`, in association with compute the Lagrangian multipliers for a state average
  MCSCF wave function and the RI option, to use the so-called Cho-FOCK algorithm, rather than the default Cho-MO algorthm.
  The Cho-Fock option is the fastest for calculations with large basis sets. For details consult the paper
  entitled "Analytical gradients of the state-average complete active space self-consistent field method with density fitting", doi.org/10.1063/1.4927228.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="CHOF" APPEAR="CHO-FOCK" KIND="SINGLE" LEVEL="BASIC">
              <HELP>
              Makes MCLR use the Cho-Fock algorithm in association with the RI option for the two-electron integrals
              CASSCF wave function.
              </HELP>
              %%Keyword: CHOF <basic>
              Makes MCLR, in association with compute the Lagrangian multipliers for a state average
              MCSCF wave function and the RI option, to use the so-called Cho-FOCK algorithm, rather than the default Cho-MO algorthm.
              The Cho-Fock option is the fastest for calculations with large basis sets. For details consult the paper
              entitled "Analytical gradients of the state-average complete active space self-consistent field method with density fitting", doi.org/10.1063/1.4927228.
              </KEYWORD>

:kword:`NAC`
  Like :kword:`SALA`, but for computing nonadiabatic couplings. It must
  be followed by two integers on the next line, specifying the states
  between which the coupling is required. Note that, unlike :kword:`SALA`,
  the numbering here is absolute, regardless of which roots are included
  in the state average.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="NAC" APPEAR="Nonadiabatic coupling: root selection" KIND="INTS" SIZE="2" LEVEL="BASIC">
              <HELP>
              Makes MCLR compute the Lagrangian multipliers for the nonadiabatic coupling
              between the specified roots in a state average CASSCF wave function.
              </HELP>
              </KEYWORD>
              %%Keyword: NAC <basic>
              Makes MCLR compute the Lagrangian multipliers for a coupling
              in a state average MCSCF wave function. These multipliers are required by ALASKA
              to obtain analytical nonadiabatic couplings between states.
              NAC has to be followed by two integers on the next line, specifying the
              states between which the nonadiabatic coupling is required.

:kword:`EXPDimension`
  Here follows the dimension of the explicit Hamiltonian used as preconditioner
  in the Preconditioned conjugate gradient algorithm. Default 100.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="EXPD" APPEAR="Explicit Hamiltonian dimension" KIND="INT" DEFAULT_VALUE="100" LEVEL="BASIC">
              <HELP>
              Specify the dimension of the explicit Hamiltonian used as preconditioner
              in the Preconditioned Conjugate Gradient algorithm.
              </HELP>
              %%Keyword: EXPDimension <advanced>
              Here follows the dimension of the explicit Hamiltonian used as preconditioner
              in the Preconditioned conjugate gradient algorithm. Default 100.
              </KEYWORD>

:kword:`ITERations`
  Specify the maximum number of iterations in the PCG. Default 200.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="ITER" APPEAR="PCG Iterations" KIND="INT" DEFAULT_VALUE="200" LEVEL="BASIC">
              %%Keyword: ITERations <advanced>
              <HELP>
              Specify the maximum number of iterations in the PCG. Default 200.
              </HELP>
              </KEYWORD>

:kword:`LOWMemory`
  Lowers the amount of memory used, by paging out the CI vectors on disk.
  This will lower the performance, but the program will need less memory.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="LOWM" APPEAR="Reduced memory usage" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: LOWMemory <advanced>
              <HELP>
              Lowers the amount of memory used, by paging out the CI vectors on disk.
              This will lower the performance, but the program will need less memory.
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  Raise the print level, default 0.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="PRINT" APPEAR="Print level" KIND="INT" DEFAULT_VALUE="0" LEVEL="ADVANCED">
              <HELP>
              Specify the general print level with an integer (0-99).
              </HELP>
              %%Keyword: PRINt <advanced>
              Raise the print level, default 0.
              </KEYWORD>

:kword:`RASSi`
  This keyword is used for transforming the CI vectors to split GUGA
  representation, and transforming the orbital rotations to AO basis,
  to make the response accessible for state interaction calculations.

  .. xmldoc:: %%Keyword: RASSi <advanced>
              This keyword is used for transforming the CI vectors to split GUGA
              representation, and transforming the orbital rotations to AO basis,
              to make the response accessible for state interaction calculations.

:kword:`SEWArd`
  Specify one particle operators, used as right hand side, form the :file:`ONEINT`
  file constructed by :program:`SEWARD`
  The keyword is followed by one row for each perturbation:
  LABEL symmetry Component

  .. xmldoc:: %%Keyword: SEWArd <advanced>
              Specify one particle operators, used as right hand side, form the ONEINT
              file constructed by SEWARD.
              The keyword is followed by one row for each perturbation:
              LABEL symmetry Component

:kword:`EndSeward`
  Marks the end of perturbation specifications read from :program:`SEWARD` :file:`ONEINT` file.

  .. xmldoc:: %%Keyword: EndSeward <advanced>
              Marks the end of perturbation specifications read from SEWARD ONEINT file.

:kword:`THREshold`
  Specify the convergence threshold for the PCG. Default is 1.0e-4.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="THRE" APPEAR="PCG Threshold" KIND="REAL" DEFAULT_VALUE="1.0D-4" LEVEL="BASIC">
              %%Keyword: THREshold <advanced>
              <HELP>
              Specify the convergence threshold for the PCG. Default is 1.0e-4.
              </HELP>
              </KEYWORD>

:kword:`DISOTOPE`
  Calculates frequencies modified for double isotopic substitution.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="DISO" APPEAR="Double isotopic substitutions" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: DISOtope <advanced>
              <HELP>
              Calculates frequencies modified for double isotopic substitution.
              </HELP>
              </KEYWORD>

:kword:`THERmochemistry`
  Request an user specified thermochemical analysis.
  The keyword must be followed by a line containing the Rotational Symmetry Number,
  a line containing the Pressure (in atm), and lines containing the Temperatures (in K)
  for which the thermochemistry will be calculated. The section is ended by the
  keyword "End of PT".

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="THERMO" APPEAR="Thermochemistry" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: THERM <advanced>
              <HELP>
              Request an user specified thermochemical analysis.
              The keyword is followed by the Rotational Symmetry Number,
              the Pressure (in atm), and lines containing the Temperatures (in K)
              for which the thermochemistry will be calculated.
              The section is ended by the keyword "End of PT".
              </HELP>
              </KEYWORD>

:kword:`TIME`
  Calculates the time dependent response of an electric periodic perturbation.
  The frequency of the perturbation should be specified on the following line.
  Used to calculated time dependent polarizabilities and required in
  a :program:`RASSI` calculation of two photon transition moments.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="TIME" APPEAR="Time dep. response" KIND="REAL" LEVEL="ADVANCED">
              <HELP>
              Activate time dependent response of an electronic periodic perturbation
              and specify the frequency of the perturbation.
              </HELP>
              %%Keyword: TIME <advanced>
              Calculates the time dependent response of an electric periodic perturbation.
              The frequency of the perturbation should be specified on the following line.
              Used to calculated time dependent polarizabilities and required in
              a RASSI calculation of two photon transition moments.
              </KEYWORD>

:kword:`MASS`
  Used to generate single and double (in conjunction with DISO) isotope
  shifted frequencies, with the isotope masses specified by the user.
  This implementation can be useful for example in calculating
  intermolecular frequencies which are contaminated by the BSSE.
  By setting the corresponding masses to very large numbers, ghost orbitals
  can be used in the frequency calculation.
  MASS needs the atomic label and the new mass in units of u (real), for each element of the molecule.

  .. xmldoc:: %%Keyword: MASS <advanced>
              Used to generate single and double (in conjunction with DISO) isotope
              shifted frequencies, with the isotope masses specified by the user.
              This implementation can be useful for example in calculating
              intermolecular frequencies which are contaminated by the BSSE.
              By setting the corresponding masses to very large numbers, ghost orbitals
              can be used in the frequency calculation.
              MASS needs the atomic label and the new mass in units of u (real), for each element of the molecule.

:kword:`TWOS`
  It is used to activate the two-step run of :program:`MCLR`, in connection to the computation of
  molecular gradients / NACs for SA-CASSCF wave function. The keyword takes two values: FIRST or SECOND.
  In the first MCLR run (i.e. TWOStep = FIRST), the MOTRA and QDAT files are generated. In the subsequent MCLR run
  (TWOstep=SECOND), the files MOTRA and QDAT are read and employed for the computation of the corresponding
  Lagrangian multipliers. This approach allows to reduce the input-output of data to/from disk during such calculations.

  .. xmldoc:: <KEYWORD MODULE="MCLR" NAME="TWOS" APPEAR="Two Step MCLR run" KIND="CHOICE" LIST="FIRST,SECOND" LEVEL="ADVANCED">
              <HELP>
              Activate the two-step run of MCLR, in connection to the computation of molecular gradients
              and NACs for SA-CASSCF wave function. Takes two values: FIRST or SECOND.
              </HELP>
              %%Keyword: TWOS <advanced>
              It is used to activate the two-step run of MCLR, in connection to the computation of
              molecular gradients / NACs for SA-CASSCF wave function. The keyword takes two values: FIRST or SECOND.
              In the first MCLR run (i.e. TWOStep = FIRST), the MOTRA and QDAT files are generated. In the subsequent MCLR run
              (TWOstep=SECOND), the files MOTRA and QDAT are read and employed for the computation of the corresponding
              Lagrangian multipliers. This approach allows to reduce the input-output of data to/from disk during such calculations.
              </KEYWORD>

Input example
.............

A default input for a harmonic frequency calculation. ::

  &MCLR

An input for a harmonic frequency calculation with modified isotopic masses
for hydrogen and oxygen. ::

  &MCLR
  MASS
  H   = 2.0079
  O   = 150000.998

Thermochemistry for an asymmetric top (Rotational Symmetry Number
= 1), at 1.0 atm and 273.15, 298.15, 398.15 and 498.15 K. ::

  &MCLR
  THERmochemistry
   1
   1.0
   273.15 ;  298.15 ;  398.15 ;  498.15
  End of PT

The time dependent response is calculated for a perturbation of frequency
0.2 au. ::

  &MCLR
  TIME = 0.2

.. compound::

  The input: ::

    &MCLR
    SALA  = 2

  computes the Lagrangian multipliers for state number 2 in the SA root.
  Note, that 2 refers to the SA root. Thus, if the ground state is not
  included in the SA, the numbering of roots in the CI root and SA root
  differ. With the following :program:`RASSCF` input: ::

    &RASSCF
    CiRoot
     2 3
     2 3
     1 1
    RlxRoot = 2

  :kword:`SALA 2` yields the gradient for CI root number 3. Geometry optimization
  of an excited SA-CASSCF state can be done normally using EMIL commands,
  and requires the use of the :kword:`RLXR` keyword in the :program:`RASSCF`
  input to specify the selected root to be optimized. An explicit input
  to :program:`MCLR` is not required but can be specified if default options
  are not appropriate.

.. xmldoc:: </MODULE>
.. index::
   single: Program; FALCON
   single: FALCON

.. _UG\:sec\:falcon:

:program:`falcon` |extramark|
=============================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:falcon_description:

Description
-----------

.. xmldoc:: <MODULE NAME="FALCON">
            %%Description:
            <HELP>
            FALCON calculates total energy and orbitals of the large system
            based on the fragment method.
            </HELP>

.. compound::

  :program:`FALCON` calculates total energy of the large system based on
  the fragment approach.
  Total energy of the whole system is calculated from total energies of
  fragments as follows,

  .. math:: E^{\text{whole}}=\sum C_i^{\text{fragment}} E_i^{\text{fragment}},

  where :math:`E_i^{\text{fragment}}` is the total energy of fragment :math:`i`, and
  :math:`C_i^{\text{fragment}}` is its coefficient.

.. compound::

  In addition to the total energy, :program:`FALCON` can calculate orbitals
  of the whole system.
  Fock matrix and overlap matrix of the whole system are calculated from
  ones of fragments using following equations,

  .. math:: \mat{F}^{\text{whole}}=\sum C_i^{\text{fragment}} \mat{F}_i^{\text{fragment}},

  and

  .. math:: \mat{S}^{\text{whole}}=\sum C_i^{\text{fragment}} \mat{S}_i^{\text{fragment}},

  where
  :math:`F_i` and :math:`S_i` are the Fock matrix and overlap matrix,
  respectively, of fragment :math:`i`.

.. compound::

  Then

  .. math:: \mat{F}\mat{C}=\mat{S}\mat{C}\mat{\varepsilon}

  is solved to obtain the orbitals, :math:`\mat{C}`, and orbitals energies,
  :math:`\mat{\varepsilon}`.

.. index::
   pair: Input; FALCON

.. _UG\:sec\:falcon_inpfalcon:

Input
-----

Below follows a description of the input to :program:`FALCON`.

The input for each module is preceded by its name like: ::

  &FALCON

Argument(s) to a keyword, either individual or composed by several entries,
can be placed in a separated line or in the same line separated by a semicolon.
If in the same line, the first argument requires an equal sign after the
name of the keyword.

Keywords
........

.. class:: keywordlist

:kword:`TITLe`
  One-line title.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              One line title.
              </HELP>
              </KEYWORD>

:kword:`FRAGment`
  Takes one, two or three argument(s).
  The first value (integer) defines the fragment number,
  the second value (real) determines coefficient,
  and the third value (integer) is the fragment number that is equivalent
  to this fragment when translational symmetry is used.
  A default for the second value is 1.0 where the first and third values have
  no default.
  Other keyword(s) specific to this fragment must follow this keyword.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="FRAGMENT" KIND="INT" LEVEL="BASIC">
              %%Keyword: Fragment <basic> GUI:keyword
              <HELP>
              Takes one, two or three argument(s).
              The first value defines the fragment number, the second value determines coefficient,
              and the third value is the fragment number that is equivalent to this fragment
              when translational symmetry is used.
              Other keyword(s) specific to this fragment must follow this keyword.
              </HELP>
              </KEYWORD>

:kword:`OPERator`
  A real value following this keyword represents a coefficient, :math:`C_i^{\text{fragment}}`,
  of fragment :math:`i` (current fragment), where :math:`i` is a value specified by FRAGMENT keyword.
  This keyword is equivalent with the second value of keyword, FRAGMENT.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="OPERATOR" KIND="REAL" LEVEL="BASIC">
              %%Keyword: Operator <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the number of fragments.
              </HELP>
              </KEYWORD>

:kword:`EQUIvalence`
  An integer, :math:`j`, following this keyword declares that current fragment
  is translationally equivalent with fragment :math:`j`, and information provided for
  fragment :math:`j` are tranfered to current fragment.
  This keyword is equivalent with the third value of keyword, FRAGMENT.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="EQUIVALENCE" KIND="INT" LEVEL="BASIC">
              %%Keyword: Equivalence <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the number of fragments.
              </HELP>
              </KEYWORD>

:kword:`TRANslate`
  Three real numbers following this keyword specifies the translational
  vector by which the current fragment is translated to give new coordinate.
  A unit of either bohr or angstrom can follow. The default unit is angstrom.
  This keyword takes effect only when the equivalent fragment is specified.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="TRANSLATE" KIND="REALS" SIZE="3" LEVEL="BASIC">
              %%Keyword: Translate <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the number of fragments.
              </HELP>
              </KEYWORD>

:kword:`RUNFile`
  Following this keyword specifies the name of RunFile file for the
  corresponding fragment.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="RUNFILE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: RunFile <basic> GUI:keyword
              <HELP>
              Following this keyword specifies the name of RunFile file for the
              corresponding fragment.
              </HELP>
              </KEYWORD>

:kword:`ONEInt`
  Following this keyword specifies the name of OneInt file for the
  corresponding fragment.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="ONEINT" KIND="STRING" LEVEL="BASIC">
              %%Keyword: OneInt <basic> GUI:keyword
              <HELP>
              Following this keyword specifies the name of OneInt file for the
              corresponding fragment.
              </HELP>
              </KEYWORD>

:kword:`NFRAgment`
  An integer following this keyword specifies the number of fragments.
  If this keyword is not given, the largest fragment number given by
  FRAGMENT keyword is set to be the number of fragment.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="NFRAGMENT" KIND="INT" LEVEL="BASIC">
              %%Keyword: nFragment <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the number of fragments.
              </HELP>
              </KEYWORD>

:kword:`NIRRep`
  An integer following this keyword specifies the number of irreducible
  representation of point group symmetry.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="NIRREP" KIND="INT" LEVEL="BASIC">
              %%Keyword: nIrrep <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the number of irreducible
              representation of point group symmetry.
              </HELP>
              </KEYWORD>

:kword:`OCCUpation`
  A list of integer(s) following this keyword specifies the number of
  occupied orbitals in each symmetry representation in the unfragmented
  system.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="OCCUPATION" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="BASIC">
              %%Keyword: Occupation <basic> GUI:keyword
              <HELP>
              A list of integer(s) following this keyword specifies the number of
              occupied orbitals in each symmetry representation.
              </HELP>
              </KEYWORD>

:kword:`DISTance`
  A real number following this keyword specifies the distance
  of two atoms that are equivalent to each other, followed by a unit that
  is eather angstrom or bohr.
  Default is angstrom.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="DISTANCE" KIND="REAL" LEVEL="BASIC">
              %%Keyword: Distance <basic> GUI:keyword
              <HELP>
              A real number following this keyword specifies the distance
              of two atoms that are equivalent to each other.
              </HELP>
              </KEYWORD>

:kword:`NEAR`
  A real number following this keyword specifies the distance
  of two atoms within which atoms are considered to be too close each other.
  An unit that is eather angstrom or bohr can follow.
  Default is angstrom.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="NEAR" KIND="REAL" LEVEL="BASIC">
              %%Keyword: Near <basic> GUI:keyword
              <HELP>
              A real number following this keyword specifies the distance
              of two atoms within which atoms are considered to be too close each other.
              </HELP>
              </KEYWORD>

:kword:`PRINt`
  An integer following this keyword specifies the format of orbital print out.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="PRINT" KIND="INT" LEVEL="BASIC">
              %%Keyword: Print <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the format of orbital
              print out.
              </HELP>
              </KEYWORD>

:kword:`ORBEne`
  A real number follwing this keyword stands for the threshold for orbital print
  out.
  The orbitals with orbital energy below this value are print out.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="ORBENE" KIND="REAL" LEVEL="BASIC">
              %%Keyword: OrbEne <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the format of orbital
              print out.
              </HELP>
              </KEYWORD>

:kword:`ORBOcc`
  A real number follwing this keyword stands for the threshold for orbital print
  out.
  The orbitals with occupation number above this value are print out.

  .. xmldoc:: <KEYWORD MODULE="FALCON" NAME="ORBOCC" KIND="REAL" LEVEL="BASIC">
              %%Keyword: OrbOcc <basic> GUI:keyword
              <HELP>
              An integer following this keyword specifies the format of orbital
              print out.
              </HELP>
              </KEYWORD>

Input examples
..............

.. compound::

  Below shows an example of input file for the three fragment system of which
  energy, :math:`E^{\text{whole}}`, is written as

  .. math:: E^{\text{whole}}= E_1^{\text{fragment}} + E_2^{\text{fragment}} - E_3^{\text{fragment}},

  by fragment energies, :math:`E_1^{\text{fragment}}`, :math:`E_2^{\text{fragment}}`, and :math:`E_3^{\text{fragment}}`. ::

    &FALCON
    Fragment=1,  1.0
    Fragment=2,  1.0
    Fragment=3, -1.0

  which can be simplified as, ::

    &FALCON
    Fragment=3, -1.0

The next example is a two fragment system in which fragment 1 and fragment 2
are equivalent except for their positons.
When their difference in position is described by a vector, (1.0, 1.0, -1.0),
a translational symmetry can be used and the input becomes as follows, ::

  &FALCON
  Fragment=2, 1.0, 1
  Translate=1.0, 1.0, -1.0

.. compound::

  If the total energy of the whole system is given by the sum of total energies
  of three fragment,

  .. math:: E^{\text{whole}}= E_1^{\text{fragment}} + E_2^{\text{fragment}} + E_3^{\text{fragment}},

  input is simplly as follows, ::

    &FALCON
    nFragment=3

.. xmldoc:: </MODULE>
.. index::
   single: Program; MPSSI
   single: MPSSI

.. _UG\:sec\:mpssi:

:program:`mpssi`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MPSSI">
            %%Description:
            <HELP>
            %%Description:
            In analogy to the RASSI program, the MPSSI program calculates overlaps, and matrix
            elements of one-electron operators, and of the electronic Hamiltonian,
            over a basis of matrix-product state (MPS) wave functions calculated by QCMaquis,
            which may each have its own
            independent set of orbitals. Energies and matrix elements are
            computed also for the non-interacting linear combinations of states,
            i.e., doing a limited CI using the MPS states as a non-orthogonal basis.
            MPSSI can be used to compute dipole oscillator strengths,
            spin-orbit interaction matrix elements as well as, for example, transition dipole
            moments for spin-orbit eigenstates.
            </HELP>

The
:program:`MPSSI` (MPS :index:`State Interaction`) program :cite:`knec16b` forms overlaps and
other :index:`matrix
elements <single: Matrix elements; DMRGSCF>` of the Hamiltonian and other operators
over a wave function basis, which consists of matrix-product state (MPS) wave functions,
each with an individual set of orbitals.
Following the philosophy of the :program:`RASSI` program, it is a generalized state-interaction approach
for both nonorthogonal and orthonormal spinfree
MPS wave functions which enables the evaluation of arbitrary one- and two-particle
transition matrix elements as well as, for example, matrix elements of the
spin-orbit coupling operator. For instance, diagonalization of the spin-orbit Hamiltonian
matrix yields spin-orbit coupled wave functions as linear combinations of the
uncoupled, spin-pure MPS states. The latter can (but do not have to) be obtained as
results from one or several DMRG-SCF orbital optimization calculations (see :program:`DMRGSCF`).

.. compound::

  Following the work of Malmqvist :cite:`Malmqvist:89`, the central element of the MPS-SI algorithm
  is the transformation of the bra and ket MPS wave functions to a biorthonormal basis
  representation. It is important to note that the latter transformation is not needed if
  the MPS wave functions considered for state interaction share a common MO basis.
  In this particular case, the MPS-SI program directly proceeds with the calculation of
  the reduced (transition) one- and two-particle density matrices. We emphasize that
  our approach is applicable to the general case with MPS wave functions built from
  mutually nonorthogonal molecular orbital bases. It therefore provides the desired
  flexibility to find the best individual molecular orbital basis to represent wave functions
  of different spin and/or spatial symmetry. After solving a generalized eigenvalue
  equation of the form

  .. math:: Hc = ESc
     :label: egv

  with the Hamiltonian matrix :math:`H` expressed in the basis of the DMRG-SCF MPS wave
  functions and the wave function overlap matrix :math:`S`, a set of fully orthogonal and noninteracting
  states are obtained as linear combinations of the DMRG-SCF MPS wave
  functions with the expansion coefficients given by :math:`c` in Eq. :eq:`egv`.

Apart from computing oscillator strengths, overlaps and Hamiltonian
matrix elements can be used to compute :index:`electron transfer rates <single: Electron transfer rate>`, or
to form :index:`quasi-diabatic states <single: Quasi-diabatic states>` and reexpress matrix elements over a
basis of such states.

Moreover, it is possible to "dress" the diagonal elements of the Hamiltonian in
Eq. :eq:`egv` for MPS-SI by adding a correlation-correction term obtained, for example,
from a preceding NEVPT2 calculation (see Section 6), by either using the :kword:`HDIAG` keyword
within the :program:`RASSI` module or provide the :file:`nevpt2.h5` wave function file as input

.. index::
   pair: Dependencies; MPSSI

.. _UG\:sec\:mpssi_dependencies:

Dependencies
------------

The :program:`MPSSI` program needs one or more :file:`dmrgscf.h5` files produced
by the :program:`DMRGSCF` program (or if :program:`MPSSI` is running subseuqently after a :program:`NEVPT2` calculation
one or more :file:`nevpt2.h5` files). Also, it needs a :file:`ONEINT` file from
:program:`SEWARD`, with overlap integrals and any one-electron
property integrals for the requested matrix elements. If Hamiltonian
matrix elements are used, also the :file:`ORDINT` file is needed.

or further information see the description of the :program:`RASSI` program (:numref:`UG:sec:rassi`).

.. index::
   pair: Files; MPSSI

.. _UG\:sec\:mpssi_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`ORDINT*`
  Ordered two-electron integral file produced by the :program:`SEWARD`
  program. In reality, this is up to 10 files in a multi-file system,
  named ORDINT, ORDINT1,...,ORDINT9. This is necessary on some platforms
  in order to store large amounts of data.

:file:`ONEINT`
  The one-electron integral file from :program:`SEWARD`

:file:`dmrgscf.h5`
  A number of :file:`dmrgscf.h5` files from different :program:`DMRGSCF` jobs.

Output files
............

.. class:: filelist

:file:`SIORBnn`
  A number of files containing natural orbitals, (numbered sequentially as
  :file:`SIORB01`, :file:`SIORB02`, etc.)

:file:`BRAORBnnmm`, :file:`KETORBnnmm`
  A number of files containing binatural orbitals for the transition between
  states nn and mm.

:file:`TOFILE`
  This output is only created if :kword:`TOFIle` is given in the input.
  It will contain the transition density matrix computed by :program:`MPSSI`.
  Currently, this file is only used as input to :program:`QmStat` (NOT TESTED!).

:file:`EIGV`
  Like :file:`TOFILE` this file is only created if :kword:`TOFIle` is given
  in the input. It contains auxiliary information that is picked up
  by :program:`QmStat` (NOT TESTED!).

  .. :file:`UNSYM`
       The derivative of the transition dipole moment desymmetrized.

.. index::
   pair: Input; MPSSI

.. _UG\:sec\:mpssi_input:

Input
-----

This section describes the input to the
:program:`MPSSI` program in the |molcas| program system,
with the program name: ::

  &MPSSI

When a keyword is followed by additional mandatory lines of input,
this sequence cannot be interrupted by a comment line. The first 4
characters of keywords are decoded. An unidentified keyword makes the
program stop. Note that :program:`MPSSI` shares **ALL** keywords with :program:`RASSI` which do **NOT** request CI-type
quantities. Below is just a list of additional keywords available for enabling the effective Hamiltonian from a
preceeding :program:`NEVPT2` calculation, in order to achieve a state-dressing.

.. index::
   pair: Keywords; MPSSI

Keywords
........

.. class:: keywordlist

:kword:`QDSC`
  Enable the effective Hamiltonian from a quasi-degenerate (QD) multi-state strongly-contracted i(SC) :program:`NEVPT2`
  calculation.

  .. xmldoc:: <KEYWORD MODULE="MPSSI" NAME="QDSC" APPEAR="SC effective Hamiltonian" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: QDSC <advanced>
              <HELP>
              Enable the QDSC (quasi-degenerate strongly contracted) effective Hamiltonian.
              </HELP>
              </KEYWORD>

:kword:`QDPC`
  Enable the effective Hamiltonian from a quasi-degenerate (QD) multi-state partially-contracted (PC) :program:`NEVPT2`
  calculation.

  .. xmldoc:: <KEYWORD MODULE="MPSSI" NAME="QDPC" APPEAR="PC effective Hamiltonian" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: QDPC <advanced>
              <HELP>
              Enable the QDPC (quasi-degenerate partially contracted) effective Hamiltonian.
              </HELP>
              </KEYWORD>

Input example
.............

An example with single JobIph:

::

  &MPSSI
  NrofJobIphs
  1 2           --- 1 JobIph (actually an .h5 file) - 2 states to be read
  1 2           --- which roots from the .h5 file.
  FILE
  1
  n2+.dmrgscf.h5
  omega
  SPIN
  EPRG
  1.0
  MEES
  PROPerties
    3
  'AngMom' 1
  'AngMom' 2
  'AngMom' 3
  * This input will compute spinfree and spin-orbit eigenstates in the space
  * spanned by the 2 input functions

An example with two separate JobIphs (singlet and triplet calculation of methylene):

::

  * Triplet calculation
  &DMRGSCF
    ActiveSpaceOptimizer=QCMaquis
    DMRGSettings
      max_bond_dimension=1024
      nsweeps=10
    EndDMRGSettings
    OOptimizationSettings
      Spin=3
      Inactive=1
      Ras2=6
      NActEl=6,0,0
    EndOOptimizationSettings
  * Save JobIph, because it will be overwritten by the subsequent calculation
  >> COPY $Project.JobIph JOBOLD
  >> COPY $Project.dmrgscf.h5 $Project.trip.h5
  * Save QCMaquis checkpoint since it will also be overwritten.
  * COPY does not work on directories so we move it
  >> EXEC mv $CurrDir/$Project.checkpoint_state.0.h5 $CurrDir/$Project.trip.checkpoint_state.0.h5
  * The rasscf.h5 file contains the QCMaquis checkpoint file name.
  * Now that QCMaquis checkpoint has been renamed, the name needs to
  * be changed in the rasscf.h5 file. The script below accomplishes this
  >> EXEC $MOLCAS/Tools/qcmaquis/qcm_checkpoint_rename.py $Project.trip.h5 -q

  * Singlet calculation
  &DMRGSCF
    ActiveSpaceOptimizer=QCMaquis
    DMRGSettings
      max_bond_dimension=1024
      nsweeps=10
    EndDMRGSettings
    OOptimizationSettings
      Spin=1
      Inactive=1
      Ras2=6
      NActEl=6,0,0
      JobIph
    EndOOptimizationSettings

  * Perform checkpoint manipulations as with triplet
  >> COPY $Project.dmrgscf.h5 $Project.sing.h5
  >> EXEC mv $CurrDir/$Project.checkpoint_state.0.h5 $CurrDir/$Project.sing.checkpoint_state.0.h5
  >> EXEC $MOLCAS/Tools/qcmaquis/qcm_checkpoint_rename.py $Project.sing.h5 -q

  * Run MPSSI
  &MPSSI
  Nrof
  2 1 1
  1
  1
  FILE
  2
  $Project.trip.h5
  $Project.sing.h5
  EJOB
  SOCOupling
  0.0001

The input is similar to an analogous :program:`RASSI` input, with a notable exception of manipulations of QCMaquis checkpoints and :file:`rasscf.h5` files. Since the MPS is stored in QCMaquis checkpoint folders, these have to be saved in addition to the :file:`rasscf.h5` file. In addition, :file:`rasscf.h5` saves the QCMaquis checkpoint file name, so when the latter is renamed, also the name saved in :file:`rasscf.h5` must be changed. This is accomplished with the command ::

  $MOLCAS/Tools/qcmaquis/qcm_checkpoint_rename.py <rasscf.h5> -q

.. xmldoc:: <INCLUDE MODULE="RASSI" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; McKinley
   single: McKinley

.. _UG\:sec\:mckinley:

:program:`mckinley` (a.k.a. :program:`denali`)
==============================================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:mckinley_description:

Description
-----------

.. xmldoc:: <MODULE NAME="MCKINLEY">
            %%Description:
            <HELP>
            This program calculates the second and first order derivatives used
            for calculating second order derivatives of the energies with perturbation
            dependent basis sets for SCF and CASSCF wavefunctions.
            Vibronic frequencies are calculated by the MCLR program which MCKINLEY
            will start automatically.
            </HELP>

This program calculates the second and first order derivatives used
for calculating second order derivatives of the energies with perturbation
dependent basis sets for SCF and CASSCF wavefunctions.
Vibronic frequencies are calculated by the :program:`MCLR` program which :program:`MCKINLEY`
will start automatically.

:program:`McKinley` is written such that properties can be
computed for any kind of valence basis function that :program:`SEWARD` will accept.
Note, that :program:`McKinley` can't handle ECP type basis sets.

:program:`McKinley` is able to compute the following integral derivatives:

* overlap integrals,
* kinetic energy integrals,
* nuclear attraction integrals,
* electron repulsion integrals,
* external electric field integrals,

:program:`McKinley` employs
two different integration schemes
to generate the
one- and two-electron integral derivatives.
The nuclear attraction and electron repulsion
integrals are evaluated by a modified Rys--Gauss quadrature :cite:`Bernhardsson:99a`.
All other integral
derivatives are evaluated with the Hermite--Gauss quadrature. The same
restriction of the valence basis sets applies as to :program:`SEWARD`.
None of the integral 2nd derivatives are written to disk but rather combined
immediately with the corresponding matrix from the wavefunction. Integral
1st derivative information is preprocessed and written to disc for later
use in :program:`MCLR`.

Note that :program:`MCKINLEY` for frequency calculations normally automatically
starts the :program:`MCLR` with a default input. To override this check the
keyword :kword:`NOMClr`.

At present the following limitations are built into :program:`McKinley`:

.. include:: ../limitations.inc

.. _UG\:sec\:mckinley_dependencies:

Dependencies
------------

:program:`McKinley` depends on the density, Fock matrices and Molecular orbitals generated by
:program:`SCF` or :program:`RASSCF`. In addition it needs the basis set
specification defined in :program:`SEWARD`. These dependencies, however,
are totally transparent to the user.

.. _UG\:sec\:mckinley_files:

Files
-----

Input files
...........

:program:`MCKINLEY` will use the following input
files: :file:`RYSRW`, :file:`ABDATA`, :file:`RUNFILE`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

In addition to the standard output unit :program:`MCKINLEY` will generate the following
files.

.. class:: filelist

:file:`MCKINT`
  File with information needed by the :program:`MCLR` response program.

.. _UG\:sec\:mckinley_input:

Input
-----

Below follows a description of the input to :program:`MCKINLEY`.

The input for each module is preceded by its name like: ::

  &MCKINLEY

Optional keywords

.. class:: keywordlist

:kword:`ONEOnly`
  Compile only the nuclear repulsion and one-electron integrals
  contribution. The default is to compute all contributions.

  .. xmldoc:: %%Keyword: Oneonly <basic>
              Compile only the nuclear repulsion and one-electron integrals
              contribution. The default is to compute all contributions.

:kword:`CUTOff`
  Threshold for ignoring contributions
  follows on the next line. The default is 1.0D-7. The prescreening
  is based on the 2nd order density matrix and the radial
  overlap contribution to the integral derivatives.

  .. xmldoc:: <KEYWORD MODULE="MCKINLEY" NAME="CUTOFF" APPEAR="Requested accuracy" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1.0D-7">
              %%Keyword: Cutoff <advanced>
              <HELP>
              Threshold for ignoring contributions.
              The default is 1.0D-7. The prescreening
              is based on the 2nd order density matrix and the radial
              overlap contribution to the integral derivatives.
              </HELP>
              </KEYWORD>

:kword:`SHOWHessian`
  The Hessian contributions will be printed.

  .. xmldoc:: <KEYWORD MODULE="MCKINLEY" NAME="SHOWHESSIAN" APPEAR="Show Hessian" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ShowHessian <basic>
              <HELP>
              The Hessian contributions will be printed.
              </HELP>
              </KEYWORD>

:kword:`PERTurbation`
  This keyword takes one of the arguments HESSian or GEOMetry on the following line.
  HESSian makes :program:`MCKINLEY` compute the full geometrical Hessian, which is
  required for a subsequent calculation of the vibronic frequencies with the :program:`MCLR` program.
  GEOMetry calculates only those parts of the geometrical Hessian that correspond to symmetry
  allowed displacements (could be used in a second order geometry optimization).
  The default is to compute the Hessian for vibrational frequency calculations.
  Note that in the case of numerical differentiation only symmetry allowed displacements
  will be computed regardless of this keyword.

  .. xmldoc:: <GROUP MODULE="MCKINLEY" NAME="PERTURBATION" APPEAR="Perturbation" KIND="RADIO" LEVEL="BASIC">
              %%Keyword: Perturbation <basic>
              This keyword takes one of the arguments HESSian or GEOMetry on the following line.
              <HELP>
              Hessian makes MCKINLEY compute the full geometrical Hessian, which is
              required for a subsequent calculation of the vibronic frequencies with the MCLR program.
              GEOMetry calculates only those parts of the geometrical Hessian that correspond to symmetry
              allowed displacements (Could be used in a second order geometry optimization).
              The default is to compute the Hessian for vibrational frequency calculations.
              </HELP>

  .. xmldoc:: <KEYWORD MODULE="MCKINLEY" NAME="HESSIAN" APPEAR="Hessian" KIND="SINGLE" LEVEL="BASIC" />

  .. xmldoc:: <KEYWORD MODULE="MCKINLEY" NAME="GEOMETRY" APPEAR="Geometry" KIND="SINGLE" LEVEL="BASIC" />

  .. xmldoc:: </GROUP>

:kword:`NOMClr`
  Request that this calculation is not followed by the execution of the MCLR module.

  .. xmldoc:: <KEYWORD MODULE="MCKINLEY" NAME="NOMCLR" APPEAR="No MCLR" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoMCLR <basic>
              <HELP>
              Request that this calculation is not followed by the execution of the MCLR module.
              </HELP>
              </KEYWORD>

:kword:`VERBose`
  The output will be a bit more verbose.

  .. xmldoc:: %%Keyword: Verbose <basic>
              The output will be a bit more verbose.

The following is an example of an input which will work for
almost all practical cases. ::

  &MCKINLEY
  Perturbation
  Hessian

.. xmldoc:: </MODULE>
.. index::
   single: Program; CMOCORR
   single: CMOCORR

.. _UG\:sec\:cmocorr:

:program:`cmocorr` |extramark|
==============================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:cmocorr_description:

Description
-----------

.. xmldoc:: <MODULE NAME="CMOCORR">
            %%Description:
            <HELP>
            The CMOCORR program compares the orbital spaces of two orbitals files.
            </HELP>

The :program:`CMOCORR` is a small utility that is used to compare
orbital spaces for two orbital vector files. This is useful for checking
that a calculation has maintained the orbital spaces intended by the user.

.. _UG\:sec\:cmocorr_dependencies:

Dependencies
------------

The :program:`CMOCORR` program requires two orbitals files as input
generated by any of the modules that produces orbitals.

.. index::
   pair: Files; CMOCORR

.. _UG\:sec\:cmocorr_files:

Files
-----

Input files
...........

Two orbitals files with the names :file:`CMOREF` and :file:`CMOCHK`
are needed by the program, and it is the responsability of the
user to make the proper links to these files, no links are
done automatically.

Output files
............

There are no output files.

.. index::
   pair: Input; CMOCORR

.. _UG\:sec\:cmocorr_input:

Input
-----

Below follows a description of the input to :program:`CMOCORR`
The input for each module is preceded by its name like: ::

  &CMOCORR

Argument(s) to a keyword, either individual or composed by several entries,
can be placed in a separated line or in the same line separated by a semicolon.
If in the same line, the first argument requires an equal sign after the
name of the keyword. Note that all character in a keyword is necessary,
not only the first four.

.. class:: keywordlist

:kword:`DoMetric`
  Compare the metric of the two files.
  If the files correspond to different geometries the metric will be different.

  .. xmldoc:: <GROUP MODULE="CMOCORR" NAME="COMPARE" APPEAR="Compare" KIND="BOX" LEVEL="BASIC" WINDOW="INPLACE">

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="DOME" APPEAR="Metric" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="DOSP,DOOR">
              %%Keyword: DoMetric <basic>
              <HELP>
              Compare the metric of the two files.
              If the files correspond to different geometries the metric will be different.
              </HELP>
              </KEYWORD>

:kword:`DoSpaces`
  Compare the orbitals spaces of the two files.
  This keyword implies :kword:`DoMetric`.

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="DOSP" APPEAR="Orbital spaces" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="DOME,DOOR">
              %%Keyword: DoSpaces <basic>
              <HELP>
              Compare the orbitals spaces of the two files.
              This keyword implies DoMetric.
              </HELP>
              </KEYWORD>

:kword:`DoOrbitals`
  Compare the orbitals one by one in the two files.
  This keyword implies :kword:`DoMetric` and :kword:`DoSpaces`.

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="DOOR" APPEAR="Orbitals" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="DOME,DOSP">
              %%Keyword: DoOrbitals <basic>
              <HELP>
              Compare the orbitals one by one in the two files.
              This keyword implies DoMetric and DoSpaces.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`sortcmo`
  Sort the orbitals according to the type index.
  This might be necessary if one of the files are created by :program:`LUSCUS` for example.

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="SORT" APPEAR="Sort orbitals" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: SortCMO <basic>
              <HELP>
              Sort the orbitals according to the type index.
              This might be necessary if one of the files are created by LUSCUS for example.
              </HELP>
              </KEYWORD>

:kword:`Thresholds`
  This keyword is followed by two parameters, :math:`t_1` and :math:`t_2`, the first specifying at what overlap
  to report that orbitals from the two files have a small overlap. In addition, orbitals in the reference
  file with best match is located. The second parameter is similar, but no search for matching orbitals
  is done. The defaults are :math:`t_1`\=0.6 and :math:`t_2`\=0.8.

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="THRE" APPEAR="Thresholds" KIND="REALS" SIZE="2" LEVEL="BASIC" DEFAULT_VALUES="0.6,0.8">
              %%Keyword: Thresholds <basic>
              <HELP>
              Overlap values (two numbers) below which orbitals from the two files will be reported as having small overlap.
              For the first number the best match in the reference file is located, for the second number no search is done.
              </HELP>
              </KEYWORD>

:kword:`End of input`
  This keyword terminates the reading of the input.

  .. xmldoc:: <KEYWORD MODULE="CMOCORR" NAME="END" APPEAR="End of input" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: End of input <basic>
              <HELP>
              This keyword terminates the reading of the input.
              </HELP>
              </KEYWORD>

Input examples
..............

First we have the bare minimum of input. This will only check that the files
have the same number of orbitals and symmetries. ::

  &CMOCORR

The next example is almost as simple, and all checks are perfomed. ::

  &CMOCORR
  DoOrbitals

.. xmldoc:: </MODULE>
.. index::
   single: Program; MULA
   single: MULA

.. _sec\:mula:

:program:`Mula`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="MULA">
            %%Description:
            <HELP>
            This program computes intensities of vibrational
            transitions between electronic states.
            </HELP>

The :program:`MULA` program calculates intensities of vibrational
transitions between electronic states.

.. index::
   pair: Dependencies; MULA

.. _sec\:mula_dependencies:

Dependencies
------------

The :program:`MULA` program may need one or more :file:`UNSYM` files produced
by the :program:`MCLR` program, depending on input options.

.. index::
   pair: Files; MULA

.. _sec\:mula_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`UNSYM`
  Output file from the :program:`MCLR` program.

Output files
............

.. class:: filelist

:file:`plot.intensity`
  Contains data for plotting an artificial spectrum.

.. index::
   pair: Input; MULA

.. _sec\:mula_input:

Input
-----

The input for :program:`MULA` begins after the program name: ::

  &MULA

There are no compulsory keyword.

.. index::
   pair: Keywords; MULA

Keywords
........

.. class:: keywordlist

:kword:`TITLe`
  Followed by a single line, the title of the calculation.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              A single title line follows.
              </HELP>
              </KEYWORD>

:kword:`FORCe`
  A force field will be given as input (or read from file), defining two
  oscillators for which individual vibrational levels and transition
  data will be computed.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="FORCE" APPEAR="Force field" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: FORCe <basic>
              <HELP>
              A force field will be given as input (or read from file).
              </HELP>
              </KEYWORD>

:kword:`ATOMs`
  Followed by one line for each individual atom in the molecule.
  On each line is the label of the atom, consisting of an element symbol
  followed by a number. After the label, separated by one or more blanks,
  one can optionally give a mass number; else, a standard mass taken from
  the file data/atomic.data.
  After these lines is one single line with the keyword "END of atoms".

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="ATOMS" APPEAR="Atoms" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: ATOMs <basic>
              <HELP>
              Followed by one line with an atom label for each individual atom
              in the molecule. A label consists of element name followed by a
              numeric label, optionally followed by a nuclear mass.
              </HELP>
              </KEYWORD>

:kword:`INTErnal`
  Specification of which internal coordinates that are to be used in the
  calculation. Each subsequent line has the form "BOND *a* *b*"
  or "ANGLE *a* *b* *c*" or
  or "TORSION *a* *b* *c* *d*" or
  or "OUTOFPL *a* *b* *c* *d*", for bond distances,
  valence angles, torsions (e.g. dihedral angles), and out-of-plane angles.
  Here, *a*...\ *d* stand for atom labels.
  After these lines follows one line with the keyword "END of internal".

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="INTERNAL" APPEAR="Internal coordinates" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: INTErnal <basic>
              <HELP>
              Followed by lines of the form e.g. 'BOND C11 Br3', i.e. coordinate type
              and atom labels, Other choices are 'ANGLE a b c', 'TORSION a b c d'
              and 'OUTOFPL a b c d', where a--d are atom labels.
              </HELP>
              </KEYWORD>

:kword:`MODEs`
  Selection of modes to be used in the intensity calculation. This is
  followed by a list of numbers, enumerating the vibrational modes to use.
  The modes are numbered sequentially in order of vibrational frequency.
  After this list follows one line with the keyword "END of modes".

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="MODES" APPEAR="Modes" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: MODEs <basic>
              <HELP>
              Selection of modes to be used in the intensity calculation.
              </HELP>
              </KEYWORD>

:kword:`MXLEvels`
  Followed by one line with
  the maximum number of excitations in each of the two states.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="MXLEVELS" APPEAR="Maximum levels" KIND="INTS" SIZE="2" LEVEL="BASIC">
              %%Keyword: MXLEvels <basic>
              <HELP>
              Followed by one line with max excitation level in the two states.
              </HELP>
              </KEYWORD>

:kword:`VARIational`
  If this keyword is included, a variational calculation will be made,
  instead of using the default double harmonic approximation.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="VARIATIONAL" APPEAR="Variatioal" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: VARIational <basic>
              <HELP>
              Make a variational calculation, no harmonic approximation.
              </HELP>
              </KEYWORD>

:kword:`TRANsitions`
  Indicates the excitations to be printed in the output.
  Followed by the word FIRST on one line, then a list of numbers which
  are the number of phonons --- the excitation level --- to be distributed
  among the modes, defining the vibrational states of the first
  potential function (force field). Then similarly, after a line with
  the word SECOND, a list of excitation levels for the second state.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="TRANSITIONS" APPEAR="Transitions" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: TRANsitions <basic>
              <HELP>
              Followed by the word FIRST, then a line with a list of
              the number of phonons to be distributed among the modes,
              for the first state, then similarly for second state.
              </HELP>
              </KEYWORD>

:kword:`ENERgies`
  The electronic :math:`T_0` energies of the two states, each value is followed by
  either "eV" or "au".

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="ENERGIES" APPEAR="Energies" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: ENERgies <basic>
              <HELP>
              The electronic T_0 energies of the two states, each value
              followed by "eV" or "au".
              </HELP>
              </KEYWORD>

:kword:`GEOMetry`
  Geometry input. Followed by keywords :kword:`FILE`, :kword:`CARTESIAN`, or :kword:`INTERNAL`.
  If :kword:`FILE`, the geometry input is taken from :file:`UNSYM1` and :file:`UNSYM2`.
  If :kword:`CARTESIAN` or :kword:`INTERNAL`, two sections follow, one headed by a line
  with the word :kword:`FIRST`, the other with the word :kword:`SECOND`. For the :kword:`CARTESIAN`
  case, the following lines list the atoms and coordinates. On each line
  is an atom label, and the three coordinates (:math:`x,y,z`). For the :kword:`INTERNAL`
  case, each line defines an internal coordinate in the same way as for
  keyword :kword:`INTERNAL`, and the value.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="GEOMETRY" APPEAR="Geometry" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: GEOMetry <basic>
              <HELP>
              Geometry input follows. Next line is FILE, CARTESIAN, or INTERNAL.
              Followed by FIRST, then coordinates, then SECOND, then coordinates.
              Format: See User's Guide.
              </HELP>
              </KEYWORD>

:kword:`MXORder`
  Maximum order of transition dipole expansion. Next line is 0, if the
  transition dipole is constant, 1 if it is a linear function, etc.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="MXORDER" APPEAR="Maximum order" KIND="INT" LEVEL="BASIC">
              %%Keyword: MXORder <basic>
              <HELP>
              Next line is 0 for constant transition dipole, 1 for linear function, etc.
              </HELP>
              </KEYWORD>

:kword:`OSCStr`
  If this keyword is included, the oscillator strength, instead of the
  intensity, of the transitions will calculated.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="OSCSTR" APPEAR="Oscillator strength" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: OSCStr <basic>
              <HELP>
              Print oscillator strengths rather than intensities.
              </HELP>
              </KEYWORD>

:kword:`BROAdplot`
  Gives the peaks in the spectrum plot an artificial halfwidth.
  The lifetime use for broadening can be specified with the :kword:`LIFEtime` keyword.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="BROADPLOT" APPEAR="Broaden peaks" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: BROAdplot <basic>
              <HELP>
              Apply artificial broadening to the spectrum plot peaks.
              </HELP>
              </KEYWORD>

:kword:`LIFEtime`
  Specify the lifetime broadening (in seconds) for the spectrum plot peaks when :kword:`BROAdplot` is given.
  The default value is :math:`130\cdot 10^{-15}` s.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="LIFETIME" APPEAR="Lifetime" KIND="REAL" DEFAULT="130.0e-15" LEVEL="BASIC">
              %%Keyword: LIFEtime <basic>
              <HELP>
              Enter life time (sec) to be used for lifetime broadening of
              artificial spectrum.
              </HELP>
              </KEYWORD>

:kword:`NANOmeters`
  If this keyword is included, the plot file will be in nanometers.
  Default is in eV.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="NANOMETERS" APPEAR="Plot in nm" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NANOmeters <basic>
              <HELP>
              If this keyword is included, the plot file will be in nanometers.
              Default is in eV.
              </HELP>
              </KEYWORD>

:kword:`CM-1`
  If this keyword is included, the plot file will be in
  cm\ :math:`^{-1}`. Default is in eV.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="CM-1" APPEAR="Plot in cm-1" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: CM-1 <basic>
              <HELP>
              If this keyword is included, the plot file will be in cm^-1.
              Default is in eV.
              </HELP>
              </KEYWORD>

:kword:`PLOT`
  Enter the limits (in eV, cm\ :math:`^{-1}`, or in nm) for the plot file.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="PLOT" APPEAR="Plot limits" KIND="REALS" SIZE="2" LEVEL="BASIC">
              %%Keyword: PLOT <basic>
              <HELP>
              Enter the limits (in eV, cm^-1, or in nm) for the plot file.
              </HELP>
              </KEYWORD>

:kword:`VIBWrite`
  If this keyword is included, the vibrational levels of the two states will
  be printed in the output.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="VIBWRITE" APPEAR="Write vibrational levels" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: VIBWrite <basic>
              <HELP>
              Print vibrational levels in the output.
              </HELP>
              </KEYWORD>

:kword:`VIBPlot`
  Two files, plot.modes1 and plot.modes2, will be generated, with pictures of
  the normal vibrational modes of the two electronic states.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="VIBPLOT" APPEAR="Generate normal mode plots" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: VIBPlot <basic>
              <HELP>
              Generate files plot.modes1 and plot.modes2 picturing normal modes.
              </HELP>
              </KEYWORD>

:kword:`HUGElog`
  This keyword will give a much more detailed output file.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="HUGELOG" APPEAR="Verbose output" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: HUGElog <basic>
              <HELP>
              Much more detailed output.
              </HELP>
              </KEYWORD>

  .. :kword:`EXPANSION`
       This keyword indicates that the calculation will be aborted after
       the calculation of the expansion point.

:kword:`SCALe`
  Scales the Hessians, by multiplying with the scale factors following this keyword.

  .. xmldoc:: %%Keyword: SCALe <basic>
              Enter scale factors that will multiply the Hessians.

:kword:`DIPOles`
  Transition dipole data. If MXORDER=0 (see above), there follows a single line
  with :math:`x,y,z` components of the transition dipole moment. If MXORDER=1 there
  are an additional line for each cartesian coordinate of each atom, with the
  derivative of the transition dipole moment w.r.t. that nuclear coordinate.

  .. xmldoc:: <KEYWORD MODULE="MULA" NAME="DIPOLES" APPEAR="Dipoles" KIND="REAL" SIZE="3" LEVEL="BASIC">
              %%Keyword: DIPOles <basic>
              <HELP>
              Transition dipole data follows. A single line with x,y,z components,
              if MAXORDER=0. Else additional lines with gradient values.
              </HELP>
              </KEYWORD>

:kword:`NONLinear`
  Specifies non-linear variable substitutions to be used in the definition of
  potential surfaces.

  .. xmldoc:: %%Keyword: NONLinear <advanced>
              Specifies non-linear variable substitutions in definition of potential functions.

:kword:`POLYnomial`
  Gives the different terms to be included in the fit of the polynomial
  to the energy data.

  .. xmldoc:: %%Keyword: POLYnomial <advanced>
              Specifies which polynomial terms that are used in modeling potential functions.

:kword:`DATA`
  Potential energy surface data.

  .. xmldoc:: %%Keyword: DATA <basic>
              Grid data follows. See manual for format.

Input example
.............

::

  &MULA

  Title
   Water molecule

  Atoms
   O1
   H2
   H3
  End Atoms

  Internal Coordinates
   Bond  O1 H2
   Bond  O1 H3
   Angle H3 O1 H2
  End Internal Coordinates

  MxLevels
    0  3

  Energies
   First
    0.0 eV
   Second
    3.78 eV

  Geometry
   Cartesian
   First
    O1     0.0000000000      0.0000000000     -0.5000000000
    H2     1.6000000000      0.0000000000      1.1000000000
    H3    -1.6000000000      0.0000000000      1.1000000000
   End
   Second
    O1     0.0000000000      0.0000000000     -0.4500000000
    H2     1.7000000000      0.0000000000      1.0000000000
    H3    -1.7000000000      0.0000000000      1.0000000000
   End

  ForceField
   First state
   Internal
    0.55 0.07 0.01
    0.07 0.55 0.01
    0.01 0.01 0.35
   Second state
   Internal
    0.50 0.03 0.01
    0.03 0.50 0.01
    0.01 0.01 0.25
  End of ForceField

  DIPOles
    0.20 0.20 1.20

  BroadPlot
  LifeTime
   10.0E-15

  NANO
  PlotWindow
   260 305

  End of input

::

  &MULA

  TITLe
   Benzene

  ATOMs
    C1
    C2
    C3
    C4
    C5
    C6
    H1
    H2
    H3
    H4
    H5
    H6
  End of Atoms

  GEOMetry
   file

  INTERNAL COORDINATES
   Bond    C1 C3
   Bond    C3 C5
   Bond    C5 C2
   Bond    C2 C6
   Bond    C6 C4
   Bond    C1 H1
   Bond    C2 H2
   Bond    C3 H3
   Bond    C4 H4
   Bond    C5 H5
   Bond    C6 H6
   Angle   C1 C3 C5
   Angle   C3 C5 C2
   Angle   C5 C2 C6
   Angle   C2 C6 C4
   Angle   H1 C1 C4
   Angle   H2 C2 C5
   Angle   H3 C3 C1
   Angle   H4 C4 C6
   Angle   H5 C5 C3
   Angle   H6 C6 C2
   Torsion C1 C3 C5 C2
   Torsion C3 C5 C2 C6
   Torsion C5 C2 C6 C4
   Torsion H1 C1 C4 C6
   Torsion H2 C2 C5 C3
   Torsion H3 C3 C1 C4
   Torsion H4 C4 C6 C2
   Torsion H5 C5 C3 C1
   Torsion H6 C6 C2 C5
  END INTERNAL COORDINATES

  VIBPLOT
   cyclic 4 1

  ENERGIES
   First
    0.0 eV
   Second
    4.51 eV

  MODES
   14 30 5 6 26 27 22 23 16 17 1 2 9 10
  END

  MXLE - MAXIMUM LEVEL of excitation (ground state - excited state)
    2 2

  MXOR - MAXIMUM ORDER in transition dipole.
    1

  OscStr

  Transitions
   First
    0
   Second
    0 1 2

  FORCEFIELD
   First
     file
   Second
     file
  END OF FORCEFIELD

  DIPOLES
   file

.. xmldoc:: </MODULE>
.. index::
   single: Program; GUGADRT
   single: GUGADRT

.. _UG\:sec\:gugadrt:

:program:`GUGADRT`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="GUGADRT">
            %%Description:
            <HELP>
            The GUGADRT program generates distict row table
            used by the MRCI. The program was written
            by Yubin Wang and Bingbing Suo,
            and has since been slightly modified to fit MOLCAS.
            </HELP>

The :program:`GUGADRT` program generates distict row table (DRT)
used in the :program:`GUGACI`
in :index:`Direct CI` calculations :cite:`Roos:72`.
Only DRT in active space are generated because
the hole-particle symmetry is used in :program:`GUGACI` :cite:`YBWang:1,BSuo:1`.
These DRT are used to evaluated the coupling coefficients
by the :index:`Graphical Unitary
Group Approach` :cite:`Shavitt:77,Shavitt:78,Siegbahn:80`,
for wavefunctions with at most two electrons excited from a set of
reference configurations. The reference configurations can be specified as a
list, where the occupation numbers are given for each active orbital
(see below) in each reference configuration, or as a :index:`Full CI`
within
the space defined by the active orbitals. In the :program:`GUGADRT` and :program:`GUGACI`
the orbitals are classified as follows:
Frozen, Inactive, Active, Secondary, and Deleted orbitals. Within each
symmetry type, they follow this order. For the :program:`GUGADRT` program,
only the active orbitals are relevant.

* **Inactive:** :index:`Inactive orbitals <single: GUGADRT; Inactive>` are doubly occupied
  in all reference configurations, but excitations out of this orbital
  space are allowed in the final CI wavefunction, i.e., they are
  correlated but have two electrons in all *reference* configurations.
  Since only single and double excitations are allowed, there can be no
  more than two holes in the active orbitals.

* **Active:** :index:`Active orbitals <single: GUGADRT; Active>` are those which may have
  different occupation in different reference configurations.

.. index::
   pair: Dependencies; GUGADRT

.. _UG\:sec\:gugadrt_dependencies:

Dependencies
------------

.. index::
   pair: Files; GUGADRT

.. _UG\:sec\:gugadrt_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`TRAONE`
  Transformed one-electron integrals from :program:`MOTRA`. Orbital information
  such as frozen, deleted orbitals will be read from this file.

Output files
............

.. class:: filelist

:file:`GUGADRT`
  This file contains the DRT that is needed in
  subsequent CI calculations.

.. index::
   pair: Input; GUGADRT

.. _UG\:sec\:gugadrt_input:

Input
-----

This section describes the input to the
:program:`GUGADRT` program in the |molcas| program system, with the program name: ::

  &GUGADRT

The first four characters of the keywords are
decoded and the rest are ignored.

.. index::
   pair: Keywords; GUGADRT

Keywords
........

Formally, there are no compulsory keyword. Obviously, some
input must be given for a meaningful calculation.

.. class:: keywordlist

:kword:`TITLe`
  The lines following this keyword are treated as title lines, until
  another keyword is encountered.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              <HELP>
              The lines following this keyword are treated as title lines, until
              another keyword is encountered.
              Enter at most ten lines of title.
              </HELP>
              </KEYWORD>

:kword:`SPIN`
  The spin degeneracy number, i.e. 2S+1. The value is read from the
  line following the keyword, in free format. The default value is
  1, meaning a singlet wave function.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="SPIN" APPEAR="Spin (2S+1)" KIND="INT" LEVEL="BASIC">
              %%Keyword: SPIN <basic>
              <HELP>
              Enter spin multiplicity, 2S+1. Default 1=Singlet.
              </HELP>
              </KEYWORD>

:kword:`ELECtrons`
  The number of electrons to be correlated in the CI calculation.
  The value is read from the line following the keyword, in free format.
  Note that this number should include the nr of electrons in inactive
  orbitals. An alternative input specification is NACTEL.
  Default: Twice nr of inactive orbitals.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="ELECTRONS" APPEAR="Number of electrons" KIND="INT" LEVEL="BASIC">
              %%Keyword: Electrons <basic>
              <HELP>
              Enter number of electrons to be correlated.
              </HELP>
              </KEYWORD>

:kword:`NACTel`
  The number of electrons in active orbitals in the reference configurations.
  The value is read from the line following the keyword, in free format.
  Note that this number includes only the of electrons in active
  orbitals. An alternative input specification is ELECTRONS.
  Default: Zero.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="NACTEL" APPEAR="Number of active electrons" KIND="INT" LEVEL="BASIC">
              %%Keyword: NACTEL <basic>
              <HELP>
              Number of active electrons (if multireference).
              </HELP>
              </KEYWORD>

:kword:`INACtive`
  The number of inactive orbitals, i.e. orbitals that have
  occupation numbers of 2 in all reference configurations. Specified for
  each of the symmetries. The values are read from the line
  following the keyword, in free format.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="INACTIVE" APPEAR="Inactive orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="BASIC">
              %%Keyword: Inactive <basic>
              <HELP>
              Number of inactive orbitals for each irrep.
              Enter list which tells, for each symmetry species, how many orbitals
              to keep fully occupied always. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`ACTIve`
  The number of active orbitals, i.e. orbitals that have varying
  occupation numbers in the reference configurations. Specified for each
  of the symmetries. The values are read from the line following
  the keyword, in free format.

  At least one of the :kword:`Inactive` or :kword:`Active` keywords must
  be present for a meaningful calculation. If one of them is left out,
  the default is 0 in all symmetries.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="ACTIVE" APPEAR="Active orbitals" KIND="INTS_LOOKUP" SIZE="NSYM" LEVEL="BASIC">
              %%Keyword: Active <basic>
              <HELP>
              Number of active orbitals for each irrep.
              Enter list which tells, for each symmetry species, how many orbitals
              that are active. Default is 0 in all symmetries.
              </HELP>
              </KEYWORD>

:kword:`REFErence`
  Specify selected reference configurations. The additional input
  that is required usually spans more than one line. The first line
  after the keyword contains the number of reference configurations, and
  the total number of active orbitals, and these two numbers are
  read by free format. Thereafter the input has one line per
  reference configuration, specifying the occupation number for each of
  the active orbitals, read by 80I1 format. Note that
  :kword:`Reference` and :kword:`CIall` are mutually exclusive.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="REFERENCE" APPEAR="Reference occupations" KIND="CUSTOM" LEVEL="BASIC" EXCLUSIVE="CIALL">
              %%Keyword: REFERENCE <basic>
              <HELP>
              One way of specifying the reference space -- see manual.
              </HELP>
              One of the two keywords REFERENCE and CIALL should be chosen.
              </KEYWORD>

:kword:`SYMMetry`
  Specify the selected symmetry type (the irrep) of the wave function
  as a number between 1 and 8 (see SEWARD). Default is 1, which
  always denote the totally symmetric irrep.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="SYMMETRY" APPEAR="Symmetry of state" KIND="INT" LEVEL="BASIC">
              %%Keyword: Symmetry <basic>
              <HELP>
              Specify symmetry of the state to be calculated.
              Default value is 1.
              </HELP>
              </KEYWORD>

:kword:`CIALl`
  Use a Full CI within the subspace of the active orbitals as
  reference configurations. The symmetry of the wavefunction must be
  specified. Note that
  :kword:`CIall` and :kword:`Reference` are mutually exclusive.
  One of these two alternatives must be chosen for a meaningful calculation.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="CIALL" APPEAR="Full reference" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="REFERENCE">
              <HELP>
              Use a full reference.
              </HELP>
              %%Keyword: CIAll <basic>
              Use a Full CI space as reference -- see manual.
              One of the two keywords REFERENCE and CIALL should be chosen.
              </KEYWORD>

:kword:`PRINt`
  Printlevel of the program. Default printlevel (0) produces very
  little output. Printlevel 5 gives some information that may be of
  interest. The value is read from the line following the keyword, in free
  format.

  .. xmldoc:: <KEYWORD MODULE="GUGADRT" NAME="PRINT" APPEAR="Print level" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: PrintLevel <advanced>
              <HELP>
              Enter print level, from 0 (default) up to 5.
              </HELP>
              </KEYWORD>

Input example
.............

::

  &GUGADRT
  Title     =  CH2 molecule.
  Electrons =  8
  Spin      =  1
  Inactive  =  1    0    0    0
  Active    =  2    2    2    0
  Symmetry  =  1
  Ciall

.. xmldoc:: </MODULE>
.. index::
   single: Program; Single_aniso
   single: Single_aniso

.. _UG\:sec\:single_aniso:

:program:`single_aniso`
=======================

.. only:: html

  .. contents::
      :local:
      :backlinks: none

.. xmldoc:: <MODULE NAME="SINGLE_ANISO" APPEAR="Single_Aniso">
            %%Description:
            <HELP>
            The SINGLE_ANISO program allows the non-perturbative calculation of
            effective spin (pseudospin) Hamiltonians and static magnetic properties
            of mononuclear complexes and fragments completely ab initio,including
            the spin-orbit interaction. As a starting point it uses the results
            of a RASSI calculation for the ground and several excited spin-orbital
            multiplets.

            The following quantities can be computed:

            1. Parameters of pseudospin magnetic Hamiltonians:
              a) First order (linear after pseudospin) Zeeman splitting tensor (g tensor),
                 including the determination of the sign of the product gX*gY*gZ
              b) Second order (bilinear after pseudospin) zero-field splitting tensor (D tensor)
              c) Higher order zero-field splitting tensors (D^2, D^4, D^6, ... etc.)
              d) Higher order Zeeman splitting tensors (G^1, G^3, G^5, ... , etc.)
              e) Angular Moments along the main magnetic axes

            2. Crystal-Field parameters for the ground atomic multiplet for lanthanides

            3. Static magnetic properties:
              a) Van Vleck susceptibility tensor
              b) Powder magnetic susceptibility function
              c) Magnetization vector for specified directions of the applied magnetic field
              d) Powder magnetization
            </HELP>

The :program:`SINGLE_ANISO` program is a routine which allows the non-perturbative calculation of
effective spin (pseudospin) Hamiltonians and static magnetic properties of mononuclear complexes
and fragments completely *ab initio*, including the spin-orbit interaction. As a starting point it
uses the results of :program:`RASSI` calculation for the ground and several excited spin-orbital
multiplets. A short description of methodology and applications can be found in :cite:`Chibotaru:1`,
:cite:`Chibotaru:2`. The second version of the :program:`SINGLE_ANISO` program is able to calculate
the following quantities:

* Parameters of pseudospin magnetic Hamiltonians (the methodology is described in :cite:`Chibotaru:3`):

  #. First rank (linear after pseudospin) Zeeman splitting tensor :math:`g_{\alpha\beta}`, its main values, including the sign of the product :math:`g_{X} \cdot g_{Y} \cdot g_{Z}`, and the main magnetic axes.
  #. Second rank (bilinear after pseudospin) zero-field splitting tensor :math:`D_{\alpha\beta}`, its main values and the anisotropy axes. The anisotropy axes are given in two coordinate systems: a) in the initial Cartesian coordinate system (:math:`x, y, z`) and b) in the coordinate system of the main magnetic axes (:math:`X_{\text{m}}, Y_{\text{m}}, Z_{\text{m}}`).
  #. Higher rank ZFS tensors (:math:`D^4`, :math:`D^6`, etc.) and Zeeman splitting tensors (:math:`G^3`, :math:`G^5`, etc.) for complexes with moderate and strong spin-orbit coupling.
  #. Angular moments along the main magnetic axes.

* All (27) parameters of the *ab initio* Crystal field acting on the ground atomic multiplet of lanthanides, and the decomposition of the CASSCF/RASSI wave functions into functions with definite projections of the total angular moment on the quantization axis.

* Static magnetic properties:

  #. Van Vleck susceptibility tensor :math:`\chi_{\alpha\beta}(T)`.
  #. Powder magnetic susceptibility function :math:`\chi(T)`.
  #. Magnetization vector :math:`\vec M (\vec H)` for specified directions of the applied magnetic field :math:`\vec H`.
  #. Powder magnetization :math:`M_{\text{mol}}(H)`.

The magnetic Hamiltonians are defined for a desired group of :math:`N` electronic states obtained
in :program:`RASSI` calculation to which a pseudospin :math:`\tilde{S}` (it reduces to a true spin
:math:`S` in the absence of spin-orbit coupling) is subscribed according to the relation :math:`N=2\tilde{S}+1`.
For instance, the two wave functions of a Kramers doublet correspond to :math:`\tilde{S}=1/2`.
The implementation is done for :math:`\tilde{S}=1/2, 1, 3/2, \ldots ,15/2`.

.. The second version of the :program:`SINGLE_ANISO` program allows the calculation of all 27 parameters of the exact Crystal-Field acting on the ground atomic multiplet for lanthanides. Moreover, the *ab initio* wave functions corresponding to the lowest atomic multiplet :math:`\ket{J,M_J}` are decomposed in a linear combination of functions with definite projection of the total moment on the quantization axis.

The calculation of magnetic properties takes into account the contribution of excited states
(the ligand-field and charge transfer states of the complex or mononuclear fragment included
in the RASSI calculation) via their thermal population and Zeeman admixture. The intermolecular
exchange interaction between magnetic molecules in a crystal can be taken into account during
the simulation of magnetic properties by a phenomenological parameter :math:`z_J` specified by
the user (see keyword :kword:`MLTP`).

.. index::
   pair: Dependencies; Single_aniso

.. _UG\:sec\:single_aniso_dependencies:

Dependencies
------------

The :program:`SINGLE_ANISO` program take, by default, all needed *ab initio* information from
the :file:`RUNFILE`: i.e. matrix elements of angular momentum, spin-orbit energy spectrum and
mixing coefficients, number of mixed states and their multiplicity, etc. In order to find the
necessary information in the :file:`RUNFILE`, the keywords MEES and SPIN are mandatory for
:program:`RASSI`. The :program:`SEWARD` keyword ANGM is also compulsory.

As an alternative, the :program:`SINGLE_ANISO` program  may read an ASCII datafile obtained in a
previous successful run :file:`$project.aniso`. For more information see the :kword:`DATA` below.


.. index::
   pair: Files; Single_aniso

.. _UG\:sec\:single_aniso_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`RUNFILE`
  The file of communication between different modules in |molcas|. Its presence is mandatory when the calculation is not a restart one from a data file.

Restart files & options
.......................

.. class:: filelist

:file:`RUNFILE`
  The file of communication between different modules in |molcas|. Normally it is already
  present in :file:`$WorkDir`. The :program:`SINGLE_ANISO` may be restarted as many times as
  necessary in the same working directory where the previous :program:`RASSI` was succesfully
  executed. The :file:`RUNFILE` contains then all necessary data.

:file:`ANISOINPUT`
  (Obsolescent. This option is being surpassed by the :kword:`DATA` keyword and the
  :file:`ANISO-DATA-FILE`, see below) The program may be restarted from the ASCII text file
  :file:`$Project.old.aniso` generated by default in a previous succesful run of the
  :program:`SINGLE_ANISO` (the name of this file may be specified during restart execution,
  see :kword:`REST` keyword below). This file contains all necessary data for :program:`SINGLE_ANISO`
  as well as for the :program:`POLY_ANISO`. In this case the initial :file:`$WorkDir` may be
  empty (:file:`RUNFILE` is not necessary).

:file:`ANISO-DATA-FILE`
  The :program:`SINGLE_ANISO` may be restarted from the ASCII formatted file :file:`$Project.aniso`
  produced in a previous successful run. This file can be saved at the end of any successful run of
  :program:`SINGLE_ANISO`, and may be given as input under any name. The initial :file:`$WorkDir`
  may be empty and :file:`RUNFILE` is not necessary. This option is used with the keyword :kword:`DATA`.

  Example: ::

   DATA
     ANISO_DATA_FILE




Output files
............

.. class:: filelist

:file:`$Project.aniso`
  This formatted file is recommended for restart. It is produced by any successful run of the code by default. This file will be used by POLY_ANISO.

:file:`ANISO`
 (Obsolescent) This file is intended to be as input for the :program:`POLY_ANISO` module in |molcas|. It is an ASCII formated file. It is produced by any successful run of the code.

:file:`zeeman_energy_xxx.txt`
  Zeeman eignestates for the applied field in the direction # *xxx* are placed in the corresponding text file. It may be used directly with external plotting programs like gnuplot to visualize the data.

:file:`XT_compare.txt`
  In case :kword:`TEXP` is employed (experimental XT(T) data points), the :program:`SINGLE_ANISO` produces a data file used to directly plot the comparison between experimental and calculated magnetic susceptibility.

:file:`MH_compare_xxx.txt`
  In case :kword:`HEXP` is employed (experimental M(H,T) data points), the :program:`SINGLE_ANISO` produces one or several data file(s) used to directly plot the comparison(s) between experimental and calculated molar magnetization at each temperature.

.. index::
   pair: Input; Single_aniso

.. _UG\:sec\:single_aniso_input:

Input
-----

Normally :program:`SINGLE_ANISO` runs without specifying any of the following
keywords. The only unknown variable for :program:`SINGLE_ANISO` is the
dimension (multiplicity) of the pseudospin. By default one multiplet is selected,
which has the dimension equal to the multiplicity of the ground term. For example,
in cases where spin-orbit coupling is weak, the multiplicity of the effective spin
Hamiltonian is usually the same as the multiplicity of the lowest term, while in
the cases with strong anisotropy (lanthanide or actinide complexes, :math:`\ce{Co^{2+}}`
complexes, etc...) the lowest energy levels of the complexes form a group of states
which can differ quite strong from the spin multiplicity of the lowest term. In these
cases the user should specify the multiplicity corresponding to a chosen value of
pseudospin :math:`(2\tilde{S}+1)`. For instance, in :math:`\ce{Dy^{3+}}` the spin of
the ground state term is :math:`S=5/2`, but in many situations only the ground Kramers
doublet is considered; then the user should set the multiplicity of the pseudospin
equal to 2 (see :kword:`MLTP` keyword). The calculation of the parameters of the
crystal field corresponding to the ground atomic multiplet for lanthanides should
be requested by the CRYS keyword. ::

  &SINGLE_ANISO

Argument(s) to a keyword are always supplied on the next line of the
input file.

Optional general keywords to control the input
..............................................

.. class:: keywordlist

:kword:`TITLe`
  One line following this one is regarded as title.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLE <basic>
              <HELP>
              One line following this one is regarded as title.
              </HELP>
              </KEYWORD>

:kword:`TYPE`
  This keyword is obsolete.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="TYPE" KIND="INT" LEVEL="BASIC">
              %%Keyword: TYPE <basic>
              <HELP>
              This keyword is obsolete
              </HELP>
              </KEYWORD>

:kword:`MLTP`
  The number of molecular multiplets (i.e. groups of spin-orbital eigenstates) for
  which :math:`g`, :math:`D` and higher magnetic tensors will be calculated (default :kword:`MLTP`\=1).
  The program reads two lines: the first is the number of multiplets (:math:`n_{\text{mult}}`) and
  the second the array of :math:`n_{\text{mult}}` numbers specifying the dimension of each multiplet.
  By default, the code will first analyze the energy spectra by itself and will
  compute the :math:`g` and :math:`D` tensors for ten low-lying groups of states. By using this
  keyword the user overwrites the default.

  Example: ::

    MLTP
    4
    2 4 4 2

  :program:`SINGLE_ANISO` will compute the :math:`g` tensor for four groups of states:
  the second and third groups have the effective spin :math:`\tilde{S}=\ket{3/2}` each, while
  the first and last groups of states being doublets.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="MLTP" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: MLTP <basic>
              <HELP>
              The number of molecular multiplets (i.e. groups of spin-orbital eigenstates) for
              which g, D and higher magnetic tensors will be calculated.
              The program reads two lines: the first is the number of multiplets (NMULT) and
              on the second line the array of NMULT numbers specifying the dimension of each multiplet.
              By default, the code will first analyze the energy spectra by itself and will
              compute the g and D tensors for ten low-lying groups of states. By using this
              keyword the user overwrites the default.
              </HELP>
              </KEYWORD>


:kword:`DATA`
  This keyword will read on the next line the filename of an ANISO data file. The ANISO data file is produced by default by any
  successful run of :program:`SINGLE_ANISO` under the name :file:`$Project.aniso`

  Example: ::

    DATA
       project_aniso_saved_before.aniso


  :program:`SINGLE_ANISO` will fetch the file name :file:`project_aniso_saved_before.aniso` from the input file and will attempt to open such file
  from :file:`$WorkDir`. The file contains all required data for a successful run of :program:`SINGLE_ANISO`.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="DATA" KIND="STRING" LEVEL="BASIC" DEFAULT_VALUE="aniso.input">
              %%Keyword: DATA <basic>
              <HELP>
              This option allows to start SINGLE_ANISO from a datafile provided by the user.
              The program SINGLE_ANISO will fetch the actual name of the datafile from  the input and
              expects a file with this name in WorkDir. The datafile is produced by a previosu successful
              run of SINGLE_ANISO under the name $Project.aniso
              </HELP>
              </KEYWORD>


:kword:`TINT`
  Specifies the temperature points for the evaluation of the magnetic susceptibility. The program will read three numbers: :math:`T_{\text{min}}`, :math:`T_{\text{max}}`, :math:`n_T`.

  .. container:: list

    :math:`T_{\text{min}}` --- the minimal temperature (Default 0.0 K)

    :math:`T_{\text{max}}` --- the maximal temperature (Default 300.0 K)

    :math:`n_T` --- number of temperature points (Default 101)

  Example: ::

    TINT
    0.0  330.0  331

  :program:`SINGLE_ANISO` will compute temperature dependence of the magnetic susceptibility in 331 points evenly distributed in temperature interval: 0.0 K -- 330.0 K.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="TINT" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TINT <basic>
              <HELP>
              Specifies the temperature points for the evaluation of the magnetic susceptibility.
              The program will read three numbers: Tmin, Tmax, nT. Units of temperature = kelvin (K).

              Tmin -- the minimal temperature (Default 0.0 K)
              Tmax -- the maximal temperature (Default 300.0 K)
              nT   -- number of temperature points (Default 101)
              </HELP>
              </KEYWORD>

:kword:`HINT`
  Specifies the field points for the evaluation of the magnetization in a certain direction. The program will read four numbers: :math:`H_{\text{min}}`, :math:`H_{\text{max}}`, :math:`n_H`.

  .. container:: list

    :math:`H_{\text{min}}` --- the minimal field (Default 0.0 T)

    :math:`H_{\text{max}}` --- the maximal filed (Default 10.0 T)

    :math:`n_H` --- number of field points (Default 101)

  Example: ::

    HINT
    0.0  20.0  201

  :program:`SINGLE_ANISO` will compute the molar magnetization in 201 points evenly distributed in field interval: 0.0 T -- 20.0 T.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="HINT" KIND="REAL" LEVEL="BASIC">
              %%Keyword: HINT <basic>
              <HELP>
              Specifies the field points for the evaluation of the molar magnetization.
              The program will read four numbers: Hmin, Hmax, nH, and dltH0. Units of magnetic field = tesla (T).

              Hmin -- the minimal field (Default 0.0 T)
              Hmax -- the maximal field (Default 300.0 T)
              nH   -- number of field points (Default 101)
              </HELP>
              </KEYWORD>

:kword:`TMAG`
  Specifies the temperature(s) at which the field-dependent magnetization is calculated. The program will read the number of temperature points (:math:`N_{\text{temp}}`) and then an array of real numbers specifying the temperatures (in kelvin) at which magnetization is to be computed.
  Default is to compute magnetization at one temperature point (2.0 K).
  Example: ::

    TMAG
    5   1.8  2.0  3.4  4.0  5.0

  :program:`SINGLE_ANISO` will compute the molar magnetization at 5 temperature points (1.8 K, 2.0 K, 3.4 K, 4.0 K, and 5.0 K).

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="TMAG" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TMAG <basic>
              <HELP>
              Specifies the temperature(s) at which the field-dependent magnetization is calculated.
              The program will read the number of temperature points (NTemp) and then an array of real
              numbers specifying the temperatures (in kelvin) at which magnetization is to be computed.
              Default is to compute magnetization at one temperature point (2.0 K).
              </HELP>
              </KEYWORD>

:kword:`ENCU`
  This flag is used to define the cut-off energy for the lowest states for which
  Zeeman interaction is taken into account exactly. The contribution to the magnetization
  arising from states that are higher in energy than :math:`E` (see below) is done by
  second-order perturbation theory. The program will read two integer
  numbers: :math:`N_K` and :math:`M_G`. Default values are: :math:`N_K`\=100, :math:`M_G`\=100.

  .. math:: E=N_K \cdot k_{\text{Boltz}} \cdot \text{TMAG} + M_G \cdot \mu_{\text{Bohr}} \cdot H_{\text{max}}

  The field-dependent magnetization is calculated at the temperature value TMAG.
  Example: ::

    ENCU
    250  150

  If :math:`H_{\text{max}}` = 10 T and :kword:`TMAG` = 1.8 K, then the cut-off energy is:

  .. math:: E=100 \cdot 250 \cdot k_{\text{Boltz}} \cdot 1.8\,\text{K} + 150 \cdot \mu_{\text{Bohr}} \cdot 10\,\text{T} = 1013.06258\,\text{cm}^{-1}

  This means that the magnetization coming from all spin-orbit states with energy lower
  than :math:`E=1013.06258\,\text{cm}^{-1}` will be computed exactly. The contribution from the
  spin-orbit states with higher energy is accounted by second-order perturbation.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="ENCU" KIND="INT" LEVEL="BASIC">
              %%Keyword: ENCU <basic>
              <HELP>
              This keyword is used to define the cut-off energy for the lowest states for which
              Zeeman interaction is taken into account exactly. The contribution to the
              magnetization coming from states that are higher in energy than E (see below)
              is done by second order perturbation theory. The program will read two integer
              numbers: NK and MG. Default values are: NK=100, MG=100. The field-dependent magnetization
              is calculated at the temperature value TMAG.
              </HELP>
              </KEYWORD>

:kword:`NCUT`
  This flag is used to define the cut-off energy for the lowest states for which
  Zeeman interaction is taken into account exactly. The contribution to the magnetization
  arising from states that are higher in energy than lowest :math:`N_{\text{CUT}}` states, is done by
  second-order perturbation theory. The program will read one integer number. In case the number
  is larger than the total number of spin-orbit states(:math:`N_{\text{SS}}`, then the :math:`N_{\text{CUT}}` is set to :math:`N_{\text{SS}}`
  (which means that the molar magnetization will be computed exactly, using full Zeeman
  diagonalization for all field points). The field-dependent magnetization is calculated at
  the temperature value(s) defined by :kword:`TMAG`.

  Example: ::

    NCUT
    32

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="NCUT" KIND="INT" LEVEL="BASIC">
              %%Keyword: NCUT <basic>
              <HELP>
              This keyword is used to define the cut-off energy for the lowest states for which
              Zeeman interaction is taken into account exactly. The contribution to the
              magnetization coming from states that are higher in energy than E (see below)
              is done by second order perturbation theory. The program will read two integer
              numbers: NK and MG. The field-dependent magnetization
              is calculated at the temperature value TMAG.
              </HELP>
              </KEYWORD>

:kword:`MVEC`
  Defines the number of directions for which the magnetization vector will be computed.
  On the first line below the keyword, the number of directions should be mentioned (:math:`N_{\text{DIR}}`. Default 0).
  The program will read :math:`N_{\text{DIR}}` lines for Cartesian coordinates specifying the direction :math:`i` of the
  applied magnetic field (:math:`\theta_i` and :math:`\phi_i`). These values may be arbitrary real numbers.
  The direction(s) of applied magnetic field are obtained by normalizing the length of each vector to one.
  Example: ::

    MVEC
    4
    0.0000  0.0000   0.1000
    1.5707  0.0000   2.5000
    1.5707  1.5707   1.0000
    0.4257  0.4187   0.0000

  The above input requests computation of the magnetization vector in four directions of applied field.
  The actual directions on the unit sphere are: ::

    4
    0.00000  0.00000  1.00000
    0.53199  0.00000  0.84675
    0.53199  0.53199  0.33870
    0.17475  0.17188  0.00000

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="MVEC" KIND="REALS_COMPUTED" SIZE="3" LEVEL="BASIC">
              %%Keyword: MVEC <basic>
              <HELP>
              Defines the number of directions for which the magnetization vector will be computed.
              On the first line below the keyword, the number of directions should be mentioned (NDIR. Default 0).
              The program will read NDIR lines for spherical coordinates specifying the direction
              "i" of the magnetic field (theta_i and phi_i). These values should be in radians.
              </HELP>
              </KEYWORD>

:kword:`MAVE`
  This keyword specifies the grid density used for the computation of powder molar
  magnetization. The program uses Lebedev-Laikov distribution of points on the unit sphere.
  The program reads two integer numbers: :math:`n_{\text{sym}}` and :math:`n_{\text{grid}}`. The :math:`n_{\text{sym}}` defines which
  part of the sphere is used for averaging. It takes one of the three values: 1 (half-sphere),
  2 (a quater of a sphere) or 3 (an octant of the sphere). :math:`n_{\text{grid}}` takes values from 1
  (the smallest grid) till 32 (the largest grid, i.e. the densiest). The default is to
  consider integration over a half-sphere (since :math:`M(H)=-M(-H)`): :math:`n_{\text{sym}}=1` and :math:`n_{\text{sym}}=15`
  (i.e 185 points distributed over half-sphere). In case of symmetric compounds, powder
  magnetization may be averaged over a smaller part of the sphere, reducing thus the number
  of points for the integration. The user is responsible to choose the appropriate integration scheme.
  Note that the program's default is rather conservative.

  .. container:: list

    :math:`N_\theta` --- number of :math:`\theta` points in the interval :math:`(0, \pi/2)`. (Default 12)

    :math:`N_\phi` --- number of :math:`\phi` points in the interval :math:`(0, 2\pi)`. (Default 24)

  The number of directions over which the actual averaging will take place is roughly the product of :math:`N_\theta` and :math:`N_\phi`.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="MAVE" KIND="INT" LEVEL="BASIC">
              %%Keyword: MAVE <basic>
              <HELP>
              This keyword specifies the grid density used for the computation of powder molar
              magnetization. The program uses Lebedev-Laikov distribution of points on the unit sphere.
              The program reads two integer numbers: NSYM and NGRID. The NSYM defines which
              part of the sphere is used for averaging. It takes one of the three values: 1 (half-sphere),
              2 (a quater of a sphere) or 3 (an octant of the sphere). NGRID takes values from 1
              (the smallest grid) till 32 (the largest grid, i.e. the densiest). The default is to
              consider integration over a half-sphere (since M(H)=-M(-H)): NSYM=1 and NGRID=15
              (i.e 185 points distributed over half-sphere). In case of symmetric compounds, powder
              magnetization may be averaged over a smaller part of the sphere, reducing thus the number
              of points for the integration. The user is responsible to choose the appropriate integration scheme.
              Note that the program's default is rather conservative.
              </HELP>
              </KEYWORD>

:kword:`TEXP`
  This keyword allows computation of the magnetic susceptibility :math:`\chi T(T)` at experimental points.
  On the line below the keyword, the number of experimental points :math:`N_T` is defined, and on
  the next :math:`N_T` lines the program reads the experimental temperature (in kelvin) and the
  experimental magnetic susceptibility (in :math:`\text{cm}^3\,\text{K}\,\text{mol}^{-1}`).
  :kword:`TEXP` and :kword:`TINT` keywords are mutually exclusive. The magnetic susceptibility
  routine will also print the total average standard deviation from the experiment.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="TEXP" KIND="REAL" LEVEL="BASIC">
              %%Keyword: TEXP <basic>
              <HELP>
              This keyword allows computation of the magnetic susceptibility at experimental
              temperature points. On the line below the keyword, the number of experimental
              points NT is defined, and on the next NT lines the program reads the experimental
              temperature (in K) and the experimental magnetic susceptibility (in cm^3 K mol^-1).
              TEXP and TINT keywords are mutually exclusive. The SINGLE_ANISO will also print the
              standard deviation from the experiment.
              </HELP>
              </KEYWORD>

:kword:`HEXP`
  This keyword allows computation of the molar magnetization :math:`M_{\text{mol}} (H)` at experimental points.
  On the line below the keyword, the number of experimental points :math:`N_H` is defined, and on the next :math:`N_H` lines
  the program reads the experimental field strength (in tesla) and the experimental magnetization (in :math:`\mu_{\text{Bohr}}`).
  :kword:`HEXP` and :kword:`HINT` are mutually exclusive. The magnetization routine will print the standard deviation from the experiment.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="HEXP" KIND="REAL" LEVEL="BASIC">
              %%Keyword: HEXP <basic>
              <HELP>
              This keyword allows computation of the molar magnetization at experimental field points.
              On the line below the keyword,the number of experimental points NH is defined, and on
              the next NH lines the program reads the experimental field strength (tesla) and the
              experimental magnetization (in Bohr magnetons). HEXP and HINT are mutually exclusive.
              The SINGLE_ANISO will print the standard deviation from the experiment.
              </HELP>
              </KEYWORD>

:kword:`ZJPR`
  This keyword specifies the value (in :math:`\text{cm}^{-1}`) of a phenomenological parameter of a mean
  molecular field acting on the spin of the complex (the average intermolecular exchange
  constant). It is used in the calculation of all magnetic properties (not for pseudo-spin
  Hamiltonians) (Default is 0.0)

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="ZJPR" KIND="REAL" LEVEL="BASIC">
              %%Keyword: ZJPR <basic>
              <HELP>
              This keyword specifies the value (in cm^-1) of a phenomenological parameter of a
              mean molecular field acting on the spin of the complex (the average intermolecular
              exchange constant). It is used in the calculation of all magnetic properties (not for
              spin Hamiltonians) (Default is 0.0)
              </HELP>
              </KEYWORD>

:kword:`XFIE`
  This keyword specifies the value (in :math:`\text{T}`) of applied magnetic field
  for the computation of magnetic susceptibility by :math:`\mathrm{d}M/\mathrm{d}H` and :math:`M/H` formulas.
  A comparison with the usual formula (in the limit of zero applied field) is provided.
  (Default is 0.0)

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="XFIE" KIND="REAL" LEVEL="BASIC">
              %%Keyword: XFIE <basic>
              <HELP>
              This keyword specifies the value (in tesla) of applied magnetic field
              for the computation of magnetic susceptibility by: dM/dH and M/H formulas.
              A comparison with the usual formula (in the limit of zero applied field) is provided.
              (Default is 0.0)
              </HELP>
              </KEYWORD>

:kword:`PRLV`
  This keyword controls the print level.

  .. container:: list

    2 --- normal. (Default)

    3 or larger (debug)

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="PRLV" KIND="INT" LEVEL="BASIC">
              %%Keyword: PRLV <basic>
              <HELP>
              This keyword controls the print level.

              2  -- normal. (Default)
              3+ -- (debug)
              </HELP>
              </KEYWORD>

:kword:`POLY`
  (Obsolescent. The formatted :file:`$Project.aniso` is generated and saved by default)
  The keyword is obsolete. The :program:`SINGLE_ANISO` creates by default one ASCII formated text file named :file:`ANISOINPUT`
  and also a binary file named :file:`$Project.Aniso`. Both may be used to restart (or re-run again) the :program:`SINGLE_ANISO` calculation.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="POLY" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: POLY <basic>
              <HELP>
              SINGLE_ANISO will prepare an input file (binary) for the future POLY_ANISO program. The default is not to create it.
              </HELP>
              </KEYWORD>

:kword:`CRYS`
  This keyword will enables the computation of the parameters of the crystal-field acting on the ground atomic multiplet of a
  lanthanide from the *ab initio* calculation performed. The implemented methodology is described :cite:`Ungur2017` and :cite:`Chibotaru:3`.
  Two types of crystal field parametererization are implemented:

  1. Parameterisation of the ground :math:`\ket{J,M_J}` group of spin-orbit states (e.g. parameterisation of the ground :math:`J=15/2` of a :math:`\ce{Dy^{3+}}` complex).
  2. Parameterisation of the ground :math:`\ket{L,M_L}` group of spin-free states (e.g. parameterisation of the ground :math:`^6H` multiplet of a :math:`\ce{Dy^{3+}}`).

  For each of the above cases, the parameters of the crystal field are given in terms of irreducible tensor
  operators defined in :cite:`Chibotaru:3`, in terms of Extended Stevens Operators defined in :cite:`Rudowicz1985,Rudowicz2004,Rudowicz2015` and also
  employed in the EasySpin function of MATLAB.
  On the next line the program will read the chemical symbol of the metal ion.
  The code understands the labels of: lanthanides, actinides and first-row transition metal ions. For transition metal ions, the oxidation state
  should be indicated as well.
  By default the program will not compute the parameters of the crystal-field.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="CRYS" KIND="STRING" LEVEL="BASIC">
              %%Keyword: CRYS <basic>
              <HELP>
              This keyword will enable computation of all 27 Crystal-Field parameters acting on the ground atomic multiplet of a lanthanide. On the next line the program wil read the chemical symbol of the lanthanide. By default the program will not compute the parameters of the Crystal Field.
              </HELP>
              </KEYWORD>

:kword:`QUAX`
  This keyword controls the quantization axis for the computation of the Crystal-Field parameters acting on the ground atomic multiplet of a lanthanide. On the next line, the program will read one of the three values: 1, 2 or 3.

  .. container:: list

    1 --- quantization axis is the main magnetic axis :math:`Z_{\text{m}}` of the ground pseudospin multiplet, whose size is specified within the :kword:`MLTP` keyword. (Default)

    2 --- quantization axis is the main magnetic axis :math:`Z_{\text{m}}` of the entire atomic multiplet :math:`\ket{J,M_J}`.

    3 --- the direction of the quantization axis is given by the user: on the next line the program will read three real numbers: the projections (:math:`p_x`, :math:`p_y`, :math:`p_z`) of the specified direction on the initial Cartesian axes. Note that :math:`p_x^2 + p_y^2 + p_z^2 = 1`.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="QUAX" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: QUAX <basic>
              <HELP>
              This keyword controls the quantization axis for the computation of the Crystal-Field parameters acting on the ground atomic multiplet of a lanthanide. On the next line, the program will read one of the three values:

              1 -- Zm of the ground pseudospin multiplet
              2 -- Zm of the ground atomic multiplet
              3 -- defined by the user on the following line
              </HELP>
              </KEYWORD>

:kword:`UBAR`
  This keyword allows estimation of the structuere of the blocking barier of a single-molecule magnet. The default is not to compute it.
  The method prints transition matrix elements of the magnetic moment according to the :numref:`fig:ubar`.

  .. figure:: ubar.*
     :name: fig:ubar
     :width: 75%
     :align: center

     Pictorial representation of the low-lying energy structure of a single-molecule magnet. A qualitative performance picture of the investigated single-molecular magnet is estimated by the strengths of the transition matrix elements of the magnetic moment connecting states with opposite magnetizations (:math:`n{+} \to n{-}`). The height of the barrier is qualitatively estimated by the energy at which the matrix element (:math:`n{+} \to n{-}`) is large enough to induce significant tunnelling splitting at usual magnetic fields (internal) present in the magnetic crystals (0.01 -- 0.1 tesla). For the above example, the blocking barrier closes at the state (:math:`8{+} \to 8{-}`).

  All transition matrix elements of the magnetic moment are given as
  (:math:`(\vert\mu_{X}\vert+\vert\mu_{Y}\vert+\vert\mu_{Z}\vert)/3`).
  The data is given in Bohr magnetons (:math:`\mu_{\text{Bohr}}`).
  The keyword is used with no arguments.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="UBAR" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: UBAR <basic>
              <HELP>
              This keyword allows estimation of the structuere of the blocking barier of a single-molecule magnet. The default is not to compute it.
              The method prints transition matrix elements of the magnetic moment connecting states with opposite magnetisations.
              The keyword is used with no arguments.
              </HELP>
              </KEYWORD>

:kword:`ABCC`
  This keyword will enable computation of magnetic and anisotropy axes in the
  crystallographic :math:`abc` system. On the next line, the program will read six real
  values, namely :math:`a`, :math:`b`, :math:`c`, :math:`\alpha`, :math:`\beta`, and :math:`\gamma`, defining the
  crystal lattice. On the second line, the program will read the Cartesian coordinates
  of the magnetic center. The computed values in the output correspond to the
  crystallographic position of three "dummy atoms" located on the corresponding anisotropy axes, at the distance of 1 ångstrom from the metal site. ::

    ABCC
    20.17   19.83   18.76    90  120.32  90
    12.329  13.872  1.234

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="ABCC" KIND="STRING" LEVEL="BASIC">
              %%Keyword: ABCC <basic>
              <HELP>
              This keyword will enable computation of magnetic and anisotropy axes in the
              crystallographic abc system. On the next line, the program will read six real
              values, namely (a, b, c, alpha, beta, and gamma), defining the crystal lattice.
              On the second line, the program will read the Cartesian coordinates of the
              magnetic center. The computed values in the output correspond to the crystallographic
              position of three "dummy atoms" located on the corresponding anisotropy axes, at the
              distance of 1.0 angstrom from the metal site.
              </HELP>
              </KEYWORD>

:kword:`PLOT`
  This keyword will generate a few plots (png or eps format) via an interface to the linux program *gnuplot*.
  The interface generates a datafile, a gnuplot script and attempts execution of the script for generation of the image.
  The plots are generated only if the respective function is invoked. The magnetic susceptibility, molar magnetisation and blocking barrier (UBAR) plots are generated.
  The files are named: :file:`$Project.XT_no_field.dat`, :file:`$Project.XT_no_field.plt`, :file:`$Project.XT_no_field.png`, :file:`$Project.XT_no_field.dat`, :file:`$Project.XT_no_field.plt`, :file:`$Project.XT_with_field_M_over_H.dat`,  :file:`$Project.XT_with_field_M_over_H.png`, :file:`$Project.XT_with_field_dM_over_dH.plt`, :file:`$Project.XT_with_field_dM_over_dH.dat`, :file:`$Project.XT_with_field_M_over_H.png`,    :file:`$Project.MH.dat`, :file:`$Project.MH.plt`, :file:`$Project.MH.png`, :file:`$Project.BARRIER_TME.dat`, :file:`$Project.BARRIER_ENE.dat`, :file:`$Project.BARRIER.plt` and :file:`$Project.BARRIER.png`. In case the version of the :program:`GNUPLOT` is older than 5.0, then the eps images are generated.

  .. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="PLOT" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: PLOT <basic>
              <HELP>
              This keyword will generate a few plots (png or eps format) via an interface to the linux program "gnuplot".
              The interface generates a datafile, a gnuplot script and attempts execution of the script for generation of the image.
              The plots are generated only if the respective function is invoked. The magnetic susceptibility, molar magnetisation and blocking barrier (UBAR) plots are generated.
              The files are named: XT.dat, XT.plt, XT.png, MH.dat, MH.plt, MH.png, BARRIER_TME.dat, BARRIER_ENE.dat, BARRIER.plt and BARRIER.png.
              </HELP>
              </KEYWORD>

An input example
................

::

  &SINGLE_ANISO
  MLTP
  3
  4 4 2
  ZJPR
  -0.2
  ENCU
  250 400
  HINT
  0.0  20.0  100
  TINT
  0.0  330.0  331
  MAVE
  1  12
  PLOT

.. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="ZEEM" KIND="REALS_COMPUTED" SIZE="3" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="ERAT" KIND="REAL" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SINGLE_ANISO" NAME="RESTART" KIND="STRING" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; Rhodyn
   single: Rhodyn

.. _UG\:sec\:rhodyn:

:program:`rhodyn`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="RHODYN">
            %%Description:
            <HELP>
            The program RHODYN is used for the density matrix based
            time-dependent configuration interaction (rho-TDCI)
            calculations.
            </HELP>


The program :program:`RHODYN` is used for the density matrix based time-dependent
configuration interaction (:math:`\rho`-TDCI) calculations.
The dynamics of a system initiated by electromagnetic pulse can be obtained
by means of density matrix propagation with the :program:`RASSI` Hamiltonian :cite:`Malmqvist:89`.
Interaction with the field is included in dipole approximation
:math:`H_{\text{int}} = - \vec{d} \cdot \vec{E}`.
The theory and methodology can be found in :cite:`Wang:17` and :cite:`Kochetov:20`.
The feature of the method is the treating core states and valence states
on the same footing if the Hamiltonian is chosen properly; depending on the chosen active space
different processes can be considered.
Because of the faster timescale (atto- to femtosecond), core-states dynamics are even more adequately described in the framework
of TDCI since electron dynamics is isolated from nuclear effects.
Nonetheless, such effects as population and phase relaxation due to nuclear bath, ionization, and Auger decay
can be taken into account (see keywords).
Output of the program:

* **Populations of basis states**

  Configuration state functions, spin-free, spin--orbit coupled states can be chosen as a basis.

* **Full density matrix**

  The full matrix can be output after a given timestep. It can be used to compute various time-dependent observables.

* **Time-evolution of dipole moment**

  The value of an observable can be accessed as :math:`\langle\vec{d}\rangle = \Tr[\rho \vec{d}]`.
  If requested it is written to file :file:`DIPOLE.dat`.

These data can be used to compute

* **Linear and non-linear spectra**, e.g., TD absorption, emission spectra, high harmonic generation, etc.

.. _UG\:sec\:rhodyn_dependencies:

Dependencies
------------

The program workflow requires some input files to be present with wave function
specifications from :program:`RASSCF`, :program:`CASPT2` and their properties from
:program:`RASSI` in HDF5 format. All these dependencies, however, are totally transparent to the user.

.. _UG\:sec\:rhodyn_files:

Files
-----

.. _UG\:sec\:rhodyn_inp_files:

Input files
...........

.. class:: filelist

:file:`RASSDX`
  HDF5 file generated by :program:`RASSCF` or :program:`CASPT2` modules. ``X`` stands for
  number of file.
  Number of files should be equal to the
  number of spin manifolds stated with keyword :kword:`NRSM`.

:file:`RASSISD`
  :program:`RASSI` output file in HDF5 format, calculated on given
  :program:`RASSCF` wave functions. It should contain also additional sets (arrays) in HDF5 file
  which are not standardly included. Writing these sets to HDF5 file is activated with the keyword :kword:`RHODyn` in
  :program:`RASSI`.

:file:`HRFACT`
  File with Huang--Rhys factors. If keyword :kword:`KEXT` is active
  then this file has to contain dissipation rate :math:`k` matrix.
  This file should be generated by the user.
  In general, it provides a 3-rank tensor, see :cite:`Kochetov:20` Eq. 8,
  which is stored in molden format. Section ``[FREQ]`` should contain frequencies of normal
  modes and section ``[HR-FACT]`` gives a matrix (or line) of HR factors for each normal mode.

:file:`INDENS`
  File with initial density matrix (as an :math:`N\times N` ASCII matrix).
  When keyword :kword:`POPUlation style` set to ``FROMFILE``,
  then this file should be present.
  This file should be generated by the user.

..
  :file:`AUGEVEC`
    (To be implemented) File containing the Auger decay rates of the basis states.
    This file should be generated by the user.

.. _UG\:sec\:rhodyn_output_files:

Output files
............

.. class:: filelist

:file:`PULSE`
  Stores the applied electric field. Duplicate in file :file:`RDOUT`.

:file:`CSFDEN`
  This file contains the diagonal density matrix in CSF basis.

:file:`SFDENS`
  This file contains the diagonal density matrix in SF basis.

:file:`SODENS`
  This file contains the diagonal density matrix in SO basis

:file:`RDPREP`
  Intermediate file in HDF5 format which is automatically created
  and contains all required ingredients for propagation: transformation
  matrices from one basis to another, full and spin--orbit coupling
  Hamiltonians, transition dipole matrix, initial density matrix, and
  Dyson amplitudes. Once created this file can be used as an input file
  with keyword :kword:`RUNMode` set to ``2``.

:file:`RDOUT`
  Main output file. Here, almost all relevant information is stored in
  HDF5 format. By far, it includes the electric field data, Hamiltonian
  used for propagation, decay matrix. The time-evolution of the DM diagonal
  is also stored here; thus it is redundant. Optionally, full density matrix
  and emission spectra can be written.

:file:`DIPOLE.dat`
  This file stores the TD-dipole moment data

.. _UG\:sec\:rhodyn_inp:

Input
-----

General keywords
................

.. class:: keywordlist

:kword:`NRSManifolds`
  The number of spin manifolds :math:`n`

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NRSM" APPEAR="Spin manifolds" KIND="INT" LEVEL="BASIC">
              %%Keyword: NRSManifolds <basic>
              <HELP>
              Number of spin manifolds.
              </HELP>
              </KEYWORD>

:kword:`NSTAte`
  The total number of states involved in the dynamics followed by a list of relevant states.
  If all states from input files are supposed to be used this list can be replaced
  by the word ``ALL``.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NSTA" APPEAR="Number of states" KIND="INTS_COMPUTED" SIZE="1" LEVEL="BASIC">
              <ALTERNATE KIND="CUSTOM"/>
              %%Keyword: NSTate <basic>
              <HELP>
              Total number of the states involved in the dynamics.
              </HELP>
              </KEYWORD>

:kword:`NRDEt`
  This keyword should be followed by :math:`n` lines
  (math:`n` is the number of spin manifolds, see :kword:`NRSM`), each containing four numbers:
  number of determinants, number of CSFs, number of roots, and spin multiplicity
  for each spin manifold. See examples below.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NRDE" APPEAR="Determinants, CSFs, roots, and spin" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: NRDet <basic>
              <HELP>
              Defines number of determinants, CSFs, roots, and spin multiplicity for each manifold.
              </HELP>
              </KEYWORD>

:kword:`POPUlation style`
  Describes how the initial DM is to be constructed depending on the chosen basis.
  Available options: ``CSF``, ``SF``, ``SF_THERMAL``, ``SO``, ``SO_THERMAL``,
  ``FROMFILE``.

  .. container:: list

    ``CSF`` --- means that given CSFs (specified by keyword :kword:`NRPO`) are populated evenly.

    ``SF`` --- same as ``CSF`` but for spin-free states.

    ``SF_THERMAL`` --- SFs will be populated according to the Boltzmann distribution
    for a given temperature, see keyword :kword:`TEMP`.

    ``SO`` --- same as ``SF`` and ``CSF`` but for spin--orbit-coupled basis states.

    ``SO_THERMAL`` --- same as ``SF_THERMAL`` but for SO basis.

    ``FROMFILE`` --- read the full initial DM from file :file:`INDENS`.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="POPU" APPEAR="State basis to be populated." KIND="CHOICE" LIST="CSF,SF,SF_THERMAL,SO,SO_THERMAL,FROMFILE" LEVEL="BASIC">
              %%Keyword: POPUlation <basic>
              <HELP>
              State basis to be populated.
              </HELP>
              </KEYWORD>

:kword:`NRPO`
  Numbers of states to be populated if :kword:`POPU` is set to ``CSF``, ``SF``, or ``SO``.
  The respective basis states will be evenly populated.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NRPO" APPEAR="Populated states" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="1" MIN_VALUE="0">
              %%Keyword: NRPO <basic>
              <HELP>
              Number of states to be populated.
              </HELP>
              </KEYWORD>

:kword:`TEMPerature`
  Temperature in K, which is used with thermal population options
  ``SF_THERMAL`` and ``SO_THERMAL`` (keyword :kword:`POPU`).
  Default is set to 300 K.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="TEMP" APPEAR="Temperature" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="300.0" MIN_VALUE="0.0">
              %%Keyword: TEMPerature <basic>
              <HELP>
              Defines the temperature for initial state population.
              </HELP>
              </KEYWORD>

:kword:`IFSO`
  Flag to include spin--orbit coupling. It is off by default.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="IFSO" APPEAR="Enable spin-orbit coupling" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: IFSO <basic>
              <HELP>
              Flag to include spin-orbit coupling.
              </HELP>
              </KEYWORD>

:kword:`RUNMode`
  Integer key governing the running mode of the program:

  .. container:: list

    ``1`` --- start propagation from the :program:`RASSCF`/:program:`RASSI` HDF5 files (default);

    ``2`` --- start propagation from reading intermediate file :file:`RDPREP`. Can be used as a checkpointing/restarting option;

    ``3`` --- only create the :file:`RDPREP` without doing the propagation;

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="RUNM" APPEAR="Run mode" KIND="CHOICE" LIST="1:Conventional,2:From prep file,3:No dynamics,4:Test" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: RUNMode <basic>
              <HELP>
              Switcher to define what part of the program runs.
              </HELP>
              </KEYWORD>

:kword:`INITialtime`
  Time when propagation starts in fs. 0 fs by default

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="INIT" APPEAR="Initial time" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.0" MIN_VALUE="0.0">
              %%Keyword: INITialtime <basic>
              <HELP>
              Time when propagation starts.
              </HELP>
              </KEYWORD>

:kword:`FINAltime`
  Time when propagation ends in fs. 10 fs by default.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="FINA" APPEAR="Final time in fs" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="10.0" MIN_VALUE="0.0">
              %%Keyword: FINAltime <basic>
              <HELP>
              Final time of the propagation.
              </HELP>
              </KEYWORD>

:kword:`TSTEp`
  Time step of integration in fs. Used only with fixed time step methods,
  see keyword :kword:`METH`. 0.0005 fs by default.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="TSTE" APPEAR="Time step" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.0005" MIN_VALUE="0.0">
              %%Keyword: TSTEp <basic>
              <HELP>
              Time step of integration in fs.
              </HELP>
              </KEYWORD>

:kword:`METHod`
  Method of integration: Runge--Kutta method of 4th order (``classic_RK4``)
  is set by default. ``RKCK`` (adaptive Runge--Kutta--Cash--Karp)
  with variable time step sometimes is better. Other available integrators are
  ``RK4``, ``RK5``, ``RK45`` (adaptive Runge--Kutta--Fehlberg).

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="METH" APPEAR="Method of integration" KIND="CHOICE" LIST="classic_RK4,RKCK,RK4,RK5,RK45" LEVEL="BASIC" DEFAULT_VALUE="classic_RK4">
              %%Keyword: METHod <basic>
              <HELP>
              Method of integration.
              </HELP>
              </KEYWORD>

:kword:`RK45`
  Error threshold for the adaptive integration methods with variable step.
  :math:`10^{-6}` by default.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="RK45" APPEAR="Error threshold" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1e-6" MIN_VALUE="0.0">
              %%Keyword: RK45 <basic>
              <HELP>
              Error threshold for the integration methods with changing step.
              </HELP>
              </KEYWORD>

:kword:`RKSAfety`
  Safety parameter to estimate error on each step for methods with
  adaptive step size. The estimated next step size is multiplied by
  the value of safety parameter. It is set to 0.9 by default.
  Increase it to get faster integration but at your own risk.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="RKSA" APPEAR="Safety parameter" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.9" MIN_VALUE="0.0">
              %%Keyword: RKSAfety <basic>
              <HELP>
              Safety parameter.
              </HELP>
              </KEYWORD>

:kword:`TOUT`
  Time interval for writing populations and output of the discretized field.
  0.05 fs by default.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="TOUT" APPEAR="Output time step" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.05" MIN_VALUE="0.0">
              %%Keyword: TOUT <basic>
              <HELP>
              Time interval of writing populations and of discretizing field.
              </HELP>
              </KEYWORD>

:kword:`PROPbasis`
  Basis used for propagation, spin-free basis by default. For some features such as
  dipole moment or emission spectrum calculations SO basis is preferrable.
  Available options: ``CSF`` basis (could be convenient, e.g., for charge migration studies),
  ``SF`` or ``SO`` bases (could be useful to study spin dynamics).

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="PROP" APPEAR="Propagation basis" KIND="CHOICE" LIST="CSF,SF,SO" LEVEL="BASIC" DEFAULT_VALUE="SF">
              %%Keyword: PROPbasis <basic>
              <HELP>
              Basis used for propagation.
              </HELP>
              </KEYWORD>

:kword:`DMBAsis`
  Basis used for the output of density matrix diagonal elements (populations),
  ``SF_SO`` by default means that density matrix is printed in two basis sets:
  spin-free and spin--orbit. To reduce time, one can change it either to ``SF`` or ``SO``.
  Available options: ``CSF``, ``SF``, ``SO``, ``CSF_SF``, ``SF_SO``, ``CSF_SO``, ``ALL``.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="DMBA" APPEAR="DM basis" KIND="CHOICE" LIST="CSF,SF,SO,CSF_SF,SF_SO,CSF_SO,ALL" LEVEL="BASIC" DEFAULT_VALUE="SF_SO">
              %%Keyword: DMBAsis <basic>
              <HELP>
              Density matrix basis.
              </HELP>
              </KEYWORD>

:kword:`TFDM`
  Time step (in fs) for the output of the full density matrix.
  Without this keyword the full DM will NOT be saved in file :file:`RDOUT`.


  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="TFDM" APPEAR="Time step for full density matrix" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="1.0" MIN_VALUE="0.0">
              %%Keyword: TFDM <basic>
              <HELP>
              Time step for output of full density matrix.
              </HELP>
              </KEYWORD>

:kword:`DYSO`
  Flag to switch on the ionization.
  Works only if :kword:`DYSOn` keyword was used in :program:`RASSI`.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="DYSO" APPEAR="Enable the ionization" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: DYSO <basic>
              <HELP>
              Enable the ionization.
              </HELP>
              </KEYWORD>

:kword:`ALPHa`
  Scaling parameter :math:`\alpha` for the matrix of Dyson amplitudes.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="ALPH" APPEAR="Dyson amplitude scaling parameter" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.001" MIN_VALUE="0.0">
              %%Keyword: ALPHa <basic>
              <HELP>
              Scaling parameter for the Dyson amplitudes.
              </HELP>
              </KEYWORD>

:kword:`IONDissipation`
  A parameter defining the phenomenological decay rates of the ionized states.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="IOND" APPEAR="Decay rate of ionized states" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="0.0" MIN_VALUE="0.0">
              %%Keyword: IONDissipation <basic>
              <HELP>
              Decay of ionized states.
              </HELP>
              </KEYWORD>

:kword:`IFDIssipation`
  Flag to switch on the dissipation due to the coupling to vibrational bath.
  See :cite:`Kochetov:20`.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="IFDI" APPEAR="Enable dissipation" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: IFDIssipation <basic>
              <HELP>
              Enable dissipation.
              </HELP>
              </KEYWORD>

:kword:`NMODe`
  Number of vibrational modes included in the calculation.
  Needed only if :kword:`IFDI` is activated.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NMOD" APPEAR="Vibrational modes" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: NMODe <basic>
              <HELP>
              Number of vibrational modes included.
              </HELP>
              </KEYWORD>

:kword:`GAMMa`
  The coupling of the primary heat bath to the secondary
  one in :math:`\text{cm}^{-1}`. See :cite:`Kochetov:20`, Eq. 7.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="GAMM" APPEAR="Electronic-nuclear bath coupling" KIND="REAL" LEVEL="BASIC" DEFAULT_VALUE="300.0" MIN_VALUE="0.0">
              %%Keyword: GAMMa <basic>
              <HELP>
              Electronic-nuclear bath coupling.
              </HELP>
              </KEYWORD>

:kword:`HRSO`
  Enables reading of Huang--Rhys factors from file :file:`HR-FACT` in spin--orbit coupled basis.
  See :cite:`Kochetov:20`, Eq. 8.
  Provided that :kword:`KEXT` is not specified, both :kword:`GAMM` and :kword:`HRSO` are used to compute
  the dissipation rates according to Eq. 11 in :cite:`Kochetov:20`.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="HRSO" APPEAR="Enable reading Huang-Rhys factors" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: HRSO <basic>
              <HELP>
              Enables reading of Huang-Rhys factors.
              </HELP>
              </KEYWORD>

:kword:`KEXTernal`
  Enables reading in the dissipation rate matrix :math:`k` from the file :file:`KEXT`.
  :kword:`KEXTernal` is an alternative to keywords :kword:`HRSO` and :kword:`GAMM`.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="KEXT" APPEAR="External k matrix" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: KEXTernal <basic>
              <HELP>
              Enables reading the dissipation rate matrix.
              </HELP>
              </KEYWORD>

:kword:`NPULses`
  Number of incoming electric pulses, ``1`` by default. Set it to ``0`` if no pulse is needed.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="NPUL" APPEAR="Incoming pulses" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: NPULses <basic>
              <HELP>
              Number of incoming electric pulses.
              </HELP>
              </KEYWORD>

:kword:`PTYPe`
  Defines form of the pulse envelope function for each pulse.
  The electric field is supposed to be in the form :math:`A\vec{e}s(t)\sin{(\Omega(t-t_0)+\varphi_0)}`,
  where :math:`s(t)` is the envelope function. Available options are

  .. container:: list

    ``Gauss`` --- Gaussian shape :math:`s(t)=\exp (-(t-t_0)^2/(2\sigma^2))`. Set by default.

    ``sinX``, ``cosX`` --- more localized shape :math:`s(t)=\sin^X(\pi(t-t_0)/(2\sigma))`.
    Here ``X`` is the power to which the sine or cosine function is raised. For example, ``sin16`` describes
    a :math:`\sin^{16}` shape function.
    The support of a single pulse is :math:`[t_0, t_0+2\sigma]` for ``sinX`` and :math:`[t_0-\sigma, t_0+\sigma]` for ``cosX``.

    ``Mono`` --- monochromatic pulse without shape function.

    ``TYPE_X_CIRCLE`` --- explicitly circularly polarized light, where ``X`` can be ``L`` or
    ``R`` for left and right direction, and ``TYPE`` replaces ``Mono`` or ``Gauss``. For example, ``GAUSS_R_CIRCLE``

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="PTYP" APPEAR="Pulse type" KIND="CHOICE" LIST="Gauss,Mono" LEVEL="BASIC" DEFAULT_VALUE="Gauss">
              <ALTERNATE KIND="STRING" />
              %%Keyword: PTYPe <basic>
              <HELP>
              Pulse type.
              </HELP>
              </KEYWORD>

:kword:`AMPLitude`
  On one line define as many amplitude values :math:`A` in atomic units as many pulses you ask for.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="AMPL" APPEAR="Amplitudes" KIND="REALS_LOOKUP" SIZE="NPUL" LEVEL="BASIC">
              %%Keyword: AMPLitude <basic>
              <HELP>
              Amplitudes for incoming pulses.
              </HELP>
              </KEYWORD>

:kword:`TAUShift`
  Here should be shifts :math:`t_0` in fs for each pulse with respect to
  the global initial time point.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="TAUS" APPEAR="Shifts of pulse centers" KIND="REALS_LOOKUP" SIZE="NPUL" LEVEL="BASIC">
              %%Keyword: TAUShift <basic>
              <HELP>
              Center shift of incoming pulses.
              </HELP>
              </KEYWORD>

:kword:`POLArization`
  Three complex numbers in the format ``(XR,XI) (YR,YI) (ZR,ZI)`` defining the polarization :math:`\vec{e}`. By default, the electric
  field is considered to be linear polarized along the :math:`x`-direction. If the
  number of pulses is more than one, the polarization vector should be
  given for each pulse on a separate line.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="POLA" APPEAR="Polarizations" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: POLArization <basic>
              <HELP>
              Polarization of incoming pulses.
              </HELP>
              </KEYWORD>

:kword:`SIGMa`
  Pulse dispersion :math:`\sigma` in fs for each pulse (in one line separated by space). See keyword :kword:`PTYP` for definition.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="SIGM" APPEAR="Widths of pulses" KIND="REALS_LOOKUP" SIZE="NPUL" LEVEL="BASIC">
              %%Keyword: SIGMa <basic>
              <HELP>
              Pulse width in fs.
              </HELP>
              </KEYWORD>

:kword:`OMEGa`
  Carrier frequency :math:`\Omega` in eV for each pulse (in one line separated by space).

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="OMEG" APPEAR="Frequencies of pulses" KIND="REALS_LOOKUP" SIZE="NPUL" LEVEL="BASIC">
              %%Keyword: OMEGa <basic>
              <HELP>
              Carrier frequency of incoming pulses.
              </HELP>
              </KEYWORD>

:kword:`PHASe`
  Phase :math:`\varphi_0` in radians for each pulse.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="PHAS" APPEAR="Phases for each pulse" KIND="REALS_LOOKUP" SIZE="NPUL" LEVEL="BASIC">
              %%Keyword: PHASe <basic>
              <HELP>
              Phase in radians for each pulses.
              </HELP>
              </KEYWORD>

:kword:`CHIRp`
  Enable correction to carrier frequency simulating experimental linear frequency chirp.
  Due to time-dependent phase, the carrier frequency gets an additional linear term
  :math:`\Omega \rightarrow \Omega + a (t - t_0)`.
  The constant :math:`a` should be specified.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="CHIR" APPEAR="Linear chirp constant" KIND="REAL" LEVEL="BASIC">
              %%Keyword: CHIRp <basic>
              <HELP>
              Linear chirp constant.
              </HELP>
              </KEYWORD>

:kword:`ACORrection`
  Enable correction to electromagnetic pulse as if is given as time derivative of
  a vector potential.

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="ACOR" APPEAR="Vector potential correction" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ACORrection <basic>
              <HELP>
              Vector potential correction.
              </HELP>
              </KEYWORD>

:kword:`DIPOle`
  Activates the calculation of mean value of dipole moment, currently it is
  written to the file :file:`DIPOLE.dat`

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="DIPO" APPEAR="Calculate dipole moment" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: DIPOle <basic>
              <HELP>
              Activates calculation of mean value of dipole moment.
              </HELP>
              </KEYWORD>

:kword:`EMISsion`
  Activates the calculation of emission spectrum

  .. xmldoc:: <KEYWORD MODULE="RHODYN" NAME="EMIS" APPEAR="Calculate emission spectra" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: EMISsion <basic>
              <HELP>
              Activates calculation of emission spectra.
              </HELP>
              </KEYWORD>

Input examples
..............

.. extractfile:: ug/RHODYN.input

  > copy /path/to/file/s3.rasscf.h5  RASSD1
  > copy /path/to/file/s1.rasscf.h5  RASSD2
  > copy /path/to/file/si.rassisd.h5 RASSISD
  > copy /path/to/file/kmatrix.dat   HRFACT

  &RHODYN

  NRSManifolds          = 2
  NRDEt,CSF,STATES,SPIN = 25   25   25   3
                          30   30   30   1
  NSTAte                = 105 all
  FINAltime             = 10
  IFSO
  AMPLitude             = 9.0
  TAUShift              = 1.
  SIGMa                 = 0.3
  OMEGa                 = 875
  IfDissipation
  KEXTernal

::

  &RHODYN

  NRSManifolds          = 2
  NRDEt,CSF,STATES,SPIN = 25   25   25   3
                          30   30   30   1
  POPUlatedstyle        = SO_THERMAL
  NSTAte                = 105 all
  FINAltime             = 6
  Tout                  = 0.0005
  METHod                = RKCK
  IFSO
  DMBAsis               = SO
  PROPbasis             = SO
  TFDM                  = 0.005

  PTYPe                 = Gaussian
  NPULses               = 1
  AMPLitude             = 9.0
  TAUShift              = 1.
  POLArization          = (1.0,0.0) (0.0,0.0) (0.0,0.0)
  SIGMa                 = 0.3
  OMEGa                 = 875
  PHASe                 = 0
  Dipole
  Emission

.. xmldoc:: </MODULE>
.. index::
   single: Program; GRID_IT
   single: GRID_IT

.. _UG\:sec\:gridit:

:program:`GRID_IT`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:gridit_description:

Description
-----------

.. xmldoc:: <MODULE NAME="GRID_IT" ONSCREEN="HF,HF-GEOMETRY,CAS,CAS-GEOMETRY">
            %%Description:
            <HELP>
            GRID_IT is an interface program for calculations of molecular
            orbitals and density in a set of Cartesian grid points.
            Calculated grid can be visualized by LUSCUS programs
            </HELP>

:program:`GRID_IT` is an interface program for calculations of molecular
orbitals and density in a set of Cartesian grid points. The calculated grid
can be visualized by :program:`LUSCUS` program.

.. _UG\:sec\:gridit_dependencies:

Dependencies
------------

The :program:`GRID_IT` program requires the communication file :file:`RUNFILE`,
produced by :program:`GATEWAY` and an orbital file :file:`INPORB`: :file:`SCFORB`,
:file:`RASORB`, :file:`PT2ORB`, generated by program :program:`SCF` (calculated with RHF or UHF hamiltonian), :program:`RASSCF`,
or :program:`CASPT2`, respectively.

.. index::
   pair: Files; GRID_IT

.. _UG\:sec\:gridit_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`GRID_IT`.

Input files
...........

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information generated by the program
  :program:`GATEWAY`.

:file:`INPORB`
  :file:`SCFORB` or another orbitals file (:file:`RASORB`, :file:`CIORB`,
  :file:`CPFORB`, :file:`SIORB`, :file:`PT2ORB`) containing calculated orbitals.
  If used after :program:`SCF` run, the information about one-electron
  energies is also retrieved.

Output files
............

.. class:: filelist

:file:`LUS`
  Output file in LUSCUS format, with default extension :file:`.lus` --- the only file needed
  for drawing program. In the case of
  UHF calculation, :program:`GRID_IT` produces two files: :file:`a.lus` and
  :file:`b.lus` with grids for alpha and beta electrons.
  :program:`LUSCUS` code could be used to combine grid files
  for visualization of total or spin density.

:file:`GRID`
  Obsolete format of the grid file, can be converted to Cube files using
  the :program:`grid2cube` tool. In order to generate a file with data
  written in grid format, keyword :kword:`NOLUSCUS` should be used.

.. index::
   pair: Input; GRID_IT

.. _UG\:sec\:gridit_input:

Input
-----

Normally, it is no reason to change any default setting of calculated
grid --- the choice of appropriate grid size, net frequency, as well as
choice of MO can be done automatically.

If user did not specified the selection of orbitals, :program:`GRID_IT`
makes a decision based on information in the :file:`InpOrb` file. For example,
if :file:`InpOrb` contains data after SCF calculation, a set of orbitals
around HOMO--LUMO gap will be used. If :file:`InpOrb` contains active orbitals,
they will be used as a default set.

Below follows a description of the input to :program:`GRID_IT`. The keywords
are always significant to four characters, but in order to make the
input more transparent, it is recommended to use the full keywords.
The :program:`GRID_IT` program section of the |molcas| input starts with the
standard reference to the code: ::

  &GRID_IT

Argument(s) to a keyword are always supplied on the next line of the
input file, except when explicitly stated otherwise.

Optional general keywords
.........................

.. class:: keywordlist

:kword:`TITLe`
  One line following this one is regarded as title.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="TITLE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: Title <basic>
              %%Tested: NONE
              <HELP>
              One line following this one is regarded as title.
              </HELP>
              </KEYWORD>

:kword:`NAME`
  One line following this one is used for generation of
  grid filename in the form: "Project.Name.lus".

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NAME" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: Name <basic>
              %%Tested: NONE
              <HELP>
              One line following this one is used for generation of
              grid filename in the form: "Project.Name.lus".
              </HELP>
              </KEYWORD>

:kword:`FILE`
  On the following line user can specify the filename, which will be
  used instead of INPORB (default). For example: :kword:`FileOrb=$CurrDir/$Project.ScfOrb`.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="FILE" APPEAR="INPORB file" KIND="STRING" LEVEL="BASIC">
              %%Keyword: File <basic>
              %%Tested: NONE
              <HELP>
              On the following line user can specify the filename, which will be
              used instead of INPORB (default).
              </HELP>
              </KEYWORD>

:kword:`SPARse`
  Set up sparse Cartesian net with 1 grid point per a.u.
  Note that quality of the grid can be poor.
  Default (without :kword:`Sparse` or :kword:`Dense`) is 3 points per a.u.

  .. xmldoc:: <SELECT MODULE="GRID_IT" NAME="QUALITY" APPEAR="Grid Quality" LEVEL="BASIC" CONTAINS="DEFAULT,SPARSE,DENSE">

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="SPARSE" APPEAR="Sparse" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="DENSE">
              %%Keyword: Sparse <basic>
              %%Tested: ##013
              <HELP>
              Set up sparse Cartesian net with 1 grid point per a.u.
              Note that quality of the grid can be poor.
              Default is 3 points per a.u.
              </HELP>
              </KEYWORD>

:kword:`DENSe`
  Set up net with 10 grid points per a.u. Note that using this option
  without choice of orbitals to draw you can produce very large output file.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="DENSE" APPEAR="Dense" KIND="SINGLE" LEVEL="BASIC" EXCLUSIVE="SPARSE">
              %%Keyword: Dense <basic>
              %%Tested: ##219
              <HELP>
              Set up dense Cartesian net with 10 grid point per a.u.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

  .. --- not clear - do we need packing at all ---

     :kword:`PACK`
       Use packing of data, to create a lower quality, but smaller output files.

  ..   .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="PACK" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="NOPACK">
                   %%Keyword: Pack <basic>
                   <HELP>
                   Use packing of data, to create a lower quality, but smaller output files.
                   </HELP>
                   </KEYWORD>

     :kword:`NOPACK`
       Do not use packing of data. By default, unless Dense grid is used,
       the data is packed, so the picture has lower (screen) quality.

   ..  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NOPACK" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="PACK">
                   %%Keyword: NoPack <basic>
                   <HELP>
                   Do not use packing of data. By default, unless Dense grid is used,
                   the data is packed, so the picture has lower (screen) quality.
                   </HELP
                   </KEYWORD>

:kword:`GAP`
  Keyword, followed by real equals to distance between
  the atomic nuclei in the molecule and the border of grid.
  Default value is 4.0 a.u.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="GAP" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: Gap <advanced>
              %%Tested: NONE
              <HELP>
              Keyword, followed by real equals to distance between
              the atomic nuclei in the molecule and the border of grid.
              Default value is 4.0 a.u.
              </HELP>
              </KEYWORD>

:kword:`ORBItal`
  Direct specification of orbitals to show. Next line set up
  number of calculated grids. And at next line(s) pairs of integers --- symmetry
  and orbital within this symmetry is given.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ORBITAL" KIND="INTS_COMPUTED" SIZE="2" MIN_VALUE="1" LEVEL="ADVANCED" EXCLUSIVE="SELECT">
              %%Keyword: Orbital <advanced>
              %%Tested: NONE
              <HELP>
              Direct specification of orbitals to show. Follows by
              number of calculated grids, and pairs of integers -- symmetry
              and orbital within this symmetry.
              </HELP>
              </KEYWORD>

:kword:`SELEct`
  Direct specification of orbitals to show. Follows by one line
  in the format: symmetry:first_orbital-last_orbital
  (Ex: 1:2-7 2:5-8)

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="SELECT" KIND="STRING" LEVEL="ADVANCED" EXCLUSIVE="ORBITAL">
              %%Keyword: Select <advanced>
              %%Tested: NONE
              <HELP>
              Direct specification of orbitals to show. Follows by one line
              in the format: symmetry:FirstOrbital-LastOrbital
              (Ex: 1:2-7 2:5-8)
              </HELP>
              </KEYWORD>

:kword:`MULLiken`
  Compute Mulliken charges separately for each occupied MO specified in
  the GRID_IT input. "LONG print" is an optional argument for more
  detailed printout.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="MULLIKEN" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: Mulliken <advanced>
              %%Tested: NONE
              <HELP>
              Compute Mulliken charges separately for each occupied MO specified in
              the GRID_IT input. "LONG print" is an optional argument for more
              detailed printout.
              </HELP>
              </KEYWORD>

:kword:`NoSort`
  Do not sort orbitals by occupation numbers and orbital energies

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NOSORT" APPEAR="NoSort" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NoSort <advanced>
              %%Tested: NONE
              <HELP>
              Do not sort orbitals by occupation numbers and orbital energies
              </HELP>
              </KEYWORD>

:kword:`ORANge`
  Followed by 2 numbers, to limit the interval of
  orbitals by occupation numbers.

  .. xmldoc:: <SELECT MODULE="GRID_IT" NAME="SELECTION" APPEAR="Orbital Selection" LEVEL="ADVANCED" CONTAINS="DEFAULT,ERANGE,ORANGE,ALL">

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ORANGE" APPEAR="oRange" KIND="REALS" SIZE="2" MIN_VALUE="0" MAX_VALUE="2" LEVEL="ADVANCED" EXCLUSIVE="ERANGE,ALL">
              %%Keyword: ORANge <advanced>
              %%Tested: ##205
              <HELP>
              Followed by 2 numbers to limit the interval of
              orbitals by occupation numbers
              </HELP>
              </KEYWORD>

:kword:`ERANge`
  Followed by 2 numbers, to limit the interval of
  orbitals by one-electron energies

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ERANGE" APPEAR="eRange" KIND="REALS" SIZE="2" LEVEL="ADVANCED" EXCLUSIVE="ORANGE,ALL">
              %%Keyword: ERANge <advanced>
              %%Tested: NONE
              <HELP>
              Followed by 2 numbers to limit the interval of
              orbitals by one-electron energies
              </HELP>
              </KEYWORD>

:kword:`ALL`
  Calculate grids for all molecular orbitals. Using this keyword you can produce a
  huge output file!

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ALL" APPEAR="ALL Orbitals" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="ORANGE,ERANGE">
              %%Keyword: All <advanced>
              %%Tested: ##219
              <HELP>
              Calculate grids for all molecular orbitals.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

  .. :kword:`NODEnsity`
       Keyword to suppress calculation of grid for density

       .. .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NODENSITY" APPEAR="No Density" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="TOTAL">
                      %%Keyword: NoDensity <advanced>
                      <HELP>
                      Keyword to suppress calculation of grid for density
                      </HELP>
                      </KEYWORD>

:kword:`TOTAl`
  Request to calculate a grid for the (correct) total
  density computed from contributions of all orbitals, instead of (default)
  just from the orbitals chosen by user.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="TOTAL" APPEAR="Total Density" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="NODENSITY">
              %%Keyword: Total <advanced>
              %%Tested: ##071
              <HELP>
              Request to calculate a grid for the (correct) total
              density computed
              from contributions of all orbitals, instead of (default)
              just from the orbitals chosen by user.
              </HELP>
              </KEYWORD>

:kword:`VB`
  This keyword enables plotting of the orbitals from the latest :program:`CASVB` orbitals.
  Note that the appropriate :file:`RASORB` orbitals must be available in the :file:`INPORB` file.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="VB" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: VB <advanced>
              %%Tested: NONE
              <HELP>
              Plots orbitals from the latest CASVB calculation.
              </HELP>
              </KEYWORD>

:kword:`ATOM`
  Calculate density at the position of atoms.

  .. xmldoc:: <SELECT MODULE="GRID_IT" NAME="FORMAT" APPEAR="Output Format" LEVEL="ADVANCED" CONTAINS="DEFAULT,ASCII,ATOM,CUBE">

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ATOM" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="ASCII">
              %%Keyword: ATOM <advanced>
              %%Tested: ##071 ##219
              <HELP>
              Calculate density in the position of atoms
              </HELP>
              </KEYWORD>

:kword:`ASCII`
  Obsolete keyword for ASCII format of output file. This option can only
  be used in combination with :kword:`NOLUSCUS`.
  This keyword is useful if a calculation
  of the grid file and visualization should be done on computers with
  different architectures.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ASCII" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="ATOM">
              %%Keyword: ASCII <advanced>
              %%Tested: NONE
              <HELP>
              Obsolete keyword for ASCII format of output file. This option can only
              be used in combination with NOLUSCUS
              </HELP>
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`NPOInts`
  Keyword, followed by 3 integers equal to number of grid points
  in x, y, z directions. Using for non-automatic choice of grid network.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NPOINTS" APPEAR="nPoints" KIND="INTS" SIZE="3" LEVEL="ADVANCED" EXCLUSIVE="GRID">
              %%Keyword: Npoints <advanced>
              %%Tested: NONE
              <HELP>
              Keyword, followed by 3 integers equal to number of grid points
              in x, y, z directions
              </HELP>
              </KEYWORD>

:kword:`GRID`
  Keyword to set manually coordinates of a grid. Followed by number of
  Cartesian coordinates, and on next lines --- x y z coordinates of
  a grid (in a.u.)

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="GRID" KIND="REALS_COMPUTED" SIZE="3" LEVEL="ADVANCED" EXCLUSIVE="NPOINTS">
              %%Keyword: GRID <advanced>
              %%Tested: NONE
              <HELP>
              Keyword to set manually coordinates of a grid. Followed by number of
              Cartesian coordinates, and on next lines -- x y z coordinates of
              a grid (in a.u.)
              </HELP>
              </KEYWORD>

:kword:`GORI`
  Keyword to set manually the parallelepiped spanning a grid.
  Followed by four lines of three columns each.
  The first line defines the x y z location of the origin,
  the next three lines are three linearly independent vectors
  that span the parallelepiped of the grid.
  This keyword requires :kword:`NPOINTS` to build up the lattice of gridpoints.

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="GORI" KIND="REALS" SIZE="12" LEVEL="ADVANCED" EXCLUSIVE="GRID" REQUIRE="NPOINTS">
              %%Keyword: GORI <advanced>
              %%Tested: NONE
              <HELP>
              Keyword to set manually the parallelepiped spanning a grid.
              Followed by four lines of three columns each.
              The first line defines the x y z location of the origin,
              the next three lines are three linearly independent vectors
              that span the parallelepiped of the grid.
              This keyword requires NPOINTS to build up the lattice of gridpoints.
              </HELP>
              </KEYWORD>

:kword:`NOLUSCUS`
  Produce data file in obsolete format (which can be read by old
  (before 2015) versions of :program:`GV`).

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="NOLUSCUS" APPEAR="Old grid format" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: NOLUSCUS <advanced>
              %%Tested: NONE
              <HELP>
              Produce data file in obsolete format (which can be read by old
              (before 2015) versions of GV)
              </HELP>
              </KEYWORD>

:kword:`XFIELD`
  Use :program:`Grid_It` in a special mode (to produce the grid for non-cartesian points).

  .. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="XFIELD" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XFIELD <advanced>
              %%Tested: NONE
              <HELP>
              Use Grid_It in a special mode (to produce the grid for non-cartesian points).
              </HELP>
              </KEYWORD>

Input example
.............

An example for high quality picture, containing selected orbitals (from symmetry 1 and 4): ::

  &GRID_IT
  Dense
  Select
  1:10-20,4:3-7

An example for screen quality picture, containing all orbitals: ::

  &GRID_IT
  SPARSE; PACK
  ALL

An example for selection orbitals with partial occupation: ::

  &GRID_IT
  ORange = 0.01 1.99

.. xmldoc:: <KEYWORD MODULE="GRID_IT" NAME="ONE" KIND="REALS" SIZE="7" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; Quater
   single: Quater

.. _UG\:sec\:quater:

:program:`quater`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="QUATER">
            %%Description:
            <HELP>
            This program aligns two molecules or frames of reference
            </HELP>

.. index::
   pair: Dependencies; Quater

.. _UG\:sec\:quater_dependencies:

Dependencies
------------

The :program:`QUATER` is free-standing and does not depend on any
other program.

.. index::
   pair: Files; Quater

.. _UG\:sec\:quater_files:

Files
-----

Input files
...........

The calculation of vibrational wave functions and spectroscopic
constants uses no input files (except for the standard input).

.. index::
   pair: Input; Quater

.. _UG\:sec\:quater_input:

Input
-----

This section describes the input to the :program:`QUATER` program in the
|molcas| program system. The program name is ::

  &QUATER

.. index::
   pair: Keywords; Quater

Keywords
........

.. class:: keywordlist

:kword:`NOROtation`
  No rotation is performed by the program.
  Only the rotation matrix is printed out.

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="NOROTATION" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOROtation <basic>
              <HELP>
              No rotation is performed by the program.
              Only the rotation matrix is printed out.
              </HELP>
              </KEYWORD>

:kword:`NOTRanslation`
  No translation is performed by the program.

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="NOTRANSLATION" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOTRanslation <basic>
              <HELP>
              No translation is performed by the program.
              </HELP>
              </KEYWORD>

:kword:`DEBUg`
  Turn on DEBUG printout

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="DEBUG" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: DEBUg <basic>
              <HELP>
              Turn on DEBUG printout
              </HELP>
              </KEYWORD>

:kword:`AXIS`
  Define the old frame of reference

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="AXIS" KIND="REALS" SIZE="6" LEVEL="BASIC">
              %%Keyword: AXIS <basic>
              <HELP>
              Define the old frame of reference
              </HELP>
              </KEYWORD>

:kword:`NEWAxis`
  Define the new frame of reference

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="NEWAXIS" KIND="REALS" SIZE="6" LEVEL="BASIC">
              %%Keyword: NEWAxis <basic>
              <HELP>
              Define the new frame of reference
              </HELP>
              </KEYWORD>

:kword:`GEO1`
  Define the first geometry

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="GEO1" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: GEO1 <basic>
              <HELP>
              Define the first geometry
              </HELP>
              </KEYWORD>

:kword:`GEO2`
  Define the second geometry

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="GEO2" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: GEO2 <basic>
              <HELP>
              Define the second geometry
              </HELP>
              </KEYWORD>

:kword:`XYZ1`
  Define the origin and two axes for the orientation of the first geometry by
  the index of three atoms of this geometry.

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="XYZ1" KIND="INTS" SIZE="3" LEVEL="BASIC">
              %%Keyword: XYZ1 <basic>
              <HELP>
              Define the origin and two axes for the orientation of the first geometry by
              the index of three atoms of this geometry.
              </HELP>
              </KEYWORD>

:kword:`XYZ2`
  Define the origin and two axes for the orientation of the second geometry by
  the index of three atoms of this geometry.

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="XYZ2" KIND="INTS" SIZE="3" LEVEL="BASIC">
              %%Keyword: XYZ2 <basic>
              <HELP>
              Define the origin and two axes for the orientation of the second geometry by
              the index of three atoms of this geometry.
              </HELP>
              </KEYWORD>

:kword:`END`
  End of input

  .. xmldoc:: <KEYWORD MODULE="QUATER" NAME="END" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: END <basic>
              <HELP>
              End of input
              </HELP>
              </KEYWORD>

:program:`QUATER` will perform a vib-rot analysis and compute
spectroscopic constants.

Input example
.............

::

  &QUATER

  GEO1
     19
  titre
   C     0.000000     0.000000     0.000000
   O     0.000000     0.000000     1.400000
   H     0.895670     0.000000     1.716663
   C    -0.683537    -1.183920    -0.483333
   H    -0.513360     0.889165    -0.363000
   C    -0.683537    -1.183920    -1.933333
   H    -0.170177    -2.073085    -0.120333
   H    -1.710256    -1.183920    -0.120333
   C     0.683537    -1.183920    -2.416667
   H    -1.196896    -2.073085    -2.296333
   H    -1.196896    -0.294755    -2.296333
   C     1.367073     0.000000    -1.933333
   H     1.196896    -2.073085    -2.053667
   H     0.683537    -1.183920    -3.505667
   C     1.367073     0.000000    -0.483333
   H     2.393792     0.000000    -2.296333
   H     0.853714     0.889165    -2.296333
   H     1.880433    -0.889165    -0.120333
   H     1.880433     0.889165    -0.120333
  END
  GEO2
     23
  titre
   C     0.000000     0.000000     0.000000
   H     0.000000     0.000000     1.089000
   C     1.367075     0.000000    -0.483328
   H    -0.334267    -0.970782    -0.363000
   C     1.367081     0.000000    -1.933328
   H     1.880433     0.889165    -0.120326
   H     1.880433    -0.889165    -0.120326
   C     0.683546     1.183920    -2.416664
   H     2.393801     0.000000    -2.296324
   H     0.853722    -0.889165    -2.296330
   C    -0.683529     1.183920    -1.933336
   H     1.196904     2.073085    -2.053662
   O     0.683551     1.183920    -3.816664
   C    -0.683535     1.183920    -0.483336
   H    -1.196887     2.073085    -2.296338
   H    -1.196887     0.294755    -2.296338
   O    -0.023570     2.327015    -0.016667
   H    -1.710255     1.183920    -0.120340
   H     0.237132     1.957142    -4.132332
   C    -0.023576     2.327015     1.383333
   H     0.489783     3.216180     1.746335
   H    -1.050296     2.327015     1.746329
   H     0.489783     1.437850     1.746335
  END
  XYZ1
  15 12 9
  XYZ2
  11 14 1
  END

This input will perform the alignment of the second geometry (GEO2) on the first one (GEO1).
Atom number 11 (C11) of the second geometry will be moved to the position of atom number
15 of the first geometry (C15).
The vector C11 C14 in GEO1 will be aligned with the vector C15 C12 of GEO1.
Finally the plane 11 14 1 of GEO1 will be aligned with the plane 15 12 9 of GEO2.

.. xmldoc:: </MODULE>
.. index::
   single: Program; EMBQ
   single: EMBQ

.. _UG\:sec\:embq:

:program:`embq` |extramark|
===========================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="EMBQ">
            %%Description:
            <HELP>
            This program computes the electrostatic embedding potential
            from known lattice cell parameters and ionic charges
            </HELP>

.. _UG\:sec\:embq_description:

Description
-----------

The :program:`EMBQ` program of the |molcas| program system computes the geometrical positions and values of point charges, which reproduce the electrostatic potential in a finite volume. These point charges can be used in the embedded cluster calculations to mimic the electrostatic potential of an infinite lattice.

.. Electrostatic embedding potential
   ---------------------------------

In embedded cluster and quantum mechanics/molecular mechanics (QM/MM) methods, a QM description of a part of the system is combined with an empirical description of its surroundings. The QM region is said to be embedded into the potential produced by its surrounding. The :program:`EMBQ` program implements a method, which allows one to generate the electrostatic embedding potential for however complex crystalline lattice. To this end (i) a lattice unit cell is complemented with point charges which zero out all multipole moments of the unit cell up to any predefined :math:`M`-tupole and (ii) a finite nano-cluster is constructed from these redefined unit cells. As the size of this nano-cluster increases, the electrostatic potential in its inner region converges to that calculated using the Ewald's procedure.

The details of this method and examples are provided in the literature :cite:`Abarenkov:07,Sushko:10`.

.. * I. V. Abarenkov, "Unit cell for a lattice electrostatic potential", Phys. Rev. B **bf 76**, 165127 (2007).
   * P. V. Sushko, I. V. Abarenkov, "General purpose electrostatic embedding potential", J. Chem. Theory Comput. **6**, 1323-1333 (2010).

.. index::
   pair: Files; EMBQ

.. UG\:sec\:embq_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`EMBQ.INP`
  This file contains keywords and control parameters for the :program:`EMBQ` program including information about the crystal lattice cell and atoms of the QM cluster. No point group symmetry is assumed.

Intermediate files
..................

All the intermediate files are created, used and removed
automatically.

Output files
............

In all output files coordinates are given in ångströms and the values of charges --- in atomic units.

.. class:: filelist

:file:`EMBQ_cell.xyz`
  .. :file:`EMBQ_UC.XYZ`

  Lattice cell: coordinates and ionic charges of the lattice cell atoms. No point group symmetry is assumed. Format: XYZ.

:file:`EMBQ_cell+Q.xyz`
  .. :file:`EMBQ_UCQ.XYZ`

  Modified cell: coordinates and charges of the lattice cell atoms and complementary point charges generated by :program:`EMBQ`. Format: XYZ. Note that the lattice atoms and complementary charges may coincide.

:file:`EMBQ_ncQ.xyz`
  .. :file:`EMBQ_NCQ.XYZ`

  Coordinates and charges of all species of the nano-cluster constructed using the modified unit cell. Format: XYZ.

:file:`EMBQ_ncQ.dat`
  .. :file:`EMBQ_NCQ.DAT`

  Coordinates and charges of all species of the nano-cluster constructed using the modified unit cell. Format: 4 columns containing Cartesian coordinates and the value of the charge.

:file:`EMBQ_ncQ-QM.xyz`
  .. :file:`EMBQ_VEX.XYZ`

  Coordinates and charges of all species of the nano-cluster *without* atoms of the QM cluster (if specified). Format: XYZ.

:file:`EMBQ_ncQ-QM.dat`
  .. :file:`EMBQ_VEX.DAT`

  Coordinates and charges of all species of the nano-cluster *without* atoms of the QM cluster (if specified). Format: 4 columns containing Cartesian coordinates and the value of the charge.

:file:`EMBQ_elpot.dat`
  .. :file:`EMBQ_EPF.OUT`

  Coordinates and charges of the nano-cluster, distance from the centre of the nano-cluster to each centre, centre number, on-site electrostatic potential and components of the field.

.. _UG\:sec\:embq_input:

Input
-----

Description of the input to :program:`EMBQ` is below. The keywords
are always significant to four characters, but in order to make the
input more transparent, it is recommended to use the full keywords.
The :program:`EMBQ` program section of the |molcas| input is bracketed by
a preceding dummy namelist reference ::

  &EMBQ
  End of Input

Argument(s) to a keyword are always supplied on the next line of the
input file, except explicitly stated otherwise.

Compulsory keywords
...................

.. class:: keywordlist

:kword:`ELMOment`
  Keyword, followed by a single integer, which specifies the largest electric
  multipole to be eliminated.
  A non-negative integer has to be supplied as argument.
  Default value is 0.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="ELMO" APPEAR="Electric moment" KIND="INT" LEVEL="BASIC" DEFAULT_VALUE="0" MIN_VALUE="0">
              %%Keyword: ELMO <basic>
              <HELP>
              Keyword, followed by a single integer, which specifies the largest electric
              multipole to be eliminated.
              A non-negative integer has to be supplied as argument.
              Default value is 0.
              </HELP>
              </KEYWORD>

:kword:`UCVEctors`
  Specifies parameters of the crystal cell (in Å).
  Three lines, containing three real numbers each, have to be supplied:

  .. container:: list

    1st line --- components of the cell vector :math:`\vec{a}_1`;

    2nd line --- components of the cell vector :math:`\vec{a}_2`;

    3rd line --- components of the cell vector :math:`\vec{a}_3`.

  .. xmldoc:: <GROUP MODULE="EMBQ" NAME="VECTORS" APPEAR="Cell vectors" KIND="BOX" LEVEL="BASIC" WINDOW="INPLACE">

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="UCVE" APPEAR="Cell: a1, a2, a3" KIND="STRINGS" SIZE="3" LEVEL="BASIC" EXCLUSIVE="UCV1,UCV2,UCV3">
              %%Keyword: UCVE <basic>
              <HELP>
              Specifies parameters of the crystal cell (in Angstroms).
              Three lines, containing three real numbers each, have to be supplied:

              1st line -- components of the cell vector a1;
              2nd line -- components of the cell vector a2;
              3rd line -- components of the cell vector a3.
              </HELP>
              </KEYWORD>

:kword:`UCV1`
  Keyword, followed by three real numbers.
  Specifies components of the crystallographic cell vector :math:`\vec{a}_1` (in Å).
  Can be used as an alternative to keyword :kword:`UCVEctors`.
  Should be used together with keywords :kword:`UCV2` and :kword:`UCV3`.
  There is no default value.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="UCV1" APPEAR="Cell: a1" KIND="REALS" SIZE="3" LEVEL="BASIC" EXCLUSIVE="UCVE">
              %%Keyword: UCV1 <basic>
              <HELP>
              Keyword, followed by three real numbers.
              Specifies components of the lattice cell vector a1 (in Angstroms).
              Can be used as an alternative to keyword UCVEctors.
              Should be used together with keywords UCV2 and UCV3.
              There is no default value.
              </HELP>
              </KEYWORD>

:kword:`UCV2`
  Keyword, followed by three real numbers.
  Specifies components of the crystallographic cell vector :math:`\vec{a}_2` (in Å).
  Can be used as an alternative to keyword :kword:`UCVEctors`.
  Should be used together with keywords :kword:`UCV1` and :kword:`UCV3`.
  There is no default value.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="UCV2" APPEAR="Cell: a2" KIND="REALS" SIZE="3" LEVEL="BASIC" EXCLUSIVE="UCVE">
              %%Keyword: UCV2 <basic>
              <HELP>
              Keyword, followed by three real numbers.
              Specifies components of the lattice cell vector a2 (in Angstroms).
              Can be used as an alternative to keyword UCVEctors.
              Should be used together with keywords UCV1 and UCV3.
              There is no default value.
              </HELP>
              </KEYWORD>

:kword:`UCV3`
  Keyword, followed by three real numbers.
  Specifies components of the crystallographic cell vector :math:`\vec{a}_3` (in Å).
  Can be used as an alternative to keyword :kword:`UCVEctors`.
  Should be used together with keywords :kword:`UCV1` and :kword:`UCV2`.
  There is no default value.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="UCV3" APPEAR="Cell: a3" KIND="REALS" SIZE="3" LEVEL="BASIC" EXCLUSIVE="UCVE">
              %%Keyword: UCV3 <basic>
              <HELP>
              Keyword, followed by three real numbers.
              Specifies components of the lattice cell vector a3 (in Angstroms).
              Can be used as an alternative to keyword UCVEctors.
              Should be used together with keywords UCV1 and UCV2.
              There is no default value.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`UCAToms`
  Keyword, followed by a single integer equal to the number of atoms in the lattice cell
  and a list of the corresponding coordinates (in Å) and ionic charges (in atomic units).

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="UCAT" APPEAR="Atoms" KIND="REALS_COMPUTED" SIZE="4" LEVEL="BASIC">
              %%Keyword: UCAT <basic>
              <HELP>
              Keyword, followed by a single integer equal to the number of atoms in the lattice cell
              and a list of the corresponding coordinates and ionic charges.
              </HELP>
              </KEYWORD>

Optional keywords
.................

.. class:: keywordlist

:kword:`TETRahedra`
  Keyword, followed by a single line containing eight integers equal to either 0 or 1.
  Specifies which tetrahedra are used to complement the crystal cell with :program:`EMBQ` charges.
  Each integer correspond to a single tetrahedron associated with a single corner of the crystal cell.
  The tetrahedron is used if the corresponding parameter equals to 1 and not used if it equals to 0.
  Default: use all eight tetrahedra.

  Orientation of the tetrahedra are determined by their axes, which are either parallel (+) or anti-parallel (|-|) to the cell vectors
  :math:`\vec{a}_1`, :math:`\vec{a}_2`, :math:`\vec{a}_3` as shown in the table below.

  .. |a| replace:: :math:`\vec{a}_1`
  .. |b| replace:: :math:`\vec{a}_2`
  .. |c| replace:: :math:`\vec{a}_3`

  =========== === === ===
  Tetrahedron Orientation
  ----------- -----------
  |zws|       |a| |b| |c|
  =========== === === ===
  1           \+  \+  \+
  2           |-| \+  \+
  3           \+  |-| \+
  4           \+  \+  |-|
  5           |-| |-| \+
  6           |-| \+  |-|
  7           \+  |-| |-|
  8           |-| |-| |-|
  =========== === === ===

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="TETR" APPEAR="Tetrahedra" KIND="INTS" SIZE="8" LEVEL="ADVANCED" DEFAULT_VALUE="1">
              %%Keyword: TETR <advanced>
              <HELP>
              Keyword, followed by a single line containing eight integers equal to either 0 or 1.
              Specifies which tetrahedra are used to complement the crystal cell with EMBQ charges.
              Each integer corresponds to a single tetrahedron that is associated with a single corner
              of the crystal cell (see User's Guide for details).
              The tetrahedron is used if the corresponding parameter equals to 1 and not used if it equals to 0.
              Default: use all eight tetrahedra.
              </HELP>
              </KEYWORD>

:kword:`SHIFt`
  Keyword, followed by a single real number.
  Specifies the shift (in fractional coordinates) of the tetrahedra from the cell corners outwards.
  Default value is zero.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="SHIF" APPEAR="Shift" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.0">
              %%Keyword: SHIF <advanced>
              <HELP>
              Keyword, followed by a single real number.
              Specifies the shift (in fractional coordinates) of the tetrahedra from the cell corners outwards.
              Default value is zero.
              </HELP>
              </KEYWORD>

:kword:`NANOcluster`
  Keyword followed by two input lines.
  The first line contains a single integer number (:math:`n`) which specifies the shape of a nano-cluster generated using the modified cells. Possible values of :math:`n`:

  .. container:: list

    1 --- to generate a *cubic* nano-cluster

    2 --- to generate a *block* nano-cluster

    3 --- to generate a *spherical* nano-cluster.

  .. compound::

    The size of the nano-cluster is defined in the following line.
    The number of input parameters depends on the shape of the nano-cluster.
    For a *cube*, provide one integer :math:`k` to generate a nano-cluster of :math:`(2k+1)^3` unit cells.
    For a *block*, provide six integers :math:`k_1`, :math:`k_2`, :math:`m_1`, :math:`m_2`, :math:`n_1`, :math:`n_2`
    to generate a nano-cluster of

    .. math:: (k_2 - k_1 + 1) \times ( m_2 - m_1 + 1) \times (n_2 - n_1 + 1)

    unit cells. For a *sphere*, provide one real number to generate a nano-cluster of radius :math:`R` (in Å).

  This keyword can be used instead of keywords :kword:`NCCube`, :kword:`NCBLock`, and :kword:`NCSPhere`. Note that only one nano-cluster will be generated.
  Default: the nano-cluster is not generated.

  .. xmldoc:: <GROUP MODULE="EMBQ" NAME="CLUSTER" APPEAR="Nano-cluster specification" KIND="BOX" LEVEL="BASIC" WINDOW="INPLACE">

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="NANO" APPEAR="Nano-cluster" KIND="STRINGS" SIZE="2" LEVEL="ADVANCED" EXCLUSIVE="NCCU,NCBL,NCSP">
              %%Keyword: NANO <advanced>
              <HELP>
              Keyword followed by two input lines.
              The first line contains a single integer number (n) which specifies the shape of a nano-cluster
              generated using the modified cells.
              Possible values of n:

              1 -- to generate a cubic nano-cluster;
              2 -- to generate a block nano-cluster;
              3 -- to generate a spherical nano-cluster.

              The size of the nano-cluster is defined in the following line.
              The number of input parameters depends on the shape of the nano-cluster.
              For a cube (n=1), provide one integer k to generate a nano-cluster of (2k+1)^3 unit cells.
              For a block (n=2), provide six integers k1 k2 m1 m2 n1 n2 to generate a nano-cluster of
                (k2-k1+1)×(m2-m1+1)×(n2-n1+1)
              unit cells.
              For a sphere (n=3), provide one real number to generate a nano-cluster of radius R (in Angstroms).
              This keyword can be used instead of keywords NCCube, NCBLock, and NCSPhere.
              Note that only one nano-cluster will be generated.
              Default: the nano-cluster is not generated.
              </HELP>
              </KEYWORD>

:kword:`NCCUbe`
  .. compound::

    Keyword, followed by a single integer number :math:`k`.
    Specifies the shape and size of the nanocluster constructed from the modified unit cells.
    The nanocluster is generated as a block of

    .. math:: (2k+1)\times(2k+1)\times(2k+1)

    cells along the lattice vectors :math:`\vec{a}_1`, :math:`\vec{a}_2`, and :math:`\vec{a}_3`, respectively.
    Default: the nanocluster is not generated.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="NCCU" APPEAR="Nano-cube" KIND="INT" LEVEL="ADVANCED" DEFAULT_VALUE="0" EXCLUSIVE="NCBL,NCSP,NANO">
              %%Keyword: NCCU <advanced>
              <HELP>
              Keyword, followed by a single integer number k.
              Specifies the shape and size of the nanocluster constructed from the modified unit cells.
              The nanocluster is generated as a block of (2k+1)×(2k+1)×(2k+1) cells
              along the lattice vectors a1, a2, and a3, respectively.
              Default: the nanocluster is not generated.
              </HELP>
              </KEYWORD>

:kword:`NCBLock`
  .. compound::

    Keyword followed by six integers: :math:`k_1` :math:`k_2` :math:`m_1` :math:`m_2` :math:`n_1` :math:`n_2`.
    Specifies the shape and size of the nanocluster constructed from the modified unit cells.
    The nanocluster is generated as a block of

    .. math:: (k_2-k_1+1)\times(m_2-m_1+1)\times(n_2-n_1+1)

    cells along the lattice vectors :math:`\vec{a}_1`, :math:`\vec{a}_2`, and :math:`\vec{a}_3`, respectively.
    Default: the nanocluster is not generated.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="NCBL" APPEAR="Nano-block" KIND="INTS" SIZE="6" LEVEL="ADVANCED" DEFAULT_VALUE="0" EXCLUSIVE="NCCU,NCSP,NANO">
              %%Keyword: NCBL <advanced>
              <HELP>
              Keyword followed by six integers: k1 k2 m1 m2 n1 n2
              Specifies the shape and size of the nanocluster constructed from the modified unit cells.
              The nanocluster is generated as a block of [(k2-k1)+1]×[(m2-m1)+1]×[(n2-n1)+1] cells
              along the lattice vectors a1, a2, and a3, respectively.
              Default: the nanocluster is not generated.
              </HELP>
              </KEYWORD>

:kword:`NCSPhere`
  Keyword followed by a single real number.
  Specifies the shape and radius (in Å) of the nano-cluster constructed from
  the modified unit cells.
  Default: the nanocluster is not generated.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="NCSP" APPEAR="Nano-sphere" KIND="REAL" LEVEL="ADVANCED" EXCLUSIVE="NCCU,NCBL,NANO">
              %%Keyword: NCSP <advanced>
              <HELP>
              Keyword followed by a single real number.
              Specifies the shape and radius (in Angstroms) of the nano-cluster constructed from
              the modified unit cells.
              Default: the nanocluster is not generated.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`PRINt`
  Keyword, followed by a single integer number.
  Specifies the general print level:

  .. container:: list

    0 --- minimal print out;

    1 --- intermediate print out;

    2 --- full print out.

  Default: use the global |molcas| print level.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="PRIN" APPEAR="Print level" KIND="CHOICE" LIST="0: Minimal,1: Intermediate,2: Full" LEVEL="ADVANCED">
              %%Keyword: PRIN <advanced>
              <HELP>
              Keyword, followed by a single integer number.
              Specifies the general print level:

              0 -- minimal print out;
              1 -- intermediate print out;
              2 -- full print out.

              Default: use the global MOLCAS print level.
              </HELP>
              </KEYWORD>

:kword:`CALCulate`
  Keyword, followed by a single integer number.
  Requests calculation of the electrostatic potential and field at all centres of the nano-cluster.
  Possible values are:

  .. container:: list

    0 --- calculate neither the potential nor components of the field vector (default);

    1 --- calculate the potential only;

    2 --- calculate the potential and components of the field vector.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="CALC" APPEAR="Calculate" KIND="CHOICE" LIST="0: None,1: Potential,2: Potential and field" LEVEL="ADVANCED" DEFAULT_VALUE="0">
              %%Keyword: CALC <advanced>
              <HELP>
              Keyword, followed by a single integer number.
              Requests calculation of the electrostatic potential and field at all centres of the nano-cluster.
              Possible values are:

              0 -- calculate neither the potential nor the field (default);
              1 -- calculate the potential only;
              2 -- calculate the potential and field.
              </HELP>
              </KEYWORD>

:kword:`QMCLuster`
  Keyword, followed by a single integer equal to the number of atoms in the QM cluster
  and a list of the corresponding Cartesian coordinates (in Å).
  Specifies geometrical structure of the QM cluster.
  Default: number of the QM cluster atoms is zero.

  .. xmldoc:: <KEYWORD MODULE="EMBQ" NAME="QMCL" APPEAR="QM atoms" KIND="REALS_COMPUTED" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: QMCL <advanced>
              <HELP>
              Keyword, followed by a single integer equal to the number of atoms in the QM cluster
              and a list of the Cartesian corresponding coordinates (in Angstroms).
              Default: number of the QM cluster atoms is zero.
              </HELP>
              </KEYWORD>

Limitations
...........

* The largest electric moment :kword:`ELMOment` is limited to 10.
* Number of atoms in :kword:`UCAToms` is limited to 1000.
* Number of atoms in :kword:`QMCLuster` is limited to 1000.
* Tetrahedra in :kword:`TETRahedra` are oriented so as three of their edges are parallel to the cell vectors.
* The value of :kword:`SHIFt` is the same for all tetrahedra.

Input example
.............

::

  &EMBQ &END
  Elmoment
  4                              Largest moment to eliminate
  Tetrahedra
  1 1 1 1 0 0 0 0                Use the tetrahedra (if 1) or not (if 0)
  Shift
  0.5                            Shift the tetrahedra from the corner sites outward by this value
  Nanocluster
  3                              Shape of the nano-cluster (1 --- cube, 2 --- cuboid, 3 --- sphere)
  30.0                           Size of the nano-cluster. Here, radius of the sphere (in Å).
  Print
  2                              Printing level
  Calculate
  2                              Calculate electrostatic potential and its derivatives.
  UCvectors
  4.593730 0.000000 0.000000     Unit cell vector a1 (in Å)
  0.000000 4.593730 0.000000     Unit cell vector a2 (in Å)
  0.000000 0.000000 2.958120     Unit cell vector a3 (in Å)
  UCatoms
  6                              Number of atoms in the cell
  0.000000000   0.000000000   0.000000000   4.0
  2.296865000   2.296865000   1.479060000   4.0
  1.402465769   1.402465769   0.000000000  -2.0
  3.699330769   0.894399231   1.479060000  -2.0
  3.191264231   3.191264231   0.000000000  -2.0
  0.894399231   3.699330769   1.479060000  -2.0
  QMatoms
  4                              Number of atoms in the QM cluster
  1.402465769   1.402465769   0.000000000
  2.296865000   2.296865000  -1.479060000
  2.296865000   2.296865000   1.479060000
  0.000000000   0.000000000   0.000000000
  End of Input

.. xmldoc:: </MODULE>
.. index::
   single: Program; FFPT
   single: FFPT

.. _UG\:sec\:ffpt:

:program:`ffpt`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="FFPT">
            %%Description:
            <HELP>
            This program applies perturbations to the one-electron Hamiltonian and the nuclear repulsion term
            for finite field perturbation calculations. These fields can be and
            external electric field or due the quadrupole moment of one or several nuclei.
            Additional contributions can be first order relativistic integrals (Darwin 1-el. term and mass-velocity contributions), or
            the so-called Well-integrals used in some forms of reaction field calculations.
            </HELP>

The program
:program:`FFPT` prepares the one-electron integral file generated by
:program:`SEWARD` for subsequent finite-field perturbation
calculations. To do so, the core Hamiltonian matrix is always
reconstructed from the nuclear attraction and kinetic energy integrals.
The perturbation matrix is then added to the core
Hamiltonian matrix where the external perturbation and its strength is
specified by input. Any suitable combination of the perturbations
is allowed. Following some examples

#. **Dipole moment operator:**
   This option corresponds
   to a homogeneous external field perturbation and can be used to
   calculate dipole moments and dipole polarizabilities.

#. **Quadrupole and higher electric moment operators:**
   This option
   corresponds to a non homogeneous external field perturbation and can be
   used to calculate quadrupole moments and quadrupole
   polarizabilities, etc.

#. **Relativistic corrections:**
   This option is used to
   calculate perturbational relativistic corrections (sum of the mass-velocity
   and the one-electron Darwin contact term) to the total energy. Note that care
   must be taken to avoid variational collapse, i.e. the perturbation correction
   should be small.

For a complete list of one-electron integrals which can be
evaluated by the program :program:`SEWARD` check out
:numref:`UG:sec:seward_description` and, especially,
:numref:`UG:sec:one-electron_integral_labels`.

Note, the perturbation matrices consist of the electronic contributions,
only. The quadrupole, electric field gradient and higher electric moment
perturbation matrices are given as the traceless tensors.

.. _UG\:sec\:ffpt_dependencies:

Dependencies
------------

In order to complete successfully, the program :program:`FFPT` needs
the one-electron integral file. The latter must include all types
of integrals needed to construct the perturbed one-electron
Hamiltonian.

.. _UG\:sec\:ffpt_files:

Files
-----

Input files
...........

The program :program:`FFPT` needs :file:`ONEINT`
(for more information see :numref:`UG:sec:files_list`).

Output files
............

The program :program:`FFPT` creates/updates file :file:`ONEINT` on output:

.. _UG\:sec\:ffpt_input:

Input
-----

The input to the :program:`FFPT` program begins with the program name: ::

  &FFPT

General keywords
................

The following keywords are known to the
:program:`FFPT` utility:

.. class:: keywordlist

:kword:`TITLe`
  Followed by a title line

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="TITLE" APPEAR="Title (optional)" KIND="STRING" LEVEL="BASIC">
              <HELP>
              Enter title line
              </HELP>
              %%Keyword: TITLe <basic>
              Followed by a title line
              </KEYWORD>

  .. xmldoc:: <GROUP MODULE="FFPT" NAME="XFIELD" APPEAR="External Electric Field options" KIND="BOX" LEVEL="BASIC">

:kword:`DIPO`
  Add the dipole moment perturbation operator. By default, the dipole moment
  integrals are always computed with respect to the center of nuclear
  charge. The keyword is followed by up to three additional input
  lines. Each line consists of two entries, the component
  of the dipole operator and the perturbation length. The component is
  specified by a single letter (X, Y or Z).

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="DIPO" APPEAR="External Electric Field" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add the external electric field. Each line contain the letters X, Y, or Z to indicate
              the component of the electric field followed by a real number to specify the strength.
              </HELP>
              %%Keyword: DIPO <basic>
              %%Values: i w
              %%Range: (X,Y,Z) (-1.,1.)
              Add the dipole moment perturbation operator. By default, the dipole moment
              integrals are always computed with respect to the center of nuclear
              charge. The keyword is followed by up to three additional input
              lines. Each line consists of two entries, the component
              of the dipole operator and the perturbation length. The component is
              specified by a single letter (X, Y or Z).
              </KEYWORD>

:kword:`QUAD`
  Add the quadrupole moment perturbation operator.
  The keyword is followed by at least one additional
  input line and may be complemented by as many additional lines as
  needed. Each line consists of two entries, the component
  of the operator and the perturbation strength. The component is
  specified by a pair of letters (XX, XY, XZ, YY, YZ or ZZ).
  By default, the quadrupole moment integrals are calculated with
  respect to the center of mass. For any other selection
  the origin of the perturbation operator also needs to be specified
  by entering a line starting with the string ORIG followed by the coordinates.

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="QUAD" APPEAR="External Electric Field Gradient" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add the external electric field gradient. Each line contains the letters XX, XY, XZ, YY, YZ, or ZZ to indicate
              the component of the electric field gradient followed by a real number to indicate the value.
              </HELP>
              %%Keyword: QUAD <basic>
              %%Values: i [w,x] [y] [z]
              %%Range: (XX,XY,XZ,YY,YZ,ZZ,ORIG)
              Add the quadrupole moment perturbation operator.
              The keyword is followed by at least one additional
              input line and may be complemented by as many additional lines as
              needed. Each line consists of two entries, the component
              of the operator and the perturbation strength. The component is
              specified by a pair of letters (XX, XY, XZ, YY, YZ or ZZ).
              By default, the quadrupole moment integrals are calculated with
              respect to the center of mass. For any other selection
              the origin of the perturbation operator also needs to be specified
              by entering a line starting with the string ORIG followed by the coordinates.
              </KEYWORD>

:kword:`OCTU`
  Add the octupole moment perturbation operator.
  The keyword is followed by at least one additional
  input line and may be complemented by as many additional lines as
  needed. Each line consists of two entries, the component
  of the operator and the perturbation strength. The component is
  specified by a triple of letters (XXX, XXY, XXZ, XYY, XYZ, XZZ, YYY, YYZ, YZZ, or ZZZ).
  By default, the octupole moment integrals are calculated with
  respect to the center of mass. For any other selection
  the origin of the perturbation operator also needs to be specified
  by entering a line starting with the string ORIG followed by the coordinates.

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="OCTU" APPEAR="External Electric Field Hessian" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add the external electric field Hessian. Each line contains the letters XXX, XXY, XXZ, XYY, XYZ, XZZ, YYY, YYZ, YZZ, or ZZZ to indicate
              the component of the electric field Hessian followed by a real number to indicate the value.
              </HELP>
              %%Keyword: OCTU <basic>
              %%Values: i [w,x] [y] [z]
              %%Range: (XXX,XXY,XXZ,XYY,XYZ,XZZ,YYY,YYZ,YZZ,ZZZ,ORIG)
              Add the octupole moment perturbation operator.
              The keyword is followed by at least one additional
              input line and may be complemented by as many additional lines as
              needed. Each line consists of two entries, the component
              of the operator and the perturbation strength. The component is
              specified by a triple of letters (XXX, XXY, XXZ, XYY, XYZ, XZZ, YYY, YYZ, YZZ, or ZZZ).
              By default, the octupole moment integrals are calculated with
              respect to the center of mass. For any other selection
              the origin of the perturbation operator also needs to be specified
              by entering a line starting with the string ORIG followed by the coordinates.
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`EFLD`
  Add the electric field perturbation operator.
  The keyword is followed by at least two additional
  input lines and may be complemented by as many additional lines as
  needed. Each line consists of two entries, the component
  of the operator and the perturbation strength. The component is
  specified by a single letter (X, Y or Z).
  In addition, the origin of the perturbation operator also needs to be specified
  by entering a line starting with the string ORIG followed by the coordinates.

  .. xmldoc:: <GROUP MODULE="FFPT" NAME="NFIELD" APPEAR="Nuclear charge fields" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="EFLD" APPEAR="Nuclear dipole moment" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add contributions due to an nuclear dipole moment. Each line contains the letters X, Y, or Z to indicate
              component of the nuclear dipole moment followed by a real number to indicate the value. Finally a line is added with the
              syntax "ORIG x y z" is used to specify the position of the center considered.
              </HELP>
              %%Keyword: EFLD <basic>
              %%Values: i [w,x] [y] [z]
              %%Range: (X,Y,Z,ORIG)
              Add the electric field perturbation operator.
              The keyword is followed by at least two additional
              input lines and may be complemented by as many additional lines as
              needed. Each line consists of two entries, the component
              of the operator and the perturbation strength. The component is
              specified by a single letter (X, Y or Z).
              In addition, the origin of the perturbation operator also needs to be specified
              by entering a line starting with the string ORIG followed by the coordinates.
              </KEYWORD>

:kword:`EFGR`
  Add the electric field gradient perturbation operator.
  The keyword is followed by at least one additional
  input line and may be complemented by as many additional lines as
  needed. Each line consists of two entries, the component
  of the operator and the perturbation strength. The component is
  specified by a pair of letters (XX, XY, XZ, YY, YZ or ZZ).
  In addition, the origin of the perturbation operator also needs to be specified
  by entering a line starting with the string ORIG followed by the coordinates.

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="EFGR" APPEAR="Nuclear quadrupole moment" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add contributions due to an nuclear quadrupole moment. Each line contains the letters XX, XY, XZ, YY, YZ, or ZZ to indicate
              component of the nuclear quadrupole moment followed by a real number to indicate the value. Finally a line is added with the
              syntax "ORIG x y z" is used to specify the position of the center considered.
              </HELP>
              %%Keyword: EFGR <basic>
              %%Values: i [w,x] [y] [z]
              %%Range: (XX,XY,XZ,YY,YZ,ZZ,ORIG)
              Add the electric field gradient perturbation operator.
              The keyword is followed by at least one additional
              input line and may be complemented by as many additional lines as
              needed. Each line consists of two entries, the component
              of the operator and the perturbation strength. The component is
              specified by a pair of letters (XX, XY, XZ, YY, YZ or ZZ).
              In addition, the origin of the perturbation operator also needs to be specified
              by entering a line starting with the string ORIG followed by the coordinates.
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`RELA`
  Add the relativistic correction (mass-velocity and one-electron
  Darwin contact term). The command is followed by one additional line
  of input specifying the perturbation strength.

  .. xmldoc:: <GROUP MODULE="FFPT" NAME="MFIELD" APPEAR="Miscellaneous Perturbations" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="RELA" APPEAR="Relativistic additions" KIND="REAL" LEVEL="BASIC">
              <HELP>
              Specify the perturbation strength of the relativistic correction (mass-velocity and one-electron
              Darwin contact term).
              </HELP>
              %%Keyword: RELA <basic>
              %%Values: w
              %%Range: (0,1)
              Add the relativistic correction (mass-velocity and one-electron
              Darwin contact term). The command is followed by one additional line
              of input specifying the perturbation strength.
              </KEYWORD>

:kword:`GLBL`
  This command marks the beginning of a more general perturbation
  description which is not included as a subcommand of the
  :kword:`FFPT` command.
  This card is followed by as many additional input lines as needed and
  is terminated if the next input line starts with a command. Each input
  line contains only one perturbation description and three data fields
  which are: Label, component and perturbation strength. The label
  consists of a character string of length 8 and names the one-electron
  integrals produced by :program:`SEWARD`. The component of
  an operator is given as an integer. The last parameter denotes
  the strength of a perturbation operator and is given as a real number.
  For a list of the available one-electron integral labels refer to
  :numref:`UG:sec:seward`.

  For example to add Pauli repulsion integrals for
  reaction field calculations the input would look like: ::

    &FFPT
    GLBL
    'Well   1' 1 1.000
    'Well   2' 1 1.000
    'Well   3' 1 1.000

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="GLBL" APPEAR="Well-integrals" KIND="CUSTOM" LEVEL="BASIC">
              <HELP>
              Add so-called well-integrals to the one-electron Hamiltonian. Syntax " 'Well   n' 1 x " where
              n is specifying the index of the well-integrals as computed by Seward and x is the coefficient
              used when the term is added (normally the value should be 1.0).
              </HELP>
              %%Keyword: GLBL <advanced>
              This command marks the beginning of a more general perturbation
              description which is not included as a predefined command.
              This card is followed by as many additional input lines as needed and
              is terminated if the next input line starts with a command. Each input
              line contains only one perturbation description and three data fields
              which are: Label, component and perturbation strength. The label
              consists of a character string of length 8 and names the one-electron
              integrals produced by SEWARD. The last parameter denotes the strength
              of a perturbation operator and is given as a real number. For a list
              of the available one-electron integral labels refer to the program
              description of SEWARD.

              example:
                &FFPT
                GLBL
                'Well   1' 1 1.000
                'Well   2' 1 1.000
                'Well   3' 1 1.000
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`SELEctive`
  .. compound::

    With the same localization scheme as used in :program:`LOPROP`, the perturbation
    from :program:`FFPT` is localized in an orthogonal basis. Then the user can
    specify on which basis functions the perturbation should act.
    For example, the input ::

      &FFPT
      DIPO
      X 0.005
      SELECTIVE
      2
      .true. 1 26
      .false. 67 82
      .true.
      0.5

    leads to that the perturbation only acts on densities with (1) both basis
    function indexes in the set :math:`\{1,\ldots,26\}` or (2) one index
    in the set :math:`\{1,\ldots,26\}` while the other is in the set
    :math:`\{67,\ldots,82\}`, and in this case the perturbation should be multiplied
    by 0.5.; all other densities are unaffected by the perturbation.
    We call the former type of subset an atom domain and the latter a bond
    domain. Generally, the input structure is this: First line specifies how
    many subsets, :math:`N`, that will be defined. Then follow :math:`N` lines starting
    with a logical flag telling if the subset is an atom domain with the starting
    and ending basis function indexes thereafter. :math:`N-1` lines follow where the
    bond domain is defined in the following way: ::

      Do i=2,nSets
        Read(*,*)(Bonds(i,j),j=1,i-1)
      Enddo

  Finally a scalar is given which scales the defined bond domains.

  The LoProp-functions will almost coincide with the
  original input AO-basis, although the localization will modify the meaning
  slightly, hence it is not possible to exactly localize the perturbation to
  a group of atoms; :program:`LOPROP` is a way to come close to perfect
  localization. :program:`FFPT` calls :program:`LOPROP` internally and no call to
  :program:`LOPROP` has to specified by the user.

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="SELE" APPEAR="Selective perturbation" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: SELE <advanced>
              <HELP>
              Specify on which basis functions the perturbation should act.
              </HELP>
              </KEYWORD>

:kword:`CUMUlative`
  Adds the perturbation to the current H0, enabling many consecutive
  FFPT calls. Without this keyword, the perturbation always starts from
  the unperturbed H0.

  .. xmldoc:: <GROUP MODULE="FFPT" NAME="AFIELD" APPEAR="Additional options" KIND="BOX" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="FFPT" NAME="CUMU" APPEAR="Cumulative (optional)" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: CUMU <advanced>
              <HELP>
              Adds the perturbation to the current H0, enabling many consecutive
              FFPT calls. Without this keyword, the perturbation always starts from
              the unperturbed H0.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Input example
-------------

The following input will prepare the one-electron integral file generated by
:program:`SEWARD` for subsequent finite-field perturbation calculations by adding
a linear electric field in z-direction. ::

  &FFPT
  DIPO
  Z 0.001

Response properties are obtained by numerical differentiation of the total energy
with respect to the field parameter. For definitions of the response properties
the interested reader is referred to the paper of A.D. Buckingham :cite:`Buckingham:67`.
According to the definition of the dipole
moment, it is obtained as the first derivative of the energy with
respect to the field strength. Similarly, the dipole polarizability is given
by the second derivative of the energy with respect to the field strength.

.. xmldoc:: </MODULE>
.. index::
   single: Program; MPPROP
   single: MPPROP

.. _UG\:sec\:mpprop:

:program:`mpprop`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. _UG\:sec\:mpprop_description:

Description
-----------

.. xmldoc:: <MODULE NAME="MPPROP">
            %%Description:
            <HELP>
            The MpProp program generates a distributed multipole expansion of the charge density
            of a molecule and atom distributed polarizabilities.
            </HELP>

The :program:`MPPROP` is a general distributed multipole expansion, and a first order polarizabilty analysis program.
It will use the one electron integrals to generate the distribution. The order of the distributed multipole expansion is defined by
:program:`SEWARD`. In order to generate distributed multipoles of higher order than 2. One has to use the Keyword
MULTipoles in :program:`SEWARD`. :program:`SEWARD` also needs the Keyword NEMO to arrange the integrals in correct order.

.. _UG\:sec\:mpprop_dependencies:

Dependencies
------------

The :program:`MPPROP` program requires the one-electron integral file
:file:`ONEINT` and the communications file :file:`RUNFILE`,
which contains among others the
multipole integrals produced by :program:`SEWARD`.

.. index::
   pair: Files; MPPROP

.. _UG\:sec\:mpprop_files:

Files
-----

Below is a list of the files that are used/created by the program
:program:`MPPROP`.

Input files
...........

.. class:: filelist

:file:`ONEINT`
  One-electron integral file generated by the program :program:`SEWARD`.

:file:`RUNFILE`
  File for communication of auxiliary information generated by the different programs
  e.g. :program:`SEWARD`.

:file:`INPORB`
  :file:`SCFORB` or :file:`RASORB` file containing the orbitals of a previous
  :program:`SCF` run or a :program:`RASSCF` run, which are used now as vectors in the :program:`MPPROP` run.

Output files
............

.. class:: filelist

:file:`MPPROP`
  The distributed multipole expansion.

.. index::
   pair: Input; MPPROP

.. _UG\:sec\:mpprop_input:

Input
-----

Below follows a description of the input to :program:`MPPROP`. The keywords
are always significant to four characters, but in order to make the
input more transparent, it is recommended to use the full keywords.
The :program:`MPPROP` program section of the |molcas| input starts with the
program: ::

  &MPPROP

There are no compulsory keywords.

Optional general keywords
.........................

.. class:: keywordlist

:kword:`BONDs`
  Use this Keyword to define bond between atoms.
  This Keyword should be followed by a line of atomlabels
  separated by a space. The following line can define
  another bond. This Keyword should be ended by a END statement
  in the last line. The example below means that O1 will bond to H1 and H2.
  It does not mean that H1 is bonded to H2. ::

    BOND
    O1 H1 H2
    END

  .. xmldoc:: %%Keyword: BONDs <basic>
              Use this Keyword to define bond between atoms.
              This Keyword should be followed by a line of atomlabels
              separated by a space. The following line can define
              another bond. This Keyword should be ended by a END statement
              in the last line. The example below means that O1 will bond to H1 and H2.
              It does not mean that H1 is bonded to H2.

:kword:`TITLe`
  This Keyword specifies the title of the molecule. This will be
  recognized by the Nemo package. And you are requested to use
  this Keyword. It is defined in the program as a Character*80.

  .. xmldoc:: <KEYWORD MODULE="MPPROP" NAME="TITLE" APPEAR="Title" KIND="STRING" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              This Keyword specifies the title of the molecule. This will be
              recognized by the Nemo package. And you are requested to use
              this Keyword. It is defined in the program as a Character*80
              </HELP>
              </KEYWORD>

:kword:`LUMOrb`
  This Keyword tells :program:`MPPROP` to use an INPORB file for
  the one electron densities.

  .. xmldoc:: <KEYWORD MODULE="MPPROP" NAME="LUMORB" APPEAR="Use INPORB" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: LUMOrb <basic>
              <HELP>
              This Keyword tells MPPROP to use an INPORB file for
              the one electron densities.
              </HELP>
              </KEYWORD>

:kword:`TYPE`
  This is to specify the typen of the atom.
  Where the first number is the atomnumber m, counted in the order it was defined in :program:`SEWARD`.
  The second number is the type of the atom n. ::

    TYPE
    m n

  .. xmldoc:: %%Keyword: TYPE <basic>
              This is to specify the typen of the atom.
              Where the first number is the atomnumber m counted as in SEWARD.
              The second number is the type of the atom n.

:kword:`POLArizability`
  This specifies if the polarizability should be calculated or not. ::

    POLArizability
    m

  .. container:: list

    .. index::
       single: MPPROP; m=0

    **m=0** Means no polarizability should be calculated.

    .. index::
       single: MPPROP; m=1

    **m=1** (Default) Means polarizability should be calculated.

    .. 2 !not implemented! the polarizability according to the new distribution

  .. xmldoc:: <KEYWORD MODULE="MPPROP" NAME="POLARIZABILITY" APPEAR="Polarizability" KIND="CHOICE" LIST="0: No polarizability,1: Compute polarizability" LEVEL="BASIC" DEFAULT_VALUE="1">
              %%Keyword: POLArizability <basic>
              <HELP>
              This specifies if the polarizability should be calculated or not.

              0 -- Means no polarizability should be calculated.
              1 -- (Default) Means polarizability should be calculated.
              </HELP>
              </KEYWORD>

:kword:`NONEarestAtom`
  The program is written in the way that multipoles should be moved
  to the nearest atom if the nearest atom is closer than any of the
  bonding atoms. Note that the move will be to atoms and not nearest bond.

  .. xmldoc:: <KEYWORD MODULE="MPPROP" NAME="NONEARESTATOM" APPEAR="Do not move to nearest atom" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NONEarestAtom <basic>
              <HELP>
              The program is written in the way that multipoles should be moved
              to the nearest atom if the nearest atom is closer than any of the
              bonding atoms. Note that the move will be to atoms and not nearest bond.
              This can be implemented if requested
              </HELP>
              </KEYWORD>

:kword:`ALLCenter`
  This Keyword means that all centers are considered for the distributed multipole expansion.

  .. xmldoc:: <KEYWORD MODULE="MPPROP" NAME="ALLCENTER" APPEAR="Consider all centers" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ALLCenter <basic>
              <HELP>
              This Keyword means that all centers are considered for the distributed multipole expansion.
              </HELP>
              </KEYWORD>

Limitations
...........

The limitations on the order of the multipole expansion is defined by :program:`SEWARD`.
While the polarizability can only be calculated directly in the program for an scf wavefunction.
And it is limited to first order polarizability

Input examples
..............

First we have the bare minimum of input. This will work well for all systems. ::

  &MPPROP

The next example is a bit more elaborate and show how to use
a few of the keywords. The system is formic-acid. ::

  &Gateway
  Title
  Fa
  NEMO
  Basis set
  C.ANO-L...3s2p1d.
  C1      2.15211991525414     -3.97152266198745      4.15134452433510
  End of Basis set

  Basis set
  O.ANO-L...4s3p1d.
  O2     3.99101917304681     -2.23465022227817      3.72611355598476
  O3     2.36712399248396     -5.81178517731397      5.48680572323840
  End of Basis set

  Basis set
  H.ANO-L...3s1p.
  H4      0.43787447048429     -3.44210745229883      3.08410918233085
  End of Basis set

  Basis set
  H.ANO-L...3s2p.
  H5     5.46574083366162     -2.78397269852552      4.70186773165853
  End of Basis set

  &Seward

  &Scf
  Title
  Formic-acid
  Occupied
    12

  &MPPROP
  Title
  Formic-acid
  lumorb
  POLArizability
  1
  BONDs
  C1 O2 O3 H4
  O2 H5
  End
  TYPE
  2 1
  3 2
  4 1
  5 2
  End

.. xmldoc:: </MODULE>
.. index::
   single: Program; GENANO
   single: GENANO

.. _UG\:sec\:genano:

:program:`genano`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="GENANO">
            %%Description:
            <HELP>
            This program is used to construct ANO type basis sets.
            </HELP>

:program:`GENANO` is a program for
determining the contraction coefficients for
generally contracted basis sets :cite:`Raffenetti:73`.
They are determined by diagonalizing a density matrix,
using the eigenvectors (natural orbitals) as
the contraction coefficients, resulting
in basis sets of the :index:`ANO` (:index:`Atomic Natural Orbitals`)
type :cite:`Almlof:87`.

.. compound::

  Some elementary theory: We can do a spectral resolution of a density matrix :math:`D`

  .. math:: D=\sum_k \eta_k c_k c_k^{\text{T}}
     :label: eqn:d-spectral

  where :math:`\eta_k` is the :math:`k`\th eigenvalue (occupation value)
  and :math:`c_k` is the :math:`k`\th eigenvector (natural orbital).
  The occupation number for a natural orbital is a
  measure of how much this orbital contributes to
  the total one-electron density.
  A natural choice is to disregard the natural orbitals
  with small occupation numbers and use those with large
  occupation numbers to form contracted basis functions as

  .. math:: \varphi_k=\sum_i c_{ki} \chi_i

  where :math:`\chi_i` is the :math:`i`\th primitive basis function.

As a generalization to this approach we can
average over density
matrices from several wave functions, resulting
in basis sets of the density matrix averaged ANO type,
see for example :cite:`anoI,anoII,anoIII,anoIV`.
We can view the averaging of density matrices as a sequence
of rank-1 updates in the same way as in equation :eq:`eqn:d-spectral`.
We have more update vectors than the rank of the matrix, but this
does not really change anything. The important observation is
that all :math:`\eta`\s are positive and no information is lost
in the averaging.

The general guideline for which wave functions to include is
based on what you want to be able to describe.
All wave functions you want an accurate description of
should be included in the averaging.

As an example, let us consider the oxygen atom.
We want to be able to describe the atom by itself accurately,
thus a wave function for the atom is needed, usually at the CI level.
In molecular systems, oxygen usually has a negative charge, thus
including :math:`\ce{O-}` is almost mandatory.
A basis set derived from these two wave function is well
balanced for the majority of systems containing oxygen.
A logical conclusion would be that you need to include a few
*molecular* wave functions of systems containing oxygen, but in
practice this is not necessary. This is due to the fact that
the degrees of freedom describing the orbital shape distortion
when forming bonds are virtually identical to the lowest
correlating orbitals.
On the other hand, a few molecular species have oxygen with
positive charge, thus it may be appropriate to include
:math:`\ce{O+}` in the basis set.

.. compound::

  A wide range of specialized basis sets can also be generated,
  for example a molecular basis set describing Rydberg orbitals,
  see the example in the "Tutorials and Examples" part,
  :numref:`TUT:sec:make_rydberg_basis_sets`.
  There is a possibility to create Rydberg orbitals
  automatically by using the keyword
  :kword:`RYDBERG`. Here all unoccupied orbitals with
  negative orbital energies will be used with the associated
  occupation numbers

  .. math:: \eta_k = e^{6.9(\epsilon_k/\epsilon_0-1)}

  where :math:`\epsilon_k` is the orbital energy of orbital :math:`k` and
  :math:`\epsilon_0` is the lowest orbital energy of all
  virtual orbitals. In order to use this option you need
  to use the
  :program:`SCF` or :program:`RASSCF` program to compute
  the orbitals for a cationic system.

You need one or more wave functions,
represented by formatted orbital files,
to generate the average density matrix.
These natural orbital files can be produced by any of the
wave function generators
:program:`SCF`,
:program:`RASSCF`,
:program:`MRCI` or
:program:`CPF`.
You could also use
:program:`MBPT2` or
:program:`CASPT2`.
This approach has been used in the generation of the ANO-RCC basis sets.
Your specific requirements dictate the choice of
wave function generator, but :program:`MRCI` would
be most commonly used.

You are not restricted to atomic calculations but
can mix molecular and atomic calculations freely.
The restrictions are that the name of the center, for which
you are constructing a basis set, must be the same
in all wave functions.
The center may not be "degenerate", i.e.
it may not generate other centers through symmetry
operations. See the description of :program:`SEWARD`
on :numref:`UG:sec:seward`
for a more extensive discussion.
For example for :math:`\ce{O2}` you cannot use :math:`D_{2h}` symmetry
since this would involve one center that is mirrored into the other.
Another restriction is, of course, that you must use the
same primitive set in all calculations.

.. _UG\:sec\:genano_dependencies:

Dependencies
------------

:program:`GENANO` needs one or more wave functions in the
form of natural orbitals. Thus you need to run one or
more of
:program:`SCF`,
:program:`RASSCF`,
:program:`MRCI` or
:program:`CPF`.
You could also use, for example, :program:`MBPT2` or :program:`CASPT2`
but this is in general not recommended.
:program:`GENANO` also needs the one electron file
:file:`ONEINT` and the :file:`RUNFILE` generated by :program:`SEWARD`.

.. index::
   pair: Files; GENANO

.. _UG\:sec\:genano_files:

Files
-----

Below is a list of the files that :program:`GENANO`
reads/writes.
Files :file:`ONEnnn`, :file:`RUNnnn` and :file:`NATnnn` must be supplied to
the program.
Files :file:`ANO` and :file:`FIG` are generated.
File :file:`PROJ` is an optional input file.

Input files
...........

.. class:: filelist

:file:`RUNnnn`
  This file contains miscellaneous information for the nnn'th
  wave function,
  generated by the program :program:`SEWARD`.
  One file per wave function must be supplied,
  :file:`RUN001`, :file:`RUN002`, ....

:file:`ONEnnn`
  This file contains the one-electron integrals corresponding to
  the nnn'th wave function, generated by the program :program:`SEWARD`.
  One file per wave function must be supplied,
  :file:`ONE001`, :file:`ONE002`, ....

:file:`NATnnn`
  This file contains the natural orbitals corresponding to the
  nnn'th wave function, generated by the appropriate wave function
  generating program.
  One file per wave function must be supplied,
  :file:`NAT001`, :file:`NAT002`, ....

:file:`PROJ`
  This file contains orbitals used for projection of the densities.
  Needs to be available if the keyword :kword:`PROJECT`
  is specified.
  It is compatible in format with the file :file:`ANO`, and can thus be the
  the file :file:`ANO` from a previous run of :program:`GENANO`.

Output files
............

.. class:: filelist

:file:`FIG`
  This file contains a PostScript figure file of eigenvalues.

:file:`ANO`
  This file contains the contraction coefficient matrix organized
  such that each column correspond to one contracted basis function.

.. _UG\:sec\:genano_input:

Input
-----

.. compound::

  The input file must contain the line ::

  &GENANO

  right before the actual input starts. Below is a list of the available keywords.
  Please note that you can not abbreviate any keyword.

.. class:: keywordlist

:kword:`TITLE`
  This keyword starts the reading of title lines,
  with no limit on the number of title lines.
  Reading the input as title lines is stopped as soon
  an the input parser detects one of the other keywords.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="TITLE" APPEAR="Title" LEVEL="BASIC" KIND="STRING">
              %%Keyword: TITLe <basic>
              <HELP>
              This keyword starts the reading of title lines,
              with no limit on the number of title lines.
              Reading the input as title lines is stopped as soon
              an the input parser detects one of the other keywords.
              </HELP>
              This keyword is optional.
              </KEYWORD>

:kword:`SETS`
  This keyword indicates that the next line of input
  contains the number of sets to be used in the
  averaging procedure.
  This keyword must precede :kword:`WEIGHTS` if
  both are supplied.
  This keyword is *optional*, with one set as the default.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="SETS" APPEAR="Sets" LEVEL="BASIC" KIND="INT">
              %%Keyword: SETS <basic>
              <HELP>
              This keyword indicates that the next line of input
              contains the number of sets to be used in the
              averaging procedure.
              </HELP>
              This keyword must precede keyword WEIGHTS if
              both are supplied.
              This keyword is optional, with one set as the default.
              </KEYWORD>

:kword:`CENTER`
  This keyword is followed, on the next line, by the atom
  label for which the basis set is to be generated.
  The label must match the label you supplied to
  :program:`SEWARD`.
  In previous versions of :program:`GENANO` this label had to
  be in uppercase, but this restriction is now lifted and
  the case does not matter.
  This keyword is *compulsory*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="CENTER" APPEAR="Center" LEVEL="BASIC" KIND="STRING">
              %%Keyword: CENTer <basic>
              <HELP>
              This keyword is followed, on the next line, by the atom
              label for which the basis set is to be generated.
              The label must match the label you supplied to
              SEWARD.
              </HELP>
              In previous versions of GENANO this label had to
              be in uppercase, but this restriction is now lifted and
              the case does not matter.
              This keyword is compulsory.
              </KEYWORD>

:kword:`ROWWISE`
  This keyword makes :program:`GENANO` produce the
  contraction coefficients row-wise instead of
  column-wise as is the default.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="ROWWISE" APPEAR="Row-wise" LEVEL="BASIC" KIND="SINGLE">
              %%Keyword: ROWWise <advanced>
              <HELP>
              This keyword makes GENANO to produce the
              contraction coefficients row-wise instead of
              column-wise as is the default.
              </HELP>
              This keyword is optional.
              </KEYWORD>

:kword:`WEIGHTS`
  This keyword must be subsequent to keyword :kword:`SETS`
  if both are supplied.
  This keyword is *optional*,
  with equal weight on each of the sets as default.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="WEIGHTS" APPEAR="Weights" LEVEL="BASIC" KIND="REALS_LOOKUP" SIZE="SETS">
              %%Keyword: WEIGhts <basic>
              <HELP>
              </HELP>
              This keyword must be subsequent to keyword SETS
              if both are supplied.
              This keyword is optional,
              with equal weight on each of the sets as default.
              </KEYWORD>

:kword:`PROJECT`
  This keyword states that you want to project out certain
  degrees of freedom from the density matrix.
  This can be useful for generating, for example,
  node less valence orbitals to be used with ECP's.
  If this keyword is specified, you must supply the file
  :file:`PROJ` obtained as file :file:`ANO` from a previous
  :program:`GENANO` calculation, for instance.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="PROJECT" APPEAR="Project out" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: PROJect <advanced>
              <HELP>
              This keyword states that you want to project out certain
              degrees of freedom from the density matrix.
              This can be useful for generating, for example,
              nodeless valence orbitals to be used with ECP's.
              If this keyword is specified, you must supply the file
              PROJ obtained as file ANO from a previous
              GENANO calculation, for instance.
              </HELP>
              This keyword is optional.
              </KEYWORD>

:kword:`LIFTDEGENERACY`
  This keyword will modify the occupation numbers read from
  the orbitals files. The purpose is to lift the
  degeneracy of core orbitals to avoid rotations.
  The occupation numbers are changed according to
  :math:`\eta'=\eta(1+10^{-3}/n)`
  where :math:`n` is the sequence number of the orbital
  in its irreducible representation.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="LIFTDEGENERACY" APPEAR="Lift degeneracy" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: LIFTdegeneracy <advanced>
              <HELP>
              This keyword will modify the occupation numbers read from
              the orbitals files. The purpose is to lift the
              degeneracy of core orbitals to avoid rotations.
              The occupation numbers are changed according to
              o'=o*(1+10^-3/n)
              where n is the sequence number of the orbital
              in its irreducible representation.
              </HELP>
              This keyword is optional.
              </KEYWORD>

:kword:`RYDBERG`
  This keyword enables automatic generation of Rydberg
  orbitals. With this keyword all occupied orbitals
  will get occupation number zero while the virtual
  orbitals will get a small occupation number
  decreasing with orbital number. Useful with a calculation
  on an cation where the virtual orbitals are near perfect
  Rydberg orbitals.
  Note that you must use orbitals from the
  :program:`SCF` or
  :program:`RASSCF` program.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="RYDBERG" APPEAR="Rydberg orbitals" LEVEL="ADVANCED" KIND="SINGLE">
              %%Keyword: RYDBerg <advanced>
              <HELP>
              This keyword enables automatic generation of Rydberg orbitals.
              With this keyword all occupied orbitals will get occupation
              number zero while the virtual orbitals will get a small
              occupation number decreasing with orbital number. Useful
              with a calculation on an cation where the virtual orbitals
              are near perfect Rydberg orbitals. Note that you must use
              orbitals from the SCF or RASSCF program.
              </HELP>
              This keyword is optional.
              </KEYWORD>

:kword:`NOTHRESHOLD`
  This keyword is used to specify the threshold for
  keeping NO's (natural orbitals). Orbitals with
  occupation numbers less than the threshold are
  discarded. The threshold is read from the line
  following the keyword. Default value is 1.0d-8.

  .. xmldoc:: <KEYWORD MODULE="GENANO" NAME="NOTHRESHOLD" APPEAR="Natural orbital threshold" LEVEL="ADVANCED" KIND="REAL" DEFAULT_VALUE="1.0d-8">
              %%Keyword: NOTHreshold <advanced>
              <HELP>
              This keyword is used to specify the threshold for
              keeping NO's (natural orbitals). Orbitals with
              occupation numbers less than the threshold are
              discarded. The threshold is read from the line
              following the keyword.
              </HELP>
              Default value is 1.0d-8.
              </KEYWORD>

Below is a simple input example, where we construct an
ANO basis set for the carbon atom.
Two wave functions are used, the SCF wave function and the
SDCI wave function for the ground state of the atom.

.. extractfile:: ug/GENANO.input

  &SEWARD
  Title
   Carbon atom
  Symmetry
  x y z
  Expert
  Basis set
  C..... / inline
    6.0 2
     10   10
  5240.6353 782.20479 178.35083 50.815942 16.823562 6.1757760 2.4180490
  .51190000 .15659000 .05480600
  1. 0. 0. 0. 0. 0. 0. 0. 0. 0.
  0. 1. 0. 0. 0. 0. 0. 0. 0. 0.
  0. 0. 1. 0. 0. 0. 0. 0. 0. 0.
  0. 0. 0. 1. 0. 0. 0. 0. 0. 0.
  0. 0. 0. 0. 1. 0. 0. 0. 0. 0.
  0. 0. 0. 0. 0. 1. 0. 0. 0. 0.
  0. 0. 0. 0. 0. 0. 1. 0. 0. 0.
  0. 0. 0. 0. 0. 0. 0. 1. 0. 0.
  0. 0. 0. 0. 0. 0. 0. 0. 1. 0.
  0. 0. 0. 0. 0. 0. 0. 0. 0. 1.
      6    6
  18.841800 4.1592400 1.2067100 .38554000 .12194000 .04267900
  1. 0. 0. 0. 0. 0.
  0. 1. 0. 0. 0. 0.
  0. 0. 1. 0. 0. 0.
  0. 0. 0. 1. 0. 0.
  0. 0. 0. 0. 1. 0.
  0. 0. 0. 0. 0. 1.
      3    3
  1.2838000 .34400000 .09220000
  1. 0. 0.
  0. 1. 0.
  0. 0. 1.
  C  0.000000  0.000000  0.000000
  End of basis

  &SCF
  Occupied =  2 0 0 0 0 0 0 0

  &RASSCF
  Symmetry =  4
  Spin     =  3
  nActEl   =  2 0 0
  Frozen   =  0 0 0 0 0 0 0 0
  Inactive =  2 0 0 0 0 0 0 0
  Ras2     =  0 1 1 0 0 0 0 0
  LevShft  =  0.00
  LumOrb
  Thrs     =  0.1d-8 0.1d-4 0.1d-4

  &MOTRA
  LumOrb
  Frozen   =  1 0 0 0 0 0 0 0

  &GUGA
  Electrons =  4
  Spin      =  3
  Inactive  =  1 0 0 0 0 0 0 0
  Active    =  0 1 1 0 0 0 0 0
  CiAll     =  4

  &MRCI
  SDCI

  >>COPY $Project.RunFile RUN001
  >>COPY $Project.RunFile RUN002
  >>COPY $Project.OneInt  ONE001
  >>COPY $Project.OneInt  ONE002
  >>COPY $Project.RasOrb  NAT001
  >>COPY $Project.CiOrb   NAT002

  &GENANO
  Title
   Carbon atom
  Project
  sets
   2
  Center
  C
  Weights
   0.5 0.5
  >>RM ONE001
  >>RM ONE002
  >>RM NAT001
  >>RM NAT002

.. xmldoc:: </MODULE>
.. index::
   single: Program; ExpBas
   single: ExpBas

.. _UG\:sec\:expbas:

:program:`expbas`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="EXPBAS">
            %%Description:
            <HELP>
            This module is used to manipulate orbital files. By default it is
            used to expand the orbital file to a larger basis set.
            This feature is available only for generally contracted basis sets (ANO or CC).
            The original orbital file INPORB is needed.
            By default, the Runfile, RUNFIL1,
            from the small calculation is also needed. One runs also the
            GATEWAY module with
            the larger basis set to obtain the corresponding runfile, RUNFIL2. The
            program will produce the file EXPORB, which can be used as the input
            orbital file for calculations using the larger basis set.
            The DESYmmetrize keyword is used to transform orbitals with symmetry to
            C1 symmetry.
            If one wants to desymmetrize the orbitals without expanding the basis set, the keyword
            NOEXpand must be used.
            When the DESY keyword is used, in combination with NOEXpand, only the INPORB file is needed. One runs
            the GATEWAY module
            with the same basis set of the original orbital file to obtain the corresponding
            runfile. The program will produce in output the DESORB file.
            In any subsequent calculation using the DESORB file, modified Cartesian
            coordinates are required, the ones internally generated by Molcas and printed
            out in the GATEWAY section of the output.
            </HELP>

This module is used to manipulate orbital files. By default it is
used to expand the orbital file to a larger basis set.
This feature is available only for generally contracted basis sets (ANO or CC).
The original orbital file :file:`INPORB` is needed.
By default, the Runfile, :file:`RUNFIL1`,
from the small calculation is also needed. One runs also the
:program:`GATEWAY` module with
the larger basis set to obtain the corresponding runfile, :file:`RUNFIL2`. The
program will produce the file :file:`EXPORB`, which can be used as the input
orbital file for calculations using the larger basis set.
The :kword:`DESYmmetrize` keyword is used to transform orbitals with symmetry to
C1 symmetry.
If one wants to desymmetrize the orbitals without expanding the basis set, the keyword
:kword:`NOEXpand` must be used.
When the :kword:`DESYmmetrize`
keyword is used, in combination with :kword:`NOEXpand`, only the :file:`INPORB`
file is needed. One runs the :program:`GATEWAY`
with the same basis set of the original orbital file to obtain the corresponding
runfile. The program will produce the :file:`DESORB` file.
In any subsequent calculation using the `DESORB` file, modified Cartesian
coordinates are required, the ones internally generated by |molcas| and printed
out in the :program:`GATEWAY` section of the output.

.. index::
   pair: Dependencies; ExpBas

.. _UG\:sec\:expbas_dependencies:

Dependencies
------------

The :program:`EXPBAS` requires one InpOrb file and two Runfiles produced by other programs.
If the keyword :kword:`NOEXpand` is used, only the :file:`INPORB` file is needed.

.. index::
   pair: Files; ExpBas

.. _UG\:sec\:expbas_files:

Files
-----

Input files
...........

:file:`INPORB`, an orbital file for the original basis set.

Two more files are needed only if the basis set expansion is to be performed:
:file:`RUNFIL1`, the runfile for the small basis set.
:file:`RUNFIL2`, the runfile for the larger basis set.

Output files
............

:program:`EXPBAS` generates the files:
:file:`EXPORB` which contains orbitals, orbital energies, occupation numbers, and
type indices for the larger basis set.
:file:`DESORB` which contains orbitals, orbital energies, occupation numbers, and
type indices for the desymmetrized basis set.

.. index::
   pair: Input; ExpBas

.. _UG\:sec\:expbas_input:

Input
-----

::

  &EXPBAS

Input example
.............

::

  >>COPY name.InpOrb INPORB
  >>COPY name.RunFil1 RUNFIL1
  >>COPY name.Runfil2 RUNFIL2
   &EXPBAS

Optional general keywords
.........................

.. class:: keywordlist

:kword:`NOEXpand`
  Deactivates the basis set expansion.

  .. xmldoc:: <KEYWORD MODULE="EXPBAS" NAME="NOEX" APPEAR="Do not expand basis set" LEVEL="BASIC" KIND="SINGLE">
              %%Keyword: NOEX <basic>
              <HELP>
              Deactivates the basis set expansion.
              </HELP>
              </KEYWORD>

:kword:`DESYmmetrize`
  Activates the basis set desymmetrization.
  The output is sorted first by orbital kind ascendingly (frozen, inactive, RAS1, ...),
  second by occupation number descendingly (2.0, 2.0, 1.x, 0.0, ...),
  third by energy ascendingly (-3.0, -2.0, -2.0, 0.0, 1.0, ...),
  and fourth by irrep ascendingly (1, 2, ..., 8)

  .. xmldoc:: <KEYWORD MODULE="EXPBAS" NAME="DESY" APPEAR="Desymmetrize basis set" LEVEL="BASIC" KIND="SINGLE">
              %%Keyword: DESY <basic>
              <HELP>
              Activates the basis set desymmetrization.
              </HELP>
              </KEYWORD>

:kword:`FILEorb`
  The next line specifies the filename containing the original orbitals that will
  be expanded to the larger basis set. By default a file named :file:`INPORB` will be used.

  .. xmldoc:: <KEYWORD MODULE="EXPBAS" NAME="FILE" APPEAR="Orbitals file" KIND="STRING" LEVEL="BASIC">
              %%Keyword: FileOrb <basic>
              <HELP>
              The next line specifies the filename containing the original orbitals that will
              be expanded to the larger basis set. By default a file named INPORB will be used.
              </HELP>
              </KEYWORD>

**Comments**. For the basis set expansion
procedure, this is the strategy:

#. Do a calculation (SCF, DFT, CASSCF, etc.) with a small basis set. Save the
   produced orbital file and the runfile as: name.Inporb and name.Runfil1.

#. Run a :program:`GATEWAY` to create the second runfile, which is then saved as
   name.Runfil2

#. Run :program:`EXPBAS` as indicated above. The file name.ExpOrb is produced.
   This file can be used as input for large basis set calculations. Note that the
   inactive and active orbitals will have the same place in the list as with the
   smaller basis set, so they can be easily identified.

.. xmldoc:: </MODULE>
.. index::
   single: Program; Gateway
   single: Gateway

.. _UG\:sec\:gateway:

:program:`gateway`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="GATEWAY">
            %%Description:
            <HELP>
            The Gateway module collects information about molecular
            system (geometry, basis sets, symmetry) to be used for future calculations.
            Note that there are two input styles - the old style format and the new XYZ format.
            The input can also contain an embedded reaction field input (starts with the
            "RF-input" keyword and terminates with the "End of RF-input" keyword). Keywords below
            carrying a "(RF)" are associated with that embedded RF-input section.
            Gateway also controls options associated with auxiliary basis sets to be used
            in density fitting procedures.
            </HELP>

The Gateway module collects information about molecular
system (geometry, basis sets, symmetry) to be used for future calculations.

Gateway module is a subset of :program:`seward`. All keywords
for this module can also appear as an input for :program:`SEWARD`, however,
for clarity the information about molecular system can be placed
as an input for this module. Note, that :program:`gateway` does not
compute any integral, and so must be followed by run of :program:`SEWARD`
module.

:program:`GATEWAY` destroys the communication file :file:`RUNFILE`,
if it is used in a combination with geometry optimization it should run
outside the optimization loop.

Input
-----

This sections will describe the various possible input blocks in :program:`Gateway`.
These control

* the molecular structure (coordinates, symmetry and basis sets),
* explicit auxiliary basis sets in terms of CD basis sets (aCD and acCD) or
  external auxiliary basis sets,
* parameters for reaction field calculations, i.e. parameters for the Kirkwood model
  or the PCM model and options for Pauli repulsion integral and external field integrals,
* options for finite nuclear charge distribution models in association with relativistic calculations, and
* the option to use the Saddle method to locate transitions state geometries.

The :program:`Gateway` input section always starts with the program reference: ::

  &GATEWAY

General keywords
................

.. class:: keywordlist

:kword:`TITLE`
  The keyword followed by a title.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="TITLE" APPEAR="Title" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: TITLE <basic>
              <HELP>
              The keyword followed by a title
              </HELP>
              </KEYWORD>

:kword:`TEST`
  :program:`GATEWAY` will only process the input and generate a non-zero return code.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="TEST" APPEAR="Test" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Test <basic>
              <HELP>
              GATEWAY will only process the input and generate a non-zero
              return code.
              </HELP>
              </KEYWORD>

:kword:`EXPErt`
  Activates "expert mode", in which various default settings are
  altered. This will, for example, allow the user to combine
  relativistic and non-relativistic basis sets.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="EXPE" APPEAR="Expert mode" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Expert <advanced>
              <HELP>
              Activates "expert mode", in which various default settings are
              altered. This will, for example, allow the user to combine
              relativistic and non-relativistic basis sets.
              </HELP>
              </KEYWORD>

:kword:`BASDIR`
  The keyword allows to set up an extra location for basis set files.
  The value can be either an absolute path (started from /) or relative to
  submit directory, e.g. BASDIR=.
  In order to use a local copy of a basis set file with name FOO --- place
  this file into directory specified in BASDIR

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BASDIR" APPEAR="BasDir" KIND="STRING" LEVEL="BASIC">
              %%Keyword: BASDIR <basic>
              <HELP>
              The keyword allows to set up an extra location for basis set files.
              The value can be either an absolute path (started from /) or relative to
              submit directory, e.g. BASDIR=.
              In order to use a local copy of a basis set file with name FOO - place
              this file into directory specified in BASDIR
              </HELP>
              </KEYWORD>

:kword:`BASLIB`
  The keyword followed by the absolute path to the basis set library directory. The default
  is the :file:`$MOLCAS/basis_library` directory. Note that this directory must also be host to
  local copies of the .tbl files.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BASLIB" APPEAR="BasLib" KIND="STRING" LEVEL="BASIC">
              %%Keyword: BASLIB <basic>
              <HELP>
              The keyword followed by the absolute path to the basis set library directory. The default
              is the $MOLCAS/basis_library directory. Note that this directory must also be host to
              local copies of the .tbl files.
              </HELP>
              </KEYWORD>

:kword:`RTRN`
  Max number of atoms for which bond lengths, angles and dihedral
  angles are listed, and
  the radius defining the maximum length of a bond follows on
  the next line. The latter is used as a threshold when printing out
  angles and dihedral angles. The length can be followed by
  :kword:`Bohr` or
  :kword:`Angstrom` which indicates the unit in which the length
  was specified, the default is
  :kword:`Bohr`.
  The default values are 15 and 3.0 au.

  .. xmldoc:: %%Keyword: RTRN <advanced>
              Max number of atoms for which bond lengths, angles and dihedral
              angles are listed, and
              the radius defining the maximum length of a bond follows on
              the next line. The latter is used as a threshold when printing out
              angles and dihedral angles. The length can be followed by
              "Bohr" or "Angstrom" which indicates the unit in which the length
              was specified, the default is "Bohr".
              The default values are 15 and 3.0 au.

:kword:`ISOTopes`
  Specify isotopic substitutions or atomic masses. By default, the mass of the most
  abundant or stable isotope is used for each atom. With this keyword different
  isotopes or arbitrary masses can be chosen. The keyword is followed by the number
  :math:`n` of isotopic specifications, and then by :math:`n` lines. Each of these
  lines should contain the symmetry-unique index of the atom for which the default
  mass is to be modified and either the mass number of the desired isotope (tabulated
  masses for most known isotopes are available in the code, use ``0`` for the default
  isotope) or the desired mass in dalton, in the latter case the keyword :kword:`Dalton`
  should follow. Note that all atoms belonging to the same "center type" must have the
  same mass. This usually means all atoms of a given element with the same basis set.
  If more fine-grained specifications are wanted, additional center types must be
  created by using several :kword:`BASIs Set` blocks for the same element (native
  input) or by using labels (XYZ input).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ISOTOPES" APPEAR="Isotopic specification" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: Isotopes <advanced>
              <HELP>
              Specifies isotopes or masses. First write the number of atom masses to change,
              then that number of lines, on each: the symmetry-unique index of the atom and
              (a) the mass number of the isotope, or (b) the mass in dalton and the word DALTON.
              </HELP>
              </KEYWORD>

:kword:`ECPShow`
  Force :program:`GATEWAY` to print ECP parameters.

  .. xmldoc:: <GROUP MODULE="GATEWAY" KIND="BOX" NAME="PROPT" APPEAR="Print options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ECPS" APPEAR="Print ECP info" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: ECPSHOW <basic>
              <HELP>
              Force GATEWAY to print ECP parameters.
              </HELP>
              </KEYWORD>

:kword:`AUXShow`
  Force :program:`GATEWAY` to print auxiliary basis set parameters.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="AUXS" APPEAR="Print auxiliary basis info" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: AUXSHOW <basic>
              <HELP>
              Force GATEWAY to print auxiliary basis set parameters.
              </HELP>
              </KEYWORD>

:kword:`BSSHow`
  Force :program:`GATEWAY` to print basis set parameters.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BSSH" APPEAR="Print basis info" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: BSSHOW <basic>
              <HELP>
              Force GATEWAY to print basis set parameters.
              </HELP>
              </KEYWORD>

:kword:`VERBose`
  Force :program:`GATEWAY` to print a bit more verbose.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="VERB" APPEAR="Verbose output" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Verbose <basic>
              <HELP>
              Force GATEWAY to print a bit more verbose.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Molecular structure: coordinates, symmetry and basis sets
.........................................................

There are three different ways to specify the molecular structure, symmetry and
the basis sets in :program:`Gateway`:

* XYZ input,
* the so-called native input (old |molcas| standard).

.. * XYZ input, and
   * Z-matrix input.

Note that only XYZ input for :program:`Gateway` is supported by Graphical User interface.
:program:`Gateway` makes a decision about the type of the input based on keywords.
If :kword:`Coord` is used, it assumes that the input is in XYZ format.

.. , if :kword:`ZMAT` is used,
   it assumes Z-matrix input.

The three different modes will be described below.

Z-matrix and XYZ input
::::::::::::::::::::::

Some times it is more convenient to set up information about coordinates in
a standard form of Z-matrix or Cartesian coordinates. In this case,
the basis set for the atoms should be specified after the :kword:`XBAS`
keyword. After that either :kword:`ZMAT` or :kword:`XYZ` should appear
to specify the coordinates.
Note that coordinates in these formats use ångström as units.

.. class:: keywordlist

:kword:`XBAS`
  A keyword to specify the basis for atoms. The specification is very similar
  to the native format: ``ATOM.BasisSet``. Each new atom is written at a new line.
  The end of the keyword is marked by an :kword:`End of basis` line.

  If all atoms have the same basis, e.g. ANO-S-VDZ, it is possible to use
  this name without element name. In this case there is no need to specify
  :kword:`End of basis`.

  .. compound::

    Example: ::

      XBAS=STO-3G

    or ::

      XBAS
      C.STO-3G
      H.STO-3G
      End of basis

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="XBAS" APPEAR="Basis set (alternate format)" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: XBAS <basic>
              <HELP>
              A keyword to specify the basis for atoms. The specification is very similar
              to the native format: ATOM.BasisSet. Each new atom is written at a new line.
              The end of the keyword is marked by an 'End of basis' line.
              </HELP>

              If all atoms have the same basis, e.g. ANO-S-VDZ, it is possible to use
              this name without element name. In this case there is no need to specify
              'End of basis'.
              </KEYWORD>

:kword:`ZMAT`
  Alternative format to give coordinates in terms of bond lengths,
  bond angles, and dihedral angles.
  Each line of a Z-matrix gives the
  internal coordinates for one of the atoms within the molecule with the following
  syntax:

  .. container:: list

    **Name  I bond-length  J bond-angle  K dihedral-angle**

    **Name** is the label (atomic symbol + string) for a symmetry distinct center L;

    **I bond-length** distance of L from atom I;

    **J bond-angle** planar angle between atoms L--I--J;

    **K dihedral-angle** dihedral angle between atoms L--I--J--K.

  Note that the first atom only requires the **Name** and defines the origin of
  Cartesian axis.
  The second atom requires **Name  I bond-length** and it will define the Z axis.
  The third atom requires **Name  I bond-length  J bond-angle** and defines the
  XZ plane (and implicitly, the Y axis).

  Only numerical values must be used (no variable names) and ångströms
  and degrees are assumed as units.

  Two types of special atoms are allowed: *dummy* **X** atoms and
  *ghost* **Z** atoms. The former will appear in the calculations,
  they have a nuclear charge of 0 and have not electrons and Basis Set.
  They will also appear in the definition of internal coordinates in :program:`SLAPAF`.
  The latter are used only within the Z-Matrix definition of the geometry but
  they will appear in the final Z-matrix section in :program:`SLAPAF`.
  Both special atoms can be used to define the Cartesian axis and the symmetry elements.

  **End of ZMAT** or a blank line mark the end of the section.

  Here is an example for (S)-1-chloroethanol (:math:`C_1` symmetry): ::

    XBAS
    H.ANO-L...2s1p.
    C.ANO-L...3s2p1d.
    O.ANO-L...3s2p1d.
    Cl.ECP.Huzinaga.7s7p1d.1s2p1d.7e-NR-AIMP.
    End of basis
    ZMAT
    C1
    O2      1   1.40000
    C3      1   1.45000   2   109.471
    H4      1   1.08900   2   109.471     3   120.000
    Cl5     1   1.75000   2   109.471     3  -120.000
    H6      2   0.94700   1   109.471     3   180.000
    H7      3   1.08900   1   109.471     2   180.000
    H8      3   1.08900   1   109.471     7   120.000
    H9      3   1.08900   1   109.471     7   240.000
    End of z-matrix

  In geometry optimizations, :program:`SLAPAF` will regenerate the coordinates as
  Z-matrix in the section with the summary concerning each iteration. This will
  be possible only if *ghost* atoms are used within the first three atoms or
  if they are not used at all.

  Both :kword:`BASIs` and :kword:`ZMAT` keywords can be used at the same time. Here is an example
  for a complex between methanol and water (:math:`C_s` symmetry): ::

    Symmetry
     Y
    XBAS
    H.ANO-L...1s.
    C.ANO-L...2s1p.
    O.ANO-L...2s1p.
    End of basis
    ZMAT
    C1
    O2  1 1.3350
    H3  1 1.0890  2 109.471
    H4  1 1.0890  2 109.471  3 -120.
    H6  2 1.0890  1 109.471  3  180.
    End of z-matrix
    Basis set
    O.ANO-L...2s1p.
     O    -2.828427     0.000000     2.335000  / Angstrom
    End of basis
    Basis set
    H.ANO-L...1s.
     H    -2.748759     0.819593     2.808729  / Angstrom
    End of basis

  In this case :program:`SLAPAF` will not regenerate the Z-matrix.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ZMAT" APPEAR="Z-matrix" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: ZMAT <basic>
              <HELP>
              Alternative format to give coordinates in the form of Z-matrix.
              Only numerical values must be used (no variable names) and angstroms
              and degrees are assumed as units. Special ghost Z and dummy X atoms
              are allowed. 'End of ZMAT' or a blank line marks the end of the section.
              </HELP>
              </KEYWORD>

:kword:`XYZ`
  The keyword is followed by XYZ formatted file (a reference to a file),
  or file, inlined into the input.

  .. compound::

    Example: ::

      XBAS=STO-3G
      XYZ=$CurrDir/Water.xyz

    or ::

      XBAS=STO-3G
      XYZ
      1
       note Angstrom units!
      C 0 0 0

  Currently, the :kword:`XYZ` keyword does not operate with symmetry, and
  the calculation is always performed without symmetry.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="XYZ" KIND="CUSTOM" LEVEL="ADVANCED" REQUIRE="XBAS">
              %%Keyword: XYZ <advanced>
              <HELP>
              Alternative format to set up geometry as XYZ formatted file.
              </HELP>
              </KEYWORD>

Advanced XYZ input
::::::::::::::::::

If the geometry is specified in XYZ format, all atoms should be specified.
The default units are ångströms. By default, maximum possible symmetry is used.

"Molcas XYZ" file format is an extension of plain XYZ format.

* First line of this file contains the number of atoms.

* Second line (a comment line) can contain "a.u." or "bohr" to
  use atomic units, instead of default ångströms.
  Also this line can contain keyword TRANS, followed by 3 numbers,
  and/or ROT, followed by 9 numbers (in this case coordinates
  will be Translated by specified vector, and/or Rotated), and SCALE (or
  SCALEX, SCALEY, SCALEZ) followed by a scale factor.

* Remaining lines are used to specify Element and cartesian
  coordinates.

  Element name might be optionally followed by a Number (e.g. ``H7``),
  a Label (separated by ``_`` sign: e.g. ``H_INNER``), or Basis Set (separated by ``.``,
  e.g. ``H.STO-3G``)

.. class:: keywordlist

:kword:`COORD`
  The keyword followed on the next line by the name of an HDF5 (created by any module), or the name of an XYZ file,
  or inline coordinates in XYZ format. If the file is located in the same directory, where
  |molcas| job was submitted there is no need to specify the PATH to this file.
  The keyword may appear several times. In this case all coordinate files
  will be concatenated, and considered as individual fragments.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="COORD" APPEAR="Coord" KIND="CUSTOM" INPUT="REQUIRED" LEVEL="BASIC" EXCLUSIVE="BASIS (NATIVE)">
              %%Keyword: COORD (XYZ format) <basic>
              <HELP>
              The keyword followed on the next line by the name of an HDF5 or XYZ file,
              or inline coordinates in XYZ format.
              The keyword may appear several times. In this case all coordinate files
              will be concatenated, and considered as individual fragments.
              </HELP>
              </KEYWORD>

:kword:`BASIS`
  The keyword can be used to specify global basis set for all atoms, or for a group of atoms.
  The keyword followed by a label of basis set, or by comma separated list of basis sets for
  individual atoms.

  Note! The basis set definition in XYZ mode does not allow to use
  inline basis set.

  Example: ::

    COORD
    4

    C           0.00000 0.00000 0.00000
    H           1.00000 0.00000 0.00000
    H           0.00000 1.00000 0.00000
    H           0.00000 0.00000 1.00000
    BASIS
    STO-3G, H.6-31G*

  In this example, the C atom (in the origin) will have the basis set STO-3G and
  the H atoms 6-31G*.

  If keyword BASIS never appears in the input, the default basis,
  ANO-S-MB, will be used.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BASIS (XYZ)" APPEAR="Basis set" KIND="STRING" LEVEL="BASIC">
              %%Keyword: BASIS (XYZ format) <basic>
              <HELP>
              The keyword followed on the next line by the name of global basis set for
              all atoms, or by comma separated list of basis sets for individual atoms.
              Note! The basis set definition in XYZ mode does not allow to use
              inline basis set.
              </HELP>
              </KEYWORD>

:kword:`GROUP`
  The keyword can be used to specify the symmetry of the molecule.

  The keyword must be followed by one of:

  * FULL (default) --- use maximum possible subgroup of :math:`D_{2h}`
  * NOSYM (same as E, or C1)
  * space separated list of generators: e.g. X XY (for more details see SYMMETRY keyword)

  .. Limitations: in the current implementation atom labels, and basis sets are ignored
     during symmetry recognition.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="GROUP" APPEAR="Group" KIND="STRING" LEVEL="BASIC">
              %%Keyword: GROUP (XYZ format) <basic>
              <HELP>
              The keyword followed on the next line by the list of group generators
              (with the same syntax as SYMMETRY keyword),
              or by FULL (highest possible group), or by NOSYM, if no symmetry operations
              should be used. The keyword can be used only with XYZ format of input,
              after COORD keyword.
              </HELP>
              </KEYWORD>

If XYZ input has been used in :program:`gateway`, a file with native |molcas| input will be
produced and stored in working directory under the name :file:`findsym.std`.

Note that choosing XYZ input you are expecting that the coordinates might be transformed.
It can be shown by the following example: ::

  &gateway
  coord
  3

  O 0 0 0
  H 1.0000001 0 0
  H 0 1 0.0000001
  *nomove
  *group=c1

The geometry of the molecule is slightly distorted, but within a threshold it is :math:`C_{2v}`.
Thus by default (keywords :kword:`nomove` and :kword:`group` are not active), the
coordinates will be transformed to maintain the highest possible symmetry.
If keyword :kword:`nomove` is active, the molecule is not allowed to rotate, and
a mirror plane :math:`xy` is the only symmetry element. Since the third hydrogen atom is
slightly out of this plane, it will be corrected. Only activation of the keyword :kword:`group=C1`
will ensure that the geometry is unchanged.

Native input
::::::::::::

If the geometry is specified in a native |molcas| format, only symmetry
inequivalent atoms should be specified. The default units are atomic units.
By default, symmetry is not used in the calculation.

.. class:: keywordlist

:kword:`SYMMetry`
  Symmetry specification follows on next line. There may be up to
  three different point group generators specified on that line. The
  generators of a point group is the minimal set of symmetry operators
  which is needed to generate all symmetry
  operators of a specific point group. A generator is in the input
  represented as a sequence of up to three of the characters x, y, and
  z. The order within a given sequence is arbitrary and the generators
  can be given in any sequence. Observe that the order of the irreps
  is defined by the order of the generators as
  (:math:`E`, :math:`g_1`, :math:`g_2`, :math:`g_1g_2`, :math:`g_3`, :math:`g_1g_3`, :math:`g_2g_3`,
  :math:`g_1g_2g_3`)! Note that :math:`E` is always assumed and should never
  be specified.

  Below is listed the possible generators.

  * **x** --- Reflection in the :math:`yz`-plane.
  * **y** --- Reflection in the :math:`xz`-plane.
  * **z** --- Reflection in the :math:`xy`-plane.
  * **xy** --- Twofold rotation around the :math:`z`-axis.
  * **xz** --- Twofold rotation around the :math:`y`-axis.
  * **yz** --- Twofold rotation around the :math:`x`-axis.
  * **xyz** --- Inversion through the origin.

  The default is no symmetry.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SYMMETRY" APPEAR="Symmetry" KIND="STRING" LEVEL="BASIC" EXCLUSIVE="COORD">
              %%Keyword: Symmetry (non-XYZ format) <basic>
              Symmetry point group is specified by up to three group generators.
              Possible generators are "x", "y", "z", "xy", "xz", "yz", and "xyz".
              The order of the irreps depends on the order of the generators.
              The keyword can be used only in 'native' input format.
              </KEYWORD>

:kword:`BASIs Set`
  This notes the start of a basis set definition.
  The next line always contains a basis set label.
  The basis set definition is alway terminated with the "End of Basis" keyword.
  For the definitions of basis set labels see the subsequent sections.
  Below follows a description of the options associated with the
  basis set definition.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BASIS (NATIVE)" APPEAR="Basis set" KIND="CUSTOM" LEVEL="ADVANCED" INPUT="REQUIRED" EXCLUSIVE="COORD">
              %%Keyword: BASIS (non-XYZ format) <basic>
              This notes the start of a basis set definition.
              The next line always contains a basis set label.
              The basis set definition is alway terminated with the "End of Basis" keyword.
              For details consult the manual.
              </KEYWORD>

  * **Label [/ option]** ---
    The label is a specification of a specific basis set, e.g.
    C.ANO...4s3p2d., which is an ANO basis set.
    If no option is specified
    :program:`GATEWAY` will look for the basis
    set in the default basis directory. If an option is specified it
    could either be the name of an alternative basis directory or
    the wording "Inline" which defines
    that the basis set will follow in the current input
    file. For the format of the
    **Inline** option see the section
    "Basis set format". Observe that the label is arbitrary for this
    option and will not be decoded.
    The **Label** card is mandatory.

  * **Name x, y, z (Angstrom or Bohr)** ---
    This card specifies an arbitrary (see next sentence!) name
    for a symmetry distinct center and its Cartesian coordinates.
    Observe, that the
    name "DBAS" is restricted to assign the center of the
    diffuse basis functions required to model the continuum
    orbitals in R-matrix calculations.
    The label is truncated to four characters. Observe that this
    label must be unique to each center. The coordinate unit can
    be specified as an option. The default unit is Bohr.
    There should at least be one card of this type in a basis set
    definition.

  * **Charge** ---
    The real entry on the subsequent line defines
    the charge associated with
    this basis set. This will override the default which is defined in
    the basis set library. The option can be used to put in ghost
    orbitals as well as to augment the basis sets of the library.
    The **Charge** card is optional.

    .. xmldoc:: %%Keyword: Charge (non-XYZ format) <advanced>
                The real entry on the subsequent line defines
                the charge associated with
                this basis set. This will override the default which is defined in
                the basis set library. The option can be used to put in ghost
                orbitals as well as to augment the basis sets of the library.
                The "Charger" card is optional.

  * **Spherical** [option] ---
    Specifying which shells will be in real spherical Gaussians. Valid options
    are "all" or a list of the shell characters separated by a blank. The
    shell characters are s, p, d, f, etc. All shells after p are by
    default in real spherical Gaussians, except for the d-functions in the
    6-31G family of basis sets which are in Cartesian.
    The **Spherical** card is optional. The s and p shells and the d-functions of
    the 6-31G family of basis sets are by default in Cartesian Gaussians.

    .. xmldoc:: %%Keyword: Spherical (non-XYZ format) <advanced>
                Specifying which shells will be in real spherical Gaussians. Valid options
                are "all" or a list of the shell characters separated by a blank. The
                shell characters are s, p, d, f, etc. All shells after p are by
                default in real spherical Gaussians, except for the d-functions in the
                6-31G family of basis sets which are in Cartesian.
                The "Spherical" card is optional. The s and p shells and the d-functions of
                the 6-31G family of basis sets are by default in Cartesian Gaussians.

  * **Cartesian** [option] ---
    Specifying which shells will be in a Cartesian Gaussian representation. For syntax
    consult the corresponding **Spherical** keyword.

    .. xmldoc:: %%Keyword: Cartesian (non-XYZ format) <advanced>
                Specifying which shells will be in a Cartesian Gaussian representation. For syntax
                consult the corresponding Spherical keyword.

  * **Contaminant** [option] ---
    Specifying for which shells the contaminant will be kept.
    The contaminants are functions of lower rank which are generated
    when a Cartesian shell is transformed to a spherical representation
    (e.g. :math:`r^2=x^2+y^2+z^2` for d-shells, p contaminants for f-shells,
    s and d contaminants for g-shells, etc.).
    Valid options are the same as for the **Spherical** keyword.
    The default is no contaminant in any shell. The **Contaminant** card is optional.

    .. xmldoc:: %%Keyword: Contaminant (non-XYZ format) <advanced>
                Specifying for which shells the contaminant will be kept.
                The contaminants are functions of lower rank which are generated
                when a Cartesian shell is transformed to a spherical representation
                (e.g. r^2=x^2+y^2+z^2 for d-shells, p contaminants for f-shells,
                s and d contaminants for g-shells, etc.).
                Valid options are the same as for the Spherical keyword.
                The default is no contaminant in any shell. The "Contaminant" card is optional.

  * **Muon** ---
    Specifying that the basis set is muonic.

    .. xmldoc:: %%Keyword: Muon (non-XYZ format) <advanced>
                Specifying that the basis set is muonic.

  * **End of Basis set** ---
    Marks the end of the basis set specification.
    This card is mandatory.

    .. xmldoc:: %%Keyword: End of Basis set (non-XYZ format) <advanced>
                Marks the end of the basis set specification.
                This card is mandatory.

Example of an input in native |molcas| format: ::

  &GATEWAY
  Title
  formaldehyde
  SYMMETRY
  X Y
  Basis set
  H.STO-3G....
  H1           0.000000    0.924258   -1.100293 /Angstrom
  End of basis

  Basis set
  C.STO-3G....
  C3           0.000000    0.000000   -0.519589 /Angstrom
  End of basis

  Basis set
  O.STO-3G....
  O            0.000000    0.000000    0.664765 /Angstrom
  End of basis

  End of input

Advanced keywords:

.. class:: keywordlist

:kword:`SYMThreshold`
  followed by a real number --- threshold for symmetry recognition (default is 0.01 Å)

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SYMT" APPEAR="Symmetry Thr" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.01" REALTIME_UPDATE="YES">
              %%Keyword: SYMThreshold (XYZ format) <advanced>
              <HELP>
              The keyword followed on the next line by the threshold for symmetry recognition code (default is 0.01)
              </HELP>
              </KEYWORD>

:kword:`CSPF`
  Turn on the use of Condon--Shortley phase factors.
  Note that this changes the sign of basis functions, and orbital files will not be compatible
  with runs without this keyword, and orbital visualizations may be wrong!

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="CSPF" APPEAR="Condon-Shortley phase factor" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: CSPF <advanced>
              <HELP>
              Turn on the use of Condon-Shortley phase factors.
              Warning: Causes incompatibilities.
              </HELP>
              </KEYWORD>

:kword:`MOVE`
  allow to translate and rotate molecule in order to find highest possible symmetry.
  (this is a default for all groups, except of :math:`C_1`)

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="MOVE" APPEAR="MOVE" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="NOMOVE">
              %%Keyword: MOVE (XYZ format) <advanced>
              <HELP>
              Allow to translate and rotate molecule in order to find highest possible symmetry.
              (this is a default for all groups, except of C1)
              </HELP>
              </KEYWORD>

:kword:`NOMOVE`
  do not allow to transform coordinates while searching for highest group (default for :math:`C_1` group)

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NOMOVE" APPEAR="NoMOVE" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="MOVE">
              %%Keyword: NOMOVE (XYZ format) <advanced>
              <HELP>
              Do not allow to transform coordinates while searching for highest group (default for C1 group)
              </HELP>
              </KEYWORD>

:kword:`BSSE`
  followed by an integer. Indicates which XYZ-file that should be
  treated like ghost atoms.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="BSSE" APPEAR="BSSE" KIND="INT" LEVEL="ADVANCED">
              %%Keyword: BSSE (XYZ format) <advanced>
              <HELP>
              Followed by an integer. Indicates which xyz-file that should be treated like ghost atoms.
              </HELP>
              </KEYWORD>

:kword:`VART`
  Specifies that the energy should not be considered invariant to translations.
  Translational variance is detected automatically, but sometimes it may be useful to enforce it.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="VART" APPEAR="Var Trans" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: VarT <advanced>
              <HELP>
              Specifies that the energy should not be considered invariant to translations.
              Translational variance is detected automatically, but sometimes it may be useful to enforce it.
              </HELP>
              </KEYWORD>

:kword:`VARR`
  Specifies that the energy should not be considered invariant to rotations.
  Rotational variance is detected automatically, but sometimes it may be useful to enforce it.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="VARR" APPEAR="Var Rot" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: VarR <advanced>
              <HELP>
              Specifies that the energy should not be considered invariant to rotations.
              Rotational variance is detected automatically, but sometimes it may be useful to enforce it.
              </HELP>
              </KEYWORD>

:kword:`NUMErical`
  Forces the calculation of numerical gradients even when analytic gradients are available.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NUMERICAL" APPEAR="Numerical gradients" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Numerical <advanced>
              <HELP>
              Forces the calculation of numerical gradients even when analytic gradients are available.
              </HELP>
              </KEYWORD>

:kword:`SHAKe`
  Randomly modifies the initial coordinates of the atoms, maintaining the input (or computed)
  symmetry. This can be useful to avoid a geometry optimization converging to a higher-symmetry
  saddle point. The maximum displacement per atom is read from the following
  real number. This number can be followed by :kword:`Bohr` or :kword:`Angstrom`, which indicates
  the unit in which the displacement is specified, the default is :kword:`Bohr`.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SHAKE" APPEAR="Shake" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: Shake <advanced>
              <HELP>
              Randomly modifies the initial coordinates of the atoms, maintaining the input (or computed)
              symmetry. This can be useful to avoid a geometry optimization converging to a higher-symmetry
              saddle point. The maximum displacement per atom is read from the following
              real number. This number can be followed by Bohr or Angstrom, which indicates
              the unit in which the displacement is specified, the default is Bohr.
              </HELP>
              </KEYWORD>

.. compound::

  Example: ::

    &GATEWAY
    COORD
    water.xyz
    BASIS
    STO-3G

  or, in short EMIL notation: ::

    &GATEWAY
    COORD=water.xyz; BASIS=STO-3G

Coordinate file may contain variables, as demonstrated in an example: ::

  >>FILE H2.input
  2
  scale $DD
  H 0.35 0 0
  H -0.35 0 0
  >>EOF

  >> FOREACH DD IN ( 0.9 1.0 1.1 )
  &GATEWAY
  COORD=$WorkDir/H2.input
  BASIS=STO-3G
  &SEWARD
  &SCF
  >>ENDDO

The atom name in XYZ file can contain an orbitrary label (to simplify assigning of different
basis sets). To indicate the label, use ``_``: e.g. ``C_SMALL``. The same label should be
defined in the basis section: ``BASIS=C_SMALL.ANO-S-MB``. The basis set label can be also
added into the name of an element: ::

  COORD
  1

  O.ANO-S-VDZP 0 0 0

XYZ file can also contain information about point charges. There are three possibilities to
setup atomic charges in XYZ file. The main option is to use ``Q`` as an element name, and in this
case the forth number, the charge, should be specified. Another possibility is to use element
names ended with minus sign. In this case, a formal charge for the element will be used.
E.g. ``H-``, ``Li-``, ``Na-``, ``K-`` defines :math:`+1` charge located in the corresponding location.
``Mg-``, ``Ca-`` --- defines charge :math:`+2`, ``Al-`` --- :math:`+3`, ``C-``, ``Si-`` :math:`+4`, for anions, ``F-``, ``Cl-``, ``Br-``, ``I-`` defines :math:`-1`,
``O-``, ``S-`` --- :math:`-2`. Finally, a label at the comment line of XYZ file --- CLUSTER followed by
an integer number can specify how many atoms are "real", so the rest will be treated as
charges with default values for this element.

Constraints
...........

In case of optimizations with constraints these are defined in the :program:`GATEWAY` input.
For a complete description of this keyword see :numref:`UG:sec:definition_of_internal_coordinates`.

.. class:: keywordlist

:kword:`CONStraints`
  This marks the start of the definition of the constraints
  which the optimization is subject to.
  This section is always ended by the keyword
  :kword:`End of Constraints`.
  This option can be used in conjunction with any definition of the
  internal coordinates.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="CONSTRAINTS" APPEAR="Constraints" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: Constraints <basic>
              <HELP>
              This marks the start of the definition of the constraints
              which the optimization is subject to.
              This section is always ended by the keyword "End of Constraints".
              Consult the manual for the details.
              </HELP>
              </KEYWORD>

:kword:`NGEXclude`
  This marks the start of the definition of additional restrictions for numerical differentiation.
  This section is always ended by the keyword :kword:`End of NGExclude`.
  The syntax of this section is like that of normal constraints, and the degrees of
  freedom specified here will be excluded from numerical differentiation (like phantom constraints).
  If a line containing only "Invert" is included inside the section,
  the definition is reversed and only these degrees of freedom are differentiated.
  :kword:`NGEXclude` is intended for use with the :kword:`KEEPOldGradient` keyword in :program:`ALASKA`,
  and can be combined with :kword:`CONStraints`, which will further reduce
  the numerical differentiation subspace :cite:`Stenrup2015`.
  Note that the value assigned to the constraints in this section is unused, but a ``Value`` block
  must still be included.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NGEXCLUDE" APPEAR="Exclude from numerical differentiation" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: NGExclude <basic>
              <HELP>
              This marks the start of the definition of additional restrictions for numerical differentiation.
              This section is always ended by the keyword "End of NGExclude".
              </HELP>
              </KEYWORD>

Explicit auxiliary basis sets
.............................

The so-called Resolution of Identity (RI) technique (also called Density
Fitting, DF) is implemented in the |molcas| package. This option involves the use
of an auxiliary basis set in the effective computation of the 2-electron
integrals. |molcas| incorporates both the use of conventionally computed,
externally provided, auxiliary basis sets (RIJ, RIJK, and RIC types), and
on-the-fly generated auxiliary basis sets. The latter are atomic CD (aCD) or the
atomic compact CD (acCD) basis
sets, based on the Cholesky decomposition method. The externally provided
auxiliary basis sets are very compact, since they are tailored for special
wave function methods. However, they are not provided for all available valence
basis sets. The aCD or acCD RI auxiliary basis sets are a more general option and
provides auxiliary basis sets for any wave function model and valence basis set.
If :variable:`MOLCAS_NEW_DEFAULTS` is set to ``YES``, acCD RI (:kword:`RICD`)
will be enabled by default, it can be disabled with :kword:`NOCD`.

.. xmldoc:: <GROUP MODULE="GATEWAY" KIND="BOX" NAME="RIDFOPTIONS" APPEAR="RI/DF options (optional)" LEVEL="BASIC">
            <HELP>
            Options of RI/DF definition of auxiliary basis sets.
            Set various thresholds and parameters for atomic CD auxiliary basis sets.
            </HELP>

.. class:: keywordlist

:kword:`RIJ`
  Use the RI-J basis in the density fitting (DF) approach to treat the two-electron integrals. Note that the valence
  basis set must have a supporting auxiliary basis set for this to work.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RIJ" APPEAR="RI-J option" KIND="SINGLE" EXCLUSIVE="RIJK,RIC,RICD,LOW,MEDI,HIGH,NOCD,XRIC" LEVEL="BASIC">
              %%Keyword: RIJ <basic>
              <HELP>
              Use the RI-J auxiliary basis in the density fitting (DF) approach to treat the two-electron integrals.
              Note that the valence basis set must have a supporting auxiliary basis set for this to work.
              </HELP>
              </KEYWORD>

:kword:`RIJK`
  Use the RI-JK auxiliary basis in the density fitting (DF) approach to treat the two-electron integrals. Note that the valence
  basis set must have a supporting auxiliary basis set for this to work.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RIJK" APPEAR="RI-JK option" KIND="SINGLE" EXCLUSIVE="RIJ,RIC,RICD,LOW,MEDI,HIGH,NOCD,XRIC" LEVEL="BASIC">
              %%Keyword: RIJK <basic>
              <HELP>
              Use the RI-JK auxiliary basis in the density fitting (DF) approach to treat the two-electron integrals.
              Note that the valence basis set must have a supporting auxiliary basis set for this to work.
              </HELP>
              </KEYWORD>

:kword:`RIC`
  Use the RI-C auxiliary basis in the density fitting (DF) approach to treat the two-electron integrals. Note that the valence
  basis set must have a supporting auxiliary basis set for this to work.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RIC" APPEAR="RI-C option" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RICD,LOW,MEDI,HIGH,NOCD,XRIC" LEVEL="BASIC">
              %%Keyword: RIC <basic>
              <HELP>
              Use the RI-C auxiliary basis in the density fitting (DF) approach to treat the two-electron integrals.
              Note that the valence basis set must have a supporting auxiliary basis set for this to work.
              </HELP>
              </KEYWORD>

:kword:`RICD`
  Use the aCD or acCD approach :cite:`Aquilante:07b` to treat the two-electron integrals.
  This procedure will use an on-the-fly generated auxiliary basis set.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RICD" APPEAR="RI-aCD option" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,LOW,MEDI,HIGH,NOCD,XRIC" LEVEL="BASIC">
              %%Keyword: RICD <basic>
              <HELP>
              Use the aCD or acCD approach to treat the two-electron integrals.
              This procedure will use an on-the-fly generated auxiliary basis set.
              </HELP>
              </KEYWORD>
:kword:`XRICd`
  Use an externally generated RICD basis set available in the file $Project.RICDLib.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="XRIC" APPEAR="x-RICD option" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,LOW,MEDI,HIGH,NOCD" LEVEL="BASIC">
              %%Keyword: xRICD <basic>
              <HELP>
              Use an externally generated RICD basis set available in the file $Project.RICDLib.
              </HELP>
              </KEYWORD>

:kword:`NOCD`
  Disable Cholesky decomposition.
  Useful in the case :kword:`RICD` has been made the default with :variable:`MOLCAS_NEW_DEFAULTS`.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NOCD" APPEAR="No CD" KIND="SINGLE" EXCLUSIVE="RIJ,RIJK,RIC,RICD,LOW,MEDI,HIGH,XRIC" LEVEL="BASIC">
              %%Keyword: NOCD <basic>
              <HELP>
              Disable Cholesky decomposition.
              Useful in the case RICD has been made the default with MOLCAS_NEW_DEFAULTS.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="XRICD" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

:kword:`CDTHreshold`
  Threshold for on-the-fly generation of aCD or acCD auxiliary basis sets for RI calculations
  (default value 1.0d-4).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="CDTH" APPEAR="aCD threshold" KIND="REAL" DEFAULT_VALUE="1.0D-4" REQUIRE="RICD" LEVEL="ADVANCED">
              %%Keyword: CDThreshold <advanced>
              <HELP>
              Threshold for on-the-fly generation of aCD or acCD auxiliary basis sets for RI calculations
              (default value 1.0d-4).
              </HELP>
              </KEYWORD>

:kword:`SHAC`
  Skip high angular combinations when creating on-the-fly basis sets, following the angular structure of the universal JK fitting sets of Weigend :cite:`Weigend:08`.
  (default off).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SHAC" APPEAR="Skip high angular combinations" KIND="SINGLE" REQUIRE="RICD" EXCLUSIVE="KHAC" LEVEL="ADVANCED">
              %%Keyword: SHAC <advanced>
              <HELP>
              Skip high angular combinations when creating on-the-fly basis sets, following the angular structure of the universal JK fitting sets of Weigend
              (default off).
              </HELP>
              </KEYWORD>

:kword:`KHAC`
  Keep high angular combinations when creating on-the-fly basis sets
  (default on).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="KHAC" APPEAR="Keep high angular combinations" KIND="SINGLE" REQUIRE="RICD" EXCLUSIVE="SHAC" LEVEL="ADVANCED">
              %%Keyword: KHAC <basic>
              <HELP>
              Keep high angular combinations when creating on-the-fly basis sets
              (default on).
              </HELP>
              </KEYWORD>

:kword:`aCD basis`
  Generate an atomic CD (aCD) auxiliary basis sets (default off).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ACD" APPEAR="aCD auxiliary basis" KIND="SINGLE" REQUIRE="RICD" EXCLUSIVE="ACCD" LEVEL="ADVANCED">
              %%Keyword: aCD basis <basic>
              <HELP>
              Generate an atomic CD (aCD) auxiliary basis sets (default off).
              </HELP>
              </KEYWORD>

:kword:`acCD basis`
  Generate an atomic compact CD (acCD) auxiliary basis sets (default on).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ACCD" APPEAR="acCD auxiliary basis" KIND="SINGLE" REQUIRE="RICD" EXCLUSIVE="ACD" LEVEL="ADVANCED">
              %%Keyword: acCD basis <basic>
              <HELP>
              Generate an atomic compact CD (acCD) auxiliary basis sets (default on).
              </HELP>
              </KEYWORD>

.. xmldoc:: </GROUP>

.. index::
   single: Reaction field
   single: Cavity
   single: Solvent

.. _UG\:sec\:rfield:

Reaction field calculations
...........................

The effect of the solvent on the quantum chemical calculations has been
introduced in |molcas| through the reaction field created
by the surrounding environment, represented by a polarizable dielectric
continuum outside the boundaries of a cavity containing the solute molecule.
|molcas| supports Self Consistent Reaction Field (SCRF) and Multi
Configurational Self Consistent Reaction Field (MCSCRF) calculations within
the framework of the :program:`SCF` and the :program:`RASSCF` programs.
The reaction field, computed in a self-consistent fashion, can be
later added as a constant perturbation for the remaining programs, as
for example :program:`CASPT2`.

The purpose of this facility is to incorporate
the effect of the environment (a solvent or a solid matrix) on the studied molecule.
The utility itself it is not a program, but requires
an additional input which has to be provided to the
:program:`GATEWAY` program.
Two methods are available for SCRF calculations: one is based on the Kirkwood
model, the other is the so called Polarizable Continuum Model (PCM).
The reaction field is computed as the response of a dielectric medium polarized
by the solute molecule: the solute is placed in a "cavity" surrounded by the
dielectric. In Kirkwood model the cavity is always spherical, whereas in PCM the
cavity is modeled on the actual solute shape.

The possible set of parameters controlled by input are:

* the Kirkwood model,
* the PCM model, and
* one-electron integrals representing
  Pauli repulsion and external fields.

First a brief presentation of the Kirkwood and the PCM models.

.. index::
   single: Kirkwood model

The Kirkwood Model
::::::::::::::::::

The Kirkwood model is an expansion of the so-called Onsager model where
the surrounding will be characterized by its dielectric
permitivity and a radius describing a spherical cavity,
indicating where the dielectric medium starts.
(Note that all atoms in the studied molecule must be inside the spherical cavity.) The Pauli repulsion
due to the medium can be introduced by use of the spherical well
integrals which are generated by :program:`SEWARD`.
The charge distribution of the molecule will introduce
an electric field acting on the dielectric medium. This reaction field will interact with the
charge distribution of the molecule. This interaction will manifest itself as
a perturbation to the one-electron Hamiltonian. The perturbation will be
automatically computed in a direct fashion (no multipole integrals are stored on
disk) and added to the one-electron Hamiltonian. Due to the direct way in which
this contribution is computed rather high terms in the multipole expansion of the
charge can be afforded.

.. index::
   single: PCM

The Polarizable Continuum Model, PCM
::::::::::::::::::::::::::::::::::::

The PCM has been developed in order to describe the solvent reaction field in a
more realistic way, basically through the use of cavities of general shape, modeled on the
solute. The cavity is built as the envelope of spheres centered on solute atoms or atomic
groups (usually, hydrogen atoms are included in the same sphere as the heavy atoms they are
bonded to). The reaction field is described by means of apparent charges (solvation
charges) spread on the cavity surface, designed to reproduced the electrostatic potential
due to the polarized dielectric inside the cavity.
Such charges are used both to compute solute-solvent interactions (modifying the total energy
of the solute), and to perturb the molecular Hamiltonian through a suitable operator
(thus distorcing the solute wave-function, and affecting all the electronic properties).
The PCM operator contains both one- and two-electron terms: it is computed using
atomic integrals already present in the program, through a "geometry matrix"
connecting different points lying on the cavity surface. It can be shown that
with this approach the SCF and RASSCF variational procedures lead to the
free energy of the given molecule in solution: this is the thermodynamic meaning
of the SCF or CI energy provided by the program. More precisely, this is the
solute-solvent electrostatic contribution to the free energy
(of course, other terms depending on solute atomic motions, like vibrational and
rotational free energies, should be included separately);
it can be used to get a good
approximation of the solvation free energy, by subtracting the SCF or CI energy
computed in vacuo, and also to compute directly energy surfaces and reaction paths
in solution. On the other hand, the solute wave-function perturbed by the
reaction field can be used to compute any electronic property in solution.

Also other quantities can be computed, namely the cavitation free energy (due
the the work spent to create the cavity in the dielectric) and the
dispersion-repulsion free energy: these terms affect only the total free energy of the molecule,
and not its electronic distribution. They are collectively referred to as
non-electrostatic contributions.

Note that two other keywords are defined for the :program:`RASSCF`
program:
they refer to the CI root selected for the calculation of the reaction field (RFROOT), and
to the possibility to perform a non-equilibrium calculation (NONEQ) when vertical electronic
transitions are studied in solution. These keywords are referenced in the
:program:`RASSCF` section. To include the reaction field perturbation in a :program:`SCF`, :program:`RASSCF`, :program:`CASPT2` or :program:`RASSI`
calculation, another keyword must be specified (RFPERT), as explained in the
respective program sections.

Complete and detailed examples of how to add a reaction field,
through the Kirkwood or the PCM model, into quantum chemical
calculations in |molcas| is presented in :numref:`TUT:sec:cavity` of the
examples manual. The user is encouraged to read that section for further details.

Input for the Kirkwood and PCM models
:::::::::::::::::::::::::::::::::::::

.. _UG\:sec\:rfield_files:

Files
"""""

.. *********************************** this part should be revised

The reaction field calculations will store the information in the following files, which
will be used by the following programs

.. class:: filelist

:file:`ONEINT`
  One-electron integral file used to store the Pauli repulsion integrals

:file:`RUNFILE`
  Communications file. The last computed self-consistent reaction field (SCF or RASSCF)
  will be stored here to be used by following programs

:file:`GV.off`
  Input file for the external program "geomview" (see Tutorial section
  "Solvent models"), for the visualization of PCM cavities

Input
"""""
Below follows a description of the input to the reaction field utility in the
:program:`GATEWAY` program. The :program:`RASSCF` program has
its own keywords to compute reaction fields for excited states.

Compulsory keywords

:kword:`RF-Input`
  Activate reaction field options.

.. xmldoc:: <GROUP MODULE="GATEWAY" NAME="RF-INPUT" APPEAR="Reaction Field Options" KIND="BLOCK" LEVEL="ADVANCED">
            <HELP>
            Reaction field options.
            </HELP>

.. class:: keywordlist

:kword:`END Of RF-Input`
  This marks the end of the input to the reaction field utility.

  .. xmldoc:: %%Keyword: End of RF-input <compulsory>
              This marks the end of the input to the reaction field utility.

Optional keywords for the Kirkwood Model

.. class:: keywordlist

:kword:`REACtion Field`
  This command is exclusive to the Kirkwood model.
  It indicates the beginning of the specification of the
  reaction field parameters. The subsequent line will contain
  the dielectric constant of the medium, the radius of the
  cavity in Bohrs (the cavity is always centered around the
  origin), and the angular quantum number of the highest multipole
  moment used in the expansion of the change distribution of
  the molecule (only charge is specified as 0, charge and dipole
  moments as 1, etc.).
  The input specified below specifies that
  a dielectric permitivity of 80.0 is used, that the cavity radius is 14.00 a.u.,
  and that the expansion of the charge distribution is truncated after :math:`l=4`, i.e. hexadecapole
  moments are the last moments included in the expansion.
  Optionally a fourth argument can be added giving the value of the dielectric constant of the
  fast component of the solvent (default value 1.0).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="REACTION" APPEAR="Onsager-Kirkwoord Model" KIND="CUSTOM" LEVEL="ADVANCED" EXCLUSIVE="PCM-MODEL">
              %%Keyword: Reaction field (RF) <basic>
              <HELP>
              This command is exclusive to the Kirkwood model.
              This indicated the beginning of the specification of the
              reaction field parameters. The subsequent line will contain
              the dielectric constant of the medium, the radius of the
              cavity in Bohrs (the cavity is always centered around the
              origin), and the angular quantum number of the highest multipole
              moment used in the expansion of the change distribution of
              the molecule (only charge is specified as 0, charge and dipole
              moments as 1, etc.).
              The input specified below specifies that
              a dielectric permitivity of 80.0 is used, that the cavity radius is 14.00 a.u.,
              and that the expansion of the charge distribution is truncated after l=4, i.e. hexadecapole
              moments are the last moments included in the expansion.
              Optionally a fourth argument can be added giving the value of the dielectric constant of the
              fast component of the solvent (default value 1.0).
              </HELP>
              </KEYWORD>

Sample input for the reaction field part (Kirkwood model) ::

  RF-Input
  Reaction field
  80.0 14.00 4
  End Of RF-Input

Sample input for a complete reaction field calculation using the Kirkwood model.
The :program:`SCF` computes the reaction field in a
self consistent manner while the :program:`MRCI`
program adds the effect as a constant perturbation.

.. extractfile:: ug/RF.input

  &GATEWAY
  Title = HF molecule
  Symmetry
  X Y
  Basis set
  F.ANO-S...3S2P.
  F      0.00000   0.00000   1.73300
  End of basis
  Basis set
  H.ANO-S...2S.
  H      0.00000   0.00000   0.00000
  End of basis
  Well integrals
   4
   1.0 5.0  6.75
   1.0 3.5  7.75
   1.0 2.0  9.75
   1.0 1.4 11.75

  RF-Input
  Reaction field
   80.0 4.75 4
  End of RF-Input

  &SEWARD

  &SCF
  Occupied =  3 1 1 0

  &MOTRA
  LumOrb
  Frozen   =  1 0 0 0
  RFPert

  &GUGA
  Electrons =     8
  Spin      =     1
  Inactive  =     2    1    1    0
  Active    =     0    0    0    0
  CiAll     =     1

  &MRCI
  SDCI

Optional keywords for the PCM Model

.. xmldoc:: <GROUP MODULE="GATEWAY" NAME="PCM" APPEAR="PCM Options" KIND="BOX" LEVEL="ADVANCED">

.. class:: keywordlist

:kword:`PCM-model`
  If no other keywords are specified, the program will execute a standard PCM calculation
  with water as solvent. The solvent reaction field will be included in all the
  programs (:program:`SCF`, :program:`RASSCF`, :program:`CASPT2`, etc.)
  invoked after :program:`SEWARD`: note that in some cases additional keywords are required
  in the corresponding program sections. Some PCM parameters can be changed through the following
  keywords.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="PCM-MODEL" APPEAR="PCM Model" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="REACTION">
              %%Keyword: PCM-model (RF) <basic>
              <HELP>
              If no other keywords are specified, the program will execute a standard PCM calculation
              with water as solvent. The solvent reaction field will be included in all the
              programs (SCF, RASSCF, CASPT2, etc.)
              invoked after SEWARD: note that in some cases additional keywords are required
              in the corresponding program sections. Many PCM parameters can be changed through the following
              keywords.
              </HELP>
              </KEYWORD>

:kword:`SOLVent`
  Used to indicate which solvent is to be simulated. The name of the requested solvent
  must be written in the line below this keyword. Find implemented solvents in the PCM model below this section.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SOLVENT" APPEAR="Solvent" KIND="CHOICE" LEVEL="ADVANCED" REQUIRE="PCM-MODEL" LIST="WATER,ACETONITRILE,METHANOL,ETHANOL,ISOQUINOLINE,QUINOLINE,CHLOROFORM,ETHYLETHER,METHYLENECHLORIDE,DICHLOROETHANE,CARBONTETRACHLORIDE,BENZENE,TOLUENE,CHLOROBENZENE,NITROMETHANE,HEPTANE,CYCLOHEXANE,ANILINE,ACETONE,TETRAHYDROFURAN,DIMETHYLSULFOXIDE,ARGON,KRYPTON,XENON">
              %%Keyword: Solvent (RF) <basic>
              <HELP>
              Used to indicate which solvent is to be simulated.
              </HELP>
              The name of the requested solvent
              must be written in the line below this keyword. Allowed solvents are:
              WATER, ACETONITRILE, METHANOL, ETHANOL, ISOQUINOLINE,
              QUINOLINE, CHLOROFORM, ETHYLETHER, METHYLENECHLORIDE,
              DICHLOROETHANE, CARBONTETRACHLORIDE, BENZENE, TOLUENE,
              CHLOROBENZENE, NITROMETHANE, HEPTANE, CYCLOHEXANE, ANILINE,
              ACETONE, TETRAHYDROFURAN, DIMETHYLSULFOXIDE, ARGON, KRYPTON,
              XENON
              </KEYWORD>

:kword:`DIELectric constant`
  Defines a different dielectric constant for the selected solvent; useful to describe
  the system at temperatures other that 298 K, or to mimic solvent mixtures.
  The value is read in the line below the keyword.
  An optional second value might be added on the same line which
  defines a different value for the infinite frequency dielectric constant for
  the selected solvent (this is used in non-equilibrium calculations; by
  default it is defined for each solvent at 298 K).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="DIELECTRIC" APPEAR="Dielectric constant" KIND="REALS" SIZE="2" LEVEL="ADVANCED" REQUIRE="PCM-MODEL">
              %%Keyword: Dielectric constant (RF) <basic>
              <HELP>
              Defines a different dielectric constant for the selected solvent; useful to describe
              the system at temperatures other that 298 K, or to mimic solvent mixtures.
              The value is read in the line below the keyword.
              An optional second value might be added on the same line which
              defines a different value for the infinite frequency dielectric constant for
              the selected solvent (this is used in non-equilibrium calculations; by
              default it is defined for each solvent at 298 K).
              </HELP>
              </KEYWORD>

  .. :kword:`INFInite frequency dielectric constant`
       Defines a different value for the infinite frequency dielectric constant for
       the selected solvent (this is used in non-equilibrium calculations; by
       default it is defined for each solvent at 298 K).
       The value is read in the line below the keyword.

       .. .. xmldoc:: %%Keyword: Infinite frequency dielectric constant (RF) <advanced>
                      Defines a different value for the infinite frequency dielectric constant for
                      the selected solvent (this is used in non-equilibrium calculations; by
                      default it is defined for each solvent at 298 K).
                      The value is read in the line below the keyword.

:kword:`CONDuctor version`
  It requires a PCM calculation where the solvent is represented as a polarized conductor:
  this is an approximation to the dielectric model which works very well for
  polar solvents (i.e. dielectric constant greater than about 5), and it has some
  computational advantages being based on simpler equations. It can be useful in cases
  when the dielectric model shows some convergence problems.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="CONDUCTOR" APPEAR="Conductor Model" KIND="SINGLE" LEVEL="ADVANCED" REQUIRE="PCM-MODEL">
              %%Keyword: Conductor version (RF) <advanced>
              <HELP>
              It requires a PCM calculation where the solvent is represented as a polarized conductor:
              this is an approximation to the dielectric model which works very well for
              polar solvents (i.e. dielectric constant greater than about 5), and it has some
              computational advantages being based on simpler equations. It can be useful in cases
              when the dielectric model shows some convergence problems.
              </HELP>
              </KEYWORD>

:kword:`AAREa`
  It is used to define the average area (in Å\ |2|)
  of the small elements on the cavity surface
  where solvation charges are placed; when larger elements are chosen, less charges
  are defined, what speeds up the calculation but risks to worsen the results. The
  default value is 0.4 Å\ |2| (i. e. 60 charges on a sphere of radius 2 Å).
  The value is read in the line below the keyword.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="AARE" APPEAR="Tessera Average Area" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="0.4" REQUIRE="PCM-MODEL">
              %%Keyword: AAREa (RF) <advanced>
              <HELP>
              It is used to define the average area (in A^2) of the small elements on the cavity surface
              where solvation charges are placed; when larger elements are chosen, less charges
              are defined, what speeds up the calculation but risks to worsen the results. The
              default value is 0.4 A^2 (i.e. 60 charges on a sphere of radius 2 A).
              The value is read in the line below the keyword.
              </HELP>
              </KEYWORD>

:kword:`R-MIn`
  It sets the minimum radius (in Å) of the spheres that the program adds to the atomic
  spheres in order to smooth the cavity surface (default 0.2 Å).
  For large solute, if the programs
  complains that too many sphere are being created, or if computational times
  become too high, it can be useful to enlarge this value (for example to 1 or 1.5
  Å), thus reducing the number of added spheres.
  The value is read in the line below the keyword.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="R-MIN" APPEAR="Minimum sphere radius" KIND="REAL" LEVEL="ADVANCED" DEFAULT_VALUE="2.0" REQUIRE="PCM-MODEL">
              %%Keyword: R-min (RF) <advanced>
              <HELP>
              It sets the minimum radius (in A) of the spheres that the program adds to the atomic
              spheres in order to smooth the cavity surface (default 0.2 A).
              For large solute, if the programs
              complains that too many sphere are being created, or if computational times
              become too high, it can be useful to enlarge this value (for example to 1 or 1.5
              A), thus reducing the number of added spheres.
              The value is read in the line below the keyword.
              </HELP>
              </KEYWORD>

:kword:`PAULing`
  It invokes the use of Pauling's radii to build the solute cavity: in
  this case, hydrogens get their own sphere (radius 1.2 Å).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="PAULING" APPEAR="Pauling radii" KIND="SINGLE" LEVEL="ADVANCED" DEFAULT_VALUE="2.0" REQUIRE="PCM-MODEL">
              %%Keyword: Pauling (RF) <advanced>
              <HELP>
              It invokes the use of Pauling's radii to build the solute cavity: in
              this case, hydrogens get their own sphere (radius 1.2 A).
              </HELP>
              </KEYWORD>

:kword:`SPHEre radius`
  It is used to provide sphere radii from input: for each sphere given
  explicitly by the user, the keyword "Sphere radius" is required,
  followed by a line containing two numbers: an integer indicating the
  atom where the sphere has to be centered, and a real indicating its
  radius (in Å). For example, "Sphere radius" followed by "3 1.5"
  indicates that a sphere of radius 1.5 Å is placed around atom #3;
  "Sphere radius" followed by "4 2.0" indicates that another sphere of
  radius 2 Å is placed around atom #4 and so on.

  .. xmldoc:: %%Keyword: Sphere radius (RF) <advanced>
              It is used to provide sphere radii from input: for each sphere given
              explicitly by the user, the keyword 'Sphere radius' is required,
              followed by a line containing two numbers: an integer indicating the
              atom where the sphere has to be centered, and a real indicating its
              radius (in A). For example, 'Sphere radius' followed by '3 1.5'
              indicates that a sphere of radius 1.5 A is placed around atom 3;
              'Sphere radius' followed by '4 2.0' indicates that another sphere of
              radius 2 A is placed around atom 4 and so on.

.. xmldoc:: </GROUP>

.. xmldoc:: </GROUP>

Solvents implemented in the PCM model are

.. %---- Table of allowed solvents ------

.. _tab\:pcm_solvents:

=================== ==========
Name                Dielectric
                    constant
=================== ==========
water                    78.39
dimethylsulfoxide        46.70
nitromethane             38.20
acetonitrile             36.64
methanol                 32.63
ethanol                  24.55
acetone                  20.70
isoquinoline             10.43
dichloroethane           10.36
quinoline                 9.03
methylenchloride          8.93
tetrahydrofuran           7.58
aniline                   6.89
chlorobenzene             5.62
chloroform                4.90
ethylether                4.34
toluene                   2.38
benzene                   2.25
carbontetrachloride       2.23
cyclohexane               2.02
heptane                   1.92
xenon                     1.71
krypton                   1.52
argon                     1.43
=================== ==========

Sample input for the reaction field part (PCM model): the solvent is
water, a surface element average area of 0.2 Å\ |2| is requested. ::

  RF-input
  PCM-model
  Solvent
  water
  AAre
  0.2
  End of RF-input

Sample input for a standard PCM calculation in water.
The :program:`SCF` and :program:`RASSCF` programs compute the reaction field
self consistently and add its contribution to the Hamiltonian. The :program:`RASSCF` is
repeated twice: first the ground state is determined, then a non-equilibrium
calculation on the first excited state is performed.

.. extractfile:: ug/RF.formaldehyde.input

  &GATEWAY
  Coord
  4
  formaldehyde
  O 0.000000 0.000000 -1.241209
  C 0.000000 0.000000 0.000000
  H 0.000000 0.949585 0.584974
  H 0.000000 -0.949585 0.584974

  Basis = STO-3G
  Group = C1
  RF-input
  PCM-model
  solvent = water
  End of RF-input

  &SEWARD ; &SCF

  &RASSCF
  nActEl   = 4 0 0
  Symmetry = 1
  Inactive = 6
  Ras2     = 3
  CiRoot
  1 1
  1
  LumOrb

  &RASSCF
  nActEl   = 4 0 0
  Symmetry = 1
  Inactive = 6
  Ras2     = 3
  CiRoot
  2 2
  1 2
  0 1
  JOBIPH
  NonEq
  RFRoot  = 2

Again the user is recommended to read :numref:`TUT:sec:cavity` of the
examples manual for further details.

Keywords associated to one-electron integrals
.............................................

.. xmldoc:: <GROUP MODULE="GATEWAY" NAME="ONE-ELECTRON" APPEAR="1-electron integral options" KIND="BOX" LEVEL="ADVANCED">

.. class:: keywordlist

:kword:`FNMC`
  Request that the so-called Finite Nuclear Mass Correction, excluded by the Born--Oppenheimer approximation,
  be added to the one-electron Hamiltonian.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FNMC" APPEAR="Finite nuclear mass correction" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: FNMC <advanced>
              <HELP>
              Request that the so-called Finite Nuclear Mass Correction, excluded by the Born-Oppenheimer approximation,
              be added to the one-electron Hamiltonian.
              </HELP>
              </KEYWORD>

:kword:`WELL integrals`
  Request computation of Pauli repulsion integrals for dielectric
  cavity reaction field calculations.
  The first line specifies the total number of primitive well integrals in the
  repulsion integral. Then follows a number of lines, one for each
  well integral, specifying the coefficient of the well integral in the
  linear combination of the well integrals which defines the repulsion integral,
  the exponent of the well integral, and the distance of the center of the
  Gaussian from the origin. In total three entries on each line.
  All entries in atomic units.
  If zero or a negative number is specified for the number of well integrals
  a standard set of 3 integrals with their position adjusted for the radius of
  the cavity will be used.
  If the distance of the center of the Gaussian from the origin is
  negative displacements relative to the cavity radius is assumed.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="WELL" APPEAR="Well integrals" KIND="REALS_COMPUTED" SIZE="3" LEVEL="BASIC">
              <ALTERNATE KIND="INT" />
              %%Keyword: Well integrals <basic>
              <HELP>
              Request computation of Pauli repulsion integrals for dielectric
              cavity reaction field calculations.
              </HELP>
              The first line specifies the total number of primitive well integrals in the
              repulsion integral. Then follows a number of lines, one for each
              well integral, specifying the coefficient of the well integral in the
              linear combination of the well integrals which defines the repulsion integral,
              the exponent of the well integral, and the distance of the center of the
              Gaussian from the origin. In total three entries on each line.
              All entries in atomic units.
              If zero or a negative number is specified for the number of well integrals
              a standard set of 3 integrals with their position adjusted for the radius of
              the cavity will be used.
              If the distance of the center of the Gaussian from the origin is
              negative displacements relative to the cavity radius is assumed.
              </KEYWORD>

:kword:`XFIEld integrals`
  Request the presence of an external electric field represented by a
  number of partial charges and dipoles. Optionally, polarisabilities may be specified whose
  induced dipoles are determined self-consistently during the SCF iteration.
  The first line may contain, apart from the first integer [nXF] (number of centers), up to
  four additional integers. The second integer [nOrd] specifies the maximum multipole order,
  or -1 signifying no permanent multipoles. Default is 1 (charges and dipoles). The third
  integer [p] specifies the type of external polarisabilities: 0 (default) no polarisabilities,
  1 (isotropic), or 2 (anisotropic). The fourth integer [nFrag] specifies the number of fragments one
  multipole may contribute to (relevant only if polarisabilities are present). The default is 0,
  meaning that each permanent multipole is only excluded in the calculation of the field at its own
  polarisability, 1 means that one gives a fragment number to each multipole and that the static
  multipoles do not contribute to the polarising field within the same fragment, whereas 2 can be
  used in more complex situations, e.g. polymers, allowing you to specify a second fragment number
  so that junction atoms does not contribute to either of the neighbouring fragments.
  Finally, the fifth and last integer [nRead] (relevant only if Langevin dipoles are used) may
  be 0 or 1 (where 0 is default), specifying whether an element number (e.g. 8 for oxygen) should be
  read for each multipole. In that case the default radius for that element is used to determine which
  Langevin grid points should be annihilated. A negative element number signifies that a particular
  radius should be used for that multipole, in thousands of a Bohr (-1400 meaning 1.4 Bohr).
  Then follows nXF lines, one for each center. On each line is first nFrag+nRead (which may equal 0)
  integers, specifying the fragments that the multipole should not contribute to (the first fragment is
  taken as the fragment that the polarisability belongs to) and the element number. Then follows
  the three coordinates of the center, followed by the multipoles and polarisabilities. The number of
  multipole entries is 0 for nOrd=-1, 1 for nOrd=0, 4 for nOrd=1, and 10 for nOrd=2. The number of
  polarisability entries are 0 for p=0, 1 for p=1, and 6 for p=2. The order of quadrupole moment and
  anisotropic polarisability entries is xx, xy, xz, yy, yz, zz. If default is used, i.e. only specifying
  the number of centers on the first line, each of these lines will contain 7 entries (coordinates,
  charge, and dipole vector). All entries are in atomic units, if not otherwise requested by the :kword:`Angstrom`
  keyword that must be placed between nXF and nOrd. All these data can be stored in a separate file whose
  name must be passed as an argument of the :kword:`XField` keyword.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="XFIELD" APPEAR="External field" KIND="CUSTOM" LEVEL="BASIC">
              <ALTERNATE KIND="STRING" />
              %%Keyword: Xfield integrals <basic>
              <HELP>
              Request the presence of an external electric field represented by a
              number of partial charges and dipoles. Optionally, polarisabilities may be specified whose
              induced dipoles are determined self-consistently during the SCF iteration.
              </HELP>
              The first line may contain, apart from the first integer (nXF) (number of centers), up to
              four additional integers. The second integer (nOrd) specifies the maximum multipole order,
              or -1 signifying no permanent multipoles. Default is 1 (charges and dipoles). The third
              integer (p) specifies the type of external polarisabilities: 0 (default) no polarisabilities,
              1 (isotropic), or 2 (anisotropic). The fourth integer (nFrag) specifies the number of fragments one
              multipole may contribute to (relevant only if polarisabilities are present). The default is 0,
              meaning that each permanent multipole is only excluded in the calculation of the field at its own
              polarisability, 1 means that one gives a fragment number to each multipole and that the static
              multipoles do not contribute to the polarising field within the same fragment, whereas 2 can be
              used in more complex situations, e.g. polymers, allowing you to specify a second fragment number
              so that junction atoms does not contribute to either of the neighbouring fragments.
              Finally, the fifth and last integer (nRead) (relevant only if Langevin dipoles are used) may
              be 0 or 1 (where 0 is default), specifying whether an element number (e.g. 8 for oxygen) should be
              read for each multipole. In that case the default radius for that element is used to determine which
              Langevin grid points should be annihilated. A negative element number signifies that a particular
              radius should be used for that multipole, in thousands of a Bohr (-1400 meaning 1.4 Bohr).
              Then follows nXF lines, one for each center. On each line is first nFrag+nRead (which may equal 0)
              integers, specifying the fragments that the multipole should not contribute to (the first fragment is
              taken as the fragment that the polarisability belongs to) and the element number. Then follows
              the three coordinates of the center, followed by the multipoles and polarisabilities. The number of
              multipole entries is 0 for nOrd=-1, 1 for nOrd=0, 4 for nOrd=1, and 10 for nOrd=2. The number of
              polarisability entries are 0 for p=0, 1 for p=1, and 6 for p=2. The order of quadrupole moment and
              anisotropic polarisability entries is xx, xy, xz, yy, yz, zz. If default is used, i.e. only specifying
              the number of centers on the first line, each of these lines will contain 7 entries (coordinates,
              charge, and dipole vector). All entries are in atomic units, if not otherwise requested by the Angstrom
              keyword that must be placed between nXF and nOrd. All these data can be stored in a separate file whose
              name must be passed as an argument of the XField keyword.
              </KEYWORD>

:kword:`SDIPole`
  Requests computation of velocity integrals. This is usually enabled by default.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SDIPOLE" APPEAR="Velocity integrals" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Sdipole <basic>
              <HELP>
              Requests computation of velocity integrals.
              </HELP>
              </KEYWORD>

:kword:`ANGM`
  Supplement
  :file:`ONEINT` for transition angular momentum calculations.
  Entry which specifies the angular momentum origin (in au).
  By default this is enabled with the origin at the center of mass.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ANGM" APPEAR="Angular momentum" KIND="REALS" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: Angm <basic>
              <HELP>
              Supplement the file for transition angular momentum calculations.
              Enter the angular momentum operator origin (in au).
              </HELP>
              The keyword is followed by a card which specifies the angular momentum
              origin (in au).
              </KEYWORD>

:kword:`OMQI`
  Supplement
  :file:`ONEINT` for transition orbital magnetic quadrupole calculations.
  Entry which specifies the orbital magnetic quadrupole origin (in au).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="OMQI" APPEAR="Orbital magnetic quadrupole" KIND="REALS" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: OMQI <basic>
              <HELP>
              Supplement the file for transition orbital magnetic quadrupole calculations.
              Enter the orbital magnetic quadrupole operator origin (in au).
              </HELP>
              The keyword is followed by a card which specifies the orbital magnetic quadrupole
              origin (in au).
              </KEYWORD>

:kword:`AMPR`
  Request the computation of angular momentum product integrals.
  The keyword is followed by values which specifies the angular momentum
  origin (in au).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="AMPR" APPEAR="Angular momentum product" KIND="REALS" SIZE="3" LEVEL="ADVANCED">
              <HELP>
              Request the computation of angular momentum product integrals and specify the
              angular momentum origin (in au).
              </HELP>
              %%Keyword: Ampr <basic>
              Request the computation of angular momentum product integrals.
              The keyword is followed by a card which specifies the angular momentum
              origin (in au).
              </KEYWORD>

:kword:`DSHD`
  Requests the computation of diamagnetic shielding integrals. The first
  entry specifies the gauge origin. Then follows an integer
  specifying the number of points at which the diamagnetic
  shielding will be computed. If this entry is zero, the diamagnetic
  shielding will be computed at each nucleus. If nonzero, then the
  coordinates (in au) for each origin has to be supplied, one entry for each
  origin.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="DSHD" APPEAR="Diamagnetic shielding" KIND="STRINGS" SIZE="10" LEVEL="ADVANCED">
              %%Keyword: DSHD <basic>
              <HELP>
              Activate the computation of diamagnetic shielding integrals. The first entry
              specifies the gauge origin. On the subsequent entries an
              integer specifying the number of points at which the diamagnetic
              shielding will be computed. If this entry is zero, the diamagnetic
              shielding will be computed at each nucleus. If nonzero, then the
              coordinates (in au) for each origin has to be supplied, one entry for each
              origin.
              </HELP>
              </KEYWORD>

:kword:`MXTC`
  Requests the computation of X2C transformed hyperfine magnetic integrals (used in subsequent
  hyperfine calculations), has to be used together with the keyword :kword:`RX2C`.
  If one wants to calculate the non-relativistic limit, one can simply set up a large
  speed of light value.
  See reference for details :cite:`Feng_JChemTheoryComput_Electron_2021`.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="MXTC" APPEAR="X2C hyperfine magnetic" KIND="SINGLE" REQUIRE="RX2C" LEVEL="BASIC">
              %%Keyword: MXTC <basic>
              <HELP>
              Requests the computation of X2C transformed hyperfine magnetic integrals (used in subsequent
              hyperfine calculations), has to be used together with the keyword RX2C.
              If one wants to calculate the non-relativistic limit, one can simply set up a large
              speed of light value.
              </HELP>
              </KEYWORD>

  .. :kword:`DOUGlas-kroll`
     Explicit request that the one-electron Hamiltonian include the scalar relativistic
     effects according to the so-called Douglas--Kroll transformation.

  ..   .. xmldoc:: %%Keyword: Douglas-Kroll <basic>
                   Explicit request that the one-electron Hamiltonian include the scalar relativistic
                   effects according to the so-called Douglas-Kroll transformation.
                   This option is automatically invoked for the ANO-RCC and ANO-DK3 basis sets.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="DOUGLAS-KROLL" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

:kword:`RX2C`
  Request the scalar relativistic X2C (eXact-two-Component) corrections to the
  one-electron Hamiltonian as well as the property integrals.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RX2C" APPEAR="Relativistic X2C integrals" KIND="SINGLE" EXCLUSIVE="RBSS" LEVEL="BASIC">
              %%Keyword: RX2C <basic>
              <HELP>
              Request the scalar relativistic X2C (eXact-two-Component) corrections to the
              one-electron Hamiltonian as well as the property integrals.
              </HELP>
              </KEYWORD>

:kword:`RBSS`
  Request the scalar relativistic BSS (Barysz--Sadlej--Snijders) corrections to the
  one-electron Hamiltonian as well as the property integrals. The non-iterative
  scheme is employed for the construction of BSS transformation.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RBSS" APPEAR="Relativistic BSS integrals" KIND="SINGLE" EXCLUSIVE="RX2C" LEVEL="BASIC">
              %%Keyword: RBSS <basic>
              <HELP>
              Request the scalar relativistic BSS (Barysz-Sadlej-Snijders) corrections to the
              one-electron Hamiltonian as well as the property integrals. The non-iterative
              scheme is employed for the construction of BSS transformation.
              </HELP>
              </KEYWORD>

:kword:`NOAMfi`
  Explicit request for no computation of atomic mean-field integrals.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NOAM" APPEAR="No AMFI integrals" KIND="SINGLE" EXCLUSIVE="AMFI" LEVEL="BASIC">
              %%Keyword: NOAMFI <basic>
              <HELP>
              Explicit request for no computation of atomic mean-field integrals.
              </HELP>
              </KEYWORD>

:kword:`AMFI`
  Explicit request for the computation of atomic mean-field integrals (used in
  subsequent spin--orbit calculations). These integrals are computed by default for the
  ANO-RCC and ANO-DK3 basis sets.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="AMFI" APPEAR="AMFI integrals option" KIND="SINGLE" EXCLUSIVE="NOAM" LEVEL="BASIC">
              %%Keyword: AMFI <basic>
              <HELP>
              Explicit request for the computation of atomic mean-field integrals (used in
              subsequent spin-orbit calculations). These integrals are computed by default for
              relativistic basis sets like the ANO-RCC and ANO-DK3 basis sets.
              </HELP>
              </KEYWORD>

:kword:`EPOT`
  An integer follows which represents the
  number of points for which the electric potential will be computed. If
  this number is zero, the electric potential acting on each nucleus will be
  computed. If nonzero, then the coordinates (in au) for each point have to be
  supplied, one entry for each point.
  This keyword is mutually exclusive with :kword:`EFLD` and :kword:`FLDG`.

  .. xmldoc:: <SELECT MODULE="GATEWAY" NAME="EF" APPEAR="Electric potential, field and field gradient options" LEVEL="BASIC" CONTAINS="EPOT,EFLD,FLDG">

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="EPOT" APPEAR="Electric potential" KIND="CUSTOM" LEVEL="ADVANCED">
              <HELP>
              Activate the computation of the electric potential at some points.
              The first entry is the number of points at which this should be computed.
              The coordinates (in au) for each point have to be
              supplied on the subsequent entries.
              If the number of points is zero, the electric potential on each nucleus will be computed.
              </HELP>
              %%Keyword: EPOT <basic>
              An integer follows which represents the
              number of points for which the electric potential will be computed. If
              this number is zero, the electric potential acting on each nucleus will be
              computed. If nonzero, then the coordinates (in au) for each point have to be
              supplied, one entry for each point.
              This keyword is mutually exclusive with EFLD and FLDG.
              </KEYWORD>

:kword:`EFLD`
  An integer follows which represents the
  number of points for which the electric potential and electric field will be computed. If
  this number is zero, the electric field acting on each nucleus will be
  computed. If nonzero, then the coordinates (in au) for each point have to be
  supplied, one entry for each point.
  This keyword is mutually exclusive with :kword:`EPOT` and :kword:`FLDG`.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="EFLD" APPEAR="Electric field" KIND="CUSTOM" LEVEL="ADVANCED">
              <HELP>
              Activate the computation of the electric potential and field at some points.
              The first entry is the number of points at which this should be computed.
              The coordinates (in au) for each point have to be
              supplied on the subsequent entries.
              If the number of points is zero, the electric field on each nucleus will be computed.
              </HELP>
              %%Keyword: EFLD <basic>
              Followed by a card with an integer entry which represents the
              number of points for which the electric potential and electric field will be computed. If
              this number is zero, the electric field acting on each nucleus will be
              computed. If nonzero, then the coordinates (in au) for each point have to be
              supplied, one entry for each point.
              This keyword is mutually exclusive with EPOT and FLDG.
              </KEYWORD>

:kword:`FLDG`
  An integer required which represents the
  number of points for which the electric potential, electric field and electric field gradient will be
  computed. If this number is zero, the electric field gradient acting
  on each nucleus will be computed. If nonzero, then either the coordinates (in au) for
  each point or labels for each atom center have to be supplied, one entry for each point.
  In case a label is supplied it must match one of those given previous in the input during specification
  of the coordinates of the atom centers. Using a label instead of a coordinate can e.g. be useful
  in something like a geometry optimization where the coordinate isn't known when the input is written.
  This keyword is mutually exclusive with :kword:`EPOT` and :kword:`EFLD`.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FLDG" APPEAR="Electric field gradient" KIND="CUSTOM" LEVEL="ADVANCED">
              <HELP>
              Activate the computation of the electric potential, field and field gradient at some points.
              The first entry is the number of points at which this should be computed.
              The coordinates (in au) for each point have to be
              supplied on the subsequent entries.
              If the number of points is zero, the electric field gradient on each nucleus will be computed.
              </HELP>
              %%Keyword: FLDG <basic>
              An integer required which represents the
              number of points for which the electric potential, electric field and electric field gradient will be
              computed. If this number is zero, the electric field gradient acting
              on each nucleus will be computed. If nonzero, then either the coordinates (in au) for
              each point or labels for each atom center have to be supplied, one entry for each point.
              In case a label is supplied it must match one of those given previous in the input during specification
              of the coordinates of the atom centers. Using a label instead of a coordinate can e.g. be useful
              in something like a geometry optimization where the coordinate isn't known when the input is written.
              This keyword is mutually exclusive with EPOT and EFLD.
              </KEYWORD>

  .. xmldoc:: </SELECT>

:kword:`EMPC`
  Use point charges specified by the keyword :kword:`XField` when calculating the Orbital-Free Embedding potential.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="EMPC" APPEAR="Embedded Point Charges" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: EMPC <basic>
              <HELP>
              Use point charges specified by the keyword XFIELD when calculating the Orbital-Free Embedding potential.
              </HELP>
              </KEYWORD>

:kword:`RF-Input`
  Specification of reaction field parameters, consult the reaction field section of this manual.

  .. xmldoc:: %%Keyword: RF-input <basic>
              Specification of reaction field parameters, consult the reaction field section of this
              manual.

.. xmldoc:: </GROUP>

Keywords associated with nuclear charge distribution models
...........................................................

Input parameters associated with different models of the nuclear charge distribution. The
default is to use a point charge representation.

.. xmldoc:: <GROUP MODULE="GATEWAY" NAME="NUCLEAR" APPEAR="Nuclear Models" KIND="BOX" LEVEL="ADVANCED">

.. class:: keywordlist

:kword:`FINIte`
  Request a finite center representation of the nuclei by a single exponent s-type Gaussian.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FINITE" APPEAR="Activate Gaussian Nuclear Charge Distribution" KIND="SINGLE" EXCLUSIVE="MGAUSSIAN" LEVEL="ADVANCED">
              %%Keyword: Finite <basic>
              <HELP>
              Request a finite center representation of the nuclei by a single exponent s-type Gaussian.
              </HELP>
              </KEYWORD>

:kword:`MGAUSsian`
  Request a finite center representation of the nuclei by a modified Gaussian.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="MGAUSSIAN" APPEAR="Activate Modified Gaussian Charge Distribution" KIND="SINGLE" EXCLUSIVE="FINITE" LEVEL="ADVANCED">
              %%Keyword: MGauss <basic>
              <HELP>
              Request a finite center representation of the nuclei by a modified Gaussian.
              </HELP>
              </KEYWORD>

.. xmldoc:: </GROUP>

The Saddle method for transition state optimization
...................................................

The Saddle method :cite:`Saddle_method` is a method to locate transition states (TS). The method, in practice, can be viewed as a
series of constrained optimization along the reaction path, which connects two starting structure (could be
the reactants and products of a reaction), to locate the region of the TS and a subsequent unconstrained optimization
to locate the TS. The only data needed for the procedure are the energies and coordinates of the two structures.
**Note** that this option will overwrite the
coordinates which have already been specified with the normal input of the molecular geometry. However, this does
not make that input section redundant and should always be included.

.. xmldoc:: <GROUP MODULE="GATEWAY" NAME="SADDLEMETHOD" APPEAR="Saddle Method" KIND="BOX" LEVEL="ADVANCED">

.. class:: keywordlist

:kword:`RP-Coordinates`
  This activates the Saddle method for TS geometry optimization.
  The line is followed by an integer specifying the number of symmetry unique coordinates to be specified. This
  is followed by two sets of input --- one line with the energy and then the Cartesian coordinates in bohr --- for
  each of the two starting structures of the Saddle method. Note that the order of the coordinates must always
  match the order specified with the conventional input of the coordinates of the molecular system.
  Alternatively, two lines with the filenames containing the coordinates of reactants and products, respectively,
  (in XYZ format) can be given.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="RP-COORD" APPEAR="Reactants and Products coordinates" KIND="STRINGS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: RP-Coordinates <advanced>
              <HELP>
              This activates the Saddle method for TS geometry optimization.
              The line is followed by an integer specifying the number of symmetry unique coordinates to be specified. This
              is followed by two sets of input - one line with the energy and then the Cartesian coordinates in bohr - for
              each of the two starting structures of the Saddle method. Note that the order of the coordinates must always
              match the order specified with the conventional input of the coordinates of the molecular system.
              Alternatively, two lines with the filenames containing the coordinates of reactants and products, respectively,
              (in XYZ format) can be given.
              </HELP>
              </KEYWORD>

:kword:`NOALign`
  By default, the two starting structures are aligned to minimize the root mean square distance (RMSD) between them,
  in particular, the first structure is moved and the second structure remains fixed.
  If this keyword is given, the starting structures are used as given.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="NOALIGN" APPEAR="No align" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="ALIGNONLY">
              %%Keyword: NoAlign <advanced>
              <HELP>
              By default, the two starting structures are aligned to minimize the root mean square distance (RMSD) between them,
              in particular, the first structure is moved and the second structure remains fixed.
              If this keyword is given, the starting structures are used as given.
              </HELP>
              </KEYWORD>

:kword:`ALIGn only`
  The two starting structures are aligned, but nothing more is done.
  An input block for :program:`seward` is still needed, but no integrals are computed.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ALIGNONLY" APPEAR="Align only" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="NOALIGN">
              %%Keyword: AlignOnly <advanced>
              <HELP>
              The two starting structures are aligned, but nothing more is done.
              An input block for SEWARD is still needed, but no integrals are computed.
              </HELP>
              </KEYWORD>

:kword:`WEIGhts`
  Relative weights of each atom to use for the alignment and for the calculations of the
  "distance" between structures. The possibilities are:

  .. container:: list

    **MASS**. This is the default. Each atom is given a weight proportional to its mass. Equivalent
    to mass-weighted coordinates.

    **EQUAL**. All atoms have an equal weight.

    **HEAVY**. Only heavy atoms are considered, with equal weights. Hydrogens are given zero weight.

  .. compound::

    A list of :math:`N` numbers can also be provided, and they will be used as weights for the :math:`N`
    symmetry-unique atoms. For example: ::

      WEIGhts
      0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0

    will align only atoms 7--12 out of 16.

  Note that, in any case, weights of 0 are likely to cause problems with constraints, and they will
  be increased automatically.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="WEIGHTS" APPEAR="Weights" KIND="STRING" DEFAULT_VALUE="Mass" LEVEL="ADVANCED">
              %%Keyword: Weights <advanced>
              <HELP>
              Relative weights of each atom to use for the alignment and for the calculation of the
              "distance" between structures. The possibilities are:

              MASS  -- This is the default. Each atom is given a weight proportional to its mass. Equivalent to mass-weighted coordinates.
              EQUAL -- All atoms have an equal weight.
              HEAVY -- Only heavy atoms are considered, with equal weights. Hydrogens are given zero weight.

              A list of N numbers can also be provided, and they will be used as weights for the N symmetry-unique atoms.
              </HELP>
              </KEYWORD>

:kword:`SADDle`
  Step size reduction for each macro iteration of the saddle method.
  The value is given in weighted coordinates, divided by the square root of the total weight
  (see the :kword:`WEIGHTS` keyword).
  Default value is 0.1 au.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SADDLE" APPEAR="Saddle Step" KIND="REAL" DEFAULT_VALUE="0.1" LEVEL="ADVANCED">
              %%Keyword: SaddleStep <advanced>
              <HELP>
              Step size reduction for each macro iteration of the saddle method.
              The value is given in weighted coordinates, divided by the square root of the total weight
              (see the WEIGHTS keyword).
              Default value is 0.1 au.
              </HELP>
              </KEYWORD>

.. xmldoc:: </GROUP>

Geometry optimization using constrained internal coordinates
............................................................

.. compound::

  These keyword are used together with the :program:`geo` to optimize the relative position of two or
  more rigid fragments. The starting geometry can either be defined by supplying an xyz-file for each
  fragment using the keyword :kword:`coord` or by placing a file named :file:`$Project.zmt` in a directory
  named :file:`$Project.GEO`. The z-matrix should be in the following format: ::

    O     0.982011 0                                 1
    H     0.982013 0   104.959565 0                  2   1
    H     1.933697 1   107.655494 1   114.496053 1   2   3   1
    O     0.988177 0   173.057942 1   -56.200750 1   4   2   3
    H     0.979890 0   104.714572 0   179.879745 1   5   4   2

  where the three columns of real numbers are internal coordinates, and the last
  three columns of integers indicate which other atoms that are used to define
  the coordinate. The type of coordinates from left to right are bond distances,
  bond angles and dihedral angels, both for the coordinates and the link. The
  column of integers just to the right of each coordinate indicate if this
  coordinate should be optimized or not (1 = optimize, 0 = do not optimize).

There are also two utility-keywords used to create a z-matrix or to write out
a constraint-definition for :program:`slapaf` and keywords to rotate and translate
fragments. (See documentation for :program:`GEO` for more details)

.. class:: keywordlist

:kword:`HYPER`
  This keyword is used to specify that a geometry optimization with constrained
  internal coordinates shall be performed later, a z-matrix and a set of
  displaced geometries are therefore constructed. The keyword should be followed by three
  real numbers defining the maximum displacement for each coordinate type.
  The order from left to right is bond distances, bond angles and dihedral angles.
  To use default values for the parameters the mutually exclusive keyword
  :kword:`geo` should be entered instead.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="HYPER" APPEAR="hyper" KIND="REALS" SIZE="3" LEVEL="ADVANCED" EXCLUSIVE="GEO">
              <HELP>
              Perform a geometry optimization in constrained internal coordinates using
              user-defined parameters for hypersurface gridpoints.
              </HELP>
              %%Keyword: hyper <advanced>
              Followed by three real numbers to define hypersurface gridpoint
              parameters for bond distance, bond angles and dihedral angles. Allows for a
              geometry optimization in constrained internal coordinates.
              </KEYWORD>

:kword:`GEO`
  This keyword is used to specify that a geometry optimization with constrained
  internal coordinates shall be performed later, a z-matrix and a set of displaced
  geometries are therefore constructed. Default values of 0.15 Å, 2.5 degrees,
  and 2.5 degrees are used for the maximum displacement of bond distances, bond
  angles and dihedral angles respectively. To enter other values for the parameters
  the mutually exclusive keyword :kword:`hyper` should be used.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="GEO" APPEAR="geo" KIND="SINGLE" LEVEL="ADVANCED" EXCLUSIVE="HYPER">
              %%Keyword: geo <advanced>
              <HELP>
              Perform a geometry optimization in constrained internal coordinates using
              default parameters for hypersurface gridpoints (bond=0.15, bond angle=2.5, and
              dihedral angle=2.5)
              </HELP>
              </KEYWORD>

:kword:`OPTH`
  This keyword is used to define the specific details of the optimization algorithm used
  for the geometry optimization in constrained internal coordinates.
  This keyword should be followed by two to three lines of parameter. The first line should
  contain an integer indicating optimization type (1 = steepest descent, 2 = a mix of
  steepest descent and Newton's method, and 3 = Newton's method). The second line
  should contain a real number defining a step factor.
  This number is multiplied with the gradient to obtain the step length.
  For optimization type 2 a third line containing a real number that defines a gradient limit
  should be entered. This limit determines how large the gradient must be for the steepest
  descent algorithm to be used. When the gradient is smaller than this limit Newton's method
  is used instead.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="OPTH" APPEAR="OptH" KIND="STRINGS" SIZE="3" LEVEL="ADVANCED">
              %%Keyword: opth <advanced>
              <HELP>
              Followed by one line with an integer specifying the optimization type (1 = steepest
              descent, 2 = mixed, 3 = Newton's method), a second line with a real number specifying
              a step factor and if using type "mixed" a third line with a real number specifying
              the maximum gradient size for which steepest descent is used.
              </HELP>
              </KEYWORD>

:kword:`OLDZ`
  This keyword is used both to start a new calculation from a user-defined z-matrix and
  to restart calculations. When using the keyword for a new calculation a directory
  :file:`$Project.GEO` must exist and contain a file called :file:`$Project.zmt` with a z-matrix in
  the format defined above. The directory must not contain any files with the suffix :file:`.info`
  when performing a fresh calculation since these files contain restart information.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="OLDZ" APPEAR="Old Z-matrix" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: OldZ <advanced>
              <HELP>
              Start new calculation based on $Project.GEO/$Project.zmt
              </HELP>
              </KEYWORD>

:kword:`ZONLY`
  This keyword is used to construct a z-matrix from a set of xyz-files (fragments)
  and store it in the directory :file:`$Project.GEO`. The optimization parameters
  of the resulting z-matrix are set so that only coordinates linking fragments are
  set to 1 (= optimize coordinate).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ZONLY" APPEAR="z-constraints" KIND="SINGLE" LEVEL="ADVANCED">
              <HELP>
              Prints a z-matrix ($Project.zmt) in the directory $Project.GEO.
              </HELP>
              %%Keyword: zonly <advanced>
              A z-matrix ($Project.zmt) is printed in the $Project.GEO-directory. The optimization parameters
              are set so that each fragment is kept rigid and only coordinates linking fragments are
              optimized.
              </KEYWORD>

:kword:`ZCONS`
  This keyword is used to define constraints from a set of xyz-files (fragments)
  on a form that could be supplied to the
  :program:`slapaf` in order to keep the fragments rigid. The resulting constraints-file
  is named :file:`$Project.cns` and stored in the directory :file:`$Project.GEO`. The
  atom-numbers in this constraint-file will not match those of your original xyz-file and
  should not be used together with this. Instead a new xyz-file named :file:`cons.xyz` is created
  and placed into the directory :file:`$Project.GEO`, this has the proper numbering to use together with the constraints.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ZCONS" APPEAR="z-constraints" KIND="SINGLE" LEVEL="ADVANCED">
              <HELP>
              Prints a constraints-file ($Project.cns) and an xyz-file (cons.xyz)
              with matching atom numbering in the directory $Project.GEO .
              </HELP>
              %%Keyword: zcons <advanced>
              Prints a file with a constraints-definition for rigid fragments formatted for
              use in slapaf ($Project.cns) and an xyz-file (cons.xyz) with the same
              atom number. Both files are printed in the $Project.GEO-directory.
              </KEYWORD>

:kword:`ORIGIN`
  This keyword is used to translate and rotate a set of xyz-files. The keyword must be entered
  before the xyz-files is entered with :kword:`coord`.
  The keyword should be followed by two lines for each fragment in the input.
  The first row should contain 3 real numbers defining a translation (x, y, z),
  the second row should contain 9 numbers defining a rotation (row1, row2, row3 of
  rotation matrix). The keyword :kword:`origin` is mutually exclusive with the keyword :kword:`frgm`
  which is an alternative way to express the same rotations and translations.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ORIG" APPEAR="origin" KIND="UNKNOWN" LEVEL="ADVANCED" EXCLUSIVE="FRGM">
              %%Keyword: origin <advanced>
              <HELP>
              Followed by two lines for each fragment.
              The first line should have 3 real numbers defining a translation and the
              second 9 real numbers defining a rotation.
              </HELP>
              (See ROT and TRANS.)
              Must occur before the xyz-files are entered with coord.
              </KEYWORD>

:kword:`FRGM`
  This keyword is used together with the keywords :kword:`rot` and :kword:`trans` to define
  rotation and translation of a specific fragment. :kword:`Frgm` defines an active fragment (each xyz-file is considered a fragment, the files are numbered based on
  order of appearance in the input from top to bottom). The keyword must be entered before the xyz-file it is supposed to modify is
  entered with :kword:`coord`. Each occurence of
  :kword:`frgm` should be followed by either one of or both of the keywords :kword:`rot` and :kword:`trans`
  to define rotation and translation. This keyword is mutually exclusive with the keyword :kword:`origin`

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FRGM" APPEAR="fragment" KIND="INT" LEVEL="ADVANCED" EXCLUSIVE="ORIGIN">
              %%Keyword: frgm <advanced>
              <HELP>
              Followed by a fragment number and either or both of ROT and TRANS to define
              rotation and translation of this fragment.
              </HELP>
              Each xyz-file is considered a
              fragment, numbering is from top to bottom of input. Must occur before the modified xyz-file
              is entered with coord.
              </KEYWORD>

:kword:`ROT`
  This keyword should be followed by nine real numbers defining the rotation for the fragment defined by
  the preceeding :kword:`frgm`. The numbers should be the nine elements of a rotation matrix
  listed with one full row at the time.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="ROT" APPEAR="rotation" KIND="REALS" SIZE="9" LEVEL="ADVANCED" REQUIRE="FRGM">
              <HELP>
              The nine numbers define a rotation matrix.
              </HELP>
              %%Keyword: rot <advanced>
              The keyword should be followed by nine real numbers defining a rotation matrix.
              Should only be used together with the FRGM keyword.
              </KEYWORD>

:kword:`TRANS`
  This keyword should be followed by three real numbers defining the translation for the fragment defined
  by the preceeding :kword:`frgm`. The numbers should be the x, y and z coordinates of the translation
  in that order.

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="TRANS" APPEAR="translation" KIND="REALS" SIZE="3" LEVEL="ADVANCED" REQUIRE="FRGM">
              <HELP>
              The three numbers define a translation. (x y z)
              </HELP>
              %%Keyword: trans <advanced>
              The keyword should be followed by three real numbers defining a translation (x y z).
              Should only be used together with the FRGM keyword.
              </KEYWORD>

Example of an input: ::

  &GATEWAY
  Title
  Water Dimer
  frgm=2
  trans=3.0 0.0 0.0
  Coord=water_monomer.xyz
  Coord=water_monomer.xyz
  Group=c1
  basis=cc-pVTZ
  hyper
  0.2 3.0 3.0
  opth
  3
  15.0d0

In this example a water dimer is constructed from a single monomer by translating
it 3.0 Å with the keyword trans. An optimization in constrained internal
coordinates using newtons method with a step-factor of 15.0d0 are prepared for. For
more details on these optimization see the manual entry for the module
:program:`geo`.

.. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="TINKER" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

QM/MM calculations with |molcas|/:program:`Gromacs`
...................................................

The following keywords apply to QM/MM calculations performed with the |molcas|/:program:`GROMACS` interface (see :numref:`UG:sec:espf` for more details).

.. class:: keywordlist

:kword:`GROMacs`
  Requests that the definition of the full QM+MM system should be imported from :program:`GROMACS`. The keyword should be followed by one of the options :kword:`SIMPLE` or :kword:`CASTMM` on the next line. In the case of :kword:`SIMPLE`, all MM atoms defined in the :program:`GROMACS` input will be treated as *outer* MM atoms in |molcas|. This means, for example, that in a geometry optimization, their positions will be updated using microiterations rather than the conventional optimization scheme. Conversely, :kword:`CASTMM` requests that certain MM atoms should be treated as *inner* MM atoms in |molcas|. Their positions will be updated with the same scheme as used for the QM atoms. The :kword:`CASTMM` option should be followed by two additional input lines, the first one containing the number of MM atoms to convert from outer to inner type, and the second containing a list of those atoms (using their corresponding :program:`GROMACS` indices).

  .. xmldoc:: <GROUP MODULE="GATEWAY" NAME="GROMACS" APPEAR="Gromacs" KIND="RADIO" LEVEL="ADVANCED">
              %%Keyword: Gromacs <basic>
              Requests that the definition of the full QM+MM system should be imported from GROMACS.
              The keyword should be followed by one of the options SIMPLE or CASTMM on the next line.
              In the case of SIMPLE, all MM atoms defined in the GROMACS input will be treated as outer MM atoms in MOLCAS.
              This means, for example, that in a geometry optimization, their positions will be updated using microiterations rather than the conventional optimization scheme.
              Conversely, CASTMM requests that certain MM atoms should be treated as inner MM atoms in MOLCAS.
              Their positions will be updated with the same scheme as used for the QM atoms.
              The CASTMM option should be followed by two additional input lines,
              the first one containing the number of MM atoms to convert from outer to inner type,
              and the second containing a list of those atoms (using their corresponding GROMACS indices).

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="SIMPLE" APPEAR="Simple" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="CASTMM" APPEAR="CastMM" KIND="INTS" SIZE="2" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: </GROUP>

:kword:`LINKatoms`
  Defines link atoms for use with the Morokuma updating scheme. The desired number of link atoms should be given as an integer on the next line. This should be followed by additional input lines, one for each link atom to be defined. Each definition should be of the form ILA, IQM, IMM, SCALE, where ILA, IQM and IMM are the :program:`GROMACS` indices of the link atom and the corresponding QM and MM frontier atoms, respectively. SCALE is the scaling factor to be used in the Morokuma scheme. Note that each link atom must be defined as a QM atom in the :program:`GROMACS` input. In addition, the frontier MM atom must be an inner MM atom specified as discussed above.

  .. xmldoc:: %%Keyword: LinkAtoms <advanced>
              Defines link atoms for use with the Morokuma updating scheme (MOLCAS/GROMACS calculations only).
              The desired number of link atoms should be given as an integer on the next line.
              This should be followed by additional input lines, one for each link atom to be defined.
              Each definition should be of the form ILA, IQM, IMM, SCALE, where ILA, IQM and IMM
              are the GROMACS indices of the link atom and the corresponding QM and MM frontier atoms, respectively.
              SCALE is the scaling factor to be used in the Morokuma scheme.
              Note that each link atom must be defined as a QM atom in the GROMACS input.
              In addition, the frontier MM atom must be an inner MM atom specified with the GROMACS keyword in GATEWAY.

.. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FPCO" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="FPPR" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="GATEWAY" NAME="PRINT" KIND="INTS_COMPUTED" SIZE="2" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>
.. index::
   single: Program; DMRGSCF
   single: DMRGSCF

.. _UG\:sec\:dmrgscf:

:program:`dmrgscf`
==================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="DMRGSCF">
            %%Description:
            <HELP>
            The DMRGSCF program generates MPS wave functions based on a given CAS model.
            It requires the one- and two-electron integral files generated by
            SEWARD, and starting orbitals from either a previous DMRGSCF/RASSCF
            calculation or from any of the other wave function generating programs,
            or from the GUESSORB facility.
            The resulting orbitals can be visualized, e.g. by LUSCUS.
            </HELP>

The :program:`DMRGSCF` program in |molcas| performs
multiconfigurational SCF calculations in which a density matrix renormalization group (DMRG)
driver replaces a CI driver for the solution of the Complete Active Space
(CAS) problem. In the latter a matrix-product state (MPS) wave function is obtained as an approximate solution to a
full CI wave function in an active orbital space. In analogy to CASSCF, the DMRGSCF method is based on a partitioning of the occupied molecular
orbitals into the following groups:

* **Inactive orbitals:** Orbitals that are doubly occupied in all
  configurations.

* **Active orbitals:** In these orbitals all possible occupations are allowed.

* **Secondary orbitals:** Orbitals that are empty (unoccupied) in all configurations.

The :program:`DMRGSCF` program currently supports only the **QCMaquis** DMRG program suite :cite:`kell15a,kell16,knec16a` as
active space optimizer but in future it could be useful also for other DMRG programs interfaced to |molcas|
such as Block or CheMPS2. The latter two are currently activated through the :program:`RASSCF` input.

For further information concerning input orbitals, convergence (acceleration) of the orbital optimization algorithm,
dependencies, input orbitals, etc., we refer the reader to the introdcution of the :program:`RASSCF` program (see
:numref:`UG:sec:rasscf`) which is called by the :program:`DMRGSCF` program in order to perform the actual orbital optimization. DMRGSCF calculations require to have
only active orbitals in RAS2 (see the keyword list in the program :program:`RASSCF`, :numref:`UG:sec:rasscf` for
details).

**NOTE**: The :program:`DMRGSCF` program does **NOT** support RASSCF/GASSCF calculations but it can be combined with MC-PDFT. For options
concerning the latter, see the documentation of the :program:`MCPDFT` program, :numref:`UG:sec:mcpdft`.

.. _QCMaquis: https://scine.ethz.ch/static/download/qcmaquis_manual.pdf

.. _UG\:sec\:dmrgscf_input:

DMRGSCF input section
---------------------

The :program:`DRMGSCF` program is activated in general by ::

  &DMRGSCF &END
  ...
  End of Input

In the following we provide further input options for a DMRGSCF calculation.

.. class:: keywordlist

:kword:`ActiveSpaceOptimizer`
  **MANDATORY**: Sets the DMRG program to be used as active space optimizer. Currently the only choice is QCMaquis,
  i.e. ::

    ActiveSpaceOptimizer=QCMaquis

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="ACTIVESPACEOPTIMIZER" KIND="CHOICE" LIST="QCMaquis" LEVEL="BASIC">
              %%Keyword: ActiveSpaceOptimizer <basic>
              <HELP>
              Sets the DMRG program to be used as active space optimizer
              </HELP>
              </KEYWORD>

:kword:`Fiedler`
  .. compound::

    The Fiedler keyword, i.e., ::

      Fiedler=on

    enables a state-specific orbital ordering for the MPS optimization by exploiting concepts from graph theory. The ordering follows from the elements of the Fiedler vector which is the eigenvector corresponding to the second lowest eigenvalue of the so-called graph Laplacian.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="FIEDLER" KIND="CHOICE" LIST="on" LEVEL="BASIC">
              %%Keyword: Fiedler <basic>
              <HELP>
              Enables Fiedler vector ordering.
              </HELP>
              </KEYWORD>

:kword:`CIDEAS`
  .. compound::

    The CIDEAS keyword, i.e., ::

      CIDEAS=on

    enables a more advanced algorithm to construct a suitable initial MPS (see the keyword init_state in Table 7 of the
    QCMaquis_ manual for other options) provided by the configuration interaction dynamically extended active space (CI-DEAS) approach.
    The CI-DEAS protocol can be interpreted
    as an orbital entanglement entropy guided configuration selection and the quality of this initial guess depends on the
    quality of the initial CAS vector. The CI-DEAS functionality is currently restricted to calculations performed with C1
    symmetry. Support for other point group symmetries will be available in due time. **Note**: The CIDEAS option requires to
    set the *HF occupation* for each state in the OptimizationSettings input section below by means of the :kword:`SOCC` keyword.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="CIDEAS" KIND="CHOICE" LIST="on" LEVEL="BASIC">
              %%Keyword: CIDEAS <basic>
              <HELP>
              Enables CI-DEAS.
              </HELP>
              </KEYWORD>

.. _UG\:sec\:dmrgsettings_input:

DMRGSettings input section
..........................

DMRGSCF calculations require to set some DMRG-specific options, which will be passed on to the **QCMaquis** program. All mandatory keywords,
which must be present in each calculation, are summarized below. In addition to those keywords, any **QCMaquis** keyword
listed in Table 8 of the QCmaquis_ manual may be specified
in this section. The start and end of the DMRGSettings input section is given by ::

  DMRGSettings
  ...
  EndDMRGSettings

.. class:: keywordlist

:kword:`max_bond_dimension`
  Maximum number of renormalized block states (commonly referred to as :math:`m`-value or bond dimension) that will be kept during each microiteration step of a sweep.

  .. xmldoc:: <GROUP MODULE="DMRGSCF" NAME="DMRGSETTINGS" APPEAR="DMRG settings" KIND="BLOCK" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="MAX_BOND_DIMENSION" KIND="INT" LEVEL="BASIC">
              %%Keyword: max_bond_dimension <basic>
              <HELP>
              Maximum bond dimension.
              </HELP>
              </KEYWORD>

:kword:`nsweeps`
  Maximum number of DMRG sweeps. Please be aware that nsweeps sets the number of combined forward and backward sweeps. Thus, the actual number of sweeps is :math:`2\times`:kword:`nsweeps`.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="NSWEEPS" KIND="INT" LEVEL="BASIC">
              %%Keyword: nsweeps <basic>
              <HELP>
              Maximum number of DMRG sweeps.
              </HELP>
              </KEYWORD>

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="NGROWSWEEPS" KIND="INT" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="NMAINSWEEPS" KIND="INT" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="SWEEP_BOND_DIMENSIONS" KIND="STRING" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="INIT_BOND_DIMENSIONS" KIND="INT" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="CONV_THRESH" KIND="REAL" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="TRUNCATION_FINAL" KIND="REAL" LEVEL="UNDOCUMENTED" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="IETL_JCD_TOL" KIND="REAL" LEVEL="UNDOCUMENTED" />

:kword:`donotdelete`
  Set :kword:`donotdelete=1` to restart DMRGSCF optimization from an existing QCMaquis MPS checkpoint. Useful e.g. to restart crashed calculations.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="DONOTDELETE" KIND="INT" LEVEL="BASIC">
              %%Keyword: donotdelete <basic>
              <HELP>
              Restart DMRGSCF optimization from an existing QCMaquis checkpoint.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

OOptimizationSettings input section
...................................

The Orbital OptimizationSettings block contains general, non DMRG-specific options required for the MPS wave function optimisation
(such as number of the active electrons, active orbital specification etc.), i.e., a normal input for a CASSCF or a CASCI
calculation with the :program:`RASSCF` module. Most of the RASSCF keywords listed in the keyword section of :numref:`UG:sec:rasscf` are accepted,
with the exception of keywords relating to explicit CI wave function quantities.
Please consult the :program:`RASSCF` module description for further details on the input.
In addition to the standard :program:`RASSCF` keywords, several optional keywords are available within :program:`DMRGSCF`
are listed below. The start and end of the OptimizationSettings input section is given by ::

  OOptimizationSettings
  ...
  EndOOptimizationSettings

.. class:: keywordlist

:kword:`FCIDUMP`
  Skip the wave function optimization and write out the transformed active MO integrals to a :file:`FCIDUMP` file in :file:`$WorkDir` which can be used in subsequent **QCMaquis** DMRG calculations.

  .. xmldoc:: <GROUP MODULE="DMRGSCF" NAME="OOPTIMIZATIONSETTINGS" APPEAR="Orbital optimization settings" KIND="BLOCK" LEVEL="BASIC">

  .. xmldoc:: <INCLUDE MODULE="RASSCF" EXCEPT="VB" />

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="FCIDUMP" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: fcidump <basic>
              <HELP>
              Dump integrals on file FCIDUMP.
              </HELP>
              </KEYWORD>

:kword:`SOCCupy`
  Initial electronic configuration for the calculated state(s). This keyword is equivalent to the :kword:`hf_occ` card in the **QCMaquis** input (see Table 8 of the QCMaquis_ manual), but allows input for multiple states. The occupation is inserted as a string (strings) of aliases of occupations of the active (RAS2) orbitals with the aliases ``2`` = full, ``u`` = up, ``d`` = down, ``0`` = empty. For several states, the occupation strings for each state are separated by newlines.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="SOCCUPY" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: soccupy <basic>
              <HELP>
              Set HF determinant start guess for MPS wave functions.
              </HELP>
              </KEYWORD>

:kword:`NEVPT2prep`
  Prepare for a subsequent DMRG-NEVPT2 or CASPT2 calculation. Then the four- and transition three-particle density matrices (4- and t-3RDMs), required for the MRPT2 calculations, will be evaluated and stored on disk in :file:`$WorkDir`. **QCMaquis** input files for the 4- and t-3RDMs evaluation are prepared and the RDM evaluation may be performed externally or directly in the :program:`NEVPT2` program. More about external RDM evaluation in Section 6.3 of the QCMaquis_ manual.
  If this keyword is used with :kword:`ITER=0,0` keyword, the DMRG-SCF/DMRG-CI calculation is skipped and only **QCMaquis** input files for the 4- and t-3RDMs evaluation are prepared. This is useful for a NEVPT2 calculation for an already converged DMRG-CI/DMRG-SCF calculation.

  .. xmldoc:: <KEYWORD MODULE="DMRGSCF" NAME="NEVPT2PREP" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NEVPT2prep <basic>
              <HELP>
              Prepare input for higher-order RDM/TDM evaluation.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Runtime options
---------------

**QCMaquis** is built by default with a shared-memory OMP parallelization. To speed up calculations the user can thus set at runtime the environment variable :variable:`QCMaquis_CPUS` or :variable:`OMP_NUM_THREADS` to the number of shared-memory cores to be used. Example: ::

  >>> EXPORT QCMaquis_CPUS=16

The default is to use a single core.

Input files
-----------

:program:`DMRGSCF` will use (in analogy to :program:`RASSCF`) the following input
files: :file:`ONEINT`, :file:`ORDINT`, :file:`RUNFILE`, :file:`INPORB`,
:file:`JOBIPH`
(for more information see :numref:`UG:sec:files_list`). We strongly recommend to use the HDF5 files
(:file:`$Project.ProgramName.h5`) produced by the wave
function modules in |molcas| as orbital input files, see the keyword :kword:`FILEORB` in the :program:`RASSCF` input,
:numref:`UG:sec:rasscf` for further details.

A number of additional files generated by :program:`SEWARD` are also used by the
:program:`DMRGSCF` program.
The availability of either of the files named :file:`INPORB` and
:file:`JOBOLD` is optional and determined by the input options
:kword:`LUMORB` and :kword:`JOBIPH`, respectively.

.. _UG\:sec\:dmrgscf_output_files:

Output files
------------

.. class:: filelist

:file:`JOBIPH`
  This file is written in binary format and carries the results
  of the wave function optimization such as MO- and CI-coefficients.
  If several consecutive RASSCF calculations are made, the file names will
  be modified by appending "01","02", etc.

:file:`RUNFILE`
  The :file:`RUNFILE` is updated with information from the RASSCF calculation
  such as the first order density and the Fock matrix.

:file:`MD_CAS.x`
  Molden input file for molecular orbital analysis for MPS state x.

:file:`RASORB`
  This ASCII file contains molecular orbitals, occupation numbers, and
  orbital indices from a :program:`DMRGSCF` calculation. The natural orbitals
  of individual states in an average-state calculation are also produced,
  and are named :file:`RASORB.1`, :file:`RASORB.2`, etc.

:file:`MCDENS`
  This ASCII file is generated for MC-PDFT calculations.
  It contains spin densities, total density and on-top pair density values on grid (coordinates in a.u.).

:file:`dmrgscf.h5`
  This .h5 file contains contains molecular orbitals, occupation numbers, and
  orbital indices from a :program:`DMRGSCF` calculation. In addition, it stores the names of the **QCMaquis** output files.

:file:`checkpoint_state.x.h5`
  Directory containing the MPS for state x.

:file:`results_state.x.h5`
  File containing the MPS optimization information and property data calculated for state x.

Input example
-------------

The following example shows the input to the
:program:`DMRGSCF` program for a calculation on the nitrogen molecule. The calculation is
performed in :math:`D_{2h}` symmetry. The :kword:`max_bond_dimension` is set to 100, which is sufficient
for a small CAS(6,6) problem. ::

  &GATEWAY
   coord
   2
  Angstrom
   N       0.000000  0.000000  -0.54880
   N       0.000000  0.000000   0.54880
   basis=cc-pvdz
  &SEWARD
  &SCF
  &DMRGSCF
  ActiveSpaceOptimizer=QCMaquis
  DMRGSettings
    conv_thresh        = 1e-4
    truncation_final   = 1e-5
    ietl_jcd_tol       = 1e-6
    nsweeps            = 4
    max_bond_dimension = 100
  EndDMRGSettings
  OOptimizationSettings
    inactive = 2 0 0 0 2 0 0 0
    RAS2     = 1 1 1 0 1 1 1 0
    ITER     = 15,100
    SOCC     = 2,2,2,0,0,0
    LINEAR
  EndOOptimizationSettings

.. xmldoc:: </MODULE>
.. index::
   single: Program; NEVPT2
   single: NEVPT2

.. _UG\:sec\:nevpt2:

:program:`nevpt2`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="NEVPT2">
            %%Description:
            <HELP>
            The NEVPT2 program computes the dynamic correlation correction to a DMRG-SCF energy
            according to the NEVPT2 theory developed originally by Angeli et al.
            Currently, NEVPT2 requires a DMRG reference wavefunction calculated with QCMaquis (with RASSCF or DMRGSCF module).
            </HELP>

NEVPT2 is a second-order perturbation theory with a CAS (or a CAS-like) reference wavefunction originally developed by Angeli et al. :cite:`Angeli_JChemPhys_Introduction_2001,Angeli_ChemPhysLett_Nelectron_2001,Angeli_JChemPhys_nelectron_2002,Angeli_JChemPhys_quasidegenerate_2004` In contrast to CASPT2, it uses a Dyall Hamiltonian :cite:`Dyall_JChemPhys_choice_1995` as the zeroth-order Hamiltonian and is therefore inherently free of intruder states and parameters such as the IPEA shift. NEVPT2 exists in two formulations -- the strongly- (SC-) and the partially-contracted NEVPT2 (PC-NEVPT2), which differ in the basis of the first-order wavefunction expansion.

The implementation in the :program:`NEVPT2` program is based on the original NEVPT2 implementation by Angeli et al. :cite:`Angeli_JChemPhys_nelectron_2002,Angeli_JChemPhys_quasidegenerate_2004`, with the implementation of the QCMaquis DMRG reference wave function and Cholesky decomposition for the two-electron integrals :cite:`Freitag_JChemTheoryComput_Multireference_2017`. For excited states both single-state and multi-state calculations with the QD-NEVPT2 approach :cite:`Angeli_JChemPhys_quasidegenerate_2004` are supported.

.. _UG\:sec\:nevpt2_dependencies:

Dependencies
------------
The :program:`NEVPT2` program needs the :file:`JOBIPH` file (or its HDF5 equivalent) with a reference wavefunction a from a :program:`RASSCF`/:program:`DMRGSCF` calculation. Currently, **only DMRG reference wavefunctions calculated with QCMaquis** are supported. Additionally, transformed MO integrals or Cholesky vectors from :program:`MOTRA` are required.

Optionally, four-particle reduced density matrices (and transition three-particle reduced density matrices for QD-NEVPT2 calculations) can be precalculated with QCMaquis in a massively parallel fashion and stored on disk. These QCMaquis calculations may be prepared and executed with the help of two scripts found in :file:`$MOLCAS/Tools/distributed-4rdm` directory, namely :file:`jobmanager.py` and :file:`prepare_rdm_template.sh`. The distributed RDM evaluation is strongly recommended for active spaces larger than 10-11 orbitals and is described in detail in :numref:`TUT:sec:nevpt2_distrdm`.

.. _UG\:sec\:nevpt2_input_files:

Input files
------------

.. class:: filelist

:file:`JobIph` or :file:`dmrgscf.h5`
  File containing information about the reference wavefunction.

:file:`ijkl.h5`
  Transformed integrals or Cholesky vectors, calculated by the :program:`MOTRA` program.

.. _UG\:sec\:nevpt2_output_files:

Output files
------------

.. class:: filelist

:file:`nevpt2.h5`
  File in HDF5 format, similar to RASSCF/DMRGSCF `dmrgscf.h5` files, containing the effective Hamiltonian for QD-NEVPT2 calculations (both strongly- and partially-contracted).

.. _UG\:sec\:nevpt2_input:

NEVPT2 input
------------

The :program:`NEVPT2` program is activated by ::

  &NEVPT2

The optional keywords supported by :program:`NEVPT2` are listed below.

.. class:: keywordlist

:kword:`STATES`
  Number of electronic states to calculate. Default: 1

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="STATES" KIND="INT" LEVEL="BASIC">
              %%Keyword: STATES <basic>
              <HELP>
              Number of states to calculate. Default: 1
              </HELP>
              </KEYWORD>

:kword:`NOMS`
  Omit the QD-NEVPT2 calculation and perform single-state NEVPT2 calculations instead.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="NOMS" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOMS <basic>
              <HELP>
              Omit the (multi-state) QD-NEVPT2 calculation for multiple states.
              </HELP>
              </KEYWORD>

:kword:`MULT`
  Select specific states to perform QD-NEVPT2 calculation. Followed by a list of whitespace-separated state numbers, preceded by their total amount. Example: ``MULT=3 1 2 4`` for states 1, 2, 4 of a preceeding DMRG-SCF calculation of 4 roots (or more). ``MULT=ALL`` includes all states and is the default.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="MULT" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: MULT <basic>
              <HELP>
              Select states for (multi-state) QD-NEVPT2 calculation.
              </HELP>
              </KEYWORD>

:kword:`FILE`
  Specify the path to a :file:`JobIph` or :file:`.h5` file with the reference wavefunction. By default, the reference wavefunction is read from :file:`JOBIPH`.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="FILE" KIND="STRING" LEVEL="BASIC">
              %%Keyword: FILE <basic>
              <HELP>
              Select JobIph or file with the reference wavefunction.
              </HELP>
              </KEYWORD>

:kword:`FROZEN`
  Specify the number of frozen orbitals. The number of frozen orbitals may be specified in two ways: if only one number :math:`n` is specified, then all orbitals from 1 to :math:`n` are frozen. Otherwise, it is possible to freeze specific orbitals with the :kword:`SELECT` keyword which follows the :kword:`FROZEN` keyword. In this case, the total number of frozen orbitals followed by the space-separated list of frozen orbitals must be entered. Note that if symmetry is used, the orbital numbering for all symmetries is still consecutive, e.g. the 1st orbital of symmetry 2 is has the number :math:`m+1` if there are :math:`m` orbitals in symmetry 1.

  If frozen orbitals are specified in :program:`MOTRA` input, they will be autodetected in :program:`NEVPT2` and there is no need to input them separately, so that this keyword is not needed.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="FROZEN" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: FROZEN <basic>
              <HELP>
              Select frozen orbitals.
              </HELP>
              </KEYWORD>

:kword:`NOPC`
  Disable the PC-NEVPT2 calculation. If the option is not present (default), both SC-NEVPT2 and PC-NEVPT2 calculations are performed.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="NOPC" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOPC <basic>
              <HELP>
              Omit the partially-contracted NEVPT2 calculation.
              </HELP>
              </KEYWORD>

:kword:`SKIPK`
  Skip the calculation of Koopmans' matrices. Requires a file named :file:`nevpt.h5` obtained from a previous calculation in the scratch directory. May be useful to restart a previous crashed calculation if it crashed past the calculation of Koopmans' matrices, and may save some computational time, especially for large active spaces.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="SKIPK" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: SKIPK <basic>
              <HELP>
              Skip calculation of Koopmans' matrices and use them from a previous NEVPT2 calculation.
              </HELP>
              </KEYWORD>

:kword:`RDMRead`
  Do not calculate the 4-RDM, but rather read it from QCMaquis result files :file:`$Project.results_state.X.h5` for state ``X``. Useful if the previous calculation crashed but the 4-RDM evaluation step has succeeded. Do NOT use it if you are using the distributed 4-RDM calculation.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="RDMRead" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: RDMRead <basic>
              <HELP>
              Read previously calculated 4-RDMs from QCMaquis result files instead of calculating it.
              </HELP>
              </KEYWORD>

:kword:`DISTributedRDM`
  Enable reading of the RDMs calculated with the distributed RDM evaluation script. This keyword should be followed by another line, which specifies the path to the folder with the calculation results. The 4-RDM will then be read from QCMaquis HDF5 files found in :file:`<path>/4rdm-scratch.<state>/parts/part-*/$Project.results_state.<state>.h5`. The distributed :math:`n`-RDM evaluation is described in the NEVPT2 program-based tutorial. If the tutorial is followed, the path should be :file:`$WorkDir`.

  .. xmldoc:: <KEYWORD MODULE="NEVPT2" NAME="DistributedRDM" KIND="STRING" LEVEL="BASIC">
              %%Keyword: DistributedRDM <basic>
              <HELP>
              Read RDMs calculated in a distributed fashion.
              </HELP>
              </KEYWORD>

.. _UG\:sec\:nevpt2_inputexample:

Input example
-------------

An input example for NEVPT2 may be found in :numref:`TUT:sec:nevpt2_run`.

.. xmldoc:: </MODULE>
.. index::
   single: Program; CHT3
   single: CHT3

.. _sec\:cht3:

:program:`cht3`
===============

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="CHT3">
            %%Description:
            <HELP>
            CHT3 is a Closed-Shell Coupled-Clusters perturbative triples
            program based exclusively on the Cholesky (or RI) decomposed 2-electron integrals
            aimed towards calculation of large systems on highly parallel architectures. Use of
            point-group symmetry is not implemented.
            It requires RUNFILE from the SCF module, T1 and T2 excitation amplitudes and MO
            transformed Cholesky/RI vectors from CHCC.
            </HELP>

:program:`CHT3` is a Closed-Shell Coupled-Clusters perturbative triples
program based exclusively on the Cholesky (or RI) decomposed 2-electron integrals
aimed towards calculation of large systems on highly parallel architectures. Use of
point-group symmetry is not implemented. Main advantage compared to the
:program:`CCSDT` module is |molcas| is in its more efficient parallelization and
dramatically lowered memory (and eventually disk) requirements.

.. For further details the reader is referred to :numref:`TUT:sec:cht3`.

.. index::
   pair: Dependencies; CHT3

.. _sec\:cht3_dependencies:

Dependencies
------------

:program:`CHT3` requires previous run of the :program:`CHCC` Cholesky/RI
based CCSD program to produce T1 and T2 excitation amplitudes stored in :file:`T2xxxx`
and :file:`RstFil` files.
The :program:`CHCC` program (as well as :program:`SEWARD` and :program:`SCF`) must be run
in Cholesky/RI mode.

The algorithm used for almost complete elimination of the :program:`CHT3`
limits in calculated system size due to the computer memory bottleneck relies
on blocking of the virtual orbitals. Size of blocks is, unlike in :program:`CHCC` program, determined automatically for optimal performance.

.. index::
   pair: Files; CHT3

.. _sec\:cht3_files:

Files
-----

Input files
...........

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information.

:file:`L0xxxx`, :file:`L1xxxx`, :file:`L2xxxx`
  MO-transformed Cholesky vectors

:file:`T2xxxx`
  T2 :math:`(ij,a'b')` excitation amplitudes

:file:`RstFil`
  Communication file containing T1 amplitudes, restart informations, etc.

Intermediate files
..................

All the intermediate files are created, used and removed
automatically, unless you yourself create a link or a file
with the specified name.

.. class:: filelist

:file:`KMATAA`, :file:`KMATBA`, :file:`LMATAA`, :file:`LMATBA`
  Temporary integral files

Output files
............

None

.. index::
   pair: Input; CHT3

.. _sec\:cht3_input:

Input
-----

The input for each module is preceded by its name like: ::

  &CHT3

.. class:: keywordlist

:kword:`TITLe`
  This keyword starts the reading of title lines,
  with the number of title lines limited to 10.
  Reading the input as title lines is stopped as soon
  as the input parser detects one of the other keywords,
  however only ten lines will be accepted.
  This keyword is *optional*.

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="TITLE" APPEAR="Title" KIND="CUSTOM" LEVEL="BASIC">
              %%Keyword: TITLe <basic>
              <HELP>
              Enter up to ten title lines. Do not put any keyword in the beginning of a title line.
              </HELP>
              </KEYWORD>

:kword:`FROZen`
  Integer on the following line specifies number of inactive occupied
  orbitals in the (T) calculation. This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="FROZ" APPEAR="Frozen orbitals" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="0">
              %%Keyword: FROZen <basic>
              <HELP>
              Specifies number of inactive occupied orbitals in the (T) procedure
              </HELP>
              </KEYWORD>

:kword:`DELEted`
  Integer on the following line specifies number of inactive virtual
  orbitals in the (T) calculation. This keyword is *optional*. (Default=0)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="DELE" APPEAR="Deleted orbitals" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" DEFAULT_VALUE="0">
              %%Keyword: DELEted <basic>
              <HELP>
              Specifies number of inactive virtual orbitals in the (T) procedure
              </HELP>
              </KEYWORD>

:kword:`LARGe`
  Integer on the following line specifies the main segmentation of the virtual orbitals
  used in previous CCSD run.

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="LARG" APPEAR="Large segmentation" KIND="INT" LEVEL="BASIC" MIN_VALUE="1" MAX_VALUE="32" DEFAULT_VALUE="1">
              %%Keyword: LARGe <basic>
              <HELP>
              Specifies the segmentation of virtual orbitals
              </HELP>
              </KEYWORD>

:kword:`MHKEy`
  Integer on the following line specifies if library BLAS (MHKEy=1) or hard-coded
  fortran vector-vector, matrix-vector and matrix-matrix manipulation is used.
  This keyword is *optional*. (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="MHKE" APPEAR="Use BLAS" KIND="INT" LEVEL="BASIC" MIN_VALUE="0" MAX_VALUE="1" DEFAULT_VALUE="1">
              %%Keyword: MHKEy <basic>
              <HELP>
              Specifies if BLAS libraries (=1) or hard-code fortran is used.
              </HELP>
              </KEYWORD>

:kword:`NOGEnerate`
  This keyword specifies that the pre-(T) steps (generation of integrals from
  the Cholesky/RI vectors, etc.) are skipped. This keyword can be used for
  restarting the (T) calculation if the required integrals were already generated.
  This keyword is *optional*. (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="NOGE" APPEAR="Skip pre-(T) steps" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOGEnerate <basic>
              <HELP>
              Pre-(T) steps, like integrals generation, etc. are skipped.
              </HELP>
              </KEYWORD>

:kword:`NOTRiples`
  This keyword specifies that the post integral preparation steps, i.e.
  the real calculation of (T) contribution will not be done. Job can be restarted
  from this point using the :kword:`NOGEnerate` keyword.
  This keyword is *optional*. (Default=OFF)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="NOTR" APPEAR="No triples" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NOTRiples <basic>
              <HELP>
              Program stops after generation of temporary integral files
              </HELP>
              </KEYWORD>

:kword:`ALOOp`
  Two integers on the following line specify first and last triplet of
  virtual orbitals blocks to be calculated in the first ("A loop") of
  the two parts of the (T) calculation. Using this keyword enables user
  to split the (T) calculation into separate jobs. Information about
  the total number of triplets in the "A loop" can be found in the
  output of the "preparation" step of the (T) program. Values
  -1, -1 mean, that the whole "A loop" is either executed or skipped,
  depending on the parameters of the BLOOp keyword.
  This keyword is *optional*. (Default=-1,-1)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="ALOO" APPEAR="A loop" KIND="INTS" SIZE="2" LEVEL="BASIC" MIN_VALUE="-1" DEFAULT_VALUE="-1">
              %%Keyword: ALOOp <basic>
              <HELP>
              Specifies the range of triplets of virtual orbitals blocks from
              the fist of two parts of (T) program to be calculated.
              </HELP>
              </KEYWORD>

:kword:`BLOOp`
  Two integers on the following line specify first and last triplet of
  virtual orbital block to be calculated in the second ("B loop") of
  two parts of the (T) calculation. Using this keyword enables user
  to split the (T) calculation into separate jobs. Information about
  the total number of triplets in the "B loop" can be found in the
  output of the "preparation" step of the (T) program. Values
  -1, -1 mean, that the whole "B loop" is either executed or skipped,
  depending on the values of the ALOOp keyword.
  This keyword is *optional*. (Default=-1,-1)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="BLOO" APPEAR="B loop" KIND="INTS" SIZE="2" LEVEL="BASIC" MIN_VALUE="-1" DEFAULT_VALUE="-1">
              %%Keyword: BLOOp <basic>
              <HELP>
              Specifies the range of triplets of virtual orbitals blocks from
              the second of two parts of (T) program to be calculated.
              </HELP>
              </KEYWORD>

:kword:`PRINtkey`
  The integer on the following line specifies the print level in output

  .. container:: list

    1  --- Minimal

    2  --- Minimal + timings of each (T) step

    10 --- Debug

  This keyword is *optional*. (Default=1)

  .. xmldoc:: <KEYWORD MODULE="CHT3" NAME="PRIN" APPEAR="Print level" KIND="CHOICE" LIST="1: Minimal,2: Minimal + timings,10: Debug" LEVEL="ADVANCED" DEFAULT_VALUE="1">
              <HELP>
              Choose the print level
              </HELP>
              </KEYWORD>
              %%Keyword: PRINtkey <advanced>
              Sets the print level

              1  -- Minimal
              2  -- Minimal + timings
              10 -- Debug

::

  &CHT3
  Title  = Benzene dimer
  Frozen = 12
  Large  = 4
  ALOOp  = 20 120
  BLoop  = 1 250
  Print  = 2

.. xmldoc:: </MODULE>
.. _UG\:sec\:false:

:program:`false`
================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="FALSE">
            %%Description:
            <HELP>
            FALSE is an interface module that allows using external programs to
            compute energies and gradients for geometry optimizations with SLAPAF.
            </HELP>

:program:`FALSE` is an interface module that allows using external programs to
compute energies and gradients for geometry optimizations with
:program:`SLAPAF`. :program:`FALSE` creates a text file with the current
Cartesian coordinates, launches an external program (specified by the
:kword:`RUN` keyword), and then reads an output text file and stores the
information in the :file:`RUNFILE` for :program:`SLAPAF` to use. In a parallel
environment, only the master process executes the external program (which can
run on a different parallel environment).

Note that, even though the external program most likely does not use the
integrals produced by :program:`SEWARD`, :program:`SEWARD` will still need to
be run for every new geometry before :program:`FALSE` to update the
coordinates. It can, however, use a dummy basis set and/or the :kword:`ONEOnly`
keyword.

:program:`FALSE` can also be run in "add" mode, where the results from the
external program are added to the existing values, instead of replacing them
(see the :kword:`MODE` keyword). In this case, :program:`FALSE` should be
called after all desired energies and gradients have been calculated with some
other method.

.. _UG\:sec\:false_files:

Files
-----

.. class:: filelist

:file:`$Project.false.in`
  This file is generated by :program:`FALSE`, and contains
  the current Cartesian coordinates of the system.

:file:`$Project.false.out`
  This file should be generated by the external program,
  and contain the energy and possibly gradient and other properties.

.. _UG\:sec\:false_inp:

Input
-----

.. class:: keywordlist

:kword:`RUN`
  This is the only and compulsory keyword of the program.
  It specifies the executable to run the external program.
  The external program will be run as ``<program> <input> <output>``, where ``<program>``
  is the value of this keyword, and ``<input>`` and ``<output>`` are, respectively,
  :file:`$Project.false.in` and :file:`$Project.false.out`.

  .. xmldoc:: <KEYWORD MODULE="FALSE" NAME="RUN" APPEAR="External executable" KIND="STRING" INPUT="REQUIRED" LEVEL="BASIC">
              %%Keyword: RUN <basic>
              <HELP>
              Specify the external executable.
              It will be run as:

                program input output
              </HELP>
              </KEYWORD>

:kword:`MODE`
  Specifies whether the values computed by the external program will replace any
  pre-existing values (`REPLACE`, which is the default), or they will be added as
  a new contribution (`ADD`). If set to `ADD`, and the output from the external
  program contains values for a single root, the values will be added to all
  roots.

  .. xmldoc:: <KEYWORD MODULE="FALSE" NAME="MODE" APPEAR="Mode" KIND="CHOICE" LIST="REPLACE,ADD" DEFAULT_VALUE="REPLACE" LEVEL="BASIC">
              %%Keyword: MODE <basic>
              <HELP>
              Set to REPLACE (default) to use the bare external program results.
              Set to ADD to add the external program results as a contribution.
              </HELP>
              </KEYWORD>

.. _UG\:sec\:false_format:

Format
------

The format of the :file:`$Project.false.in` file is simply the header ``[XYZ]``
followed by the Cartesian coordinates in xyz format (number of atoms, comment
line, atomic symbols and coordinates in ångström). Example: ::

  [XYZ]
       3
  angstrom
   O      -0.000000000000      0.000000000000      1.585980150915
   H      -1.441800130217      0.000000000000     -1.265660575457
   H       1.441800130217      0.000000000000     -1.265660575457

The expected format for the :file:`$Project.false.out` has sections marked by
bracketed headers (case-insensitive), and all values are in atomic units.
Unknown sections are ignored.

* ``[ROOTS]`` is compulsory, followed by the number of roots for which energies
  and other properties will be given later. If :kword:`MODE` is `ADD`, it should
  match the number of roots already existing, or be `1` (in which case the
  external contribution will be added to all roots).

* ``[RELAX ROOT]`` is optional, followed by the index of the root that will
  be optimized. If not given, the highest root will be assumed. If given, it must
  appear before other properties.

* ``[ENERGIES]`` is compulsory, followed by the energies of the specified roots
  in free format.

* ``[GRADIENT]`` is optional, followed by a root index and the Cartesian gradient
  of that root, in the order :math:`x`, :math:`y`, :math:`z` components of first
  atom, :math:`x`, :math:`y`, :math:`z` of second atom, etc. Numbers are in free
  format. This section can appear several times for different roots. If not present
  for the root to be optimized, numerical gradients will be computed.

* ``[NAC]`` is optional, followed by two root indices and the Cartesian nonadiabatic
  coupling vector for those two roots, in the same order as the gradient. Numbers
  are in free format. This section can appear several times for different root pairs.

* ``[HESSIAN]`` is optional, followed by a root index and the lower triangle of the
  Cartesian Hessian of that root, in row order (same component order as the gradient).
  Numbers are in free format. This section can appear several times for different roots.

* ``[DIPOLES]`` is optional, followed by the dipole moments (:math:`x`, :math:`y`,
  :math:`z` components) of the specified roots. The numbers are in free format,
  but the dipole for each root must start on a new line.

Example: ::

  [ROOTS]
  1

  [ENERGIES]
  -0.00023387481687211915

  [GRADIENT]
  1
  0.0 0.0 1.305627486117155e-06
  4.46416708565692e-07 0.0 -6.528137430585775e-07
  -4.46416708565692e-07 0.0 -6.528137430585775e-07

.. xmldoc:: </MODULE>
.. _UG\:sec\:dimerpert:

:program:`dimerpert` |extramark|
================================

.. warning::

   This program is not available in |openmolcas|

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: %%Description:
            This module is still undocumented

This module is still undocumented
.. index::
   single: Program; SLAPAF
   single: SLAPAF

.. _UG\:sec\:slapaf:

:program:`SlapAf`
=================

.. only:: html

  .. contents::
     :local:
     :backlinks: none

.. xmldoc:: <MODULE NAME="SLAPAF">
            %%Description:
            <HELP>
            This program is a general purpose facility for geometry
            optimization. At present, it is tailored to use analytical gradients
            produced by ALASKA.
            SLAPAF also computes an approximate Hessian.
            </HELP>

Provided with the first order derivative with respect to nuclear displacements
the program is capable to optimize molecular structures with or
without constraints for minima or
transition states. This will be achieved with a quasi-Newton approach
in combination with 2nd ranks updates of the approximate Hessian or
with the use of a computed (analytic or numerical) Hessian.
Note that *if* a computed Hessian is available on the
:file:`RUNFILE` then it will be used rather than the approximate Hessian generated by :program:`Slapaf`.
On completion of an optimization :program:`SlapAf` will automatically execute a single energy evaluation,
this can be disabled with the :kword:`NOLAst` keyword.

.. _UG\:sec\:slapaf_description:

Description
-----------

:program:`SlapAf` has three different ways in selecting the
basis for the displacements during the optimization.
The first format require user input (not recommended), whereas the two other options are totally black-boxed.
The formats are:

#. the old format as in |molcasiii|, which is user specified.
   The internal coordinates
   are here represented as linear combination of internal coordinates
   (such as bonds, angles, torsions, out of plane angles, Cartesian coordinates
   and separation of centers of mass) and the linear combinations are totally defined
   by user input.
   This format does also require the user to specify the
   Hessian (default a diagonal matrix).
   This option *allows* for frozen internal coordinates.

#. the second format is an automatic
   option which employs the Cartesian eigenvectors of the approximative Hessian (generated by the
   Hessian model functional :cite:`HMF`).

#. the third format (this is the recommend and default) is an automatic option which utilizes linear combinations
   of some curvilinear coordinates (stretches, bends, and torsions).
   This implementation
   has two variations. The first can be viewed as the conventional use of
   non-redundant internal coordinates :cite:`nric1,nric2,nric3`.
   The second variation is a force constant weighted (FCW)
   redundant space (the HWRS option) version of the former
   implementation :cite:`Lindh:97`.

All three formats of internal coordinates can be used in combinations with
constraints on the molecular parameters or other type of constraints as for
example energy differences.

The displacements are symmetry adapted
and any rotation and translation if present is deleted.
The relaxation is symmetry preserving.

.. _UG\:sec\:slapaf_dependencies:

Dependencies
------------

:program:`SlapAf` depends on the results of :program:`ALASKA` and also possibly
on :program:`MCKINLEY` and :program:`MCLR`.

.. _UG\:sec\:slapaf_files:

Files
-----

Input files
...........

Apart from the standard input file :program:`SlapAf` will use the following input
files.

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information. If a computed Hessian is available on this file it will be used rather than
  the approximate Hessian generated by :program:`Slapaf`.

:file:`RUNFILE2`
  File for communication of auxiliary information of the "ground state" in case of minimum energy cross point optimizations.

:file:`RUNOLD`
  File for communication of auxiliary information for reading an old Hessian matrix from a previous geometry optimization.

Output files
............

In addition to the standard output file :program:`SlapAf` will use the following output
files.

.. class:: filelist

:file:`RUNFILE`
  File for communication of auxiliary information.

:file:`RUNFILE2`
  File for communication of auxiliary information of the "ground state" in case of minimum energy cross point optimizations.

:file:`MD_GEO`
  Molden input file for geometry optimization analysis.

:file:`MD_MEP`
  Molden input file for minimum energy path (MEP).

:file:`MD_SADDLE`
  Molden input file for energy path (MEP) of a Saddle TS optimization.

:file:`MD_IRC`
  Molden input file for intrinsic reaction coordinate analysis of a TS.

:file:`MD_FREQ`
  Molden input file for harmonic frequency analysis.

:file:`UNSYM`
  ASCII file where all essential information, like geometry, Hessian normal modes and dipole
  derivatives are stored.

:file:`STRUCTURE`
  Output file with a statistics of geometry optimization convergence.

.. _UG\:sec\:slapaf_input:

Input
-----

:program:`SlapAf` will as standard
provided with an energy and a corresponding gradient
update the geometry (optimize).
Possible update methods include different quasi-Newton methods.
The program will also provide for updates of the Hessian.
The program has a number of different variable metric methods available for
the Hessian update.
This section describes the input to the :program:`SlapAf` program.

This section describes the input to the
:program:`SLAPAF` program in the |molcas| program system. The input starts
with the program name ::

  &SLAPAF

There are no compulsory keywords

Optional convergence control keywords

.. class:: keywordlist

:kword:`ITERations`
  Maximum number of iterations which
  will be allowed in the relaxation procedure. Default is 500
  iterations, however, if environment variable :variable:`MOLCAS_MAXITER` has been exported by the user
  this is the assumed default value.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="ITERATIONS" APPEAR="Max iterations" KIND="INT" MIN_VALUE="0" DEFAULT_VALUE="500" LEVEL="BASIC">
              %%Keyword: Iterations <basic>
              <HELP>
              Specify the max number of iterations which
              will be allowed in the relaxation procedure. Default is 500
              iterations however, if MOLCAS_MAXITER has been exported by the user
              this is the assumed default value.
              </HELP>
              </KEYWORD>

:kword:`THRShld`
  Enter two real numbers which specifies the convergence criterion with respect to the
  energy change and the norm of the gradient. The defaults are
  0.0 and 3.0D-4 au for Gaussian convergence criteria
  (which normally do not consider the energy change), and
  1.0D-6 and 3.0D-4 for Baker criteria (see the :kword:`BAKER` keyword).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="THRSHLD" APPEAR="Convergence threshold" KIND="REALS" SIZE="2" MIN_VALUE="0.0" DEFAULT_VALUES="0.0,3.0D-4" LEVEL="ADVANCED">
              %%Keyword: Thrshld <advanced>
              <HELP>
              Enter two real numbers
              which specifies the convergence criterion with respect to the
              energy change and the norm of the gradient.
              </HELP>
              The defaults are 0.0 and 3.0D-4 for Gaussian, and 1.0D-6 and 3.0D-4 for Baker.
              </KEYWORD>

:kword:`BAKEr`
  Activate convergence criteria according to Baker :cite:`Baker`.
  Default is to use the convergence criteria as in the Gaussian
  program :cite:`GAUSSIAN94`.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="BAKER" APPEAR="Baker style convergence criteria" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Baker <advanced>
              <HELP>
              Activate convergence criteria according to Baker.
              Default is to use the convergence criteria as in the Gaussian
              program.
              </HELP>
              </KEYWORD>

:kword:`MAXStep`
  This keyword is followed by the value which defines the seed of largest
  change of the internal coordinates which will be accepted. A
  change which is larger is reduced to the max value. The value is dynamically modified each iterations.
  The default value is 0.3 au or rad.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MAXSTEP" APPEAR="Max step" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="0.3" LEVEL="BASIC">
              %%Keyword: Maxstep <basic>
              <HELP>
              Enter the value which defines the seed of largest
              change of the internal coordinates which will be accepted. A
              change which is larger is reduced to the max value. The value is dynamically modified each iterations.
              </HELP>
              The default
              value is 0.3 au or rad.
              </KEYWORD>

:kword:`CNWEight`
  Sets the maximum weight assigned to the fulfillment of the constraints, relative to the step taken in the
  complementary space for energy minimization. The step in the constraint space is truncated to be at most as
  large as the step in the minimization space, or half the maximum total step, whichever is larger, multiplied
  by this value. Default is 1.0.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="CNWEIGHT" APPEAR="Max constraint weight" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0" LEVEL="BASIC">
              %%Keyword: CnWeight <basic>
              <HELP>
              Sets the maximum weight assigned to the fulfillment of
              the constraints, relative to the step taken in the
              complementary space for energy minimization.
              </HELP>
              </KEYWORD>

:kword:`TOLErance`
  Controls how strictly the constraints (if any) must be satisfied at convergence. The default value
  is very large, such that this criterion is always met, and only the gradient and maximum step (or
  energy difference) control convergence. If you set this keyword to some value, a constrained optimization
  will only converge if the maximum error in any constraint is lower than this number (in atomic units,
  and radians).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="TOLE" APPEAR="Constraint tolerance" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="1.0D10" LEVEL="BASIC">
              %%Keyword: Tolerance <basic>
              <HELP>
              Controls how strictly the constraints must be satisfied at convergence.
              </HELP>
              </KEYWORD>

Optional coordinate selection keywords

.. class:: keywordlist

:kword:`CARTesian`
  Activate :program:`SlapAf` to use the eigenvectors
  of the approximative Hessian expressed in Cartesian as the
  definition of the internal coordinates. The default is to
  use the FCW non-redundant internal coordinates.
  The Hessian will be modeled by the Hessian Model Functional.

  .. xmldoc:: <GROUP MODULE="SLAPAF" KIND="BOX" NAME="IC" APPEAR="Internal coordinate selection" LEVEL="ADVANCED">

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="CARTESIAN" APPEAR="Cartesian internal coordinates" KIND="SINGLE" EXCLUSIVE="HWRS,NOHWRS,INTERNAL" LEVEL="ADVANCED">
              %%Keyword: Cartesian <advanced>
              <HELP>
              Activate SlapAf to use the eigenvectors
              of the approximative Hessian expressed in Cartesian as the
              definition of the internal coordinates. The default is to
              use the FCW non-redundant internal coordinates.
              The Hessian will be modeled by the Hessian Model Functional.
              </HELP>
              </KEYWORD>

:kword:`INTErnal`
  This marks the start of the definition of the internal
  coordinates. This section is always ended by the keyword
  :kword:`End of Internal`.
  For a complete description of this
  keyword see
  :numref:`UG:sec:definition_of_internal_coordinates`.
  This option will also use a diagonal matrix as default for
  the Hessian matrix.
  The default is to
  use the FCW non-redundant internal coordinates.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="INTERNAL" APPEAR="User-defined internal coordinates" KIND="CUSTOM" EXCLUSIVE="HWRS,NOHWRS,CARTESIAN" LEVEL="ADVANCED">
              %%Keyword: Internal <advanced>
              <HELP>
              This marks the start of the definition of the internal
              coordinates.
              </HELP>
              This section is always ended by the keyword "End of Internal".
              Consult the manual for details.
              </KEYWORD>

:kword:`HWRS`
  Use the force constant weighted (FCW) redundant space version of the
  nonredundant internal coordinates. This is the default.
  The Hessian will be modeled by the Hessian Model Functional.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="HWRS" APPEAR="FWC internal coordinates" KIND="SINGLE" EXCLUSIVE="NOHWRS,CARTESIAN,INTERNAL" LEVEL="ADVANCED">
              %%Keyword: HWRS <basic>
              <HELP>
              Use the force constant weighted (FCW) redundant space version of the
              nonredundant internal coordinates.
              The Hessian will be modeled by the Hessian Model Functional.
              This is the default.
              </HELP>
              </KEYWORD>

:kword:`NOHWrs`
  Disable the use of the force constant weighted redundant space version of the
  nonredundant internal coordinates. The default is to use the HWRS option.
  The Hessian will be modeled by the Hessian Model Functional.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NOHWRS" APPEAR="Integral coordinates" KIND="SINGLE" EXCLUSIVE="HWRS,CARTESIAN,INTERNAL" LEVEL="ADVANCED">
              %%Keyword: NoHWRS <basic>
              <HELP>
              Disable the use of the force constant weighted redundant space version of the
              nonredundant internal coordinates. The default is to use the HWRS option.
              The Hessian will be modeled by the Hessian Model Functional.
              </HELP>
              </KEYWORD>

:kword:`FUZZ`
  When automatically generating the primitive internal coordinates, the system may
  end up in disconnected fragments, in which case additional bonds are defined
  between the fragments.
  This keyword controls how many inter-fragment bonds are added. Bonds are generated
  between the closest atoms of two fragments, and all pairs of atoms in separate
  fragments at a distance up to the specified value longer.
  The value can be followed with the unit BOHR or ANGSTROM. The default is 0.5 a.u.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="FUZZ" APPEAR="Fuzz" KIND="REAL" MIN_VALUE="0.001" DEFAULT_VALUE="0.5" LEVEL="ADVANCED">
              %%Keyword: Fuzz <advanced>
              <HELP>
              When automatically generating the primitive internal coordinates, the system may
              end up in disconnected fragments, in which case additional bonds are defined
              between the fragments.
              This keyword controls how many inter-fragment bonds are added. Bonds are generated
              between the closest atoms of two fragments, and all pairs of atoms in separate
              fragments at a distance up to the specified value longer.
              The value can be followed with the unit BOHR or ANGSTROM. The default is 0.5 a.u.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Optional Hessian update keywords

.. class:: keywordlist

:kword:`HUPDate`
  Method used for updating the Hessian matrix. It must be one of:

  * ``None`` --- No update is applied.

  * ``BFGS`` --- Activate update according to Broyden--Fletcher--Goldfarb--Shanno.
    This is the default.

  * ``MSP`` --- Activate the Murtagh--Sargent--Powell update according to Bofill :cite:`MSP`.
    This update is preferred for the location of transition states.

  * ``EU`` --- Activate the EU update according to Bofill :cite:`EU`.
    This update can be used for the location of transition states.

  * ``TS-BFGS`` --- Activate the TS-BFGS update according to Bofill :cite:`EU`.
    This update can be used for the location of minima or transition states.

  .. xmldoc:: <GROUP MODULE="SLAPAF" KIND="BOX" NAME="HU" APPEAR="Hessian update options" LEVEL="ADVANCED">

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="HUPDATE" APPEAR="Hessian update method" KIND="CHOICE" LIST="None,BFGS,MSP,EU,TS-BFGS" LEVEL="ADVANCED" DEFAULT_VALUE="BFGS">
              %%Keyword: HUpdate <advanced>
              <HELP>
              Method used for updating the Hessian matrix.
              </HELP>
              It must be one of: None, BFGS, MSP, EU, TS-BFGS.
              </KEYWORD>

:kword:`UORDer`
  Order the gradients and displacements vectors according to Schlegel prior to
  the update of the Hessian. Default is no reorder.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="UORDER" APPEAR="Ordered update" KIND="SINGLE" EXCLUSIVE="NOUPDATE" LEVEL="ADVANCED">
              %%Keyword: UORDer <basic>
              <HELP>
              Order the gradients and displacements vectors according to Schlegel prior to
              the update of the Hessian. Default is no reorder.
              </HELP>
              </KEYWORD>

:kword:`WINDow`
  Maximum number of previous iterations to include in the Hessian update.
  When using RVO (see :kword:`KRIGing` keyword), the maximum number of sample points used is twice this value.
  Default is 5.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="WINDOW" APPEAR="Update window" KIND="INT" EXCLUSIVE="NOUPDATE" DEFAULT_VALUE="5" LEVEL="ADVANCED">
              %%Keyword: WINDow <basic>
              <HELP>
              Maximum number of previous iterations to include in the Hessian update.
              </HELP>
              Default is 5.
              </KEYWORD>

  .. xmldoc:: </GROUP>

Optional optimization procedure keywords

.. class:: keywordlist

:kword:`NOLIne`
  Disable line search. Default is to use line search for minima.

  .. xmldoc:: <GROUP MODULE="SLAPAF" KIND="BOX" NAME="OP" APPEAR="Optimization options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NOLINE" APPEAR="Deactivate line-search" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Noline <basic>
              <HELP>
              Disable line search. Default is to use line search for minima.
              </HELP>
              </KEYWORD>

:kword:`RATIonal`
  Activate geometry optimization using the restricted step Rational Functional optimization :cite:`rf,rs-rf`,
  this is the default.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="RATIONAL" APPEAR="RFO option" KIND="SINGLE" EXCLUSIVE="C1-DIIS,C2-DIIS,NEWTON" LEVEL="BASIC">
              %%Keyword: Rational <basic>
              <HELP>
              Activate geometry optimization using the restricted step Rational Functional optimization,
              this is the default.
              </HELP>
              </KEYWORD>

:kword:`C1-Diis`
  Activate geometry optimization using the C1-GDIIS method :cite:`gdiis,diis1,diis2`.
  The default is to use the Rational Functional approach.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="C1-DIIS" APPEAR="C1-DIIS option" KIND="SINGLE" EXCLUSIVE="RATIONAL,C2-DIIS,NEWTON" LEVEL="BASIC">
              %%Keyword: C1-diis <advanced>
              <HELP>
              Activate geometry optimization using the C1-GDIIS method.
              The default is to use the Rational Functional approach.
              </HELP>
              </KEYWORD>

:kword:`C2-Diis`
  Activate geometry optimization using the C2-GDIIS method :cite:`c2-diis`.
  The default is to use the Rational Functional approach.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="C2-DIIS" APPEAR="C2-DIIS option" KIND="SINGLE" EXCLUSIVE="RATIONAL,C1-DIIS,NEWTON" LEVEL="BASIC">
              %%Keyword: C2-diis <basic>
              <HELP>
              Activate geometry optimization using the C2-GDIIS method.
              The default is to use the Rational Functional approach.
              </HELP>
              </KEYWORD>

:kword:`DXDX`
  This option is associated to the use of the C1- and C2-GDIIS
  procedures. This option will activate the computation of the
  so-called error matrix elements as :math:`e=\delta x^{\text{T}}\delta x`,
  where :math:`\delta x` is the displacement vector.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="DXDX" APPEAR="dxdx DIIS option" KIND="SINGLE" REQUIRE="C1-DIIS.OR.C2-DIIS" EXCLUSIVE="DXG,GDX,GG" LEVEL="ADVANCED">
              %%Keyword: dxdx <basic>
              <HELP>
              This option is associated to the use of the C1- and C2-GDIIS
              procedures. This option will activate the computation of the
              so-called error matrix elements as e=dx(T)dx,
              where dx is the displacement vector.
              </HELP>
              </KEYWORD>

:kword:`DXG`
  This option is associated to the use of the C1- and C2-GDIIS
  procedures. This option will activate the computation of the
  so-called error matrix elements as :math:`e=\delta x^{\text{T}}g`,
  where :math:`\delta x` is the displacement vector and :math:`g` is the
  gradient vector.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="DXG" APPEAR="dxg DIIS option" KIND="SINGLE" REQUIRE="C1-DIIS.OR.C2-DIIS" EXCLUSIVE="DXDX,GDX,GG" LEVEL="ADVANCED">
              %%Keyword: dxg <basic>
              <HELP>
              This option is associated to the use of the C1- and C2-GDIIS
              procedures. This option will activate the computation of the
              so-called error matrix elements as e=dx(T)g,
              where dx is the displacement vector and g is the
              gradient vector.
              </HELP>
              </KEYWORD>

:kword:`GDX`
  See above.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="GDX" APPEAR="gdx DIIS option" KIND="SINGLE" REQUIRE="C1-DIIS.OR.C2-DIIS" EXCLUSIVE="DXDX,DXG,GG" LEVEL="ADVANCED">
              %%Keyword: gdx <basic>
              <HELP>
              See the dxg keyword.
              </HELP>
              </KEYWORD>

:kword:`GG`
  This option is associated to the use of the C1- and C2-GDIIS
  procedures. This option will activate the computation of the
  so-called error matrix elements as :math:`e=g^{\text{T}}g`,
  where :math:`g` is the gradient vector. This is the default.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="GG" APPEAR="gg DIIS option" KIND="SINGLE" REQUIRE="C1-DIIS.OR.C2-DIIS" EXCLUSIVE="DXDX,DXG,GDX" LEVEL="ADVANCED">
              %%Keyword: gg <basic>
              <HELP>
              This option is associated to the use of the C1- and C2-GDIIS
              procedures. This option will activate the computation of the
              so-called error matrix elements as e=g(T)g,
              where g is the gradient vector. This is the default.
              </HELP>
              </KEYWORD>

:kword:`NEWTon`
  Activate geometry optimization using the standard quasi-Newton approach.
  The default is to use the Rational Functional approach.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NEWTON" APPEAR="Newton-Raphson optimization" KIND="SINGLE" EXCLUSIVE="RATIONAL,C1-DIIS,C2-DIIS" LEVEL="BASIC">
              %%Keyword: Newton <basic>
              <HELP>
              Activate geometry optimization using the standard quasi-Newton approach.
              The default is to use the Rational Functional approach.
              </HELP>
              </KEYWORD>

:kword:`RS-P-rfo`
  Activate RS-P-RFO :cite:`rs-rf` as default for TS-search. Default is RS-I-RFO.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="RS-P-RFO" APPEAR="RS-P-RFO option" KIND="SINGLE" REQUIRE="TS.OR.FINDTS" LEVEL="BASIC">
              %%Keyword: RS-P-RFO <basic>
              <HELP>
              Activate RS-P-RFO as default for TS-search. Default is RS-I-RFO.
              </HELP>
              </KEYWORD>

:kword:`TS`
  Keyword for optimization of transition states. This flag will activate
  the use of the mode following rational functional approach :cite:`mfrf`.
  The mode to follow can either be the one with the lowest eigenvalue (if positive
  it will be changed to a negative value) or by the eigenvector which index
  is specified by the :kword:`MODE` keyword (see below). The keyword will also
  activate the Murtagh--Sargent--Powell update of the Hessian and inactivate
  line search. This keyword will also enforce that the Hessian has the
  right index (i.e. one negative eigenvalue).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="TS" APPEAR="Brute force TS optimization" KIND="SINGLE" EXCLUSIVE="C1-DIIS,C2-DIIS,NEWTON,NOUPDATE,MEYER,BPUPDATE,BFGS" LEVEL="BASIC">
              %%Keyword: TS <basic>
              <HELP>
              Keyword for optimization of transition states. This flag will activate
              the use of the mode following rational functional approach.
              The mode to follow can either be the one with the lowest eigenvalue (if positive
              it will be changed to a negative value) or by the eigenvector which index
              is specified by the MODE keyword. The keyword will also
              activate the Murtagh-Sargent-Powell update of the Hessian and inactivate
              line search. This keyword will also enforce that the Hessian has the
              right index (i.e. one negative eigenvalue).
              </HELP>
              </KEYWORD>

:kword:`MODE`
  Specification of the Hessian eigenvector index, this mode will be followed
  by the mode following RF method for optimization of transition states.
  The keyword card is followed by a single card specifying the eigenvector index.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MODE" APPEAR="Mode specification" KIND="INT" REQUIRE="TS" LEVEL="BASIC">
              %%Keyword: Mode <advanced>
              <HELP>
              Specification of the Hessian eigenvector index, this mode will be followed
              by the mode following RF method for optimization of transition states.
              The keyword card is followed by a single card specifying the eigenvector index.
              </HELP>
              </KEYWORD>

:kword:`FINDTS`
  Enable a constrained optimization to release the constraints and locate
  a transition state if negative curvature is encountered and the
  gradient norm is below a specific threshold (see the :kword:`GNRM` option).
  Keyword :kword:`TSCOnstraints` should be used in combination with :kword:`FINDTS`.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="FINDTS" APPEAR="Find TS algorithm" KIND="SINGLE" EXCLUSIVE="TS" LEVEL="BASIC">
              %%Keyword: FindTS <basic>
              <HELP>
              Enable a constrained optimization to release the constraints and locate
              a transition state if negative curvature is encountered and the
              gradient norm is below a specific threshold (see the GNRM option).
              Keyword TSCOnstraints should be used in combination with FINDTS.
              </HELP>
              </KEYWORD>

:kword:`TSCOnstraints`
  Specify constraints that will be active during the initial stage of an
  optimization with :kword:`FINDTS`. When negative curvature and low
  gradient are encountered, these constraints will be released and
  other constraints will remain active. If this block is not given in
  the input, all constraints will be released. The syntax of this
  keyword is exactly like normal constraints, and it must be ended with
  :kword:`End of TSConstraints`
  (see :numref:`UG:sec:definition_of_internal_coordinates` below).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="TSCONSTRAINTS" APPEAR="TS constraints" KIND="CUSTOM" REQUIRE="FINDTS" LEVEL="BASIC">
              %%Keyword: TSConstraints <basic>
              <HELP>
              Specify constraints that will be active during the initial stage of an
              optimization with FINDTS. When a transition state region is reached
              these constraints will be released. If this keyword is not used,
              all constraints will be released.
              </HELP>
              </KEYWORD>

:kword:`GNRM`
  Modify the gradient norm threshold associated with the :kword:`FINDTS` option.
  The actual threshold is specified on the subsequent line. The default
  value is 0.2.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="GNRM" APPEAR="Gradient norm threshold" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="0.2" REQUIRE="FINDTS" LEVEL="ADVANCED">
              %%Keyword: GNRM <basic>
              <HELP>
              Modify the gradient norm threshold associated with the FINDTS option.
              The actual threshold is specified on the subsequent line. The default
              value is 0.2.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

:kword:`MEP-search` or :kword:`MEP`
  Enable a minimum energy path (MEP) search.

  .. xmldoc:: <GROUP MODULE="SLAPAF" KIND="BOX" NAME="ADVANCED" APPEAR="Advanced PES exploration options" LEVEL="BASIC">

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MEP-SEARCH" APPEAR="MEP-search" KIND="SINGLE" LEVEL="BASIC" ALSO="MEP">
              %%Keyword: MEP-search <basic>
              <HELP>
              Enable a minimum energy path (MEP) search.
              </HELP>
              MEP is a valid synonym.
              </KEYWORD>

  .. xmldoc:: %%Keyword: MEP <basic>
              Enable a minimum energy path (MEP) search.
              Synonym of MEP-search.

:kword:`rMEP-search` 
  Enable a reverse minimum energy path (MEP) search.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="RMEP-SEARCH" APPEAR="Reverse MEP-search" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: RMEP-search <basic>
              <HELP>
              Enable a reverse minimum energy path (MEP) search.
              </HELP>
              </KEYWORD>

:kword:`IRC`
  The keyword is used to perform an intrinsic reaction coordinate (IRC) analysis of a
  transition state structure. The analysis will follow the reaction path forward and
  backward until the energy increases. The keyword requires that the starting structure be
  that of a transition state and that the reaction vector be specified explicitly
  (check the keyword :kword:`REACtion vector`) or implicitly if it can be found on :file:`RUNOLD`.
  Note that the user should not specify any explicit constraints!

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="IRC" APPEAR="IRC analysis" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: IRC <basic>
              <HELP>
              The keyword is used to perform an intrinsic reaction coordinate (IRC) analysis of a
              transition state structure. The analysis will follow the reaction path forward and
              backward until the energy increase. The keyword require that the starting structure is
              that of a transition state and that the reaction vector is specified explicitly
              (check the keyword "REACtion vector") or implicitly can be found on RUNOLD.
              Note that the user should not specify any explicit constraints!
              </HELP>
              </KEYWORD>

:kword:`NMEP` or :kword:`NIRC`
  Maximum number of points to find in a minimum energy path search or intrinsic reaction coordinate analysis.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NMEP" APPEAR="Max points on a MEP" KIND="INT" MIN_VALUE="1" REQUIRE="MEP-SEARCH.OR.RMEP-SEARCH.OR.IRC" LEVEL="BASIC" ALSO="NIRC">
              %%Keyword: NMEP <basic>
              <HELP>
              Maximum number of points to find in a minimum energy path search or intrinsic reaction coordinate analysis.
              </HELP>
              NIRC is a valid synonym.
              </KEYWORD>

              %%Keyword: NIRC <basic>
              Maximum number of points to find in an intrinsic reaction coordinate analysis or minimum energy path search.
              Synonym of NMEP.

:kword:`MEPStep` or :kword:`IRCStep`
  The keyword is used to specify the step length done in the MEP search or IRC analysis.
  The step length can be followed with the unit BOHR or ANGSTROM. The default is 0.1 a.u.
  (in normalized mass-weighted coordinates).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MEPSTEP" APPEAR="MEP Step" KIND="STRING" REQUIRE="MEP-SEARCH.OR.RMEP-SEARCH.OR.IRC" LEVEL="BASIC" ALSO="IRCSTEP">
              %%Keyword: MEPStep <basic>
              <HELP>
              The keyword is used to specify the step length done in the MEP search or IRC analysis.
              The step length can be followed with the unit BOHR or ANGSTROM. The default is 0.1 a.u.
              (in normalized mass-weighted coordinates).
              </HELP>
              IRCStep is a valid synonym.
              </KEYWORD>

              %%Keyword: IRCStep <basic>
              The keyword is used to specify the step length done in the IRC analysis or MEP search.
              The step length can be followed with the unit BOHR or ANGSTROM. The default is 0.1 a.u.
              (in normalized mass-weighted coordinates).
              Synonym of MEPStep.

:kword:`MEPType`  or :kword:`IRCType`
  Specifies what kind of constraint will be used for optimizing the points during the MEP search or IRC analysis.
  The possibilities are SPHERE, the default, which uses the Sphere constraint (each structure is at a given distance in coordinate space from the reference),
  or PLANE which uses the Transverse constraint (each structure is at a given distance from the hyperplane defined by the reference and the path direction).
  The reference structure changes at each step, according to the :kword:`MEPAlgorithm` keyword.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MEPTYPE" APPEAR="MEP Type" KIND="STRING" REQUIRE="MEP-SEARCH.OR.RMEP-SEARCH.OR.IRC" LEVEL="ADVANCED" ALSO="IRCTYPE">
              %%Keyword: MEPType <advanced>
              <HELP>
              Specifies what kind of constraint will be used for optimizing the points during the MEP search or IRC analysis.
              The possibilities are SPHERE, the default, which uses the Sphere constraint (each structure is at a given distance in coordinate space from the reference),
              or PLANE which uses the Transverse constraint (each structure is at a given distance from the hyperplane defined by the reference and the path direction).
              The reference structure changes at each step, according to the MEPAlgorithm keyword.
              </HELP>
              IRCType is a valid synonym.
              </KEYWORD>

              %%Keyword: IRCType <advanced>
              Specifies what kind of constraint will be used for optimizing the points during the IRC analysis or MEP search.
              The possibilities are SPHERE, the default, which uses the Sphere constraint (each structure is at a given distance in coordinate space from the reference),
              or PLANE which uses the Transverse constraint (each structure is at a given distance from the hyperplane defined by the reference and the path direction).
              The reference structure changes at each step, according to the IRCAlgorithm keyword.
              Synonym of MEPType.

:kword:`MEPAlgorithm` or :kword:`IRCAlgorithm`
  Selects the algorithm for a MEP search or IRC analysis.
  The possibilities are GS for the González--Schlegel algorithm, the default, or MB for the Müller--Brown algorithm.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MEPALGORITHM" APPEAR="MEP Algorithm" KIND="STRING" REQUIRE="MEP-SEARCH.OR.RMEP-SEARCH.OR.IRC" LEVEL="ADVANCED" ALSO="IRCALGORITHM">
              %%Keyword: MEPAlgorithm <advanced>
              <HELP>
              Selects the algorithm for a MEP search or IRC analysis.
              The possibilities are GS for the Gonzalez-Schlegel algorithm, the default, or MB for the Mueller-Brown algorithm.
              </HELP>
              IRCAlgorithm is a valid synonym.
              </KEYWORD>

              %%Keyword: IRCAlgorithm <advanced>
              Selects the algorithm for a MEP search or IRC analysis.
              The possibilities are GS for the Gonzalez-Schlegel algorithm, the default, or MB for the Mueller-Brown algorithm.
              Synonym of MEPAlgorithm.

:kword:`MEPConvergence` or :kword:`IRCConvergence`
  Sets the gradient convergence for a MEP search or IRC analysis.
  The path will be terminated when the gradient norm at an optimized point is below this threshold.
  By default it is the same as the gradient threshold for the normal iterations, specified with :kword:`THRShld`,
  it may be necessary to reduce it to follow a path on a very flat surface.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MEPCONVERGENCE" APPEAR="MEP gradient convergence" KIND="REAL" REQUIRE="MEP-SEARCH.OR.RMEP-SEARCH.OR.IRC" LEVEL="ADVANCED" ALSO="IRCCONVERGENCE">
              %%Keyword: MEPConvergence <advanced>
              <HELP>
              Sets the gradient convergence for a MEP search or IRC analysis.
              The path will be terminated when the gradient norm at an optimized point is below this threshold.
              By default it is the same as the gradient threshold for the normal iterations, specified with THRShld,
              it may be necessary to reduce it to follow a path on a very flat surface.
              </HELP>
              IRCConvergence is a valid synonym.
              </KEYWORD>

              %%Keyword: IRCConvergence <advanced>
              Sets the gradient convergence for a MEP search or IRC analysis.
              The path will be terminated when the gradient norm at an optimized point is below this threshold.
              By default it is the same as the gradient threshold for the normal iterations, specified with THRShld,
              Synonym of MEPConvergence.

:kword:`REFErence`
  The keyword is followed by a list of the symmetry unique coordinates (in au)
  of the origin of the hyper sphere. The default origin is the structure
  of the first iteration.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="REFERENCE" APPEAR="MEP reference structure" KIND="REALS_LOOKUP" SIZE="DEG_FREEDOM" LEVEL="BASIC">
              %%Keyword: REFErence <basic>
              <HELP>
              The keyword is followed by a list of the symmetry unique coordinates (in au)
              of the origin of the hyper sphere. The default origin is the structure
              of the first iteration.
              </HELP>
              </KEYWORD>

:kword:`GRADient of reference`
  The keyword is followed by a list of the gradient vector components. This keyword is
  compulsory when using the Transverse kind of constraint. The optimization is performed in
  a space orthogonal to the given vector.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="GRAD" APPEAR="Gradient of reference" KIND="REALS_LOOKUP" SIZE="DEG_FREEDOM" LEVEL="BASIC">
              %%Keyword: GRADient of reference <basic>
              <HELP>
              The keyword is followed by a list of the gradient vector components. This keyword is
              compulsory when using the Transverse kind of constraint. The optimization is performed in
              a space orthogonal to the given vector.
              </HELP>
              </KEYWORD>

:kword:`REACtion vector`
  The keyword is followed by the reaction vector specified as the Cartesian vector components
  on each of the symmetry unique atoms.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="REAC" APPEAR="Reaction vector" KIND="REALS_LOOKUP" SIZE="DEG_FREEDOM" LEVEL="BASIC">
              %%Keyword: REACtion vector <basic>
              <HELP>
              The keyword is followed by the reaction vector specified as the Cartesian vector components
              on each of the symmetry unique atoms.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Optional force constant keywords

.. class:: keywordlist

:kword:`OLDForce`
  The Hessian matrix is read from the file :file:`RUNOLD`.
  This Hessian is either
  an analytic or approximative Hessian updated by Slapaf.
  Note that for this option to work properly the type of
  internal coordinates must be the same!

  .. xmldoc:: <GROUP MODULE="SLAPAF" KIND="BOX" NAME="FCO" APPEAR="Force constant options" LEVEL="ADVANCED">

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="OLDFORCE" APPEAR="External Hessian in internals" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Oldforce <advanced>
              <HELP>
              The Hessian matrix is read from the file RUNOLD.
              This Hessian is either
              an analytic or approximative Hessian updated by Slapaf.
              Note that for this option to work properly the type of
              internal coordinates must be the same!
              </HELP>
              </KEYWORD>

:kword:`FCONstant`
  Input of Hessian in internal coordinates.
  There are two different syntaxes.

  #. The keyword is followed by an entry with
     the number of elements which will be set (observe that the
     update will preserve that the elements :math:`H_{ij}` and :math:`H_{ji}` are
     equal). The next entries will contain the value and the indices of
     the elements to be replaced.
  #. The keyword if followed by the label :kword:`Square` or
     :kword:`Triangular`. The subsequent line specifies the rank of the
     Hessian. This is then followed by entries specifying the Hessian
     in square or lower triangular order.

  .. xmldoc:: %%Keyword: Fconstant <advanced>
              Input of Hessian in internal coordinates.
              Note this is
              There are two different syntaxes.

              1) The keyword is followed by an entry with
                 the number of elements which will be set (observe that the
                 update will preserve that the elements Hij and Hji are
                 equal). The next lines will contain the value and the indices of
                 the elements to be replaced.
              2) The keyword if followed by the label "Square" or
                 "Triangular". The subsequent entry specifies the rank of the
                 Hessian. This is then followed by entries specifying the Hessian
                 in square or lower triangular order.

:kword:`XFCOnstant`
  Input of an external Hessian matrix in cartesian coordinates. The
  syntax is the same as for the :kword:`FCONSTANT` keyword.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="XFCONSTANT" APPEAR="External Hessian in Cartesians" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: XFConstant <basic>
              <HELP>
              Input of an external Hessian matrix in cartesian coordinates. The
              syntax is the same as for the FCONSTANT keyword.
              </HELP>
              </KEYWORD>

:kword:`NUMErical`
  This invokes as calculation of the force constant matrix by a
  two-point finite difference formula. The resulting force
  constant matrix is used for an analysis of the harmonic
  frequencies. **Observe** that in case of the use of internal
  coordinates defined as Cartesian coordinates that these has to be
  linear combinations which are free from translational and
  rotational components for the harmonic frequency analysis to be
  valid. **Alternative:** see keyword :kword:`RowH` in the section
  about Internal coordinates.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NUMERICAL" APPEAR="Numerical Hessian" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Numerical <basic>
              <HELP>
              This invokes as calculation of the force constant matrix by a
              two-point finite difference formula. The resulting force
              constant matrix is used for an analysis of the harmonic
              frequencies. Observe that in case of the use of internal
              coordinates defined as Cartesian coordinates that these has to be
              linear combinations which are free from translational and
              rotational components for the harmonic frequency analysis to be
              valid.
              </HELP>
              </KEYWORD>

:kword:`CUBIc`
  This invokes a calculation of the 2nd and the 3rd order
  force constant matrix by finite difference formula.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="CUBIC" APPEAR="Numerical anharmonic force constants" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Cubic <basic>
              <HELP>
              This invokes a calculation of the 2nd and the 3rd order
              force constant matrix by finite difference formula.
              </HELP>
              </KEYWORD>

:kword:`DELTa`
  This keyword is followed by a real number which defines the
  step length used in the finite differentiation. Default: 1.0D-2.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="DELTA" APPEAR="Numerical displacement value" KIND="REAL" REQUIRE="NUMERICAL.OR.CUBIC" LEVEL="ADVANCED">
              %%Keyword: Delta <basic>
              <HELP>
              This keyword is followed by a real number which defines the
              step length used in the finite differentiation. Default: 1.0D-2.
              </HELP>
              </KEYWORD>

:kword:`PRFC`
  The eigenvalues and eigenvectors of the Hessian matrix
  are printed. The internal coordinates definitions are also printed.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="PRFC" APPEAR="Print eigen vectors and values of H" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: PrFC <basic>
              <HELP>
              The eigenvalues and eigenvectors of the Hessian matrix
              are printed. The internal coordinates definitions is also printed.
              </HELP>
              </KEYWORD>

:kword:`RHIDden`
  Define the hidden atoms selection radius in order to improve a QM/MM Hessian. It can be followed by :kword:`Angstrom`.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="RHID" APPEAR="Hidden atoms selection radius" KIND="REAL" LEVEL="ADVANCED">
              %%Keyword: rHid <advanced>
              <HELP>
              Define the hidden atoms selection radius in order to improve a QM/MM Hessian.
              </HELP>
              </KEYWORD>

  .. xmldoc:: </GROUP>

Optional miscellaneous keywords

.. class:: keywordlist

:kword:`CTOF`
  Coordinates TO Follow defines an internal coordinate whose values
  will be printed in the output during the optimization. Both
  the original and the new values will be printed.
  The keyword must be followed by the definition on the primitive
  coordinate.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="CTOF" KIND="STRINGS" SIZE="2" LEVEL="ADVANCED">
              %%Keyword: CTOF <advanced>
              <HELP>
              Coordinates TO Follow defines an internal coordinate whose values
              will be printed in the output during the optimization. Both
              the original and the new values will be printed.
              The keyword must be followed by the definition on the primitive
              coordinate.
              </HELP>
              </KEYWORD>

:kword:`RTRN`
  Maximum number of atoms for which bond lengths, angles and dihedral
  angles are listed, and
  the radius defining the maximum length of a bond follows.
  The latter is used as a threshold when printing out
  angles and dihedral angles. The length can be followed by
  :kword:`Bohr` or
  :kword:`Angstrom` which indicates the unit in which the length
  was specified, the default is
  :kword:`Bohr`.
  The default values are 15 and 3.0 au.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="RTRN" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: RTRN <advanced>
              <HELP>
              Maximum number of atoms for which bond lengths, angles and dihedral
              angles are listed, and
              the radius defining the maximum length of a bond follows on
              the next line. The latter is used as a threshold when printing out
              angles and dihedral angles. The length can be followed by
              "Bohr" or "Angstrom" which indicates the unit in which the length
              was specified, the default is "Bohr".
              </HELP>
              </KEYWORD>

:kword:`THERmochemistry`
  Request frequencies to be computed followed by an user specified thermochemical analysis.
  The keyword must be followed by different entries containing the Rotational Symmetry Number,
  the Pressure (in atm), and one entry per Temperature (in K)
  for which the thermochemistry will be calculated.
  The section is ended by the keyword :kword:`End of PT`.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="THERMO" APPEAR="Thermochemical analysis" KIND="CUSTOM" LEVEL="ADVANCED">
              %%Keyword: THER <advanced>
              <HELP>
              Request frequencies to be computed followed by an user specified thermochemical analysis.
              The keyword must be followed by different entries containing the Rotational Symmetry Number,
              the Pressure (in atm), and one entry per Temperature (in K)
              for which the thermochemistry will be calculated.
              The section is ended by the keyword "End of PT".
              </HELP>
              </KEYWORD>

:kword:`DISOtope`
  Calculates frequencies modified for double isotopic substitution.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="DISO" APPEAR="Double isotopic substitutions" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: DISOtope <advanced>
              <HELP>
              Calculates frequencies modified for double isotopic substitution.
              </HELP>
              </KEYWORD>

:kword:`TRACk`
  Tries to follow electronic states during an optimization, by computing state overlaps with :program:`RASSI`
  at each step. Root numbers selected with :kword:`RlxRoot` in :program:`RASSCF` or with the "EDiff" constraint
  are only fixed in the first iteration, then the best-matching states are chosen.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="TRACK" APPEAR="Track states" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: Track <basic>
              <HELP>
              Tries to follow electronic states during an optimization, by computing state overlaps with RASSI.
              </HELP>
              </KEYWORD>

:kword:`LASTenergy`
  Specifies the quantum chemical method requested for the Last_Energy module (e.g., SCF, CASSCF, CASPT2, etc.)
  The keyword must be followed by the name of the module. Moreover, the EMIL command COPY needs to be used
  in the global input to provide a file named LASTEN, containing the input for the specified module.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="LASTENERGY" APPEAR="Last Energy method" KIND="STRING" LEVEL="ADVANCED">
              %%Keyword: LAST <advanced>
              <HELP>
              Specifies the quantum chemical method requested for the Last_Energy module (e.g., SCF, CASSCF, CASPT2, etc.)
              The keyword must be followed by the name of the module. Moreover, the EMIL command COPY needs to be used
              in the global input to provide a file named LASTEN, containing the input for the specified module.
              </HELP>
              </KEYWORD>

:kword:`NOLAst energy`
  Disables the call to the :program:`Last_Energy` module when convergence is achieved.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NOLASTENERGY" APPEAR="No Last Energy" KIND="SINGLE" LEVEL="BASIC">
              %%Keyword: NoLastEnergy <basic>
              <HELP>
              Disables the call to the Last_Energy module when convergence is achieved.
              </HELP>
              </KEYWORD>

Optional restricted variance optimization (RVO) :cite:`Raggi2020,FdezGalvan2021` keywords

.. class:: keywordlist

:kword:`KRIGing`
  Activate RVO using gradient-enhanced Kriging (GEK) to describe the surrogate model.
  The maximum number of sample points (energies and gradients) is twice the value indicated by the :kword:`WINDow` keyword (i.e. 10 by default).

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="KRIGING" APPEAR="Restricted variance optimization" KIND="SINGLE" LEVEL="ADVANCED">
              %%Keyword: Kriging <advanced>
              <HELP>
              Activate restricted variance optimization (RVO) using gradient-enhanced Kriging to describe the surrogate model.
              </HELP>
              </KEYWORD>

:kword:`TFOFfset`
  Trend function or baseline offset for the GEK surrogate model.
  The surrogate model will tend to the maximum energy among the sample points plus this value (in au).
  The default value is 10.0 au.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="TFOFFSET" APPEAR="Trend function offset" KIND="REAL" DEFAULT_VALUE="10.0" REQUIRE="KRIGING" LEVEL="ADVANCED">
              %%Keyword: TFOFfset <advanced>
              <HELP>
              Trend function or baseline offset for the GEK surrogate model.
              The surrogate model will tend to the maximum energy among the sample points plus this value.
              </HELP>
              Default: 10.0 au.
              </KEYWORD>

:kword:`MAXDisp`
  Maximum energy dispersion allowed during each macro iteration of the RVO procedure.
  A real value is read from the input, the maximum dispersion is this value times the maximum Cartesian gradient.
  The default value is 0.3 au.
  During the constrained phase of an optimization with :kword:`FindTS`, the default is 0.1 au.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MAXDISP" APPEAR="Maximum dispersion factor" KIND="REAL" MIN_VALUE="0.0" DEFAULT_VALUE="0.3" REQUIRE="KRIGING" LEVEL="ADVANCED">
              %%Keyword: MAXDISP <advanced>
              <HELP>
              Maximum energy dispersion allowed during each macro iteration of the RVO procedure.
              A factor, multiplied by the maximum Cartesian Gradient.
              </HELP>
              Default: 0.3 au.
              </KEYWORD>

:kword:`MXMI`
  Maximum number of micro iterations in each macro iteration of the RVO procedure.
  The default value is 50.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="MXMI" APPEAR="Micro iterations" KIND="INT" MIN_VALUE="1" DEFAULT_VALUE="50" REQUIRE="KRIGING" LEVEL="ADVANCED">
              %%Keyword: MXMI <advanced>
              <HELP>
              Maximum number of micro iterations in each macro iteration of the RVO procedure.
              </HELP>
              Default: 50.
              </KEYWORD>

:kword:`NDELta`
  Activate partial gradient enhanced Kriging, PGEK. This integer number determines for how many fewer iterations the gradients will
  be included in the PGEK procedure.
  The default value is 0, that is standard GEK.

  .. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NDELTA" APPEAR="Samples without gradient" KIND="INT" MIN_VALUE="0" DEFAULT_VALUE="0" REQUIRE="KRIGING" LEVEL="ADVANCED">
              %%Keyword: NDELta <advanced>
              <HELP>
              Activate partial gradient enhanced Kriging, PGEK. This integer number determines for how many fewer iterations the gradients will
              be included in the PGEK procedure.
              </HELP>
              Default: 0.
              </KEYWORD>

Example: A complete set of input decks for a CASSCF geometry
optimization. These are the input decks for the optimization
of the enediyne molecule.

.. extractfile:: ug/SLAPAF.input

  &GATEWAY
  Title= Enediyne
  Coord= $MOLCAS/Coord/enediyne.xyz
  Basis= ANO-L-VQZP
  Group= x z

  > DoWhile

  &SEWARD

  &SCF
  ITERATIONS= 30; Occupied= 9 8 2 1; Thresholds= 1.0d-8 1.0d-3 1.5d-3 0.2d-3; IVO

  &RASSCF
  Symmetry= 1; Spin= 1
  NactEl= 12 0 0; Inactive= 7 7 0 0; Ras2= 3 3 3 3
  Iterations= 50 50; CiRoot= 1 1; 1; Thrs= 1.0e-08 1.0e-05 1.0e-05
  Lumorb

  &SLAPAF; Iterations= 20

  > EndDo

Example: Thermochemistry for an asymmetric top (Rotational Symmetry Number
= 1), at 1.0 atm and 273.15, 298.15, 398.15 and 498.15 K. ::

  &SLAPAF; THERmochemistry= 1; 1.0; 273.15; 298.15; 398.15; 498.15; End of PT
  End of input

.. _UG\:sec\:definition_of_internal_coordinates:

Definition of internal coordinates or constraints
.................................................

The input section defining the internal coordinates always start with the
keyword :kword:`Internal coordinates` and the definition of the constraints
starts with the keyword :kword:`Constraints`. Note that the latter
is an input section for the :program:`GATEWAY` module.

The input is always sectioned into two
parts where the first section defines a set of primitive internal
coordinates
and the second part defines the actual internal coordinates as
any arbitrary linear combination of the primitive internal coordinates
that was defined in the first section.
In case of constraints the second part does also assign values to the
constraints.

In the first section we will refer to the atoms by their atom label
(:program:`SEWARD` will make sure that there is no redundancy). In case of
symmetry one will have to augment the atom label with a symmetry operation
in parenthesis in order to specify a symmetry related center.
Note that the user only
have to specify distinct internal coordinates (:program:`ALASKA` will make the
symmetry adaptation).

In the specification below *rLabel* is a user defined label with no more
than 8 (eight) characters. The specifications atom1, atom2, atom3, and atom4
are the unique atom labels as specified in the input to :program:`SEWARD`.

**The primitive internal coordinates** are defined as

.. class:: primlist

*rLabel* = Bond atom1 atom2
  a primitive internal coordinate *rLabel* is defined as the bond
  between center atom1 and atom2.

*rLabel* = Angle atom1 atom2 atom3
  a primitive internal coordinate *rLabel* is defined as the angle
  between the bonds formed from connecting atom1 to atom2 and
  connecting atom2 to atom3.

*rLabel* = LAngle(1) atom1 atom2 atom3
  a primitive internal coordinate *rLabel* is defined as the linear angle
  between the bonds formed from connecting atom1 to atom2 and
  connecting atom2 to atom3. To define the direction of the angle the following
  procedure is followed.

  #. --- *the three centers are linear*,

    #. form a reference axis, :math:`R_1`, connecting atom1 and atom3,
    #. compute the number of zero elements, *nR*, in the reference vector,

      #. --- *nR=0*,
         a first perpendicular direction to the reference axis is formed by

         .. compound::

           .. math:: R=(R_{1x},R_{1y},-R_{1z})

           followed by the projection

           .. math:: R_2=R-\frac{R \cdot R_1}{R_1 \cdot R_1} R_1.

         The second perpendicular direction completes the right-handed system.
      #. --- *nR=1*,
         a first perpendicular direction to the reference axis is defined by setting the element in :math:`R_2`
         corresponding to the zero entry in :math:`R_1` to unity.
         The second perpendicular direction completes the right-handed system.
      #. --- *nR=2*,
         a first perpendicular direction to the reference axis is defined by setting the element
         corresponding to the first zero entry in :math:`R_1` to unity.
         The second perpendicular direction completes the right-handed system.

  #. --- *the three centers are nonlinear*,
     the first perpendicular direction is the one which is in the plane formed by atoms atom1, atom2, and atom3.
     The second perpendicular direction is taken as the direction perpendicular to the same plane.

  The direction of the bend for **LAngle(1)** is taken in the direction of the first perpendicular direction, etc.

*rLabel* = LAngle(2) atom1 atom2 atom3
  a primitive internal coordinate *rLabel* is defined as the linear angle
  between the bonds formed from connecting atom1 to atom2 and
  connecting atom2 to atom3. The definition of the perpendicular directions
  is as described above. The direction of the bend for **LAngle(2)** is taken in the direction of
  the second perpendicular direction.

*rLabel* = Dihedral atom1 atom2 atom3 atom4
  a primitive internal coordinate *rLabel* is defined as the angle
  between the planes formed of atom1, atom2 and atom3, and atom2,
  atom3 and atom4, respectively.

*rLabel* = OutOfP atom1 atom2 atom3 atom4
  a primitive internal coordinate *rLabel* is defined as the angle
  between the plane formed by atom2, atom3, and atom4 and the
  bond formed by connecting atom1 and atom4.

*rLabel* = Dissoc (n1+n2) atom1 atom2 atom3 ... atomN
  a primitive internal coordinate *rLabel* is defined as the distance
  between the center of masses of two sets of centers. The first
  center has n1 members and the second has n2.
  The input contains the labels of the atoms of the first group followed
  immediately by the labels of the second group.
  This option is not available for constraints.

*rLabel* = Cartesian i atom1
  a primitive internal coordinate *rLabel* is defined as the pure
  Cartesian displacement of the center labeled atom1. The label
  i is selected to x, y, or z to give the appropriate component.

*rLabel* = Ediff [i j]
  the energy difference between states i and j (if provided, the brackets indicate they
  are optional, do not include the brackets).
  If i and j are not provided, the difference is between the "current" state and
  the state provided on :file:`RUNFILE2`.
  This is only used in constrained optimization in which crossings or conical intersections
  are located. If this constraint is used, the average energy of the two states will
  be optimized, subject to the constraint. If the value is 0.0 and the spin and spatial
  symmetry of both states is the same, a conical intersection will be searched.
  In this case, :program:`SLAPAF` will request an analytical calculation of the nonadiabatic
  coupling vector, if available. If it is not available, or if :file:`RUNFILE2` is being used
  (i and j not provided), the branching space update method of Maeda et al. will be used :cite:`Maeda2010`.

*rLabel* = Sphere
  the radius of the hypersphere defined by two different molecular structures
  (the origin is the first structure) in relative mass-weighted coordinates.
  This is only used in constrained optimization in which minimum reaction paths (MEP) or intrinsic reaction
  coordinate (IRC) paths are followed. The units of the radius is in mass-weighted coordinates
  divided with the square root of the total mass of the molecule.

*rLabel* = Transverse
  a level of "orthogonality". This is used to perform an optimization in a space
  orthogonal to a given vector. Recommended value 0.0. Requires usage of GRAD keyword.

*rLabel* = Fragment atom1 atom2 atom3 ... atomN
  a dummy internal coordinate *rLabel* is defined. This translates to
  that a set of internal coordinates are generated automatically according
  to a standard Z-matrix format to define all degrees of freedom
  of the fragment defined by the list of atoms on the same line. These
  internal coordinates will be automatically fixed in the geometry optimizations to
  the values of starting structure. Note, the values of these do not need to
  be explicitly defined and set in the :kword:`Values` section. Note, too, that
  the generation of the internal coordinates is done according to the order
  in which atom1, atom2, etc. are given; for some systems, especially with
  linear angles, it may be preferable to define the coordinates manually.

The second section starts with the label :kword:`Vary` or in the case of constraints
with the label :kword:`Values`.

.. compound::

  In case of a definition of **internal coordinates** in this section the user
  specifies all symmetric internal coordinates excluding translation and rotation
  using a list of expressions like

    *label* = f1 *rLabel1* + f2 *rLabel2* + ...

  which defines an internal coordinate *label* as the linear combination of the
  primitive internal coordinates *rLabel1*, *rLabel2*, ... with the coefficients
  f1, f2, ..., respectively. If the internal coordinate just corresponds to
  the primitive internal coordinate, the same label can be used

    *label*

If some internal coordinates are chosen to be fixed they should be defined after
the label :kword:`Fix`. The fixed internal coordinate are defined with
expressions as in the section :kword:`Vary`. Observe: using expression can
introduce linear dependence and/or undefined nuclear coordinates, so use with care.

For the internal coordinates defined after :kword:`Vary` (and :kword:`Fix`, if present)
a numerical estimation of rows and columns of the Hessian matrix can be performed. The
*label* of internal coordinates (max 10) must be specified after keyword :kword:`RowH`.
Keywords :kword:`NUMErical` and :kword:`RowH` are mutually exclusive.

.. compound::

  In case of a definition of **constraints** the sections contains either a
  direct reference to a *rLabel* as in

    *rLabel* = *rValue* [Angstrom,Degrees] [Soft,Hard] [Phantom]

  or one can also use expressions like

    f1 *rLabel1* |+-| f2 *rLabel2* |+-| ... = *Value* [Angstrom,Degrees] [Soft,Hard] [Phantom]

  where *rValue* is the desired value of the constraint in au or rad, or in
  angstrom or degrees if the corresponding keyword is added. The "Hard" and "Soft"
  keywords are only meaningful for numerical differentiation: the coordinates corresponding
  to soft constraints are differentiated, those of hard constraints are not :cite:`Stenrup2015`.
  By default almost all constraints are hard, only constraints of the type "Sphere", "Transverse"
  and "Ediff" default to soft. The "Hard" and "Soft" keywords override the default.
  When using constraints in combination with the :kword:`FINDTS` keyword, one should use
  soft constraints, at least for the constraint most similar to the expected reaction vector.
  Constraints defined in :kword:`TSCOnstraints` (recommended) are automatically considered
  soft.

The "Phantom" modifier can be used to ignore a constraint in the optimization. A phantom
constraint will only be considered for numerical differentiation. Phantom constraints are
useful in combination with the :kword:`KEEPOldGradient` keyword of :program:`ALASKA`.
Using :kword:`NGEXclude` in :program:`GATEWAY` is equivalent to phantom constraints,
and it is the preferred way to set up composite gradients :cite:`Stenrup2015`.

Alternatively, if the current value of an internal coordinate is to be used, i.e.
no change is to be allowed (frozen), this is expressed as

  *rLabel* = Fix [Soft,Hard] [Phantom]

Note that a coordinate of type "Fragment" does not need to appear in the :kword:`Values`
section, but if it does it must be assigned the value "Fix".

Example: A definition of user specified internal coordinates of benzene. The molecule is
in :math:`D_{6h}` and since |molcas| only uses up to :math:`D_{2h}` the
:kword:`Fix` option is used to
constrain the relaxation to the higher point group. **Observe** that this will
only restrict the nuclear coordinates to :math:`D_{6h}`. The electronic wavefunction,
however, can have lower symmetry. ::

  Internal coordinates
  r1 = Bond C1 C2
  r2 = Bond C1 H1
  r3 = Bond C2 H2
  r4 = Bond C2 C2(x)
  f1 = Angle H1 C1 C2
  f2 = Angle H2 C2 C1
  Vary
  a = 1.0 r1 +  1.0 r4
  b = 1.0 r2 +  1.0 r3
  c = 1.0 f1 +  1.0 f2
  Fix
  a = 1.0 r1 + -1.0 r4
  b = 1.0 r2 + -1.0 r3
  c = 1.0 f1 + -1.0 f2
  End of Internal

Example: A input for the optimization of water constraining the structure to be linear
at convergence.

.. extractfile:: ug/SLAPAF.constrains.input

  &GATEWAY
    Title= H2O geom optim, using the ANO-S basis set.
    Coord=$MOLCAS/Coord/Water.xyz
    Basis=ANO-S-VDZ
    Group= c1
    Constraints
        a1 = langle(1) H2 O1 H3
    Values
        a1 = 179.99 degrees
    End of Constraints
  >>> DO WHILE <<<
  &SEWARD; &SCF
  &SLAPAF
  >>> END DO <<<

Example: A complete set of input decks for a UHF transition
structure geometry optimization of an identity hydrogen
transfer reaction (:math:`\ce{HO + H_2O -> H_2O + OH}`).

.. extractfile:: ug/SLAPAF.Zmat.input

  &GATEWAY
  ZMAT
  O.STO-3G....
  H.STO-3G....

  H1
  Z2    1  1.0
  O3    1  1.15    2   92.
  O4    1  1.15    2   92.     3  180.
  H5    3  0.98    4  105.4    2  120.
  H6    4  0.98    3  105.4    2  120.

  >>> DO WHILE <<<
  &SEWARD;
  &SCF; UHF
  &SLAPAF; TS; PRFC
    Internal
      bOO4  = Bond O3 O4
      bOH5  = Bond H5 O3
      bOH6  = Bond H6 O4
      bOH1  = Bond O3 H1
      aOOH5 = Angle O4 O3 H5
      aOOH6 = Angle O3 O4 H6
      aHOH1 = Angle H5 O3 H1
      dH6  = Dihedral H6 O4 O3 H5
      dH1  = Dihedral O4 H5 O3 H1
    Vary; bOO4; bOH5; bOH6; bOH1; aOOH5; aOOH6; aHOH1; dH6; dH1
    RowH; bOH1
    End of Internal

  >>> ENDDO <<<

Example: Optimization of a minimum energy conical intersection point,
using automatic calculation of analytical gradients and nonadiabatic coupling.

.. extractfile:: ug/SLAPAF.CI.input

  &GATEWAY
    Coord = acrolein.xyz
    Basis = cc-pVDZ
    Group = NoSymm
    Constraints
      a = Ediff 1 2
    Values
      a = 0.0
    End of constraints

  >>> DoWhile

    &SEWARD

    >>> If (iter = 1)
      &SCF
      &MBPT2
        PrPt
    >>> EndIf

    &RASSCF
      FileOrb = $Project.MP2Orb
      Charge = 0
      NActEl = 6 0 0
      RAS2 = 5
      CIRoot = 4 4 1

    &SLAPAF

  >>> EndDo

.. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="REDUNDANT" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: <KEYWORD MODULE="SLAPAF" NAME="NOEMEP" KIND="SINGLE" LEVEL="UNDOCUMENTED" />

.. xmldoc:: </MODULE>

.. xmldoc:: <MODULE NAME="LAST_ENERGY">
            </MODULE>
